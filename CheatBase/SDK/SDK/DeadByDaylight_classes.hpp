#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DeadByDaylight

#include "Basic.hpp"

#include "GameplayTagUtilities_structs.hpp"
#include "DeadByDaylight_structs.hpp"
#include "DBDSharedTypes_structs.hpp"
#include "DBDSharedTypes_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "NetworkUtilities_structs.hpp"
#include "Competence_structs.hpp"
#include "Competence_classes.hpp"
#include "PhysicsCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Activation_structs.hpp"
#include "VFXUtilities_classes.hpp"
#include "AnimationUtilities_structs.hpp"
#include "AnimationUtilities_classes.hpp"
#include "PlatformsProviders_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "StatSystem_structs.hpp"
#include "Projectile_classes.hpp"
#include "DataTableUtilities_structs.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "DBDUIViewInterfaces_structs.hpp"
#include "SlateCore_structs.hpp"
#include "DBDUIViewsMobile_classes.hpp"
#include "ReversibleActionSystem_classes.hpp"
#include "AkAudio_structs.hpp"
#include "AkAudio_classes.hpp"
#include "GameplayUtilities_classes.hpp"
#include "ChatHistory_structs.hpp"
#include "UMG_classes.hpp"
#include "DeveloperSettings_classes.hpp"
#include "SystemUtilities_classes.hpp"
#include "DBDAnimationBudgetAllocator_classes.hpp"
#include "NavigationSystem_classes.hpp"
#include "OnlineSubsystemUtils_classes.hpp"
#include "GFXUtilities_classes.hpp"
#include "SocialParty_classes.hpp"
#include "Customization_structs.hpp"
#include "OnlinePresence_structs.hpp"
#include "SignificanceUtilities_classes.hpp"
#include "Slate_structs.hpp"
#include "DBDAudio_classes.hpp"
#include "Niagara_structs.hpp"


namespace SDK
{

// Class DeadByDaylight.OutlineUpdateStrategy
// 0x0028 (0x00E0 - 0x00B8)
class UOutlineUpdateStrategy : public UActorComponent
{
public:
	TArray<struct FGameplayTag>                   _requiredPlayerStateTags;                          // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTag>                   _preventativePlayerStateTags;                      // 0x00C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UDBDOutlineComponent*                   _outlineComponent;                                 // 0x00D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutlineUpdateStrategy">();
	}
	static class UOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UOutlineUpdateStrategy");
static_assert(sizeof(UOutlineUpdateStrategy) == 0x0000E0, "Wrong size on UOutlineUpdateStrategy");
static_assert(offsetof(UOutlineUpdateStrategy, _requiredPlayerStateTags) == 0x0000B8, "Member 'UOutlineUpdateStrategy::_requiredPlayerStateTags' has a wrong offset!");
static_assert(offsetof(UOutlineUpdateStrategy, _preventativePlayerStateTags) == 0x0000C8, "Member 'UOutlineUpdateStrategy::_preventativePlayerStateTags' has a wrong offset!");
static_assert(offsetof(UOutlineUpdateStrategy, _outlineComponent) == 0x0000D8, "Member 'UOutlineUpdateStrategy::_outlineComponent' has a wrong offset!");

// Class DeadByDaylight.SourceBasedOutlineUpdateStrategy
// 0x0080 (0x0160 - 0x00E0)
class USourceBasedOutlineUpdateStrategy : public UOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _defaultColorForSurvivor;                          // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _defaultColorForSlasher;                           // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_100[0x60];                                     // 0x0100(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SourceBasedOutlineUpdateStrategy">();
	}
	static class USourceBasedOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USourceBasedOutlineUpdateStrategy>();
	}
};
static_assert(alignof(USourceBasedOutlineUpdateStrategy) == 0x000008, "Wrong alignment on USourceBasedOutlineUpdateStrategy");
static_assert(sizeof(USourceBasedOutlineUpdateStrategy) == 0x000160, "Wrong size on USourceBasedOutlineUpdateStrategy");
static_assert(offsetof(USourceBasedOutlineUpdateStrategy, _defaultColorForSurvivor) == 0x0000E0, "Member 'USourceBasedOutlineUpdateStrategy::_defaultColorForSurvivor' has a wrong offset!");
static_assert(offsetof(USourceBasedOutlineUpdateStrategy, _defaultColorForSlasher) == 0x0000F0, "Member 'USourceBasedOutlineUpdateStrategy::_defaultColorForSlasher' has a wrong offset!");

// Class DeadByDaylight.SeanceRitualOutlineUpdateStrategy
// 0x0000 (0x0160 - 0x0160)
class USeanceRitualOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	struct FLinearColor GetRevealColorToSurvivor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeanceRitualOutlineUpdateStrategy">();
	}
	static class USeanceRitualOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeanceRitualOutlineUpdateStrategy>();
	}
};
static_assert(alignof(USeanceRitualOutlineUpdateStrategy) == 0x000008, "Wrong alignment on USeanceRitualOutlineUpdateStrategy");
static_assert(sizeof(USeanceRitualOutlineUpdateStrategy) == 0x000160, "Wrong size on USeanceRitualOutlineUpdateStrategy");

// Class DeadByDaylight.AICharacterBehaviour
// 0x0028 (0x0058 - 0x0030)
class UAICharacterBehaviour : public UObject
{
public:
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Pause();
	void Resume();
	void SetEnable(bool Enable);
	void Start();
	void Stop();
	void Update(float DeltaTime);

	bool IsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterBehaviour">();
	}
	static class UAICharacterBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterBehaviour>();
	}
};
static_assert(alignof(UAICharacterBehaviour) == 0x000008, "Wrong alignment on UAICharacterBehaviour");
static_assert(sizeof(UAICharacterBehaviour) == 0x000058, "Wrong size on UAICharacterBehaviour");

// Class DeadByDaylight.AIMoveToPosition
// 0x0018 (0x0070 - 0x0058)
class UAIMoveToPosition final : public UAICharacterBehaviour
{
public:
	class UAIMoveToPositionData*                  _aiBehaviourData;                                  // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDAIPlayerController*                 _aiController;                                     // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class ADBDPlayer* Character, class UAICharacterBehaviourData* behaviourData);
	void TargetPositionReached(const struct FAIRequestID& RequestID, EPathFollowingResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIMoveToPosition">();
	}
	static class UAIMoveToPosition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIMoveToPosition>();
	}
};
static_assert(alignof(UAIMoveToPosition) == 0x000008, "Wrong alignment on UAIMoveToPosition");
static_assert(sizeof(UAIMoveToPosition) == 0x000070, "Wrong size on UAIMoveToPosition");
static_assert(offsetof(UAIMoveToPosition, _aiBehaviourData) == 0x000058, "Member 'UAIMoveToPosition::_aiBehaviourData' has a wrong offset!");
static_assert(offsetof(UAIMoveToPosition, _aiController) == 0x000060, "Member 'UAIMoveToPosition::_aiController' has a wrong offset!");

// Class DeadByDaylight.GameplayModifierContainer
// 0x0168 (0x0260 - 0x00F8)
class UGameplayModifierContainer : public UBaseModifierContainer
{
public:
	uint8                                         Pad_F8[0x90];                                      // 0x00F8(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	struct FModifierTickableConditionReplicatedData _tickableConditionsData;                         // 0x0188(0x0018)(Net, Transient, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FOperationConditionsReplicatedData     _operationConditionsData;                          // 0x01A0(0x0018)(Net, Transient, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           _tags;                                             // 0x01B8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          UseApplyFunction;                                  // 0x01C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BroadcastStatusViewWhenApplicable;                 // 0x01C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BroadcastStatusViewOnInitialized;                  // 0x01CA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EStatusViewDataUpdateType                     StatusViewDataUpdateType;                          // 0x01CB(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   StatusViewID;                                      // 0x01CC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _autoInitializeOnBeginPlay;                        // 0x01D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _canOptimizeTickActivation;                        // 0x01D9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAlwaysApplicable;                               // 0x01DA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DB[0x5D];                                     // 0x01DB(0x005D)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimerObject*                           _activationTimer;                                  // 0x0238(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_240[0x8];                                      // 0x0240(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCompetenceOperation*>           _competenceOperations;                             // 0x0248(0x0010)(Edit, ExportObject, Net, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_258[0x8];                                      // 0x0258(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Apply(float DeltaTime);
	void Authority_ClearActivationTimer();
	void Authority_InstantiateGameplayModifierConditions();
	void Authority_SetActivationTimerPaused(const bool paused);
	void Authority_TriggerActivationTimer(float activationTime);
	void ListenToDispatcherGameEvent(const struct FGameplayTag& EventType);
	void OnApplyBegin();
	void OnApplyEnd();
	void OnGameEventDispatched(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData);
	void OnInitialized();
	void OnInitialized_Internal();
	void OnLevelReadyToPlay();
	void OnRep_ActivationTimer();
	void OnRep_ModifierData();
	void OnRep_OperationConditionsData(const struct FOperationConditionsReplicatedData& oldOperationConditionsData);
	void OnRep_TickableConditionsData(const struct FModifierTickableConditionReplicatedData& oldTickableConditionsData);
	void RemoveAllFlags();
	void RemoveAllModifiers();
	void RemoveModifier(const struct FGameplayTag& Type);
	void SetFlag(const struct FGameplayTag& Flag, bool flagValue);
	void SetModifierValue(const struct FGameplayTag& Type, float GameplayModifierValue);
	void UnlistenToAllDispatcherGameEvents();
	void UnlistenToDispatcherGameEvent(const struct FGameplayTag& EventType);
	void UpdateIsApplicable();

	float GetActivationTimerDuration() const;
	float GetActivationTimerElapsedTime() const;
	float GetActivationTimerElapsedTimePercent() const;
	float GetActivationTimerPercentRemaining() const;
	float GetActivationTimerRemainingTime() const;
	float GetModifierValue(const struct FGameplayTag& Type) const;
	class UGameplayModifierContainer* GetOriginatingEffect() const;
	class ADBDPlayer* GetOwningPlayer() const;
	float GetPercentageFill() const;
	float GetRemainingLifetime() const;
	bool HasFlag(const struct FGameplayTag& Flag) const;
	bool HasModifierOfType(const struct FGameplayTag& Type) const;
	bool IsActivationTimerActive() const;
	bool IsActivationTimerDone() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayModifierContainer">();
	}
	static class UGameplayModifierContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayModifierContainer>();
	}
};
static_assert(alignof(UGameplayModifierContainer) == 0x000008, "Wrong alignment on UGameplayModifierContainer");
static_assert(sizeof(UGameplayModifierContainer) == 0x000260, "Wrong size on UGameplayModifierContainer");
static_assert(offsetof(UGameplayModifierContainer, _tickableConditionsData) == 0x000188, "Member 'UGameplayModifierContainer::_tickableConditionsData' has a wrong offset!");
static_assert(offsetof(UGameplayModifierContainer, _operationConditionsData) == 0x0001A0, "Member 'UGameplayModifierContainer::_operationConditionsData' has a wrong offset!");
static_assert(offsetof(UGameplayModifierContainer, _tags) == 0x0001B8, "Member 'UGameplayModifierContainer::_tags' has a wrong offset!");
static_assert(offsetof(UGameplayModifierContainer, UseApplyFunction) == 0x0001C8, "Member 'UGameplayModifierContainer::UseApplyFunction' has a wrong offset!");
static_assert(offsetof(UGameplayModifierContainer, BroadcastStatusViewWhenApplicable) == 0x0001C9, "Member 'UGameplayModifierContainer::BroadcastStatusViewWhenApplicable' has a wrong offset!");
static_assert(offsetof(UGameplayModifierContainer, BroadcastStatusViewOnInitialized) == 0x0001CA, "Member 'UGameplayModifierContainer::BroadcastStatusViewOnInitialized' has a wrong offset!");
static_assert(offsetof(UGameplayModifierContainer, StatusViewDataUpdateType) == 0x0001CB, "Member 'UGameplayModifierContainer::StatusViewDataUpdateType' has a wrong offset!");
static_assert(offsetof(UGameplayModifierContainer, StatusViewID) == 0x0001CC, "Member 'UGameplayModifierContainer::StatusViewID' has a wrong offset!");
static_assert(offsetof(UGameplayModifierContainer, _autoInitializeOnBeginPlay) == 0x0001D8, "Member 'UGameplayModifierContainer::_autoInitializeOnBeginPlay' has a wrong offset!");
static_assert(offsetof(UGameplayModifierContainer, _canOptimizeTickActivation) == 0x0001D9, "Member 'UGameplayModifierContainer::_canOptimizeTickActivation' has a wrong offset!");
static_assert(offsetof(UGameplayModifierContainer, _isAlwaysApplicable) == 0x0001DA, "Member 'UGameplayModifierContainer::_isAlwaysApplicable' has a wrong offset!");
static_assert(offsetof(UGameplayModifierContainer, _activationTimer) == 0x000238, "Member 'UGameplayModifierContainer::_activationTimer' has a wrong offset!");
static_assert(offsetof(UGameplayModifierContainer, _competenceOperations) == 0x000248, "Member 'UGameplayModifierContainer::_competenceOperations' has a wrong offset!");

// Class DeadByDaylight.StatusEffect
// 0x0138 (0x0398 - 0x0260)
class UStatusEffect : public UGameplayModifierContainer
{
public:
	uint8                                         Pad_260[0x48];                                     // 0x0260(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayModifierData                  ModifierData;                                      // 0x02A8(0x0030)(Edit, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	bool                                          ShouldDisplay;                                     // 0x02D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D9[0x3];                                      // 0x02D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CustomParam;                                       // 0x02DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _removeOnRemainingLifetimeEnded;                   // 0x02E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BroadcastAsStatusEffectWhenApplicable;             // 0x02E1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BroadcastAsStatusEffectByActivationTimer;          // 0x02E2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BroadcastAsStatusEffectWhenLifeRemains;            // 0x02E3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BroadcastAsStatusEffectByFunction;                 // 0x02E4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BroadcastAsStatusEffectAlways;                     // 0x02E5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BroadcastAsStatusEffectManual;                     // 0x02E6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BroadcastOriginatorGameEventNotificationWhenFirstApplicable; // 0x02E7(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShouldHideStatusEffectIconForOriginatingPlayer;    // 0x02E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShouldHideStatusEffectIconByFunction;              // 0x02E9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _forceActivationTimerDisplay;                      // 0x02EA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EB[0x5];                                      // 0x02EB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStatusEffectInitializationData        _statusInitializationData;                         // 0x02F0(0x0028)(Net, Transient, RepNotify, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          _shouldBroadcastAsStatusEffect;                    // 0x0318(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_319[0x37];                                     // 0x0319(0x0037)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           _nonStackingEffects;                               // 0x0350(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	float                                         _statusEffectIconPercentage;                       // 0x0360(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_364[0x34];                                     // 0x0364(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_End();
	void Authority_EndSelf();
	void Authority_OnOriginatingPlayerEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason);
	void Authority_RemoveSelf();
	void Authority_SetRemainingLifetime(float Lifetime);
	void Authority_Start(const float Duration);
	void BroadcastGameEventNotification(const struct FGameplayNotificationData& notificationData, bool addToHistory);
	void BroadcastOriginatorGameEventNotification();
	void InitializeLifetime(float Lifetime);
	void Multicast_SetRemainingLifetime(float Lifetime);
	void Multicast_SetRemainingLifetimeInitialized(bool remainingLifetimeInitialized);
	void OnLifetimeEnded();
	void OnLifetimeStarted();
	void OnRep_ShouldDisplay();
	void OnRep_ShouldOriginatingPlayerChange();
	void OnRep_StatusInitializationData();
	void OnShouldDisplayChanged(bool CurrentValue);
	void OnShouldOriginatingPlayerChange();
	void SetShouldDisplay(bool On);
	void SetStatusEffectIconPercentage(float Value);

	void FireActiveStatusEffectEvent(float Percentage, int32 levelToDisplay) const;
	float GetCustomParam() const;
	float GetLifetimeDuration() const;
	class ADBDPlayer* GetOriginatingPlayer() const;
	bool GetShouldDisplay() const;
	float GetStatusEffectCooldownRate() const;
	EStatusEffectType GetStatusEffectType() const;
	bool IsInOriginatorRange() const;
	bool IsKillerInOriginatorRange(float AdditiveRangeModifier) const;
	bool IsOriginatorAlive() const;
	bool IsOriginatorHooked() const;
	bool ShouldDisplayStatusEffectIcon() const;
	bool ShouldHideStatusEffectIcon() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusEffect">();
	}
	static class UStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatusEffect>();
	}
};
static_assert(alignof(UStatusEffect) == 0x000008, "Wrong alignment on UStatusEffect");
static_assert(sizeof(UStatusEffect) == 0x000398, "Wrong size on UStatusEffect");
static_assert(offsetof(UStatusEffect, ModifierData) == 0x0002A8, "Member 'UStatusEffect::ModifierData' has a wrong offset!");
static_assert(offsetof(UStatusEffect, ShouldDisplay) == 0x0002D8, "Member 'UStatusEffect::ShouldDisplay' has a wrong offset!");
static_assert(offsetof(UStatusEffect, CustomParam) == 0x0002DC, "Member 'UStatusEffect::CustomParam' has a wrong offset!");
static_assert(offsetof(UStatusEffect, _removeOnRemainingLifetimeEnded) == 0x0002E0, "Member 'UStatusEffect::_removeOnRemainingLifetimeEnded' has a wrong offset!");
static_assert(offsetof(UStatusEffect, BroadcastAsStatusEffectWhenApplicable) == 0x0002E1, "Member 'UStatusEffect::BroadcastAsStatusEffectWhenApplicable' has a wrong offset!");
static_assert(offsetof(UStatusEffect, BroadcastAsStatusEffectByActivationTimer) == 0x0002E2, "Member 'UStatusEffect::BroadcastAsStatusEffectByActivationTimer' has a wrong offset!");
static_assert(offsetof(UStatusEffect, BroadcastAsStatusEffectWhenLifeRemains) == 0x0002E3, "Member 'UStatusEffect::BroadcastAsStatusEffectWhenLifeRemains' has a wrong offset!");
static_assert(offsetof(UStatusEffect, BroadcastAsStatusEffectByFunction) == 0x0002E4, "Member 'UStatusEffect::BroadcastAsStatusEffectByFunction' has a wrong offset!");
static_assert(offsetof(UStatusEffect, BroadcastAsStatusEffectAlways) == 0x0002E5, "Member 'UStatusEffect::BroadcastAsStatusEffectAlways' has a wrong offset!");
static_assert(offsetof(UStatusEffect, BroadcastAsStatusEffectManual) == 0x0002E6, "Member 'UStatusEffect::BroadcastAsStatusEffectManual' has a wrong offset!");
static_assert(offsetof(UStatusEffect, BroadcastOriginatorGameEventNotificationWhenFirstApplicable) == 0x0002E7, "Member 'UStatusEffect::BroadcastOriginatorGameEventNotificationWhenFirstApplicable' has a wrong offset!");
static_assert(offsetof(UStatusEffect, ShouldHideStatusEffectIconForOriginatingPlayer) == 0x0002E8, "Member 'UStatusEffect::ShouldHideStatusEffectIconForOriginatingPlayer' has a wrong offset!");
static_assert(offsetof(UStatusEffect, ShouldHideStatusEffectIconByFunction) == 0x0002E9, "Member 'UStatusEffect::ShouldHideStatusEffectIconByFunction' has a wrong offset!");
static_assert(offsetof(UStatusEffect, _forceActivationTimerDisplay) == 0x0002EA, "Member 'UStatusEffect::_forceActivationTimerDisplay' has a wrong offset!");
static_assert(offsetof(UStatusEffect, _statusInitializationData) == 0x0002F0, "Member 'UStatusEffect::_statusInitializationData' has a wrong offset!");
static_assert(offsetof(UStatusEffect, _shouldBroadcastAsStatusEffect) == 0x000318, "Member 'UStatusEffect::_shouldBroadcastAsStatusEffect' has a wrong offset!");
static_assert(offsetof(UStatusEffect, _nonStackingEffects) == 0x000350, "Member 'UStatusEffect::_nonStackingEffects' has a wrong offset!");
static_assert(offsetof(UStatusEffect, _statusEffectIconPercentage) == 0x000360, "Member 'UStatusEffect::_statusEffectIconPercentage' has a wrong offset!");

// Class DeadByDaylight.OfferingCardAnim
// 0x0020 (0x0370 - 0x0350)
class UOfferingCardAnim final : public UAnimInstance
{
public:
	TMulticastInlineDelegate<void()>              _onCardDissolved;                                  // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPrivate)
	EOfferingAnimState                            _activeState;                                      // 0x0360(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isRevealed;                                       // 0x0361(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_362[0xE];                                      // 0x0362(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OfferingCardAnim">();
	}
	static class UOfferingCardAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOfferingCardAnim>();
	}
};
static_assert(alignof(UOfferingCardAnim) == 0x000010, "Wrong alignment on UOfferingCardAnim");
static_assert(sizeof(UOfferingCardAnim) == 0x000370, "Wrong size on UOfferingCardAnim");
static_assert(offsetof(UOfferingCardAnim, _onCardDissolved) == 0x000350, "Member 'UOfferingCardAnim::_onCardDissolved' has a wrong offset!");
static_assert(offsetof(UOfferingCardAnim, _activeState) == 0x000360, "Member 'UOfferingCardAnim::_activeState' has a wrong offset!");
static_assert(offsetof(UOfferingCardAnim, _isRevealed) == 0x000361, "Member 'UOfferingCardAnim::_isRevealed' has a wrong offset!");

// Class DeadByDaylight.Interactable
// 0x0108 (0x03A8 - 0x02A0)
class AInteractable : public AActor
{
public:
	uint8                                         Pad_2A0[0x68];                                     // 0x02A0(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    _singleZone;                                       // 0x0308(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _useSingleZone;                                    // 0x0310(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_311[0x7];                                      // 0x0311(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInteractor*>                    _interactors;                                      // 0x0318(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UInteractableTransformOptimizer*        _transformOptimizer;                               // 0x0328(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_330[0x20];                                     // 0x0330(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UPrimitiveComponent*, struct FInteractionArray> _zoneToInteractions;                  // 0x0350(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UGameplayTagContainerComponent*         _interactableObjectState;                          // 0x03A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AttachEveryInteractionToZone(class UPrimitiveComponent* zone);
	void AuthorityRequestCancelOngoingInteractions(bool onlyOnHitCancelableInteractions);
	void OnInteractorLockChanged(bool Locked, class ADBDPlayer* interactingPlayer);
	void OnLevelReadyToPlay();
	void OnLevelReadyToPlay_Native();
	void PreInterruptionEvent(class ADBDPlayer* interruptor, class ADBDPlayer* interruptee, class UInterruptionDefinition* interruption);
	void SetInteractorsUsable(bool usable, class UInteractor* exception);
	void SetSingleZone(class UPrimitiveComponent* zone);

	TArray<class ADBDPlayer*> Authority_GetInteractingPlayers() const;
	struct FVector GetFocalPointPosition(const class ADBDPlayer* Player, const class UInteractionDefinition* definition) const;
	TArray<class ADBDPlayer*> GetInteractingPlayersRaw() const;
	TArray<class UInteractor*> GetInteractors() const;
	class UGameplayTagContainerComponent* GetObjectState() const;
	class ADBDPlayer* GetPlayerOwner() const;
	bool HasAnOngoingInteraction() const;
	bool IsInteractingWith(const class ADBDPlayer* Player) const;
	bool IsInteractionDone(class ADBDPlayer* Player, const class UInteractor* Interactor, const class UInteractionDefinition* definition, EInputInteractionType interactionType) const;
	bool IsInterruptionPossible(const class ADBDPlayer* interruptor, const class ADBDPlayer* interruptee, const class UInteractor* Interactor, const class UInteractionDefinition* definition, const class UInterruptionDefinition* interruption) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Interactable">();
	}
	static class AInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInteractable>();
	}
};
static_assert(alignof(AInteractable) == 0x000008, "Wrong alignment on AInteractable");
static_assert(sizeof(AInteractable) == 0x0003A8, "Wrong size on AInteractable");
static_assert(offsetof(AInteractable, _singleZone) == 0x000308, "Member 'AInteractable::_singleZone' has a wrong offset!");
static_assert(offsetof(AInteractable, _useSingleZone) == 0x000310, "Member 'AInteractable::_useSingleZone' has a wrong offset!");
static_assert(offsetof(AInteractable, _interactors) == 0x000318, "Member 'AInteractable::_interactors' has a wrong offset!");
static_assert(offsetof(AInteractable, _transformOptimizer) == 0x000328, "Member 'AInteractable::_transformOptimizer' has a wrong offset!");
static_assert(offsetof(AInteractable, _zoneToInteractions) == 0x000350, "Member 'AInteractable::_zoneToInteractions' has a wrong offset!");
static_assert(offsetof(AInteractable, _interactableObjectState) == 0x0003A0, "Member 'AInteractable::_interactableObjectState' has a wrong offset!");

// Class DeadByDaylight.Collectable
// 0x01B0 (0x0558 - 0x03A8)
class ACollectable : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x48];                                     // 0x03A8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          DisplayUsePercent;                                 // 0x03F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StrafeOnUse;                                       // 0x03F1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VisibleWhenEquipped;                               // 0x03F2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopRunningOnUse;                                  // 0x03F3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemHandPosition                             HandPosition;                                      // 0x03F4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableArmOverrideDuringInteractions;              // 0x03F5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasUseInteraction;                                 // 0x03F6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RemoveInteractionsOnInteractorChange;              // 0x03F7(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollectableCategory                          category;                                          // 0x03F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F9[0x3];                                      // 0x03F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemId;                                            // 0x03FC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FromPlayerSpawn;                                   // 0x0408(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_409[0x7];                                      // 0x0409(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UItemModifier*                          BaseItemModifier;                                  // 0x0410(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemModifier*                          ItemModifier1;                                     // 0x0418(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemModifier*                          ItemModifier2;                                     // 0x0420(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldRegisterToOnSurvivorAdded;                   // 0x0428(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_429[0x67];                                     // 0x0429(0x0067)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           EventToDispatchOnCollect;                          // 0x0490(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BeingCollected;                                    // 0x049C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BeingDropped;                                      // 0x049D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _beingConsumedByEntity;                            // 0x049E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49F[0x1];                                      // 0x049F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractor*                            _itemInteractor;                                   // 0x04A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDSkeletalMeshComponentBudgeted*      _mesh;                                             // 0x04A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInputInteractionType                         _displayedInputType;                               // 0x04B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isKeyPromptForceDisabled;                         // 0x04B1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBoundToFirstCollector;                          // 0x04B2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCursedItem;                                     // 0x04B3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isSpecialItem;                                    // 0x04B4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _useInventoryCount;                                // 0x04B5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttachToSocketNameEnum                       _attachToSocketName;                               // 0x04B6(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInventoryType                                _collectInInventoryType;                           // 0x04B7(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B8[0x18];                                     // 0x04B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        _placementOrigin;                                  // 0x04D0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D8[0x18];                                     // 0x04D8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _collector;                                        // 0x04F0(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDPlayer*                             _firstCollector;                                   // 0x04F8(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECollectableState                             _state;                                            // 0x0500(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_501[0x7];                                      // 0x0501(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UItemAddon*>                     _itemAddons;                                       // 0x0508(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UItemModifier*>                  _itemModifiers;                                    // 0x0518(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	int32                                         _itemCount;                                        // 0x0528(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_52C[0x4];                                      // 0x052C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ASearchable*                            _attachedSearchable;                               // 0x0530(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _stateTagForCollector;                             // 0x0538(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _stateTagEquippedForCollector;                     // 0x0544(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELoadoutItemType                              _itemType;                                         // 0x0550(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _discardOnDrop;                                    // 0x0551(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _discardWhenConsumed;                              // 0x0552(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _disableAttachmentReplication;                     // 0x0553(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_554[0x2];                                      // 0x0554(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isInUse;                                          // 0x0556(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _aimOnUse;                                         // 0x0557(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool Authority_AddItemAddon(class UItemAddon* addon);
	void Authority_Discard();
	void Authority_OnCollectorEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason);
	void Authority_OnConsumed(bool forceDiscard);
	void Authority_RemoveItemAddon(class UItemAddon* addon);
	void Authority_Use();
	void Authority_UseReleased();
	void BP_OnSurvivorAdded(class ASurvivor* Survivor);
	void CallOnCollectorSetBP(TDelegate<void(class ADBDPlayer* Player)> Callback);
	void DebugPrintStats();
	TArray<class UItemAddon*> GetItemAddons();
	void Local_Dropped_Location(class ADBDPlayer* droppedBy, const struct FVector& Location, const struct FRotator& Rotation);
	void Multicast_Collected(class ADBDPlayer* collector, EInventoryType inventoryType);
	void Multicast_Dropped(class ADBDPlayer* droppedBy, const struct FVector& Location, const struct FRotator& Rotation, EItemDropType itemDropType);
	void Multicast_RemoveAllAddons();
	void Multicast_RemoveItemAddon(class UItemAddon* addon);
	void Multicast_Use();
	void Multicast_UseReleased(class ADBDPlayer* collector);
	void OnActivateDissolveItem();
	void OnAddonsAdded(const TArray<class UItemAddon*>& addons);
	void OnAddonsRemoved(const TArray<class UItemAddon*>& addons);
	void OnCollectorSet(class ADBDPlayer* collector);
	void OnCustomizationChanged();
	void OnDropped(class ADBDPlayer* droppingPlayer);
	void OnPostItemAddonsCreation(class ADBDPlayer* Player);
	void OnRep_Collector(class ADBDPlayer* oldCollector);
	void OnRep_State();
	void OnUse();
	void OnUseReleased(class ADBDPlayer* collector);
	void SetCount(int32 Count);
	void SetDisplayedInputType(const EInputInteractionType displayedInputType);
	void SetIsKeyPromptForceDisabled(const bool IsKeyPromptForceDisabled);
	void SetItemInteractor(class UInteractor* Interactor);
	void SetVisibilityEvent(bool Visibility);

	bool CanBeCollected(const class ADBDPlayer* collector) const;
	bool CanBeDropped(const class ADBDPlayer* dropper) const;
	bool CanUse(const class ADBDPlayer* Player) const;
	class ADBDPlayer* GetCollector() const;
	int32 GetCount() const;
	EInputInteractionType GetDisplayedInputType() const;
	const class FString GetIconFilePath() const;
	uint8 GetItemIconIndex() const;
	class UInteractor* GetItemInteractor() const;
	float GetModifierMax(const struct FGameplayTag& modifierType, float defaultValue) const;
	float GetModifierSum(const struct FGameplayTag& modifierType, float defaultValue) const;
	float GetUsePercentLeft() const;
	bool HasGameplayModifierFlag(const struct FGameplayTag& modifierFlag) const;
	bool IsCollected() const;
	bool IsCountDisplayForced() const;
	bool IsCursedItem() const;
	bool IsEquipped() const;
	bool IsInSearchable() const;
	bool IsKeyPromptForceDisabled() const;
	bool IsLocallyControlled() const;
	bool IsOnGround() const;
	bool IsPickable() const;
	bool IsRechargeable() const;
	bool IsSpecialItem() const;
	bool IsStored() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Collectable">();
	}
	static class ACollectable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACollectable>();
	}
};
static_assert(alignof(ACollectable) == 0x000008, "Wrong alignment on ACollectable");
static_assert(sizeof(ACollectable) == 0x000558, "Wrong size on ACollectable");
static_assert(offsetof(ACollectable, DisplayUsePercent) == 0x0003F0, "Member 'ACollectable::DisplayUsePercent' has a wrong offset!");
static_assert(offsetof(ACollectable, StrafeOnUse) == 0x0003F1, "Member 'ACollectable::StrafeOnUse' has a wrong offset!");
static_assert(offsetof(ACollectable, VisibleWhenEquipped) == 0x0003F2, "Member 'ACollectable::VisibleWhenEquipped' has a wrong offset!");
static_assert(offsetof(ACollectable, StopRunningOnUse) == 0x0003F3, "Member 'ACollectable::StopRunningOnUse' has a wrong offset!");
static_assert(offsetof(ACollectable, HandPosition) == 0x0003F4, "Member 'ACollectable::HandPosition' has a wrong offset!");
static_assert(offsetof(ACollectable, DisableArmOverrideDuringInteractions) == 0x0003F5, "Member 'ACollectable::DisableArmOverrideDuringInteractions' has a wrong offset!");
static_assert(offsetof(ACollectable, HasUseInteraction) == 0x0003F6, "Member 'ACollectable::HasUseInteraction' has a wrong offset!");
static_assert(offsetof(ACollectable, RemoveInteractionsOnInteractorChange) == 0x0003F7, "Member 'ACollectable::RemoveInteractionsOnInteractorChange' has a wrong offset!");
static_assert(offsetof(ACollectable, category) == 0x0003F8, "Member 'ACollectable::category' has a wrong offset!");
static_assert(offsetof(ACollectable, ItemId) == 0x0003FC, "Member 'ACollectable::ItemId' has a wrong offset!");
static_assert(offsetof(ACollectable, FromPlayerSpawn) == 0x000408, "Member 'ACollectable::FromPlayerSpawn' has a wrong offset!");
static_assert(offsetof(ACollectable, BaseItemModifier) == 0x000410, "Member 'ACollectable::BaseItemModifier' has a wrong offset!");
static_assert(offsetof(ACollectable, ItemModifier1) == 0x000418, "Member 'ACollectable::ItemModifier1' has a wrong offset!");
static_assert(offsetof(ACollectable, ItemModifier2) == 0x000420, "Member 'ACollectable::ItemModifier2' has a wrong offset!");
static_assert(offsetof(ACollectable, ShouldRegisterToOnSurvivorAdded) == 0x000428, "Member 'ACollectable::ShouldRegisterToOnSurvivorAdded' has a wrong offset!");
static_assert(offsetof(ACollectable, EventToDispatchOnCollect) == 0x000490, "Member 'ACollectable::EventToDispatchOnCollect' has a wrong offset!");
static_assert(offsetof(ACollectable, BeingCollected) == 0x00049C, "Member 'ACollectable::BeingCollected' has a wrong offset!");
static_assert(offsetof(ACollectable, BeingDropped) == 0x00049D, "Member 'ACollectable::BeingDropped' has a wrong offset!");
static_assert(offsetof(ACollectable, _beingConsumedByEntity) == 0x00049E, "Member 'ACollectable::_beingConsumedByEntity' has a wrong offset!");
static_assert(offsetof(ACollectable, _itemInteractor) == 0x0004A0, "Member 'ACollectable::_itemInteractor' has a wrong offset!");
static_assert(offsetof(ACollectable, _mesh) == 0x0004A8, "Member 'ACollectable::_mesh' has a wrong offset!");
static_assert(offsetof(ACollectable, _displayedInputType) == 0x0004B0, "Member 'ACollectable::_displayedInputType' has a wrong offset!");
static_assert(offsetof(ACollectable, _isKeyPromptForceDisabled) == 0x0004B1, "Member 'ACollectable::_isKeyPromptForceDisabled' has a wrong offset!");
static_assert(offsetof(ACollectable, _isBoundToFirstCollector) == 0x0004B2, "Member 'ACollectable::_isBoundToFirstCollector' has a wrong offset!");
static_assert(offsetof(ACollectable, _isCursedItem) == 0x0004B3, "Member 'ACollectable::_isCursedItem' has a wrong offset!");
static_assert(offsetof(ACollectable, _isSpecialItem) == 0x0004B4, "Member 'ACollectable::_isSpecialItem' has a wrong offset!");
static_assert(offsetof(ACollectable, _useInventoryCount) == 0x0004B5, "Member 'ACollectable::_useInventoryCount' has a wrong offset!");
static_assert(offsetof(ACollectable, _attachToSocketName) == 0x0004B6, "Member 'ACollectable::_attachToSocketName' has a wrong offset!");
static_assert(offsetof(ACollectable, _collectInInventoryType) == 0x0004B7, "Member 'ACollectable::_collectInInventoryType' has a wrong offset!");
static_assert(offsetof(ACollectable, _placementOrigin) == 0x0004D0, "Member 'ACollectable::_placementOrigin' has a wrong offset!");
static_assert(offsetof(ACollectable, _collector) == 0x0004F0, "Member 'ACollectable::_collector' has a wrong offset!");
static_assert(offsetof(ACollectable, _firstCollector) == 0x0004F8, "Member 'ACollectable::_firstCollector' has a wrong offset!");
static_assert(offsetof(ACollectable, _state) == 0x000500, "Member 'ACollectable::_state' has a wrong offset!");
static_assert(offsetof(ACollectable, _itemAddons) == 0x000508, "Member 'ACollectable::_itemAddons' has a wrong offset!");
static_assert(offsetof(ACollectable, _itemModifiers) == 0x000518, "Member 'ACollectable::_itemModifiers' has a wrong offset!");
static_assert(offsetof(ACollectable, _itemCount) == 0x000528, "Member 'ACollectable::_itemCount' has a wrong offset!");
static_assert(offsetof(ACollectable, _attachedSearchable) == 0x000530, "Member 'ACollectable::_attachedSearchable' has a wrong offset!");
static_assert(offsetof(ACollectable, _stateTagForCollector) == 0x000538, "Member 'ACollectable::_stateTagForCollector' has a wrong offset!");
static_assert(offsetof(ACollectable, _stateTagEquippedForCollector) == 0x000544, "Member 'ACollectable::_stateTagEquippedForCollector' has a wrong offset!");
static_assert(offsetof(ACollectable, _itemType) == 0x000550, "Member 'ACollectable::_itemType' has a wrong offset!");
static_assert(offsetof(ACollectable, _discardOnDrop) == 0x000551, "Member 'ACollectable::_discardOnDrop' has a wrong offset!");
static_assert(offsetof(ACollectable, _discardWhenConsumed) == 0x000552, "Member 'ACollectable::_discardWhenConsumed' has a wrong offset!");
static_assert(offsetof(ACollectable, _disableAttachmentReplication) == 0x000553, "Member 'ACollectable::_disableAttachmentReplication' has a wrong offset!");
static_assert(offsetof(ACollectable, _isInUse) == 0x000556, "Member 'ACollectable::_isInUse' has a wrong offset!");
static_assert(offsetof(ACollectable, _aimOnUse) == 0x000557, "Member 'ACollectable::_aimOnUse' has a wrong offset!");

// Class DeadByDaylight.BaseTrap
// 0x0008 (0x0560 - 0x0558)
class ABaseTrap : public ACollectable
{
public:
	bool                                          _isTrapSet;                                        // 0x0558(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_559[0x7];                                      // 0x0559(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetIsTrapSet(const bool Value);

	bool IsTrapSet() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseTrap">();
	}
	static class ABaseTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseTrap>();
	}
};
static_assert(alignof(ABaseTrap) == 0x000008, "Wrong alignment on ABaseTrap");
static_assert(sizeof(ABaseTrap) == 0x000560, "Wrong size on ABaseTrap");
static_assert(offsetof(ABaseTrap, _isTrapSet) == 0x000558, "Member 'ABaseTrap::_isTrapSet' has a wrong offset!");

// Class DeadByDaylight.SpawnElementTrackerComponent
// 0x0010 (0x00C8 - 0x00B8)
class USpawnElementTrackerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnElementTrackerComponent">();
	}
	static class USpawnElementTrackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnElementTrackerComponent>();
	}
};
static_assert(alignof(USpawnElementTrackerComponent) == 0x000008, "Wrong alignment on USpawnElementTrackerComponent");
static_assert(sizeof(USpawnElementTrackerComponent) == 0x0000C8, "Wrong size on USpawnElementTrackerComponent");

// Class DeadByDaylight.InteractionDefinition
// 0x04A0 (0x0770 - 0x02D0)
#pragma pack(push, 0x1)
class alignas(0x10) UInteractionDefinition : public USceneComponent
{
public:
	uint8                                         Pad_2D0[0x40];                                     // 0x02D0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 InteractionID;                                     // 0x0310(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SnapTime;                                          // 0x0320(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ResetCameraDuringSnap;                             // 0x0324(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_325[0x1];                                      // 0x0325(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          AllowStartInteractionFromHeldInput;                // 0x0326(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopInteractionOnMontageComplete;                  // 0x0327(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopInteractionOnMontageBlendingOut;               // 0x0328(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopInteractionOnTimerExpire;                      // 0x0329(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopInteractionOnHeightDelta;                      // 0x032A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopEnterMontageOnExit;                            // 0x032B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopUpdateMontageOnExit;                           // 0x032C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreStrafeAnimFix;                               // 0x032D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractionAnimation                         InteractionAnimation;                              // 0x032E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SurvivorCanInteract;                               // 0x032F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          KillerCanInteract;                                 // 0x0330(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowInputPersistence;                             // 0x0331(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SnapPosition;                                      // 0x0332(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SweepOnFinalSnap;                                  // 0x0333(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SnapRotation;                                      // 0x0334(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_335[0x3];                                      // 0x0335(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SnapStopDistance;                                  // 0x0338(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TestClearPathDuringSnap;                           // 0x033C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MustBeClosestPlayerToSnapPoint;                    // 0x033D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CheckInteractableIsInPlayerView;                   // 0x033E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33F[0x1];                                      // 0x033F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CheckInteractableInViewSphereSweepRadius;          // 0x0340(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_344[0x4];                                      // 0x0344(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CheckInteractableInViewOffset;                     // 0x0348(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CheckInteractableInViewOffsetDistanceToHitPoint;   // 0x0360(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInterruptibleIfTestClearPathDuringSnapFails;     // 0x0364(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TestPlayerOrientationOnSnap;                       // 0x0365(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ScaleEnterAnimationToTime;                         // 0x0366(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ScaleMainAnimationToTime;                          // 0x0367(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ScaleExitAnimationToTime;                          // 0x0368(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnapBackType                                 SnapBackType;                                      // 0x0369(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnapBackPositionType                         SnapBackPositionType;                              // 0x036A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36B[0x5];                                      // 0x036B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              SnapBackPositionOffset;                            // 0x0370(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SnapToInitialRotationDuringSnapBack;               // 0x0380(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseStartSnapTimeForSnapExitTime;                   // 0x0381(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanInteractWhileIncapacitated;                     // 0x0382(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanInteractWhileCloaked;                           // 0x0383(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanInteractWhileAttacking;                         // 0x0384(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanInteractWhileChainLinked;                       // 0x0385(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanInteractWhileShocked;                           // 0x0386(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanInteractWhileUnhookingSelf;                     // 0x0387(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanSurvivorsInteractWhileFalling;                  // 0x0388(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanInteractWhileCarrying;                          // 0x0389(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowNavigation;                                   // 0x038A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowNavigationInput;                              // 0x038B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowRotation;                                     // 0x038C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCameraMontageMode;                              // 0x038D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OwnerBlocksAttack;                                 // 0x038E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHighPriority;                                    // 0x038F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowOverridingWhenNotForced;                      // 0x0390(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreOverlapOnInteractable;                       // 0x0391(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseAuthoritativeMovement;                          // 0x0392(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanBeAuthoritativePushedDuringEnter;               // 0x0393(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanBeAuthoritativePushedDuringUpdate;              // 0x0394(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanBeAuthoritativePushedDuringExit;                // 0x0395(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanAuthoritativePush;                              // 0x0396(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CancelOnHit;                                       // 0x0397(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CancelOnAttack;                                    // 0x0398(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HideItem;                                          // 0x0399(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ContinueCachingLastSafeItemDropLocation;           // 0x039A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoBindToParentInteractor;                        // 0x039B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoBindToParentZone;                              // 0x039C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39D[0x3];                                      // 0x039D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CancelOnMoveInitialDelay;                          // 0x03A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CancelOnMoveInput;                                 // 0x03A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CancelOnMoveInputOnlyWhenRunning;                  // 0x03A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A9[0x1];                                      // 0x03A9(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          CanCrouch;                                         // 0x03AA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AffectsStillness;                                  // 0x03AB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3AC[0x1];                                      // 0x03AC(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          BlockSelfInteract;                                 // 0x03AD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3AE[0x2];                                      // 0x03AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InteractionTime;                                   // 0x03B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputInteractionType                         interactionInputType;                              // 0x03B4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NoInputInteraction;                                // 0x03B5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopInteractionOnInputRelease;                     // 0x03B6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowHitMontageWhenInteracting;                    // 0x03B7(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowBasicInteractionIcon;                          // 0x03B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HideItemIcon;                                      // 0x03B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3BA[0x6];                                      // 0x03BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInterruptionDefinition*>        _interruptionDefinitions;                          // 0x03C0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADBDPlayer* Player)> OnInteractionEnteredDelegate;           // 0x03D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E0[0x30];                                     // 0x03E0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnInteractionFinishedDelegate;                     // 0x0410(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_420[0x29];                                     // 0x0420(0x0029)(Fixing Size After Last Property [ Dumper-7 ])
	EInputInteractionType                         SecondaryActionInputType;                          // 0x0449(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44A[0x1E];                                     // 0x044A(0x001E)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            NavigationSpeedCurveEnter;                         // 0x0468(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            NavigationSpeedCurve;                              // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            NavigationSpeedCurveExit;                          // 0x0478(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _shouldCheckInteractedUpon;                        // 0x0480(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInteractionOwnership                         OwnershipUsability;                                // 0x0481(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_482[0x2];                                      // 0x0482(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExitInteractionTime;                               // 0x0484(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ApplyModifiersToExitTime;                          // 0x0488(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_489[0x7];                                      // 0x0489(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   InteractionDescriptionText;                        // 0x0490(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   DisabledInputPromptText;                           // 0x04A8(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          InteractionCanBeToggled;                           // 0x04C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsOverridingInputToggleReleasePromptMessage;       // 0x04C1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C2[0x6];                                      // 0x04C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 InputToggleReleasePromptMessage;                   // 0x04C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IgnoreSprintToCancelSetting;                       // 0x04D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ForceWithSprintToCancelSetting;                    // 0x04D9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4DA[0x2];                                      // 0x04DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InteractionHeightDeltaMax;                         // 0x04DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaximumVelocity;                                   // 0x04E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E4[0x4];                                      // 0x04E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimationMontageDescriptor            EnterMontage;                                      // 0x04E8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FAnimationMontageDescriptor            UpdateMontage;                                     // 0x0508(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FAnimationMontageDescriptor            ExitMontage;                                       // 0x0528(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           EnterMontageVariantCycle;                          // 0x0548(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           UpdateMontageVariantCycle;                         // 0x0558(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           ExitMontageVariantCycle;                           // 0x0568(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   SnapSocketName;                                    // 0x0578(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _canBeAttachedToAnyZone;                           // 0x0584(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInterruptibleBySacrifice;                       // 0x0585(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IgnoreStun;                                        // 0x0586(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_587[0x1];                                      // 0x0587(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _tags;                                             // 0x0588(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _objectStateTag;                                   // 0x05A8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B4[0x4];                                      // 0x05B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FSecondaryInteractionProperties> _secondaryInteractions;                // 0x05B8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          _useHoldPrompt;                                    // 0x0608(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _allowInteractionInNarrowSpaces;                   // 0x0609(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _allowIKSensorDuringInteraction;                   // 0x060A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_60B[0x25];                                     // 0x060B(0x0025)(Fixing Size After Last Property [ Dumper-7 ])
	struct FActivationDefinition                  _activationDefinition;                             // 0x0630(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          _startUpdateMontageDuringEnter;                    // 0x0658(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_659[0x7];                                      // 0x0659(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractor*                            _interactor;                                       // 0x0660(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UInteractionDefinition*>         _mutuallyExclusiveInteractionsClient;              // 0x0668(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UPrimitiveComponent*                    _zone;                                             // 0x0678(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EInputInteractionType                         _cancelInputType;                                  // 0x0680(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_681[0x7];                                      // 0x0681(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _preventingTags;                                   // 0x0688(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6A8[0x20];                                     // 0x06A8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPlayerInteractionHandler*>      _evaluatingInteractionHandlers;                    // 0x06C8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FSecondaryInteractionProperties        DEPRECATED_SecondaryInteractionProperties;         // 0x06D8(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UTexture2D>              _interactionIconPromptOverride;                    // 0x0710(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_748[0x20];                                     // 0x0748(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddMutuallyExclusiveInteraction(class UInteractionDefinition* Interaction);
	void AttachToInteractor(class UInteractor* Interactor);
	void AttachToZone(class UPrimitiveComponent* zone);
	void Authority_OnInteractionAuthorized(class ADBDPlayer* Player);
	class ADBDPlayer* GetPlayerDependency(const class ADBDPlayer* interactingPlayer);
	void OnInteractionAnimNotifyEvent(class FName NotifyId, class ADBDPlayer* Player);
	void OnInteractionCancelled(class ADBDPlayer* Player);
	void OnInteractionEnterEnd(class ADBDPlayer* Player);
	void OnInteractionEnterStart(class ADBDPlayer* Player, float actualSnapTime);
	void OnInteractionEnterTick(class ADBDPlayer* Player, float DeltaTime);
	void OnInteractionExitEnd(class ADBDPlayer* Player);
	void OnInteractionExitStart(class ADBDPlayer* Player);
	void OnInteractionExitTick(class ADBDPlayer* Player, float DeltaTime);
	void OnInteractionFinished(class ADBDPlayer* Player, bool hasInteractionStarted);
	void OnInteractionInit(class ADBDPlayer* Player);
	void OnInteractionInterruptEnd(class ADBDPlayer* Player, class UInterruptionDefinition* currentInterruption, class ADBDPlayer* interruptingPlayer);
	void OnInteractionInterruptStart(class ADBDPlayer* Player, class UInterruptionDefinition* currentInterruption, class ADBDPlayer* interruptingPlayer);
	void OnInteractionInterruptStarted(class ADBDPlayer* Player, class UInterruptionDefinition* currentInterruption, class ADBDPlayer* interruptingPlayer);
	void OnInteractionUpdateEnd(class ADBDPlayer* Player);
	void OnInteractionUpdateMontageReachedMiddle(class ADBDPlayer* Player);
	void OnInteractionUpdateStart(class ADBDPlayer* Player);
	void OnInteractionUpdateTick(class ADBDPlayer* Player, float DeltaTime);
	void OnInterruptorUpdateStart(class UInterruptionDefinition* currentInterruption, class ADBDPlayer* interruptor, class ADBDPlayer* interruptee);
	void OnUpdateMontageStart(class ADBDPlayer* Player);

	float CalculateSnapTimeForConstantMaxNormalMovementSpeed(const class ADBDPlayer* Player, float speedBoost) const;
	bool CanOverrideInteraction(const class UInteractionDefinition* Interaction) const;
	EInteractionComparisonPriority ComparePriorityToInteraction(const class UInteractionDefinition* Interaction) const;
	bool DoesPlayerHaveClearPath(const class ADBDPlayer* Player) const;
	float GetActionSpeedMultiplier(const class ADBDPlayer* Character) const;
	float GetActorHeightDelta(const class ADBDPlayer* Player) const;
	TArray<class AActor*> GetActorsToIgnoreOverlap() const;
	bool GetAllowNavigation(const class ADBDPlayer* Player) const;
	float GetChargePercent() const;
	struct FAnimationMontageDescriptor GetEnterMontage(const class ADBDPlayer* Player) const;
	struct FAnimationMontageDescriptor GetExitMontage(const class ADBDPlayer* Player) const;
	struct FVector GetFocalPointPosition(const class ADBDPlayer* Player) const;
	class AInteractable* GetInteractable() const;
	const class FText GetInteractionDescriptionText() const;
	float GetInteractionExitTime(const class ADBDPlayer* Character) const;
	class FString GetInteractionText(const class ADBDPlayer* Player) const;
	float GetInteractionTime(const class ADBDPlayer* Character) const;
	float GetInteractionTimeMultiplier(const class ADBDPlayer* Character) const;
	class UInteractor* GetInteractor() const;
	class ADBDPlayer* GetPlayerOwner() const;
	struct FRotator GetRotationToSnapPoint(const class ADBDPlayer* Player) const;
	EInputInteractionType GetSecondaryActionInputType(const class UObject* WorldContextObject) const;
	struct FVector GetSlashableRelativeLocation() const;
	float GetSnapDistance(const class ADBDPlayer* Player) const;
	struct FVector GetSnapPointPosition(const class ADBDPlayer* Player) const;
	class FName GetSnapSocketName(const class ADBDPlayer* Player) const;
	float GetSnapTime(const class ADBDPlayer* Player) const;
	struct FAnimationMontageDescriptor GetUpdateMontage(const class ADBDPlayer* Player) const;
	bool IsCancelable(const class ADBDPlayer* Player) const;
	bool IsInteractionDone(const class ADBDPlayer* Player, EInputInteractionType interactionType) const;
	bool IsInteractionPossible(const class ADBDPlayer* Player, EInputInteractionType interactionType, bool performClientCheck, bool performHeightCheck, bool isBotPredictionCheck) const;
	bool IsInteractionPossibleBP(const class ADBDPlayer* Player, EInputInteractionType interactionType) const;
	bool IsInteractionPossibleClient(const class ADBDPlayer* Player, EInputInteractionType interactionType) const;
	bool IsInteractionUsingOffering(const class ADBDPlayer* Player) const;
	bool IsInterruptionPossible(const class ADBDPlayer* interruptor, const class ADBDPlayer* interruptee, const class UInterruptionDefinition* interruption) const;
	bool ShouldStartUpdateMontageDuringEnter(const class ADBDPlayer* Character) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionDefinition">();
	}
	static class UInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionDefinition>();
	}
};
#pragma pack(pop)
static_assert(alignof(UInteractionDefinition) == 0x000010, "Wrong alignment on UInteractionDefinition");
static_assert(sizeof(UInteractionDefinition) == 0x000770, "Wrong size on UInteractionDefinition");
static_assert(offsetof(UInteractionDefinition, InteractionID) == 0x000310, "Member 'UInteractionDefinition::InteractionID' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SnapTime) == 0x000320, "Member 'UInteractionDefinition::SnapTime' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ResetCameraDuringSnap) == 0x000324, "Member 'UInteractionDefinition::ResetCameraDuringSnap' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, AllowStartInteractionFromHeldInput) == 0x000326, "Member 'UInteractionDefinition::AllowStartInteractionFromHeldInput' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, StopInteractionOnMontageComplete) == 0x000327, "Member 'UInteractionDefinition::StopInteractionOnMontageComplete' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, StopInteractionOnMontageBlendingOut) == 0x000328, "Member 'UInteractionDefinition::StopInteractionOnMontageBlendingOut' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, StopInteractionOnTimerExpire) == 0x000329, "Member 'UInteractionDefinition::StopInteractionOnTimerExpire' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, StopInteractionOnHeightDelta) == 0x00032A, "Member 'UInteractionDefinition::StopInteractionOnHeightDelta' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, StopEnterMontageOnExit) == 0x00032B, "Member 'UInteractionDefinition::StopEnterMontageOnExit' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, StopUpdateMontageOnExit) == 0x00032C, "Member 'UInteractionDefinition::StopUpdateMontageOnExit' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, IgnoreStrafeAnimFix) == 0x00032D, "Member 'UInteractionDefinition::IgnoreStrafeAnimFix' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, InteractionAnimation) == 0x00032E, "Member 'UInteractionDefinition::InteractionAnimation' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SurvivorCanInteract) == 0x00032F, "Member 'UInteractionDefinition::SurvivorCanInteract' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, KillerCanInteract) == 0x000330, "Member 'UInteractionDefinition::KillerCanInteract' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, AllowInputPersistence) == 0x000331, "Member 'UInteractionDefinition::AllowInputPersistence' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SnapPosition) == 0x000332, "Member 'UInteractionDefinition::SnapPosition' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SweepOnFinalSnap) == 0x000333, "Member 'UInteractionDefinition::SweepOnFinalSnap' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SnapRotation) == 0x000334, "Member 'UInteractionDefinition::SnapRotation' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SnapStopDistance) == 0x000338, "Member 'UInteractionDefinition::SnapStopDistance' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, TestClearPathDuringSnap) == 0x00033C, "Member 'UInteractionDefinition::TestClearPathDuringSnap' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, MustBeClosestPlayerToSnapPoint) == 0x00033D, "Member 'UInteractionDefinition::MustBeClosestPlayerToSnapPoint' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CheckInteractableIsInPlayerView) == 0x00033E, "Member 'UInteractionDefinition::CheckInteractableIsInPlayerView' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CheckInteractableInViewSphereSweepRadius) == 0x000340, "Member 'UInteractionDefinition::CheckInteractableInViewSphereSweepRadius' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CheckInteractableInViewOffset) == 0x000348, "Member 'UInteractionDefinition::CheckInteractableInViewOffset' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CheckInteractableInViewOffsetDistanceToHitPoint) == 0x000360, "Member 'UInteractionDefinition::CheckInteractableInViewOffsetDistanceToHitPoint' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, IsInterruptibleIfTestClearPathDuringSnapFails) == 0x000364, "Member 'UInteractionDefinition::IsInterruptibleIfTestClearPathDuringSnapFails' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, TestPlayerOrientationOnSnap) == 0x000365, "Member 'UInteractionDefinition::TestPlayerOrientationOnSnap' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ScaleEnterAnimationToTime) == 0x000366, "Member 'UInteractionDefinition::ScaleEnterAnimationToTime' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ScaleMainAnimationToTime) == 0x000367, "Member 'UInteractionDefinition::ScaleMainAnimationToTime' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ScaleExitAnimationToTime) == 0x000368, "Member 'UInteractionDefinition::ScaleExitAnimationToTime' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SnapBackType) == 0x000369, "Member 'UInteractionDefinition::SnapBackType' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SnapBackPositionType) == 0x00036A, "Member 'UInteractionDefinition::SnapBackPositionType' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SnapBackPositionOffset) == 0x000370, "Member 'UInteractionDefinition::SnapBackPositionOffset' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SnapToInitialRotationDuringSnapBack) == 0x000380, "Member 'UInteractionDefinition::SnapToInitialRotationDuringSnapBack' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, UseStartSnapTimeForSnapExitTime) == 0x000381, "Member 'UInteractionDefinition::UseStartSnapTimeForSnapExitTime' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanInteractWhileIncapacitated) == 0x000382, "Member 'UInteractionDefinition::CanInteractWhileIncapacitated' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanInteractWhileCloaked) == 0x000383, "Member 'UInteractionDefinition::CanInteractWhileCloaked' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanInteractWhileAttacking) == 0x000384, "Member 'UInteractionDefinition::CanInteractWhileAttacking' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanInteractWhileChainLinked) == 0x000385, "Member 'UInteractionDefinition::CanInteractWhileChainLinked' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanInteractWhileShocked) == 0x000386, "Member 'UInteractionDefinition::CanInteractWhileShocked' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanInteractWhileUnhookingSelf) == 0x000387, "Member 'UInteractionDefinition::CanInteractWhileUnhookingSelf' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanSurvivorsInteractWhileFalling) == 0x000388, "Member 'UInteractionDefinition::CanSurvivorsInteractWhileFalling' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanInteractWhileCarrying) == 0x000389, "Member 'UInteractionDefinition::CanInteractWhileCarrying' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, AllowNavigation) == 0x00038A, "Member 'UInteractionDefinition::AllowNavigation' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, AllowNavigationInput) == 0x00038B, "Member 'UInteractionDefinition::AllowNavigationInput' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, AllowRotation) == 0x00038C, "Member 'UInteractionDefinition::AllowRotation' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, UseCameraMontageMode) == 0x00038D, "Member 'UInteractionDefinition::UseCameraMontageMode' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, OwnerBlocksAttack) == 0x00038E, "Member 'UInteractionDefinition::OwnerBlocksAttack' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, IsHighPriority) == 0x00038F, "Member 'UInteractionDefinition::IsHighPriority' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, AllowOverridingWhenNotForced) == 0x000390, "Member 'UInteractionDefinition::AllowOverridingWhenNotForced' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, IgnoreOverlapOnInteractable) == 0x000391, "Member 'UInteractionDefinition::IgnoreOverlapOnInteractable' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, UseAuthoritativeMovement) == 0x000392, "Member 'UInteractionDefinition::UseAuthoritativeMovement' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanBeAuthoritativePushedDuringEnter) == 0x000393, "Member 'UInteractionDefinition::CanBeAuthoritativePushedDuringEnter' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanBeAuthoritativePushedDuringUpdate) == 0x000394, "Member 'UInteractionDefinition::CanBeAuthoritativePushedDuringUpdate' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanBeAuthoritativePushedDuringExit) == 0x000395, "Member 'UInteractionDefinition::CanBeAuthoritativePushedDuringExit' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanAuthoritativePush) == 0x000396, "Member 'UInteractionDefinition::CanAuthoritativePush' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CancelOnHit) == 0x000397, "Member 'UInteractionDefinition::CancelOnHit' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CancelOnAttack) == 0x000398, "Member 'UInteractionDefinition::CancelOnAttack' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, HideItem) == 0x000399, "Member 'UInteractionDefinition::HideItem' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ContinueCachingLastSafeItemDropLocation) == 0x00039A, "Member 'UInteractionDefinition::ContinueCachingLastSafeItemDropLocation' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, AutoBindToParentInteractor) == 0x00039B, "Member 'UInteractionDefinition::AutoBindToParentInteractor' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, AutoBindToParentZone) == 0x00039C, "Member 'UInteractionDefinition::AutoBindToParentZone' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CancelOnMoveInitialDelay) == 0x0003A0, "Member 'UInteractionDefinition::CancelOnMoveInitialDelay' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CancelOnMoveInput) == 0x0003A4, "Member 'UInteractionDefinition::CancelOnMoveInput' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CancelOnMoveInputOnlyWhenRunning) == 0x0003A8, "Member 'UInteractionDefinition::CancelOnMoveInputOnlyWhenRunning' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanCrouch) == 0x0003AA, "Member 'UInteractionDefinition::CanCrouch' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, AffectsStillness) == 0x0003AB, "Member 'UInteractionDefinition::AffectsStillness' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, BlockSelfInteract) == 0x0003AD, "Member 'UInteractionDefinition::BlockSelfInteract' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, InteractionTime) == 0x0003B0, "Member 'UInteractionDefinition::InteractionTime' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, interactionInputType) == 0x0003B4, "Member 'UInteractionDefinition::interactionInputType' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, NoInputInteraction) == 0x0003B5, "Member 'UInteractionDefinition::NoInputInteraction' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, StopInteractionOnInputRelease) == 0x0003B6, "Member 'UInteractionDefinition::StopInteractionOnInputRelease' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, AllowHitMontageWhenInteracting) == 0x0003B7, "Member 'UInteractionDefinition::AllowHitMontageWhenInteracting' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ShowBasicInteractionIcon) == 0x0003B8, "Member 'UInteractionDefinition::ShowBasicInteractionIcon' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, HideItemIcon) == 0x0003B9, "Member 'UInteractionDefinition::HideItemIcon' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _interruptionDefinitions) == 0x0003C0, "Member 'UInteractionDefinition::_interruptionDefinitions' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, OnInteractionEnteredDelegate) == 0x0003D0, "Member 'UInteractionDefinition::OnInteractionEnteredDelegate' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, OnInteractionFinishedDelegate) == 0x000410, "Member 'UInteractionDefinition::OnInteractionFinishedDelegate' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SecondaryActionInputType) == 0x000449, "Member 'UInteractionDefinition::SecondaryActionInputType' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, NavigationSpeedCurveEnter) == 0x000468, "Member 'UInteractionDefinition::NavigationSpeedCurveEnter' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, NavigationSpeedCurve) == 0x000470, "Member 'UInteractionDefinition::NavigationSpeedCurve' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, NavigationSpeedCurveExit) == 0x000478, "Member 'UInteractionDefinition::NavigationSpeedCurveExit' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _shouldCheckInteractedUpon) == 0x000480, "Member 'UInteractionDefinition::_shouldCheckInteractedUpon' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, OwnershipUsability) == 0x000481, "Member 'UInteractionDefinition::OwnershipUsability' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ExitInteractionTime) == 0x000484, "Member 'UInteractionDefinition::ExitInteractionTime' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ApplyModifiersToExitTime) == 0x000488, "Member 'UInteractionDefinition::ApplyModifiersToExitTime' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, InteractionDescriptionText) == 0x000490, "Member 'UInteractionDefinition::InteractionDescriptionText' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, DisabledInputPromptText) == 0x0004A8, "Member 'UInteractionDefinition::DisabledInputPromptText' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, InteractionCanBeToggled) == 0x0004C0, "Member 'UInteractionDefinition::InteractionCanBeToggled' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, IsOverridingInputToggleReleasePromptMessage) == 0x0004C1, "Member 'UInteractionDefinition::IsOverridingInputToggleReleasePromptMessage' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, InputToggleReleasePromptMessage) == 0x0004C8, "Member 'UInteractionDefinition::InputToggleReleasePromptMessage' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, IgnoreSprintToCancelSetting) == 0x0004D8, "Member 'UInteractionDefinition::IgnoreSprintToCancelSetting' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ForceWithSprintToCancelSetting) == 0x0004D9, "Member 'UInteractionDefinition::ForceWithSprintToCancelSetting' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, InteractionHeightDeltaMax) == 0x0004DC, "Member 'UInteractionDefinition::InteractionHeightDeltaMax' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, MaximumVelocity) == 0x0004E0, "Member 'UInteractionDefinition::MaximumVelocity' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, EnterMontage) == 0x0004E8, "Member 'UInteractionDefinition::EnterMontage' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, UpdateMontage) == 0x000508, "Member 'UInteractionDefinition::UpdateMontage' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ExitMontage) == 0x000528, "Member 'UInteractionDefinition::ExitMontage' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, EnterMontageVariantCycle) == 0x000548, "Member 'UInteractionDefinition::EnterMontageVariantCycle' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, UpdateMontageVariantCycle) == 0x000558, "Member 'UInteractionDefinition::UpdateMontageVariantCycle' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ExitMontageVariantCycle) == 0x000568, "Member 'UInteractionDefinition::ExitMontageVariantCycle' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SnapSocketName) == 0x000578, "Member 'UInteractionDefinition::SnapSocketName' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _canBeAttachedToAnyZone) == 0x000584, "Member 'UInteractionDefinition::_canBeAttachedToAnyZone' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _isInterruptibleBySacrifice) == 0x000585, "Member 'UInteractionDefinition::_isInterruptibleBySacrifice' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, IgnoreStun) == 0x000586, "Member 'UInteractionDefinition::IgnoreStun' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _tags) == 0x000588, "Member 'UInteractionDefinition::_tags' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _objectStateTag) == 0x0005A8, "Member 'UInteractionDefinition::_objectStateTag' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _secondaryInteractions) == 0x0005B8, "Member 'UInteractionDefinition::_secondaryInteractions' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _useHoldPrompt) == 0x000608, "Member 'UInteractionDefinition::_useHoldPrompt' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _allowInteractionInNarrowSpaces) == 0x000609, "Member 'UInteractionDefinition::_allowInteractionInNarrowSpaces' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _allowIKSensorDuringInteraction) == 0x00060A, "Member 'UInteractionDefinition::_allowIKSensorDuringInteraction' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _activationDefinition) == 0x000630, "Member 'UInteractionDefinition::_activationDefinition' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _startUpdateMontageDuringEnter) == 0x000658, "Member 'UInteractionDefinition::_startUpdateMontageDuringEnter' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _interactor) == 0x000660, "Member 'UInteractionDefinition::_interactor' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _mutuallyExclusiveInteractionsClient) == 0x000668, "Member 'UInteractionDefinition::_mutuallyExclusiveInteractionsClient' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _zone) == 0x000678, "Member 'UInteractionDefinition::_zone' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _cancelInputType) == 0x000680, "Member 'UInteractionDefinition::_cancelInputType' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _preventingTags) == 0x000688, "Member 'UInteractionDefinition::_preventingTags' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _evaluatingInteractionHandlers) == 0x0006C8, "Member 'UInteractionDefinition::_evaluatingInteractionHandlers' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, DEPRECATED_SecondaryInteractionProperties) == 0x0006D8, "Member 'UInteractionDefinition::DEPRECATED_SecondaryInteractionProperties' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _interactionIconPromptOverride) == 0x000710, "Member 'UInteractionDefinition::_interactionIconPromptOverride' has a wrong offset!");

// Class DeadByDaylight.LanternLightCollectable
// 0x0008 (0x0560 - 0x0558)
class ALanternLightCollectable final : public ACollectable
{
public:
	class ALanternInteractable*                   _parentLantern;                                    // 0x0558(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetParentLantern(class ALanternInteractable* parentLantern);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LanternLightCollectable">();
	}
	static class ALanternLightCollectable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALanternLightCollectable>();
	}
};
static_assert(alignof(ALanternLightCollectable) == 0x000008, "Wrong alignment on ALanternLightCollectable");
static_assert(sizeof(ALanternLightCollectable) == 0x000560, "Wrong size on ALanternLightCollectable");
static_assert(offsetof(ALanternLightCollectable, _parentLantern) == 0x000558, "Member 'ALanternLightCollectable::_parentLantern' has a wrong offset!");

// Class DeadByDaylight.GameFlowContextSystem
// 0x00A0 (0x00D8 - 0x0038)
class UGameFlowContextSystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x88];                                      // 0x0038(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	class URootMovie*                             m_RootMovie;                                       // 0x00C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x10];                                      // 0x00C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameFlowContextSystem">();
	}
	static class UGameFlowContextSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameFlowContextSystem>();
	}
};
static_assert(alignof(UGameFlowContextSystem) == 0x000008, "Wrong alignment on UGameFlowContextSystem");
static_assert(sizeof(UGameFlowContextSystem) == 0x0000D8, "Wrong size on UGameFlowContextSystem");
static_assert(offsetof(UGameFlowContextSystem, m_RootMovie) == 0x0000C0, "Member 'UGameFlowContextSystem::m_RootMovie' has a wrong offset!");

// Class DeadByDaylight.Competence
// 0x00C0 (0x0320 - 0x0260)
class UCompetence : public UGameplayModifierContainer
{
public:
	uint8                                         Pad_260[0x30];                                     // 0x0260(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UBasePerkIconStrategy>      PerkIconStrategyClass;                             // 0x0290(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_298[0x18];                                     // 0x0298(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool Disabled)> OnPermanentlyDisabledBP;                           // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0[0x18];                                     // 0x02C0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(int32 tokenCount)> OnTokenCountChangedBP;                          // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UTimerObject*                           _cooldownTimer;                                    // 0x02E8(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F0[0x8];                                      // 0x02F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimerObject*                           _hudIconTimer;                                     // 0x02F8(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          SetInactiveDuringCooldown;                         // 0x0300(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_301[0x7];                                      // 0x0301(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBasePerkIconStrategy*                  _perkIconStrategy;                                 // 0x0308(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isDisabled;                                       // 0x0310(0x0001)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_311[0x3];                                      // 0x0311(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _tokenCount;                                       // 0x0314(0x0004)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _maxTokenCount;                                    // 0x0318(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPerkTokenSoundStrategy                       _tokenSoundStrategy;                               // 0x031C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31D[0x3];                                      // 0x031D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_DecrementToken();
	void Authority_IncrementToken();
	void Authority_SetMaxTokenCount(int32 Value);
	void Authority_SetPermanentlyDisabled(bool Disabled);
	void Authority_SetTokenCount(int32 Value);
	void Authority_TriggerCooldownTimer(const float Duration);
	void Authority_TriggerHudIconTimer(float Duration);
	void OnRep_IsDisabled(bool Disabled);
	void OnRep_TokenCount(int32 oldCount);

	class UTimerObject* GetCooldownTimer() const;
	float GetHudIconTimerElapsedTimePercent() const;
	float GetHudIconTimerRemainingTime() const;
	int32 GetMaxTokenCount() const;
	class UBasePerkIconStrategy* GetPerkIconStrategy() const;
	int32 GetTokenCount() const;
	bool IsCooldownTimerDone() const;
	bool IsHudIconTimerActive() const;
	bool IsHudIconTimerDone() const;
	bool IsPermanentlyDisabled() const;
	void OnRep_CooldownTimer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Competence">();
	}
	static class UCompetence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCompetence>();
	}
};
static_assert(alignof(UCompetence) == 0x000008, "Wrong alignment on UCompetence");
static_assert(sizeof(UCompetence) == 0x000320, "Wrong size on UCompetence");
static_assert(offsetof(UCompetence, PerkIconStrategyClass) == 0x000290, "Member 'UCompetence::PerkIconStrategyClass' has a wrong offset!");
static_assert(offsetof(UCompetence, OnPermanentlyDisabledBP) == 0x0002B0, "Member 'UCompetence::OnPermanentlyDisabledBP' has a wrong offset!");
static_assert(offsetof(UCompetence, OnTokenCountChangedBP) == 0x0002D8, "Member 'UCompetence::OnTokenCountChangedBP' has a wrong offset!");
static_assert(offsetof(UCompetence, _cooldownTimer) == 0x0002E8, "Member 'UCompetence::_cooldownTimer' has a wrong offset!");
static_assert(offsetof(UCompetence, _hudIconTimer) == 0x0002F8, "Member 'UCompetence::_hudIconTimer' has a wrong offset!");
static_assert(offsetof(UCompetence, SetInactiveDuringCooldown) == 0x000300, "Member 'UCompetence::SetInactiveDuringCooldown' has a wrong offset!");
static_assert(offsetof(UCompetence, _perkIconStrategy) == 0x000308, "Member 'UCompetence::_perkIconStrategy' has a wrong offset!");
static_assert(offsetof(UCompetence, _isDisabled) == 0x000310, "Member 'UCompetence::_isDisabled' has a wrong offset!");
static_assert(offsetof(UCompetence, _tokenCount) == 0x000314, "Member 'UCompetence::_tokenCount' has a wrong offset!");
static_assert(offsetof(UCompetence, _maxTokenCount) == 0x000318, "Member 'UCompetence::_maxTokenCount' has a wrong offset!");
static_assert(offsetof(UCompetence, _tokenSoundStrategy) == 0x00031C, "Member 'UCompetence::_tokenSoundStrategy' has a wrong offset!");

// Class DeadByDaylight.Perk
// 0x0140 (0x0460 - 0x0320)
class UPerk : public UCompetence
{
public:
	uint8                                         Pad_320[0x30];                                     // 0x0320(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayModifierData                  PerkLevelData[0x3];                                // 0x0350(0x0030)(Edit, Net, EditFixedSize, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E0[0x60];                                     // 0x03E0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isUsable;                                         // 0x0440(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _keepImposedStatusEffectsOnEndPlay;                // 0x0441(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          BroadcastWhenApplicable;                           // 0x0442(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          BroadcastOnTimer;                                  // 0x0443(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          BroadcastCooldownTimer;                            // 0x0444(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          BroadcastInactiveCooldownTimer;                    // 0x0445(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          BroadcastAlways;                                   // 0x0446(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_447[0x1];                                      // 0x0447(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPerkInitializationData                _perkInitializationData;                           // 0x0448(0x0008)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_450[0x8];                                      // 0x0450(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionDefinition*                 _activatableInteraction;                           // 0x0458(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_SetIsUsable(bool Value);
	void FireActivePerkEvent(const float Percentage, const int32 chargeCount);
	struct FGameplayModifierData GetGameplayModifierData();
	void OnRep_PerkInitializationData();
	void SetIsUsable(bool Value);

	bool GetIsUsable() const;
	int32 GetPerkLevel() const;
	void OnRep_IsUsable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Perk">();
	}
	static class UPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerk>();
	}
};
static_assert(alignof(UPerk) == 0x000008, "Wrong alignment on UPerk");
static_assert(sizeof(UPerk) == 0x000460, "Wrong size on UPerk");
static_assert(offsetof(UPerk, PerkLevelData) == 0x000350, "Member 'UPerk::PerkLevelData' has a wrong offset!");
static_assert(offsetof(UPerk, _isUsable) == 0x000440, "Member 'UPerk::_isUsable' has a wrong offset!");
static_assert(offsetof(UPerk, _keepImposedStatusEffectsOnEndPlay) == 0x000441, "Member 'UPerk::_keepImposedStatusEffectsOnEndPlay' has a wrong offset!");
static_assert(offsetof(UPerk, BroadcastWhenApplicable) == 0x000442, "Member 'UPerk::BroadcastWhenApplicable' has a wrong offset!");
static_assert(offsetof(UPerk, BroadcastOnTimer) == 0x000443, "Member 'UPerk::BroadcastOnTimer' has a wrong offset!");
static_assert(offsetof(UPerk, BroadcastCooldownTimer) == 0x000444, "Member 'UPerk::BroadcastCooldownTimer' has a wrong offset!");
static_assert(offsetof(UPerk, BroadcastInactiveCooldownTimer) == 0x000445, "Member 'UPerk::BroadcastInactiveCooldownTimer' has a wrong offset!");
static_assert(offsetof(UPerk, BroadcastAlways) == 0x000446, "Member 'UPerk::BroadcastAlways' has a wrong offset!");
static_assert(offsetof(UPerk, _perkInitializationData) == 0x000448, "Member 'UPerk::_perkInitializationData' has a wrong offset!");
static_assert(offsetof(UPerk, _activatableInteraction) == 0x000458, "Member 'UPerk::_activatableInteraction' has a wrong offset!");

// Class DeadByDaylight.DBDGameViewportClient
// 0x0068 (0x0438 - 0x03D0)
class UDBDGameViewportClient final : public UGameViewportClient
{
public:
	uint8                                         Pad_3D0[0x68];                                     // 0x03D0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGameViewportClient">();
	}
	static class UDBDGameViewportClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDGameViewportClient>();
	}
};
static_assert(alignof(UDBDGameViewportClient) == 0x000008, "Wrong alignment on UDBDGameViewportClient");
static_assert(sizeof(UDBDGameViewportClient) == 0x000438, "Wrong size on UDBDGameViewportClient");

// Class DeadByDaylight.CompetenceAction
// 0x0010 (0x0040 - 0x0030)
class UCompetenceAction : public UObject
{
public:
	class UGameplayModifierContainer*             _owningContainer;                                  // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnApplyBegin();
	void OnApplyEnd();

	class ADBDPlayer* GetOwningPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CompetenceAction">();
	}
	static class UCompetenceAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCompetenceAction>();
	}
};
static_assert(alignof(UCompetenceAction) == 0x000008, "Wrong alignment on UCompetenceAction");
static_assert(sizeof(UCompetenceAction) == 0x000040, "Wrong size on UCompetenceAction");
static_assert(offsetof(UCompetenceAction, _owningContainer) == 0x000030, "Member 'UCompetenceAction::_owningContainer' has a wrong offset!");

// Class DeadByDaylight.LimitedTimeGameModeManager
// 0x0058 (0x0090 - 0x0038)
class ULimitedTimeGameModeManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x58];                                      // 0x0038(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LimitedTimeGameModeManager">();
	}
	static class ULimitedTimeGameModeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULimitedTimeGameModeManager>();
	}
};
static_assert(alignof(ULimitedTimeGameModeManager) == 0x000008, "Wrong alignment on ULimitedTimeGameModeManager");
static_assert(sizeof(ULimitedTimeGameModeManager) == 0x000090, "Wrong size on ULimitedTimeGameModeManager");

// Class DeadByDaylight.BaseSpawnConditionStrategy
// 0x0000 (0x0030 - 0x0030)
class UBaseSpawnConditionStrategy : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseSpawnConditionStrategy">();
	}
	static class UBaseSpawnConditionStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseSpawnConditionStrategy>();
	}
};
static_assert(alignof(UBaseSpawnConditionStrategy) == 0x000008, "Wrong alignment on UBaseSpawnConditionStrategy");
static_assert(sizeof(UBaseSpawnConditionStrategy) == 0x000030, "Wrong size on UBaseSpawnConditionStrategy");

// Class DeadByDaylight.DBDRemotePlayer
// 0x0000 (0x1E68 - 0x1E68)
class UDBDRemotePlayer final : public UIpConnection
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDRemotePlayer">();
	}
	static class UDBDRemotePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDRemotePlayer>();
	}
};
static_assert(alignof(UDBDRemotePlayer) == 0x000008, "Wrong alignment on UDBDRemotePlayer");
static_assert(sizeof(UDBDRemotePlayer) == 0x001E68, "Wrong size on UDBDRemotePlayer");

// Class DeadByDaylight.Skill
// 0x0068 (0x0388 - 0x0320)
class USkill : public UCompetence
{
public:
	struct FGameplayModifierData                  ModifierData;                                      // 0x0320(0x0030)(Edit, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_350[0x30];                                     // 0x0350(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSkillInitializationData               _skillInitializationData;                          // 0x0380(0x0001)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_381[0x7];                                      // 0x0381(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_SkillInitializationData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Skill">();
	}
	static class USkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkill>();
	}
};
static_assert(alignof(USkill) == 0x000008, "Wrong alignment on USkill");
static_assert(sizeof(USkill) == 0x000388, "Wrong size on USkill");
static_assert(offsetof(USkill, ModifierData) == 0x000320, "Member 'USkill::ModifierData' has a wrong offset!");
static_assert(offsetof(USkill, _skillInitializationData) == 0x000380, "Member 'USkill::_skillInitializationData' has a wrong offset!");

// Class DeadByDaylight.AnimationPreview
// 0x00F8 (0x0128 - 0x0030)
class UAnimationPreview : public UObject
{
public:
	TArray<struct FAnimationPreviewCharacter>     Characters;                                        // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAnimationPreviewProp>          Props;                                             // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x38];                                      // 0x0050(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimationPreviewRequest               _request;                                          // 0x0088(0x0068)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x38];                                      // 0x00F0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnimationStartFadeOutComplete();
	void OnFadeInComplete();
	void OnFadeOutForCompletionComplete(bool Succeeded);
	void OnRequiredClassesLoaded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationPreview">();
	}
	static class UAnimationPreview* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimationPreview>();
	}
};
static_assert(alignof(UAnimationPreview) == 0x000008, "Wrong alignment on UAnimationPreview");
static_assert(sizeof(UAnimationPreview) == 0x000128, "Wrong size on UAnimationPreview");
static_assert(offsetof(UAnimationPreview, Characters) == 0x000030, "Member 'UAnimationPreview::Characters' has a wrong offset!");
static_assert(offsetof(UAnimationPreview, Props) == 0x000040, "Member 'UAnimationPreview::Props' has a wrong offset!");
static_assert(offsetof(UAnimationPreview, _request) == 0x000088, "Member 'UAnimationPreview::_request' has a wrong offset!");

// Class DeadByDaylight.InteractionAnimationPreview
// 0x0008 (0x0130 - 0x0128)
class UInteractionAnimationPreview : public UAnimationPreview
{
public:
	class UInteractionDefinition*                 _interactionDefinition;                            // 0x0128(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnInteractionFinished(class ADBDPlayer* Player, bool didInteractionStart);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionAnimationPreview">();
	}
	static class UInteractionAnimationPreview* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionAnimationPreview>();
	}
};
static_assert(alignof(UInteractionAnimationPreview) == 0x000008, "Wrong alignment on UInteractionAnimationPreview");
static_assert(sizeof(UInteractionAnimationPreview) == 0x000130, "Wrong size on UInteractionAnimationPreview");
static_assert(offsetof(UInteractionAnimationPreview, _interactionDefinition) == 0x000128, "Member 'UInteractionAnimationPreview::_interactionDefinition' has a wrong offset!");

// Class DeadByDaylight.MoriAnimationPreview
// 0x0058 (0x0188 - 0x0130)
class UMoriAnimationPreview : public UInteractionAnimationPreview
{
public:
	uint8                                         Pad_130[0x58];                                     // 0x0130(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAudioEventFinished(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoriAnimationPreview">();
	}
	static class UMoriAnimationPreview* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoriAnimationPreview>();
	}
};
static_assert(alignof(UMoriAnimationPreview) == 0x000008, "Wrong alignment on UMoriAnimationPreview");
static_assert(sizeof(UMoriAnimationPreview) == 0x000188, "Wrong size on UMoriAnimationPreview");

// Class DeadByDaylight.SurvivorCollectableOutlineUpdateStrategy
// 0x0030 (0x0110 - 0x00E0)
class USurvivorCollectableOutlineUpdateStrategy : public UOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _outlineColor;                                     // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _nearlyConsumedColor;                              // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _yellowOutlineColor;                               // 0x0100(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorCollectableOutlineUpdateStrategy">();
	}
	static class USurvivorCollectableOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorCollectableOutlineUpdateStrategy>();
	}
};
static_assert(alignof(USurvivorCollectableOutlineUpdateStrategy) == 0x000008, "Wrong alignment on USurvivorCollectableOutlineUpdateStrategy");
static_assert(sizeof(USurvivorCollectableOutlineUpdateStrategy) == 0x000110, "Wrong size on USurvivorCollectableOutlineUpdateStrategy");
static_assert(offsetof(USurvivorCollectableOutlineUpdateStrategy, _outlineColor) == 0x0000E0, "Member 'USurvivorCollectableOutlineUpdateStrategy::_outlineColor' has a wrong offset!");
static_assert(offsetof(USurvivorCollectableOutlineUpdateStrategy, _nearlyConsumedColor) == 0x0000F0, "Member 'USurvivorCollectableOutlineUpdateStrategy::_nearlyConsumedColor' has a wrong offset!");
static_assert(offsetof(USurvivorCollectableOutlineUpdateStrategy, _yellowOutlineColor) == 0x000100, "Member 'USurvivorCollectableOutlineUpdateStrategy::_yellowOutlineColor' has a wrong offset!");

// Class DeadByDaylight.UMGHudEditorLayoutScreen
// 0x0010 (0x02B8 - 0x02A8)
class UUMGHudEditorLayoutScreen final : public UUserWidget
{
public:
	TArray<class UUMGDragWidget_HudEditor*>       _editableWidgets;                                  // 0x02A8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGHudEditorLayoutScreen">();
	}
	static class UUMGHudEditorLayoutScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGHudEditorLayoutScreen>();
	}
};
static_assert(alignof(UUMGHudEditorLayoutScreen) == 0x000008, "Wrong alignment on UUMGHudEditorLayoutScreen");
static_assert(sizeof(UUMGHudEditorLayoutScreen) == 0x0002B8, "Wrong size on UUMGHudEditorLayoutScreen");
static_assert(offsetof(UUMGHudEditorLayoutScreen, _editableWidgets) == 0x0002A8, "Member 'UUMGHudEditorLayoutScreen::_editableWidgets' has a wrong offset!");

// Class DeadByDaylight.LightFollower
// 0x0030 (0x00E8 - 0x00B8)
class ULightFollower final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x30];                                      // 0x00B8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddFollower(class ULightComponent* Follower);
	void SetLeader(class ULightComponent* Leader, float maxIntensity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightFollower">();
	}
	static class ULightFollower* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightFollower>();
	}
};
static_assert(alignof(ULightFollower) == 0x000008, "Wrong alignment on ULightFollower");
static_assert(sizeof(ULightFollower) == 0x0000E8, "Wrong size on ULightFollower");

// Class DeadByDaylight.OfferingSequenceAssets
// 0x0030 (0x02D0 - 0x02A0)
class AOfferingSequenceAssets final : public AActor
{
public:
	float                                         SpaceBetweenCards;                                 // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AOfferingCard>              DefaultCardClass;                                  // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UOfferingCardAnim>          DefaultCardAnimation;                              // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOfferingRevealDelays>          OfferingRevealDelays;                              // 0x02B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class AActor*                                 CardsParent;                                       // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void PlayFadeIn();
	void PlayFadeOut();
	void PlaySmoke();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OfferingSequenceAssets">();
	}
	static class AOfferingSequenceAssets* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOfferingSequenceAssets>();
	}
};
static_assert(alignof(AOfferingSequenceAssets) == 0x000008, "Wrong alignment on AOfferingSequenceAssets");
static_assert(sizeof(AOfferingSequenceAssets) == 0x0002D0, "Wrong size on AOfferingSequenceAssets");
static_assert(offsetof(AOfferingSequenceAssets, SpaceBetweenCards) == 0x0002A0, "Member 'AOfferingSequenceAssets::SpaceBetweenCards' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceAssets, DefaultCardClass) == 0x0002A8, "Member 'AOfferingSequenceAssets::DefaultCardClass' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceAssets, DefaultCardAnimation) == 0x0002B0, "Member 'AOfferingSequenceAssets::DefaultCardAnimation' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceAssets, OfferingRevealDelays) == 0x0002B8, "Member 'AOfferingSequenceAssets::OfferingRevealDelays' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceAssets, CardsParent) == 0x0002C8, "Member 'AOfferingSequenceAssets::CardsParent' has a wrong offset!");

// Class DeadByDaylight.DBDMenuSilhouette
// 0x0000 (0x02A0 - 0x02A0)
class ADBDMenuSilhouette final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDMenuSilhouette">();
	}
	static class ADBDMenuSilhouette* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDMenuSilhouette>();
	}
};
static_assert(alignof(ADBDMenuSilhouette) == 0x000008, "Wrong alignment on ADBDMenuSilhouette");
static_assert(sizeof(ADBDMenuSilhouette) == 0x0002A0, "Wrong size on ADBDMenuSilhouette");

// Class DeadByDaylight.OfferingSequenceManager
// 0x00C0 (0x0360 - 0x02A0)
class AOfferingSequenceManager : public AActor
{
public:
	class UDBDGameInstance*                       _gameInstance;                                     // 0x02A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerController*                      _localPlayerController;                            // 0x02A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOfferingHandler*                       _offeringHandler;                                  // 0x02B0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOfferingSequenceAssets*                _sequenceAssets;                                   // 0x02B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDLobbyHud*                           _hud;                                              // 0x02C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACameraActor*                           _offeringCamera;                                   // 0x02C8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<uint8, class AOfferingCard*>             _spawnedCards;                                     // 0x02D0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_320[0x10];                                     // 0x0320(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AOfferingCard>              _defaultCardsClass;                                // 0x0330(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AOfferingCard>              _eventCardsClass;                                  // 0x0338(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_340[0x20];                                     // 0x0340(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FadeInScreen();
	void HandleSequenceEnded();
	void HandleSequenceStarted();
	void HandleSequenceStateChanged(EOfferingSequenceState State);

	bool ContainsDefaultCard() const;
	bool ContainsEventCard() const;
	EOfferingSequenceState GetCurrentState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OfferingSequenceManager">();
	}
	static class AOfferingSequenceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOfferingSequenceManager>();
	}
};
static_assert(alignof(AOfferingSequenceManager) == 0x000008, "Wrong alignment on AOfferingSequenceManager");
static_assert(sizeof(AOfferingSequenceManager) == 0x000360, "Wrong size on AOfferingSequenceManager");
static_assert(offsetof(AOfferingSequenceManager, _gameInstance) == 0x0002A0, "Member 'AOfferingSequenceManager::_gameInstance' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceManager, _localPlayerController) == 0x0002A8, "Member 'AOfferingSequenceManager::_localPlayerController' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceManager, _offeringHandler) == 0x0002B0, "Member 'AOfferingSequenceManager::_offeringHandler' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceManager, _sequenceAssets) == 0x0002B8, "Member 'AOfferingSequenceManager::_sequenceAssets' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceManager, _hud) == 0x0002C0, "Member 'AOfferingSequenceManager::_hud' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceManager, _offeringCamera) == 0x0002C8, "Member 'AOfferingSequenceManager::_offeringCamera' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceManager, _spawnedCards) == 0x0002D0, "Member 'AOfferingSequenceManager::_spawnedCards' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceManager, _defaultCardsClass) == 0x000330, "Member 'AOfferingSequenceManager::_defaultCardsClass' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceManager, _eventCardsClass) == 0x000338, "Member 'AOfferingSequenceManager::_eventCardsClass' has a wrong offset!");

// Class DeadByDaylight.ScreenBase
// 0x00F8 (0x0128 - 0x0030)
class UScreenBase : public UObject
{
public:
	bool                                          isAnimationDone;                                   // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGFxObject*                             ScreenObject;                                      // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScreenController*                      _screenController;                                 // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LocKeyResultMaxChars;                              // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0xDC];                                      // 0x004C(0x00DC)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastOnHighlightedElementClickedEvent(const class FName onBoardingID);
	void OnAnimationUpdate(int32 isAnimationDone_0);
	void OnAnyKey(float Code);
	void OnBack();
	void OnEscape();
	void OnHideVirtualKeyboardRequested();
	void OnNavKey(const class FString& navKey);
	void OnStart();
	void OnTextInputMouseClicked(bool IsPassword);

	void SetFadesOut(bool fadesOut) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenBase">();
	}
	static class UScreenBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenBase>();
	}
};
static_assert(alignof(UScreenBase) == 0x000008, "Wrong alignment on UScreenBase");
static_assert(sizeof(UScreenBase) == 0x000128, "Wrong size on UScreenBase");
static_assert(offsetof(UScreenBase, isAnimationDone) == 0x000030, "Member 'UScreenBase::isAnimationDone' has a wrong offset!");
static_assert(offsetof(UScreenBase, ScreenObject) == 0x000038, "Member 'UScreenBase::ScreenObject' has a wrong offset!");
static_assert(offsetof(UScreenBase, _screenController) == 0x000040, "Member 'UScreenBase::_screenController' has a wrong offset!");
static_assert(offsetof(UScreenBase, LocKeyResultMaxChars) == 0x000048, "Member 'UScreenBase::LocKeyResultMaxChars' has a wrong offset!");

// Class DeadByDaylight.BasePopupScreen
// 0x0000 (0x0128 - 0x0128)
class UBasePopupScreen : public UScreenBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePopupScreen">();
	}
	static class UBasePopupScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBasePopupScreen>();
	}
};
static_assert(alignof(UBasePopupScreen) == 0x000008, "Wrong alignment on UBasePopupScreen");
static_assert(sizeof(UBasePopupScreen) == 0x000128, "Wrong size on UBasePopupScreen");

// Class DeadByDaylight.AtlantaUtilities
// 0x0000 (0x0030 - 0x0030)
class UAtlantaUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class FText GetAlantaInteractionDescriptionText(class UInteractionDefinition* Interaction);
	static class UInteractionDefinition* GetAvailableInteractionOfType(class ADBDPlayer* Player, EInputInteractionType interactionInputType);
	static struct FSlateColor GetCurrencyColor(ECurrencyType currencyType);
	static class FString GetCurrencyUITexturePath(ECurrencyType currencyType);
	static class UInteractionDefinition* GetCurrentInteraction(class ADBDPlayer* Player);
	static class UInteractionDefinition* GetCurrentInteractionOfType(class ADBDPlayer* Player, EInputInteractionType interactionInputType);
	static class UInteractionDefinition* GetCurrentOrAvailableInteractionOfType(class ADBDPlayer* Player, EInputInteractionType interactionInputType);
	static class FText GetDifficultyLevelText(const EAIDifficultyLevel difficultyLevel);
	static class FText GetEmblemQualityText(const EEmblemQuality EmblemQuality);
	static class UTexture2D* GetIconImageByPath(const class FString& IconPath);
	static class FText GetItemAvailabilityText(const EItemAvailability Availability);
	static class FText GetItemRarityText(const EItemRarity Rarity);
	static class UPaperSprite* GetMapSpriteFromPath(const class FString& mapSpritePath);
	static class FText GetOfferingCategoryText(const EOfferingCategory OfferingCategory);
	static class FText GetPlayerRoleText(const EPlayerRole PlayerRole);
	static class FText GetPlayerRoleTextUppercase(const EPlayerRole PlayerRole);
	static class UPaperSprite* GetSpriteFromFullPath(const class FString& fullSpritePath);
	static class UPaperSprite* GetSpriteFromPath(const class FString& fullDbPathToImage, const class FString& constantDbPathToImageFolder, const class FString& constantPathToSpriteFolder);
	static bool IsPlayerInteractingWithActor(class ADBDPlayer* Player, const class AActor* Actor);
	static class UTexture2D* LoadTextureByAsset(const class FString& Path);
	static struct FSlateBrush MakeBrushFromSprite(class UPaperSprite* Sprite);
	static struct FSlateBrush MakeBrushFromTexture(class UTexture2D* Texture);
	static class FString SecondsToStringWithoutDecimals(const int32 Seconds);
	static void SetButtonStyle(class UButton* Button, const struct FSlateBrush& Brush);
	static void SetImageBrush(class UImage* Image, class UTexture2D* Asset, bool bMatchSize);
	static void SetImageBrushFromPath(class UImage* Image, const class FString& Path, bool bMatchSize);
	static void SetImageBrushFromSpritePath(class UImage* Image, const class FString& Path);
	static bool SetImageSlateBrush(class UImage* Image, const struct FSlateBrush& Brush, bool bMatchSize);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaUtilities">();
	}
	static class UAtlantaUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaUtilities>();
	}
};
static_assert(alignof(UAtlantaUtilities) == 0x000008, "Wrong alignment on UAtlantaUtilities");
static_assert(sizeof(UAtlantaUtilities) == 0x000030, "Wrong size on UAtlantaUtilities");

// Class DeadByDaylight.DBDBaseGameMode
// 0x0068 (0x0400 - 0x0398)
class ADBDBaseGameMode : public AGameMode
{
public:
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableDropdown                     DebugSpecialEvent;                                 // 0x03A0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	struct FDataTableDropdown                     DebugGameType;                                     // 0x03D0(0x0030)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBaseGameMode">();
	}
	static class ADBDBaseGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDBaseGameMode>();
	}
};
static_assert(alignof(ADBDBaseGameMode) == 0x000008, "Wrong alignment on ADBDBaseGameMode");
static_assert(sizeof(ADBDBaseGameMode) == 0x000400, "Wrong size on ADBDBaseGameMode");
static_assert(offsetof(ADBDBaseGameMode, DebugSpecialEvent) == 0x0003A0, "Member 'ADBDBaseGameMode::DebugSpecialEvent' has a wrong offset!");
static_assert(offsetof(ADBDBaseGameMode, DebugGameType) == 0x0003D0, "Member 'ADBDBaseGameMode::DebugGameType' has a wrong offset!");

// Class DeadByDaylight.DBDBaseMatchGameMode
// 0x0058 (0x0458 - 0x0400)
class ADBDBaseMatchGameMode : public ADBDBaseGameMode
{
public:
	TArray<TSubclassOf<class AGameObjectiveBase>> _gameObjectiveClasses;                             // 0x0400(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UBehaviourDetectionConfiguration> _behaviourDetectionConfiguration;         // 0x0410(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndGameComponent*                      _endGameComponent;                                 // 0x0448(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ANetworkFenceActor*                     _theFence;                                         // 0x0450(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UEndGameComponent* GetEndGameComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBaseMatchGameMode">();
	}
	static class ADBDBaseMatchGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDBaseMatchGameMode>();
	}
};
static_assert(alignof(ADBDBaseMatchGameMode) == 0x000008, "Wrong alignment on ADBDBaseMatchGameMode");
static_assert(sizeof(ADBDBaseMatchGameMode) == 0x000458, "Wrong size on ADBDBaseMatchGameMode");
static_assert(offsetof(ADBDBaseMatchGameMode, _gameObjectiveClasses) == 0x000400, "Member 'ADBDBaseMatchGameMode::_gameObjectiveClasses' has a wrong offset!");
static_assert(offsetof(ADBDBaseMatchGameMode, _behaviourDetectionConfiguration) == 0x000410, "Member 'ADBDBaseMatchGameMode::_behaviourDetectionConfiguration' has a wrong offset!");
static_assert(offsetof(ADBDBaseMatchGameMode, _endGameComponent) == 0x000448, "Member 'ADBDBaseMatchGameMode::_endGameComponent' has a wrong offset!");
static_assert(offsetof(ADBDBaseMatchGameMode, _theFence) == 0x000450, "Member 'ADBDBaseMatchGameMode::_theFence' has a wrong offset!");

// Class DeadByDaylight.BaseCameraTargetingStrategy
// 0x0020 (0x0050 - 0x0030)
class UBaseCameraTargetingStrategy : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _maxFreeAngle;                                     // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxInputRotation;                                 // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _interpolationSpeed;                               // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _interpolationSpeedOutsideFreeMoveZone;            // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 _target;                                           // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseCameraTargetingStrategy">();
	}
	static class UBaseCameraTargetingStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseCameraTargetingStrategy>();
	}
};
static_assert(alignof(UBaseCameraTargetingStrategy) == 0x000008, "Wrong alignment on UBaseCameraTargetingStrategy");
static_assert(sizeof(UBaseCameraTargetingStrategy) == 0x000050, "Wrong size on UBaseCameraTargetingStrategy");
static_assert(offsetof(UBaseCameraTargetingStrategy, _maxFreeAngle) == 0x000038, "Member 'UBaseCameraTargetingStrategy::_maxFreeAngle' has a wrong offset!");
static_assert(offsetof(UBaseCameraTargetingStrategy, _maxInputRotation) == 0x00003C, "Member 'UBaseCameraTargetingStrategy::_maxInputRotation' has a wrong offset!");
static_assert(offsetof(UBaseCameraTargetingStrategy, _interpolationSpeed) == 0x000040, "Member 'UBaseCameraTargetingStrategy::_interpolationSpeed' has a wrong offset!");
static_assert(offsetof(UBaseCameraTargetingStrategy, _interpolationSpeedOutsideFreeMoveZone) == 0x000044, "Member 'UBaseCameraTargetingStrategy::_interpolationSpeedOutsideFreeMoveZone' has a wrong offset!");
static_assert(offsetof(UBaseCameraTargetingStrategy, _target) == 0x000048, "Member 'UBaseCameraTargetingStrategy::_target' has a wrong offset!");

// Class DeadByDaylight.ConnectionStatusSubsystem
// 0x00E0 (0x0118 - 0x0038)
class UConnectionStatusSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0xE0];                                      // 0x0038(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConnectionStatusSubsystem">();
	}
	static class UConnectionStatusSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConnectionStatusSubsystem>();
	}
};
static_assert(alignof(UConnectionStatusSubsystem) == 0x000008, "Wrong alignment on UConnectionStatusSubsystem");
static_assert(sizeof(UConnectionStatusSubsystem) == 0x000118, "Wrong size on UConnectionStatusSubsystem");

// Class DeadByDaylight.DBDSignificanceStrategy
// 0x01E0 (0x0210 - 0x0030)
class UDBDSignificanceStrategy final : public USignificanceStrategy
{
public:
	struct FBHVRPerDetailModeFloat                _farDistance;                                      // 0x0030(0x00A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FBHVRPerDetailModeFloat                _auraRevealedMultiplier;                           // 0x00D0(0x00A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FBHVRPerDetailModeFloat                _auraRevealedMinimumSignificance;                  // 0x0170(0x00A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDSignificanceStrategy">();
	}
	static class UDBDSignificanceStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDSignificanceStrategy>();
	}
};
static_assert(alignof(UDBDSignificanceStrategy) == 0x000008, "Wrong alignment on UDBDSignificanceStrategy");
static_assert(sizeof(UDBDSignificanceStrategy) == 0x000210, "Wrong size on UDBDSignificanceStrategy");
static_assert(offsetof(UDBDSignificanceStrategy, _farDistance) == 0x000030, "Member 'UDBDSignificanceStrategy::_farDistance' has a wrong offset!");
static_assert(offsetof(UDBDSignificanceStrategy, _auraRevealedMultiplier) == 0x0000D0, "Member 'UDBDSignificanceStrategy::_auraRevealedMultiplier' has a wrong offset!");
static_assert(offsetof(UDBDSignificanceStrategy, _auraRevealedMinimumSignificance) == 0x000170, "Member 'UDBDSignificanceStrategy::_auraRevealedMinimumSignificance' has a wrong offset!");

// Class DeadByDaylight.DBDAttackSubstate
// 0x00E8 (0x0118 - 0x0030)
class UDBDAttackSubstate : public UObject
{
public:
	struct FStatProperty                          _duration;                                         // 0x0030(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _speedCurve;                                       // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _montage;                                          // 0x00C0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _currentCurve;                                     // 0x00D0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x40];                                      // 0x00D8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAttackSubstate">();
	}
	static class UDBDAttackSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAttackSubstate>();
	}
};
static_assert(alignof(UDBDAttackSubstate) == 0x000008, "Wrong alignment on UDBDAttackSubstate");
static_assert(sizeof(UDBDAttackSubstate) == 0x000118, "Wrong size on UDBDAttackSubstate");
static_assert(offsetof(UDBDAttackSubstate, _duration) == 0x000030, "Member 'UDBDAttackSubstate::_duration' has a wrong offset!");
static_assert(offsetof(UDBDAttackSubstate, _speedCurve) == 0x0000B8, "Member 'UDBDAttackSubstate::_speedCurve' has a wrong offset!");
static_assert(offsetof(UDBDAttackSubstate, _montage) == 0x0000C0, "Member 'UDBDAttackSubstate::_montage' has a wrong offset!");
static_assert(offsetof(UDBDAttackSubstate, _currentCurve) == 0x0000D0, "Member 'UDBDAttackSubstate::_currentCurve' has a wrong offset!");

// Class DeadByDaylight.DBDAttackHittingSubstate
// 0x0088 (0x01A0 - 0x0118)
class UDBDAttackHittingSubstate : public UDBDAttackSubstate
{
public:
	struct FStatProperty                          _hittingPercentDamageBegin;                        // 0x0118(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAttackHittingSubstate">();
	}
	static class UDBDAttackHittingSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAttackHittingSubstate>();
	}
};
static_assert(alignof(UDBDAttackHittingSubstate) == 0x000008, "Wrong alignment on UDBDAttackHittingSubstate");
static_assert(sizeof(UDBDAttackHittingSubstate) == 0x0001A0, "Wrong size on UDBDAttackHittingSubstate");
static_assert(offsetof(UDBDAttackHittingSubstate, _hittingPercentDamageBegin) == 0x000118, "Member 'UDBDAttackHittingSubstate::_hittingPercentDamageBegin' has a wrong offset!");

// Class DeadByDaylight.GameplayNotificationManager
// 0x0028 (0x00E0 - 0x00B8)
class UGameplayNotificationManager final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x28];                                      // 0x00B8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FireGameplayNotification(const struct FGameplayNotificationData& notificationData, bool addToHistory);
	void Multicast_FireGameplayNotification(const class UGameplayModifierContainer* modifierContainer, bool addToHistory);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayNotificationManager">();
	}
	static class UGameplayNotificationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayNotificationManager>();
	}
};
static_assert(alignof(UGameplayNotificationManager) == 0x000008, "Wrong alignment on UGameplayNotificationManager");
static_assert(sizeof(UGameplayNotificationManager) == 0x0000E0, "Wrong size on UGameplayNotificationManager");

// Class DeadByDaylight.ChargeableInteractionDefinition
// 0x0150 (0x08C0 - 0x0770)
class UChargeableInteractionDefinition : public UInteractionDefinition
{
public:
	uint8                                         Pad_768[0x30];                                     // 0x0768(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool Success, bool Bonus, class ADBDPlayer* Player, bool TriggerLoudNoise, ESkillCheckCustomType Type)> SkillCheckResponseAestheticDelegate; // 0x0798(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool Success, bool Bonus, class ADBDPlayer* Player, bool TriggerLoudNoise, ESkillCheckCustomType Type)> SkillCheckResponseAuthorityDelegate; // 0x07A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          StopInteractionOnChargeComplete;                   // 0x07B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillCheckCustomType                         SkillCheckType;                                    // 0x07B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasProgressivelyHarderSkillChecks;                 // 0x07BA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7BB[0x1];                                      // 0x07BB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProgressiveDifficultyModifier;                     // 0x07BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 ProgressBasedSkillChecks;                          // 0x07C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	EChargeableInteractionBarType                 ProgressBarType;                                   // 0x07D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D1[0x7];                                      // 0x07D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 ProgressPips;                                      // 0x07D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          HideProgressBar;                                   // 0x07E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldHavePriorityProgressBar;                     // 0x07E9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AddChargeOnInteractionUpdateTick;                  // 0x07EA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ResetChargeOnInteractionFinished;                  // 0x07EB(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ResetChargeOnInteractionChargeCompleted;           // 0x07EC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ToggleCrouchSlashableCapsule;                      // 0x07ED(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7EE[0x2];                                      // 0x07EE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargeableComponent*                   _chargeableComponent;                              // 0x07F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _tutorialChargeableMultiplier;                     // 0x07F8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7FC[0x54];                                     // 0x07FC(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ShowSpeedProficiencyForMultipleInteractors;        // 0x0850(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_851[0x7];                                      // 0x0851(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _interactionSpecificActionSpeedTags;               // 0x0858(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  _interactionSpecificActionSpeedMultiplicativeTags; // 0x0878(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  _interactionSpecificActionDurationAdditiveTags;    // 0x0898(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8B8[0x8];                                      // 0x08B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_AddCharge(float DeltaSeconds, class ADBDPlayer* Character, bool isChargeFromItem);
	void Authority_ChargeWithItem(float DeltaSeconds, class ACollectable* Item, class ADBDPlayer* Character);
	void Authority_ResetCharge(class ADBDPlayer* Character);
	void OnInteractionCompletionStateChanged(class ADBDPlayer* Player, bool complete);
	void OnSkillCheckResponseAesthetic(bool Success, bool Bonus, class ADBDPlayer* Player, bool TriggerLoudNoise, bool hadInput, ESkillCheckCustomType Type);
	void OnSkillCheckResponseAestheticBP(class ADBDPlayer* Player, bool Success, bool Bonus, bool hadInput, ESkillCheckCustomType Type);
	void OnSkillCheckResponseAuthority(bool Success, bool Bonus, class ADBDPlayer* Player, bool TriggerLoudNoise, bool hadInput, ESkillCheckCustomType Type);
	void OnSkillCheckResponseAuthorityBP(class ADBDPlayer* Player, bool Success, bool Bonus, bool hadInput, ESkillCheckCustomType Type);
	void SetChargeableComponent(class UChargeableComponent* ChargeableComponent, bool isNullAllowed);
	void SetSecondsToCharge(float SecondsToCharge);
	void SetSpeedBase(float speedBase);
	void SetTutorialChargeableMultiplier(float multiplierValue);

	float GetAdditiveChargeTimeReductionAsMultiplier(const class ADBDPlayer* Character) const;
	float GetAdditiveLuckBonus(const class ADBDPlayer* Character) const;
	float GetBonusSkillCheckSuccessPercentReward(const class ADBDPlayer* Player) const;
	float GetBonusSkillCheckZoneSizeModifier(const class ADBDPlayer* Character) const;
	class UChargeableComponent* GetChargeableComponent() const;
	float GetChargeAmountForTime(float DeltaSeconds, class ADBDPlayer* Character) const;
	float GetChargeSpeedModifier(const class ADBDPlayer* Character) const;
	float GetGoodSkillCheckSuccessPercentReward(const class ADBDPlayer* Player) const;
	float GetInteractionChargeSpeedMultiplier(const class ADBDPlayer* Character) const;
	float GetItemEfficiencyModifier(const class ADBDPlayer* Character) const;
	float GetMaxCharge() const;
	float GetMultiplicativeLuckBonus(const class ADBDPlayer* Character) const;
	float GetPerkMultiplier(const class ADBDPlayer* Character) const;
	int32 GetPipsPassed() const;
	float GetSkillCheckCharge(class ADBDPlayer* Player, bool Success, bool Bonus, ESkillCheckCustomType Type) const;
	float GetSkillCheckDifficulityModifier(const class ADBDPlayer* Character) const;
	float GetSkillCheckFailurePercentPenalty(const class ADBDPlayer* Player) const;
	float GetSkillCheckFailureTimePenalty() const;
	float GetSkillCheckProbability(const class ADBDPlayer* interactingPlayer) const;
	float GetSuccessProbability() const;
	float GetTunableValue(class FName tunableValueID, float defaultValue) const;
	bool HasSkillCheckHappened(const class ADBDPlayer* Character) const;
	bool IsChargeComplete() const;
	bool ShouldShowSpeedProficiencyForMultipleInteractors() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChargeableInteractionDefinition">();
	}
	static class UChargeableInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChargeableInteractionDefinition>();
	}
};
static_assert(alignof(UChargeableInteractionDefinition) == 0x000010, "Wrong alignment on UChargeableInteractionDefinition");
static_assert(sizeof(UChargeableInteractionDefinition) == 0x0008C0, "Wrong size on UChargeableInteractionDefinition");
static_assert(offsetof(UChargeableInteractionDefinition, SkillCheckResponseAestheticDelegate) == 0x000798, "Member 'UChargeableInteractionDefinition::SkillCheckResponseAestheticDelegate' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, SkillCheckResponseAuthorityDelegate) == 0x0007A8, "Member 'UChargeableInteractionDefinition::SkillCheckResponseAuthorityDelegate' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, StopInteractionOnChargeComplete) == 0x0007B8, "Member 'UChargeableInteractionDefinition::StopInteractionOnChargeComplete' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, SkillCheckType) == 0x0007B9, "Member 'UChargeableInteractionDefinition::SkillCheckType' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, HasProgressivelyHarderSkillChecks) == 0x0007BA, "Member 'UChargeableInteractionDefinition::HasProgressivelyHarderSkillChecks' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, ProgressiveDifficultyModifier) == 0x0007BC, "Member 'UChargeableInteractionDefinition::ProgressiveDifficultyModifier' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, ProgressBasedSkillChecks) == 0x0007C0, "Member 'UChargeableInteractionDefinition::ProgressBasedSkillChecks' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, ProgressBarType) == 0x0007D0, "Member 'UChargeableInteractionDefinition::ProgressBarType' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, ProgressPips) == 0x0007D8, "Member 'UChargeableInteractionDefinition::ProgressPips' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, HideProgressBar) == 0x0007E8, "Member 'UChargeableInteractionDefinition::HideProgressBar' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, ShouldHavePriorityProgressBar) == 0x0007E9, "Member 'UChargeableInteractionDefinition::ShouldHavePriorityProgressBar' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, AddChargeOnInteractionUpdateTick) == 0x0007EA, "Member 'UChargeableInteractionDefinition::AddChargeOnInteractionUpdateTick' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, ResetChargeOnInteractionFinished) == 0x0007EB, "Member 'UChargeableInteractionDefinition::ResetChargeOnInteractionFinished' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, ResetChargeOnInteractionChargeCompleted) == 0x0007EC, "Member 'UChargeableInteractionDefinition::ResetChargeOnInteractionChargeCompleted' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, ToggleCrouchSlashableCapsule) == 0x0007ED, "Member 'UChargeableInteractionDefinition::ToggleCrouchSlashableCapsule' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, _chargeableComponent) == 0x0007F0, "Member 'UChargeableInteractionDefinition::_chargeableComponent' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, _tutorialChargeableMultiplier) == 0x0007F8, "Member 'UChargeableInteractionDefinition::_tutorialChargeableMultiplier' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, ShowSpeedProficiencyForMultipleInteractors) == 0x000850, "Member 'UChargeableInteractionDefinition::ShowSpeedProficiencyForMultipleInteractors' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, _interactionSpecificActionSpeedTags) == 0x000858, "Member 'UChargeableInteractionDefinition::_interactionSpecificActionSpeedTags' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, _interactionSpecificActionSpeedMultiplicativeTags) == 0x000878, "Member 'UChargeableInteractionDefinition::_interactionSpecificActionSpeedMultiplicativeTags' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, _interactionSpecificActionDurationAdditiveTags) == 0x000898, "Member 'UChargeableInteractionDefinition::_interactionSpecificActionDurationAdditiveTags' has a wrong offset!");

// Class DeadByDaylight.AssetLibrary
// 0x0080 (0x00B0 - 0x0030)
class UAssetLibrary : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UObjectLibrary*                         _objectLibrary;                                    // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x64];                                      // 0x0040(0x0064)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SecondsDelayBetweenBatch;                          // 0x00A4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssetLibrary">();
	}
	static class UAssetLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetLibrary>();
	}
};
static_assert(alignof(UAssetLibrary) == 0x000008, "Wrong alignment on UAssetLibrary");
static_assert(sizeof(UAssetLibrary) == 0x0000B0, "Wrong size on UAssetLibrary");
static_assert(offsetof(UAssetLibrary, _objectLibrary) == 0x000038, "Member 'UAssetLibrary::_objectLibrary' has a wrong offset!");
static_assert(offsetof(UAssetLibrary, SecondsDelayBetweenBatch) == 0x0000A4, "Member 'UAssetLibrary::SecondsDelayBetweenBatch' has a wrong offset!");

// Class DeadByDaylight.IniAssetLibrary
// 0x0010 (0x00C0 - 0x00B0)
class UIniAssetLibrary final : public UAssetLibrary
{
public:
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IniAssetLibrary">();
	}
	static class UIniAssetLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIniAssetLibrary>();
	}
};
static_assert(alignof(UIniAssetLibrary) == 0x000008, "Wrong alignment on UIniAssetLibrary");
static_assert(sizeof(UIniAssetLibrary) == 0x0000C0, "Wrong size on UIniAssetLibrary");

// Class DeadByDaylight.KillerAudioProxyActorInterface
// 0x0000 (0x0000 - 0x0000)
class IKillerAudioProxyActorInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerAudioProxyActorInterface">();
	}
	static class IKillerAudioProxyActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IKillerAudioProxyActorInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IKillerAudioProxyActorInterface) == 0x000001, "Wrong alignment on IKillerAudioProxyActorInterface");
static_assert(sizeof(IKillerAudioProxyActorInterface) == 0x000001, "Wrong size on IKillerAudioProxyActorInterface");

// Class DeadByDaylight.RestrictedPlacementAreaStrategy
// 0x0078 (0x00A8 - 0x0030)
class URestrictedPlacementAreaStrategy : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   RestrictedRadius;                                  // 0x0040(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_68[0x4];                                       // 0x0068(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _useTunableForHeight;                              // 0x006C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _maxHeightRestriction;                             // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _maxHeightRestrictionTunable;                      // 0x0078(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          _shouldInitializeOnIntroCompleteInsteadOfLevelReadyToPlay; // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RestrictedPlacementAreaStrategy">();
	}
	static class URestrictedPlacementAreaStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<URestrictedPlacementAreaStrategy>();
	}
};
static_assert(alignof(URestrictedPlacementAreaStrategy) == 0x000008, "Wrong alignment on URestrictedPlacementAreaStrategy");
static_assert(sizeof(URestrictedPlacementAreaStrategy) == 0x0000A8, "Wrong size on URestrictedPlacementAreaStrategy");
static_assert(offsetof(URestrictedPlacementAreaStrategy, RestrictedRadius) == 0x000040, "Member 'URestrictedPlacementAreaStrategy::RestrictedRadius' has a wrong offset!");
static_assert(offsetof(URestrictedPlacementAreaStrategy, _useTunableForHeight) == 0x00006C, "Member 'URestrictedPlacementAreaStrategy::_useTunableForHeight' has a wrong offset!");
static_assert(offsetof(URestrictedPlacementAreaStrategy, _maxHeightRestriction) == 0x000070, "Member 'URestrictedPlacementAreaStrategy::_maxHeightRestriction' has a wrong offset!");
static_assert(offsetof(URestrictedPlacementAreaStrategy, _maxHeightRestrictionTunable) == 0x000078, "Member 'URestrictedPlacementAreaStrategy::_maxHeightRestrictionTunable' has a wrong offset!");
static_assert(offsetof(URestrictedPlacementAreaStrategy, _shouldInitializeOnIntroCompleteInsteadOfLevelReadyToPlay) == 0x0000A0, "Member 'URestrictedPlacementAreaStrategy::_shouldInitializeOnIntroCompleteInsteadOfLevelReadyToPlay' has a wrong offset!");

// Class DeadByDaylight.CommentatorSpawnStrategy
// 0x0000 (0x0030 - 0x0030)
class UCommentatorSpawnStrategy : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommentatorSpawnStrategy">();
	}
	static class UCommentatorSpawnStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommentatorSpawnStrategy>();
	}
};
static_assert(alignof(UCommentatorSpawnStrategy) == 0x000008, "Wrong alignment on UCommentatorSpawnStrategy");
static_assert(sizeof(UCommentatorSpawnStrategy) == 0x000030, "Wrong size on UCommentatorSpawnStrategy");

// Class DeadByDaylight.FreeSpotAroundLocationSpawnStrategy
// 0x0028 (0x0058 - 0x0030)
class UFreeSpotAroundLocationSpawnStrategy final : public UCommentatorSpawnStrategy
{
public:
	float                                         _minSpawnRadius;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxSpawnRadius;                                   // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _floorDepth;                                       // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _collisionSphereRadius;                            // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _checkForEveryAngleDegrees;                        // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _numberOfPositionToCheckInAnAngle;                 // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class AActor>>             _actorsToIgnore;                                   // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FreeSpotAroundLocationSpawnStrategy">();
	}
	static class UFreeSpotAroundLocationSpawnStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFreeSpotAroundLocationSpawnStrategy>();
	}
};
static_assert(alignof(UFreeSpotAroundLocationSpawnStrategy) == 0x000008, "Wrong alignment on UFreeSpotAroundLocationSpawnStrategy");
static_assert(sizeof(UFreeSpotAroundLocationSpawnStrategy) == 0x000058, "Wrong size on UFreeSpotAroundLocationSpawnStrategy");
static_assert(offsetof(UFreeSpotAroundLocationSpawnStrategy, _minSpawnRadius) == 0x000030, "Member 'UFreeSpotAroundLocationSpawnStrategy::_minSpawnRadius' has a wrong offset!");
static_assert(offsetof(UFreeSpotAroundLocationSpawnStrategy, _maxSpawnRadius) == 0x000034, "Member 'UFreeSpotAroundLocationSpawnStrategy::_maxSpawnRadius' has a wrong offset!");
static_assert(offsetof(UFreeSpotAroundLocationSpawnStrategy, _floorDepth) == 0x000038, "Member 'UFreeSpotAroundLocationSpawnStrategy::_floorDepth' has a wrong offset!");
static_assert(offsetof(UFreeSpotAroundLocationSpawnStrategy, _collisionSphereRadius) == 0x00003C, "Member 'UFreeSpotAroundLocationSpawnStrategy::_collisionSphereRadius' has a wrong offset!");
static_assert(offsetof(UFreeSpotAroundLocationSpawnStrategy, _checkForEveryAngleDegrees) == 0x000040, "Member 'UFreeSpotAroundLocationSpawnStrategy::_checkForEveryAngleDegrees' has a wrong offset!");
static_assert(offsetof(UFreeSpotAroundLocationSpawnStrategy, _numberOfPositionToCheckInAnAngle) == 0x000044, "Member 'UFreeSpotAroundLocationSpawnStrategy::_numberOfPositionToCheckInAnAngle' has a wrong offset!");
static_assert(offsetof(UFreeSpotAroundLocationSpawnStrategy, _actorsToIgnore) == 0x000048, "Member 'UFreeSpotAroundLocationSpawnStrategy::_actorsToIgnore' has a wrong offset!");

// Class DeadByDaylight.PopupFactory
// 0x0008 (0x0038 - 0x0030)
class UPopupFactory final : public UObject
{
public:
	class UDBDGameInstance*                       _gameInstance;                                     // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PopupFactory">();
	}
	static class UPopupFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPopupFactory>();
	}
};
static_assert(alignof(UPopupFactory) == 0x000008, "Wrong alignment on UPopupFactory");
static_assert(sizeof(UPopupFactory) == 0x000038, "Wrong size on UPopupFactory");
static_assert(offsetof(UPopupFactory, _gameInstance) == 0x000030, "Member 'UPopupFactory::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.DBDAnimationBudgetAllocatorActivator
// 0x0030 (0x00E8 - 0x00B8)
class UDBDAnimationBudgetAllocatorActivator final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x30];                                      // 0x00B8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAnimationBudgetAllocatorActivator">();
	}
	static class UDBDAnimationBudgetAllocatorActivator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAnimationBudgetAllocatorActivator>();
	}
};
static_assert(alignof(UDBDAnimationBudgetAllocatorActivator) == 0x000008, "Wrong alignment on UDBDAnimationBudgetAllocatorActivator");
static_assert(sizeof(UDBDAnimationBudgetAllocatorActivator) == 0x0000E8, "Wrong size on UDBDAnimationBudgetAllocatorActivator");

// Class DeadByDaylight.PlayerScoreEmitter
// 0x0008 (0x0038 - 0x0030)
class UPlayerScoreEmitter : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerScoreEmitter">();
	}
	static class UPlayerScoreEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerScoreEmitter>();
	}
};
static_assert(alignof(UPlayerScoreEmitter) == 0x000008, "Wrong alignment on UPlayerScoreEmitter");
static_assert(sizeof(UPlayerScoreEmitter) == 0x000038, "Wrong size on UPlayerScoreEmitter");

// Class DeadByDaylight.DisplayStandController
// 0x0190 (0x01C0 - 0x0030)
class UDisplayStandController : public UObject
{
public:
	uint8                                         Pad_30[0x190];                                     // 0x0030(0x0190)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisplayStandController">();
	}
	static class UDisplayStandController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisplayStandController>();
	}
};
static_assert(alignof(UDisplayStandController) == 0x000008, "Wrong alignment on UDisplayStandController");
static_assert(sizeof(UDisplayStandController) == 0x0001C0, "Wrong size on UDisplayStandController");

// Class DeadByDaylight.BasePerkIconStrategy
// 0x0008 (0x0038 - 0x0030)
class UBasePerkIconStrategy : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetDisplayPercent(const class UCompetence* Competence) const;
	bool GetIsRechargeable(const class UCompetence* Competence) const;
	bool GetIsRechargeableActive(const class UCompetence* Competence) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePerkIconStrategy">();
	}
	static class UBasePerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBasePerkIconStrategy>();
	}
};
static_assert(alignof(UBasePerkIconStrategy) == 0x000008, "Wrong alignment on UBasePerkIconStrategy");
static_assert(sizeof(UBasePerkIconStrategy) == 0x000038, "Wrong size on UBasePerkIconStrategy");

// Class DeadByDaylight.ApplicableActivationTimerRemainingCooldownElapsedIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UApplicableActivationTimerRemainingCooldownElapsedIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ApplicableActivationTimerRemainingCooldownElapsedIconStrategy">();
	}
	static class UApplicableActivationTimerRemainingCooldownElapsedIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UApplicableActivationTimerRemainingCooldownElapsedIconStrategy>();
	}
};
static_assert(alignof(UApplicableActivationTimerRemainingCooldownElapsedIconStrategy) == 0x000008, "Wrong alignment on UApplicableActivationTimerRemainingCooldownElapsedIconStrategy");
static_assert(sizeof(UApplicableActivationTimerRemainingCooldownElapsedIconStrategy) == 0x000038, "Wrong size on UApplicableActivationTimerRemainingCooldownElapsedIconStrategy");

// Class DeadByDaylight.ObjectPlacementValidationStrategy
// 0x0000 (0x00B8 - 0x00B8)
class UObjectPlacementValidationStrategy : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectPlacementValidationStrategy">();
	}
	static class UObjectPlacementValidationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectPlacementValidationStrategy>();
	}
};
static_assert(alignof(UObjectPlacementValidationStrategy) == 0x000008, "Wrong alignment on UObjectPlacementValidationStrategy");
static_assert(sizeof(UObjectPlacementValidationStrategy) == 0x0000B8, "Wrong size on UObjectPlacementValidationStrategy");

// Class DeadByDaylight.DefaultObjectPlacementValidationStrategy
// 0x0058 (0x0110 - 0x00B8)
class UDefaultObjectPlacementValidationStrategy : public UObjectPlacementValidationStrategy
{
public:
	TArray<class AActor*>                         _ignoredActors;                                    // 0x00B8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          _ignoreTrapBlockers;                               // 0x00C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _objectPlacementRaycastStart;                      // 0x00D0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _objectPlacementRaycastEnd;                        // 0x00E8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatRange                            _objectHeightRangeAroundBaseLocation;              // 0x0100(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DefaultObjectPlacementValidationStrategy">();
	}
	static class UDefaultObjectPlacementValidationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDefaultObjectPlacementValidationStrategy>();
	}
};
static_assert(alignof(UDefaultObjectPlacementValidationStrategy) == 0x000008, "Wrong alignment on UDefaultObjectPlacementValidationStrategy");
static_assert(sizeof(UDefaultObjectPlacementValidationStrategy) == 0x000110, "Wrong size on UDefaultObjectPlacementValidationStrategy");
static_assert(offsetof(UDefaultObjectPlacementValidationStrategy, _ignoredActors) == 0x0000B8, "Member 'UDefaultObjectPlacementValidationStrategy::_ignoredActors' has a wrong offset!");
static_assert(offsetof(UDefaultObjectPlacementValidationStrategy, _ignoreTrapBlockers) == 0x0000C8, "Member 'UDefaultObjectPlacementValidationStrategy::_ignoreTrapBlockers' has a wrong offset!");
static_assert(offsetof(UDefaultObjectPlacementValidationStrategy, _objectPlacementRaycastStart) == 0x0000D0, "Member 'UDefaultObjectPlacementValidationStrategy::_objectPlacementRaycastStart' has a wrong offset!");
static_assert(offsetof(UDefaultObjectPlacementValidationStrategy, _objectPlacementRaycastEnd) == 0x0000E8, "Member 'UDefaultObjectPlacementValidationStrategy::_objectPlacementRaycastEnd' has a wrong offset!");
static_assert(offsetof(UDefaultObjectPlacementValidationStrategy, _objectHeightRangeAroundBaseLocation) == 0x000100, "Member 'UDefaultObjectPlacementValidationStrategy::_objectHeightRangeAroundBaseLocation' has a wrong offset!");

// Class DeadByDaylight.ActivationTimerElapsedIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActivationTimerElapsedIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivationTimerElapsedIconStrategy">();
	}
	static class UActivationTimerElapsedIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivationTimerElapsedIconStrategy>();
	}
};
static_assert(alignof(UActivationTimerElapsedIconStrategy) == 0x000008, "Wrong alignment on UActivationTimerElapsedIconStrategy");
static_assert(sizeof(UActivationTimerElapsedIconStrategy) == 0x000038, "Wrong size on UActivationTimerElapsedIconStrategy");

// Class DeadByDaylight.KillerProjectileDodgeComponent
// 0x0030 (0x00E8 - 0x00B8)
class UKillerProjectileDodgeComponent final : public UActorComponent
{
public:
	class AKillerProjectile*                      _killerProjectile;                                 // 0x00B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ASurvivor*>                      _proximitySurvivors;                               // 0x00C0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x18];                                      // 0x00D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnKillerProjectileFinished(class AActor* survivorHit);
	void OnKillerProjectileFinishedWithoutCollision();
	void OnKillerProjectileLaunched();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerProjectileDodgeComponent">();
	}
	static class UKillerProjectileDodgeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerProjectileDodgeComponent>();
	}
};
static_assert(alignof(UKillerProjectileDodgeComponent) == 0x000008, "Wrong alignment on UKillerProjectileDodgeComponent");
static_assert(sizeof(UKillerProjectileDodgeComponent) == 0x0000E8, "Wrong size on UKillerProjectileDodgeComponent");
static_assert(offsetof(UKillerProjectileDodgeComponent, _killerProjectile) == 0x0000B8, "Member 'UKillerProjectileDodgeComponent::_killerProjectile' has a wrong offset!");
static_assert(offsetof(UKillerProjectileDodgeComponent, _proximitySurvivors) == 0x0000C0, "Member 'UKillerProjectileDodgeComponent::_proximitySurvivors' has a wrong offset!");

// Class DeadByDaylight.SupplyCrateInteractable
// 0x0118 (0x04C0 - 0x03A8)
class ASupplyCrateInteractable final : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x38];                                     // 0x03A8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargeableComponent*                   _chargeableComponent;                              // 0x03E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ACollectable>               _containedCollectable;                             // 0x03E8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _openInteractionSecondsToCharge;                   // 0x03F0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	class ACollectable*                           _itemInSupplyCrate;                                // 0x0418(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        _containingItemSpawnPoint;                         // 0x0420(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        _itemDropPoint;                                    // 0x0428(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isOpen;                                           // 0x0430(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isAutoClosing;                                    // 0x0431(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_432[0x3E];                                     // 0x0432(0x003E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _crateSelfClosingTime;                             // 0x0470(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _crateAutoCloseAnimationTime;                      // 0x0498(0x0028)(Edit, NativeAccessSpecifierPrivate)

public:
	void OnIsClosing();
	void OnIsOpened();
	void OnRep_IsAutoClosing();
	void OnRep_IsOpen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplyCrateInteractable">();
	}
	static class ASupplyCrateInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASupplyCrateInteractable>();
	}
};
static_assert(alignof(ASupplyCrateInteractable) == 0x000008, "Wrong alignment on ASupplyCrateInteractable");
static_assert(sizeof(ASupplyCrateInteractable) == 0x0004C0, "Wrong size on ASupplyCrateInteractable");
static_assert(offsetof(ASupplyCrateInteractable, _chargeableComponent) == 0x0003E0, "Member 'ASupplyCrateInteractable::_chargeableComponent' has a wrong offset!");
static_assert(offsetof(ASupplyCrateInteractable, _containedCollectable) == 0x0003E8, "Member 'ASupplyCrateInteractable::_containedCollectable' has a wrong offset!");
static_assert(offsetof(ASupplyCrateInteractable, _openInteractionSecondsToCharge) == 0x0003F0, "Member 'ASupplyCrateInteractable::_openInteractionSecondsToCharge' has a wrong offset!");
static_assert(offsetof(ASupplyCrateInteractable, _itemInSupplyCrate) == 0x000418, "Member 'ASupplyCrateInteractable::_itemInSupplyCrate' has a wrong offset!");
static_assert(offsetof(ASupplyCrateInteractable, _containingItemSpawnPoint) == 0x000420, "Member 'ASupplyCrateInteractable::_containingItemSpawnPoint' has a wrong offset!");
static_assert(offsetof(ASupplyCrateInteractable, _itemDropPoint) == 0x000428, "Member 'ASupplyCrateInteractable::_itemDropPoint' has a wrong offset!");
static_assert(offsetof(ASupplyCrateInteractable, _isOpen) == 0x000430, "Member 'ASupplyCrateInteractable::_isOpen' has a wrong offset!");
static_assert(offsetof(ASupplyCrateInteractable, _isAutoClosing) == 0x000431, "Member 'ASupplyCrateInteractable::_isAutoClosing' has a wrong offset!");
static_assert(offsetof(ASupplyCrateInteractable, _crateSelfClosingTime) == 0x000470, "Member 'ASupplyCrateInteractable::_crateSelfClosingTime' has a wrong offset!");
static_assert(offsetof(ASupplyCrateInteractable, _crateAutoCloseAnimationTime) == 0x000498, "Member 'ASupplyCrateInteractable::_crateAutoCloseAnimationTime' has a wrong offset!");

// Class DeadByDaylight.DefaultOutlineUpdateStrategy
// 0x0020 (0x0100 - 0x00E0)
class UDefaultOutlineUpdateStrategy : public UOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _revealedColorToSurvivor;                          // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _revealedColorToKiller;                            // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DefaultOutlineUpdateStrategy">();
	}
	static class UDefaultOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDefaultOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UDefaultOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UDefaultOutlineUpdateStrategy");
static_assert(sizeof(UDefaultOutlineUpdateStrategy) == 0x000100, "Wrong size on UDefaultOutlineUpdateStrategy");
static_assert(offsetof(UDefaultOutlineUpdateStrategy, _revealedColorToSurvivor) == 0x0000E0, "Member 'UDefaultOutlineUpdateStrategy::_revealedColorToSurvivor' has a wrong offset!");
static_assert(offsetof(UDefaultOutlineUpdateStrategy, _revealedColorToKiller) == 0x0000F0, "Member 'UDefaultOutlineUpdateStrategy::_revealedColorToKiller' has a wrong offset!");

// Class DeadByDaylight.KillerSoundCuesComponent
// 0x0010 (0x00C8 - 0x00B8)
class UKillerSoundCuesComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartTrackingActor(class AActor* actorToStartTracking, class FName distanceDataID);
	void StartTrackingActorWithLifetime(class AActor* actorToStartTracking, class FName distanceDataID, float trackerLifetime);
	void StopTrackingActor(class AActor* actorToStopTracking);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerSoundCuesComponent">();
	}
	static class UKillerSoundCuesComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerSoundCuesComponent>();
	}
};
static_assert(alignof(UKillerSoundCuesComponent) == 0x000008, "Wrong alignment on UKillerSoundCuesComponent");
static_assert(sizeof(UKillerSoundCuesComponent) == 0x0000C8, "Wrong size on UKillerSoundCuesComponent");

// Class DeadByDaylight.DecalSpawnerCollection
// 0x0050 (0x0080 - 0x0030)
class UDecalSpawnerCollection final : public UObject
{
public:
	TMap<class FName, class UDecalSpawner*>       _decalSpawners;                                    // 0x0030(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	class UDecalSpawner* CreateDecalSpawner(const class UObject* WorldContextObject, class FName decalSpawnerName, class UMaterialInterface* decalMaterial, int32 PoolSize, ESpawnerStrategyType spawnerStrateryType);
	void ReleaseDecalSpawner(class FName decalSpawnerName);
	class UDBDDecalComponent* SpawnDecalAtLocation(class FName decalSpawnerName, const struct FVector& DecalSize, const struct FVector& Location, const struct FRotator& Rotation, float LifeSpan, class FName decalType, const int32 SortOrder);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DecalSpawnerCollection">();
	}
	static class UDecalSpawnerCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDecalSpawnerCollection>();
	}
};
static_assert(alignof(UDecalSpawnerCollection) == 0x000008, "Wrong alignment on UDecalSpawnerCollection");
static_assert(sizeof(UDecalSpawnerCollection) == 0x000080, "Wrong size on UDecalSpawnerCollection");
static_assert(offsetof(UDecalSpawnerCollection, _decalSpawners) == 0x000030, "Member 'UDecalSpawnerCollection::_decalSpawners' has a wrong offset!");

// Class DeadByDaylight.AISense_UnclearHearing
// 0x0060 (0x00F0 - 0x0090)
class UAISense_UnclearHearing final : public UAISense
{
public:
	TArray<struct FAIUnclearNoiseEvent>           NoiseEvents;                                       // 0x0090(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A0[0x50];                                      // 0x00A0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ReportUnclearNoiseEvent(class UObject* WorldContextObject, const struct FVector& NoiseLocation, float Loudness, class AActor* Instigator, float MaxRange, class FName Tag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISense_UnclearHearing">();
	}
	static class UAISense_UnclearHearing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISense_UnclearHearing>();
	}
};
static_assert(alignof(UAISense_UnclearHearing) == 0x000008, "Wrong alignment on UAISense_UnclearHearing");
static_assert(sizeof(UAISense_UnclearHearing) == 0x0000F0, "Wrong size on UAISense_UnclearHearing");
static_assert(offsetof(UAISense_UnclearHearing, NoiseEvents) == 0x000090, "Member 'UAISense_UnclearHearing::NoiseEvents' has a wrong offset!");

// Class DeadByDaylight.ItemModifier
// 0x0060 (0x02C0 - 0x0260)
class UItemModifier : public UGameplayModifierContainer
{
public:
	struct FGameplayModifierData                  ModifierData;                                      // 0x0260(0x0030)(Edit, Net, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_290[0x30];                                     // 0x0290(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AuthoritySetItemCount(int32 itemCount);
	void AuthoritySetItemEnergy(float energy);
	void AuthoritySetItemMaxEnergy(float energy);
	void HandleIncreaseCharge();
	void HandleIncreaseItemCount();
	void HandleIncreaseMaxCharge();

	class ACollectable* GetBaseItem() const;
	int32 GetItemCount() const;
	float GetItemEnergy() const;
	float GetItemMaxEnergy() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemModifier">();
	}
	static class UItemModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemModifier>();
	}
};
static_assert(alignof(UItemModifier) == 0x000008, "Wrong alignment on UItemModifier");
static_assert(sizeof(UItemModifier) == 0x0002C0, "Wrong size on UItemModifier");
static_assert(offsetof(UItemModifier, ModifierData) == 0x000260, "Member 'UItemModifier::ModifierData' has a wrong offset!");

// Class DeadByDaylight.K31UIDataInterface
// 0x0000 (0x0000 - 0x0000)
class IK31UIDataInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K31UIDataInterface">();
	}
	static class IK31UIDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IK31UIDataInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IK31UIDataInterface) == 0x000001, "Wrong alignment on IK31UIDataInterface");
static_assert(sizeof(IK31UIDataInterface) == 0x000001, "Wrong size on IK31UIDataInterface");

// Class DeadByDaylight.PlayerProfileDAL
// 0x0058 (0x0088 - 0x0030)
class UPlayerProfileDAL : public UObject
{
public:
	uint8                                         Pad_30[0x58];                                      // 0x0030(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerProfileDAL">();
	}
	static class UPlayerProfileDAL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerProfileDAL>();
	}
};
static_assert(alignof(UPlayerProfileDAL) == 0x000008, "Wrong alignment on UPlayerProfileDAL");
static_assert(sizeof(UPlayerProfileDAL) == 0x000088, "Wrong size on UPlayerProfileDAL");

// Class DeadByDaylight.PS5ProfileDAL
// 0x0000 (0x0088 - 0x0088)
class UPS5ProfileDAL final : public UPlayerProfileDAL
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PS5ProfileDAL">();
	}
	static class UPS5ProfileDAL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPS5ProfileDAL>();
	}
};
static_assert(alignof(UPS5ProfileDAL) == 0x000008, "Wrong alignment on UPS5ProfileDAL");
static_assert(sizeof(UPS5ProfileDAL) == 0x000088, "Wrong size on UPS5ProfileDAL");

// Class DeadByDaylight.PresentationItemProgressComponent
// 0x0008 (0x00C0 - 0x00B8)
class UPresentationItemProgressComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PresentationItemProgressComponent">();
	}
	static class UPresentationItemProgressComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPresentationItemProgressComponent>();
	}
};
static_assert(alignof(UPresentationItemProgressComponent) == 0x000008, "Wrong alignment on UPresentationItemProgressComponent");
static_assert(sizeof(UPresentationItemProgressComponent) == 0x0000C0, "Wrong size on UPresentationItemProgressComponent");

// Class DeadByDaylight.MovementSettings
// 0x0000 (0x0000 - 0x0000)
class IMovementSettings final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovementSettings">();
	}
	static class IMovementSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMovementSettings>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IMovementSettings) == 0x000001, "Wrong alignment on IMovementSettings");
static_assert(sizeof(IMovementSettings) == 0x000001, "Wrong size on IMovementSettings");

// Class DeadByDaylight.SurvivorHitCosmeticHandler
// 0x0030 (0x0060 - 0x0030)
class USurvivorHitCosmeticHandler final : public UBaseReversibleInstantActionHandler
{
public:
	class UNiagaraComponent*                      _bloodSpurts;                                      // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x28];                                      // 0x0038(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMontageStarted(const struct FAnimationMontageDescriptor& animMontageID, const float PlayRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorHitCosmeticHandler">();
	}
	static class USurvivorHitCosmeticHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorHitCosmeticHandler>();
	}
};
static_assert(alignof(USurvivorHitCosmeticHandler) == 0x000008, "Wrong alignment on USurvivorHitCosmeticHandler");
static_assert(sizeof(USurvivorHitCosmeticHandler) == 0x000060, "Wrong size on USurvivorHitCosmeticHandler");
static_assert(offsetof(USurvivorHitCosmeticHandler, _bloodSpurts) == 0x000030, "Member 'USurvivorHitCosmeticHandler::_bloodSpurts' has a wrong offset!");

// Class DeadByDaylight.AICharacterEscapeCarried
// 0x0010 (0x0068 - 0x0058)
class UAICharacterEscapeCarried final : public UAICharacterBehaviour
{
public:
	class ASurvivor*                              _camperPlayer;                                     // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAICharacterEscapeCarriedData*          _behaviourData;                                    // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterEscapeCarried">();
	}
	static class UAICharacterEscapeCarried* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterEscapeCarried>();
	}
};
static_assert(alignof(UAICharacterEscapeCarried) == 0x000008, "Wrong alignment on UAICharacterEscapeCarried");
static_assert(sizeof(UAICharacterEscapeCarried) == 0x000068, "Wrong size on UAICharacterEscapeCarried");
static_assert(offsetof(UAICharacterEscapeCarried, _camperPlayer) == 0x000058, "Member 'UAICharacterEscapeCarried::_camperPlayer' has a wrong offset!");
static_assert(offsetof(UAICharacterEscapeCarried, _behaviourData) == 0x000060, "Member 'UAICharacterEscapeCarried::_behaviourData' has a wrong offset!");

// Class DeadByDaylight.DynamicGrass
// 0x0018 (0x02B8 - 0x02A0)
class ADynamicGrass final : public AActor
{
public:
	class UMaterialParameterCollection*           _worldSettings;                                    // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A8[0x10];                                     // 0x02A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicGrass">();
	}
	static class ADynamicGrass* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADynamicGrass>();
	}
};
static_assert(alignof(ADynamicGrass) == 0x000008, "Wrong alignment on ADynamicGrass");
static_assert(sizeof(ADynamicGrass) == 0x0002B8, "Wrong size on ADynamicGrass");
static_assert(offsetof(ADynamicGrass, _worldSettings) == 0x0002A0, "Member 'ADynamicGrass::_worldSettings' has a wrong offset!");

// Class DeadByDaylight.ItemAddon
// 0x0040 (0x0300 - 0x02C0)
class UItemAddon : public UItemModifier
{
public:
	TSubclassOf<class ACollectable>               BaseItemType;                                      // 0x02C0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _needsSetup;                                       // 0x02C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C9[0x3];                                      // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _maxTokenCount;                                    // 0x02CC(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D0[0x1C];                                     // 0x02D0(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _tokenCount;                                       // 0x02EC(0x0004)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FItemAddonInitializationData           _addonInitializationData;                          // 0x02F0(0x0002)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F2[0x2];                                      // 0x02F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ACollectable>            _baseItem;                                         // 0x02F4(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_ApplyMetaModifiers();
	void Authority_DecrementToken();
	void Authority_IncrementToken();
	void Authority_OnCollectableDropped(class ADBDPlayer* Player);
	void Authority_OnCollectablePickedUp(class ADBDPlayer* Player);
	void Authority_SetMaxTokenCount(int32 Value);
	void Authority_SetTokenCount(int32 Value);
	void DebugPrintStats();
	void OnPostItemAddonsCreation(class ADBDPlayer* Player, class ACollectable* Item);
	void OnRep_AddonInitializationData();
	void OnRep_BaseItem();
	void OnRep_TokenCount(int32 oldCount);
	void SetUpAddon();

	int32 GetMaxTokenCount() const;
	int32 GetTokenCount() const;
	bool IsReadyForSetUp() const;
	bool IsSecondaryAction() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAddon">();
	}
	static class UItemAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAddon>();
	}
};
static_assert(alignof(UItemAddon) == 0x000008, "Wrong alignment on UItemAddon");
static_assert(sizeof(UItemAddon) == 0x000300, "Wrong size on UItemAddon");
static_assert(offsetof(UItemAddon, BaseItemType) == 0x0002C0, "Member 'UItemAddon::BaseItemType' has a wrong offset!");
static_assert(offsetof(UItemAddon, _needsSetup) == 0x0002C8, "Member 'UItemAddon::_needsSetup' has a wrong offset!");
static_assert(offsetof(UItemAddon, _maxTokenCount) == 0x0002CC, "Member 'UItemAddon::_maxTokenCount' has a wrong offset!");
static_assert(offsetof(UItemAddon, _tokenCount) == 0x0002EC, "Member 'UItemAddon::_tokenCount' has a wrong offset!");
static_assert(offsetof(UItemAddon, _addonInitializationData) == 0x0002F0, "Member 'UItemAddon::_addonInitializationData' has a wrong offset!");
static_assert(offsetof(UItemAddon, _baseItem) == 0x0002F4, "Member 'UItemAddon::_baseItem' has a wrong offset!");

// Class DeadByDaylight.StateMachine
// 0x0078 (0x0130 - 0x00B8)
class alignas(0x10) UStateMachine : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x9];                                       // 0x00B8(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _enableJoinInProgress;                             // 0x00C1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C2[0x56];                                      // 0x00C2(0x0056)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint16>                                _netStateIDStackInitial;                           // 0x0118(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_SetStateStack(const TArray<uint16>& netStateIDStack);
	void NetIDStackChanged();
	void Server_SetStateStack(const TArray<uint16>& netStateIDStack);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateMachine">();
	}
	static class UStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateMachine>();
	}
};
static_assert(alignof(UStateMachine) == 0x000010, "Wrong alignment on UStateMachine");
static_assert(sizeof(UStateMachine) == 0x000130, "Wrong size on UStateMachine");
static_assert(offsetof(UStateMachine, _enableJoinInProgress) == 0x0000C1, "Member 'UStateMachine::_enableJoinInProgress' has a wrong offset!");
static_assert(offsetof(UStateMachine, _netStateIDStackInitial) == 0x000118, "Member 'UStateMachine::_netStateIDStackInitial' has a wrong offset!");

// Class DeadByDaylight.PlayerStateMachine
// 0x0010 (0x0140 - 0x0130)
class UPlayerStateMachine : public UStateMachine
{
public:
	uint8                                         Pad_130[0x10];                                     // 0x0130(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_DeniedStateChange(const struct FPlayerStateMachineTransitionData& rejectedStateStack, const TArray<uint16>& serverCurrentStateStack);
	void Multicast_SetStateStackImmediate(const TArray<uint16>& netStateIDStack);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStateMachine">();
	}
	static class UPlayerStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerStateMachine>();
	}
};
static_assert(alignof(UPlayerStateMachine) == 0x000010, "Wrong alignment on UPlayerStateMachine");
static_assert(sizeof(UPlayerStateMachine) == 0x000140, "Wrong size on UPlayerStateMachine");

// Class DeadByDaylight.KillerInstinctInterface
// 0x0000 (0x0000 - 0x0000)
class IKillerInstinctInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerInstinctInterface">();
	}
	static class IKillerInstinctInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IKillerInstinctInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IKillerInstinctInterface) == 0x000001, "Wrong alignment on IKillerInstinctInterface");
static_assert(sizeof(IKillerInstinctInterface) == 0x000001, "Wrong size on IKillerInstinctInterface");

// Class DeadByDaylight.DBDAttack
// 0x0378 (0x0430 - 0x00B8)
class alignas(0x10) UDBDAttack : public UActorComponent
{
public:
	uint8                                         Pad_B8[0xB8];                                      // 0x00B8(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	EAttackType                                   _attackType;                                       // 0x0170(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _useMontage;                                       // 0x0171(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDetectionZone                                _damageZone;                                       // 0x0172(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDetectionZone                                _lockZone;                                         // 0x0173(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDetectionZone                                _obstructionZone;                                  // 0x0174(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_175[0x3];                                      // 0x0175(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStatProperty                          _maxAccelerationMultiplier;                        // 0x0178(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          _onlyApplyAccelerationMultiplierWhenWalking;       // 0x0200(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_201[0x7];                                      // 0x0201(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDAttackTargetTracker                _targetTracker;                                    // 0x0208(0x00B8)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EAttackSubstate, TSubclassOf<class UDBDAttackSubstate>> _stateClasses;                      // 0x02C0(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class ACharacter*>                     _localAlreadyHitTargets;                           // 0x0310(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class ACharacter*>                     _hitTargets;                                       // 0x0320(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TSet<class ACharacter*>                       _targetsAwaitingServerValidation;                  // 0x0330(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_380[0x30];                                     // 0x0380(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EAttackSubstate, class UDBDAttackSubstate*> _states;                                        // 0x03B0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_400[0x26];                                     // 0x0400(0x0026)(Fixing Size After Last Property [ Dumper-7 ])
	EHitValidatorConfigName                       _hitValidationConfigName;                          // 0x0426(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_427[0x9];                                      // 0x0427(0x0009)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_ReceiveAttackSubstateRequestResult(const struct FAttackSubstateRequestResult& Result);
	void Client_ReceiveHitResult(class ACharacter* Target, bool IsValid, const struct FActionPredictionKey& PredictionKey);
	void Local_OnMovementChanged(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);
	void Multicast_ClearTargets();
	void Multicast_HitAttackableComponent(class UAttackableComponent* AttackableComponent);
	void Multicast_HitTarget(class ACharacter* Target, bool hitCosmeticOnly);
	void Multicast_RequestStateChange(const EAttackSubstate State);
	void Multicast_SendPostHitTargetData(class ADBDPlayer* owningKiller, class ADBDPlayer* Target, const struct FPreAttackData& PreAttackData, const struct FPostAttackData& PostAttackData);
	void Server_ClearTargets();
	void Server_HitDestroyableActorAttackableComponent(class UAttackableComponent* AttackableComponent);
	void Server_HitTarget(class ACharacter* Target, const float TargetLocationTimestamp, const struct FActionPredictionKey& PredictionKey);
	void Server_RequestStateChange(const EAttackSubstate State);

	class UDBDAttackSubstate* GetAttackSubstate(const EAttackSubstate State) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAttack">();
	}
	static class UDBDAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAttack>();
	}
};
static_assert(alignof(UDBDAttack) == 0x000010, "Wrong alignment on UDBDAttack");
static_assert(sizeof(UDBDAttack) == 0x000430, "Wrong size on UDBDAttack");
static_assert(offsetof(UDBDAttack, _attackType) == 0x000170, "Member 'UDBDAttack::_attackType' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _useMontage) == 0x000171, "Member 'UDBDAttack::_useMontage' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _damageZone) == 0x000172, "Member 'UDBDAttack::_damageZone' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _lockZone) == 0x000173, "Member 'UDBDAttack::_lockZone' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _obstructionZone) == 0x000174, "Member 'UDBDAttack::_obstructionZone' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _maxAccelerationMultiplier) == 0x000178, "Member 'UDBDAttack::_maxAccelerationMultiplier' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _onlyApplyAccelerationMultiplierWhenWalking) == 0x000200, "Member 'UDBDAttack::_onlyApplyAccelerationMultiplierWhenWalking' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _targetTracker) == 0x000208, "Member 'UDBDAttack::_targetTracker' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _stateClasses) == 0x0002C0, "Member 'UDBDAttack::_stateClasses' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _localAlreadyHitTargets) == 0x000310, "Member 'UDBDAttack::_localAlreadyHitTargets' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _hitTargets) == 0x000320, "Member 'UDBDAttack::_hitTargets' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _targetsAwaitingServerValidation) == 0x000330, "Member 'UDBDAttack::_targetsAwaitingServerValidation' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _states) == 0x0003B0, "Member 'UDBDAttack::_states' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _hitValidationConfigName) == 0x000426, "Member 'UDBDAttack::_hitValidationConfigName' has a wrong offset!");

// Class DeadByDaylight.NotExhaustedActivationTimerElapsedIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UNotExhaustedActivationTimerElapsedIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NotExhaustedActivationTimerElapsedIconStrategy">();
	}
	static class UNotExhaustedActivationTimerElapsedIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNotExhaustedActivationTimerElapsedIconStrategy>();
	}
};
static_assert(alignof(UNotExhaustedActivationTimerElapsedIconStrategy) == 0x000008, "Wrong alignment on UNotExhaustedActivationTimerElapsedIconStrategy");
static_assert(sizeof(UNotExhaustedActivationTimerElapsedIconStrategy) == 0x000038, "Wrong size on UNotExhaustedActivationTimerElapsedIconStrategy");

// Class DeadByDaylight.SurvivorBloodFXComponent
// 0x0000 (0x00B8 - 0x00B8)
class USurvivorBloodFXComponent final : public UActorComponent
{
public:
	class UNiagaraComponent* SpawnBloodSpurts();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorBloodFXComponent">();
	}
	static class USurvivorBloodFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorBloodFXComponent>();
	}
};
static_assert(alignof(USurvivorBloodFXComponent) == 0x000008, "Wrong alignment on USurvivorBloodFXComponent");
static_assert(sizeof(USurvivorBloodFXComponent) == 0x0000B8, "Wrong size on USurvivorBloodFXComponent");

// Class DeadByDaylight.SpecialBehaviourInteractable
// 0x0040 (0x03E8 - 0x03A8)
class ASpecialBehaviourInteractable : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x30];                                     // 0x03A8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ADBDPlayerState>         _specialBehaviourOwner;                            // 0x03D8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E0[0x8];                                      // 0x03E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_SpecialBehaviourOwner();

	class ADBDPlayer* GetOwnerPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecialBehaviourInteractable">();
	}
	static class ASpecialBehaviourInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpecialBehaviourInteractable>();
	}
};
static_assert(alignof(ASpecialBehaviourInteractable) == 0x000008, "Wrong alignment on ASpecialBehaviourInteractable");
static_assert(sizeof(ASpecialBehaviourInteractable) == 0x0003E8, "Wrong size on ASpecialBehaviourInteractable");
static_assert(offsetof(ASpecialBehaviourInteractable, _specialBehaviourOwner) == 0x0003D8, "Member 'ASpecialBehaviourInteractable::_specialBehaviourOwner' has a wrong offset!");

// Class DeadByDaylight.DBDTunableUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDTunableUtilities final : public UBlueprintFunctionLibrary
{
public:
	static float GetEndGameTunableValue(const class UObject* WorldContextObject, class FName valueName);
	static float GetSlasherTunableValue(const class UObject* WorldContextObject, class FName valueName);
	static float GetTunableRowHandleValue(const struct FDBDTunableRowHandle& rowHandle);
	static float GetTunableValue(const class UObject* WorldContextObject, class FName valueName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDTunableUtilities">();
	}
	static class UDBDTunableUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDTunableUtilities>();
	}
};
static_assert(alignof(UDBDTunableUtilities) == 0x000008, "Wrong alignment on UDBDTunableUtilities");
static_assert(sizeof(UDBDTunableUtilities) == 0x000030, "Wrong size on UDBDTunableUtilities");

// Class DeadByDaylight.GameObjectiveBase
// 0x0040 (0x02E0 - 0x02A0)
class AGameObjectiveBase : public AInfo
{
public:
	uint8                                         Pad_2A0[0x30];                                     // 0x02A0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _type;                                             // 0x02D0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCompleted;                                      // 0x02DC(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isForcedCompleted;                                // 0x02DD(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isActive;                                         // 0x02DE(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DF[0x1];                                      // 0x02DF(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_IsCompleted(bool wasCompleted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameObjectiveBase">();
	}
	static class AGameObjectiveBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameObjectiveBase>();
	}
};
static_assert(alignof(AGameObjectiveBase) == 0x000008, "Wrong alignment on AGameObjectiveBase");
static_assert(sizeof(AGameObjectiveBase) == 0x0002E0, "Wrong size on AGameObjectiveBase");
static_assert(offsetof(AGameObjectiveBase, _type) == 0x0002D0, "Member 'AGameObjectiveBase::_type' has a wrong offset!");
static_assert(offsetof(AGameObjectiveBase, _isCompleted) == 0x0002DC, "Member 'AGameObjectiveBase::_isCompleted' has a wrong offset!");
static_assert(offsetof(AGameObjectiveBase, _isForcedCompleted) == 0x0002DD, "Member 'AGameObjectiveBase::_isForcedCompleted' has a wrong offset!");
static_assert(offsetof(AGameObjectiveBase, _isActive) == 0x0002DE, "Member 'AGameObjectiveBase::_isActive' has a wrong offset!");

// Class DeadByDaylight.GameObjective_ActorList
// 0x0010 (0x02F0 - 0x02E0)
class AGameObjective_ActorList : public AGameObjectiveBase
{
public:
	TArray<class AActor*>                         _actors;                                           // 0x02E0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameObjective_ActorList">();
	}
	static class AGameObjective_ActorList* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameObjective_ActorList>();
	}
};
static_assert(alignof(AGameObjective_ActorList) == 0x000008, "Wrong alignment on AGameObjective_ActorList");
static_assert(sizeof(AGameObjective_ActorList) == 0x0002F0, "Wrong size on AGameObjective_ActorList");
static_assert(offsetof(AGameObjective_ActorList, _actors) == 0x0002E0, "Member 'AGameObjective_ActorList::_actors' has a wrong offset!");

// Class DeadByDaylight.GameObjective_ActorClassList
// 0x0008 (0x02F8 - 0x02F0)
class AGameObjective_ActorClassList final : public AGameObjective_ActorList
{
public:
	TSubclassOf<class AActor>                     _actorClass;                                       // 0x02F0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameObjective_ActorClassList">();
	}
	static class AGameObjective_ActorClassList* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameObjective_ActorClassList>();
	}
};
static_assert(alignof(AGameObjective_ActorClassList) == 0x000008, "Wrong alignment on AGameObjective_ActorClassList");
static_assert(sizeof(AGameObjective_ActorClassList) == 0x0002F8, "Wrong size on AGameObjective_ActorClassList");
static_assert(offsetof(AGameObjective_ActorClassList, _actorClass) == 0x0002F0, "Member 'AGameObjective_ActorClassList::_actorClass' has a wrong offset!");

// Class DeadByDaylight.KillInteractionDefinition
// 0x0120 (0x09E0 - 0x08C0)
class UKillInteractionDefinition : public UChargeableInteractionDefinition
{
public:
	bool                                          _disableFOVSystemDuringInteraction;                // 0x08C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _overrideSlasherFieldOfViewDuringInteraction;      // 0x08C1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _overrideCamperFieldOfViewDuringInteraction;       // 0x08C2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _camperCopySlasherFOVCurve;                        // 0x08C3(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _cameraFOVCurveName;                               // 0x08C4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _survivorBeingKilledStatusEffect;                  // 0x08D0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 _moriKillAudioSwitchName;                          // 0x08D8(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 _moriKillAudioSwitchOnStateName;                   // 0x08E8(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 _moriKillAudioSwitchOffStateName;                  // 0x08F8(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _setKillerStatusInCrazyStateDuringMori;            // 0x0908(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_909[0x7];                                      // 0x0909(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _killerStatusAudioSwitchName;                      // 0x0910(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 _killerStatusAudioSwitchCrazyState;                // 0x0920(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 _killerStatusAudioSwitchExitState;                 // 0x0930(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 _killerStatusAudioSwitchDefaultState;              // 0x0940(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FString>                         _nonOverrideableTargetInteractions;                // 0x0950(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          _chargeCompleted;                                  // 0x0960(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isKillShownInThirdPerson;                         // 0x0961(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _manuallyManageMeshHiding;                         // 0x0962(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _survivorAnimationLastAfterInteractionEnds;        // 0x0963(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_964[0x34];                                     // 0x0964(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _maximumDelayBeforeSurvivorDeath;                  // 0x0998(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_99C[0x4];                                      // 0x099C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimationMontageDescriptor            _exitMontage;                                      // 0x09A0(0x0020)(Edit, NativeAccessSpecifierPrivate)
	float                                         _slasherFacingTolerance;                           // 0x09C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9C4[0x4];                                      // 0x09C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AKiller*                                _originatingKiller;                                // 0x09C8(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9D0[0x10];                                     // 0x09D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMoriCancelled();

	bool GetChargeCompleted() const;
	struct FAnimationMontageDescriptor GetExitAnimationMontage() const;
	const class AKiller* GetOriginatingKiller() const;
	const class ASurvivor* GetOwningSurvivor() const;
	bool IsKillerAllowedToKillSurvivor(const class AKiller* Killer, const class ASurvivor* Survivor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillInteractionDefinition">();
	}
	static class UKillInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillInteractionDefinition>();
	}
};
static_assert(alignof(UKillInteractionDefinition) == 0x000010, "Wrong alignment on UKillInteractionDefinition");
static_assert(sizeof(UKillInteractionDefinition) == 0x0009E0, "Wrong size on UKillInteractionDefinition");
static_assert(offsetof(UKillInteractionDefinition, _disableFOVSystemDuringInteraction) == 0x0008C0, "Member 'UKillInteractionDefinition::_disableFOVSystemDuringInteraction' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _overrideSlasherFieldOfViewDuringInteraction) == 0x0008C1, "Member 'UKillInteractionDefinition::_overrideSlasherFieldOfViewDuringInteraction' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _overrideCamperFieldOfViewDuringInteraction) == 0x0008C2, "Member 'UKillInteractionDefinition::_overrideCamperFieldOfViewDuringInteraction' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _camperCopySlasherFOVCurve) == 0x0008C3, "Member 'UKillInteractionDefinition::_camperCopySlasherFOVCurve' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _cameraFOVCurveName) == 0x0008C4, "Member 'UKillInteractionDefinition::_cameraFOVCurveName' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _survivorBeingKilledStatusEffect) == 0x0008D0, "Member 'UKillInteractionDefinition::_survivorBeingKilledStatusEffect' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _moriKillAudioSwitchName) == 0x0008D8, "Member 'UKillInteractionDefinition::_moriKillAudioSwitchName' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _moriKillAudioSwitchOnStateName) == 0x0008E8, "Member 'UKillInteractionDefinition::_moriKillAudioSwitchOnStateName' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _moriKillAudioSwitchOffStateName) == 0x0008F8, "Member 'UKillInteractionDefinition::_moriKillAudioSwitchOffStateName' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _setKillerStatusInCrazyStateDuringMori) == 0x000908, "Member 'UKillInteractionDefinition::_setKillerStatusInCrazyStateDuringMori' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _killerStatusAudioSwitchName) == 0x000910, "Member 'UKillInteractionDefinition::_killerStatusAudioSwitchName' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _killerStatusAudioSwitchCrazyState) == 0x000920, "Member 'UKillInteractionDefinition::_killerStatusAudioSwitchCrazyState' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _killerStatusAudioSwitchExitState) == 0x000930, "Member 'UKillInteractionDefinition::_killerStatusAudioSwitchExitState' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _killerStatusAudioSwitchDefaultState) == 0x000940, "Member 'UKillInteractionDefinition::_killerStatusAudioSwitchDefaultState' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _nonOverrideableTargetInteractions) == 0x000950, "Member 'UKillInteractionDefinition::_nonOverrideableTargetInteractions' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _chargeCompleted) == 0x000960, "Member 'UKillInteractionDefinition::_chargeCompleted' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _isKillShownInThirdPerson) == 0x000961, "Member 'UKillInteractionDefinition::_isKillShownInThirdPerson' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _manuallyManageMeshHiding) == 0x000962, "Member 'UKillInteractionDefinition::_manuallyManageMeshHiding' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _survivorAnimationLastAfterInteractionEnds) == 0x000963, "Member 'UKillInteractionDefinition::_survivorAnimationLastAfterInteractionEnds' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _maximumDelayBeforeSurvivorDeath) == 0x000998, "Member 'UKillInteractionDefinition::_maximumDelayBeforeSurvivorDeath' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _exitMontage) == 0x0009A0, "Member 'UKillInteractionDefinition::_exitMontage' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _slasherFacingTolerance) == 0x0009C0, "Member 'UKillInteractionDefinition::_slasherFacingTolerance' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _originatingKiller) == 0x0009C8, "Member 'UKillInteractionDefinition::_originatingKiller' has a wrong offset!");

// Class DeadByDaylight.ItemPerformedInteraction
// 0x0000 (0x0000 - 0x0000)
class IItemPerformedInteraction final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemPerformedInteraction">();
	}
	static class IItemPerformedInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<IItemPerformedInteraction>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IItemPerformedInteraction) == 0x000001, "Wrong alignment on IItemPerformedInteraction");
static_assert(sizeof(IItemPerformedInteraction) == 0x000001, "Wrong size on IItemPerformedInteraction");

// Class DeadByDaylight.DBDSpectator
// 0x0020 (0x0370 - 0x0350)
class ADBDSpectator final : public ASpectatorPawn
{
public:
	uint8                                         Pad_350[0x20];                                     // 0x0350(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDSpectator">();
	}
	static class ADBDSpectator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDSpectator>();
	}
};
static_assert(alignof(ADBDSpectator) == 0x000008, "Wrong alignment on ADBDSpectator");
static_assert(sizeof(ADBDSpectator) == 0x000370, "Wrong size on ADBDSpectator");

// Class DeadByDaylight.AICharacterRepairGeneratorBehaviour
// 0x0048 (0x00A0 - 0x0058)
class UAICharacterRepairGeneratorBehaviour final : public UAICharacterBehaviour
{
public:
	uint8                                         Pad_58[0x18];                                      // 0x0058(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _aiPlayer;                                         // 0x0070(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDAIPlayerController*                 _aiPlayerController;                               // 0x0078(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractor*                            _targetInteractor;                                 // 0x0080(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAICharacterRepairGeneratorBehaviourData* _characterRepairGeneratorData;                   // 0x0088(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x10];                                      // 0x0090(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGeneratorRepairedEventHandler(bool isAutoCompleted);
	void OnMovementFinished(const struct FAIRequestID& RequestID, EPathFollowingResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterRepairGeneratorBehaviour">();
	}
	static class UAICharacterRepairGeneratorBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterRepairGeneratorBehaviour>();
	}
};
static_assert(alignof(UAICharacterRepairGeneratorBehaviour) == 0x000008, "Wrong alignment on UAICharacterRepairGeneratorBehaviour");
static_assert(sizeof(UAICharacterRepairGeneratorBehaviour) == 0x0000A0, "Wrong size on UAICharacterRepairGeneratorBehaviour");
static_assert(offsetof(UAICharacterRepairGeneratorBehaviour, _aiPlayer) == 0x000070, "Member 'UAICharacterRepairGeneratorBehaviour::_aiPlayer' has a wrong offset!");
static_assert(offsetof(UAICharacterRepairGeneratorBehaviour, _aiPlayerController) == 0x000078, "Member 'UAICharacterRepairGeneratorBehaviour::_aiPlayerController' has a wrong offset!");
static_assert(offsetof(UAICharacterRepairGeneratorBehaviour, _targetInteractor) == 0x000080, "Member 'UAICharacterRepairGeneratorBehaviour::_targetInteractor' has a wrong offset!");
static_assert(offsetof(UAICharacterRepairGeneratorBehaviour, _characterRepairGeneratorData) == 0x000088, "Member 'UAICharacterRepairGeneratorBehaviour::_characterRepairGeneratorData' has a wrong offset!");

// Class DeadByDaylight.DBDAttackOpenSubstate
// 0x0000 (0x0118 - 0x0118)
class UDBDAttackOpenSubstate : public UDBDAttackSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAttackOpenSubstate">();
	}
	static class UDBDAttackOpenSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAttackOpenSubstate>();
	}
};
static_assert(alignof(UDBDAttackOpenSubstate) == 0x000008, "Wrong alignment on UDBDAttackOpenSubstate");
static_assert(sizeof(UDBDAttackOpenSubstate) == 0x000118, "Wrong size on UDBDAttackOpenSubstate");

// Class DeadByDaylight.DBDBaseActorSpawnerActor2
// 0x0010 (0x02B0 - 0x02A0)
class ADBDBaseActorSpawnerActor2 : public AActor
{
public:
	uint8                                         Pad_2A0[0x10];                                     // 0x02A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBaseActorSpawnerActor2">();
	}
	static class ADBDBaseActorSpawnerActor2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDBaseActorSpawnerActor2>();
	}
};
static_assert(alignof(ADBDBaseActorSpawnerActor2) == 0x000008, "Wrong alignment on ADBDBaseActorSpawnerActor2");
static_assert(sizeof(ADBDBaseActorSpawnerActor2) == 0x0002B0, "Wrong size on ADBDBaseActorSpawnerActor2");

// Class DeadByDaylight.DBDTileSpawnPointActor2
// 0x0008 (0x02B8 - 0x02B0)
class ADBDTileSpawnPointActor2 final : public ADBDBaseActorSpawnerActor2
{
public:
	class UTileSpawnPoint*                        tileSpawnPointComponent;                           // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDTileSpawnPointActor2">();
	}
	static class ADBDTileSpawnPointActor2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDTileSpawnPointActor2>();
	}
};
static_assert(alignof(ADBDTileSpawnPointActor2) == 0x000008, "Wrong alignment on ADBDTileSpawnPointActor2");
static_assert(sizeof(ADBDTileSpawnPointActor2) == 0x0002B8, "Wrong size on ADBDTileSpawnPointActor2");
static_assert(offsetof(ADBDTileSpawnPointActor2, tileSpawnPointComponent) == 0x0002B0, "Member 'ADBDTileSpawnPointActor2::tileSpawnPointComponent' has a wrong offset!");

// Class DeadByDaylight.DBDAttackSuccessSubstate
// 0x0000 (0x0118 - 0x0118)
class UDBDAttackSuccessSubstate : public UDBDAttackSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAttackSuccessSubstate">();
	}
	static class UDBDAttackSuccessSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAttackSuccessSubstate>();
	}
};
static_assert(alignof(UDBDAttackSuccessSubstate) == 0x000008, "Wrong alignment on UDBDAttackSuccessSubstate");
static_assert(sizeof(UDBDAttackSuccessSubstate) == 0x000118, "Wrong size on UDBDAttackSuccessSubstate");

// Class DeadByDaylight.GameplaySpawnerComponent
// 0x0038 (0x00F0 - 0x00B8)
class UGameplaySpawnerComponent : public UActorComponent
{
public:
	TArray<class UActorComponent*>                _spawnedComponents;                                // 0x00B8(0x0010)(ExportObject, Net, ZeroConstructor, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	int32                                         _numComponentsSpawned;                             // 0x00C8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _numComponentsToSpawn;                             // 0x00CC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x20];                                      // 0x00D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_SpawnedComponents();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplaySpawnerComponent">();
	}
	static class UGameplaySpawnerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplaySpawnerComponent>();
	}
};
static_assert(alignof(UGameplaySpawnerComponent) == 0x000008, "Wrong alignment on UGameplaySpawnerComponent");
static_assert(sizeof(UGameplaySpawnerComponent) == 0x0000F0, "Wrong size on UGameplaySpawnerComponent");
static_assert(offsetof(UGameplaySpawnerComponent, _spawnedComponents) == 0x0000B8, "Member 'UGameplaySpawnerComponent::_spawnedComponents' has a wrong offset!");
static_assert(offsetof(UGameplaySpawnerComponent, _numComponentsSpawned) == 0x0000C8, "Member 'UGameplaySpawnerComponent::_numComponentsSpawned' has a wrong offset!");
static_assert(offsetof(UGameplaySpawnerComponent, _numComponentsToSpawn) == 0x0000CC, "Member 'UGameplaySpawnerComponent::_numComponentsToSpawn' has a wrong offset!");

// Class DeadByDaylight.SpecialBehaviourGameplaySpawnerComponent
// 0x0000 (0x00F0 - 0x00F0)
class USpecialBehaviourGameplaySpawnerComponent final : public UGameplaySpawnerComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecialBehaviourGameplaySpawnerComponent">();
	}
	static class USpecialBehaviourGameplaySpawnerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpecialBehaviourGameplaySpawnerComponent>();
	}
};
static_assert(alignof(USpecialBehaviourGameplaySpawnerComponent) == 0x000008, "Wrong alignment on USpecialBehaviourGameplaySpawnerComponent");
static_assert(sizeof(USpecialBehaviourGameplaySpawnerComponent) == 0x0000F0, "Wrong size on USpecialBehaviourGameplaySpawnerComponent");

// Class DeadByDaylight.DLCManager
// 0x0060 (0x0098 - 0x0038)
class UDLCManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x60];                                      // 0x0038(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DLCManager">();
	}
	static class UDLCManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDLCManager>();
	}
};
static_assert(alignof(UDLCManager) == 0x000008, "Wrong alignment on UDLCManager");
static_assert(sizeof(UDLCManager) == 0x000098, "Wrong size on UDLCManager");

// Class DeadByDaylight.SurvivorTrapPerk
// 0x0088 (0x04E8 - 0x0460)
class USurvivorTrapPerk : public UPerk
{
public:
	uint8                                         Pad_460[0x8];                                      // 0x0460(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ETrapType                                     _trapType;                                         // 0x0468(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_469[0x7];                                      // 0x0469(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AInteractable>              _trappableInteractableType;                        // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _progressPercentRequirementLevels[0x3];            // 0x0478(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _trapDurationLevels[0x3];                          // 0x0484(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AInteractable*                          _trappedInteractable;                              // 0x0490(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTrapInstallerComponent>    _trapInstallerComponentClass;                      // 0x0498(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A0[0x38];                                     // 0x04A0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _progressPercent;                                  // 0x04D8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isTrapReady;                                      // 0x04DC(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4DD[0xB];                                      // 0x04DD(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnKillerInteracted(const struct FGameplayTag& GameEventTag, const struct FGameEventData& GameEventData);
	void Authority_OnRepairProgress(float IndividualChargeAmount, float TotalChargeAmount, class AActor* ChargeInstigator, bool WasCoop, float DeltaTime);
	void Authority_OnSurvivorRemoved(class ASurvivor* Survivor);
	void Authority_OnTrapInteractionEvent(const struct FGameplayTag& GameEvent, const struct FGameEventData& GameEventData);
	void Authority_OnTrapTimerDone();
	void OnRep_TrappedInteractable(class AInteractable* oldInteractable);

	class UPerkTrappableComponent* GetPerkTrappableComponent(class AInteractable* Interactable) const;
	float GetRepairProgressPercent() const;
	float GetRequiredRepairProgressForActivation() const;
	float GetTrapDuration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorTrapPerk">();
	}
	static class USurvivorTrapPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorTrapPerk>();
	}
};
static_assert(alignof(USurvivorTrapPerk) == 0x000008, "Wrong alignment on USurvivorTrapPerk");
static_assert(sizeof(USurvivorTrapPerk) == 0x0004E8, "Wrong size on USurvivorTrapPerk");
static_assert(offsetof(USurvivorTrapPerk, _trapType) == 0x000468, "Member 'USurvivorTrapPerk::_trapType' has a wrong offset!");
static_assert(offsetof(USurvivorTrapPerk, _trappableInteractableType) == 0x000470, "Member 'USurvivorTrapPerk::_trappableInteractableType' has a wrong offset!");
static_assert(offsetof(USurvivorTrapPerk, _progressPercentRequirementLevels) == 0x000478, "Member 'USurvivorTrapPerk::_progressPercentRequirementLevels' has a wrong offset!");
static_assert(offsetof(USurvivorTrapPerk, _trapDurationLevels) == 0x000484, "Member 'USurvivorTrapPerk::_trapDurationLevels' has a wrong offset!");
static_assert(offsetof(USurvivorTrapPerk, _trappedInteractable) == 0x000490, "Member 'USurvivorTrapPerk::_trappedInteractable' has a wrong offset!");
static_assert(offsetof(USurvivorTrapPerk, _trapInstallerComponentClass) == 0x000498, "Member 'USurvivorTrapPerk::_trapInstallerComponentClass' has a wrong offset!");
static_assert(offsetof(USurvivorTrapPerk, _progressPercent) == 0x0004D8, "Member 'USurvivorTrapPerk::_progressPercent' has a wrong offset!");
static_assert(offsetof(USurvivorTrapPerk, _isTrapReady) == 0x0004DC, "Member 'USurvivorTrapPerk::_isTrapReady' has a wrong offset!");

// Class DeadByDaylight.FoliageDensityHISM
// 0x0000 (0x0970 - 0x0970)
class UFoliageDensityHISM final : public UHierarchicalInstancedStaticMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FoliageDensityHISM">();
	}
	static class UFoliageDensityHISM* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFoliageDensityHISM>();
	}
};
static_assert(alignof(UFoliageDensityHISM) == 0x000010, "Wrong alignment on UFoliageDensityHISM");
static_assert(sizeof(UFoliageDensityHISM) == 0x000970, "Wrong size on UFoliageDensityHISM");

// Class DeadByDaylight.DBDAttackMissSubstate
// 0x0000 (0x0118 - 0x0118)
class UDBDAttackMissSubstate : public UDBDAttackSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAttackMissSubstate">();
	}
	static class UDBDAttackMissSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAttackMissSubstate>();
	}
};
static_assert(alignof(UDBDAttackMissSubstate) == 0x000008, "Wrong alignment on UDBDAttackMissSubstate");
static_assert(sizeof(UDBDAttackMissSubstate) == 0x000118, "Wrong size on UDBDAttackMissSubstate");

// Class DeadByDaylight.DBDAttackObstructSubstate
// 0x0000 (0x0118 - 0x0118)
class UDBDAttackObstructSubstate : public UDBDAttackSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAttackObstructSubstate">();
	}
	static class UDBDAttackObstructSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAttackObstructSubstate>();
	}
};
static_assert(alignof(UDBDAttackObstructSubstate) == 0x000008, "Wrong alignment on UDBDAttackObstructSubstate");
static_assert(sizeof(UDBDAttackObstructSubstate) == 0x000118, "Wrong size on UDBDAttackObstructSubstate");

// Class DeadByDaylight.SpecialHookDrainStageComponent
// 0x0008 (0x00C0 - 0x00B8)
class USpecialHookDrainStageComponent final : public UActorComponent
{
public:
	bool                                          _hasSpecialHookDrainStage;                         // 0x00B8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecialHookDrainStageComponent">();
	}
	static class USpecialHookDrainStageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpecialHookDrainStageComponent>();
	}
};
static_assert(alignof(USpecialHookDrainStageComponent) == 0x000008, "Wrong alignment on USpecialHookDrainStageComponent");
static_assert(sizeof(USpecialHookDrainStageComponent) == 0x0000C0, "Wrong size on USpecialHookDrainStageComponent");
static_assert(offsetof(USpecialHookDrainStageComponent, _hasSpecialHookDrainStage) == 0x0000B8, "Member 'USpecialHookDrainStageComponent::_hasSpecialHookDrainStage' has a wrong offset!");

// Class DeadByDaylight.BloodwebManager
// 0x0218 (0x0248 - 0x0030)
class UBloodwebManager final : public UObject
{
public:
	uint8                                         Pad_30[0x78];                                      // 0x0030(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UBloodwebGenerator>         _bloodwebBuilderClass;                             // 0x00A8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDGameInstance*                       _gameInstance;                                     // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBaseBloodwebContentAdapter*            _bloodWebContentAdapter;                           // 0x00B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBloodwebHandler*                       _bloodwebHandler;                                  // 0x00C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBloodwebPathfinder*                    _bloodwebPathfinder;                               // 0x00C8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x178];                                     // 0x00D0(0x0178)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class UDBDGameInstance* GameInstance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodwebManager">();
	}
	static class UBloodwebManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodwebManager>();
	}
};
static_assert(alignof(UBloodwebManager) == 0x000008, "Wrong alignment on UBloodwebManager");
static_assert(sizeof(UBloodwebManager) == 0x000248, "Wrong size on UBloodwebManager");
static_assert(offsetof(UBloodwebManager, _bloodwebBuilderClass) == 0x0000A8, "Member 'UBloodwebManager::_bloodwebBuilderClass' has a wrong offset!");
static_assert(offsetof(UBloodwebManager, _gameInstance) == 0x0000B0, "Member 'UBloodwebManager::_gameInstance' has a wrong offset!");
static_assert(offsetof(UBloodwebManager, _bloodWebContentAdapter) == 0x0000B8, "Member 'UBloodwebManager::_bloodWebContentAdapter' has a wrong offset!");
static_assert(offsetof(UBloodwebManager, _bloodwebHandler) == 0x0000C0, "Member 'UBloodwebManager::_bloodwebHandler' has a wrong offset!");
static_assert(offsetof(UBloodwebManager, _bloodwebPathfinder) == 0x0000C8, "Member 'UBloodwebManager::_bloodwebPathfinder' has a wrong offset!");

// Class DeadByDaylight.AttackableComponent
// 0x0000 (0x00B8 - 0x00B8)
class UAttackableComponent : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttackableComponent">();
	}
	static class UAttackableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttackableComponent>();
	}
};
static_assert(alignof(UAttackableComponent) == 0x000008, "Wrong alignment on UAttackableComponent");
static_assert(sizeof(UAttackableComponent) == 0x0000B8, "Wrong size on UAttackableComponent");

// Class DeadByDaylight.AnimTagProvider
// 0x0000 (0x0000 - 0x0000)
class IAnimTagProvider final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimTagProvider">();
	}
	static class IAnimTagProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAnimTagProvider>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IAnimTagProvider) == 0x000001, "Wrong alignment on IAnimTagProvider");
static_assert(sizeof(IAnimTagProvider) == 0x000001, "Wrong size on IAnimTagProvider");

// Class DeadByDaylight.ChargeStrategy
// 0x0018 (0x0048 - 0x0030)
class UChargeStrategy final : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _shouldApplyRedirectedChargeNormally;              // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _shouldBroadcastChargeApplied;                     // 0x0041(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _shouldApplyModifiersToRedirectedCharge;           // 0x0042(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _shouldAllowChargeFromItem;                        // 0x0043(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _shouldRedirectSkillcheckChargePenalty;            // 0x0044(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChargeStrategy">();
	}
	static class UChargeStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChargeStrategy>();
	}
};
static_assert(alignof(UChargeStrategy) == 0x000008, "Wrong alignment on UChargeStrategy");
static_assert(sizeof(UChargeStrategy) == 0x000048, "Wrong size on UChargeStrategy");
static_assert(offsetof(UChargeStrategy, _shouldApplyRedirectedChargeNormally) == 0x000040, "Member 'UChargeStrategy::_shouldApplyRedirectedChargeNormally' has a wrong offset!");
static_assert(offsetof(UChargeStrategy, _shouldBroadcastChargeApplied) == 0x000041, "Member 'UChargeStrategy::_shouldBroadcastChargeApplied' has a wrong offset!");
static_assert(offsetof(UChargeStrategy, _shouldApplyModifiersToRedirectedCharge) == 0x000042, "Member 'UChargeStrategy::_shouldApplyModifiersToRedirectedCharge' has a wrong offset!");
static_assert(offsetof(UChargeStrategy, _shouldAllowChargeFromItem) == 0x000043, "Member 'UChargeStrategy::_shouldAllowChargeFromItem' has a wrong offset!");
static_assert(offsetof(UChargeStrategy, _shouldRedirectSkillcheckChargePenalty) == 0x000044, "Member 'UChargeStrategy::_shouldRedirectSkillcheckChargePenalty' has a wrong offset!");

// Class DeadByDaylight.BlindableBaseComponent
// 0x01B8 (0x0270 - 0x00B8)
class UBlindableBaseComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0xA8];                                      // 0x00B8(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isBlinded;                                        // 0x0160(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_161[0x7];                                      // 0x0161(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTagStateBool                          _isBeingBlinded;                                   // 0x0168(0x0048)(Net, Transient, Protected, NativeAccessSpecifierProtected)
	class UChargeableComponent*                   _chargeableComponent;                              // 0x01B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class AActor*, TScriptInterface<class IBlindingEffectorInterface>> _authority_blindingEffectors; // 0x01B8(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_208[0x68];                                     // 0x0208(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_AddBlindingEffector(TScriptInterface<class IBlindingEffectorInterface> effector);
	void Authority_Blinded(EBlindType blindType, float BlindnessDuration, class AActor* effectorActor);
	void Authority_RemoveBlindingEffector(TScriptInterface<class IBlindingEffectorInterface> effector);
	void OnChargeableCompletionPercentChanged(class UChargeableComponent* ChargeableComponent, float TotalPercentComplete);
	void OnRep_IsBlinded();
	void SetChargeable(class UChargeableComponent* Value);

	bool IsBlinded() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlindableBaseComponent">();
	}
	static class UBlindableBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlindableBaseComponent>();
	}
};
static_assert(alignof(UBlindableBaseComponent) == 0x000008, "Wrong alignment on UBlindableBaseComponent");
static_assert(sizeof(UBlindableBaseComponent) == 0x000270, "Wrong size on UBlindableBaseComponent");
static_assert(offsetof(UBlindableBaseComponent, _isBlinded) == 0x000160, "Member 'UBlindableBaseComponent::_isBlinded' has a wrong offset!");
static_assert(offsetof(UBlindableBaseComponent, _isBeingBlinded) == 0x000168, "Member 'UBlindableBaseComponent::_isBeingBlinded' has a wrong offset!");
static_assert(offsetof(UBlindableBaseComponent, _chargeableComponent) == 0x0001B0, "Member 'UBlindableBaseComponent::_chargeableComponent' has a wrong offset!");
static_assert(offsetof(UBlindableBaseComponent, _authority_blindingEffectors) == 0x0001B8, "Member 'UBlindableBaseComponent::_authority_blindingEffectors' has a wrong offset!");

// Class DeadByDaylight.RBTOutlineUpdateStrategy
// 0x0000 (0x0100 - 0x0100)
class URBTOutlineUpdateStrategy final : public UDefaultOutlineUpdateStrategy
{
public:
	bool IsRevealedToLocalPlayer_BP(const class ADBDPlayer* Player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RBTOutlineUpdateStrategy">();
	}
	static class URBTOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<URBTOutlineUpdateStrategy>();
	}
};
static_assert(alignof(URBTOutlineUpdateStrategy) == 0x000008, "Wrong alignment on URBTOutlineUpdateStrategy");
static_assert(sizeof(URBTOutlineUpdateStrategy) == 0x000100, "Wrong size on URBTOutlineUpdateStrategy");

// Class DeadByDaylight.DBDDangerPredictionComponent
// 0x0068 (0x0120 - 0x00B8)
class UDBDDangerPredictionComponent : public UActorComponent
{
public:
	bool                                          ApplyAdditionalCostInDangerArea;                   // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESurvivorFleePathStrategy                     SurvivorFleePathStrategy;                          // 0x00B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x2];                                       // 0x00BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RelevantHorizontalDistance;                        // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RelevantVerticalDistance;                          // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDangerTraversePriority                       DangerTraversePriority;                            // 0x00C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerRole                                   RelevantRole;                                      // 0x00C5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C6[0x2];                                       // 0x00C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEQSParametrizedQueryExecutionRequest  FleeEQSRequest;                                    // 0x00C8(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDDangerPredictionComponent">();
	}
	static class UDBDDangerPredictionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDDangerPredictionComponent>();
	}
};
static_assert(alignof(UDBDDangerPredictionComponent) == 0x000008, "Wrong alignment on UDBDDangerPredictionComponent");
static_assert(sizeof(UDBDDangerPredictionComponent) == 0x000120, "Wrong size on UDBDDangerPredictionComponent");
static_assert(offsetof(UDBDDangerPredictionComponent, ApplyAdditionalCostInDangerArea) == 0x0000B8, "Member 'UDBDDangerPredictionComponent::ApplyAdditionalCostInDangerArea' has a wrong offset!");
static_assert(offsetof(UDBDDangerPredictionComponent, SurvivorFleePathStrategy) == 0x0000B9, "Member 'UDBDDangerPredictionComponent::SurvivorFleePathStrategy' has a wrong offset!");
static_assert(offsetof(UDBDDangerPredictionComponent, RelevantHorizontalDistance) == 0x0000BC, "Member 'UDBDDangerPredictionComponent::RelevantHorizontalDistance' has a wrong offset!");
static_assert(offsetof(UDBDDangerPredictionComponent, RelevantVerticalDistance) == 0x0000C0, "Member 'UDBDDangerPredictionComponent::RelevantVerticalDistance' has a wrong offset!");
static_assert(offsetof(UDBDDangerPredictionComponent, DangerTraversePriority) == 0x0000C4, "Member 'UDBDDangerPredictionComponent::DangerTraversePriority' has a wrong offset!");
static_assert(offsetof(UDBDDangerPredictionComponent, RelevantRole) == 0x0000C5, "Member 'UDBDDangerPredictionComponent::RelevantRole' has a wrong offset!");
static_assert(offsetof(UDBDDangerPredictionComponent, FleeEQSRequest) == 0x0000C8, "Member 'UDBDDangerPredictionComponent::FleeEQSRequest' has a wrong offset!");

// Class DeadByDaylight.BlindingFXComponent
// 0x0050 (0x0108 - 0x00B8)
class UBlindingFXComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x14];                                      // 0x00B8(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _blindnessIntensityParameter;                      // 0x00CC(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _blindnessMaterialCurve;                           // 0x00D8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _blindnessCurve;                                   // 0x00E0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPostProcessComponent*                  _postProcess;                                      // 0x00E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _postProcessMaterial;                              // 0x00F0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x10];                                      // 0x00F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetPostProcess(class UPostProcessComponent* Value);
	void SetPostProcessMaterial(class UMaterialInstanceDynamic* Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlindingFXComponent">();
	}
	static class UBlindingFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlindingFXComponent>();
	}
};
static_assert(alignof(UBlindingFXComponent) == 0x000008, "Wrong alignment on UBlindingFXComponent");
static_assert(sizeof(UBlindingFXComponent) == 0x000108, "Wrong size on UBlindingFXComponent");
static_assert(offsetof(UBlindingFXComponent, _blindnessIntensityParameter) == 0x0000CC, "Member 'UBlindingFXComponent::_blindnessIntensityParameter' has a wrong offset!");
static_assert(offsetof(UBlindingFXComponent, _blindnessMaterialCurve) == 0x0000D8, "Member 'UBlindingFXComponent::_blindnessMaterialCurve' has a wrong offset!");
static_assert(offsetof(UBlindingFXComponent, _blindnessCurve) == 0x0000E0, "Member 'UBlindingFXComponent::_blindnessCurve' has a wrong offset!");
static_assert(offsetof(UBlindingFXComponent, _postProcess) == 0x0000E8, "Member 'UBlindingFXComponent::_postProcess' has a wrong offset!");
static_assert(offsetof(UBlindingFXComponent, _postProcessMaterial) == 0x0000F0, "Member 'UBlindingFXComponent::_postProcessMaterial' has a wrong offset!");

// Class DeadByDaylight.StoreMenuFlowEventsGenerator
// 0x0010 (0x0040 - 0x0030)
class UStoreMenuFlowEventsGenerator final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULocalEventManager*                     _localEventManager;                                // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreMenuFlowEventsGenerator">();
	}
	static class UStoreMenuFlowEventsGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreMenuFlowEventsGenerator>();
	}
};
static_assert(alignof(UStoreMenuFlowEventsGenerator) == 0x000008, "Wrong alignment on UStoreMenuFlowEventsGenerator");
static_assert(sizeof(UStoreMenuFlowEventsGenerator) == 0x000040, "Wrong size on UStoreMenuFlowEventsGenerator");
static_assert(offsetof(UStoreMenuFlowEventsGenerator, _localEventManager) == 0x000038, "Member 'UStoreMenuFlowEventsGenerator::_localEventManager' has a wrong offset!");

// Class DeadByDaylight.CustomizationPresetController
// 0x0000 (0x0030 - 0x0030)
class UCustomizationPresetController final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationPresetController">();
	}
	static class UCustomizationPresetController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationPresetController>();
	}
};
static_assert(alignof(UCustomizationPresetController) == 0x000008, "Wrong alignment on UCustomizationPresetController");
static_assert(sizeof(UCustomizationPresetController) == 0x000030, "Wrong size on UCustomizationPresetController");

// Class DeadByDaylight.VisualFXOverrideUtilities
// 0x0000 (0x0030 - 0x0030)
class UVisualFXOverrideUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VisualFXOverrideUtilities">();
	}
	static class UVisualFXOverrideUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVisualFXOverrideUtilities>();
	}
};
static_assert(alignof(UVisualFXOverrideUtilities) == 0x000008, "Wrong alignment on UVisualFXOverrideUtilities");
static_assert(sizeof(UVisualFXOverrideUtilities) == 0x000030, "Wrong size on UVisualFXOverrideUtilities");

// Class DeadByDaylight.AnimNotifyState_HideCustomizationAttachments
// 0x0008 (0x0040 - 0x0038)
class UAnimNotifyState_HideCustomizationAttachments final : public UAnimNotifyState
{
public:
	ECustomizationCategory                        category;                                          // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_HideCustomizationAttachments">();
	}
	static class UAnimNotifyState_HideCustomizationAttachments* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_HideCustomizationAttachments>();
	}
};
static_assert(alignof(UAnimNotifyState_HideCustomizationAttachments) == 0x000008, "Wrong alignment on UAnimNotifyState_HideCustomizationAttachments");
static_assert(sizeof(UAnimNotifyState_HideCustomizationAttachments) == 0x000040, "Wrong size on UAnimNotifyState_HideCustomizationAttachments");
static_assert(offsetof(UAnimNotifyState_HideCustomizationAttachments, category) == 0x000038, "Member 'UAnimNotifyState_HideCustomizationAttachments::category' has a wrong offset!");

// Class DeadByDaylight.KillerRedStainUpdateStrategy
// 0x0040 (0x00F8 - 0x00B8)
class UKillerRedStainUpdateStrategy : public UActorComponent
{
public:
	class UCurveFloat*                            _stealthRatioToRedStainIntensityCurve;             // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  _hideRedStainStateTags;                            // 0x00C0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x18];                                      // 0x00E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHeadHiddenChanged(bool IsHidden);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerRedStainUpdateStrategy">();
	}
	static class UKillerRedStainUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerRedStainUpdateStrategy>();
	}
};
static_assert(alignof(UKillerRedStainUpdateStrategy) == 0x000008, "Wrong alignment on UKillerRedStainUpdateStrategy");
static_assert(sizeof(UKillerRedStainUpdateStrategy) == 0x0000F8, "Wrong size on UKillerRedStainUpdateStrategy");
static_assert(offsetof(UKillerRedStainUpdateStrategy, _stealthRatioToRedStainIntensityCurve) == 0x0000B8, "Member 'UKillerRedStainUpdateStrategy::_stealthRatioToRedStainIntensityCurve' has a wrong offset!");
static_assert(offsetof(UKillerRedStainUpdateStrategy, _hideRedStainStateTags) == 0x0000C0, "Member 'UKillerRedStainUpdateStrategy::_hideRedStainStateTags' has a wrong offset!");

// Class DeadByDaylight.SeancePerk
// 0x0050 (0x04B0 - 0x0460)
class USeancePerk : public UPerk
{
public:
	TSubclassOf<class USeancePerformerComponent>  _seancePerformerComponentClass;                    // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _brokenEffect;                                     // 0x0468(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _seanceCompletedSurvivorStatusEffectClass;         // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _seanceCompletedKillerStatusEffectClass;           // 0x0478(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isRitualOngoing;                                  // 0x0480(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _destructivePerk;                                  // 0x0481(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESeanceState                                  _seanceState;                                      // 0x0482(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_483[0x2D];                                     // 0x0483(0x002D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeancePerk">();
	}
	static class USeancePerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeancePerk>();
	}
};
static_assert(alignof(USeancePerk) == 0x000008, "Wrong alignment on USeancePerk");
static_assert(sizeof(USeancePerk) == 0x0004B0, "Wrong size on USeancePerk");
static_assert(offsetof(USeancePerk, _seancePerformerComponentClass) == 0x000460, "Member 'USeancePerk::_seancePerformerComponentClass' has a wrong offset!");
static_assert(offsetof(USeancePerk, _brokenEffect) == 0x000468, "Member 'USeancePerk::_brokenEffect' has a wrong offset!");
static_assert(offsetof(USeancePerk, _seanceCompletedSurvivorStatusEffectClass) == 0x000470, "Member 'USeancePerk::_seanceCompletedSurvivorStatusEffectClass' has a wrong offset!");
static_assert(offsetof(USeancePerk, _seanceCompletedKillerStatusEffectClass) == 0x000478, "Member 'USeancePerk::_seanceCompletedKillerStatusEffectClass' has a wrong offset!");
static_assert(offsetof(USeancePerk, _isRitualOngoing) == 0x000480, "Member 'USeancePerk::_isRitualOngoing' has a wrong offset!");
static_assert(offsetof(USeancePerk, _destructivePerk) == 0x000481, "Member 'USeancePerk::_destructivePerk' has a wrong offset!");
static_assert(offsetof(USeancePerk, _seanceState) == 0x000482, "Member 'USeancePerk::_seanceState' has a wrong offset!");

// Class DeadByDaylight.KillerBlindingFXComponent
// 0x0048 (0x0150 - 0x0108)
class UKillerBlindingFXComponent : public UBlindingFXComponent
{
public:
	uint8                                         Pad_108[0x18];                                     // 0x0108(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          _blindedSound;                                     // 0x0120(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_128[0x28];                                     // 0x0128(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_OnBlindedByPlayersCosmetic(const TArray<class ADBDPlayer*>& Players);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerBlindingFXComponent">();
	}
	static class UKillerBlindingFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerBlindingFXComponent>();
	}
};
static_assert(alignof(UKillerBlindingFXComponent) == 0x000008, "Wrong alignment on UKillerBlindingFXComponent");
static_assert(sizeof(UKillerBlindingFXComponent) == 0x000150, "Wrong size on UKillerBlindingFXComponent");
static_assert(offsetof(UKillerBlindingFXComponent, _blindedSound) == 0x000120, "Member 'UKillerBlindingFXComponent::_blindedSound' has a wrong offset!");

// Class DeadByDaylight.MapSpecificGameStateComponent
// 0x0000 (0x00B8 - 0x00B8)
class UMapSpecificGameStateComponent : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapSpecificGameStateComponent">();
	}
	static class UMapSpecificGameStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapSpecificGameStateComponent>();
	}
};
static_assert(alignof(UMapSpecificGameStateComponent) == 0x000008, "Wrong alignment on UMapSpecificGameStateComponent");
static_assert(sizeof(UMapSpecificGameStateComponent) == 0x0000B8, "Wrong size on UMapSpecificGameStateComponent");

// Class DeadByDaylight.MapSpecificLocalPlayerEffects
// 0x0040 (0x00F8 - 0x00B8)
class UMapSpecificLocalPlayerEffects final : public UMapSpecificGameStateComponent
{
public:
	uint8                                         Pad_B8[0x30];                                      // 0x00B8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ADBDPlayerController>    _cachedLocalPlayerController;                      // 0x00E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      _niagaraComponent;                                 // 0x00F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Local_SpawnOnLocalCamera(class UCameraComponent* localCamera);
	void OnObservedActorChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapSpecificLocalPlayerEffects">();
	}
	static class UMapSpecificLocalPlayerEffects* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapSpecificLocalPlayerEffects>();
	}
};
static_assert(alignof(UMapSpecificLocalPlayerEffects) == 0x000008, "Wrong alignment on UMapSpecificLocalPlayerEffects");
static_assert(sizeof(UMapSpecificLocalPlayerEffects) == 0x0000F8, "Wrong size on UMapSpecificLocalPlayerEffects");
static_assert(offsetof(UMapSpecificLocalPlayerEffects, _cachedLocalPlayerController) == 0x0000E8, "Member 'UMapSpecificLocalPlayerEffects::_cachedLocalPlayerController' has a wrong offset!");
static_assert(offsetof(UMapSpecificLocalPlayerEffects, _niagaraComponent) == 0x0000F0, "Member 'UMapSpecificLocalPlayerEffects::_niagaraComponent' has a wrong offset!");

// Class DeadByDaylight.VaultDefinition
// 0x0060 (0x07D0 - 0x0770)
#pragma pack(push, 0x1)
class alignas(0x10) UVaultDefinition : public UInteractionDefinition
{
public:
	struct FGameplayTag                           _vaultGameEvent;                                   // 0x0768(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _feetOffGroundID;                                  // 0x0774(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _feetOnGroundID;                                   // 0x0780(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _allowedHeightDelta;                               // 0x078C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isFall;                                           // 0x0790(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_791[0x37];                                     // 0x0791(0x0037)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsWindowVaultable() const;
	bool IsWithinHeightDelta(const class ADBDPlayer* Player) const;
	bool ShouldLaunchCharacter(const class ADBDPlayer* Player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VaultDefinition">();
	}
	static class UVaultDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVaultDefinition>();
	}
};
#pragma pack(pop)
static_assert(alignof(UVaultDefinition) == 0x000010, "Wrong alignment on UVaultDefinition");
static_assert(sizeof(UVaultDefinition) == 0x0007D0, "Wrong size on UVaultDefinition");
static_assert(offsetof(UVaultDefinition, _vaultGameEvent) == 0x000768, "Member 'UVaultDefinition::_vaultGameEvent' has a wrong offset!");
static_assert(offsetof(UVaultDefinition, _feetOffGroundID) == 0x000774, "Member 'UVaultDefinition::_feetOffGroundID' has a wrong offset!");
static_assert(offsetof(UVaultDefinition, _feetOnGroundID) == 0x000780, "Member 'UVaultDefinition::_feetOnGroundID' has a wrong offset!");
static_assert(offsetof(UVaultDefinition, _allowedHeightDelta) == 0x00078C, "Member 'UVaultDefinition::_allowedHeightDelta' has a wrong offset!");
static_assert(offsetof(UVaultDefinition, _isFall) == 0x000790, "Member 'UVaultDefinition::_isFall' has a wrong offset!");

// Class DeadByDaylight.SpherePlayerOverlapComponent
// 0x0000 (0x05D0 - 0x05D0)
class USpherePlayerOverlapComponent final : public USphereComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpherePlayerOverlapComponent">();
	}
	static class USpherePlayerOverlapComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpherePlayerOverlapComponent>();
	}
};
static_assert(alignof(USpherePlayerOverlapComponent) == 0x000010, "Wrong alignment on USpherePlayerOverlapComponent");
static_assert(sizeof(USpherePlayerOverlapComponent) == 0x0005D0, "Wrong size on USpherePlayerOverlapComponent");

// Class DeadByDaylight.AutomaticLeanComponent
// 0x0398 (0x0450 - 0x00B8)
class UAutomaticLeanComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(ELeanState leanState)> OnLeanStateChanged;                         // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(ELeanState leanState)> OnPotentialLeanStateChanged;                // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool canInitiate)> OnCanInitiateLeanChanged;                       // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FSocketOrBoneCache                     _cameraIdleLocation;                               // 0x00E8(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	struct FSocketOrBoneCache                     _cameraLeftLeanLocation;                           // 0x0168(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	struct FSocketOrBoneCache                     _cameraRightLeanLocation;                          // 0x01E8(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	struct FSocketOrBoneCache                     _cameraCrouchLocation;                             // 0x0268(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	struct FSocketOrBoneCache                     _cameraCrouchLeftLeanLocation;                     // 0x02E8(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	struct FSocketOrBoneCache                     _cameraCrouchRightLeanLocation;                    // 0x0368(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	float                                         _middleSphereTraceLength;                          // 0x03E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sideSphereTraceLength;                            // 0x03EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sphereTraceRadius;                                // 0x03F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _standingTraceHeightOffset;                        // 0x03F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _crouchingTraceHeightOffset;                       // 0x03F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sideTraceOffset;                                  // 0x03FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxCameraDistance;                                // 0x0400(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxCameraAngle;                                   // 0x0404(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _debugMode;                                        // 0x0408(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELeanState                                    _leanState;                                        // 0x0409(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40A[0x46];                                     // 0x040A(0x0046)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Local_Lean();
	void Local_Unlean();
	void OnRep_LeanState();
	void Server_SetLeanState(ELeanState leanState);

	bool CanInitiateLean() const;
	float GetAvailableDistanceInFrontOfCamera() const;
	ELeanState GetLeanState() const;
	ELeanState GetPotentialLeanState() const;
	bool IsLeaning() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutomaticLeanComponent">();
	}
	static class UAutomaticLeanComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutomaticLeanComponent>();
	}
};
static_assert(alignof(UAutomaticLeanComponent) == 0x000008, "Wrong alignment on UAutomaticLeanComponent");
static_assert(sizeof(UAutomaticLeanComponent) == 0x000450, "Wrong size on UAutomaticLeanComponent");
static_assert(offsetof(UAutomaticLeanComponent, OnLeanStateChanged) == 0x0000B8, "Member 'UAutomaticLeanComponent::OnLeanStateChanged' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, OnPotentialLeanStateChanged) == 0x0000C8, "Member 'UAutomaticLeanComponent::OnPotentialLeanStateChanged' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, OnCanInitiateLeanChanged) == 0x0000D8, "Member 'UAutomaticLeanComponent::OnCanInitiateLeanChanged' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _cameraIdleLocation) == 0x0000E8, "Member 'UAutomaticLeanComponent::_cameraIdleLocation' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _cameraLeftLeanLocation) == 0x000168, "Member 'UAutomaticLeanComponent::_cameraLeftLeanLocation' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _cameraRightLeanLocation) == 0x0001E8, "Member 'UAutomaticLeanComponent::_cameraRightLeanLocation' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _cameraCrouchLocation) == 0x000268, "Member 'UAutomaticLeanComponent::_cameraCrouchLocation' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _cameraCrouchLeftLeanLocation) == 0x0002E8, "Member 'UAutomaticLeanComponent::_cameraCrouchLeftLeanLocation' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _cameraCrouchRightLeanLocation) == 0x000368, "Member 'UAutomaticLeanComponent::_cameraCrouchRightLeanLocation' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _middleSphereTraceLength) == 0x0003E8, "Member 'UAutomaticLeanComponent::_middleSphereTraceLength' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _sideSphereTraceLength) == 0x0003EC, "Member 'UAutomaticLeanComponent::_sideSphereTraceLength' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _sphereTraceRadius) == 0x0003F0, "Member 'UAutomaticLeanComponent::_sphereTraceRadius' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _standingTraceHeightOffset) == 0x0003F4, "Member 'UAutomaticLeanComponent::_standingTraceHeightOffset' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _crouchingTraceHeightOffset) == 0x0003F8, "Member 'UAutomaticLeanComponent::_crouchingTraceHeightOffset' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _sideTraceOffset) == 0x0003FC, "Member 'UAutomaticLeanComponent::_sideTraceOffset' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _maxCameraDistance) == 0x000400, "Member 'UAutomaticLeanComponent::_maxCameraDistance' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _maxCameraAngle) == 0x000404, "Member 'UAutomaticLeanComponent::_maxCameraAngle' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _debugMode) == 0x000408, "Member 'UAutomaticLeanComponent::_debugMode' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _leanState) == 0x000409, "Member 'UAutomaticLeanComponent::_leanState' has a wrong offset!");

// Class DeadByDaylight.KillerVaultDefinition
// 0x0090 (0x0860 - 0x07D0)
class UKillerVaultDefinition : public UVaultDefinition
{
public:
	bool                                          _shouldUseCustomDuration;                          // 0x07C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C9[0x7];                                      // 0x07C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStatProperty                          _vaultDuration;                                    // 0x07D0(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_858[0x8];                                      // 0x0858(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerVaultDefinition">();
	}
	static class UKillerVaultDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerVaultDefinition>();
	}
};
static_assert(alignof(UKillerVaultDefinition) == 0x000010, "Wrong alignment on UKillerVaultDefinition");
static_assert(sizeof(UKillerVaultDefinition) == 0x000860, "Wrong size on UKillerVaultDefinition");
static_assert(offsetof(UKillerVaultDefinition, _shouldUseCustomDuration) == 0x0007C8, "Member 'UKillerVaultDefinition::_shouldUseCustomDuration' has a wrong offset!");
static_assert(offsetof(UKillerVaultDefinition, _vaultDuration) == 0x0007D0, "Member 'UKillerVaultDefinition::_vaultDuration' has a wrong offset!");

// Class DeadByDaylight.DecalSpawner
// 0x0018 (0x0048 - 0x0030)
class UDecalSpawner final : public UObject
{
public:
	class UDecalCollection*                       _decalCollection;                                  // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpawnerStrategy*                       _spawnerStrategy;                                  // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USpawnerStrategy* GetSpawnerStrategy();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DecalSpawner">();
	}
	static class UDecalSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDecalSpawner>();
	}
};
static_assert(alignof(UDecalSpawner) == 0x000008, "Wrong alignment on UDecalSpawner");
static_assert(sizeof(UDecalSpawner) == 0x000048, "Wrong size on UDecalSpawner");
static_assert(offsetof(UDecalSpawner, _decalCollection) == 0x000030, "Member 'UDecalSpawner::_decalCollection' has a wrong offset!");
static_assert(offsetof(UDecalSpawner, _spawnerStrategy) == 0x000038, "Member 'UDecalSpawner::_spawnerStrategy' has a wrong offset!");

// Class DeadByDaylight.DBDAIController
// 0x04A8 (0x0878 - 0x03D0)
class ADBDAIController : public AAIController
{
public:
	float                                         DefaultSightRange;                                 // 0x03D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloakedTargetSightRange;                           // 0x03D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SightSweepTestRadius;                              // 0x03D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraMaxPitchAngle;                               // 0x03DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraMinPitchAngle;                               // 0x03E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E4[0x4];                                      // 0x03E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    CameraHighDeltaLerpSpeed;                          // 0x03E8(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    CameraLowDeltaLerpSpeed;                           // 0x0448(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    CameraTowardTargetDeltaAngle;                      // 0x04A8(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EAIDifficultyLevel, int32>               AIDifficultyMaxPlayerRanks;                        // 0x0508(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_558[0x50];                                     // 0x0558(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  _aiPawn;                                           // 0x05A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APawn*                                  _lastAiPawn;                                       // 0x05B0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class UObject*, float>                   _contextualPathSpeedFactors;                       // 0x05B8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class UObject*                                _objOverridingDefaultNavigationFilter;             // 0x0608(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UNavigationQueryFilter>     _originalDefaultNavigationFilter;                  // 0x0610(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_618[0x28];                                     // 0x0618(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPawnInputPressTypes, class UObject*>    _inputLocks;                                       // 0x0640(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class UObject*                                _movementLock;                                     // 0x0690(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                        _focusPriorityLocks;                               // 0x0698(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6A8[0x1D0];                                    // 0x06A8(0x01D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbilityTwoRequest(const class UObject* requester, ECharacterMovementTypes MovementMode);
	void ActionRequest(const class UObject* requester);
	void AttackRequest(const class UObject* requester);
	void CancelMinigameRequest(const class UObject* requester);
	void CrouchRequest(const class UObject* requester);
	void DropItemRequest(const class UObject* requester);
	void EndAbilityTwoRequest(const class UObject* requester);
	void EndActionRequest(const class UObject* requester);
	void EndCrouchRequest(const class UObject* requester);
	void EndDropItemRequest(const class UObject* requester);
	void EndEventAbilityRequest(const class UObject* requester);
	void EndFastInteractRequest(const class UObject* requester);
	void EndInteractRequest(const class UObject* requester);
	void EndRunRequest(const class UObject* requester);
	void EndSecondAttackRequest(const class UObject* requester);
	void EndUseItemRequest(const class UObject* requester);
	void EventAbilityRequest(const class UObject* requester);
	void FastInteractRequest(const class UObject* requester);
	void Gesture01Request(const class UObject* requester);
	void Gesture02Request(const class UObject* requester);
	void Gesture03Request(const class UObject* requester);
	void Gesture04Request(const class UObject* requester);
	void InteractRequest(const class UObject* requester);
	void InteractRequestRelease(const class UObject* requester);
	void RunRequest(const class UObject* requester);
	void SecondaryActionRequest(const class UObject* requester);
	void SecondAttackRequest(const class UObject* requester);
	void Server_SetAIPlayerRank(int32 playerRank);
	bool SetCharacterMovement(ECharacterMovementTypes movementTypes, const class UObject* requester, EAIMovementPriority applyOrder);
	void StruggleRequest(const class UObject* requester, float Input);
	void UseItemRequest(const class UObject* requester);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAIController">();
	}
	static class ADBDAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDAIController>();
	}
};
static_assert(alignof(ADBDAIController) == 0x000008, "Wrong alignment on ADBDAIController");
static_assert(sizeof(ADBDAIController) == 0x000878, "Wrong size on ADBDAIController");
static_assert(offsetof(ADBDAIController, DefaultSightRange) == 0x0003D0, "Member 'ADBDAIController::DefaultSightRange' has a wrong offset!");
static_assert(offsetof(ADBDAIController, CloakedTargetSightRange) == 0x0003D4, "Member 'ADBDAIController::CloakedTargetSightRange' has a wrong offset!");
static_assert(offsetof(ADBDAIController, SightSweepTestRadius) == 0x0003D8, "Member 'ADBDAIController::SightSweepTestRadius' has a wrong offset!");
static_assert(offsetof(ADBDAIController, CameraMaxPitchAngle) == 0x0003DC, "Member 'ADBDAIController::CameraMaxPitchAngle' has a wrong offset!");
static_assert(offsetof(ADBDAIController, CameraMinPitchAngle) == 0x0003E0, "Member 'ADBDAIController::CameraMinPitchAngle' has a wrong offset!");
static_assert(offsetof(ADBDAIController, CameraHighDeltaLerpSpeed) == 0x0003E8, "Member 'ADBDAIController::CameraHighDeltaLerpSpeed' has a wrong offset!");
static_assert(offsetof(ADBDAIController, CameraLowDeltaLerpSpeed) == 0x000448, "Member 'ADBDAIController::CameraLowDeltaLerpSpeed' has a wrong offset!");
static_assert(offsetof(ADBDAIController, CameraTowardTargetDeltaAngle) == 0x0004A8, "Member 'ADBDAIController::CameraTowardTargetDeltaAngle' has a wrong offset!");
static_assert(offsetof(ADBDAIController, AIDifficultyMaxPlayerRanks) == 0x000508, "Member 'ADBDAIController::AIDifficultyMaxPlayerRanks' has a wrong offset!");
static_assert(offsetof(ADBDAIController, _aiPawn) == 0x0005A8, "Member 'ADBDAIController::_aiPawn' has a wrong offset!");
static_assert(offsetof(ADBDAIController, _lastAiPawn) == 0x0005B0, "Member 'ADBDAIController::_lastAiPawn' has a wrong offset!");
static_assert(offsetof(ADBDAIController, _contextualPathSpeedFactors) == 0x0005B8, "Member 'ADBDAIController::_contextualPathSpeedFactors' has a wrong offset!");
static_assert(offsetof(ADBDAIController, _objOverridingDefaultNavigationFilter) == 0x000608, "Member 'ADBDAIController::_objOverridingDefaultNavigationFilter' has a wrong offset!");
static_assert(offsetof(ADBDAIController, _originalDefaultNavigationFilter) == 0x000610, "Member 'ADBDAIController::_originalDefaultNavigationFilter' has a wrong offset!");
static_assert(offsetof(ADBDAIController, _inputLocks) == 0x000640, "Member 'ADBDAIController::_inputLocks' has a wrong offset!");
static_assert(offsetof(ADBDAIController, _movementLock) == 0x000690, "Member 'ADBDAIController::_movementLock' has a wrong offset!");
static_assert(offsetof(ADBDAIController, _focusPriorityLocks) == 0x000698, "Member 'ADBDAIController::_focusPriorityLocks' has a wrong offset!");

// Class DeadByDaylight.DBDNetworkUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDNetworkUtilities final : public UBlueprintFunctionLibrary
{
public:
	static bool IsOnDedicatedServerNetwork(const class UObject* WorldContextObject);
	static bool IsRunningDedicatedServerFlow();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDNetworkUtilities">();
	}
	static class UDBDNetworkUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDNetworkUtilities>();
	}
};
static_assert(alignof(UDBDNetworkUtilities) == 0x000008, "Wrong alignment on UDBDNetworkUtilities");
static_assert(sizeof(UDBDNetworkUtilities) == 0x000030, "Wrong size on UDBDNetworkUtilities");

// Class DeadByDaylight.CompetenceOperation
// 0x0028 (0x0058 - 0x0030)
class UCompetenceOperation final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UEventDrivenModifierCondition> _conditionClass;                                // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEventDrivenModifierCondition*          _condition;                                        // 0x0040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UCompetenceAction*>              _actions;                                          // 0x0048(0x0010)(Edit, ExportObject, Net, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CompetenceOperation">();
	}
	static class UCompetenceOperation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCompetenceOperation>();
	}
};
static_assert(alignof(UCompetenceOperation) == 0x000008, "Wrong alignment on UCompetenceOperation");
static_assert(sizeof(UCompetenceOperation) == 0x000058, "Wrong size on UCompetenceOperation");
static_assert(offsetof(UCompetenceOperation, _conditionClass) == 0x000038, "Member 'UCompetenceOperation::_conditionClass' has a wrong offset!");
static_assert(offsetof(UCompetenceOperation, _condition) == 0x000040, "Member 'UCompetenceOperation::_condition' has a wrong offset!");
static_assert(offsetof(UCompetenceOperation, _actions) == 0x000048, "Member 'UCompetenceOperation::_actions' has a wrong offset!");

// Class DeadByDaylight.DBDCharacterMovementComponent
// 0x04D0 (0x1430 - 0x0F60)
class UDBDCharacterMovementComponent : public UCharacterMovementComponent
{
public:
	uint8                                         Pad_F60[0x10];                                     // 0x0F60(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProjectedWallSlidingFactor;                        // 0x0F70(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomInputFrontMultiplier;                        // 0x0F74(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomInputSideMultiplier;                         // 0x0F78(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomInputBackMultiplier;                         // 0x0F7C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F80[0xD8];                                     // 0x0F80(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _lowHeightDropStaggerThreshold;                    // 0x1058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minDropStaggerDurationTime;                       // 0x105C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _highHeightDropStaggerThreshold;                   // 0x1060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxDropStaggerDurationTime;                       // 0x1064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1068[0x20];                                    // 0x1068(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBHVRPerDetailModeFloat                _significanceThresholdForSmoothUpdateVisualOptimization; // 0x1088(0x00A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FBHVRPerDetailModeFloat                _significanceThresholdForSimulatedMovementPrediction; // 0x1128(0x00A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FBHVRPerDetailModeInt                  _significanceMaxRefreshRateForSmoothUpdateVisualOptimization; // 0x11C8(0x00A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          _forceUseDropStaggerFix;                           // 0x1268(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1269[0x117];                                   // 0x1269(0x0117)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseCharacterVelocityCalculationStrategy* _velocityAdditiveStrategy;                      // 0x1380(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBaseInputAccelerationConstraintStrategy* _inputAccelerationConstraintStrategy;            // 0x1388(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBaseCharacterRotationStrategy*         _rotationStrategy;                                 // 0x1390(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 _lookAtTarget;                                     // 0x1398(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13A0[0x90];                                    // 0x13A0(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_Cheat_SetMaxSpeedMultiplier(const float maxSpeedMultiplier);
	void Client_PreventMovement(const bool Value);
	void Client_Stop();
	void Client_TeleportTo(const struct FVector_NetQuantize100& Location, const struct FYawAndPitchRotator_NetQuantize32& Rotation);
	void Server_Launch(float Timestamp, const struct FVector& LaunchVelocity, int32 launchCallCount);
	void Server_MovementSetStateStack(float Timestamp, const TArray<struct FPlayerStateMachineTransitionData>& stateStackContainers, int32 stateStackCallCount);
	void Server_MovementTimeSync(uint64 clientTimeSync, uint32 minStackDepth, bool isInGameThreadOnly);
	void Server_ReplicateControlRotation(uint8 ClientRoll, uint32 View);
	void Server_SetMaxAcceleration(float Timestamp, float Value);
	void Server_UpdateCameraRotation(float Timestamp, const struct FRotator& cameraRotation, int32 updateCameraRotationCallCount);

	void Multicast_SetIsIgnoringPawnCollision(const bool isIgnoringPawnCollision) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDCharacterMovementComponent">();
	}
	static class UDBDCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDCharacterMovementComponent>();
	}
};
static_assert(alignof(UDBDCharacterMovementComponent) == 0x000010, "Wrong alignment on UDBDCharacterMovementComponent");
static_assert(sizeof(UDBDCharacterMovementComponent) == 0x001430, "Wrong size on UDBDCharacterMovementComponent");
static_assert(offsetof(UDBDCharacterMovementComponent, ProjectedWallSlidingFactor) == 0x000F70, "Member 'UDBDCharacterMovementComponent::ProjectedWallSlidingFactor' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, RandomInputFrontMultiplier) == 0x000F74, "Member 'UDBDCharacterMovementComponent::RandomInputFrontMultiplier' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, RandomInputSideMultiplier) == 0x000F78, "Member 'UDBDCharacterMovementComponent::RandomInputSideMultiplier' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, RandomInputBackMultiplier) == 0x000F7C, "Member 'UDBDCharacterMovementComponent::RandomInputBackMultiplier' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, _lowHeightDropStaggerThreshold) == 0x001058, "Member 'UDBDCharacterMovementComponent::_lowHeightDropStaggerThreshold' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, _minDropStaggerDurationTime) == 0x00105C, "Member 'UDBDCharacterMovementComponent::_minDropStaggerDurationTime' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, _highHeightDropStaggerThreshold) == 0x001060, "Member 'UDBDCharacterMovementComponent::_highHeightDropStaggerThreshold' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, _maxDropStaggerDurationTime) == 0x001064, "Member 'UDBDCharacterMovementComponent::_maxDropStaggerDurationTime' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, _significanceThresholdForSmoothUpdateVisualOptimization) == 0x001088, "Member 'UDBDCharacterMovementComponent::_significanceThresholdForSmoothUpdateVisualOptimization' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, _significanceThresholdForSimulatedMovementPrediction) == 0x001128, "Member 'UDBDCharacterMovementComponent::_significanceThresholdForSimulatedMovementPrediction' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, _significanceMaxRefreshRateForSmoothUpdateVisualOptimization) == 0x0011C8, "Member 'UDBDCharacterMovementComponent::_significanceMaxRefreshRateForSmoothUpdateVisualOptimization' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, _forceUseDropStaggerFix) == 0x001268, "Member 'UDBDCharacterMovementComponent::_forceUseDropStaggerFix' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, _velocityAdditiveStrategy) == 0x001380, "Member 'UDBDCharacterMovementComponent::_velocityAdditiveStrategy' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, _inputAccelerationConstraintStrategy) == 0x001388, "Member 'UDBDCharacterMovementComponent::_inputAccelerationConstraintStrategy' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, _rotationStrategy) == 0x001390, "Member 'UDBDCharacterMovementComponent::_rotationStrategy' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, _lookAtTarget) == 0x001398, "Member 'UDBDCharacterMovementComponent::_lookAtTarget' has a wrong offset!");

// Class DeadByDaylight.BaseLockerItem
// 0x0028 (0x02C8 - 0x02A0)
class ABaseLockerItem : public AActor
{
public:
	class ALocker*                                _owningLocker;                                     // 0x02A0(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _adjustedRelativePosition;                         // 0x02B0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AdjustPositionOnLocker();
	void OnRep_OwningLocker();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseLockerItem">();
	}
	static class ABaseLockerItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseLockerItem>();
	}
};
static_assert(alignof(ABaseLockerItem) == 0x000008, "Wrong alignment on ABaseLockerItem");
static_assert(sizeof(ABaseLockerItem) == 0x0002C8, "Wrong size on ABaseLockerItem");
static_assert(offsetof(ABaseLockerItem, _owningLocker) == 0x0002A0, "Member 'ABaseLockerItem::_owningLocker' has a wrong offset!");
static_assert(offsetof(ABaseLockerItem, _adjustedRelativePosition) == 0x0002B0, "Member 'ABaseLockerItem::_adjustedRelativePosition' has a wrong offset!");

// Class DeadByDaylight.PresentationPowerFadeComponent
// 0x0000 (0x00B8 - 0x00B8)
class UPresentationPowerFadeComponent : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PresentationPowerFadeComponent">();
	}
	static class UPresentationPowerFadeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPresentationPowerFadeComponent>();
	}
};
static_assert(alignof(UPresentationPowerFadeComponent) == 0x000008, "Wrong alignment on UPresentationPowerFadeComponent");
static_assert(sizeof(UPresentationPowerFadeComponent) == 0x0000B8, "Wrong size on UPresentationPowerFadeComponent");

// Class DeadByDaylight.InteractionDetectorComponent
// 0x0100 (0x01B8 - 0x00B8)
class UInteractionDetectorComponent final : public UActorComponent
{
public:
	class UPrimitiveComponent*                    _detectionPrimitive;                               // 0x00B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class AInteractable*>                    _overlappingInteractables;                         // 0x00C0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<class UPrimitiveComponent*>              _overlappingPrimitiveComponents;                   // 0x0110(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSet<class AActor*>                           _ignoredActors;                                    // 0x0160(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B0[0x8];                                      // 0x01B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddIgnoredActor(class AActor* ignored);
	void BeginOverlapCallback(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool fromSweep, const struct FHitResult& SweepResult);
	void EndOverlapCallback(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnLocallyObservedChanged(class ADBDPlayer* Player);
	void SetDetectionPrimitive(class UPrimitiveComponent* detectionPrimitive);

	class UPrimitiveComponent* GetDetectionPrimitive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionDetectorComponent">();
	}
	static class UInteractionDetectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionDetectorComponent>();
	}
};
static_assert(alignof(UInteractionDetectorComponent) == 0x000008, "Wrong alignment on UInteractionDetectorComponent");
static_assert(sizeof(UInteractionDetectorComponent) == 0x0001B8, "Wrong size on UInteractionDetectorComponent");
static_assert(offsetof(UInteractionDetectorComponent, _detectionPrimitive) == 0x0000B8, "Member 'UInteractionDetectorComponent::_detectionPrimitive' has a wrong offset!");
static_assert(offsetof(UInteractionDetectorComponent, _overlappingInteractables) == 0x0000C0, "Member 'UInteractionDetectorComponent::_overlappingInteractables' has a wrong offset!");
static_assert(offsetof(UInteractionDetectorComponent, _overlappingPrimitiveComponents) == 0x000110, "Member 'UInteractionDetectorComponent::_overlappingPrimitiveComponents' has a wrong offset!");
static_assert(offsetof(UInteractionDetectorComponent, _ignoredActors) == 0x000160, "Member 'UInteractionDetectorComponent::_ignoredActors' has a wrong offset!");

// Class DeadByDaylight.AISenseConfig_PointOfInterest
// 0x0010 (0x0060 - 0x0050)
class UAISenseConfig_PointOfInterest final : public UAISenseConfig
{
public:
	TSubclassOf<class UAISense_PointOfInterest>   Implementation;                                    // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinGeneratorRepairSoundRange;                      // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxGeneratorRepairSoundRange;                      // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISenseConfig_PointOfInterest">();
	}
	static class UAISenseConfig_PointOfInterest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISenseConfig_PointOfInterest>();
	}
};
static_assert(alignof(UAISenseConfig_PointOfInterest) == 0x000008, "Wrong alignment on UAISenseConfig_PointOfInterest");
static_assert(sizeof(UAISenseConfig_PointOfInterest) == 0x000060, "Wrong size on UAISenseConfig_PointOfInterest");
static_assert(offsetof(UAISenseConfig_PointOfInterest, Implementation) == 0x000050, "Member 'UAISenseConfig_PointOfInterest::Implementation' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_PointOfInterest, MinGeneratorRepairSoundRange) == 0x000058, "Member 'UAISenseConfig_PointOfInterest::MinGeneratorRepairSoundRange' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_PointOfInterest, MaxGeneratorRepairSoundRange) == 0x00005C, "Member 'UAISenseConfig_PointOfInterest::MaxGeneratorRepairSoundRange' has a wrong offset!");

// Class DeadByDaylight.AimingCrosshairComponent
// 0x0040 (0x00F8 - 0x00B8)
class UAimingCrosshairComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x40];                                      // 0x00B8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnCrosshairStateChanged(EAimingCrosshairState newState, EAimingCrosshairState lastState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimingCrosshairComponent">();
	}
	static class UAimingCrosshairComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimingCrosshairComponent>();
	}
};
static_assert(alignof(UAimingCrosshairComponent) == 0x000008, "Wrong alignment on UAimingCrosshairComponent");
static_assert(sizeof(UAimingCrosshairComponent) == 0x0000F8, "Wrong size on UAimingCrosshairComponent");

// Class DeadByDaylight.KillerAttackPickerComponent
// 0x0000 (0x00B8 - 0x00B8)
class UKillerAttackPickerComponent : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerAttackPickerComponent">();
	}
	static class UKillerAttackPickerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerAttackPickerComponent>();
	}
};
static_assert(alignof(UKillerAttackPickerComponent) == 0x000008, "Wrong alignment on UKillerAttackPickerComponent");
static_assert(sizeof(UKillerAttackPickerComponent) == 0x0000B8, "Wrong size on UKillerAttackPickerComponent");

// Class DeadByDaylight.DBDPersistentData
// 0x0DA0 (0x0DD0 - 0x0030)
class UDBDPersistentData final : public UObject
{
public:
	struct FGamePersistentData                    _gamePersistentData;                               // 0x0030(0x0108)(Transient, NativeAccessSpecifierPrivate)
	TArray<class FString>                         _keepDataIDs;                                      // 0x0138(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<class FString, struct FPlayerPersistentData> _playerIdToPersistentDataMap;                  // 0x0148(0x0050)(Transient, NativeAccessSpecifierPrivate)
	struct FPlayerPersistentData                  _localPlayerPersistentData;                        // 0x0198(0x0BB8)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D50[0x50];                                     // 0x0D50(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCloudInventoryItem>            _cloudInventory;                                   // 0x0DA0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DB0[0x20];                                     // 0x0DB0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPersistentData">();
	}
	static class UDBDPersistentData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDPersistentData>();
	}
};
static_assert(alignof(UDBDPersistentData) == 0x000008, "Wrong alignment on UDBDPersistentData");
static_assert(sizeof(UDBDPersistentData) == 0x000DD0, "Wrong size on UDBDPersistentData");
static_assert(offsetof(UDBDPersistentData, _gamePersistentData) == 0x000030, "Member 'UDBDPersistentData::_gamePersistentData' has a wrong offset!");
static_assert(offsetof(UDBDPersistentData, _keepDataIDs) == 0x000138, "Member 'UDBDPersistentData::_keepDataIDs' has a wrong offset!");
static_assert(offsetof(UDBDPersistentData, _playerIdToPersistentDataMap) == 0x000148, "Member 'UDBDPersistentData::_playerIdToPersistentDataMap' has a wrong offset!");
static_assert(offsetof(UDBDPersistentData, _localPlayerPersistentData) == 0x000198, "Member 'UDBDPersistentData::_localPlayerPersistentData' has a wrong offset!");
static_assert(offsetof(UDBDPersistentData, _cloudInventory) == 0x000DA0, "Member 'UDBDPersistentData::_cloudInventory' has a wrong offset!");

// Class DeadByDaylight.ChallengesManager
// 0x0488 (0x04C0 - 0x0038)
class UChallengesManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x488];                                     // 0x0038(0x0488)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengesManager">();
	}
	static class UChallengesManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChallengesManager>();
	}
};
static_assert(alignof(UChallengesManager) == 0x000008, "Wrong alignment on UChallengesManager");
static_assert(sizeof(UChallengesManager) == 0x0004C0, "Wrong size on UChallengesManager");

// Class DeadByDaylight.DBDGame_Start
// 0x0088 (0x0488 - 0x0400)
class ADBDGame_Start : public ADBDBaseGameMode
{
public:
	uint8                                         Pad_400[0x60];                                     // 0x0400(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class IClientStartupInitializerInterface> _startupInitializer;                  // 0x0460(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_470[0x18];                                     // 0x0470(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGame_Start">();
	}
	static class ADBDGame_Start* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDGame_Start>();
	}
};
static_assert(alignof(ADBDGame_Start) == 0x000008, "Wrong alignment on ADBDGame_Start");
static_assert(sizeof(ADBDGame_Start) == 0x000488, "Wrong size on ADBDGame_Start");
static_assert(offsetof(ADBDGame_Start, _startupInitializer) == 0x000460, "Member 'ADBDGame_Start::_startupInitializer' has a wrong offset!");

// Class DeadByDaylight.KillerProjectileLauncher
// 0x0000 (0x01A8 - 0x01A8)
class UKillerProjectileLauncher : public UBaseProjectileLauncher
{
public:
	void Server_UpdateCameraRotation(const struct FRotator& Rotation);

	class AKiller* GetOwningKiller() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerProjectileLauncher">();
	}
	static class UKillerProjectileLauncher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerProjectileLauncher>();
	}
};
static_assert(alignof(UKillerProjectileLauncher) == 0x000008, "Wrong alignment on UKillerProjectileLauncher");
static_assert(sizeof(UKillerProjectileLauncher) == 0x0001A8, "Wrong size on UKillerProjectileLauncher");

// Class DeadByDaylight.ChunkingManager
// 0x0058 (0x0088 - 0x0030)
class UChunkingManager final : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDGameInstance*                       _gameInstance;                                     // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x38];                                      // 0x0050(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChunkingManager">();
	}
	static class UChunkingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChunkingManager>();
	}
};
static_assert(alignof(UChunkingManager) == 0x000008, "Wrong alignment on UChunkingManager");
static_assert(sizeof(UChunkingManager) == 0x000088, "Wrong size on UChunkingManager");
static_assert(offsetof(UChunkingManager, _gameInstance) == 0x000048, "Member 'UChunkingManager::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.MenuForcedLODHandler
// 0x0070 (0x0128 - 0x00B8)
class UMenuForcedLODHandler final : public UActorComponent
{
public:
	TArray<EGameFlowStep>                         _forcedLOD0GameFlowSteps;                          // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x60];                                      // 0x00C8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCustomizationChanged(ECustomizationCategory category, const class FName& ItemId, class ADBDMenuPlayer* menuPlayer);
	void OnMenuPlayerEndPlay(class AActor* menuPlayerActor, EEndPlayReason EndPlayReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuForcedLODHandler">();
	}
	static class UMenuForcedLODHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuForcedLODHandler>();
	}
};
static_assert(alignof(UMenuForcedLODHandler) == 0x000008, "Wrong alignment on UMenuForcedLODHandler");
static_assert(sizeof(UMenuForcedLODHandler) == 0x000128, "Wrong size on UMenuForcedLODHandler");
static_assert(offsetof(UMenuForcedLODHandler, _forcedLOD0GameFlowSteps) == 0x0000B8, "Member 'UMenuForcedLODHandler::_forcedLOD0GameFlowSteps' has a wrong offset!");

// Class DeadByDaylight.DBDBasePlayer
// 0x0120 (0x0770 - 0x0650)
class ADBDBasePlayer : public ACharacter
{
public:
	uint8                                         Pad_650[0x10];                                     // 0x0650(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnCustomizationChanged;                            // 0x0660(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_670[0x20];                                     // 0x0670(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _semanticGameplayTags;                             // 0x0690(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UBaseGroundDetectorComponent*           _leftFootGroundDetector;                           // 0x06B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBaseGroundDetectorComponent*           _rightFootGroundDetector;                          // 0x06B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBaseGroundDetectorComponent*           _leftFrontFootGroundDetector;                      // 0x06C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBaseGroundDetectorComponent*           _rightFrontFootGroundDetector;                     // 0x06C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMontagePlayer*                         _montagePlayer;                                    // 0x06D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   _botAIControllerClass;                             // 0x06D8(0x0038)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_710[0x10];                                     // 0x0710(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _characterIndex;                                   // 0x0720(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_724[0x4C];                                     // 0x0724(0x004C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_SwapCosmetics(class FName cosmeticId);
	void Multicast_SwapCosmetics(class FName cosmeticId);
	void OnAnimInstanceChanged();
	void OnCurrentMontageBlendingOut(class UAnimMontage* MontageAsset, bool interrupted);
	void OnCurrentMontageComplete(class UAnimMontage* MontageAsset, bool interrupted);
	class UAnimMontage* PlayMontage(const struct FAnimationMontageDescriptor& animMontageID, float PlayRate, bool isFollower);
	void StopMontage();
	bool TeleportWithClothHandling(const struct FVector& Location, const struct FRotator& Rotation, bool checkCollisions);

	class UAnimInstance* GetAnimInstance() const;
	void GetAnimTags(TArray<class FName>* outTags) const;
	class UAkComponent* GetAudioComponent() const;
	int32 GetCharacterIndex() const;
	class FName GetCharacterName() const;
	class FName GetCharacterOverrideId() const;
	class UCustomizedAudioComponent* GetCustomizedAudio() const;
	class UCustomizedSkeletalMesh* GetCustomizedSkeletalMesh() const;
	class UBaseGroundDetectorComponent* GetLeftFootGroundDetector() const;
	class UBaseGroundDetectorComponent* GetLeftFrontFootGroundDetector() const;
	class UAnimMontage* GetMontage(const struct FAnimationMontageDescriptor& animMontageID) const;
	float GetMontageLength(const struct FAnimationMontageDescriptor& animMontageID) const;
	struct FMontagePlaybackDefinition GetMontagePlaybackDefinition(const struct FAnimationMontageDescriptor& animMontageID, float PlayRate, bool isFollower) const;
	class UMontagePlayer* GetMontagePlayer() const;
	class UBaseGroundDetectorComponent* GetRightFootGroundDetector() const;
	class UBaseGroundDetectorComponent* GetRightFrontFootGroundDetector() const;
	const struct FGameplayTagContainer GetSemanticTag() const;
	bool GetShowBlindDebugInfo() const;
	bool IsPlayingAnyMontage() const;
	bool IsPlayingMontage(const struct FAnimationMontageDescriptor& animMontageID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBasePlayer">();
	}
	static class ADBDBasePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDBasePlayer>();
	}
};
static_assert(alignof(ADBDBasePlayer) == 0x000010, "Wrong alignment on ADBDBasePlayer");
static_assert(sizeof(ADBDBasePlayer) == 0x000770, "Wrong size on ADBDBasePlayer");
static_assert(offsetof(ADBDBasePlayer, OnCustomizationChanged) == 0x000660, "Member 'ADBDBasePlayer::OnCustomizationChanged' has a wrong offset!");
static_assert(offsetof(ADBDBasePlayer, _semanticGameplayTags) == 0x000690, "Member 'ADBDBasePlayer::_semanticGameplayTags' has a wrong offset!");
static_assert(offsetof(ADBDBasePlayer, _leftFootGroundDetector) == 0x0006B0, "Member 'ADBDBasePlayer::_leftFootGroundDetector' has a wrong offset!");
static_assert(offsetof(ADBDBasePlayer, _rightFootGroundDetector) == 0x0006B8, "Member 'ADBDBasePlayer::_rightFootGroundDetector' has a wrong offset!");
static_assert(offsetof(ADBDBasePlayer, _leftFrontFootGroundDetector) == 0x0006C0, "Member 'ADBDBasePlayer::_leftFrontFootGroundDetector' has a wrong offset!");
static_assert(offsetof(ADBDBasePlayer, _rightFrontFootGroundDetector) == 0x0006C8, "Member 'ADBDBasePlayer::_rightFrontFootGroundDetector' has a wrong offset!");
static_assert(offsetof(ADBDBasePlayer, _montagePlayer) == 0x0006D0, "Member 'ADBDBasePlayer::_montagePlayer' has a wrong offset!");
static_assert(offsetof(ADBDBasePlayer, _botAIControllerClass) == 0x0006D8, "Member 'ADBDBasePlayer::_botAIControllerClass' has a wrong offset!");
static_assert(offsetof(ADBDBasePlayer, _characterIndex) == 0x000720, "Member 'ADBDBasePlayer::_characterIndex' has a wrong offset!");

// Class DeadByDaylight.DBDPlayer
// 0x0E40 (0x15B0 - 0x0770)
class ADBDPlayer : public ADBDBasePlayer
{
public:
	uint8                                         Pad_770[0xE0];                                     // 0x0770(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          AllowInterrupting;                                 // 0x0850(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_851[0x3];                                      // 0x0851(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinFallHeight;                                     // 0x0854(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_858[0x1];                                      // 0x0858(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsInInteractionUpdate;                             // 0x0859(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInteractionChargeCompleted;                      // 0x085A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85B[0x1];                                      // 0x085B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PitchLimitLower;                                   // 0x085C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchLimitUpper;                                   // 0x0860(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_864[0x4];                                      // 0x0864(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StrafingOffset;                                    // 0x0868(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PelvisHeight;                                      // 0x0880(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PelvisHeightForPounceOnStandingCamper;             // 0x0884(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PelvisHeightForPounceOnCrouchingCamper;            // 0x0888(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88C[0x34];                                     // 0x088C(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              Authority_OnAttackedDelegate;                      // 0x08C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADBDPlayer* Source, class ADBDPlayer* Target, EAttackType attackType, bool didDamage)> OnDamageTargetDelegate; // 0x08D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADBDPlayer* Player)> OnSensed;                               // 0x08E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADBDPlayer* Player)> OnAnimNotify_Pickup;                    // 0x08F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADBDPlayer* Player)> OnAnimNotify_Release;                   // 0x0900(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADBDPlayer* Player, class UInteractionDefinition* Interaction, bool fromCancelRequest)> Authority_OnSecondaryActionInput; // 0x0910(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool firstPerson)> OnFirstPersonModeChanged;                       // 0x0920(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool forwardInputLockValue)> OnForwardInputLockedChanged;          // 0x0930(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	class USpringArmComponent*                    CameraBoom;                                        // 0x0940(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_948[0x18];                                     // 0x0948(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ForceSkillChecks;                                  // 0x0960(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_961[0xF];                                      // 0x0961(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             IKLeftHandTransform;                               // 0x0970(0x0060)(BlueprintVisible, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             IKRightHandTransform;                              // 0x09D0(0x0060)(BlueprintVisible, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraResetSpeed;                                  // 0x0A30(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A34[0x4];                                      // 0x0A34(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AverageSpeedBufferTime;                            // 0x0A38(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlmostCurrentSpeedBufferTime;                      // 0x0A3C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            GamepadYawCurve;                                   // 0x0A40(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            GamepadPitchCurve;                                 // 0x0A48(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            GamepadSettingToYawRateCurve;                      // 0x0A50(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            GamepadSettingToPitchRateCurve;                    // 0x0A58(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            JoyconSettingToYawRateCurve;                       // 0x0A60(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            JoyconSettingToPitchRateCurve;                     // 0x0A68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool isCrouched)> OnIsCrouchedChanged;                             // 0x0A70(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool isRunningAndMoving)> OnRunningAndMovingChanged;               // 0x0A80(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_A90[0x18];                                     // 0x0A90(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraComponent*                       Camera;                                            // 0x0AA8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialHelper*                        MaterialHelper;                                    // 0x0AB0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AB8[0x30];                                     // 0x0AB8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class APlayerInteractable>        Interactable;                                      // 0x0AE8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AF0[0x18];                                     // 0x0AF0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterInventoryComponent*           _characterInventoryComponent;                      // 0x0B08(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CarryJointName;                                    // 0x0B10(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pitchOffsetForInteractionPriority;                // 0x0B1C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxOcclusionQueryComponent*            _renderedPixelCounter;                             // 0x0B20(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          _standingOcclusionBox;                             // 0x0B28(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          _crouchingOcclusionBox;                            // 0x0B30(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UActivatorComponent*                    _activator;                                        // 0x0B38(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerLockerStateComponent*            _lockerStateComponent;                             // 0x0B40(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsInteracting;                                     // 0x0B48(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B49[0x3];                                      // 0x0B49(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _aiCanBeSeenTestCrouchScale;                       // 0x0B4C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _aiCanBeSeenTestRightOffset;                       // 0x0B50(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _aiCanBeSeenTestHighOffset;                        // 0x0B54(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _aiCanBeSeenTestLowOffset;                         // 0x0B58(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ClearPathTestRadiusMultiplier;                     // 0x0B5C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ClearPathTestHeightMultiplier;                     // 0x0B60(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LocationClearTestRadiusMultiplier;                 // 0x0B64(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LocationClearTestHeightMultiplier;                 // 0x0B68(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ClearPathTestStepHeight;                           // 0x0B6C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MouseTurnSpeedMultiplier;                          // 0x0B70(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MouseLookUpSpeedMultiplier;                        // 0x0B74(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              DeathSound;                                        // 0x0B78(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECamperState                                  CurrentCamperState;                                // 0x0B80(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B81[0x3];                                      // 0x0B81(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CollectableAttachPoint;                            // 0x0B84(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStateMachine*                          _stateMachine;                                     // 0x0B90(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerInteractionHandler*              _interactionHandler;                               // 0x0B98(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPerkManager*                           _perkManager;                                      // 0x0BA0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDPlayerData*                         _playerData;                                       // 0x0BA8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerInteractable*                    _interactable;                                     // 0x0BB0(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BB8[0x50];                                     // 0x0BB8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _carryingPlayer;                                   // 0x0C08(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C10[0x8];                                      // 0x0C10(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _interactingPlayer;                                // 0x0C18(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C20[0x30];                                     // 0x0C20(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	EAttackSubstate                               _nextAttackSubstate;                               // 0x0C50(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C51[0x7];                                      // 0x0C51(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADBDPlayer*>                     _hitTargets;                                       // 0x0C58(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UCharacterChaseVisualComponent*         _characterChaseVisualComponent;                    // 0x0C68(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraHandlerComponent*                _cameraHandlerComponent;                           // 0x0C70(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UReversibleActionSystemComponent*       _reversibleActionSystemComponent;                  // 0x0C78(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _itemDropOffPosition;                              // 0x0C80(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAIPerceptionStimuliSourceComponent*    _perceptionStimuliComponent;                       // 0x0C88(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         _ignoreActors;                                     // 0x0C90(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FEffectCameraTypeSettings>      EffectCameraTypeSettings;                          // 0x0CA0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class USceneComponent*, bool>            _detectionZoneEnabledMap;                          // 0x0CB0(0x0050)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D00[0x58];                                     // 0x0D00(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargeableComponent*                   _blindingChargeableComponent;                      // 0x0D58(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDateTime                              _stillnessStartTime;                               // 0x0D60(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D68[0xD8];                                     // 0x0D68(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _shouldUpdateStateMachineDriverOnPossessed;        // 0x0E40(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E41[0x7];                                      // 0x0E41(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlindableComponent*                    _blindableComponent;                               // 0x0E48(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E50[0x4];                                      // 0x0E50(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _tutorialChargeableInteractionMultiplier;          // 0x0E54(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E58[0x8];                                      // 0x0E58(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPollableEventListener*                 _eventListener;                                    // 0x0E60(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E68[0x8];                                      // 0x0E68(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UChaseComponent*                        _chaseComponent;                                   // 0x0E70(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UZoneDetectorComponent*                 _meatHookZoneDetector;                             // 0x0E78(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UZoneDetectorComponent*                 _basementZoneDetector;                             // 0x0E80(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E88[0x98];                                     // 0x0E88(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _animGameplayTags;                                 // 0x0F20(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F40[0x88];                                     // 0x0F40(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionDefinition*                 _bookmarkedInteraction;                            // 0x0FC8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EDetectionZone, class UPrimitiveComponent*> _detectionZoneMap;                              // 0x0FD0(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1020[0x70];                                    // 0x1020(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class UAuthoritativeMovementComponent*        _authoritativeMovementComponent;                   // 0x1090(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1098[0x35C];                                   // 0x1098(0x035C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _screenAspectRatio;                                // 0x13F4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13F8[0x20];                                    // 0x13F8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayTagContainerComponent*         _objectState;                                      // 0x1418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioFXComponent*                      _audioFXComponent;                                 // 0x1420(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerPerspectiveComponent*            _playerPerspectiveComponent;                       // 0x1428(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1430[0x8];                                     // 0x1430(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterSightComponent*               _characterSightComponent;                          // 0x1438(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1440[0x8];                                     // 0x1440(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterSightableComponent*           _characterSightableComponent;                      // 0x1448(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1450[0x10];                                    // 0x1450(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UNavigationStateComponent*              _navigationStateComponent;                         // 0x1460(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractionDetectorComponent*          _interactionDetectorComponent;                     // 0x1468(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPrimitivesRegistererComponent*         _clippablePrimitivesRegistererComponent;           // 0x1470(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClippableProviderComponent*            _clippableProviderComponent;                       // 0x1478(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDynamicCapsuleResizerComponent*        _dynCapsuleResizer;                                // 0x1480(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAxisMovementComponent*                 _axisMovementComponent;                            // 0x1488(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerGameRelevancyComponent*          _playerGameRelevancyComponent;                     // 0x1490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UContextualQuestComponent*              _contextualQuestComponent;                         // 0x1498(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14A0[0x20];                                    // 0x14A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UActorComponent*                        _questEventHandler;                                // 0x14C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableProgressProviderComponent*   _presentationChargeableProgressComponent;          // 0x14C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14D0[0x18];                                    // 0x14D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _currentGamepadYawCurve;                           // 0x14E8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _currentGamepadPitchCurve;                         // 0x14F0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDPlayerState*                        _associatedPlayerStateCache;                       // 0x14F8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FOnMovementCacheStruct                 _onMovementCacheStruct;                            // 0x1500(0x0018)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1518[0x8];                                     // 0x1518(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UOtherCharactersVerticalCollisionsHandler* _otherCharactersVerticalCollisionsHandler;      // 0x1520(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1528[0x88];                                    // 0x1528(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDetectionZone(EDetectionZone detectionZoneID, class UPrimitiveComponent* zone);
	void AttachInteractor(class UInteractor* Interactor);
	void Authority_HandleScoreEvent(const struct FGameplayTag& scoreTypeTag, const struct FScoreEventData& ScoreEventData);
	void CameraUpdated();
	void CancelCarry(bool alsoCancelForOtherPlayer);
	void Client_SendCancelInteraction(const class UInteractionDefinition* InteractionDefinition);
	void Client_TryInteraction(class UInteractionDefinition* Interaction, class ADBDPlayer* requester, bool force, bool usingInputPersistence);
	void Client_TryInteractionType(EInputInteractionType interactionType, class ADBDPlayer* requester);
	void DBD_SetMouseLookUpSpeedMultiplier(float Value);
	void DBD_SetMouseTurnSpeedMultiplier(float Value);
	void DBD_ToggleForceAuthoritativeMovement();
	void DBDCrouch();
	void DBDUnCrouch();
	void DetachInteractor();
	void Dissolve(bool Dissolve_0);
	const struct FInteractionPlayerProperties GetInteractionPlayerProperties();
	bool K2_SetActorLocationByBottomCapsule(const struct FVector& NewLocation, bool bSweep, struct FHitResult* SweepHitResult);
	void Local_NotifyMatchEnded();
	void Multicast_Broadcast_DebugPlayMontage(const struct FAnimationMontageDescriptor& animMontageID, float PlayRate);
	void Multicast_ConfirmItemDrop(bool Pressed);
	void Multicast_Debug_SetMaxWalkSpeed(float MaxWalkSpeed);
	void Multicast_LeaveGame(const struct FGuid& uniqueLeavingPlayerId);
	void Multicast_ReplicateController(class AController* NewController);
	void Multicast_ServerResetMeshRelativeOffSet();
	void Multicast_SetAuthoritativeMovement(bool Enabled);
	void Multicast_SetContinuousPrintDebug(bool Enabled);
	void Multicast_SetCustomization(const struct FEquippedPlayerCustomization& Customization);
	void Multicast_SetDebugCarry(bool Enabled);
	void Multicast_SetDebugPrintAvailableInteractions(bool Enabled);
	void Multicast_SetDebugSnapPoint(bool Enabled);
	void Multicast_SetEnableCapsuleDynamicResize(bool Enabled);
	void Multicast_SetForceAuthoritativeMovement(bool Value);
	void Multicast_SetInteractingPlayer(class ADBDPlayer* interactingPlayer);
	void Multicast_SetReverseTraverseEnabled(bool Enabled);
	void Multicast_SetRunVaultEnabled(bool Enabled);
	void OnAllPlayerLoaded();
	void OnBlindChargeEmptied();
	void OnClientRestart();
	void OnControllerChanged(class APawn* Pawn, class AController* OldController, class AController* NewController);
	void OnEscapeDoorActivated();
	void OnHudVisibilityChanged(const bool IsVisible);
	void OnHudVisibilityChangedNative(const bool IsVisible);
	void OnInterruptedStart();
	void OnIntroCompleted();
	void OnIntroCompletedNative();
	void OnLevelReadyToPlay();
	void OnLocallyObservedChanged();
	void OnPickupEnd(class ADBDPlayer* Target);
	void OnPickupStart(class ADBDPlayer* Target, float pickupDuration);
	void OnPostProcessInput();
	void OnRep_Interactable();
	void RemoveStatusEffect(class UStatusEffect* StatusEffect);
	void ResetCamera();
	void ResetPitchScale(float adjustTime);
	void Server_Broadcast_DebugPlayMontage(const struct FAnimationMontageDescriptor& animMontageID, float PlayRate);
	void Server_DebugSetCustomization(const struct FEquippedPlayerCustomization& Customization);
	void Server_SendAbilityInput(bool Pressed);
	void Server_SendAbilityTwoInput(bool Pressed);
	void Server_SendEventAbilityInput(bool Pressed);
	void Server_SendFastInteractionInput(bool Pressed);
	void Server_SendInteractionInput(bool Pressed);
	void Server_SendItemDropInput(bool Pressed);
	void Server_SendItemUseInput(bool Pressed, bool requestItemUse);
	void Server_SendSecondaryActionPressed(bool fromCancelRequest);
	void Server_UpdateScreenAspectRatio(const float Value);
	void SetAllDetectionZonesEnabled(bool Enabled);
	void SetAnimationCrouchState(bool crouched);
	void SetDetectionZoneEnabled(EDetectionZone detectionZoneID, bool Enabled);
	void SetFirstPersonModelEnabled(bool Enabled, bool force);
	void SetFirstPersonVfxsVisibility(bool isFirstPerson);
	void SetForceDisableSkillChecks(bool IsEnabled);
	void SetItemUseAsToggle(bool Value);
	void SetQuestEventHandlerComponent(class UActorComponent* Component);
	void SetReverseMontage(bool Reverse);
	void SetShouldPlayCarryAnim(bool ShouldPlayCarryAnim_0);
	void TriggerAnimNotify(EAnimNotifyType animNotifyType);
	bool TryInteraction(class UInteractionDefinition* Interaction, class ADBDPlayer* requester, bool force, bool usingInputPersistence);
	bool TryInteractionType(EInputInteractionType interactionInputType, class ADBDPlayer* requester, bool usingInputPersistence, bool force);

	void Authority_EvaluateIfPlayerCanSee() const;
	bool CanInterrupt_BP() const;
	class ADBDPlayer* FindClosestSlashablePlayerInDetectionZone(EDetectionZone detectionZoneID) const;
	struct FVector GetActorLocationFromFeetLocation(const struct FVector& feetLocation) const;
	class ADBDPlayer* GetAssociatedPlayer() const;
	class APlayerState* GetAssociatedPlayerState() const;
	class USceneComponent* GetAttachPoint(class FName attachPointName) const;
	class UAuthoritativeMovementComponent* GetAuthoritativeMovementComponent() const;
	struct FVector GetAverageVelocity() const;
	class UBlindableComponent* GetBlindableComponent() const;
	struct FVector GetBoneLocation(class FName Name_0, EBoneSpaces space) const;
	class ADBDPlayerCameraManager* GetCameraManager() const;
	class UCharacterInventoryComponent* GetCharacterInventoryComponent() const;
	class UChaseComponent* GetChaseComponent() const;
	class UInteractionDefinition* GetCurrentInteraction() const;
	EInteractionAnimation GetCurrentInteractionAnimation() const;
	float GetCurrentVsBaseMaxSpeedDifferenceAsPercentage() const;
	class ADBDPlayerState* GetDBDPlayerState() const;
	class UPrimitiveComponent* GetDetectionZone(EDetectionZone detectionZoneID) const;
	struct FVector GetFeetPosition() const;
	class UActorComponent* GetFirstComponentByClass(TSubclassOf<class UActorComponent> ComponentClass) const;
	float GetGrassEffectRadiusMultiplier() const;
	class AInteractable* GetInteractable() const;
	class UInteractionDetectorComponent* GetInteractionDetectorComponent() const;
	bool GetIsInFirstPerson() const;
	bool GetIsInteracting() const;
	bool GetIsInterrupting() const;
	const TArray<class UItemAddon*> GetItemAddons() const;
	const TArray<class UItemModifier*> GetItemModifiers() const;
	float GetLuck() const;
	float GetMaxSpeed() const;
	class FString GetNameDebugString() const;
	class UGameplayTagContainerComponent* GetObjectState() const;
	class UOtherCharactersVerticalCollisionsHandler* GetOtherCharactersVerticalCollisionsHandler() const;
	EPawnType GetPawnType() const;
	float GetPercentMovementSpeed() const;
	class UPerkManager* GetPerkManager() const;
	class UCameraComponent* GetPlayerCamera() const;
	class ADBDPlayerController* GetPlayerController() const;
	struct FRotator GetPlayerDirection() const;
	class UPlayerInteractionHandler* GetPlayerInteractionHandler() const;
	EPlayerRole GetPlayerRole() const;
	EPlayerTeam GetPlayerTeam() const;
	struct FRotator GetRepControlRotation() const;
	bool GetReverseTraverseEnabled() const;
	bool GetRunVaultEnabled() const;
	class ADBDPlayerController* GetSharedPlayerController() const;
	struct FDateTime GetStillnessStartTime() const;
	float GetTunableValue(class FName Key, float defaultValue, bool warnIfRowMissing) const;
	bool HasClearPathToTarget(const struct FVector& TargetPosition) const;
	bool HasClearPathToTargetWithFilter(const struct FVector& TargetPosition, TSubclassOf<class AActor> ClassFilter, class AActor* IgnoreActor) const;
	bool HasClearPathToTargetWithIgnore(const struct FVector& TargetPosition, const TArray<class AActor*>& ignoreActors) const;
	bool HasMoveInput() const;
	bool IsBeingInterrupted() const;
	bool IsCloaked() const;
	bool IsCrouching() const;
	bool IsCrouchPressed() const;
	bool IsExhausted() const;
	bool IsForPreview() const;
	bool IsHeadHidden() const;
	bool IsIncapacitated() const;
	bool IsInMeathookZone() const;
	bool IsInParadise() const;
	bool IsInsideLocker() const;
	bool IsInStalkMode() const;
	bool IsInteractionInputPressed(EInputInteractionType interactionType) const;
	bool IsInTerrorRadius() const;
	bool IsLocallyObserved() const;
	bool IsMoving() const;
	bool IsRunning() const;
	bool Local_IsInteractionInputPressed(EInputInteractionType interactionType) const;
	class FString OnGetCharacterName() const;
	bool ShouldFall() const;
	bool ShouldPlayCarryAnim() const;
	void UpdateLoadoutFromInventory() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayer">();
	}
	static class ADBDPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDPlayer>();
	}
};
static_assert(alignof(ADBDPlayer) == 0x000010, "Wrong alignment on ADBDPlayer");
static_assert(sizeof(ADBDPlayer) == 0x0015B0, "Wrong size on ADBDPlayer");
static_assert(offsetof(ADBDPlayer, AllowInterrupting) == 0x000850, "Member 'ADBDPlayer::AllowInterrupting' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, MinFallHeight) == 0x000854, "Member 'ADBDPlayer::MinFallHeight' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, IsInInteractionUpdate) == 0x000859, "Member 'ADBDPlayer::IsInInteractionUpdate' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, IsInteractionChargeCompleted) == 0x00085A, "Member 'ADBDPlayer::IsInteractionChargeCompleted' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, PitchLimitLower) == 0x00085C, "Member 'ADBDPlayer::PitchLimitLower' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, PitchLimitUpper) == 0x000860, "Member 'ADBDPlayer::PitchLimitUpper' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, StrafingOffset) == 0x000868, "Member 'ADBDPlayer::StrafingOffset' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, PelvisHeight) == 0x000880, "Member 'ADBDPlayer::PelvisHeight' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, PelvisHeightForPounceOnStandingCamper) == 0x000884, "Member 'ADBDPlayer::PelvisHeightForPounceOnStandingCamper' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, PelvisHeightForPounceOnCrouchingCamper) == 0x000888, "Member 'ADBDPlayer::PelvisHeightForPounceOnCrouchingCamper' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, Authority_OnAttackedDelegate) == 0x0008C0, "Member 'ADBDPlayer::Authority_OnAttackedDelegate' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, OnDamageTargetDelegate) == 0x0008D0, "Member 'ADBDPlayer::OnDamageTargetDelegate' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, OnSensed) == 0x0008E0, "Member 'ADBDPlayer::OnSensed' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, OnAnimNotify_Pickup) == 0x0008F0, "Member 'ADBDPlayer::OnAnimNotify_Pickup' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, OnAnimNotify_Release) == 0x000900, "Member 'ADBDPlayer::OnAnimNotify_Release' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, Authority_OnSecondaryActionInput) == 0x000910, "Member 'ADBDPlayer::Authority_OnSecondaryActionInput' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, OnFirstPersonModeChanged) == 0x000920, "Member 'ADBDPlayer::OnFirstPersonModeChanged' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, OnForwardInputLockedChanged) == 0x000930, "Member 'ADBDPlayer::OnForwardInputLockedChanged' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, CameraBoom) == 0x000940, "Member 'ADBDPlayer::CameraBoom' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, ForceSkillChecks) == 0x000960, "Member 'ADBDPlayer::ForceSkillChecks' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, IKLeftHandTransform) == 0x000970, "Member 'ADBDPlayer::IKLeftHandTransform' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, IKRightHandTransform) == 0x0009D0, "Member 'ADBDPlayer::IKRightHandTransform' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, CameraResetSpeed) == 0x000A30, "Member 'ADBDPlayer::CameraResetSpeed' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, AverageSpeedBufferTime) == 0x000A38, "Member 'ADBDPlayer::AverageSpeedBufferTime' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, AlmostCurrentSpeedBufferTime) == 0x000A3C, "Member 'ADBDPlayer::AlmostCurrentSpeedBufferTime' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, GamepadYawCurve) == 0x000A40, "Member 'ADBDPlayer::GamepadYawCurve' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, GamepadPitchCurve) == 0x000A48, "Member 'ADBDPlayer::GamepadPitchCurve' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, GamepadSettingToYawRateCurve) == 0x000A50, "Member 'ADBDPlayer::GamepadSettingToYawRateCurve' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, GamepadSettingToPitchRateCurve) == 0x000A58, "Member 'ADBDPlayer::GamepadSettingToPitchRateCurve' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, JoyconSettingToYawRateCurve) == 0x000A60, "Member 'ADBDPlayer::JoyconSettingToYawRateCurve' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, JoyconSettingToPitchRateCurve) == 0x000A68, "Member 'ADBDPlayer::JoyconSettingToPitchRateCurve' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, OnIsCrouchedChanged) == 0x000A70, "Member 'ADBDPlayer::OnIsCrouchedChanged' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, OnRunningAndMovingChanged) == 0x000A80, "Member 'ADBDPlayer::OnRunningAndMovingChanged' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, Camera) == 0x000AA8, "Member 'ADBDPlayer::Camera' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, MaterialHelper) == 0x000AB0, "Member 'ADBDPlayer::MaterialHelper' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, Interactable) == 0x000AE8, "Member 'ADBDPlayer::Interactable' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _characterInventoryComponent) == 0x000B08, "Member 'ADBDPlayer::_characterInventoryComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, CarryJointName) == 0x000B10, "Member 'ADBDPlayer::CarryJointName' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _pitchOffsetForInteractionPriority) == 0x000B1C, "Member 'ADBDPlayer::_pitchOffsetForInteractionPriority' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _renderedPixelCounter) == 0x000B20, "Member 'ADBDPlayer::_renderedPixelCounter' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _standingOcclusionBox) == 0x000B28, "Member 'ADBDPlayer::_standingOcclusionBox' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _crouchingOcclusionBox) == 0x000B30, "Member 'ADBDPlayer::_crouchingOcclusionBox' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _activator) == 0x000B38, "Member 'ADBDPlayer::_activator' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _lockerStateComponent) == 0x000B40, "Member 'ADBDPlayer::_lockerStateComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, IsInteracting) == 0x000B48, "Member 'ADBDPlayer::IsInteracting' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _aiCanBeSeenTestCrouchScale) == 0x000B4C, "Member 'ADBDPlayer::_aiCanBeSeenTestCrouchScale' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _aiCanBeSeenTestRightOffset) == 0x000B50, "Member 'ADBDPlayer::_aiCanBeSeenTestRightOffset' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _aiCanBeSeenTestHighOffset) == 0x000B54, "Member 'ADBDPlayer::_aiCanBeSeenTestHighOffset' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _aiCanBeSeenTestLowOffset) == 0x000B58, "Member 'ADBDPlayer::_aiCanBeSeenTestLowOffset' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, ClearPathTestRadiusMultiplier) == 0x000B5C, "Member 'ADBDPlayer::ClearPathTestRadiusMultiplier' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, ClearPathTestHeightMultiplier) == 0x000B60, "Member 'ADBDPlayer::ClearPathTestHeightMultiplier' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, LocationClearTestRadiusMultiplier) == 0x000B64, "Member 'ADBDPlayer::LocationClearTestRadiusMultiplier' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, LocationClearTestHeightMultiplier) == 0x000B68, "Member 'ADBDPlayer::LocationClearTestHeightMultiplier' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, ClearPathTestStepHeight) == 0x000B6C, "Member 'ADBDPlayer::ClearPathTestStepHeight' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, MouseTurnSpeedMultiplier) == 0x000B70, "Member 'ADBDPlayer::MouseTurnSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, MouseLookUpSpeedMultiplier) == 0x000B74, "Member 'ADBDPlayer::MouseLookUpSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, DeathSound) == 0x000B78, "Member 'ADBDPlayer::DeathSound' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, CurrentCamperState) == 0x000B80, "Member 'ADBDPlayer::CurrentCamperState' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, CollectableAttachPoint) == 0x000B84, "Member 'ADBDPlayer::CollectableAttachPoint' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _stateMachine) == 0x000B90, "Member 'ADBDPlayer::_stateMachine' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _interactionHandler) == 0x000B98, "Member 'ADBDPlayer::_interactionHandler' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _perkManager) == 0x000BA0, "Member 'ADBDPlayer::_perkManager' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _playerData) == 0x000BA8, "Member 'ADBDPlayer::_playerData' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _interactable) == 0x000BB0, "Member 'ADBDPlayer::_interactable' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _carryingPlayer) == 0x000C08, "Member 'ADBDPlayer::_carryingPlayer' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _interactingPlayer) == 0x000C18, "Member 'ADBDPlayer::_interactingPlayer' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _nextAttackSubstate) == 0x000C50, "Member 'ADBDPlayer::_nextAttackSubstate' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _hitTargets) == 0x000C58, "Member 'ADBDPlayer::_hitTargets' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _characterChaseVisualComponent) == 0x000C68, "Member 'ADBDPlayer::_characterChaseVisualComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _cameraHandlerComponent) == 0x000C70, "Member 'ADBDPlayer::_cameraHandlerComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _reversibleActionSystemComponent) == 0x000C78, "Member 'ADBDPlayer::_reversibleActionSystemComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _itemDropOffPosition) == 0x000C80, "Member 'ADBDPlayer::_itemDropOffPosition' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _perceptionStimuliComponent) == 0x000C88, "Member 'ADBDPlayer::_perceptionStimuliComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _ignoreActors) == 0x000C90, "Member 'ADBDPlayer::_ignoreActors' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, EffectCameraTypeSettings) == 0x000CA0, "Member 'ADBDPlayer::EffectCameraTypeSettings' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _detectionZoneEnabledMap) == 0x000CB0, "Member 'ADBDPlayer::_detectionZoneEnabledMap' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _blindingChargeableComponent) == 0x000D58, "Member 'ADBDPlayer::_blindingChargeableComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _stillnessStartTime) == 0x000D60, "Member 'ADBDPlayer::_stillnessStartTime' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _shouldUpdateStateMachineDriverOnPossessed) == 0x000E40, "Member 'ADBDPlayer::_shouldUpdateStateMachineDriverOnPossessed' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _blindableComponent) == 0x000E48, "Member 'ADBDPlayer::_blindableComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _tutorialChargeableInteractionMultiplier) == 0x000E54, "Member 'ADBDPlayer::_tutorialChargeableInteractionMultiplier' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _eventListener) == 0x000E60, "Member 'ADBDPlayer::_eventListener' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _chaseComponent) == 0x000E70, "Member 'ADBDPlayer::_chaseComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _meatHookZoneDetector) == 0x000E78, "Member 'ADBDPlayer::_meatHookZoneDetector' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _basementZoneDetector) == 0x000E80, "Member 'ADBDPlayer::_basementZoneDetector' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _animGameplayTags) == 0x000F20, "Member 'ADBDPlayer::_animGameplayTags' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _bookmarkedInteraction) == 0x000FC8, "Member 'ADBDPlayer::_bookmarkedInteraction' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _detectionZoneMap) == 0x000FD0, "Member 'ADBDPlayer::_detectionZoneMap' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _authoritativeMovementComponent) == 0x001090, "Member 'ADBDPlayer::_authoritativeMovementComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _screenAspectRatio) == 0x0013F4, "Member 'ADBDPlayer::_screenAspectRatio' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _objectState) == 0x001418, "Member 'ADBDPlayer::_objectState' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _audioFXComponent) == 0x001420, "Member 'ADBDPlayer::_audioFXComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _playerPerspectiveComponent) == 0x001428, "Member 'ADBDPlayer::_playerPerspectiveComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _characterSightComponent) == 0x001438, "Member 'ADBDPlayer::_characterSightComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _characterSightableComponent) == 0x001448, "Member 'ADBDPlayer::_characterSightableComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _navigationStateComponent) == 0x001460, "Member 'ADBDPlayer::_navigationStateComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _interactionDetectorComponent) == 0x001468, "Member 'ADBDPlayer::_interactionDetectorComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _clippablePrimitivesRegistererComponent) == 0x001470, "Member 'ADBDPlayer::_clippablePrimitivesRegistererComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _clippableProviderComponent) == 0x001478, "Member 'ADBDPlayer::_clippableProviderComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _dynCapsuleResizer) == 0x001480, "Member 'ADBDPlayer::_dynCapsuleResizer' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _axisMovementComponent) == 0x001488, "Member 'ADBDPlayer::_axisMovementComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _playerGameRelevancyComponent) == 0x001490, "Member 'ADBDPlayer::_playerGameRelevancyComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _contextualQuestComponent) == 0x001498, "Member 'ADBDPlayer::_contextualQuestComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _questEventHandler) == 0x0014C0, "Member 'ADBDPlayer::_questEventHandler' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _presentationChargeableProgressComponent) == 0x0014C8, "Member 'ADBDPlayer::_presentationChargeableProgressComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _currentGamepadYawCurve) == 0x0014E8, "Member 'ADBDPlayer::_currentGamepadYawCurve' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _currentGamepadPitchCurve) == 0x0014F0, "Member 'ADBDPlayer::_currentGamepadPitchCurve' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _associatedPlayerStateCache) == 0x0014F8, "Member 'ADBDPlayer::_associatedPlayerStateCache' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _onMovementCacheStruct) == 0x001500, "Member 'ADBDPlayer::_onMovementCacheStruct' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _otherCharactersVerticalCollisionsHandler) == 0x001520, "Member 'ADBDPlayer::_otherCharactersVerticalCollisionsHandler' has a wrong offset!");

// Class DeadByDaylight.ChaseComponent
// 0x0088 (0x0140 - 0x00B8)
class UChaseComponent : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(class ADBDPlayer* Player)> OnChaseStarted;                         // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADBDPlayer* Player, float chaseTime)> OnChaseEnded;          // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnAllChaseEnded;                                   // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool IsInChase)> OnIsInChaseChanged;                               // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FTagStateBool                          _isInChase;                                        // 0x00F8(0x0048)(Net, RepNotify, NativeAccessSpecifierPrivate)

public:
	void OnRep_IsInChase();

	bool IsInChase() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChaseComponent">();
	}
	static class UChaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChaseComponent>();
	}
};
static_assert(alignof(UChaseComponent) == 0x000008, "Wrong alignment on UChaseComponent");
static_assert(sizeof(UChaseComponent) == 0x000140, "Wrong size on UChaseComponent");
static_assert(offsetof(UChaseComponent, OnChaseStarted) == 0x0000B8, "Member 'UChaseComponent::OnChaseStarted' has a wrong offset!");
static_assert(offsetof(UChaseComponent, OnChaseEnded) == 0x0000C8, "Member 'UChaseComponent::OnChaseEnded' has a wrong offset!");
static_assert(offsetof(UChaseComponent, OnAllChaseEnded) == 0x0000D8, "Member 'UChaseComponent::OnAllChaseEnded' has a wrong offset!");
static_assert(offsetof(UChaseComponent, OnIsInChaseChanged) == 0x0000E8, "Member 'UChaseComponent::OnIsInChaseChanged' has a wrong offset!");
static_assert(offsetof(UChaseComponent, _isInChase) == 0x0000F8, "Member 'UChaseComponent::_isInChase' has a wrong offset!");

// Class DeadByDaylight.ChaserCharacterComponent
// 0x0100 (0x0240 - 0x0140)
class UChaserCharacterComponent final : public UChaseComponent
{
public:
	uint8                                         Pad_140[0x38];                                     // 0x0140(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDPawnSensingComponent*               _camperSensor;                                     // 0x0178(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class ADBDPlayer*, struct FChaseUpdateInfo> _chaseUpdateInfo;                               // 0x0180(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class ADBDPlayer*>                     _chasedPlayers;                                    // 0x01D0(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class ADBDPlayer*>                     _authority_survivorsWhoStunnedKillerByPalletDuringChase; // 0x01E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F0[0x28];                                     // 0x01F0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _preventChaseTags;                                 // 0x0218(0x0020)(Edit, NativeAccessSpecifierPrivate)
	bool                                          _camperSensorLocationUsesEyesViewPoint;            // 0x0238(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnChaseTargetFound(class APawn* Pawn);
	void Multicast_OnAllChaseEnd();
	void Multicast_OnChaseEnd(class ASurvivor* Survivor, const struct FChaseUpdateInfo& ChaseUpdateInfo);
	void Multicast_OnChaseStart(class ASurvivor* Survivor);
	void OnKillerLocallyObservedChanged(bool locallyObserved);

	void OnRep_ChasedPlayers() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChaserCharacterComponent">();
	}
	static class UChaserCharacterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChaserCharacterComponent>();
	}
};
static_assert(alignof(UChaserCharacterComponent) == 0x000008, "Wrong alignment on UChaserCharacterComponent");
static_assert(sizeof(UChaserCharacterComponent) == 0x000240, "Wrong size on UChaserCharacterComponent");
static_assert(offsetof(UChaserCharacterComponent, _camperSensor) == 0x000178, "Member 'UChaserCharacterComponent::_camperSensor' has a wrong offset!");
static_assert(offsetof(UChaserCharacterComponent, _chaseUpdateInfo) == 0x000180, "Member 'UChaserCharacterComponent::_chaseUpdateInfo' has a wrong offset!");
static_assert(offsetof(UChaserCharacterComponent, _chasedPlayers) == 0x0001D0, "Member 'UChaserCharacterComponent::_chasedPlayers' has a wrong offset!");
static_assert(offsetof(UChaserCharacterComponent, _authority_survivorsWhoStunnedKillerByPalletDuringChase) == 0x0001E0, "Member 'UChaserCharacterComponent::_authority_survivorsWhoStunnedKillerByPalletDuringChase' has a wrong offset!");
static_assert(offsetof(UChaserCharacterComponent, _preventChaseTags) == 0x000218, "Member 'UChaserCharacterComponent::_preventChaseTags' has a wrong offset!");
static_assert(offsetof(UChaserCharacterComponent, _camperSensorLocationUsesEyesViewPoint) == 0x000238, "Member 'UChaserCharacterComponent::_camperSensorLocationUsesEyesViewPoint' has a wrong offset!");

// Class DeadByDaylight.KillerProjectile
// 0x0080 (0x03D8 - 0x0358)
class AKillerProjectile : public APhysicsBasedProjectile
{
public:
	uint8                                         Pad_358[0x48];                                     // 0x0358(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _killerProjectileAttemptGameEventTag;              // 0x03A0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3AC[0x4];                                      // 0x03AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHitValidatorConfigurator*              _hitValidatorConfigurator;                         // 0x03B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHitValidatorComponent*                 _hitValidatorComponent;                            // 0x03B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EHitValidatorConfigName                       _hitValidationConfigName;                          // 0x03C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C1[0x17];                                     // 0x03C1(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetActiveSlashable(bool Active);

	class AKiller* GetLaunchingKiller() const;
	class UPrimitiveComponent* GetPlayerPrimitiveComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerProjectile">();
	}
	static class AKillerProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKillerProjectile>();
	}
};
static_assert(alignof(AKillerProjectile) == 0x000008, "Wrong alignment on AKillerProjectile");
static_assert(sizeof(AKillerProjectile) == 0x0003D8, "Wrong size on AKillerProjectile");
static_assert(offsetof(AKillerProjectile, _killerProjectileAttemptGameEventTag) == 0x0003A0, "Member 'AKillerProjectile::_killerProjectileAttemptGameEventTag' has a wrong offset!");
static_assert(offsetof(AKillerProjectile, _hitValidatorConfigurator) == 0x0003B0, "Member 'AKillerProjectile::_hitValidatorConfigurator' has a wrong offset!");
static_assert(offsetof(AKillerProjectile, _hitValidatorComponent) == 0x0003B8, "Member 'AKillerProjectile::_hitValidatorComponent' has a wrong offset!");
static_assert(offsetof(AKillerProjectile, _hitValidationConfigName) == 0x0003C0, "Member 'AKillerProjectile::_hitValidationConfigName' has a wrong offset!");

// Class DeadByDaylight.ColorBlindSettingsListenerInterface
// 0x0000 (0x0000 - 0x0000)
class IColorBlindSettingsListenerInterface final
{
public:
	void OnColorBlindSettingsChange(EColorVisionDeficiency ColorBlindMode, int32 ColorblindIntensity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ColorBlindSettingsListenerInterface">();
	}
	static class IColorBlindSettingsListenerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IColorBlindSettingsListenerInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IColorBlindSettingsListenerInterface) == 0x000001, "Wrong alignment on IColorBlindSettingsListenerInterface");
static_assert(sizeof(IColorBlindSettingsListenerInterface) == 0x000001, "Wrong size on IColorBlindSettingsListenerInterface");

// Class DeadByDaylight.LoudNoiseNotifier
// 0x0000 (0x0030 - 0x0030)
class ULoudNoiseNotifier final : public UBlueprintFunctionLibrary
{
public:
	static bool CanSeeLoudNoise(const class UObject* WorldContextObject, const struct FVector& Location);
	static void Fire(const class UObject* WorldContextObject, class AActor* Instigator, const struct FVector& Location, bool shouldTrack, float audibleRange, class ADBDPlayer* instigatingPlayer, bool isQuickAction, bool isDeceivingNoise);
	static void FireWithTimeBudgeter(const class UObject* WorldContextObject, class AActor* Instigator, const struct FVector& Location, bool shouldTrack, float audibleRange, class ADBDPlayer* instigatingPlayer, bool isQuickAction);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoudNoiseNotifier">();
	}
	static class ULoudNoiseNotifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoudNoiseNotifier>();
	}
};
static_assert(alignof(ULoudNoiseNotifier) == 0x000008, "Wrong alignment on ULoudNoiseNotifier");
static_assert(sizeof(ULoudNoiseNotifier) == 0x000030, "Wrong size on ULoudNoiseNotifier");

// Class DeadByDaylight.TotemBoundPerk
// 0x0058 (0x04B8 - 0x0460)
class UTotemBoundPerk : public UPerk
{
public:
	uint8                                         Pad_460[0x18];                                     // 0x0460(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	ETotemState                                   TotemBoundState;                                   // 0x0478(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _doNotBindToTotemOnInit;                           // 0x0479(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_47A[0x6];                                      // 0x047A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ATotem*>                         _boundTotems;                                      // 0x0480(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<class ATotem*>                         _local_boundTotems;                                // 0x0490(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class ATotem*>                         _authorityPrevTotemActors;                         // 0x04A0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         _numTotemsToBind;                                  // 0x04B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B4[0x4];                                      // 0x04B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool Authority_BindToDullTotems(bool allowAdditionalBoundTotems);
	void Authority_UnbindFromTotem(class ATotem* aTotemActor);
	void OnRep_BoundTotems();

	TArray<class ATotem*> GetBoundTotems() const;
	float GetSquaredDistanceToOwner(const class AActor* Survivor) const;
	const TArray<class ATotem*> GetTotems() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TotemBoundPerk">();
	}
	static class UTotemBoundPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTotemBoundPerk>();
	}
};
static_assert(alignof(UTotemBoundPerk) == 0x000008, "Wrong alignment on UTotemBoundPerk");
static_assert(sizeof(UTotemBoundPerk) == 0x0004B8, "Wrong size on UTotemBoundPerk");
static_assert(offsetof(UTotemBoundPerk, TotemBoundState) == 0x000478, "Member 'UTotemBoundPerk::TotemBoundState' has a wrong offset!");
static_assert(offsetof(UTotemBoundPerk, _doNotBindToTotemOnInit) == 0x000479, "Member 'UTotemBoundPerk::_doNotBindToTotemOnInit' has a wrong offset!");
static_assert(offsetof(UTotemBoundPerk, _boundTotems) == 0x000480, "Member 'UTotemBoundPerk::_boundTotems' has a wrong offset!");
static_assert(offsetof(UTotemBoundPerk, _local_boundTotems) == 0x000490, "Member 'UTotemBoundPerk::_local_boundTotems' has a wrong offset!");
static_assert(offsetof(UTotemBoundPerk, _authorityPrevTotemActors) == 0x0004A0, "Member 'UTotemBoundPerk::_authorityPrevTotemActors' has a wrong offset!");
static_assert(offsetof(UTotemBoundPerk, _numTotemsToBind) == 0x0004B0, "Member 'UTotemBoundPerk::_numTotemsToBind' has a wrong offset!");

// Class DeadByDaylight.DBDSpringArmComponent
// 0x0090 (0x0460 - 0x03D0)
class UDBDSpringArmComponent final : public USpringArmComponent
{
public:
	uint8                                         bEnableComponentwiseCameraLag : 1;                 // 0x03D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3D1[0x7];                                      // 0x03D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ComponenwiseCameraLagSpeed;                        // 0x03D8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetArmMinLength;                                // 0x03F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableDistanceCameraLag : 1;                      // 0x03F4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3F5[0x3];                                      // 0x03F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraDistanceLagSpeed;                            // 0x03F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3FC[0x4];                                      // 0x03FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bDrawDebugTraceMarkers : 1;                        // 0x0400(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_401[0x7];                                      // 0x0401(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AActor>>          ignoreActors;                                      // 0x0408(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_418[0x48];                                     // 0x0418(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void IgnoreActor(class AActor* Actor, bool bShouldIgnore);
	void ZoomCamera(float zoomCount, float zoomDuration);
	void ZoomCameraToDefault(float zoomDuration);
	void ZoomCameraTowardsNewTargetArmLength(float newTargetArmLength, float zoomDuration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDSpringArmComponent">();
	}
	static class UDBDSpringArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDSpringArmComponent>();
	}
};
static_assert(alignof(UDBDSpringArmComponent) == 0x000010, "Wrong alignment on UDBDSpringArmComponent");
static_assert(sizeof(UDBDSpringArmComponent) == 0x000460, "Wrong size on UDBDSpringArmComponent");
static_assert(offsetof(UDBDSpringArmComponent, ComponenwiseCameraLagSpeed) == 0x0003D8, "Member 'UDBDSpringArmComponent::ComponenwiseCameraLagSpeed' has a wrong offset!");
static_assert(offsetof(UDBDSpringArmComponent, TargetArmMinLength) == 0x0003F0, "Member 'UDBDSpringArmComponent::TargetArmMinLength' has a wrong offset!");
static_assert(offsetof(UDBDSpringArmComponent, CameraDistanceLagSpeed) == 0x0003F8, "Member 'UDBDSpringArmComponent::CameraDistanceLagSpeed' has a wrong offset!");
static_assert(offsetof(UDBDSpringArmComponent, ignoreActors) == 0x000408, "Member 'UDBDSpringArmComponent::ignoreActors' has a wrong offset!");

// Class DeadByDaylight.GameplayModifierFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameplayModifierFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void Authority_ClearAllPlayerGameplayFlags(class ADBDPlayer* TargetPlayer);
	static void Authority_ClearAllPlayerGameplayModifiers(class ADBDPlayer* TargetPlayer);
	static void Authority_ClearPlayerGameplayFlag(class ADBDPlayer* TargetPlayer, const struct FGameplayTag& FlagType);
	static void Authority_ClearPlayerGameplayModifier(class ADBDPlayer* TargetPlayer, const struct FGameplayTag& modifierType);
	static void Authority_SetPlayerGameplayFlag(class ADBDPlayer* TargetPlayer, const struct FGameplayTag& FlagType);
	static void Authority_SetPlayerGameplayModifier(class ADBDPlayer* TargetPlayer, const struct FGameplayTag& modifierType, float ModifierValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayModifierFunctionLibrary">();
	}
	static class UGameplayModifierFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayModifierFunctionLibrary>();
	}
};
static_assert(alignof(UGameplayModifierFunctionLibrary) == 0x000008, "Wrong alignment on UGameplayModifierFunctionLibrary");
static_assert(sizeof(UGameplayModifierFunctionLibrary) == 0x000030, "Wrong size on UGameplayModifierFunctionLibrary");

// Class DeadByDaylight.AnimationFollowerActor
// 0x00B8 (0x0358 - 0x02A0)
class AAnimationFollowerActor : public AActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDSkeletalMeshComponentBudgeted*      _skeletalMeshComponent;                            // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationMontageSlave*                 _montageFollower;                                  // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMontagePlayer*                         _montagePlayer;                                    // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x78];                                     // 0x02C0(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           _montageIDsLeavingActorVisible;                    // 0x0338(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_348[0x9];                                      // 0x0348(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _attachToMontageLeaderOnAnimationStart;            // 0x0351(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_352[0x6];                                      // 0x0352(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnMontageStarted(const struct FAnimationMontageDescriptor& montagePlayed);
	void Cosmetic_OnMontageStopped();
	void Cosmetic_OnVisibilityChanged(bool IsVisible);
	void NativeOnMontageEnded(const struct FAnimationMontageDescriptor& Montage, bool interrupted);
	void NativeOnMontageStarted(const struct FAnimationMontageDescriptor& ID, const float Rate);
	void NativeOnMontageStopped(const struct FAnimationMontageDescriptor& ID);
	void OnMontageEnd(const struct FAnimationMontageDescriptor& MontageID, bool interrupted);
	void OnMontageStarted(const struct FAnimationMontageDescriptor& MontageID, const float Rate);
	void OnMontageStopped(const struct FAnimationMontageDescriptor& MontageID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationFollowerActor">();
	}
	static class AAnimationFollowerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAnimationFollowerActor>();
	}
};
static_assert(alignof(AAnimationFollowerActor) == 0x000008, "Wrong alignment on AAnimationFollowerActor");
static_assert(sizeof(AAnimationFollowerActor) == 0x000358, "Wrong size on AAnimationFollowerActor");
static_assert(offsetof(AAnimationFollowerActor, _skeletalMeshComponent) == 0x0002A8, "Member 'AAnimationFollowerActor::_skeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AAnimationFollowerActor, _montageFollower) == 0x0002B0, "Member 'AAnimationFollowerActor::_montageFollower' has a wrong offset!");
static_assert(offsetof(AAnimationFollowerActor, _montagePlayer) == 0x0002B8, "Member 'AAnimationFollowerActor::_montagePlayer' has a wrong offset!");
static_assert(offsetof(AAnimationFollowerActor, _montageIDsLeavingActorVisible) == 0x000338, "Member 'AAnimationFollowerActor::_montageIDsLeavingActorVisible' has a wrong offset!");
static_assert(offsetof(AAnimationFollowerActor, _attachToMontageLeaderOnAnimationStart) == 0x000351, "Member 'AAnimationFollowerActor::_attachToMontageLeaderOnAnimationStart' has a wrong offset!");

// Class DeadByDaylight.DBDBotsUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDBotsUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBotsUtilities">();
	}
	static class UDBDBotsUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDBotsUtilities>();
	}
};
static_assert(alignof(UDBDBotsUtilities) == 0x000008, "Wrong alignment on UDBDBotsUtilities");
static_assert(sizeof(UDBDBotsUtilities) == 0x000030, "Wrong size on UDBDBotsUtilities");

// Class DeadByDaylight.ObjectPlacerComponent
// 0x0070 (0x0340 - 0x02D0)
#pragma pack(push, 0x1)
class alignas(0x10) UObjectPlacerComponent : public USceneComponent
{
public:
	class UObjectPlacementUpdateStrategy*         _objectPlacementUpdateStrategy;                    // 0x02D0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoClear, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObjectPlacementValidationStrategy*     _objectPlacementValidationStrategy;                // 0x02D8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoClear, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   _objectMesh;                                       // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _meshOffsetZ;                                      // 0x02E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _socketName;                                       // 0x02EC(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _indicatorOffsetY;                                 // 0x02F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _indicatorOffsetX;                                 // 0x02FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _itemObjectId;                                     // 0x0300(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _showIndicator;                                    // 0x030C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _stayActiveWhileItemInUse;                         // 0x030D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hideIndicatorDuringAttack;                        // 0x030E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30F[0x1];                                      // 0x030F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   _tagsPreventingObjectPlacement;                    // 0x0310(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_320[0x18];                                     // 0x0320(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateObjectPlacement(bool Active);
	void SetHideIndicatorDuringAttack(bool Enable);
	void SetIndicatorOffsetX(float X);
	void SetIndicatorOffsetY(float Y);
	void SetMeshOffsetZ(float Z);
	void SetObjectMesh(class UStaticMeshComponent* objectMesh);
	void SetShowIndicator(bool NewValue);

	struct FVector GetObjectPlacementLocation() const;
	struct FRotator GetObjectPlacementRotation() const;
	bool IsPlacementValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectPlacerComponent">();
	}
	static class UObjectPlacerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectPlacerComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UObjectPlacerComponent) == 0x000010, "Wrong alignment on UObjectPlacerComponent");
static_assert(sizeof(UObjectPlacerComponent) == 0x000340, "Wrong size on UObjectPlacerComponent");
static_assert(offsetof(UObjectPlacerComponent, _objectPlacementUpdateStrategy) == 0x0002D0, "Member 'UObjectPlacerComponent::_objectPlacementUpdateStrategy' has a wrong offset!");
static_assert(offsetof(UObjectPlacerComponent, _objectPlacementValidationStrategy) == 0x0002D8, "Member 'UObjectPlacerComponent::_objectPlacementValidationStrategy' has a wrong offset!");
static_assert(offsetof(UObjectPlacerComponent, _objectMesh) == 0x0002E0, "Member 'UObjectPlacerComponent::_objectMesh' has a wrong offset!");
static_assert(offsetof(UObjectPlacerComponent, _meshOffsetZ) == 0x0002E8, "Member 'UObjectPlacerComponent::_meshOffsetZ' has a wrong offset!");
static_assert(offsetof(UObjectPlacerComponent, _socketName) == 0x0002EC, "Member 'UObjectPlacerComponent::_socketName' has a wrong offset!");
static_assert(offsetof(UObjectPlacerComponent, _indicatorOffsetY) == 0x0002F8, "Member 'UObjectPlacerComponent::_indicatorOffsetY' has a wrong offset!");
static_assert(offsetof(UObjectPlacerComponent, _indicatorOffsetX) == 0x0002FC, "Member 'UObjectPlacerComponent::_indicatorOffsetX' has a wrong offset!");
static_assert(offsetof(UObjectPlacerComponent, _itemObjectId) == 0x000300, "Member 'UObjectPlacerComponent::_itemObjectId' has a wrong offset!");
static_assert(offsetof(UObjectPlacerComponent, _showIndicator) == 0x00030C, "Member 'UObjectPlacerComponent::_showIndicator' has a wrong offset!");
static_assert(offsetof(UObjectPlacerComponent, _stayActiveWhileItemInUse) == 0x00030D, "Member 'UObjectPlacerComponent::_stayActiveWhileItemInUse' has a wrong offset!");
static_assert(offsetof(UObjectPlacerComponent, _hideIndicatorDuringAttack) == 0x00030E, "Member 'UObjectPlacerComponent::_hideIndicatorDuringAttack' has a wrong offset!");
static_assert(offsetof(UObjectPlacerComponent, _tagsPreventingObjectPlacement) == 0x000310, "Member 'UObjectPlacerComponent::_tagsPreventingObjectPlacement' has a wrong offset!");

// Class DeadByDaylight.ChargerComponent
// 0x0098 (0x0150 - 0x00B8)
class UChargerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ChargerComponentID;                                // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool Empty)>    OnChargeStateChange;                               // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float ChargePercent)> OnChargePercentChange;                       // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0x30];                                      // 0x00F0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	EEnergyTypeEnum                               EnergyType;                                        // 0x0120(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_121[0x3];                                      // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _currentEnergyLevel;                               // 0x0124(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxEnergyLevel;                                   // 0x0128(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12C[0x24];                                     // 0x012C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_EnergyLevel(float previousEnergyLevel);
	void Reset();
	void SetEnergyLevel(float EnergyLevel);
	float SetEnergyLevelAndGetDiff(float EnergyLevel);
	void SetMaxEnergyLevel(float EnergyLevel);
	void SetNormalizedEnergyLevel(float EnergyLevel);
	void UseEnergy(float Seconds, float energyUseModifier);

	float GetEnergyLevel() const;
	float GetMaxEnergyLevel() const;
	float GetNormalizedEnergyLevel() const;
	bool HasCharge() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChargerComponent">();
	}
	static class UChargerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChargerComponent>();
	}
};
static_assert(alignof(UChargerComponent) == 0x000008, "Wrong alignment on UChargerComponent");
static_assert(sizeof(UChargerComponent) == 0x000150, "Wrong size on UChargerComponent");
static_assert(offsetof(UChargerComponent, ChargerComponentID) == 0x0000C0, "Member 'UChargerComponent::ChargerComponentID' has a wrong offset!");
static_assert(offsetof(UChargerComponent, OnChargeStateChange) == 0x0000D0, "Member 'UChargerComponent::OnChargeStateChange' has a wrong offset!");
static_assert(offsetof(UChargerComponent, OnChargePercentChange) == 0x0000E0, "Member 'UChargerComponent::OnChargePercentChange' has a wrong offset!");
static_assert(offsetof(UChargerComponent, EnergyType) == 0x000120, "Member 'UChargerComponent::EnergyType' has a wrong offset!");
static_assert(offsetof(UChargerComponent, _currentEnergyLevel) == 0x000124, "Member 'UChargerComponent::_currentEnergyLevel' has a wrong offset!");
static_assert(offsetof(UChargerComponent, _maxEnergyLevel) == 0x000128, "Member 'UChargerComponent::_maxEnergyLevel' has a wrong offset!");

// Class DeadByDaylight.DBDGenericTeamAgentInterface
// 0x0000 (0x0000 - 0x0000)
class IDBDGenericTeamAgentInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGenericTeamAgentInterface">();
	}
	static class IDBDGenericTeamAgentInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDBDGenericTeamAgentInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IDBDGenericTeamAgentInterface) == 0x000001, "Wrong alignment on IDBDGenericTeamAgentInterface");
static_assert(sizeof(IDBDGenericTeamAgentInterface) == 0x000001, "Wrong size on IDBDGenericTeamAgentInterface");

// Class DeadByDaylight.PowerWidgetPresentationComponent
// 0x0018 (0x00D0 - 0x00B8)
class UPowerWidgetPresentationComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UPowerWidgetData*                       _powerWidgetData;                                  // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PowerWidgetPresentationComponent">();
	}
	static class UPowerWidgetPresentationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPowerWidgetPresentationComponent>();
	}
};
static_assert(alignof(UPowerWidgetPresentationComponent) == 0x000008, "Wrong alignment on UPowerWidgetPresentationComponent");
static_assert(sizeof(UPowerWidgetPresentationComponent) == 0x0000D0, "Wrong size on UPowerWidgetPresentationComponent");
static_assert(offsetof(UPowerWidgetPresentationComponent, _powerWidgetData) == 0x0000C8, "Member 'UPowerWidgetPresentationComponent::_powerWidgetData' has a wrong offset!");

// Class DeadByDaylight.QuickTimeEventPlayerComponent
// 0x0020 (0x00D8 - 0x00B8)
class UQuickTimeEventPlayerComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x20];                                      // 0x00B8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_CompleteQuickTimeEvent(const struct FQuickTimeEventResponse& Response);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuickTimeEventPlayerComponent">();
	}
	static class UQuickTimeEventPlayerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuickTimeEventPlayerComponent>();
	}
};
static_assert(alignof(UQuickTimeEventPlayerComponent) == 0x000008, "Wrong alignment on UQuickTimeEventPlayerComponent");
static_assert(sizeof(UQuickTimeEventPlayerComponent) == 0x0000D8, "Wrong size on UQuickTimeEventPlayerComponent");

// Class DeadByDaylight.DetectionZoneUtilities
// 0x0000 (0x0030 - 0x0030)
class UDetectionZoneUtilities final : public UBlueprintFunctionLibrary
{
public:
	static bool DetectObstruction(const class ADBDPlayer* Player, EDetectionZone detectionZoneID, class UPhysicalMaterial** physicalMaterialOut, struct FVector* positionOut, struct FVector* normalOut);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DetectionZoneUtilities">();
	}
	static class UDetectionZoneUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDetectionZoneUtilities>();
	}
};
static_assert(alignof(UDetectionZoneUtilities) == 0x000008, "Wrong alignment on UDetectionZoneUtilities");
static_assert(sizeof(UDetectionZoneUtilities) == 0x000030, "Wrong size on UDetectionZoneUtilities");

// Class DeadByDaylight.BlockElement
// 0x0078 (0x00A8 - 0x0030)
class UBlockElement final : public UObject
{
public:
	TWeakObjectPtr<class UObject>                 _source;                                           // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<TWeakObjectPtr<class ADBDPlayer>>        _affectedPlayers;                                  // 0x0038(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x20];                                      // 0x0088(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlockElement">();
	}
	static class UBlockElement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlockElement>();
	}
};
static_assert(alignof(UBlockElement) == 0x000008, "Wrong alignment on UBlockElement");
static_assert(sizeof(UBlockElement) == 0x0000A8, "Wrong size on UBlockElement");
static_assert(offsetof(UBlockElement, _source) == 0x000030, "Member 'UBlockElement::_source' has a wrong offset!");
static_assert(offsetof(UBlockElement, _affectedPlayers) == 0x000038, "Member 'UBlockElement::_affectedPlayers' has a wrong offset!");

// Class DeadByDaylight.DemogorgonAnimProxy
// 0x0000 (0x0000 - 0x0000)
class IDemogorgonAnimProxy final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DemogorgonAnimProxy">();
	}
	static class IDemogorgonAnimProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDemogorgonAnimProxy>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IDemogorgonAnimProxy) == 0x000001, "Wrong alignment on IDemogorgonAnimProxy");
static_assert(sizeof(IDemogorgonAnimProxy) == 0x000001, "Wrong size on IDemogorgonAnimProxy");

// Class DeadByDaylight.PlayerInteractable
// 0x0038 (0x03E0 - 0x03A8)
class APlayerInteractable : public AInteractable
{
public:
	class UPrimitiveComponent*                    _mainInteractionZone;                              // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractor*                            _selfInteractionsInteractor;                       // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _rootComponent;                                    // 0x03B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C0[0x20];                                     // 0x03C0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitInteractable(class ADBDPlayer* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerInteractable">();
	}
	static class APlayerInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerInteractable>();
	}
};
static_assert(alignof(APlayerInteractable) == 0x000008, "Wrong alignment on APlayerInteractable");
static_assert(sizeof(APlayerInteractable) == 0x0003E0, "Wrong size on APlayerInteractable");
static_assert(offsetof(APlayerInteractable, _mainInteractionZone) == 0x0003A8, "Member 'APlayerInteractable::_mainInteractionZone' has a wrong offset!");
static_assert(offsetof(APlayerInteractable, _selfInteractionsInteractor) == 0x0003B0, "Member 'APlayerInteractable::_selfInteractionsInteractor' has a wrong offset!");
static_assert(offsetof(APlayerInteractable, _rootComponent) == 0x0003B8, "Member 'APlayerInteractable::_rootComponent' has a wrong offset!");

// Class DeadByDaylight.BloodTrailComponent
// 0x01C8 (0x0280 - 0x00B8)
class alignas(0x10) UBloodTrailComponent : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(class UDBDDecalComponent* decal)> Cosmetic_OnBloodDecalSpawned;    // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UBloodTrailSettings*                    _bloodTrailSettings;                               // 0x00C8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x80];                                      // 0x00D0(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UDBDDecalComponent*, struct FBloodDecal> _bloodDecals;                                // 0x0150(0x0050)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UBloodDecalEffect*                      _bloodDecalEffect;                                 // 0x01A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A8[0xC0];                                     // 0x01A8(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	class UDecalSpawner*                          _decalSpawner;                                     // 0x0268(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_270[0x10];                                     // 0x0270(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ConditionalStartBleeding();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodTrailComponent">();
	}
	static class UBloodTrailComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodTrailComponent>();
	}
};
static_assert(alignof(UBloodTrailComponent) == 0x000010, "Wrong alignment on UBloodTrailComponent");
static_assert(sizeof(UBloodTrailComponent) == 0x000280, "Wrong size on UBloodTrailComponent");
static_assert(offsetof(UBloodTrailComponent, Cosmetic_OnBloodDecalSpawned) == 0x0000B8, "Member 'UBloodTrailComponent::Cosmetic_OnBloodDecalSpawned' has a wrong offset!");
static_assert(offsetof(UBloodTrailComponent, _bloodTrailSettings) == 0x0000C8, "Member 'UBloodTrailComponent::_bloodTrailSettings' has a wrong offset!");
static_assert(offsetof(UBloodTrailComponent, _bloodDecals) == 0x000150, "Member 'UBloodTrailComponent::_bloodDecals' has a wrong offset!");
static_assert(offsetof(UBloodTrailComponent, _bloodDecalEffect) == 0x0001A0, "Member 'UBloodTrailComponent::_bloodDecalEffect' has a wrong offset!");
static_assert(offsetof(UBloodTrailComponent, _decalSpawner) == 0x000268, "Member 'UBloodTrailComponent::_decalSpawner' has a wrong offset!");

// Class DeadByDaylight.SoftBanManager
// 0x0040 (0x0070 - 0x0030)
class USoftBanManager final : public UObject
{
public:
	uint8                                         Pad_30[0x40];                                      // 0x0030(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoftBanManager">();
	}
	static class USoftBanManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoftBanManager>();
	}
};
static_assert(alignof(USoftBanManager) == 0x000008, "Wrong alignment on USoftBanManager");
static_assert(sizeof(USoftBanManager) == 0x000070, "Wrong size on USoftBanManager");

// Class DeadByDaylight.CombinedPartyFriendFacade
// 0x0138 (0x0168 - 0x0030)
class UCombinedPartyFriendFacade final : public UObject
{
public:
	uint8                                         Pad_30[0x138];                                     // 0x0030(0x0138)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CombinedPartyFriendFacade">();
	}
	static class UCombinedPartyFriendFacade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCombinedPartyFriendFacade>();
	}
};
static_assert(alignof(UCombinedPartyFriendFacade) == 0x000008, "Wrong alignment on UCombinedPartyFriendFacade");
static_assert(sizeof(UCombinedPartyFriendFacade) == 0x000168, "Wrong size on UCombinedPartyFriendFacade");

// Class DeadByDaylight.AICharacterBehaviourInteractWithActor
// 0x0030 (0x0088 - 0x0058)
class UAICharacterBehaviourInteractWithActor : public UAICharacterBehaviour
{
public:
	class ADBDPlayer*                             _aiPlayer;                                         // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADBDAIPlayerController*                 _aiPlayerController;                               // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAICharacterBehaviourInteractWithActorData* _behaviourData;                                // 0x0068(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_70[0x18];                                      // 0x0070(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMovementFinished(const struct FAIRequestID& RequestID, EPathFollowingResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterBehaviourInteractWithActor">();
	}
	static class UAICharacterBehaviourInteractWithActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterBehaviourInteractWithActor>();
	}
};
static_assert(alignof(UAICharacterBehaviourInteractWithActor) == 0x000008, "Wrong alignment on UAICharacterBehaviourInteractWithActor");
static_assert(sizeof(UAICharacterBehaviourInteractWithActor) == 0x000088, "Wrong size on UAICharacterBehaviourInteractWithActor");
static_assert(offsetof(UAICharacterBehaviourInteractWithActor, _aiPlayer) == 0x000058, "Member 'UAICharacterBehaviourInteractWithActor::_aiPlayer' has a wrong offset!");
static_assert(offsetof(UAICharacterBehaviourInteractWithActor, _aiPlayerController) == 0x000060, "Member 'UAICharacterBehaviourInteractWithActor::_aiPlayerController' has a wrong offset!");
static_assert(offsetof(UAICharacterBehaviourInteractWithActor, _behaviourData) == 0x000068, "Member 'UAICharacterBehaviourInteractWithActor::_behaviourData' has a wrong offset!");

// Class DeadByDaylight.AICharacterBehaviourDropPallet
// 0x0008 (0x0090 - 0x0088)
class UAICharacterBehaviourDropPallet final : public UAICharacterBehaviourInteractWithActor
{
public:
	class APallet*                                _targetPallet;                                     // 0x0088(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterBehaviourDropPallet">();
	}
	static class UAICharacterBehaviourDropPallet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterBehaviourDropPallet>();
	}
};
static_assert(alignof(UAICharacterBehaviourDropPallet) == 0x000008, "Wrong alignment on UAICharacterBehaviourDropPallet");
static_assert(sizeof(UAICharacterBehaviourDropPallet) == 0x000090, "Wrong size on UAICharacterBehaviourDropPallet");
static_assert(offsetof(UAICharacterBehaviourDropPallet, _targetPallet) == 0x000088, "Member 'UAICharacterBehaviourDropPallet::_targetPallet' has a wrong offset!");

// Class DeadByDaylight.DBDLocalPlayer
// 0x0000 (0x02A8 - 0x02A8)
class UDBDLocalPlayer final : public ULocalPlayer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDLocalPlayer">();
	}
	static class UDBDLocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDLocalPlayer>();
	}
};
static_assert(alignof(UDBDLocalPlayer) == 0x000008, "Wrong alignment on UDBDLocalPlayer");
static_assert(sizeof(UDBDLocalPlayer) == 0x0002A8, "Wrong size on UDBDLocalPlayer");

// Class DeadByDaylight.FirstPersonViewComponent
// 0x0048 (0x0100 - 0x00B8)
class UFirstPersonViewComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x28];                                      // 0x00B8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _activatingTagsForThirdPerson;                     // 0x00E0(0x0020)(Edit, NativeAccessSpecifierPrivate)

public:
	void OnIntroCompleted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FirstPersonViewComponent">();
	}
	static class UFirstPersonViewComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFirstPersonViewComponent>();
	}
};
static_assert(alignof(UFirstPersonViewComponent) == 0x000008, "Wrong alignment on UFirstPersonViewComponent");
static_assert(sizeof(UFirstPersonViewComponent) == 0x000100, "Wrong size on UFirstPersonViewComponent");
static_assert(offsetof(UFirstPersonViewComponent, _activatingTagsForThirdPerson) == 0x0000E0, "Member 'UFirstPersonViewComponent::_activatingTagsForThirdPerson' has a wrong offset!");

// Class DeadByDaylight.NavigationStateComponent
// 0x0110 (0x01C8 - 0x00B8)
class UNavigationStateComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x4B];                                      // 0x00B8(0x004B)(Fixing Size After Last Property [ Dumper-7 ])
	EImmobilizedState                             _immobilizedState;                                 // 0x0103(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuidingInfo                           _guidedState;                                      // 0x0108(0x0018)(Net, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x98];                                     // 0x0120(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADBDPlayer*>                     _local_oldGuidedPlayers;                           // 0x01B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void OnControllerChanged(class APawn* Pawn, class AController* OldController, class AController* NewController);
	void OnRep_GuidedState(const struct FGuidingInfo& previousState);
	void OnRep_ImmobilizedState(EImmobilizedState previousState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationStateComponent">();
	}
	static class UNavigationStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationStateComponent>();
	}
};
static_assert(alignof(UNavigationStateComponent) == 0x000008, "Wrong alignment on UNavigationStateComponent");
static_assert(sizeof(UNavigationStateComponent) == 0x0001C8, "Wrong size on UNavigationStateComponent");
static_assert(offsetof(UNavigationStateComponent, _immobilizedState) == 0x000103, "Member 'UNavigationStateComponent::_immobilizedState' has a wrong offset!");
static_assert(offsetof(UNavigationStateComponent, _guidedState) == 0x000108, "Member 'UNavigationStateComponent::_guidedState' has a wrong offset!");
static_assert(offsetof(UNavigationStateComponent, _local_oldGuidedPlayers) == 0x0001B8, "Member 'UNavigationStateComponent::_local_oldGuidedPlayers' has a wrong offset!");

// Class DeadByDaylight.AISenseConfig_Trail
// 0x0018 (0x0068 - 0x0050)
class UAISenseConfig_Trail final : public UAISenseConfig
{
public:
	TSubclassOf<class UAISense_Trail>             Implementation;                                    // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PeripheralVisionAngleDegrees;                      // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAISenseAffiliationFilter              DetectionByAffiliation;                            // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISenseConfig_Trail">();
	}
	static class UAISenseConfig_Trail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISenseConfig_Trail>();
	}
};
static_assert(alignof(UAISenseConfig_Trail) == 0x000008, "Wrong alignment on UAISenseConfig_Trail");
static_assert(sizeof(UAISenseConfig_Trail) == 0x000068, "Wrong size on UAISenseConfig_Trail");
static_assert(offsetof(UAISenseConfig_Trail, Implementation) == 0x000050, "Member 'UAISenseConfig_Trail::Implementation' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_Trail, MaxRange) == 0x000058, "Member 'UAISenseConfig_Trail::MaxRange' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_Trail, PeripheralVisionAngleDegrees) == 0x00005C, "Member 'UAISenseConfig_Trail::PeripheralVisionAngleDegrees' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_Trail, DetectionByAffiliation) == 0x000060, "Member 'UAISenseConfig_Trail::DetectionByAffiliation' has a wrong offset!");

// Class DeadByDaylight.StationaryPointLightComponent
// 0x0000 (0x04F0 - 0x04F0)
class UStationaryPointLightComponent final : public UPointLightComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StationaryPointLightComponent">();
	}
	static class UStationaryPointLightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStationaryPointLightComponent>();
	}
};
static_assert(alignof(UStationaryPointLightComponent) == 0x000010, "Wrong alignment on UStationaryPointLightComponent");
static_assert(sizeof(UStationaryPointLightComponent) == 0x0004F0, "Wrong size on UStationaryPointLightComponent");

// Class DeadByDaylight.ObjectPlacementValidationWithRestrictionStrategy
// 0x0010 (0x0120 - 0x0110)
class UObjectPlacementValidationWithRestrictionStrategy : public UDefaultObjectPlacementValidationStrategy
{
public:
	TArray<class URestrictedPlacementAreaStrategy*> _restrictedAreas;                                // 0x0110(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, NoClear, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void OnIntroComplete();
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectPlacementValidationWithRestrictionStrategy">();
	}
	static class UObjectPlacementValidationWithRestrictionStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectPlacementValidationWithRestrictionStrategy>();
	}
};
static_assert(alignof(UObjectPlacementValidationWithRestrictionStrategy) == 0x000008, "Wrong alignment on UObjectPlacementValidationWithRestrictionStrategy");
static_assert(sizeof(UObjectPlacementValidationWithRestrictionStrategy) == 0x000120, "Wrong size on UObjectPlacementValidationWithRestrictionStrategy");
static_assert(offsetof(UObjectPlacementValidationWithRestrictionStrategy, _restrictedAreas) == 0x000110, "Member 'UObjectPlacementValidationWithRestrictionStrategy::_restrictedAreas' has a wrong offset!");

// Class DeadByDaylight.ActivationTimerElapsedCooldownRemainingIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActivationTimerElapsedCooldownRemainingIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivationTimerElapsedCooldownRemainingIconStrategy">();
	}
	static class UActivationTimerElapsedCooldownRemainingIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivationTimerElapsedCooldownRemainingIconStrategy>();
	}
};
static_assert(alignof(UActivationTimerElapsedCooldownRemainingIconStrategy) == 0x000008, "Wrong alignment on UActivationTimerElapsedCooldownRemainingIconStrategy");
static_assert(sizeof(UActivationTimerElapsedCooldownRemainingIconStrategy) == 0x000038, "Wrong size on UActivationTimerElapsedCooldownRemainingIconStrategy");

// Class DeadByDaylight.BaseHitValidationConfigurator
// 0x0008 (0x00C0 - 0x00B8)
class UBaseHitValidationConfigurator : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseHitValidationConfigurator">();
	}
	static class UBaseHitValidationConfigurator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseHitValidationConfigurator>();
	}
};
static_assert(alignof(UBaseHitValidationConfigurator) == 0x000008, "Wrong alignment on UBaseHitValidationConfigurator");
static_assert(sizeof(UBaseHitValidationConfigurator) == 0x0000C0, "Wrong size on UBaseHitValidationConfigurator");

// Class DeadByDaylight.IterativeWeightAdjustmentStrategy
// 0x0010 (0x0040 - 0x0030)
class UIterativeWeightAdjustmentStrategy : public UObject
{
public:
	TArray<TScriptInterface<class IWeightedElement>> _selectedSpawners;                              // 0x0030(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IterativeWeightAdjustmentStrategy">();
	}
	static class UIterativeWeightAdjustmentStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIterativeWeightAdjustmentStrategy>();
	}
};
static_assert(alignof(UIterativeWeightAdjustmentStrategy) == 0x000008, "Wrong alignment on UIterativeWeightAdjustmentStrategy");
static_assert(sizeof(UIterativeWeightAdjustmentStrategy) == 0x000040, "Wrong size on UIterativeWeightAdjustmentStrategy");
static_assert(offsetof(UIterativeWeightAdjustmentStrategy, _selectedSpawners) == 0x000030, "Member 'UIterativeWeightAdjustmentStrategy::_selectedSpawners' has a wrong offset!");

// Class DeadByDaylight.KillerSpecificGameStateComponent
// 0x0000 (0x00B8 - 0x00B8)
class UKillerSpecificGameStateComponent : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerSpecificGameStateComponent">();
	}
	static class UKillerSpecificGameStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerSpecificGameStateComponent>();
	}
};
static_assert(alignof(UKillerSpecificGameStateComponent) == 0x000008, "Wrong alignment on UKillerSpecificGameStateComponent");
static_assert(sizeof(UKillerSpecificGameStateComponent) == 0x0000B8, "Wrong size on UKillerSpecificGameStateComponent");

// Class DeadByDaylight.BloodwebDistribution
// 0x02F0 (0x0320 - 0x0030)
class UBloodwebDistribution final : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBloodwebTunables*                      _bloodwebTunables;                                 // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x2D8];                                     // 0x0048(0x02D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodwebDistribution">();
	}
	static class UBloodwebDistribution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodwebDistribution>();
	}
};
static_assert(alignof(UBloodwebDistribution) == 0x000008, "Wrong alignment on UBloodwebDistribution");
static_assert(sizeof(UBloodwebDistribution) == 0x000320, "Wrong size on UBloodwebDistribution");
static_assert(offsetof(UBloodwebDistribution, _bloodwebTunables) == 0x000040, "Member 'UBloodwebDistribution::_bloodwebTunables' has a wrong offset!");

// Class DeadByDaylight.PlayerPerspectiveChangeComponent
// 0x0078 (0x0130 - 0x00B8)
class UPlayerPerspectiveChangeComponent : public UActorComponent
{
public:
	struct FPlayerPerspectiveChangeCameraMovementData _currentCameraTransitionData;                  // 0x00B8(0x0050)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FPlayerPerspectiveChangeTargetData     _targetPerspective;                                // 0x0108(0x0020)(Transient, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          _shouldUpdateFirstPersonMeshAndModelAfterFinalize; // 0x0128(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinalizeTargetPerspective();
	void TransitionToTargetPerspective(const struct FPlayerPerspectiveChangeTargetData& TargetData, float TransitionDuration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerPerspectiveChangeComponent">();
	}
	static class UPlayerPerspectiveChangeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerPerspectiveChangeComponent>();
	}
};
static_assert(alignof(UPlayerPerspectiveChangeComponent) == 0x000008, "Wrong alignment on UPlayerPerspectiveChangeComponent");
static_assert(sizeof(UPlayerPerspectiveChangeComponent) == 0x000130, "Wrong size on UPlayerPerspectiveChangeComponent");
static_assert(offsetof(UPlayerPerspectiveChangeComponent, _currentCameraTransitionData) == 0x0000B8, "Member 'UPlayerPerspectiveChangeComponent::_currentCameraTransitionData' has a wrong offset!");
static_assert(offsetof(UPlayerPerspectiveChangeComponent, _targetPerspective) == 0x000108, "Member 'UPlayerPerspectiveChangeComponent::_targetPerspective' has a wrong offset!");
static_assert(offsetof(UPlayerPerspectiveChangeComponent, _shouldUpdateFirstPersonMeshAndModelAfterFinalize) == 0x000128, "Member 'UPlayerPerspectiveChangeComponent::_shouldUpdateFirstPersonMeshAndModelAfterFinalize' has a wrong offset!");

// Class DeadByDaylight.SpawnElement
// 0x0000 (0x0000 - 0x0000)
class ISpawnElement final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnElement">();
	}
	static class ISpawnElement* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISpawnElement>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ISpawnElement) == 0x000001, "Wrong alignment on ISpawnElement");
static_assert(sizeof(ISpawnElement) == 0x000001, "Wrong size on ISpawnElement");

// Class DeadByDaylight.ConfigurableCollisionComponent
// 0x0070 (0x0340 - 0x02D0)
#pragma pack(push, 0x1)
class alignas(0x10) UConfigurableCollisionComponent : public USceneComponent
{
public:
	struct FCollisionZoneParams                   _collisionParams;                                  // 0x02D0(0x0048)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTag>                   _requiredPresenceTag;                              // 0x0318(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          _spawnOnAuthorityOnly;                             // 0x0328(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_329[0x7];                                      // 0x0329(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UShapeComponent*                        _collisionZone;                                    // 0x0330(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool fromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConfigurableCollisionComponent">();
	}
	static class UConfigurableCollisionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfigurableCollisionComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UConfigurableCollisionComponent) == 0x000010, "Wrong alignment on UConfigurableCollisionComponent");
static_assert(sizeof(UConfigurableCollisionComponent) == 0x000340, "Wrong size on UConfigurableCollisionComponent");
static_assert(offsetof(UConfigurableCollisionComponent, _collisionParams) == 0x0002D0, "Member 'UConfigurableCollisionComponent::_collisionParams' has a wrong offset!");
static_assert(offsetof(UConfigurableCollisionComponent, _requiredPresenceTag) == 0x000318, "Member 'UConfigurableCollisionComponent::_requiredPresenceTag' has a wrong offset!");
static_assert(offsetof(UConfigurableCollisionComponent, _spawnOnAuthorityOnly) == 0x000328, "Member 'UConfigurableCollisionComponent::_spawnOnAuthorityOnly' has a wrong offset!");
static_assert(offsetof(UConfigurableCollisionComponent, _collisionZone) == 0x000330, "Member 'UConfigurableCollisionComponent::_collisionZone' has a wrong offset!");

// Class DeadByDaylight.TransientInteractionDefinition
// 0x0000 (0x0770 - 0x0770)
class UTransientInteractionDefinition : public UInteractionDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TransientInteractionDefinition">();
	}
	static class UTransientInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTransientInteractionDefinition>();
	}
};
static_assert(alignof(UTransientInteractionDefinition) == 0x000010, "Wrong alignment on UTransientInteractionDefinition");
static_assert(sizeof(UTransientInteractionDefinition) == 0x000770, "Wrong size on UTransientInteractionDefinition");

// Class DeadByDaylight.GroundDetectorUtilities
// 0x0000 (0x0030 - 0x0030)
class UGroundDetectorUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class FString GetAudioSurfaceName(class UBaseGroundDetectorComponent* groundDetectorComponent);
	static EPhysicalSurface GetSurfaceType(class UBaseGroundDetectorComponent* groundDetectorComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GroundDetectorUtilities">();
	}
	static class UGroundDetectorUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGroundDetectorUtilities>();
	}
};
static_assert(alignof(UGroundDetectorUtilities) == 0x000008, "Wrong alignment on UGroundDetectorUtilities");
static_assert(sizeof(UGroundDetectorUtilities) == 0x000030, "Wrong size on UGroundDetectorUtilities");

// Class DeadByDaylight.StationarySpotLightComponent
// 0x0000 (0x0530 - 0x0530)
class UStationarySpotLightComponent final : public USpotLightComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StationarySpotLightComponent">();
	}
	static class UStationarySpotLightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStationarySpotLightComponent>();
	}
};
static_assert(alignof(UStationarySpotLightComponent) == 0x000010, "Wrong alignment on UStationarySpotLightComponent");
static_assert(sizeof(UStationarySpotLightComponent) == 0x000530, "Wrong size on UStationarySpotLightComponent");

// Class DeadByDaylight.ArchiveVignettesContainer
// 0x00D8 (0x0108 - 0x0030)
class UArchiveVignettesContainer final : public UObject
{
public:
	uint8                                         Pad_30[0xD8];                                      // 0x0030(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveVignettesContainer">();
	}
	static class UArchiveVignettesContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArchiveVignettesContainer>();
	}
};
static_assert(alignof(UArchiveVignettesContainer) == 0x000008, "Wrong alignment on UArchiveVignettesContainer");
static_assert(sizeof(UArchiveVignettesContainer) == 0x000108, "Wrong size on UArchiveVignettesContainer");

// Class DeadByDaylight.GameObjective_ActorInterfaceList
// 0x0008 (0x02F8 - 0x02F0)
class AGameObjective_ActorInterfaceList : public AGameObjective_ActorList
{
public:
	TSubclassOf<class IInterface>                 _interfaceClass;                                   // 0x02F0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameObjective_ActorInterfaceList">();
	}
	static class AGameObjective_ActorInterfaceList* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameObjective_ActorInterfaceList>();
	}
};
static_assert(alignof(AGameObjective_ActorInterfaceList) == 0x000008, "Wrong alignment on AGameObjective_ActorInterfaceList");
static_assert(sizeof(AGameObjective_ActorInterfaceList) == 0x0002F8, "Wrong size on AGameObjective_ActorInterfaceList");
static_assert(offsetof(AGameObjective_ActorInterfaceList, _interfaceClass) == 0x0002F0, "Member 'AGameObjective_ActorInterfaceList::_interfaceClass' has a wrong offset!");

// Class DeadByDaylight.GeneratorTrapPerk
// 0x0000 (0x04E8 - 0x04E8)
class UGeneratorTrapPerk : public USurvivorTrapPerk
{
public:
	void Authority_OnExitGatesPowered(const struct FGameplayTag& GameEventTag, const struct FGameEventData& GameEventData);
	void Authority_OnGeneratorCompleted(bool isAutoCompleted);
	void Client_OnTrapActivated(const class AGenerator* Generator);
	void Client_OnTrapDestroyed(const class AGenerator* Generator, const ETrapRemovedReason Reason);
	void Cosmetic_TrapActivated(const class AGenerator* Generator);
	void Cosmetic_TrapDestroyed(const class AGenerator* Generator, const ETrapRemovedReason Reason);

	float GetGeneratorTrapDuration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratorTrapPerk">();
	}
	static class UGeneratorTrapPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneratorTrapPerk>();
	}
};
static_assert(alignof(UGeneratorTrapPerk) == 0x000008, "Wrong alignment on UGeneratorTrapPerk");
static_assert(sizeof(UGeneratorTrapPerk) == 0x0004E8, "Wrong size on UGeneratorTrapPerk");

// Class DeadByDaylight.LevelReadyToPlayPlayerComponent
// 0x0070 (0x0128 - 0x00B8)
class ULevelReadyToPlayPlayerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x40];                                      // 0x00B8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLevelReadyToPlayRequirements>  _levelReadyToPlayRequirementsTarget;               // 0x00F8(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<struct FLevelReadyToPlayRequirements>  _levelReadyToPlayRequirementState;                 // 0x0108(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x10];                                     // 0x0118(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_LevelReadyToPlayRequirementsTarget();
	void Server_SetIsReadyToPlay(const struct FFilesInformation& hackInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelReadyToPlayPlayerComponent">();
	}
	static class ULevelReadyToPlayPlayerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelReadyToPlayPlayerComponent>();
	}
};
static_assert(alignof(ULevelReadyToPlayPlayerComponent) == 0x000008, "Wrong alignment on ULevelReadyToPlayPlayerComponent");
static_assert(sizeof(ULevelReadyToPlayPlayerComponent) == 0x000128, "Wrong size on ULevelReadyToPlayPlayerComponent");
static_assert(offsetof(ULevelReadyToPlayPlayerComponent, _levelReadyToPlayRequirementsTarget) == 0x0000F8, "Member 'ULevelReadyToPlayPlayerComponent::_levelReadyToPlayRequirementsTarget' has a wrong offset!");
static_assert(offsetof(ULevelReadyToPlayPlayerComponent, _levelReadyToPlayRequirementState) == 0x000108, "Member 'ULevelReadyToPlayPlayerComponent::_levelReadyToPlayRequirementState' has a wrong offset!");

// Class DeadByDaylight.VaultFastDefintion
// 0x0000 (0x07D0 - 0x07D0)
class UVaultFastDefintion : public UVaultDefinition
{
public:
	bool                                          _isMediumVault;                                    // 0x07C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C9[0x7];                                      // 0x07C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VaultFastDefintion">();
	}
	static class UVaultFastDefintion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVaultFastDefintion>();
	}
};
static_assert(alignof(UVaultFastDefintion) == 0x000010, "Wrong alignment on UVaultFastDefintion");
static_assert(sizeof(UVaultFastDefintion) == 0x0007D0, "Wrong size on UVaultFastDefintion");
static_assert(offsetof(UVaultFastDefintion, _isMediumVault) == 0x0007C8, "Member 'UVaultFastDefintion::_isMediumVault' has a wrong offset!");

// Class DeadByDaylight.DBDBaseHud
// 0x0010 (0x03A0 - 0x0390)
class ADBDBaseHud : public AHUD
{
public:
	class UFont*                                  _debugFont;                                        // 0x0390(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_ShowAnimHud(bool Show);
	void ShowAnimHudBP();

	bool ShouldDrawAnimHud() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBaseHud">();
	}
	static class ADBDBaseHud* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDBaseHud>();
	}
};
static_assert(alignof(ADBDBaseHud) == 0x000008, "Wrong alignment on ADBDBaseHud");
static_assert(sizeof(ADBDBaseHud) == 0x0003A0, "Wrong size on ADBDBaseHud");
static_assert(offsetof(ADBDBaseHud, _debugFont) == 0x000390, "Member 'ADBDBaseHud::_debugFont' has a wrong offset!");

// Class DeadByDaylight.DBDInGameHud
// 0x0028 (0x03C8 - 0x03A0)
class ADBDInGameHud final : public ADBDBaseHud
{
public:
	class UFont*                                  _debugFontObj;                                     // 0x03A0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A8[0x18];                                     // 0x03A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCompetenceDebugger*                    _competenceDebugger;                               // 0x03C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDInGameHud">();
	}
	static class ADBDInGameHud* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDInGameHud>();
	}
};
static_assert(alignof(ADBDInGameHud) == 0x000008, "Wrong alignment on ADBDInGameHud");
static_assert(sizeof(ADBDInGameHud) == 0x0003C8, "Wrong size on ADBDInGameHud");
static_assert(offsetof(ADBDInGameHud, _debugFontObj) == 0x0003A0, "Member 'ADBDInGameHud::_debugFontObj' has a wrong offset!");
static_assert(offsetof(ADBDInGameHud, _competenceDebugger) == 0x0003C0, "Member 'ADBDInGameHud::_competenceDebugger' has a wrong offset!");

// Class DeadByDaylight.DBDPrimaryDataAsset
// 0x0010 (0x0048 - 0x0038)
class UDBDPrimaryDataAsset : public UPrimaryDataAsset
{
public:
	struct FPrimaryAssetType                      AssetType;                                         // 0x0038(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPrimaryDataAsset">();
	}
	static class UDBDPrimaryDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDPrimaryDataAsset>();
	}
};
static_assert(alignof(UDBDPrimaryDataAsset) == 0x000008, "Wrong alignment on UDBDPrimaryDataAsset");
static_assert(sizeof(UDBDPrimaryDataAsset) == 0x000048, "Wrong size on UDBDPrimaryDataAsset");
static_assert(offsetof(UDBDPrimaryDataAsset, AssetType) == 0x000038, "Member 'UDBDPrimaryDataAsset::AssetType' has a wrong offset!");

// Class DeadByDaylight.LightingFactory
// 0x0008 (0x0038 - 0x0030)
class ULightingFactory final : public UObject
{
public:
	class ULightingData*                          _data;                                             // 0x0030(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightingFactory">();
	}
	static class ULightingFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightingFactory>();
	}
};
static_assert(alignof(ULightingFactory) == 0x000008, "Wrong alignment on ULightingFactory");
static_assert(sizeof(ULightingFactory) == 0x000038, "Wrong size on ULightingFactory");
static_assert(offsetof(ULightingFactory, _data) == 0x000030, "Member 'ULightingFactory::_data' has a wrong offset!");

// Class DeadByDaylight.WorldObjectTriggeringActorComponent
// 0x0008 (0x00C0 - 0x00B8)
class UWorldObjectTriggeringActorComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldObjectTriggeringActorComponent">();
	}
	static class UWorldObjectTriggeringActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldObjectTriggeringActorComponent>();
	}
};
static_assert(alignof(UWorldObjectTriggeringActorComponent) == 0x000008, "Wrong alignment on UWorldObjectTriggeringActorComponent");
static_assert(sizeof(UWorldObjectTriggeringActorComponent) == 0x0000C0, "Wrong size on UWorldObjectTriggeringActorComponent");

// Class DeadByDaylight.SlashableActivationSourceCollection
// 0x0040 (0x00F8 - 0x00B8)
class USlashableActivationSourceCollection final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x40];                                      // 0x00B8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void AddSource(class UObject* Source);
	static void ForceActivate(const class UObject* WorldContextObject);
	static void RemoveSource(class UObject* Source);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlashableActivationSourceCollection">();
	}
	static class USlashableActivationSourceCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlashableActivationSourceCollection>();
	}
};
static_assert(alignof(USlashableActivationSourceCollection) == 0x000008, "Wrong alignment on USlashableActivationSourceCollection");
static_assert(sizeof(USlashableActivationSourceCollection) == 0x0000F8, "Wrong size on USlashableActivationSourceCollection");

// Class DeadByDaylight.Gate
// 0x0018 (0x02B8 - 0x02A0)
class AGate : public AActor
{
public:
	TArray<float>                                 InteractionInputs;                                 // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         InteractionOutput;                                 // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gate">();
	}
	static class AGate* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGate>();
	}
};
static_assert(alignof(AGate) == 0x000008, "Wrong alignment on AGate");
static_assert(sizeof(AGate) == 0x0002B8, "Wrong size on AGate");
static_assert(offsetof(AGate, InteractionInputs) == 0x0002A0, "Member 'AGate::InteractionInputs' has a wrong offset!");
static_assert(offsetof(AGate, InteractionOutput) == 0x0002B0, "Member 'AGate::InteractionOutput' has a wrong offset!");

// Class DeadByDaylight.AndGate
// 0x0000 (0x02B8 - 0x02B8)
class AAndGate final : public AGate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AndGate">();
	}
	static class AAndGate* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAndGate>();
	}
};
static_assert(alignof(AAndGate) == 0x000008, "Wrong alignment on AAndGate");
static_assert(sizeof(AAndGate) == 0x0002B8, "Wrong size on AAndGate");

// Class DeadByDaylight.QuestEventEvaluatorBase
// 0x0098 (0x00C8 - 0x0030)
class UQuestEventEvaluatorBase : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _dbdPlayer;                                        // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AController*                            _controller;                                       // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x28];                                      // 0x0058(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	EConditionNeedsType                           _conditionNeedsType;                               // 0x0080(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UEvaluatorCondition>> _evaluatorConditionsClass;                        // 0x0088(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UEvaluatorCondition*>            _evaluatorConditions;                              // 0x0098(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x20];                                      // 0x00A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameEvent(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestEventEvaluatorBase">();
	}
	static class UQuestEventEvaluatorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestEventEvaluatorBase>();
	}
};
static_assert(alignof(UQuestEventEvaluatorBase) == 0x000008, "Wrong alignment on UQuestEventEvaluatorBase");
static_assert(sizeof(UQuestEventEvaluatorBase) == 0x0000C8, "Wrong size on UQuestEventEvaluatorBase");
static_assert(offsetof(UQuestEventEvaluatorBase, _dbdPlayer) == 0x000048, "Member 'UQuestEventEvaluatorBase::_dbdPlayer' has a wrong offset!");
static_assert(offsetof(UQuestEventEvaluatorBase, _controller) == 0x000050, "Member 'UQuestEventEvaluatorBase::_controller' has a wrong offset!");
static_assert(offsetof(UQuestEventEvaluatorBase, _conditionNeedsType) == 0x000080, "Member 'UQuestEventEvaluatorBase::_conditionNeedsType' has a wrong offset!");
static_assert(offsetof(UQuestEventEvaluatorBase, _evaluatorConditionsClass) == 0x000088, "Member 'UQuestEventEvaluatorBase::_evaluatorConditionsClass' has a wrong offset!");
static_assert(offsetof(UQuestEventEvaluatorBase, _evaluatorConditions) == 0x000098, "Member 'UQuestEventEvaluatorBase::_evaluatorConditions' has a wrong offset!");

// Class DeadByDaylight.StandDisplayable
// 0x0000 (0x0000 - 0x0000)
class IStandDisplayable final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StandDisplayable">();
	}
	static class IStandDisplayable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStandDisplayable>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IStandDisplayable) == 0x000001, "Wrong alignment on IStandDisplayable");
static_assert(sizeof(IStandDisplayable) == 0x000001, "Wrong size on IStandDisplayable");

// Class DeadByDaylight.EvaluatorCondition
// 0x0018 (0x0048 - 0x0030)
class UEvaluatorCondition : public UObject
{
public:
	EConditionSubject                             _conditionSubject;                                 // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x17];                                      // 0x0031(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EvaluatorCondition">();
	}
	static class UEvaluatorCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEvaluatorCondition>();
	}
};
static_assert(alignof(UEvaluatorCondition) == 0x000008, "Wrong alignment on UEvaluatorCondition");
static_assert(sizeof(UEvaluatorCondition) == 0x000048, "Wrong size on UEvaluatorCondition");
static_assert(offsetof(UEvaluatorCondition, _conditionSubject) == 0x000030, "Member 'UEvaluatorCondition::_conditionSubject' has a wrong offset!");

// Class DeadByDaylight.DBDBaseInputHandler
// 0x00A8 (0x00D8 - 0x0030)
class UDBDBaseInputHandler final : public UObject
{
public:
	class APawn*                                  _pawn;                                             // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpringArmComponent*                    _cameraBoom;                                       // 0x0038(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x98];                                      // 0x0040(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBaseInputHandler">();
	}
	static class UDBDBaseInputHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDBaseInputHandler>();
	}
};
static_assert(alignof(UDBDBaseInputHandler) == 0x000008, "Wrong alignment on UDBDBaseInputHandler");
static_assert(sizeof(UDBDBaseInputHandler) == 0x0000D8, "Wrong size on UDBDBaseInputHandler");
static_assert(offsetof(UDBDBaseInputHandler, _pawn) == 0x000030, "Member 'UDBDBaseInputHandler::_pawn' has a wrong offset!");
static_assert(offsetof(UDBDBaseInputHandler, _cameraBoom) == 0x000038, "Member 'UDBDBaseInputHandler::_cameraBoom' has a wrong offset!");

// Class DeadByDaylight.LobbyDialogueSubsystem
// 0x0058 (0x0090 - 0x0038)
class ULobbyDialogueSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x58];                                      // 0x0038(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void CountGuestLobbyMembersWithAudioSwitch(EAudioCustomizationCategory switchCategory, const TArray<class FString>& audioSwitches, int32* numMatching, int32* numNotMatching);
	static TArray<class ADBDMenuPlayer*> GetGuestLobbyMembers();
	static bool HasCharacterPlayedDialogueForThisLobby(const class FString& CharacterName, int32 dialogueId);
	static bool IsLobbyFullForRole(EPlayerRole Role);
	static void NotifyCharacterPlayedDialogueForThisLobby(const class FString& CharacterName, int32 dialogueId);
	static void NotifyDialogueInterrupted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyDialogueSubsystem">();
	}
	static class ULobbyDialogueSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyDialogueSubsystem>();
	}
};
static_assert(alignof(ULobbyDialogueSubsystem) == 0x000008, "Wrong alignment on ULobbyDialogueSubsystem");
static_assert(sizeof(ULobbyDialogueSubsystem) == 0x000090, "Wrong size on ULobbyDialogueSubsystem");

// Class DeadByDaylight.SpecialBehaviourIterativeWeightAdjustmentStrategy
// 0x0000 (0x0030 - 0x0030)
class USpecialBehaviourIterativeWeightAdjustmentStrategy : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecialBehaviourIterativeWeightAdjustmentStrategy">();
	}
	static class USpecialBehaviourIterativeWeightAdjustmentStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpecialBehaviourIterativeWeightAdjustmentStrategy>();
	}
};
static_assert(alignof(USpecialBehaviourIterativeWeightAdjustmentStrategy) == 0x000008, "Wrong alignment on USpecialBehaviourIterativeWeightAdjustmentStrategy");
static_assert(sizeof(USpecialBehaviourIterativeWeightAdjustmentStrategy) == 0x000030, "Wrong size on USpecialBehaviourIterativeWeightAdjustmentStrategy");

// Class DeadByDaylight.AbstractAnalyticsManager
// 0x0000 (0x0038 - 0x0038)
class UAbstractAnalyticsManager : public UGameInstanceSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbstractAnalyticsManager">();
	}
	static class UAbstractAnalyticsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbstractAnalyticsManager>();
	}
};
static_assert(alignof(UAbstractAnalyticsManager) == 0x000008, "Wrong alignment on UAbstractAnalyticsManager");
static_assert(sizeof(UAbstractAnalyticsManager) == 0x000038, "Wrong size on UAbstractAnalyticsManager");

// Class DeadByDaylight.ObjectPlacementUpdateStrategy
// 0x0038 (0x0068 - 0x0030)
class UObjectPlacementUpdateStrategy : public UObject
{
public:
	uint8                                         Pad_30[0x38];                                      // 0x0030(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectPlacementUpdateStrategy">();
	}
	static class UObjectPlacementUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectPlacementUpdateStrategy>();
	}
};
static_assert(alignof(UObjectPlacementUpdateStrategy) == 0x000008, "Wrong alignment on UObjectPlacementUpdateStrategy");
static_assert(sizeof(UObjectPlacementUpdateStrategy) == 0x000068, "Wrong size on UObjectPlacementUpdateStrategy");

// Class DeadByDaylight.ArmIKSensorComponent
// 0x0080 (0x0138 - 0x00B8)
class UArmIKSensorComponent : public UActorComponent
{
public:
	class USkeletalMeshComponent*                 _mesh;                                             // 0x00B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EArm, struct FArmIKSensorDatum>          _arms;                                             // 0x00C0(0x0050)(Edit, EditFixedSize, Protected, NativeAccessSpecifierProtected)
	float                                         _capsuleRadius;                                    // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _capsuleHalfHeight;                                // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _traceLength;                                      // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraComponent*                       _owningCamera;                                     // 0x0120(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x10];                                     // 0x0128(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArmIKSensorComponent">();
	}
	static class UArmIKSensorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArmIKSensorComponent>();
	}
};
static_assert(alignof(UArmIKSensorComponent) == 0x000008, "Wrong alignment on UArmIKSensorComponent");
static_assert(sizeof(UArmIKSensorComponent) == 0x000138, "Wrong size on UArmIKSensorComponent");
static_assert(offsetof(UArmIKSensorComponent, _mesh) == 0x0000B8, "Member 'UArmIKSensorComponent::_mesh' has a wrong offset!");
static_assert(offsetof(UArmIKSensorComponent, _arms) == 0x0000C0, "Member 'UArmIKSensorComponent::_arms' has a wrong offset!");
static_assert(offsetof(UArmIKSensorComponent, _capsuleRadius) == 0x000110, "Member 'UArmIKSensorComponent::_capsuleRadius' has a wrong offset!");
static_assert(offsetof(UArmIKSensorComponent, _capsuleHalfHeight) == 0x000114, "Member 'UArmIKSensorComponent::_capsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(UArmIKSensorComponent, _traceLength) == 0x000118, "Member 'UArmIKSensorComponent::_traceLength' has a wrong offset!");
static_assert(offsetof(UArmIKSensorComponent, _owningCamera) == 0x000120, "Member 'UArmIKSensorComponent::_owningCamera' has a wrong offset!");

// Class DeadByDaylight.DBDRankDesignTunables
// 0x0030 (0x0060 - 0x0030)
class UDBDRankDesignTunables final : public UObject
{
public:
	class UCurveFloat*                            UnbrokenTimeAlivePointsCurve;                      // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            EvaderStealthPointsByDistanceWhileKillerNotChasingCurve; // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            EvaderStealthPointsByDistanceWhileKillerIsChasingCurve; // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            EvaderChasePointsByDurationCurve;                  // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            EvaderZAxisDistanceScalingCurve;                   // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ChaserChasePointsByDurationCurve;                  // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDRankDesignTunables">();
	}
	static class UDBDRankDesignTunables* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDRankDesignTunables>();
	}
};
static_assert(alignof(UDBDRankDesignTunables) == 0x000008, "Wrong alignment on UDBDRankDesignTunables");
static_assert(sizeof(UDBDRankDesignTunables) == 0x000060, "Wrong size on UDBDRankDesignTunables");
static_assert(offsetof(UDBDRankDesignTunables, UnbrokenTimeAlivePointsCurve) == 0x000030, "Member 'UDBDRankDesignTunables::UnbrokenTimeAlivePointsCurve' has a wrong offset!");
static_assert(offsetof(UDBDRankDesignTunables, EvaderStealthPointsByDistanceWhileKillerNotChasingCurve) == 0x000038, "Member 'UDBDRankDesignTunables::EvaderStealthPointsByDistanceWhileKillerNotChasingCurve' has a wrong offset!");
static_assert(offsetof(UDBDRankDesignTunables, EvaderStealthPointsByDistanceWhileKillerIsChasingCurve) == 0x000040, "Member 'UDBDRankDesignTunables::EvaderStealthPointsByDistanceWhileKillerIsChasingCurve' has a wrong offset!");
static_assert(offsetof(UDBDRankDesignTunables, EvaderChasePointsByDurationCurve) == 0x000048, "Member 'UDBDRankDesignTunables::EvaderChasePointsByDurationCurve' has a wrong offset!");
static_assert(offsetof(UDBDRankDesignTunables, EvaderZAxisDistanceScalingCurve) == 0x000050, "Member 'UDBDRankDesignTunables::EvaderZAxisDistanceScalingCurve' has a wrong offset!");
static_assert(offsetof(UDBDRankDesignTunables, ChaserChasePointsByDurationCurve) == 0x000058, "Member 'UDBDRankDesignTunables::ChaserChasePointsByDurationCurve' has a wrong offset!");

// Class DeadByDaylight.CharacterDataSubsystem
// 0x0018 (0x0050 - 0x0038)
class UCharacterDataSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterDataSubsystem">();
	}
	static class UCharacterDataSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterDataSubsystem>();
	}
};
static_assert(alignof(UCharacterDataSubsystem) == 0x000008, "Wrong alignment on UCharacterDataSubsystem");
static_assert(sizeof(UCharacterDataSubsystem) == 0x000050, "Wrong size on UCharacterDataSubsystem");

// Class DeadByDaylight.DBDMenuPlayer
// 0x0130 (0x08A0 - 0x0770)
class ADBDMenuPlayer : public ADBDBasePlayer
{
public:
	uint8                                         Pad_770[0x28];                                     // 0x0770(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          RoleSelected;                                      // 0x0798(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOnline;                                          // 0x0799(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79A[0x6];                                      // 0x079A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnItemEquipped;                                    // 0x07A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B0[0x18];                                     // 0x07B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   MoriPreviewAnimClass;                              // 0x07C8(0x0038)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialInterface>      DarkMaterial;                                      // 0x0800(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EItemHandPosition                             _handPosition;                                     // 0x0838(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_839[0x7];                                      // 0x0839(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDSkeletalMeshComponentBudgeted*      ItemMesh;                                          // 0x0840(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialHelper*                        MaterialHelper;                                    // 0x0848(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCustomizedSkeletalMesh*                _customizedSkeletalMeshComponent;                  // 0x0850(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _equippedItemName;                                 // 0x0858(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_864[0x28];                                     // 0x0864(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _blockRotationDuringSpawnAnimationDuration;        // 0x088C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isLocalPlayerCharacter;                           // 0x0890(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isReady;                                          // 0x0891(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_892[0xE];                                      // 0x0892(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginCreateSequence();
	void BeginDestroySequence_Internal();
	void BlockCharacterRotation(bool shouldBlock);
	class UCharmSpawnerComponent* GetCharmSpawnerComponent();
	bool HasSameCharacterInLobby();
	bool IsInMenuPlayer();
	void OnAllPlayersReadyInOnlineLobby();
	void OnCustomizationTransactionCompleted(ECustomizationCategory category);
	void OnFinishSpawnOnStand();
	void OnGameplayTagAnimNotify(const struct FGameplayTag& InformationTag);
	void OnGuestPlayerDespawned(class ADBDMenuPlayer* Player);
	void OnGuestPlayerReadyChanged(class ADBDMenuPlayer* Player, bool IsReady);
	void OnGuestPlayerSpawned(class ADBDMenuPlayer* Player);
	void OnIsReadyChanged(bool IsReady);
	void OnLocalPlayerReadyChanged(bool IsReady);
	void OnLocalPlayerSpawned();
	void OnPlayerMaxPrestige();
	void RestartInSequence_Internal();
	void SetIsMuted(bool isMuted);
	void WrappedOnDestroyed(class AActor* DestroyedActor);

	float GetBlockRotationAfterSpawningTime() const;
	EGameFlowStep GetCurrentMenu() const;
	EItemHandPosition GetHandPosition() const;
	bool GetIsLocalPlayerCharacter() const;
	bool GetIsReady() const;
	bool ShouldApplyPositionOffset() const;
	bool ShouldShowSpawnAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDMenuPlayer">();
	}
	static class ADBDMenuPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDMenuPlayer>();
	}
};
static_assert(alignof(ADBDMenuPlayer) == 0x000010, "Wrong alignment on ADBDMenuPlayer");
static_assert(sizeof(ADBDMenuPlayer) == 0x0008A0, "Wrong size on ADBDMenuPlayer");
static_assert(offsetof(ADBDMenuPlayer, RoleSelected) == 0x000798, "Member 'ADBDMenuPlayer::RoleSelected' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, IsOnline) == 0x000799, "Member 'ADBDMenuPlayer::IsOnline' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, OnItemEquipped) == 0x0007A0, "Member 'ADBDMenuPlayer::OnItemEquipped' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, MoriPreviewAnimClass) == 0x0007C8, "Member 'ADBDMenuPlayer::MoriPreviewAnimClass' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, DarkMaterial) == 0x000800, "Member 'ADBDMenuPlayer::DarkMaterial' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, _handPosition) == 0x000838, "Member 'ADBDMenuPlayer::_handPosition' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, ItemMesh) == 0x000840, "Member 'ADBDMenuPlayer::ItemMesh' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, MaterialHelper) == 0x000848, "Member 'ADBDMenuPlayer::MaterialHelper' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, _customizedSkeletalMeshComponent) == 0x000850, "Member 'ADBDMenuPlayer::_customizedSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, _equippedItemName) == 0x000858, "Member 'ADBDMenuPlayer::_equippedItemName' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, _blockRotationDuringSpawnAnimationDuration) == 0x00088C, "Member 'ADBDMenuPlayer::_blockRotationDuringSpawnAnimationDuration' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, _isLocalPlayerCharacter) == 0x000890, "Member 'ADBDMenuPlayer::_isLocalPlayerCharacter' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, _isReady) == 0x000891, "Member 'ADBDMenuPlayer::_isReady' has a wrong offset!");

// Class DeadByDaylight.DBDAIUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDAIUtilities : public UBlueprintFunctionLibrary
{
public:
	static bool DrawDebugAINavigation();
	static bool DrawDebugAINavigationFilter();
	static bool DrawDebugAIPerception();
	static class UNavigationPath* FindPathWithAgentRadiusToActorSynchronously(class UObject* WorldContextObject, const struct FVector& pathStart, class AActor* GoalActor, float AgentRadius, float tetherDistance, class AActor* pathfindingContext, TSubclassOf<class UNavigationQueryFilter> FilterClass);
	static void SetCanEverAffectNavigation(class UActorComponent* Component, bool affectNavigation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAIUtilities">();
	}
	static class UDBDAIUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAIUtilities>();
	}
};
static_assert(alignof(UDBDAIUtilities) == 0x000008, "Wrong alignment on UDBDAIUtilities");
static_assert(sizeof(UDBDAIUtilities) == 0x000030, "Wrong size on UDBDAIUtilities");

// Class DeadByDaylight.GameplayModifierCondition
// 0x0000 (0x00D0 - 0x00D0)
class UGameplayModifierCondition : public UBaseModifierCondition
{
public:
	void OnOwningGameplayModifierSet();
	void SetOwningGameplayModifier(class UGameplayModifierContainer* OwningGameplayModifier);

	class UGameplayModifierContainer* GetOwningGameplayModifier() const;
	class ADBDPlayer* GetOwningPlayer() const;
	bool IsApplicable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayModifierCondition">();
	}
	static class UGameplayModifierCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayModifierCondition>();
	}
};
static_assert(alignof(UGameplayModifierCondition) == 0x000008, "Wrong alignment on UGameplayModifierCondition");
static_assert(sizeof(UGameplayModifierCondition) == 0x0000D0, "Wrong size on UGameplayModifierCondition");

// Class DeadByDaylight.AlwaysVisiblePerkIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UAlwaysVisiblePerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AlwaysVisiblePerkIconStrategy">();
	}
	static class UAlwaysVisiblePerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAlwaysVisiblePerkIconStrategy>();
	}
};
static_assert(alignof(UAlwaysVisiblePerkIconStrategy) == 0x000008, "Wrong alignment on UAlwaysVisiblePerkIconStrategy");
static_assert(sizeof(UAlwaysVisiblePerkIconStrategy) == 0x000038, "Wrong size on UAlwaysVisiblePerkIconStrategy");

// Class DeadByDaylight.NavArea_Drone
// 0x0000 (0x0050 - 0x0050)
class UNavArea_Drone final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_Drone">();
	}
	static class UNavArea_Drone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_Drone>();
	}
};
static_assert(alignof(UNavArea_Drone) == 0x000008, "Wrong alignment on UNavArea_Drone");
static_assert(sizeof(UNavArea_Drone) == 0x000050, "Wrong size on UNavArea_Drone");

// Class DeadByDaylight.SeancePerformerComponent
// 0x0018 (0x00D0 - 0x00B8)
class USeancePerformerComponent final : public UActorComponent
{
public:
	TArray<class USeancePerk*>                    _ownedSeancePerks;                                 // 0x00B8(0x0010)(ExportObject, Net, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	float                                         _ritualInteractionMultiplierAdditive;              // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnInteractionCompleted();
	void Cosmetic_OnStartedInteracting();
	void Cosmetic_OnStoppedInteracting(bool interrupted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeancePerformerComponent">();
	}
	static class USeancePerformerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeancePerformerComponent>();
	}
};
static_assert(alignof(USeancePerformerComponent) == 0x000008, "Wrong alignment on USeancePerformerComponent");
static_assert(sizeof(USeancePerformerComponent) == 0x0000D0, "Wrong size on USeancePerformerComponent");
static_assert(offsetof(USeancePerformerComponent, _ownedSeancePerks) == 0x0000B8, "Member 'USeancePerformerComponent::_ownedSeancePerks' has a wrong offset!");
static_assert(offsetof(USeancePerformerComponent, _ritualInteractionMultiplierAdditive) == 0x0000C8, "Member 'USeancePerformerComponent::_ritualInteractionMultiplierAdditive' has a wrong offset!");

// Class DeadByDaylight.DBDGameState
// 0x0770 (0x0A90 - 0x0320)
class ADBDGameState : public AGameState
{
public:
	uint8                                         Pad_320[0x88];                                     // 0x0320(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnEscapeDoorActivated;                             // 0x03A8(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B8[0xA8];                                     // 0x03B8(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	EIntroState                                   IntroState;                                        // 0x0460(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_461[0x7];                                      // 0x0461(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(float killerIntroCompletePercentChanged)> OnKillerIntroCompletePercentChanged; // 0x0468(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLightingGenerated;                               // 0x0478(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_488[0x30];                                     // 0x0488(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class USpecialEventGameplaySpawnerComponent*  _specialEventGameplaySpawnerComponent;             // 0x04B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpecialBehaviourGameplaySpawnerComponent* _specialBehaviourGameplaySpawnerComponent;      // 0x04C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              AuthorityOnAllPlayerLoaded;                        // 0x04C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSlasherSet;                                      // 0x04D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E8[0x18];                                     // 0x04E8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ASurvivor* newObsession, class ASurvivor* previousObsession)> OnObsessionChanged; // 0x0500(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         SecondsLeftInLobby;                                // 0x0510(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_514[0x4C];                                     // 0x0514(0x004C)(Fixing Size After Last Property [ Dumper-7 ])
	class AKiller*                                Slasher;                                           // 0x0560(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URenderingFeaturesSequencer*            _renderingSequencer;                               // 0x0568(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_570[0x48];                                     // 0x0570(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _survivorHookedInBasementCount;                    // 0x05B8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5BC[0x8];                                      // 0x05BC(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EServerUseNetAsyncLoading                     _useNetAsyncLoading;                               // 0x05C4(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _gameLevelLoadingStarted;                          // 0x05C5(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C6[0x2];                                      // 0x05C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBuiltLevelData                        _builtLevelData;                                   // 0x05C8(0x00B8)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	struct FOfferingData                          _levelOfferings;                                   // 0x0680(0x0018)(Net, Transient, NativeAccessSpecifierPrivate)
	class AClipManager*                           _clipManager;                                      // 0x0698(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFadeManager*                           _fadeManager;                                      // 0x06A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  _sessionId;                                        // 0x06A8(0x0010)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  _lobbyId;                                          // 0x06B8(0x0010)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _escapeDoorActivated;                              // 0x06C8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _escapeDoorOpened;                                 // 0x06C9(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isHatchOpen;                                      // 0x06CA(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _levelReadyToPlay;                                 // 0x06CB(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _playerDistributionReady;                          // 0x06CC(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _usingWeakenedMechanic;                            // 0x06CD(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6CE[0x2];                                      // 0x06CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _survivorLeft;                                     // 0x06D0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6D4[0x4];                                      // 0x06D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AMeatHook*>                      _meatHooks;                                        // 0x06D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ASearchable*>                    _searchables;                                      // 0x06E8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AGenerator*>                     _generators;                                       // 0x06F8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AEscapeDoor*>                    _escapeDoors;                                      // 0x0708(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AHatch*>                         _hatches;                                          // 0x0718(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AInteractable*>                  _specialGenerators;                                // 0x0728(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	bool                                          _isInitializedSpecialGenerators;                   // 0x0738(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_739[0x7];                                      // 0x0739(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AReverseBearTrapRemover*>        _reverseBearTrapRemovers;                          // 0x0740(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ABaseTrap*>                      _baseTraps;                                        // 0x0750(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class APallet*>                        _pallets;                                          // 0x0760(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AWindow*>                        _windows;                                          // 0x0770(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ALocker*>                        _lockers;                                          // 0x0780(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ABreakableBase*>                 _breakableWalls;                                   // 0x0790(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ATotem*>                         _totems;                                           // 0x07A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FBoxSphereBounds                       _mapBoxSphereBounds;                               // 0x07B0(0x0038)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FBoxSphereBounds                       _basementBoxSphereBounds;                          // 0x07E8(0x0038)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_820[0x1C];                                     // 0x0820(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _camperEscapedThroughHatch;                        // 0x083C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ASurvivor*                              _obsessionTarget;                                  // 0x0840(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _cachedObsessionEscaped;                           // 0x0848(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_849[0x7];                                      // 0x0849(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int8                                          _numberOfSurvivorsKilledOrSacrificed;              // 0x0850(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_851[0x7];                                      // 0x0851(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AInteractable*>                  _traps;                                            // 0x0858(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UDBDDangerPredictionComponent*>  _dangerPredictionObjects;                          // 0x0868(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_878[0x8];                                      // 0x0878(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGamePresetData                        _gamePresetData;                                   // 0x0880(0x0090)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	bool                                          _gameLevelLoaded;                                  // 0x0910(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _gameLevelCreated;                                 // 0x0911(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _gameLevelEnded;                                   // 0x0912(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _gameTimedOut;                                     // 0x0913(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEndGameReason                                _gameEndedReason;                                  // 0x0914(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isLoadoutFrozen;                                  // 0x0915(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_916[0x2];                                      // 0x0916(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndGameStateComponent*                 _endGameState;                                     // 0x0918(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UScourgeHookManagerComponent*           _scourgeHookManager;                               // 0x0920(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UActorPairQueryEvaluatorComponent*      _actorPairQueryEvaluatorComponent;                 // 0x0928(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULoudNoiseEventSystem*                  _loudNoiseEventSystem;                             // 0x0930(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHudStateComponent*                     _hudStateComponent;                                // 0x0938(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBackendGameplayTunablesComponent*      _backendGameplayTunablesComponent;                 // 0x0940(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_948[0x8];                                      // 0x0948(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterCollection*                   _characterCollection;                              // 0x0950(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCollectableCollection*                 _collectableCollection;                            // 0x0958(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UServerTimeProviderComponent*           _serverTimeProvider;                               // 0x0960(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInGameAssetPreloaderComponent*         _inGameAssetPreloaderComponent;                    // 0x0968(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOnScreenDebugComponent*                _onScreenDebugComponent;                           // 0x0970(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_978[0x28];                                     // 0x0978(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              _matchStartTime;                                   // 0x09A0(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isServerDedicated;                                // 0x09A8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9A9[0x3];                                      // 0x09A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _maxSurvivorCount;                                 // 0x09AC(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 _serverBuildVersion;                               // 0x09B0(0x0010)(Net, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 _serverContentVersion;                             // 0x09C0(0x0010)(Net, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 _serverSessionId;                                  // 0x09D0(0x0010)(Net, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 _serverRegion;                                     // 0x09E0(0x0010)(Net, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 _serverMatchId;                                    // 0x09F0(0x0010)(Net, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _introDuration;                                    // 0x0A00(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _leaveSpectateRequested;                           // 0x0A04(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A05[0x3];                                      // 0x0A05(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEventTrackerObjectiveLevelEntry> _eventTrackerObjectiveLevels;                    // 0x0A08(0x0010)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	int32                                         _hatchVisibleSurvivorThreshold;                    // 0x0A18(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isForPreview;                                     // 0x0A1C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1D[0x73];                                     // 0x0A1D(0x0073)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDangerPredictionObject(class UDBDDangerPredictionComponent* toAdd);
	void AddTrap(class AInteractable* toAdd);
	void Authority_DeactivateAI();
	void Authority_EnableObsession();
	void Authority_EscapeThroughHatch();
	void Authority_EvaluateObsessionTarget(class ADBDPlayer* potentialTarget);
	void Authority_OnPlayerGameStateChangedAddIfKilled(class ADBDPlayerState* PlayerState, EGameState GameState);
	void Authority_SetAllPlayerLoaded();
	void Authority_SetBuiltLevelData(const struct FBuiltLevelData& BuiltLevelData);
	void Authority_SetEscapeDoorOpened(bool OPENED);
	void Authority_SetGameLevelCreated();
	void Authority_SetGameLevelEnded(EEndGameReason endGameReason);
	void Authority_SetGameLevelLoaded();
	void Authority_SetGameSelectedOffering(const TArray<struct FSelectedOffering>& offerings);
	void Authority_SetGameStarted();
	void Authority_SetLevelReadyToPlay();
	void Authority_SetObsessionTarget(class ASurvivor* obsessionTarget);
	void Authority_SetSurvivorLeft(int32 survivorRemaining);
	void Authority_SignalEscapeDoorActivated(bool newEscapeDoorActivated);
	void Authority_UnsetLevelReadyToPlay();
	void Authority_UpdateHatchState();
	void BroadcastOnSetBuildLevelData();
	void CallOnIntroComplete(TDelegate<void()> Callback);
	void CallOnLevelReadyToPlay(TDelegate<void()> Callback);
	void CallOnSlasherSet(TDelegate<void(class AKiller* Slasher)> Callback);
	const TArray<class UDBDDangerPredictionComponent*> GetDangerPredictionObjects(const bool isObjectDynamic);
	void IntroCompleted();
	bool IsObsessionTargetAlive();
	bool IsObsessionTargetAliveInLevel();
	void Multicast_BroadcastOnLevelLoadingTimeOutClientEvent();
	void Multicast_FireLoudNoiseNotification(class AActor* loudNoiseInstigator, const struct FVector& Location, bool shouldTrack, float audibleRange, class ADBDPlayer* instigatingPlayer, bool isQuickAction, bool isDeceivingNoise);
	void Multicast_OnGameStarted();
	void Multicast_SendEnsureToClients(const class FString& Ensure);
	void Multicast_SendHVSPlusState(bool Enabled);
	void Multicast_SetBuiltLevelData(const struct FBuiltLevelData& BuiltLevelData);
	void Multicast_SetGameEnded(bool hasServerLeftGame);
	void Multicast_SetGameLevelEnded(EEndGameReason endGameReason);
	void Multicast_SetGameLevelLoaded(bool gameLevelLoaded);
	void Multicast_SetLostServerConnection(bool hasLostServerConnection);
	void Multicast_SetServerLeftGame(bool hasServerLeftGame);
	void Multicast_UpdateCharacterFromGamePreset(class ADBDPlayerState_Menu* playerState_Menu, const struct FGamePresetData& GamePresetData);
	void OnRep_BuildLevelData();
	void OnRep_EscapeDoorActivated(bool OldValue);
	void OnRep_GameLevelLoadingStarted(bool OldValue);
	void OnRep_GamePresetData();
	void OnRep_LobbyId();
	void OnRep_NumberOfSurvivorsKilledOrSacrificed();
	void OnRep_ObsessionTarget(class ASurvivor* previousObsessionTarget);
	void OnRep_OnGameLevelCreated();
	void OnRep_OnLevelReadyToPlay();
	void OnRep_SecondsLeftInLobby(const int32 OldValue);
	void OnRep_SessionId();
	void OnRep_SurvivorLeft(int32 OldValue);
	void OnRep_UseNetAsyncLoading();
	void RemoveDangerPredictionObject(class UDBDDangerPredictionComponent* toRemove);
	void RemoveTrap(class AInteractable* toRemove);
	void ResetGameLevelStatus();
	void Server_UpdateGameRole();
	void SetDisplayMapName(bool Display);
	void SetGameLevelEnded(EEndGameReason endGameReason);
	void SetKillerIntroCompletedNormalized(float completedAmount);
	void SetPlayersReadyToStart(bool playersReadyToStart);
	void SortOfferings();
	void UnregisterFromIntroCompleteAndLevelReadyToPlay(const class UObject* inObject);

	const TArray<class UDBDDangerPredictionComponent*> GetAllDangerPredictionObjects() const;
	class UCharacterCollection* GetCharacterCollection() const;
	class UCollectableCollection* GetCollectableCollection() const;
	class UEndGameStateComponent* GetEndGameStateComponent() const;
	bool GetGameLevelLoaded() const;
	bool GetGameLevelLoadingStarted() const;
	const TArray<class ABaseTrap*> GetInGameBaseTraps() const;
	const TArray<class AEscapeDoor*> GetInGameEscapeDoors() const;
	const TArray<class AGenerator*> GetInGameGenerators() const;
	const TArray<class AHatch*> GetInGameHatches() const;
	const TArray<class AMeatHook*> GetInGameMeatHooks() const;
	const TArray<class APallet*> GetInGamePallets() const;
	const TArray<class AReverseBearTrapRemover*> GetInGameReverseBearTrapRemovers() const;
	const TArray<class ASearchable*> GetInGameSearchables() const;
	const TArray<class AInteractable*> GetInGameSpecialGenerators() const;
	const TArray<class AWindow*> GetInGameWindows() const;
	bool GetIsGameEnded() const;
	class AKiller* GetKiller() const;
	float GetKillerIntroCompletedNormalized() const;
	const struct FBuiltLevelData GetLevelData() const;
	TSoftObjectPtr<class UAkAudioBank> GetLevelThemeAudioSoundBankAssetPtr() const;
	class APawn* GetLocalPlayerBasePawn() const;
	class ADBDPlayer* GetLocalPlayerPawn() const;
	class FName GetMapThemeName() const;
	int32 GetNumberOfActiveSurvivors() const;
	int32 GetNumberOfOtherActiveSurvivors(class ADBDPlayer* exception) const;
	class ASurvivor* GetObsessionTarget() const;
	void GetPlayerRoleCounts(int32* survivorCount, int32* killerCount, int32* spectatorCount) const;
	bool GetPlayersReadyToStart() const;
	class ADBDPlayerState* GetPlayerStateByIDString(const class FString& ID, bool IsReplacementBot) const;
	class ADBDPlayerState* GetPlayerStateByMirrorsID(const class FString& ID) const;
	bool GetSelectedOffering(int32 Index_0, struct FSelectedOffering* SelectedOffering) const;
	const TArray<struct FSelectedOffering> GetSelectedOfferings() const;
	class USpecialEventGameplaySpawnerComponent* GetSpecialEventGameplaySpawnerComponent() const;
	int32 GetSurvivorLeft() const;
	const TArray<class ATotem*> GetTotems() const;
	const TArray<class AInteractable*> GetTraps() const;
	bool IsEscapeDoorActivated() const;
	bool IsEscapeDoorOpen() const;
	bool IsHatchVisible() const;
	bool IsIntroCompleted() const;
	bool IsLevelReadyToPlay() const;
	bool IsLevelSetupDone() const;
	bool IsLightingGenerated() const;
	bool IsOfferingReceived() const;
	bool IsOnePlayerLeft() const;
	bool IsPlayerDistributionReady() const;
	void OnRep_HatchOpened() const;
	void UpdateInGamePallets() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGameState">();
	}
	static class ADBDGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDGameState>();
	}
};
static_assert(alignof(ADBDGameState) == 0x000008, "Wrong alignment on ADBDGameState");
static_assert(sizeof(ADBDGameState) == 0x000A90, "Wrong size on ADBDGameState");
static_assert(offsetof(ADBDGameState, OnEscapeDoorActivated) == 0x0003A8, "Member 'ADBDGameState::OnEscapeDoorActivated' has a wrong offset!");
static_assert(offsetof(ADBDGameState, IntroState) == 0x000460, "Member 'ADBDGameState::IntroState' has a wrong offset!");
static_assert(offsetof(ADBDGameState, OnKillerIntroCompletePercentChanged) == 0x000468, "Member 'ADBDGameState::OnKillerIntroCompletePercentChanged' has a wrong offset!");
static_assert(offsetof(ADBDGameState, OnLightingGenerated) == 0x000478, "Member 'ADBDGameState::OnLightingGenerated' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _specialEventGameplaySpawnerComponent) == 0x0004B8, "Member 'ADBDGameState::_specialEventGameplaySpawnerComponent' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _specialBehaviourGameplaySpawnerComponent) == 0x0004C0, "Member 'ADBDGameState::_specialBehaviourGameplaySpawnerComponent' has a wrong offset!");
static_assert(offsetof(ADBDGameState, AuthorityOnAllPlayerLoaded) == 0x0004C8, "Member 'ADBDGameState::AuthorityOnAllPlayerLoaded' has a wrong offset!");
static_assert(offsetof(ADBDGameState, OnSlasherSet) == 0x0004D8, "Member 'ADBDGameState::OnSlasherSet' has a wrong offset!");
static_assert(offsetof(ADBDGameState, OnObsessionChanged) == 0x000500, "Member 'ADBDGameState::OnObsessionChanged' has a wrong offset!");
static_assert(offsetof(ADBDGameState, SecondsLeftInLobby) == 0x000510, "Member 'ADBDGameState::SecondsLeftInLobby' has a wrong offset!");
static_assert(offsetof(ADBDGameState, Slasher) == 0x000560, "Member 'ADBDGameState::Slasher' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _renderingSequencer) == 0x000568, "Member 'ADBDGameState::_renderingSequencer' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _survivorHookedInBasementCount) == 0x0005B8, "Member 'ADBDGameState::_survivorHookedInBasementCount' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _useNetAsyncLoading) == 0x0005C4, "Member 'ADBDGameState::_useNetAsyncLoading' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _gameLevelLoadingStarted) == 0x0005C5, "Member 'ADBDGameState::_gameLevelLoadingStarted' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _builtLevelData) == 0x0005C8, "Member 'ADBDGameState::_builtLevelData' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _levelOfferings) == 0x000680, "Member 'ADBDGameState::_levelOfferings' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _clipManager) == 0x000698, "Member 'ADBDGameState::_clipManager' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _fadeManager) == 0x0006A0, "Member 'ADBDGameState::_fadeManager' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _sessionId) == 0x0006A8, "Member 'ADBDGameState::_sessionId' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _lobbyId) == 0x0006B8, "Member 'ADBDGameState::_lobbyId' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _escapeDoorActivated) == 0x0006C8, "Member 'ADBDGameState::_escapeDoorActivated' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _escapeDoorOpened) == 0x0006C9, "Member 'ADBDGameState::_escapeDoorOpened' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _isHatchOpen) == 0x0006CA, "Member 'ADBDGameState::_isHatchOpen' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _levelReadyToPlay) == 0x0006CB, "Member 'ADBDGameState::_levelReadyToPlay' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _playerDistributionReady) == 0x0006CC, "Member 'ADBDGameState::_playerDistributionReady' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _usingWeakenedMechanic) == 0x0006CD, "Member 'ADBDGameState::_usingWeakenedMechanic' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _survivorLeft) == 0x0006D0, "Member 'ADBDGameState::_survivorLeft' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _meatHooks) == 0x0006D8, "Member 'ADBDGameState::_meatHooks' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _searchables) == 0x0006E8, "Member 'ADBDGameState::_searchables' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _generators) == 0x0006F8, "Member 'ADBDGameState::_generators' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _escapeDoors) == 0x000708, "Member 'ADBDGameState::_escapeDoors' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _hatches) == 0x000718, "Member 'ADBDGameState::_hatches' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _specialGenerators) == 0x000728, "Member 'ADBDGameState::_specialGenerators' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _isInitializedSpecialGenerators) == 0x000738, "Member 'ADBDGameState::_isInitializedSpecialGenerators' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _reverseBearTrapRemovers) == 0x000740, "Member 'ADBDGameState::_reverseBearTrapRemovers' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _baseTraps) == 0x000750, "Member 'ADBDGameState::_baseTraps' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _pallets) == 0x000760, "Member 'ADBDGameState::_pallets' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _windows) == 0x000770, "Member 'ADBDGameState::_windows' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _lockers) == 0x000780, "Member 'ADBDGameState::_lockers' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _breakableWalls) == 0x000790, "Member 'ADBDGameState::_breakableWalls' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _totems) == 0x0007A0, "Member 'ADBDGameState::_totems' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _mapBoxSphereBounds) == 0x0007B0, "Member 'ADBDGameState::_mapBoxSphereBounds' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _basementBoxSphereBounds) == 0x0007E8, "Member 'ADBDGameState::_basementBoxSphereBounds' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _camperEscapedThroughHatch) == 0x00083C, "Member 'ADBDGameState::_camperEscapedThroughHatch' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _obsessionTarget) == 0x000840, "Member 'ADBDGameState::_obsessionTarget' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _cachedObsessionEscaped) == 0x000848, "Member 'ADBDGameState::_cachedObsessionEscaped' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _numberOfSurvivorsKilledOrSacrificed) == 0x000850, "Member 'ADBDGameState::_numberOfSurvivorsKilledOrSacrificed' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _traps) == 0x000858, "Member 'ADBDGameState::_traps' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _dangerPredictionObjects) == 0x000868, "Member 'ADBDGameState::_dangerPredictionObjects' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _gamePresetData) == 0x000880, "Member 'ADBDGameState::_gamePresetData' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _gameLevelLoaded) == 0x000910, "Member 'ADBDGameState::_gameLevelLoaded' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _gameLevelCreated) == 0x000911, "Member 'ADBDGameState::_gameLevelCreated' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _gameLevelEnded) == 0x000912, "Member 'ADBDGameState::_gameLevelEnded' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _gameTimedOut) == 0x000913, "Member 'ADBDGameState::_gameTimedOut' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _gameEndedReason) == 0x000914, "Member 'ADBDGameState::_gameEndedReason' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _isLoadoutFrozen) == 0x000915, "Member 'ADBDGameState::_isLoadoutFrozen' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _endGameState) == 0x000918, "Member 'ADBDGameState::_endGameState' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _scourgeHookManager) == 0x000920, "Member 'ADBDGameState::_scourgeHookManager' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _actorPairQueryEvaluatorComponent) == 0x000928, "Member 'ADBDGameState::_actorPairQueryEvaluatorComponent' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _loudNoiseEventSystem) == 0x000930, "Member 'ADBDGameState::_loudNoiseEventSystem' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _hudStateComponent) == 0x000938, "Member 'ADBDGameState::_hudStateComponent' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _backendGameplayTunablesComponent) == 0x000940, "Member 'ADBDGameState::_backendGameplayTunablesComponent' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _characterCollection) == 0x000950, "Member 'ADBDGameState::_characterCollection' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _collectableCollection) == 0x000958, "Member 'ADBDGameState::_collectableCollection' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _serverTimeProvider) == 0x000960, "Member 'ADBDGameState::_serverTimeProvider' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _inGameAssetPreloaderComponent) == 0x000968, "Member 'ADBDGameState::_inGameAssetPreloaderComponent' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _onScreenDebugComponent) == 0x000970, "Member 'ADBDGameState::_onScreenDebugComponent' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _matchStartTime) == 0x0009A0, "Member 'ADBDGameState::_matchStartTime' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _isServerDedicated) == 0x0009A8, "Member 'ADBDGameState::_isServerDedicated' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _maxSurvivorCount) == 0x0009AC, "Member 'ADBDGameState::_maxSurvivorCount' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _serverBuildVersion) == 0x0009B0, "Member 'ADBDGameState::_serverBuildVersion' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _serverContentVersion) == 0x0009C0, "Member 'ADBDGameState::_serverContentVersion' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _serverSessionId) == 0x0009D0, "Member 'ADBDGameState::_serverSessionId' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _serverRegion) == 0x0009E0, "Member 'ADBDGameState::_serverRegion' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _serverMatchId) == 0x0009F0, "Member 'ADBDGameState::_serverMatchId' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _introDuration) == 0x000A00, "Member 'ADBDGameState::_introDuration' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _leaveSpectateRequested) == 0x000A04, "Member 'ADBDGameState::_leaveSpectateRequested' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _eventTrackerObjectiveLevels) == 0x000A08, "Member 'ADBDGameState::_eventTrackerObjectiveLevels' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _hatchVisibleSurvivorThreshold) == 0x000A18, "Member 'ADBDGameState::_hatchVisibleSurvivorThreshold' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _isForPreview) == 0x000A1C, "Member 'ADBDGameState::_isForPreview' has a wrong offset!");

// Class DeadByDaylight.Tile2
// 0x0060 (0x0300 - 0x02A0)
class ATile2 : public AActor
{
public:
	struct FRandomStream                          SharedTileRandomizer;                              // 0x02A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLevelLoaded;                                     // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UTileSpawnPoint* TileSpawnPoint, class AActor* spawnedObject)> OnSetSpawnObject; // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnAllTileSpawned;                                  // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              InitOnSpawned;                                     // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          EnableRandomizer;                                  // 0x02E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E9[0x3];                                      // 0x02E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RandomizerSeed;                                    // 0x02EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTileRandomizerData>            Randomizers;                                       // 0x02F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Tile2">();
	}
	static class ATile2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATile2>();
	}
};
static_assert(alignof(ATile2) == 0x000008, "Wrong alignment on ATile2");
static_assert(sizeof(ATile2) == 0x000300, "Wrong size on ATile2");
static_assert(offsetof(ATile2, SharedTileRandomizer) == 0x0002A0, "Member 'ATile2::SharedTileRandomizer' has a wrong offset!");
static_assert(offsetof(ATile2, OnLevelLoaded) == 0x0002A8, "Member 'ATile2::OnLevelLoaded' has a wrong offset!");
static_assert(offsetof(ATile2, OnSetSpawnObject) == 0x0002B8, "Member 'ATile2::OnSetSpawnObject' has a wrong offset!");
static_assert(offsetof(ATile2, OnAllTileSpawned) == 0x0002C8, "Member 'ATile2::OnAllTileSpawned' has a wrong offset!");
static_assert(offsetof(ATile2, InitOnSpawned) == 0x0002D8, "Member 'ATile2::InitOnSpawned' has a wrong offset!");
static_assert(offsetof(ATile2, EnableRandomizer) == 0x0002E8, "Member 'ATile2::EnableRandomizer' has a wrong offset!");
static_assert(offsetof(ATile2, RandomizerSeed) == 0x0002EC, "Member 'ATile2::RandomizerSeed' has a wrong offset!");
static_assert(offsetof(ATile2, Randomizers) == 0x0002F0, "Member 'ATile2::Randomizers' has a wrong offset!");

// Class DeadByDaylight.EscapeTile2
// 0x0000 (0x0300 - 0x0300)
class AEscapeTile2 final : public ATile2
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EscapeTile2">();
	}
	static class AEscapeTile2* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEscapeTile2>();
	}
};
static_assert(alignof(AEscapeTile2) == 0x000008, "Wrong alignment on AEscapeTile2");
static_assert(sizeof(AEscapeTile2) == 0x000300, "Wrong size on AEscapeTile2");

// Class DeadByDaylight.TriggerableWorldObjectComponent
// 0x0108 (0x01C0 - 0x00B8)
class UTriggerableWorldObjectComponent : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(class ACharacter* Instigator, const struct FVector& Location)> OnTriggered; // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTriggerReset;                                    // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FDBDTunableRowHandle                   _triggerResetTime;                                 // 0x00D8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _randomChance;                                     // 0x0100(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _rollFrequency;                                    // 0x0128(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_150[0x10];                                     // 0x0150(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UPrimitiveComponent>     _conditionalTriggerVolume;                         // 0x0160(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class ACharacter*>                       _conditionalVolumeOverlappingCharacters;           // 0x0168(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UPrimitiveComponent>     _guaranteedTriggerVolume;                          // 0x01B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_ConditionalVolumeBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& HitResult);
	void Authority_ConditionalVolumeEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void Authority_GuaranteedVolumeOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& HitResult);
	void Multicast_OnTriggered(class ACharacter* Instigator, const struct FVector& triggerLocation);
	void Multicast_OnTriggerReset();
	void OnLevelReadyToPlay();
	void SetConditionalTriggerVolume(class UPrimitiveComponent* Volume);
	void SetGuaranteedTriggerVolume(class UPrimitiveComponent* Volume);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TriggerableWorldObjectComponent">();
	}
	static class UTriggerableWorldObjectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTriggerableWorldObjectComponent>();
	}
};
static_assert(alignof(UTriggerableWorldObjectComponent) == 0x000008, "Wrong alignment on UTriggerableWorldObjectComponent");
static_assert(sizeof(UTriggerableWorldObjectComponent) == 0x0001C0, "Wrong size on UTriggerableWorldObjectComponent");
static_assert(offsetof(UTriggerableWorldObjectComponent, OnTriggered) == 0x0000B8, "Member 'UTriggerableWorldObjectComponent::OnTriggered' has a wrong offset!");
static_assert(offsetof(UTriggerableWorldObjectComponent, OnTriggerReset) == 0x0000C8, "Member 'UTriggerableWorldObjectComponent::OnTriggerReset' has a wrong offset!");
static_assert(offsetof(UTriggerableWorldObjectComponent, _triggerResetTime) == 0x0000D8, "Member 'UTriggerableWorldObjectComponent::_triggerResetTime' has a wrong offset!");
static_assert(offsetof(UTriggerableWorldObjectComponent, _randomChance) == 0x000100, "Member 'UTriggerableWorldObjectComponent::_randomChance' has a wrong offset!");
static_assert(offsetof(UTriggerableWorldObjectComponent, _rollFrequency) == 0x000128, "Member 'UTriggerableWorldObjectComponent::_rollFrequency' has a wrong offset!");
static_assert(offsetof(UTriggerableWorldObjectComponent, _conditionalTriggerVolume) == 0x000160, "Member 'UTriggerableWorldObjectComponent::_conditionalTriggerVolume' has a wrong offset!");
static_assert(offsetof(UTriggerableWorldObjectComponent, _conditionalVolumeOverlappingCharacters) == 0x000168, "Member 'UTriggerableWorldObjectComponent::_conditionalVolumeOverlappingCharacters' has a wrong offset!");
static_assert(offsetof(UTriggerableWorldObjectComponent, _guaranteedTriggerVolume) == 0x0001B8, "Member 'UTriggerableWorldObjectComponent::_guaranteedTriggerVolume' has a wrong offset!");

// Class DeadByDaylight.PS4GRDKBaseProfileDAL
// 0x0000 (0x0088 - 0x0088)
class UPS4GRDKBaseProfileDAL : public UPlayerProfileDAL
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PS4GRDKBaseProfileDAL">();
	}
	static class UPS4GRDKBaseProfileDAL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPS4GRDKBaseProfileDAL>();
	}
};
static_assert(alignof(UPS4GRDKBaseProfileDAL) == 0x000008, "Wrong alignment on UPS4GRDKBaseProfileDAL");
static_assert(sizeof(UPS4GRDKBaseProfileDAL) == 0x000088, "Wrong size on UPS4GRDKBaseProfileDAL");

// Class DeadByDaylight.PS4ProfileDAL
// 0x0000 (0x0088 - 0x0088)
class UPS4ProfileDAL final : public UPS4GRDKBaseProfileDAL
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PS4ProfileDAL">();
	}
	static class UPS4ProfileDAL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPS4ProfileDAL>();
	}
};
static_assert(alignof(UPS4ProfileDAL) == 0x000008, "Wrong alignment on UPS4ProfileDAL");
static_assert(sizeof(UPS4ProfileDAL) == 0x000088, "Wrong size on UPS4ProfileDAL");

// Class DeadByDaylight.BlueprintPlatformUtilities
// 0x0000 (0x0030 - 0x0030)
class UBlueprintPlatformUtilities final : public UBlueprintFunctionLibrary
{
public:
	static float ToFloat(const struct FDBDPerPlatformFloat& PerPlatformFloat, const class UObject* objectInWorld);
	static int32 ToInteger(const struct FDBDPerPlatformInt& PerPlatformInt, const class UObject* objectInWorld);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlueprintPlatformUtilities">();
	}
	static class UBlueprintPlatformUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprintPlatformUtilities>();
	}
};
static_assert(alignof(UBlueprintPlatformUtilities) == 0x000008, "Wrong alignment on UBlueprintPlatformUtilities");
static_assert(sizeof(UBlueprintPlatformUtilities) == 0x000030, "Wrong size on UBlueprintPlatformUtilities");

// Class DeadByDaylight.IgnoreCollisionsComponent
// 0x0050 (0x0108 - 0x00B8)
class UIgnoreCollisionsComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x50];                                      // 0x00B8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgnoreCollisionsComponent">();
	}
	static class UIgnoreCollisionsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgnoreCollisionsComponent>();
	}
};
static_assert(alignof(UIgnoreCollisionsComponent) == 0x000008, "Wrong alignment on UIgnoreCollisionsComponent");
static_assert(sizeof(UIgnoreCollisionsComponent) == 0x000108, "Wrong size on UIgnoreCollisionsComponent");

// Class DeadByDaylight.PowerWidgetBundlePresentationComponent
// 0x0060 (0x0118 - 0x00B8)
class UPowerWidgetBundlePresentationComponent : public UActorComponent
{
public:
	TArray<struct FGameplayTag>                   _powerWidgetPriorities;                            // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x50];                                      // 0x00C8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PowerWidgetBundlePresentationComponent">();
	}
	static class UPowerWidgetBundlePresentationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPowerWidgetBundlePresentationComponent>();
	}
};
static_assert(alignof(UPowerWidgetBundlePresentationComponent) == 0x000008, "Wrong alignment on UPowerWidgetBundlePresentationComponent");
static_assert(sizeof(UPowerWidgetBundlePresentationComponent) == 0x000118, "Wrong size on UPowerWidgetBundlePresentationComponent");
static_assert(offsetof(UPowerWidgetBundlePresentationComponent, _powerWidgetPriorities) == 0x0000B8, "Member 'UPowerWidgetBundlePresentationComponent::_powerWidgetPriorities' has a wrong offset!");

// Class DeadByDaylight.CooldownTimerPerkIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UCooldownTimerPerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CooldownTimerPerkIconStrategy">();
	}
	static class UCooldownTimerPerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCooldownTimerPerkIconStrategy>();
	}
};
static_assert(alignof(UCooldownTimerPerkIconStrategy) == 0x000008, "Wrong alignment on UCooldownTimerPerkIconStrategy");
static_assert(sizeof(UCooldownTimerPerkIconStrategy) == 0x000038, "Wrong size on UCooldownTimerPerkIconStrategy");

// Class DeadByDaylight.CapsulePlayerOverlapComponent
// 0x0000 (0x05D0 - 0x05D0)
class UCapsulePlayerOverlapComponent final : public UCapsuleComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CapsulePlayerOverlapComponent">();
	}
	static class UCapsulePlayerOverlapComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCapsulePlayerOverlapComponent>();
	}
};
static_assert(alignof(UCapsulePlayerOverlapComponent) == 0x000010, "Wrong alignment on UCapsulePlayerOverlapComponent");
static_assert(sizeof(UCapsulePlayerOverlapComponent) == 0x0005D0, "Wrong size on UCapsulePlayerOverlapComponent");

// Class DeadByDaylight.StunnableInterface
// 0x0000 (0x0000 - 0x0000)
class IStunnableInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StunnableInterface">();
	}
	static class IStunnableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStunnableInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IStunnableInterface) == 0x000001, "Wrong alignment on IStunnableInterface");
static_assert(sizeof(IStunnableInterface) == 0x000001, "Wrong size on IStunnableInterface");

// Class DeadByDaylight.AICharacterBehaviourData
// 0x0000 (0x0030 - 0x0030)
class UAICharacterBehaviourData : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterBehaviourData">();
	}
	static class UAICharacterBehaviourData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterBehaviourData>();
	}
};
static_assert(alignof(UAICharacterBehaviourData) == 0x000008, "Wrong alignment on UAICharacterBehaviourData");
static_assert(sizeof(UAICharacterBehaviourData) == 0x000030, "Wrong size on UAICharacterBehaviourData");

// Class DeadByDaylight.AICharacterEscapeCarriedData
// 0x0008 (0x0038 - 0x0030)
class UAICharacterEscapeCarriedData final : public UAICharacterBehaviourData
{
public:
	bool                                          _preventWiggleSuccess;                             // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(bool preventWiggleSuccess);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterEscapeCarriedData">();
	}
	static class UAICharacterEscapeCarriedData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterEscapeCarriedData>();
	}
};
static_assert(alignof(UAICharacterEscapeCarriedData) == 0x000008, "Wrong alignment on UAICharacterEscapeCarriedData");
static_assert(sizeof(UAICharacterEscapeCarriedData) == 0x000038, "Wrong size on UAICharacterEscapeCarriedData");
static_assert(offsetof(UAICharacterEscapeCarriedData, _preventWiggleSuccess) == 0x000030, "Member 'UAICharacterEscapeCarriedData::_preventWiggleSuccess' has a wrong offset!");

// Class DeadByDaylight.ScreenIndicatorWorldMarkerComponent
// 0x0020 (0x02F0 - 0x02D0)
#pragma pack(push, 0x1)
class alignas(0x10) UScreenIndicatorWorldMarkerComponent : public USceneComponent
{
public:
	EHudScreenIndicatorType                       HudScreenIndicatorType;                            // 0x02D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D1[0x3];                                      // 0x02D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRange                            VisibleDistanceRange;                              // 0x02D4(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenIndicatorWorldMarkerComponent">();
	}
	static class UScreenIndicatorWorldMarkerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenIndicatorWorldMarkerComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UScreenIndicatorWorldMarkerComponent) == 0x000010, "Wrong alignment on UScreenIndicatorWorldMarkerComponent");
static_assert(sizeof(UScreenIndicatorWorldMarkerComponent) == 0x0002F0, "Wrong size on UScreenIndicatorWorldMarkerComponent");
static_assert(offsetof(UScreenIndicatorWorldMarkerComponent, HudScreenIndicatorType) == 0x0002D0, "Member 'UScreenIndicatorWorldMarkerComponent::HudScreenIndicatorType' has a wrong offset!");
static_assert(offsetof(UScreenIndicatorWorldMarkerComponent, VisibleDistanceRange) == 0x0002D4, "Member 'UScreenIndicatorWorldMarkerComponent::VisibleDistanceRange' has a wrong offset!");

// Class DeadByDaylight.DBDDesignTunables
// 0x0068 (0x00A0 - 0x0038)
class UDBDDesignTunables final : public UEngineSubsystem
{
public:
	TSoftObjectPtr<class UDesignTunableDataAsset> SoftDesignTunableDataAsset;                        // 0x0038(0x0038)(Edit, BlueprintVisible, Config, NoClear, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDesignTunableDataAsset*                DesignTunableDataAsset;                            // 0x0070(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMenuCameraDesignTunables*              MenuCameraDesignTunables;                          // 0x0078(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDTextDesignTunables*                 TextTunables;                                      // 0x0080(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDCoreUMGDesignTunables*              CoreUMGDesignTunables;                             // 0x0088(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x10];                                      // 0x0090(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static TArray<class FString> GetArrayGameTypeTunable(EGameType gameType, EGameTypeModifierName TunableName);
	static bool GetBoolGameTypeTunable(EGameType gameType, EGameTypeModifierName TunableName);
	static bool GetBoolManualTunableValue(class FName ID, const bool defaultValue, bool warnIfRowMissing);
	static float GetFloatGameTypeTunable(EGameType gameType, EGameTypeModifierName TunableName);
	static float GetFloatManualTunableValue(class FName ID, const float defaultValue, bool warnIfRowMissing);
	static int32 GetInt32ManualTunableValue(class FName ID, const int32 defaultValue, bool warnIfRowMissing);
	static int32 GetIntGameTypeTunable(EGameType gameType, EGameTypeModifierName TunableName);
	static TArray<class FString> GetStringArrayManualTunableValue(class FName ID, const TArray<class FString>& defaultValue, bool warnIfRowMissing);
	static class FString GetStringGameTypeTunable(EGameType gameType, EGameTypeModifierName TunableName);
	static class FString GetStringManualTunableValue(class FName ID, const class FString& defaultValue, bool warnIfRowMissing);

	void OnPluginDataPathAdded(const class FString& DataPath);

	float GetTunableValue(class FName ID, bool warnIfRowMissing) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDDesignTunables">();
	}
	static class UDBDDesignTunables* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDDesignTunables>();
	}
};
static_assert(alignof(UDBDDesignTunables) == 0x000008, "Wrong alignment on UDBDDesignTunables");
static_assert(sizeof(UDBDDesignTunables) == 0x0000A0, "Wrong size on UDBDDesignTunables");
static_assert(offsetof(UDBDDesignTunables, SoftDesignTunableDataAsset) == 0x000038, "Member 'UDBDDesignTunables::SoftDesignTunableDataAsset' has a wrong offset!");
static_assert(offsetof(UDBDDesignTunables, DesignTunableDataAsset) == 0x000070, "Member 'UDBDDesignTunables::DesignTunableDataAsset' has a wrong offset!");
static_assert(offsetof(UDBDDesignTunables, MenuCameraDesignTunables) == 0x000078, "Member 'UDBDDesignTunables::MenuCameraDesignTunables' has a wrong offset!");
static_assert(offsetof(UDBDDesignTunables, TextTunables) == 0x000080, "Member 'UDBDDesignTunables::TextTunables' has a wrong offset!");
static_assert(offsetof(UDBDDesignTunables, CoreUMGDesignTunables) == 0x000088, "Member 'UDBDDesignTunables::CoreUMGDesignTunables' has a wrong offset!");

// Class DeadByDaylight.DBDEmblem
// 0x0048 (0x0100 - 0x00B8)
class UDBDEmblem : public UActorComponent
{
public:
	float                                         _points;                                           // 0x00B8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FProgressionPoints>             _progressionPoints;                                // 0x00C0(0x0010)(Net, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    _definition;                                       // 0x00D0(0x0018)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E8[0x18];                                      // 0x00E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_FinalizeReplication(const float Points, const TArray<struct FProgressionPoints>& ProgressionPoints);
	void Server_EnableEmblemDebugging(bool Enabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDEmblem">();
	}
	static class UDBDEmblem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDEmblem>();
	}
};
static_assert(alignof(UDBDEmblem) == 0x000008, "Wrong alignment on UDBDEmblem");
static_assert(sizeof(UDBDEmblem) == 0x000100, "Wrong size on UDBDEmblem");
static_assert(offsetof(UDBDEmblem, _points) == 0x0000B8, "Member 'UDBDEmblem::_points' has a wrong offset!");
static_assert(offsetof(UDBDEmblem, _progressionPoints) == 0x0000C0, "Member 'UDBDEmblem::_progressionPoints' has a wrong offset!");
static_assert(offsetof(UDBDEmblem, _definition) == 0x0000D0, "Member 'UDBDEmblem::_definition' has a wrong offset!");

// Class DeadByDaylight.Generator
// 0x03A8 (0x0750 - 0x03A8)
class AGenerator final : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x88];                                     // 0x03A8(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          WasASMCachePreWarmTriggered;                       // 0x0430(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPlaySkillcheckAesthetic;                         // 0x0431(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_432[0x6];                                      // 0x0432(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveLinearColor*                      KillerOutlineFadeCurve;                            // 0x0438(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool isAutoCompleted)> OnGeneratorRepaired;                        // 0x0440(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADBDPlayer* repairingSurvivor)> OnGeneratorRepairedBySurvivor; // 0x0450(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGenerator* Generator, class ADBDPlayer* Player)> OnIsDamagedChanged; // 0x0460(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UGeneratorDamageComponent*              _generatorDamageComponent;                         // 0x0470(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FireLevelScoreEventOnFix;                          // 0x0478(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_479[0x7];                                      // 0x0479(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FTransform>          _activatedTopLightsTransformMap;                   // 0x0480(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class USceneComponent*                        _leftInteractionSceneComponent;                    // 0x04D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _rightInteractionSceneComponent;                   // 0x04D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _frontInteractionSceneComponent;                   // 0x04E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _backInteractionSceneComponent;                    // 0x04E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAIPerceptionStimuliSourceComponent*    _perceptionStimuliComponent;                       // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDischargeUntilThresholdIsReachedComponent* _regressChargeUntilThresholdIsReached;         // 0x04F8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _regressionSpeedWhileDamaged;                      // 0x0500(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_528[0x1C];                                     // 0x0528(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _repairSemanticTag;                                // 0x0544(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_550[0x48];                                     // 0x0550(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isBlocked;                                        // 0x0598(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isBlockedFromCharging;                            // 0x0599(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_59A[0x6];                                      // 0x059A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UObject*>                          _blockingSources;                                  // 0x05A0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F0[0x30];                                     // 0x05F0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargeableComponent*                   _generatorCharge;                                  // 0x0620(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FPlayerFloatTuple>              _playerStartTimes;                                 // 0x0628(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_638[0x10];                                     // 0x0638(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isAutoCompleted;                                  // 0x0648(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isOvercharged;                                    // 0x0649(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_64A[0x6];                                      // 0x064A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCoopRepairTracker*                     _coopRepairTracker;                                // 0x0650(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _activated;                                        // 0x0658(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_659[0x1B];                                     // 0x0659(0x001B)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _VFX_LightDistanceDefault;                         // 0x0674(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_678[0x60];                                     // 0x0678(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInteractionDefinition*>         _damagingInteractions;                             // 0x06D8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6E8[0x28];                                     // 0x06E8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADBDPlayer*>                     _authority_cachedInteractingPlayersOnCompletion;   // 0x0710(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _defaultImmediateRegressionPercentage;             // 0x0720(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_748[0x8];                                      // 0x0748(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDamagingInteraction(class UInteractionDefinition* Interaction);
	void AddPlayerStartTime(class ADBDPlayer* Player, float starttime);
	void AT_SetActivated(bool activated);
	void Authority_AddBlockingSource(const class UObject* Source);
	void Authority_AddTimedBlockingSource(const class UObject* Source, const float blockingTime);
	void Authority_OnChargeApplied(float IndividualChargeAmount, float TotalChargeAmount, class AActor* ChargeInstigator, bool WasCoop, float DeltaTime);
	void Authority_OnChargeChanged(class UChargeableComponent* ChargeableComponent, float PercentCompletionChange, float TotalPercentComplete);
	void Authority_RemoveBlockingSource(const class UObject* Source);
	void Authority_RepairDamage(class ADBDPlayer* repairedBy);
	void Authority_SetRepaired(const bool showGeneratorCloneLoudNoise, const bool isAutoCompleted);
	void BroadcastIsDamagedChangedEvent(class ADBDPlayer* Player);
	void DisableInaccessibleInteractors();
	bool GetIsBlockedFromCharging();
	void Multicast_OnRepaired(const bool showGeneratorCloneLoudNoise, const bool isAutoCompleted, const int32 updatedRemainingGeneratorCount);
	void Multicast_PlayFailSparksFX(class ADBDPlayer* Player, bool Explode);
	void NotifyRepairFinish(const class ADBDPlayer* Player, class UInteractor* Interactor);
	void NotifyRepairStart(const class ADBDPlayer* Player);
	void OnBlockingStatusChanged(const bool IsBlocked);
	void OnCaptureProbeSecondState();
	void OnChargeChanged(class UChargeableComponent* ChargeableComponent, float Percent);
	void OnEscapeDoorActivated();
	void OnPreWarmASMCache();
	void OnRegressionStateChanged(const bool regressing, class ADBDPlayer* lastDamageChangeSource);
	void OnRep_IsBlocked();
	void OnRepairedBP(const bool showGeneratorCloneLoudNoise, const bool isAutoCompleted);
	void OnResetGenerator();
	void OnUpdateChargeProgress(float newPercentComplete);
	void PlayFailSparksFX(class ADBDPlayer* interactingPlayer, bool Explode);
	int32 PostAkEvent(class UAkAudioEvent* akEvent, int32 callbackMask, const TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)>& postEventCallback);
	void RemovePlayerStartTime(const class ADBDPlayer* Player);
	void ResetGenerator();
	void SetComplete(bool complete);
	void SetIsAutoCompleted(const bool isAutoCompleted);
	void SetIsBlockedFromCharging(bool isBlockedFromCharging);
	void SetIsOvercharged(const bool overcharged);
	void StopDischarge();
	void TriggerSkillCheck(class ADBDPlayer* instigatingPlayer);
	void TriggerSkillCheckFailureLoudNoise(class ADBDPlayer* instigatingPlayer);
	void VFXClampTopActivationSingleLight(float Distance, class FName ParameterName);

	void ActivateTeleportGeneratorIndicator(bool Activate) const;
	void BroadcastGeneratorRepairedBySurvivor(class ADBDPlayer* repairingSurvivor) const;
	bool CanSurvivorReactToBlockingEntity(const class ASurvivor* Survivor) const;
	float GetChargePercentComplete() const;
	class UAkComponent* GetGeneratorAudioComponent() const;
	class UChargeableComponent* GetGeneratorChargeComponent() const;
	bool GetIsAutoCompleted() const;
	float GetPlayerStartTime(const class ADBDPlayer* Player) const;
	const TArray<struct FPlayerFloatTuple> GetPlayerStartTimes() const;
	float GetRepairPercentComplete() const;
	class USkeletalMeshComponent* GetSkeletalMesh() const;
	bool IsBeingDamagedByKiller() const;
	bool ShouldDoOverchargeSkillcheck() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Generator">();
	}
	static class AGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGenerator>();
	}
};
static_assert(alignof(AGenerator) == 0x000008, "Wrong alignment on AGenerator");
static_assert(sizeof(AGenerator) == 0x000750, "Wrong size on AGenerator");
static_assert(offsetof(AGenerator, WasASMCachePreWarmTriggered) == 0x000430, "Member 'AGenerator::WasASMCachePreWarmTriggered' has a wrong offset!");
static_assert(offsetof(AGenerator, IsPlaySkillcheckAesthetic) == 0x000431, "Member 'AGenerator::IsPlaySkillcheckAesthetic' has a wrong offset!");
static_assert(offsetof(AGenerator, KillerOutlineFadeCurve) == 0x000438, "Member 'AGenerator::KillerOutlineFadeCurve' has a wrong offset!");
static_assert(offsetof(AGenerator, OnGeneratorRepaired) == 0x000440, "Member 'AGenerator::OnGeneratorRepaired' has a wrong offset!");
static_assert(offsetof(AGenerator, OnGeneratorRepairedBySurvivor) == 0x000450, "Member 'AGenerator::OnGeneratorRepairedBySurvivor' has a wrong offset!");
static_assert(offsetof(AGenerator, OnIsDamagedChanged) == 0x000460, "Member 'AGenerator::OnIsDamagedChanged' has a wrong offset!");
static_assert(offsetof(AGenerator, _generatorDamageComponent) == 0x000470, "Member 'AGenerator::_generatorDamageComponent' has a wrong offset!");
static_assert(offsetof(AGenerator, FireLevelScoreEventOnFix) == 0x000478, "Member 'AGenerator::FireLevelScoreEventOnFix' has a wrong offset!");
static_assert(offsetof(AGenerator, _activatedTopLightsTransformMap) == 0x000480, "Member 'AGenerator::_activatedTopLightsTransformMap' has a wrong offset!");
static_assert(offsetof(AGenerator, _leftInteractionSceneComponent) == 0x0004D0, "Member 'AGenerator::_leftInteractionSceneComponent' has a wrong offset!");
static_assert(offsetof(AGenerator, _rightInteractionSceneComponent) == 0x0004D8, "Member 'AGenerator::_rightInteractionSceneComponent' has a wrong offset!");
static_assert(offsetof(AGenerator, _frontInteractionSceneComponent) == 0x0004E0, "Member 'AGenerator::_frontInteractionSceneComponent' has a wrong offset!");
static_assert(offsetof(AGenerator, _backInteractionSceneComponent) == 0x0004E8, "Member 'AGenerator::_backInteractionSceneComponent' has a wrong offset!");
static_assert(offsetof(AGenerator, _perceptionStimuliComponent) == 0x0004F0, "Member 'AGenerator::_perceptionStimuliComponent' has a wrong offset!");
static_assert(offsetof(AGenerator, _regressChargeUntilThresholdIsReached) == 0x0004F8, "Member 'AGenerator::_regressChargeUntilThresholdIsReached' has a wrong offset!");
static_assert(offsetof(AGenerator, _regressionSpeedWhileDamaged) == 0x000500, "Member 'AGenerator::_regressionSpeedWhileDamaged' has a wrong offset!");
static_assert(offsetof(AGenerator, _repairSemanticTag) == 0x000544, "Member 'AGenerator::_repairSemanticTag' has a wrong offset!");
static_assert(offsetof(AGenerator, _isBlocked) == 0x000598, "Member 'AGenerator::_isBlocked' has a wrong offset!");
static_assert(offsetof(AGenerator, _isBlockedFromCharging) == 0x000599, "Member 'AGenerator::_isBlockedFromCharging' has a wrong offset!");
static_assert(offsetof(AGenerator, _blockingSources) == 0x0005A0, "Member 'AGenerator::_blockingSources' has a wrong offset!");
static_assert(offsetof(AGenerator, _generatorCharge) == 0x000620, "Member 'AGenerator::_generatorCharge' has a wrong offset!");
static_assert(offsetof(AGenerator, _playerStartTimes) == 0x000628, "Member 'AGenerator::_playerStartTimes' has a wrong offset!");
static_assert(offsetof(AGenerator, _isAutoCompleted) == 0x000648, "Member 'AGenerator::_isAutoCompleted' has a wrong offset!");
static_assert(offsetof(AGenerator, _isOvercharged) == 0x000649, "Member 'AGenerator::_isOvercharged' has a wrong offset!");
static_assert(offsetof(AGenerator, _coopRepairTracker) == 0x000650, "Member 'AGenerator::_coopRepairTracker' has a wrong offset!");
static_assert(offsetof(AGenerator, _activated) == 0x000658, "Member 'AGenerator::_activated' has a wrong offset!");
static_assert(offsetof(AGenerator, _VFX_LightDistanceDefault) == 0x000674, "Member 'AGenerator::_VFX_LightDistanceDefault' has a wrong offset!");
static_assert(offsetof(AGenerator, _damagingInteractions) == 0x0006D8, "Member 'AGenerator::_damagingInteractions' has a wrong offset!");
static_assert(offsetof(AGenerator, _authority_cachedInteractingPlayersOnCompletion) == 0x000710, "Member 'AGenerator::_authority_cachedInteractingPlayersOnCompletion' has a wrong offset!");
static_assert(offsetof(AGenerator, _defaultImmediateRegressionPercentage) == 0x000720, "Member 'AGenerator::_defaultImmediateRegressionPercentage' has a wrong offset!");

// Class DeadByDaylight.AbstractGameFlowHandler
// 0x0000 (0x0038 - 0x0038)
class UAbstractGameFlowHandler : public UGameInstanceSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbstractGameFlowHandler">();
	}
	static class UAbstractGameFlowHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbstractGameFlowHandler>();
	}
};
static_assert(alignof(UAbstractGameFlowHandler) == 0x000008, "Wrong alignment on UAbstractGameFlowHandler");
static_assert(sizeof(UAbstractGameFlowHandler) == 0x000038, "Wrong size on UAbstractGameFlowHandler");

// Class DeadByDaylight.SurvivorMovementComponent
// 0x00B0 (0x14E0 - 0x1430)
class USurvivorMovementComponent final : public UDBDCharacterMovementComponent
{
public:
	uint8                                         Pad_1430[0x18];                                    // 0x1430(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxCrawlSpeed;                                     // 0x1448(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRunSpeed;                                       // 0x144C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               _defaultRotationRate;                              // 0x1450(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               _rotationRateWhileCrawling;                        // 0x1468(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _dropStaggerMaxSpeed;                              // 0x1480(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1488[0x58];                                    // 0x1488(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCamperHealthStateChanged(EHealthState oldDamageState, EHealthState currentDamageState);

	struct FRotator GetDefaultRotationRate() const;
	float GetDropStaggerTimeLeft() const;
	struct FRotator GetRotationRateWhileCrawling() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorMovementComponent">();
	}
	static class USurvivorMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorMovementComponent>();
	}
};
static_assert(alignof(USurvivorMovementComponent) == 0x000010, "Wrong alignment on USurvivorMovementComponent");
static_assert(sizeof(USurvivorMovementComponent) == 0x0014E0, "Wrong size on USurvivorMovementComponent");
static_assert(offsetof(USurvivorMovementComponent, MaxCrawlSpeed) == 0x001448, "Member 'USurvivorMovementComponent::MaxCrawlSpeed' has a wrong offset!");
static_assert(offsetof(USurvivorMovementComponent, MaxRunSpeed) == 0x00144C, "Member 'USurvivorMovementComponent::MaxRunSpeed' has a wrong offset!");
static_assert(offsetof(USurvivorMovementComponent, _defaultRotationRate) == 0x001450, "Member 'USurvivorMovementComponent::_defaultRotationRate' has a wrong offset!");
static_assert(offsetof(USurvivorMovementComponent, _rotationRateWhileCrawling) == 0x001468, "Member 'USurvivorMovementComponent::_rotationRateWhileCrawling' has a wrong offset!");
static_assert(offsetof(USurvivorMovementComponent, _dropStaggerMaxSpeed) == 0x001480, "Member 'USurvivorMovementComponent::_dropStaggerMaxSpeed' has a wrong offset!");

// Class DeadByDaylight.AchievementHelper
// 0x0000 (0x0030 - 0x0030)
class UAchievementHelper final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementHelper">();
	}
	static class UAchievementHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementHelper>();
	}
};
static_assert(alignof(UAchievementHelper) == 0x000008, "Wrong alignment on UAchievementHelper");
static_assert(sizeof(UAchievementHelper) == 0x000030, "Wrong size on UAchievementHelper");

// Class DeadByDaylight.ActionButton
// 0x0388 (0x06D0 - 0x0348)
class UActionButton final : public UMobileBaseUserWidget
{
public:
	uint8                                         Pad_348[0x8];                                      // 0x0348(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            DefaultImage;                                      // 0x0350(0x00D0)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class UImage*                                 IconImage;                                         // 0x0420(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ToggleSmokeImage;                                  // 0x0428(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UButton*                                Button;                                            // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultOpacity;                                    // 0x0438(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ToggledOpacity;                                    // 0x043C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisabledOpacity;                                   // 0x0440(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_444[0xC];                                      // 0x0444(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Normal;                                            // 0x0450(0x00D0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FSlateBrush                            Toggled;                                           // 0x0520(0x00D0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FSlateBrush                            Disabled;                                          // 0x05F0(0x00D0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	EActionButtonState                            _currentState;                                     // 0x06C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EActionButtonState                            _previousState;                                    // 0x06C1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C2[0xE];                                      // 0x06C2(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayBecameAvailableAnimation();
	void SetIcon(const struct FSlateBrush& SlateBrush);
	void SetPreviousState();
	void SetSlateBrush(const struct FSlateBrush& InBrush);
	void SetState(EActionButtonState State);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionButton">();
	}
	static class UActionButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionButton>();
	}
};
static_assert(alignof(UActionButton) == 0x000010, "Wrong alignment on UActionButton");
static_assert(sizeof(UActionButton) == 0x0006D0, "Wrong size on UActionButton");
static_assert(offsetof(UActionButton, DefaultImage) == 0x000350, "Member 'UActionButton::DefaultImage' has a wrong offset!");
static_assert(offsetof(UActionButton, IconImage) == 0x000420, "Member 'UActionButton::IconImage' has a wrong offset!");
static_assert(offsetof(UActionButton, ToggleSmokeImage) == 0x000428, "Member 'UActionButton::ToggleSmokeImage' has a wrong offset!");
static_assert(offsetof(UActionButton, Button) == 0x000430, "Member 'UActionButton::Button' has a wrong offset!");
static_assert(offsetof(UActionButton, DefaultOpacity) == 0x000438, "Member 'UActionButton::DefaultOpacity' has a wrong offset!");
static_assert(offsetof(UActionButton, ToggledOpacity) == 0x00043C, "Member 'UActionButton::ToggledOpacity' has a wrong offset!");
static_assert(offsetof(UActionButton, DisabledOpacity) == 0x000440, "Member 'UActionButton::DisabledOpacity' has a wrong offset!");
static_assert(offsetof(UActionButton, Normal) == 0x000450, "Member 'UActionButton::Normal' has a wrong offset!");
static_assert(offsetof(UActionButton, Toggled) == 0x000520, "Member 'UActionButton::Toggled' has a wrong offset!");
static_assert(offsetof(UActionButton, Disabled) == 0x0005F0, "Member 'UActionButton::Disabled' has a wrong offset!");
static_assert(offsetof(UActionButton, _currentState) == 0x0006C0, "Member 'UActionButton::_currentState' has a wrong offset!");
static_assert(offsetof(UActionButton, _previousState) == 0x0006C1, "Member 'UActionButton::_previousState' has a wrong offset!");

// Class DeadByDaylight.NavigationScreen
// 0x01A8 (0x02D0 - 0x0128)
class UNavigationScreen final : public UScreenBase
{
public:
	uint8                                         Pad_128[0x1A8];                                    // 0x0128(0x01A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAddPlayerClick(int32 buttonId);
	void OnBankClick(int32 currencyTypeInt);
	void OnBloodpointIncentiveHovered(int32 X, int32 Y, int32 Width, int32 Height);
	void OnBloodpointIncentiveUnhovered();
	void OnCancelButtonClick();
	void OnCharacterSwapArrowClick(bool isNext);
	void OnFadeOutEnded();
	void OnInviteFriendClick();
	void OnMatchMakingBanTimeout();
	void OnMatchManagementButtonClick();
	void OnPlayerInfoClick(int32 PlayerId);
	void OnPlayerOptionSelected(const class FString& KrakenId, const class FString& PlayerId, uint8 Option);
	void OnReadyButtonClick();
	void OnSettingsClick();
	void ShowcaseMapButtonHovered(int32 X, int32 Y, int32 Width, int32 Height);
	void ShowcaseMapButtonUnhovered();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationScreen">();
	}
	static class UNavigationScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationScreen>();
	}
};
static_assert(alignof(UNavigationScreen) == 0x000008, "Wrong alignment on UNavigationScreen");
static_assert(sizeof(UNavigationScreen) == 0x0002D0, "Wrong size on UNavigationScreen");

// Class DeadByDaylight.SurvivorActivityIndicatorComponent
// 0x0160 (0x0218 - 0x00B8)
class USurvivorActivityIndicatorComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0xB0];                                      // 0x00B8(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	class USurvivorActivityData*                  _activitiesDataAsset;                              // 0x0168(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_170[0x30];                                     // 0x0170(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _durationNeededToEnableUI;                         // 0x01A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A4[0x74];                                     // 0x01A4(0x0074)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnCamperEscape(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData);
	void HandleStartActivityIfStillInEffect(const struct FSurvivorActivity& activityViewInfo);
	void Multicast_OnCamperEscape();
	void OnChargeableProgressChanged(class UChargeableComponent* ChargeableComponent, float TotalPercentComplete);
	void OnDamageStateChanged(EHealthState oldDamageState, EHealthState currentDamageState);
	void OnPlayerDropped();
	void OnPlayerPickedUp(class ADBDPlayer* picker);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorActivityIndicatorComponent">();
	}
	static class USurvivorActivityIndicatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorActivityIndicatorComponent>();
	}
};
static_assert(alignof(USurvivorActivityIndicatorComponent) == 0x000008, "Wrong alignment on USurvivorActivityIndicatorComponent");
static_assert(sizeof(USurvivorActivityIndicatorComponent) == 0x000218, "Wrong size on USurvivorActivityIndicatorComponent");
static_assert(offsetof(USurvivorActivityIndicatorComponent, _activitiesDataAsset) == 0x000168, "Member 'USurvivorActivityIndicatorComponent::_activitiesDataAsset' has a wrong offset!");
static_assert(offsetof(USurvivorActivityIndicatorComponent, _durationNeededToEnableUI) == 0x0001A0, "Member 'USurvivorActivityIndicatorComponent::_durationNeededToEnableUI' has a wrong offset!");

// Class DeadByDaylight.AISlasherChaseAndAttackBehaviourData
// 0x0010 (0x0040 - 0x0030)
class UAISlasherChaseAndAttackBehaviourData final : public UAICharacterBehaviourData
{
public:
	class ASurvivor*                              _targetSurvivor;                                   // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sqrtAttackRangeDistance;                          // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sqrtMaxTargetPositionDiff;                        // 0x003C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Init(class ASurvivor* TargetSurvivor, float attackRangeDistance, float locationDistance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISlasherChaseAndAttackBehaviourData">();
	}
	static class UAISlasherChaseAndAttackBehaviourData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISlasherChaseAndAttackBehaviourData>();
	}
};
static_assert(alignof(UAISlasherChaseAndAttackBehaviourData) == 0x000008, "Wrong alignment on UAISlasherChaseAndAttackBehaviourData");
static_assert(sizeof(UAISlasherChaseAndAttackBehaviourData) == 0x000040, "Wrong size on UAISlasherChaseAndAttackBehaviourData");
static_assert(offsetof(UAISlasherChaseAndAttackBehaviourData, _targetSurvivor) == 0x000030, "Member 'UAISlasherChaseAndAttackBehaviourData::_targetSurvivor' has a wrong offset!");
static_assert(offsetof(UAISlasherChaseAndAttackBehaviourData, _sqrtAttackRangeDistance) == 0x000038, "Member 'UAISlasherChaseAndAttackBehaviourData::_sqrtAttackRangeDistance' has a wrong offset!");
static_assert(offsetof(UAISlasherChaseAndAttackBehaviourData, _sqrtMaxTargetPositionDiff) == 0x00003C, "Member 'UAISlasherChaseAndAttackBehaviourData::_sqrtMaxTargetPositionDiff' has a wrong offset!");

// Class DeadByDaylight.ActivationAndTimerIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActivationAndTimerIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivationAndTimerIconStrategy">();
	}
	static class UActivationAndTimerIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivationAndTimerIconStrategy>();
	}
};
static_assert(alignof(UActivationAndTimerIconStrategy) == 0x000008, "Wrong alignment on UActivationAndTimerIconStrategy");
static_assert(sizeof(UActivationAndTimerIconStrategy) == 0x000038, "Wrong size on UActivationAndTimerIconStrategy");

// Class DeadByDaylight.ActivationTimerElapsedCooldownElapsedIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActivationTimerElapsedCooldownElapsedIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivationTimerElapsedCooldownElapsedIconStrategy">();
	}
	static class UActivationTimerElapsedCooldownElapsedIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivationTimerElapsedCooldownElapsedIconStrategy>();
	}
};
static_assert(alignof(UActivationTimerElapsedCooldownElapsedIconStrategy) == 0x000008, "Wrong alignment on UActivationTimerElapsedCooldownElapsedIconStrategy");
static_assert(sizeof(UActivationTimerElapsedCooldownElapsedIconStrategy) == 0x000038, "Wrong size on UActivationTimerElapsedCooldownElapsedIconStrategy");

// Class DeadByDaylight.LevelParadise
// 0x0090 (0x0330 - 0x02A0)
class ALevelParadise final : public AActor
{
public:
	float                                         LoopStartDistance;                                 // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoopDistance;                                      // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        MainPlayerSpawnPoint;                              // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                OtherSurvivorSpawnPoints;                          // 0x02B0(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                ParadiseTiles;                                     // 0x02C0(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class AActor*                                 ParadiseViewTarget;                                // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D8[0x40];                                     // 0x02D8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _spawnedMainPawn;                                  // 0x0318(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        _runnerComponent;                                  // 0x0320(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _fadeOutDuration;                                  // 0x0328(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _fadeInDuration;                                   // 0x032C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnInterpolationDone();
	void ParadiseEntered(const struct FParadiseData& PlayerData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelParadise">();
	}
	static class ALevelParadise* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevelParadise>();
	}
};
static_assert(alignof(ALevelParadise) == 0x000008, "Wrong alignment on ALevelParadise");
static_assert(sizeof(ALevelParadise) == 0x000330, "Wrong size on ALevelParadise");
static_assert(offsetof(ALevelParadise, LoopStartDistance) == 0x0002A0, "Member 'ALevelParadise::LoopStartDistance' has a wrong offset!");
static_assert(offsetof(ALevelParadise, LoopDistance) == 0x0002A4, "Member 'ALevelParadise::LoopDistance' has a wrong offset!");
static_assert(offsetof(ALevelParadise, MainPlayerSpawnPoint) == 0x0002A8, "Member 'ALevelParadise::MainPlayerSpawnPoint' has a wrong offset!");
static_assert(offsetof(ALevelParadise, OtherSurvivorSpawnPoints) == 0x0002B0, "Member 'ALevelParadise::OtherSurvivorSpawnPoints' has a wrong offset!");
static_assert(offsetof(ALevelParadise, ParadiseTiles) == 0x0002C0, "Member 'ALevelParadise::ParadiseTiles' has a wrong offset!");
static_assert(offsetof(ALevelParadise, ParadiseViewTarget) == 0x0002D0, "Member 'ALevelParadise::ParadiseViewTarget' has a wrong offset!");
static_assert(offsetof(ALevelParadise, _spawnedMainPawn) == 0x000318, "Member 'ALevelParadise::_spawnedMainPawn' has a wrong offset!");
static_assert(offsetof(ALevelParadise, _runnerComponent) == 0x000320, "Member 'ALevelParadise::_runnerComponent' has a wrong offset!");
static_assert(offsetof(ALevelParadise, _fadeOutDuration) == 0x000328, "Member 'ALevelParadise::_fadeOutDuration' has a wrong offset!");
static_assert(offsetof(ALevelParadise, _fadeInDuration) == 0x00032C, "Member 'ALevelParadise::_fadeInDuration' has a wrong offset!");

// Class DeadByDaylight.SupportACreatorSubsystem
// 0x0020 (0x0058 - 0x0038)
class USupportACreatorSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupportACreatorSubsystem">();
	}
	static class USupportACreatorSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USupportACreatorSubsystem>();
	}
};
static_assert(alignof(USupportACreatorSubsystem) == 0x000008, "Wrong alignment on USupportACreatorSubsystem");
static_assert(sizeof(USupportACreatorSubsystem) == 0x000058, "Wrong size on USupportACreatorSubsystem");

// Class DeadByDaylight.ActivationTimerIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActivationTimerIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivationTimerIconStrategy">();
	}
	static class UActivationTimerIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivationTimerIconStrategy>();
	}
};
static_assert(alignof(UActivationTimerIconStrategy) == 0x000008, "Wrong alignment on UActivationTimerIconStrategy");
static_assert(sizeof(UActivationTimerIconStrategy) == 0x000038, "Wrong size on UActivationTimerIconStrategy");

// Class DeadByDaylight.DBDTextDesignTunables
// 0x00D8 (0x0108 - 0x0030)
class UDBDTextDesignTunables : public UObject
{
public:
	class FText                                   LegalTextTitle;                                    // 0x0030(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	class FText                                   LegalText;                                         // 0x0048(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	class FText                                   ConsentTextTitle;                                  // 0x0060(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	class FText                                   ConsentText;                                       // 0x0078(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	class FText                                   LegalTextSIEA;                                     // 0x0090(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	class FText                                   LegalTextSIEE;                                     // 0x00A8(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	class FText                                   SystemMessage_ChatDisconnected;                    // 0x00C0(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	class FText                                   SystemMessage_ChatReturnedToLobby;                 // 0x00D8(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	class FText                                   SystemMessage_ChatMatchServerClosed;               // 0x00F0(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDTextDesignTunables">();
	}
	static class UDBDTextDesignTunables* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDTextDesignTunables>();
	}
};
static_assert(alignof(UDBDTextDesignTunables) == 0x000008, "Wrong alignment on UDBDTextDesignTunables");
static_assert(sizeof(UDBDTextDesignTunables) == 0x000108, "Wrong size on UDBDTextDesignTunables");
static_assert(offsetof(UDBDTextDesignTunables, LegalTextTitle) == 0x000030, "Member 'UDBDTextDesignTunables::LegalTextTitle' has a wrong offset!");
static_assert(offsetof(UDBDTextDesignTunables, LegalText) == 0x000048, "Member 'UDBDTextDesignTunables::LegalText' has a wrong offset!");
static_assert(offsetof(UDBDTextDesignTunables, ConsentTextTitle) == 0x000060, "Member 'UDBDTextDesignTunables::ConsentTextTitle' has a wrong offset!");
static_assert(offsetof(UDBDTextDesignTunables, ConsentText) == 0x000078, "Member 'UDBDTextDesignTunables::ConsentText' has a wrong offset!");
static_assert(offsetof(UDBDTextDesignTunables, LegalTextSIEA) == 0x000090, "Member 'UDBDTextDesignTunables::LegalTextSIEA' has a wrong offset!");
static_assert(offsetof(UDBDTextDesignTunables, LegalTextSIEE) == 0x0000A8, "Member 'UDBDTextDesignTunables::LegalTextSIEE' has a wrong offset!");
static_assert(offsetof(UDBDTextDesignTunables, SystemMessage_ChatDisconnected) == 0x0000C0, "Member 'UDBDTextDesignTunables::SystemMessage_ChatDisconnected' has a wrong offset!");
static_assert(offsetof(UDBDTextDesignTunables, SystemMessage_ChatReturnedToLobby) == 0x0000D8, "Member 'UDBDTextDesignTunables::SystemMessage_ChatReturnedToLobby' has a wrong offset!");
static_assert(offsetof(UDBDTextDesignTunables, SystemMessage_ChatMatchServerClosed) == 0x0000F0, "Member 'UDBDTextDesignTunables::SystemMessage_ChatMatchServerClosed' has a wrong offset!");

// Class DeadByDaylight.MapData
// 0x00B8 (0x00F0 - 0x0038)
class UMapData final : public UDataAsset
{
public:
	class FName                                   ThemeName;                                         // 0x0038(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ThemeWeather;                                      // 0x0044(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioStateThemes;                                  // 0x0050(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioStateWeather;                                 // 0x005C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioThemeEvent;                                   // 0x0068(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioLimitPointEvent;                              // 0x0074(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkAudioBank>            AudioThemeSoundBank;                               // 0x0080(0x0038)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapWidth;                                          // 0x00B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapHeight;                                         // 0x00BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Draft;                                             // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTileProperties>                MapTileProperties;                                 // 0x00C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UBlackboardData*                        Blackboard;                                        // 0x00D8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Gesture;                                           // 0x00E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UProceduralGenerationData*              _proceduralGenerationData;                         // 0x00E8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapData">();
	}
	static class UMapData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapData>();
	}
};
static_assert(alignof(UMapData) == 0x000008, "Wrong alignment on UMapData");
static_assert(sizeof(UMapData) == 0x0000F0, "Wrong size on UMapData");
static_assert(offsetof(UMapData, ThemeName) == 0x000038, "Member 'UMapData::ThemeName' has a wrong offset!");
static_assert(offsetof(UMapData, ThemeWeather) == 0x000044, "Member 'UMapData::ThemeWeather' has a wrong offset!");
static_assert(offsetof(UMapData, AudioStateThemes) == 0x000050, "Member 'UMapData::AudioStateThemes' has a wrong offset!");
static_assert(offsetof(UMapData, AudioStateWeather) == 0x00005C, "Member 'UMapData::AudioStateWeather' has a wrong offset!");
static_assert(offsetof(UMapData, AudioThemeEvent) == 0x000068, "Member 'UMapData::AudioThemeEvent' has a wrong offset!");
static_assert(offsetof(UMapData, AudioLimitPointEvent) == 0x000074, "Member 'UMapData::AudioLimitPointEvent' has a wrong offset!");
static_assert(offsetof(UMapData, AudioThemeSoundBank) == 0x000080, "Member 'UMapData::AudioThemeSoundBank' has a wrong offset!");
static_assert(offsetof(UMapData, MapWidth) == 0x0000B8, "Member 'UMapData::MapWidth' has a wrong offset!");
static_assert(offsetof(UMapData, MapHeight) == 0x0000BC, "Member 'UMapData::MapHeight' has a wrong offset!");
static_assert(offsetof(UMapData, Draft) == 0x0000C0, "Member 'UMapData::Draft' has a wrong offset!");
static_assert(offsetof(UMapData, MapTileProperties) == 0x0000C8, "Member 'UMapData::MapTileProperties' has a wrong offset!");
static_assert(offsetof(UMapData, Blackboard) == 0x0000D8, "Member 'UMapData::Blackboard' has a wrong offset!");
static_assert(offsetof(UMapData, Gesture) == 0x0000E0, "Member 'UMapData::Gesture' has a wrong offset!");
static_assert(offsetof(UMapData, _proceduralGenerationData) == 0x0000E8, "Member 'UMapData::_proceduralGenerationData' has a wrong offset!");

// Class DeadByDaylight.ActivationTimerRemainingCooldownElapsedIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActivationTimerRemainingCooldownElapsedIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivationTimerRemainingCooldownElapsedIconStrategy">();
	}
	static class UActivationTimerRemainingCooldownElapsedIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivationTimerRemainingCooldownElapsedIconStrategy>();
	}
};
static_assert(alignof(UActivationTimerRemainingCooldownElapsedIconStrategy) == 0x000008, "Wrong alignment on UActivationTimerRemainingCooldownElapsedIconStrategy");
static_assert(sizeof(UActivationTimerRemainingCooldownElapsedIconStrategy) == 0x000038, "Wrong size on UActivationTimerRemainingCooldownElapsedIconStrategy");

// Class DeadByDaylight.BaseBehaviourPenalty
// 0x0010 (0x0040 - 0x0030)
class UBaseBehaviourPenalty : public UObject
{
public:
	struct FGameplayTag                           _id;                                               // 0x0030(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseBehaviourPenalty">();
	}
	static class UBaseBehaviourPenalty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseBehaviourPenalty>();
	}
};
static_assert(alignof(UBaseBehaviourPenalty) == 0x000008, "Wrong alignment on UBaseBehaviourPenalty");
static_assert(sizeof(UBaseBehaviourPenalty) == 0x000040, "Wrong size on UBaseBehaviourPenalty");
static_assert(offsetof(UBaseBehaviourPenalty, _id) == 0x000030, "Member 'UBaseBehaviourPenalty::_id' has a wrong offset!");

// Class DeadByDaylight.BehaviourPenalty_AFKBotSetSuspectedPlayer
// 0x0000 (0x0040 - 0x0040)
class UBehaviourPenalty_AFKBotSetSuspectedPlayer final : public UBaseBehaviourPenalty
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BehaviourPenalty_AFKBotSetSuspectedPlayer">();
	}
	static class UBehaviourPenalty_AFKBotSetSuspectedPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBehaviourPenalty_AFKBotSetSuspectedPlayer>();
	}
};
static_assert(alignof(UBehaviourPenalty_AFKBotSetSuspectedPlayer) == 0x000008, "Wrong alignment on UBehaviourPenalty_AFKBotSetSuspectedPlayer");
static_assert(sizeof(UBehaviourPenalty_AFKBotSetSuspectedPlayer) == 0x000040, "Wrong size on UBehaviourPenalty_AFKBotSetSuspectedPlayer");

// Class DeadByDaylight.ActivationTimerRemainingPercentIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActivationTimerRemainingPercentIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivationTimerRemainingPercentIconStrategy">();
	}
	static class UActivationTimerRemainingPercentIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivationTimerRemainingPercentIconStrategy>();
	}
};
static_assert(alignof(UActivationTimerRemainingPercentIconStrategy) == 0x000008, "Wrong alignment on UActivationTimerRemainingPercentIconStrategy");
static_assert(sizeof(UActivationTimerRemainingPercentIconStrategy) == 0x000038, "Wrong size on UActivationTimerRemainingPercentIconStrategy");

// Class DeadByDaylight.ActiveOnTimerOrApplicablePerkIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActiveOnTimerOrApplicablePerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActiveOnTimerOrApplicablePerkIconStrategy">();
	}
	static class UActiveOnTimerOrApplicablePerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActiveOnTimerOrApplicablePerkIconStrategy>();
	}
};
static_assert(alignof(UActiveOnTimerOrApplicablePerkIconStrategy) == 0x000008, "Wrong alignment on UActiveOnTimerOrApplicablePerkIconStrategy");
static_assert(sizeof(UActiveOnTimerOrApplicablePerkIconStrategy) == 0x000038, "Wrong size on UActiveOnTimerOrApplicablePerkIconStrategy");

// Class DeadByDaylight.BaseSky
// 0x0168 (0x0408 - 0x02A0)
class ABaseSky final : public AActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          AdjustCullDistance;                                // 0x02A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A9[0x3];                                      // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IBLContributionMultiplier;                         // 0x02AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ProbesTintColor;                                   // 0x02B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProbesSaturationValue;                             // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBHVRPerDetailModeFloat                ASMDepthBias;                                      // 0x02C8(0x00A0)(Edit, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	struct FBHVRPerDetailModeFloat                ASMDepthAttenuation;                               // 0x0368(0x00A0)(Edit, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)

public:
	void CopyComponentsSettingsFromSource(class UStaticMeshComponent* moonMesh, class UDirectionalLightComponent* shadowLight, class UDirectionalLightComponent* godRayLight, class USkyLightComponent* SkyLight, class UExponentialHeightFogComponent* HeightFog, class UPostProcessComponent* postProcess, class UClass* sourceBaseSkyClass);
	class UPostProcessComponent* GetPostprocessComponent();
	class USceneComponent* GetVistasAndEnvironmentElements();
	void OnAlphaChanged(float newAlpha, class AActor* Other);
	void OnFadeBegin(class AActor* Other);
	void OnFadeEnd(class AActor* Other);
	void SetCullDistance(float NewCullDistance);
	void SetProbesTint(const struct FLinearColor& InColor, float inSaturation);
	void ToggleLightingChange(bool toggleOn, class FName ThemeName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseSky">();
	}
	static class ABaseSky* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseSky>();
	}
};
static_assert(alignof(ABaseSky) == 0x000008, "Wrong alignment on ABaseSky");
static_assert(sizeof(ABaseSky) == 0x000408, "Wrong size on ABaseSky");
static_assert(offsetof(ABaseSky, AdjustCullDistance) == 0x0002A8, "Member 'ABaseSky::AdjustCullDistance' has a wrong offset!");
static_assert(offsetof(ABaseSky, IBLContributionMultiplier) == 0x0002AC, "Member 'ABaseSky::IBLContributionMultiplier' has a wrong offset!");
static_assert(offsetof(ABaseSky, ProbesTintColor) == 0x0002B0, "Member 'ABaseSky::ProbesTintColor' has a wrong offset!");
static_assert(offsetof(ABaseSky, ProbesSaturationValue) == 0x0002C0, "Member 'ABaseSky::ProbesSaturationValue' has a wrong offset!");
static_assert(offsetof(ABaseSky, ASMDepthBias) == 0x0002C8, "Member 'ABaseSky::ASMDepthBias' has a wrong offset!");
static_assert(offsetof(ABaseSky, ASMDepthAttenuation) == 0x000368, "Member 'ABaseSky::ASMDepthAttenuation' has a wrong offset!");

// Class DeadByDaylight.ActiveOnTimerPerkIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActiveOnTimerPerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActiveOnTimerPerkIconStrategy">();
	}
	static class UActiveOnTimerPerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActiveOnTimerPerkIconStrategy>();
	}
};
static_assert(alignof(UActiveOnTimerPerkIconStrategy) == 0x000008, "Wrong alignment on UActiveOnTimerPerkIconStrategy");
static_assert(sizeof(UActiveOnTimerPerkIconStrategy) == 0x000038, "Wrong size on UActiveOnTimerPerkIconStrategy");

// Class DeadByDaylight.ActiveWhenApplicableAndActivationAndCooldownPerkIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActiveWhenApplicableAndActivationAndCooldownPerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActiveWhenApplicableAndActivationAndCooldownPerkIconStrategy">();
	}
	static class UActiveWhenApplicableAndActivationAndCooldownPerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActiveWhenApplicableAndActivationAndCooldownPerkIconStrategy>();
	}
};
static_assert(alignof(UActiveWhenApplicableAndActivationAndCooldownPerkIconStrategy) == 0x000008, "Wrong alignment on UActiveWhenApplicableAndActivationAndCooldownPerkIconStrategy");
static_assert(sizeof(UActiveWhenApplicableAndActivationAndCooldownPerkIconStrategy) == 0x000038, "Wrong size on UActiveWhenApplicableAndActivationAndCooldownPerkIconStrategy");

// Class DeadByDaylight.HooksWithSurvivorRestrictedPlacementAreaStrategy
// 0x0090 (0x0138 - 0x00A8)
class UHooksWithSurvivorRestrictedPlacementAreaStrategy final : public URestrictedPlacementAreaStrategy
{
public:
	struct FDBDTunableRowHandle                   RestrictedSphericalRadius;                         // 0x00A8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          _isRestrictionLingeringEnabled;                    // 0x00D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _restrictionLingerTime;                            // 0x00D8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_100[0x4];                                      // 0x0100(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _useSphericalZoneForBasementHooks;                 // 0x0104(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_105[0x13];                                     // 0x0105(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        RestrictedSphericalLocations;                      // 0x0118(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x10];                                     // 0x0128(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HooksWithSurvivorRestrictedPlacementAreaStrategy">();
	}
	static class UHooksWithSurvivorRestrictedPlacementAreaStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHooksWithSurvivorRestrictedPlacementAreaStrategy>();
	}
};
static_assert(alignof(UHooksWithSurvivorRestrictedPlacementAreaStrategy) == 0x000008, "Wrong alignment on UHooksWithSurvivorRestrictedPlacementAreaStrategy");
static_assert(sizeof(UHooksWithSurvivorRestrictedPlacementAreaStrategy) == 0x000138, "Wrong size on UHooksWithSurvivorRestrictedPlacementAreaStrategy");
static_assert(offsetof(UHooksWithSurvivorRestrictedPlacementAreaStrategy, RestrictedSphericalRadius) == 0x0000A8, "Member 'UHooksWithSurvivorRestrictedPlacementAreaStrategy::RestrictedSphericalRadius' has a wrong offset!");
static_assert(offsetof(UHooksWithSurvivorRestrictedPlacementAreaStrategy, _isRestrictionLingeringEnabled) == 0x0000D0, "Member 'UHooksWithSurvivorRestrictedPlacementAreaStrategy::_isRestrictionLingeringEnabled' has a wrong offset!");
static_assert(offsetof(UHooksWithSurvivorRestrictedPlacementAreaStrategy, _restrictionLingerTime) == 0x0000D8, "Member 'UHooksWithSurvivorRestrictedPlacementAreaStrategy::_restrictionLingerTime' has a wrong offset!");
static_assert(offsetof(UHooksWithSurvivorRestrictedPlacementAreaStrategy, _useSphericalZoneForBasementHooks) == 0x000104, "Member 'UHooksWithSurvivorRestrictedPlacementAreaStrategy::_useSphericalZoneForBasementHooks' has a wrong offset!");
static_assert(offsetof(UHooksWithSurvivorRestrictedPlacementAreaStrategy, RestrictedSphericalLocations) == 0x000118, "Member 'UHooksWithSurvivorRestrictedPlacementAreaStrategy::RestrictedSphericalLocations' has a wrong offset!");

// Class DeadByDaylight.ActiveWhenApplicableAndEnabledPerkIconStrategy
// 0x0008 (0x0040 - 0x0038)
class UActiveWhenApplicableAndEnabledPerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActiveWhenApplicableAndEnabledPerkIconStrategy">();
	}
	static class UActiveWhenApplicableAndEnabledPerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActiveWhenApplicableAndEnabledPerkIconStrategy>();
	}
};
static_assert(alignof(UActiveWhenApplicableAndEnabledPerkIconStrategy) == 0x000008, "Wrong alignment on UActiveWhenApplicableAndEnabledPerkIconStrategy");
static_assert(sizeof(UActiveWhenApplicableAndEnabledPerkIconStrategy) == 0x000040, "Wrong size on UActiveWhenApplicableAndEnabledPerkIconStrategy");

// Class DeadByDaylight.DBDGameSession
// 0x0060 (0x0320 - 0x02C0)
class ADBDGameSession final : public AGameSession
{
public:
	uint8                                         Pad_2C0[0x60];                                     // 0x02C0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGameSession">();
	}
	static class ADBDGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDGameSession>();
	}
};
static_assert(alignof(ADBDGameSession) == 0x000008, "Wrong alignment on ADBDGameSession");
static_assert(sizeof(ADBDGameSession) == 0x000320, "Wrong size on ADBDGameSession");

// Class DeadByDaylight.Tile
// 0x01C0 (0x0460 - 0x02A0)
class ATile : public AActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          RerunConstructionScript;                           // 0x02A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9[0x3];                                      // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinimumSpacing;                                    // 0x02AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumSpacing;                                    // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DiagonalSpacing;                                   // 0x02B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TypeSpacing;                                       // 0x02B5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B6[0x2];                                      // 0x02B6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaximumCount;                                      // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Dimension;                                         // 0x02C0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EscapeStrategyType>                    AvailableEscapeTypes;                              // 0x02D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETileType                                     Type;                                              // 0x02E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDensity                                      Density;                                           // 0x02E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPathType                                     Path;                                              // 0x02E2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E3[0x1];                                      // 0x02E3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Number;                                            // 0x02E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PlaceHolder;                                       // 0x02E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Replacement;                                       // 0x02E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EA[0x2];                                      // 0x02EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SpawnPriorityTier;                                 // 0x02EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Weight;                                            // 0x02F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Coord;                                             // 0x02F8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQuadrantSpawnType                            QuadrantSpawnType;                                 // 0x0308(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBasementType                                 BasementType;                                      // 0x0309(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30A[0x6];                                      // 0x030A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTileSpawnPoint*>                SpawnPointsCache;                                  // 0x0310(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UObjectRandomizer*>              ObjectRandomizersCache;                            // 0x0320(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UActorSpawner*>                  ActorSpawnersCache;                                // 0x0330(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UActorVariationSpawner*>         ActorVariationSpawnersCache;                       // 0x0340(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_350[0x7C];                                     // 0x0350(0x007C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRandomStream                          SharedTileRandomizer;                              // 0x03CC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsOutOfWorldTile;                                  // 0x03D4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseTileEventSpawnerSettingOverride;                // 0x03D5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D6[0x2];                                      // 0x03D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTileEventSpawnerSettingData           TileEventSpawnerSettingOverride;                   // 0x03D8(0x0028)(Edit, NativeAccessSpecifierPublic)
	bool                                          _initialized;                                      // 0x0400(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_401[0x5F];                                     // 0x0401(0x005F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitOnSpawned();
	void OnAllTileSpawned();
	void OnRep_Initialized(bool OldValue);
	void OnSetSpawnObject(class UTileSpawnPoint* TileSpawnPoint, class AActor* spawnedObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Tile">();
	}
	static class ATile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATile>();
	}
};
static_assert(alignof(ATile) == 0x000008, "Wrong alignment on ATile");
static_assert(sizeof(ATile) == 0x000460, "Wrong size on ATile");
static_assert(offsetof(ATile, RerunConstructionScript) == 0x0002A8, "Member 'ATile::RerunConstructionScript' has a wrong offset!");
static_assert(offsetof(ATile, MinimumSpacing) == 0x0002AC, "Member 'ATile::MinimumSpacing' has a wrong offset!");
static_assert(offsetof(ATile, MaximumSpacing) == 0x0002B0, "Member 'ATile::MaximumSpacing' has a wrong offset!");
static_assert(offsetof(ATile, DiagonalSpacing) == 0x0002B4, "Member 'ATile::DiagonalSpacing' has a wrong offset!");
static_assert(offsetof(ATile, TypeSpacing) == 0x0002B5, "Member 'ATile::TypeSpacing' has a wrong offset!");
static_assert(offsetof(ATile, MaximumCount) == 0x0002B8, "Member 'ATile::MaximumCount' has a wrong offset!");
static_assert(offsetof(ATile, Dimension) == 0x0002C0, "Member 'ATile::Dimension' has a wrong offset!");
static_assert(offsetof(ATile, AvailableEscapeTypes) == 0x0002D0, "Member 'ATile::AvailableEscapeTypes' has a wrong offset!");
static_assert(offsetof(ATile, Type) == 0x0002E0, "Member 'ATile::Type' has a wrong offset!");
static_assert(offsetof(ATile, Density) == 0x0002E1, "Member 'ATile::Density' has a wrong offset!");
static_assert(offsetof(ATile, Path) == 0x0002E2, "Member 'ATile::Path' has a wrong offset!");
static_assert(offsetof(ATile, Number) == 0x0002E4, "Member 'ATile::Number' has a wrong offset!");
static_assert(offsetof(ATile, PlaceHolder) == 0x0002E8, "Member 'ATile::PlaceHolder' has a wrong offset!");
static_assert(offsetof(ATile, Replacement) == 0x0002E9, "Member 'ATile::Replacement' has a wrong offset!");
static_assert(offsetof(ATile, SpawnPriorityTier) == 0x0002EC, "Member 'ATile::SpawnPriorityTier' has a wrong offset!");
static_assert(offsetof(ATile, Weight) == 0x0002F0, "Member 'ATile::Weight' has a wrong offset!");
static_assert(offsetof(ATile, Coord) == 0x0002F8, "Member 'ATile::Coord' has a wrong offset!");
static_assert(offsetof(ATile, QuadrantSpawnType) == 0x000308, "Member 'ATile::QuadrantSpawnType' has a wrong offset!");
static_assert(offsetof(ATile, BasementType) == 0x000309, "Member 'ATile::BasementType' has a wrong offset!");
static_assert(offsetof(ATile, SpawnPointsCache) == 0x000310, "Member 'ATile::SpawnPointsCache' has a wrong offset!");
static_assert(offsetof(ATile, ObjectRandomizersCache) == 0x000320, "Member 'ATile::ObjectRandomizersCache' has a wrong offset!");
static_assert(offsetof(ATile, ActorSpawnersCache) == 0x000330, "Member 'ATile::ActorSpawnersCache' has a wrong offset!");
static_assert(offsetof(ATile, ActorVariationSpawnersCache) == 0x000340, "Member 'ATile::ActorVariationSpawnersCache' has a wrong offset!");
static_assert(offsetof(ATile, SharedTileRandomizer) == 0x0003CC, "Member 'ATile::SharedTileRandomizer' has a wrong offset!");
static_assert(offsetof(ATile, IsOutOfWorldTile) == 0x0003D4, "Member 'ATile::IsOutOfWorldTile' has a wrong offset!");
static_assert(offsetof(ATile, UseTileEventSpawnerSettingOverride) == 0x0003D5, "Member 'ATile::UseTileEventSpawnerSettingOverride' has a wrong offset!");
static_assert(offsetof(ATile, TileEventSpawnerSettingOverride) == 0x0003D8, "Member 'ATile::TileEventSpawnerSettingOverride' has a wrong offset!");
static_assert(offsetof(ATile, _initialized) == 0x000400, "Member 'ATile::_initialized' has a wrong offset!");

// Class DeadByDaylight.ActiveWhenApplicableAndNotCampingPerkIconStrategy
// 0x0008 (0x0040 - 0x0038)
class UActiveWhenApplicableAndNotCampingPerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActiveWhenApplicableAndNotCampingPerkIconStrategy">();
	}
	static class UActiveWhenApplicableAndNotCampingPerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActiveWhenApplicableAndNotCampingPerkIconStrategy>();
	}
};
static_assert(alignof(UActiveWhenApplicableAndNotCampingPerkIconStrategy) == 0x000008, "Wrong alignment on UActiveWhenApplicableAndNotCampingPerkIconStrategy");
static_assert(sizeof(UActiveWhenApplicableAndNotCampingPerkIconStrategy) == 0x000040, "Wrong size on UActiveWhenApplicableAndNotCampingPerkIconStrategy");

// Class DeadByDaylight.BehaviourDetectionConfiguration
// 0x0010 (0x0048 - 0x0038)
class UBehaviourDetectionConfiguration final : public UDataAsset
{
public:
	TArray<struct FBehaviourDetectionClassConfiguration> _detectionClassConfigurations;              // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BehaviourDetectionConfiguration">();
	}
	static class UBehaviourDetectionConfiguration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBehaviourDetectionConfiguration>();
	}
};
static_assert(alignof(UBehaviourDetectionConfiguration) == 0x000008, "Wrong alignment on UBehaviourDetectionConfiguration");
static_assert(sizeof(UBehaviourDetectionConfiguration) == 0x000048, "Wrong size on UBehaviourDetectionConfiguration");
static_assert(offsetof(UBehaviourDetectionConfiguration, _detectionClassConfigurations) == 0x000038, "Member 'UBehaviourDetectionConfiguration::_detectionClassConfigurations' has a wrong offset!");

// Class DeadByDaylight.DesignTunableDataAsset
// 0x0248 (0x0280 - 0x0038)
class UDesignTunableDataAsset final : public UDataAsset
{
public:
	bool                                          _overrideDefaultLobby;                             // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _lobbyOverrideName;                                // 0x003C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   _conspicuousActionEvents;                          // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int8                                          EntityDispleasedKills;                             // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          BrutalKillerKills;                                 // 0x0059(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          RuthlessKillerKills;                               // 0x005A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          MercilessKillerKills;                              // 0x005B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WinStreakThresholdLarge;                           // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WinStreakThresholdSmall;                           // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxFearTokens;                                     // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QuantityOfItemsToBuyBeforeFreeBloodwebRefresh;     // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPerkLevelDefinition>           PerkLevelDefinitions;                              // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSet<struct FGameplayTag>                     MetaModifiers;                                     // 0x0080(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSet<struct FGameplayTag>                     RangedSurvivorAuraPerceptionModifiers;             // 0x00D0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSet<struct FGameplayTag>                     SurvivorRevelatoryAuraPerceptionModifiers;         // 0x0120(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSet<struct FGameplayTag>                     DisruptableAuraReadingFlags;                       // 0x0170(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   TextDesignTunableClass;                            // 0x01C0(0x0038)(Edit, BlueprintVisible, NoClear, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameEventForwarderInfo>        GameEventForwarderInfos;                           // 0x01F8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CoreUMGDesignTunableClass;                         // 0x0208(0x0038)(Edit, BlueprintVisible, NoClear, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMenuCameraDesignTunables> SoftMenuCameraDesignTunable;                     // 0x0240(0x0038)(Edit, BlueprintVisible, NoClear, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameTypeModifierDefaults*              GameTypeModifierDefaults;                          // 0x0278(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DesignTunableDataAsset">();
	}
	static class UDesignTunableDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDesignTunableDataAsset>();
	}
};
static_assert(alignof(UDesignTunableDataAsset) == 0x000008, "Wrong alignment on UDesignTunableDataAsset");
static_assert(sizeof(UDesignTunableDataAsset) == 0x000280, "Wrong size on UDesignTunableDataAsset");
static_assert(offsetof(UDesignTunableDataAsset, _overrideDefaultLobby) == 0x000038, "Member 'UDesignTunableDataAsset::_overrideDefaultLobby' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, _lobbyOverrideName) == 0x00003C, "Member 'UDesignTunableDataAsset::_lobbyOverrideName' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, _conspicuousActionEvents) == 0x000048, "Member 'UDesignTunableDataAsset::_conspicuousActionEvents' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, EntityDispleasedKills) == 0x000058, "Member 'UDesignTunableDataAsset::EntityDispleasedKills' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, BrutalKillerKills) == 0x000059, "Member 'UDesignTunableDataAsset::BrutalKillerKills' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, RuthlessKillerKills) == 0x00005A, "Member 'UDesignTunableDataAsset::RuthlessKillerKills' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, MercilessKillerKills) == 0x00005B, "Member 'UDesignTunableDataAsset::MercilessKillerKills' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, WinStreakThresholdLarge) == 0x00005C, "Member 'UDesignTunableDataAsset::WinStreakThresholdLarge' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, WinStreakThresholdSmall) == 0x000060, "Member 'UDesignTunableDataAsset::WinStreakThresholdSmall' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, MaxFearTokens) == 0x000064, "Member 'UDesignTunableDataAsset::MaxFearTokens' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, QuantityOfItemsToBuyBeforeFreeBloodwebRefresh) == 0x000068, "Member 'UDesignTunableDataAsset::QuantityOfItemsToBuyBeforeFreeBloodwebRefresh' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, PerkLevelDefinitions) == 0x000070, "Member 'UDesignTunableDataAsset::PerkLevelDefinitions' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, MetaModifiers) == 0x000080, "Member 'UDesignTunableDataAsset::MetaModifiers' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, RangedSurvivorAuraPerceptionModifiers) == 0x0000D0, "Member 'UDesignTunableDataAsset::RangedSurvivorAuraPerceptionModifiers' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, SurvivorRevelatoryAuraPerceptionModifiers) == 0x000120, "Member 'UDesignTunableDataAsset::SurvivorRevelatoryAuraPerceptionModifiers' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, DisruptableAuraReadingFlags) == 0x000170, "Member 'UDesignTunableDataAsset::DisruptableAuraReadingFlags' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, TextDesignTunableClass) == 0x0001C0, "Member 'UDesignTunableDataAsset::TextDesignTunableClass' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, GameEventForwarderInfos) == 0x0001F8, "Member 'UDesignTunableDataAsset::GameEventForwarderInfos' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, CoreUMGDesignTunableClass) == 0x000208, "Member 'UDesignTunableDataAsset::CoreUMGDesignTunableClass' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, SoftMenuCameraDesignTunable) == 0x000240, "Member 'UDesignTunableDataAsset::SoftMenuCameraDesignTunable' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, GameTypeModifierDefaults) == 0x000278, "Member 'UDesignTunableDataAsset::GameTypeModifierDefaults' has a wrong offset!");

// Class DeadByDaylight.ActiveWhenApplicablePerkIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActiveWhenApplicablePerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActiveWhenApplicablePerkIconStrategy">();
	}
	static class UActiveWhenApplicablePerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActiveWhenApplicablePerkIconStrategy>();
	}
};
static_assert(alignof(UActiveWhenApplicablePerkIconStrategy) == 0x000008, "Wrong alignment on UActiveWhenApplicablePerkIconStrategy");
static_assert(sizeof(UActiveWhenApplicablePerkIconStrategy) == 0x000038, "Wrong size on UActiveWhenApplicablePerkIconStrategy");

// Class DeadByDaylight.ActiveWhenKOdAndCooldownTimerPerkIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActiveWhenKOdAndCooldownTimerPerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActiveWhenKOdAndCooldownTimerPerkIconStrategy">();
	}
	static class UActiveWhenKOdAndCooldownTimerPerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActiveWhenKOdAndCooldownTimerPerkIconStrategy>();
	}
};
static_assert(alignof(UActiveWhenKOdAndCooldownTimerPerkIconStrategy) == 0x000008, "Wrong alignment on UActiveWhenKOdAndCooldownTimerPerkIconStrategy");
static_assert(sizeof(UActiveWhenKOdAndCooldownTimerPerkIconStrategy) == 0x000038, "Wrong size on UActiveWhenKOdAndCooldownTimerPerkIconStrategy");

// Class DeadByDaylight.BlindingEffectorInterface
// 0x0000 (0x0000 - 0x0000)
class IBlindingEffectorInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlindingEffectorInterface">();
	}
	static class IBlindingEffectorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBlindingEffectorInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IBlindingEffectorInterface) == 0x000001, "Wrong alignment on IBlindingEffectorInterface");
static_assert(sizeof(IBlindingEffectorInterface) == 0x000001, "Wrong size on IBlindingEffectorInterface");

// Class DeadByDaylight.ActorClipperComponent
// 0x0080 (0x0138 - 0x00B8)
class UActorClipperComponent final : public UActorComponent
{
public:
	class USphereComponent*                       Shape;                                             // 0x00B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class AActor*, struct FClippedActor>     _clippedActors;                                    // 0x00C0(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UPrimitiveCollection>    _clippables;                                       // 0x0110(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x20];                                     // 0x0118(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCameraChanged(EDBDCameraSocketID socketId);
	void OnOwnerLocallyObservedChanged(bool locallyObserved);
	void SetPrimitiveCollection(const class UPrimitiveCollection* clippables);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorClipperComponent">();
	}
	static class UActorClipperComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorClipperComponent>();
	}
};
static_assert(alignof(UActorClipperComponent) == 0x000008, "Wrong alignment on UActorClipperComponent");
static_assert(sizeof(UActorClipperComponent) == 0x000138, "Wrong size on UActorClipperComponent");
static_assert(offsetof(UActorClipperComponent, Shape) == 0x0000B8, "Member 'UActorClipperComponent::Shape' has a wrong offset!");
static_assert(offsetof(UActorClipperComponent, _clippedActors) == 0x0000C0, "Member 'UActorClipperComponent::_clippedActors' has a wrong offset!");
static_assert(offsetof(UActorClipperComponent, _clippables) == 0x000110, "Member 'UActorClipperComponent::_clippables' has a wrong offset!");

// Class DeadByDaylight.ActorComponentExt
// 0x0000 (0x0030 - 0x0030)
class UActorComponentExt final : public UBlueprintFunctionLibrary
{
public:
	static class ACharacter* GetOwningCharacter(const class UActorComponent* ActorComponent, bool recursiveSearch);
	static class ACharacter* GetOwningCharacterChecked(const class UActorComponent* ActorComponent, bool recursiveSearch);
	static class AKiller* GetOwningKiller(const class UActorComponent* ActorComponent, bool recursiveSearch);
	static class APawn* GetOwningPawn(const class UActorComponent* ActorComponent, bool recursiveSearch);
	static class APawn* GetOwningPawnChecked(const class UActorComponent* ActorComponent, bool recursiveSearch);
	static class ADBDPlayer* GetOwningPlayer(const class UActorComponent* ActorComponent, bool recursiveSearch);
	static class ADBDPlayer* GetOwningPlayerChecked(const class UActorComponent* ActorComponent, bool recursiveSearch);
	static class ADBDPlayer* GetOwningPlayerInHierarchy(const class UActorComponent* ActorComponent);
	static class ASurvivor* GetOwningSurvivor(const class UActorComponent* ActorComponent, bool recursiveSearch);
	static class ASurvivor* GetOwningSurvivorChecked(const class UActorComponent* ActorComponent, bool recursiveSearch);
	static class AActor* GetValidatedOwner(const class UActorComponent* ActorComponent);
	static bool HasAuthority(const class UActorComponent* ActorComponent);
	static bool IsLocallyControlled(const class UActorComponent* ActorComponent, bool recursiveSearch);
	static bool IsLocallyObserved(const class UActorComponent* ActorComponent, bool recursiveSearch);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorComponentExt">();
	}
	static class UActorComponentExt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorComponentExt>();
	}
};
static_assert(alignof(UActorComponentExt) == 0x000008, "Wrong alignment on UActorComponentExt");
static_assert(sizeof(UActorComponentExt) == 0x000030, "Wrong size on UActorComponentExt");

// Class DeadByDaylight.SurvivorPlagueEffect
// 0x01F8 (0x0590 - 0x0398)
class USurvivorPlagueEffect final : public UStatusEffect
{
public:
	uint8                                         Pad_398[0x48];                                     // 0x0398(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _sicknessAmount;                                   // 0x03E0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sicknessCap;                                      // 0x03E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _vomitSlowDuration;                                // 0x03E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _vomitSlowAmount;                                  // 0x03EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<float>                                 _sicknessThresholds;                               // 0x03F0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          _wasRecentlyHitByVomit;                            // 0x0400(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_401[0x7];                                      // 0x0401(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         _nonNauseatingInteractions;                        // 0x0408(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_418[0x18];                                     // 0x0418(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTunableStat                           _sicknessGainPerSecondFromInfectedInteractable;    // 0x0430(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B0[0x88];                                     // 0x04B0(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _debugMode;                                        // 0x0538(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_539[0x47];                                     // 0x0539(0x0047)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _exposeMaximumSickSurvivorEffect;                  // 0x0580(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _brokenMaximumSickSurvivorEffect;                  // 0x0588(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_AddSickness(float sicknessToAdd);
	void Authority_InfectInteractable(class AInteractable* Interactable);
	void Authority_OnHitBySuperVomitProjectile();
	void Authority_OnHitByVomitProjectile(float sicknessToAdd);
	void Authority_OnHitByVomitProjectileAesthetic();
	void Authority_ResetSickness(float newSickness);
	void Multicast_AddOnScreenDebugMessage(uint64 Key, float Duration, const struct FColor& DisplayColor, const class FString& debugMessage);
	void Multicast_OnMaxSicknessReached();
	void Multicast_OnSicknessChanged(float newSickness);
	void Multicast_OnSicknessCured();
	void Multicast_OnSurvivorBecomesInfected();
	void Multicast_OnSurvivorVomit();
	void OnHitByVomit(bool isSuperVomit);
	void OnMaxSicknessReached_Aesthetic();
	void OnRep_SicknessAmount();
	void OnSicknessChanged_Aesthetic(float newSickness);
	void OnSicknessCured_Aesthetic();
	void OnSurvivorBecomesInfected_Aesthetic();
	void OnSurvivorDisguisedOrUndisguised(bool isDisguised);
	void OnSurvivorVomit_Aesthetic();
	void RefreshSicknessGainValues();

	uint8 GetMaxSicknessLevel() const;
	float GetSicknessAmount() const;
	uint8 GetSicknessLevel() const;
	float GetSicknessPercentage() const;
	TArray<float> GetSicknessThresholds() const;
	bool HasMaxLevelSickness() const;
	bool IsDebugModeActive() const;
	bool IsInfected() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorPlagueEffect">();
	}
	static class USurvivorPlagueEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorPlagueEffect>();
	}
};
static_assert(alignof(USurvivorPlagueEffect) == 0x000008, "Wrong alignment on USurvivorPlagueEffect");
static_assert(sizeof(USurvivorPlagueEffect) == 0x000590, "Wrong size on USurvivorPlagueEffect");
static_assert(offsetof(USurvivorPlagueEffect, _sicknessAmount) == 0x0003E0, "Member 'USurvivorPlagueEffect::_sicknessAmount' has a wrong offset!");
static_assert(offsetof(USurvivorPlagueEffect, _sicknessCap) == 0x0003E4, "Member 'USurvivorPlagueEffect::_sicknessCap' has a wrong offset!");
static_assert(offsetof(USurvivorPlagueEffect, _vomitSlowDuration) == 0x0003E8, "Member 'USurvivorPlagueEffect::_vomitSlowDuration' has a wrong offset!");
static_assert(offsetof(USurvivorPlagueEffect, _vomitSlowAmount) == 0x0003EC, "Member 'USurvivorPlagueEffect::_vomitSlowAmount' has a wrong offset!");
static_assert(offsetof(USurvivorPlagueEffect, _sicknessThresholds) == 0x0003F0, "Member 'USurvivorPlagueEffect::_sicknessThresholds' has a wrong offset!");
static_assert(offsetof(USurvivorPlagueEffect, _wasRecentlyHitByVomit) == 0x000400, "Member 'USurvivorPlagueEffect::_wasRecentlyHitByVomit' has a wrong offset!");
static_assert(offsetof(USurvivorPlagueEffect, _nonNauseatingInteractions) == 0x000408, "Member 'USurvivorPlagueEffect::_nonNauseatingInteractions' has a wrong offset!");
static_assert(offsetof(USurvivorPlagueEffect, _sicknessGainPerSecondFromInfectedInteractable) == 0x000430, "Member 'USurvivorPlagueEffect::_sicknessGainPerSecondFromInfectedInteractable' has a wrong offset!");
static_assert(offsetof(USurvivorPlagueEffect, _debugMode) == 0x000538, "Member 'USurvivorPlagueEffect::_debugMode' has a wrong offset!");
static_assert(offsetof(USurvivorPlagueEffect, _exposeMaximumSickSurvivorEffect) == 0x000580, "Member 'USurvivorPlagueEffect::_exposeMaximumSickSurvivorEffect' has a wrong offset!");
static_assert(offsetof(USurvivorPlagueEffect, _brokenMaximumSickSurvivorEffect) == 0x000588, "Member 'USurvivorPlagueEffect::_brokenMaximumSickSurvivorEffect' has a wrong offset!");

// Class DeadByDaylight.BehaviourPenalty_DisableCollisions
// 0x0018 (0x0058 - 0x0040)
class UBehaviourPenalty_DisableCollisions final : public UBaseBehaviourPenalty
{
public:
	float                                         _time;                                             // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADBDPlayer>              _player;                                           // 0x0044(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0xC];                                       // 0x004C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void TimerDone() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BehaviourPenalty_DisableCollisions">();
	}
	static class UBehaviourPenalty_DisableCollisions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBehaviourPenalty_DisableCollisions>();
	}
};
static_assert(alignof(UBehaviourPenalty_DisableCollisions) == 0x000008, "Wrong alignment on UBehaviourPenalty_DisableCollisions");
static_assert(sizeof(UBehaviourPenalty_DisableCollisions) == 0x000058, "Wrong size on UBehaviourPenalty_DisableCollisions");
static_assert(offsetof(UBehaviourPenalty_DisableCollisions, _time) == 0x000040, "Member 'UBehaviourPenalty_DisableCollisions::_time' has a wrong offset!");
static_assert(offsetof(UBehaviourPenalty_DisableCollisions, _player) == 0x000044, "Member 'UBehaviourPenalty_DisableCollisions::_player' has a wrong offset!");

// Class DeadByDaylight.ActorDependency
// 0x0010 (0x00C8 - 0x00B8)
class UActorDependency final : public UActorComponent
{
public:
	TArray<struct FDependency>                    Dependencies;                                      // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorDependency">();
	}
	static class UActorDependency* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorDependency>();
	}
};
static_assert(alignof(UActorDependency) == 0x000008, "Wrong alignment on UActorDependency");
static_assert(sizeof(UActorDependency) == 0x0000C8, "Wrong size on UActorDependency");
static_assert(offsetof(UActorDependency, Dependencies) == 0x0000B8, "Member 'UActorDependency::Dependencies' has a wrong offset!");

// Class DeadByDaylight.ActorDetectorComponent
// 0x0028 (0x00E0 - 0x00B8)
class UActorDetectorComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(class AActor* Actor)> OnActorDetected;                             // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UClass*>                         CollectedTypes;                                    // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    _primitive;                                        // 0x00D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnOverlapEnter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void SetDetectionPrimitive(class UPrimitiveComponent* Primitive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorDetectorComponent">();
	}
	static class UActorDetectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorDetectorComponent>();
	}
};
static_assert(alignof(UActorDetectorComponent) == 0x000008, "Wrong alignment on UActorDetectorComponent");
static_assert(sizeof(UActorDetectorComponent) == 0x0000E0, "Wrong size on UActorDetectorComponent");
static_assert(offsetof(UActorDetectorComponent, OnActorDetected) == 0x0000B8, "Member 'UActorDetectorComponent::OnActorDetected' has a wrong offset!");
static_assert(offsetof(UActorDetectorComponent, CollectedTypes) == 0x0000C8, "Member 'UActorDetectorComponent::CollectedTypes' has a wrong offset!");
static_assert(offsetof(UActorDetectorComponent, _primitive) == 0x0000D8, "Member 'UActorDetectorComponent::_primitive' has a wrong offset!");

// Class DeadByDaylight.InteractionAnimNotify
// 0x0010 (0x0050 - 0x0040)
class UInteractionAnimNotify final : public UAnimNotify
{
public:
	class FName                                   NotifyId;                                          // 0x0040(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionAnimNotify">();
	}
	static class UInteractionAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionAnimNotify>();
	}
};
static_assert(alignof(UInteractionAnimNotify) == 0x000008, "Wrong alignment on UInteractionAnimNotify");
static_assert(sizeof(UInteractionAnimNotify) == 0x000050, "Wrong size on UInteractionAnimNotify");
static_assert(offsetof(UInteractionAnimNotify, NotifyId) == 0x000040, "Member 'UInteractionAnimNotify::NotifyId' has a wrong offset!");

// Class DeadByDaylight.BaseBehaviourDetectionComponent
// 0x0070 (0x0128 - 0x00B8)
class UBaseBehaviourDetectionComponent : public UActorComponent
{
public:
	TArray<TSubclassOf<class UBaseBehaviourPenalty>> _penaltyClasses;                                // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _id;                                               // 0x00C8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, class UBaseBehaviourPenalty*> _penalties;                              // 0x00D8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	void StartMonitoring();
	void StopMonitoring();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseBehaviourDetectionComponent">();
	}
	static class UBaseBehaviourDetectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseBehaviourDetectionComponent>();
	}
};
static_assert(alignof(UBaseBehaviourDetectionComponent) == 0x000008, "Wrong alignment on UBaseBehaviourDetectionComponent");
static_assert(sizeof(UBaseBehaviourDetectionComponent) == 0x000128, "Wrong size on UBaseBehaviourDetectionComponent");
static_assert(offsetof(UBaseBehaviourDetectionComponent, _penaltyClasses) == 0x0000B8, "Member 'UBaseBehaviourDetectionComponent::_penaltyClasses' has a wrong offset!");
static_assert(offsetof(UBaseBehaviourDetectionComponent, _id) == 0x0000C8, "Member 'UBaseBehaviourDetectionComponent::_id' has a wrong offset!");
static_assert(offsetof(UBaseBehaviourDetectionComponent, _penalties) == 0x0000D8, "Member 'UBaseBehaviourDetectionComponent::_penalties' has a wrong offset!");

// Class DeadByDaylight.BehaviourDetectionComponent_GoingNext
// 0x0110 (0x0238 - 0x0128)
class UBehaviourDetectionComponent_GoingNext final : public UBaseBehaviourDetectionComponent
{
public:
	struct FDBDTunableRowHandle                   _timeLimit;                                        // 0x0128(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _gracePeriodDuration;                              // 0x0150(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _hookTimeLimit;                                    // 0x0178(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _requiredEmblemPoints;                             // 0x01A0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C8[0x70];                                     // 0x01C8(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BehaviourDetectionComponent_GoingNext">();
	}
	static class UBehaviourDetectionComponent_GoingNext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBehaviourDetectionComponent_GoingNext>();
	}
};
static_assert(alignof(UBehaviourDetectionComponent_GoingNext) == 0x000008, "Wrong alignment on UBehaviourDetectionComponent_GoingNext");
static_assert(sizeof(UBehaviourDetectionComponent_GoingNext) == 0x000238, "Wrong size on UBehaviourDetectionComponent_GoingNext");
static_assert(offsetof(UBehaviourDetectionComponent_GoingNext, _timeLimit) == 0x000128, "Member 'UBehaviourDetectionComponent_GoingNext::_timeLimit' has a wrong offset!");
static_assert(offsetof(UBehaviourDetectionComponent_GoingNext, _gracePeriodDuration) == 0x000150, "Member 'UBehaviourDetectionComponent_GoingNext::_gracePeriodDuration' has a wrong offset!");
static_assert(offsetof(UBehaviourDetectionComponent_GoingNext, _hookTimeLimit) == 0x000178, "Member 'UBehaviourDetectionComponent_GoingNext::_hookTimeLimit' has a wrong offset!");
static_assert(offsetof(UBehaviourDetectionComponent_GoingNext, _requiredEmblemPoints) == 0x0001A0, "Member 'UBehaviourDetectionComponent_GoingNext::_requiredEmblemPoints' has a wrong offset!");

// Class DeadByDaylight.SupplyCrateAnimInstance
// 0x0010 (0x0370 - 0x0360)
class USupplyCrateAnimInstance final : public USleepingAnimInstance
{
public:
	class ASupplyCrateInteractable*               _owningSupplyCrate;                                // 0x0360(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOpen;                                           // 0x0368(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingPriedOpen;                                 // 0x0369(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAutoClosing;                                    // 0x036A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36B[0x5];                                      // 0x036B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeingPriedOpenStarted(class ADBDPlayer* Player);
	void OnBeingPriedOpenStopped();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplyCrateAnimInstance">();
	}
	static class USupplyCrateAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USupplyCrateAnimInstance>();
	}
};
static_assert(alignof(USupplyCrateAnimInstance) == 0x000010, "Wrong alignment on USupplyCrateAnimInstance");
static_assert(sizeof(USupplyCrateAnimInstance) == 0x000370, "Wrong size on USupplyCrateAnimInstance");
static_assert(offsetof(USupplyCrateAnimInstance, _owningSupplyCrate) == 0x000360, "Member 'USupplyCrateAnimInstance::_owningSupplyCrate' has a wrong offset!");
static_assert(offsetof(USupplyCrateAnimInstance, _isOpen) == 0x000368, "Member 'USupplyCrateAnimInstance::_isOpen' has a wrong offset!");
static_assert(offsetof(USupplyCrateAnimInstance, _isBeingPriedOpen) == 0x000369, "Member 'USupplyCrateAnimInstance::_isBeingPriedOpen' has a wrong offset!");
static_assert(offsetof(USupplyCrateAnimInstance, _isAutoClosing) == 0x00036A, "Member 'USupplyCrateAnimInstance::_isAutoClosing' has a wrong offset!");

// Class DeadByDaylight.ActorInstanceProperties
// 0x0080 (0x00B0 - 0x0030)
class UActorInstanceProperties final : public UObject
{
public:
	struct FObjectTransformId                     _actorId;                                          // 0x0030(0x0070)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class UActorComponent*>                _savedComponents;                                  // 0x00A0(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorInstanceProperties">();
	}
	static class UActorInstanceProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorInstanceProperties>();
	}
};
static_assert(alignof(UActorInstanceProperties) == 0x000010, "Wrong alignment on UActorInstanceProperties");
static_assert(sizeof(UActorInstanceProperties) == 0x0000B0, "Wrong size on UActorInstanceProperties");
static_assert(offsetof(UActorInstanceProperties, _actorId) == 0x000030, "Member 'UActorInstanceProperties::_actorId' has a wrong offset!");
static_assert(offsetof(UActorInstanceProperties, _savedComponents) == 0x0000A0, "Member 'UActorInstanceProperties::_savedComponents' has a wrong offset!");

// Class DeadByDaylight.ActorInstancePropertiesComponent
// 0x0010 (0x00C8 - 0x00B8)
class UActorInstancePropertiesComponent final : public UActorComponent
{
public:
	TArray<class UActorInstanceProperties*>       _actorInstancePropertiesList;                      // 0x00B8(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorInstancePropertiesComponent">();
	}
	static class UActorInstancePropertiesComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorInstancePropertiesComponent>();
	}
};
static_assert(alignof(UActorInstancePropertiesComponent) == 0x000008, "Wrong alignment on UActorInstancePropertiesComponent");
static_assert(sizeof(UActorInstancePropertiesComponent) == 0x0000C8, "Wrong size on UActorInstancePropertiesComponent");
static_assert(offsetof(UActorInstancePropertiesComponent, _actorInstancePropertiesList) == 0x0000B8, "Member 'UActorInstancePropertiesComponent::_actorInstancePropertiesList' has a wrong offset!");

// Class DeadByDaylight.UMGBaseAlertWidget
// 0x0048 (0x02F0 - 0x02A8)
class UUMGBaseAlertWidget : public UUserWidget
{
public:
	uint8                                         Pad_2A8[0x48];                                     // 0x02A8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGBaseAlertWidget">();
	}
	static class UUMGBaseAlertWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGBaseAlertWidget>();
	}
};
static_assert(alignof(UUMGBaseAlertWidget) == 0x000008, "Wrong alignment on UUMGBaseAlertWidget");
static_assert(sizeof(UUMGBaseAlertWidget) == 0x0002F0, "Wrong size on UUMGBaseAlertWidget");

// Class DeadByDaylight.UMGScoreAlertWidget
// 0x0000 (0x02F0 - 0x02F0)
class UUMGScoreAlertWidget final : public UUMGBaseAlertWidget
{
public:
	void UpdateWidget(EDBDScoreCategory ScoreType, const class FString& Title, int32 ScoreValue, float Progress, const class FText& defaultScoreText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGScoreAlertWidget">();
	}
	static class UUMGScoreAlertWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGScoreAlertWidget>();
	}
};
static_assert(alignof(UUMGScoreAlertWidget) == 0x000008, "Wrong alignment on UUMGScoreAlertWidget");
static_assert(sizeof(UUMGScoreAlertWidget) == 0x0002F0, "Wrong size on UUMGScoreAlertWidget");

// Class DeadByDaylight.BlessedVignetteController
// 0x0010 (0x00C8 - 0x00B8)
class UBlessedVignetteController final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActivateBlessedVignette();
	void OnDeactivateBlessedVignette();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlessedVignetteController">();
	}
	static class UBlessedVignetteController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlessedVignetteController>();
	}
};
static_assert(alignof(UBlessedVignetteController) == 0x000008, "Wrong alignment on UBlessedVignetteController");
static_assert(sizeof(UBlessedVignetteController) == 0x0000C8, "Wrong size on UBlessedVignetteController");

// Class DeadByDaylight.ActorKnowledgeCollection
// 0x0050 (0x0108 - 0x00B8)
class UActorKnowledgeCollection final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         _actors;                                           // 0x00D0(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         _previousActors;                                   // 0x00E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	bool                                          _available;                                        // 0x00F0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             _possessor;                                        // 0x00F8(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EKnowledgeSharingType                         _sharing;                                          // 0x0100(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool Authority_Add(class AActor* Actor);
	void Authority_Append(const TArray<class AActor*>& Actors);
	void Authority_Empty();
	void Authority_Remove(class AActor* Actor);
	void Authority_SetAvailable(bool Value);
	void Authority_SetPossessor(class ACharacter* possessor);
	void Authority_SetSharingType(EKnowledgeSharingType Value);
	void Local_SetAvailable(bool Value);
	void OnRep_Actors();

	bool Contains(class AActor* Actor) const;
	bool IsAvailable(const class ACharacter* Character) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorKnowledgeCollection">();
	}
	static class UActorKnowledgeCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorKnowledgeCollection>();
	}
};
static_assert(alignof(UActorKnowledgeCollection) == 0x000008, "Wrong alignment on UActorKnowledgeCollection");
static_assert(sizeof(UActorKnowledgeCollection) == 0x000108, "Wrong size on UActorKnowledgeCollection");
static_assert(offsetof(UActorKnowledgeCollection, _actors) == 0x0000D0, "Member 'UActorKnowledgeCollection::_actors' has a wrong offset!");
static_assert(offsetof(UActorKnowledgeCollection, _previousActors) == 0x0000E0, "Member 'UActorKnowledgeCollection::_previousActors' has a wrong offset!");
static_assert(offsetof(UActorKnowledgeCollection, _available) == 0x0000F0, "Member 'UActorKnowledgeCollection::_available' has a wrong offset!");
static_assert(offsetof(UActorKnowledgeCollection, _possessor) == 0x0000F8, "Member 'UActorKnowledgeCollection::_possessor' has a wrong offset!");
static_assert(offsetof(UActorKnowledgeCollection, _sharing) == 0x000100, "Member 'UActorKnowledgeCollection::_sharing' has a wrong offset!");

// Class DeadByDaylight.MeatHookStateMachine
// 0x0000 (0x0130 - 0x0130)
class UMeatHookStateMachine final : public UStateMachine
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeatHookStateMachine">();
	}
	static class UMeatHookStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeatHookStateMachine>();
	}
};
static_assert(alignof(UMeatHookStateMachine) == 0x000010, "Wrong alignment on UMeatHookStateMachine");
static_assert(sizeof(UMeatHookStateMachine) == 0x000130, "Wrong size on UMeatHookStateMachine");

// Class DeadByDaylight.ActorPairQueryEvaluatorUtilities
// 0x0000 (0x0030 - 0x0030)
class UActorPairQueryEvaluatorUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorPairQueryEvaluatorUtilities">();
	}
	static class UActorPairQueryEvaluatorUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorPairQueryEvaluatorUtilities>();
	}
};
static_assert(alignof(UActorPairQueryEvaluatorUtilities) == 0x000008, "Wrong alignment on UActorPairQueryEvaluatorUtilities");
static_assert(sizeof(UActorPairQueryEvaluatorUtilities) == 0x000030, "Wrong size on UActorPairQueryEvaluatorUtilities");

// Class DeadByDaylight.BloodwebTunables
// 0x0000 (0x0030 - 0x0030)
class UBloodwebTunables : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodwebTunables">();
	}
	static class UBloodwebTunables* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodwebTunables>();
	}
};
static_assert(alignof(UBloodwebTunables) == 0x000008, "Wrong alignment on UBloodwebTunables");
static_assert(sizeof(UBloodwebTunables) == 0x000030, "Wrong size on UBloodwebTunables");

// Class DeadByDaylight.BloodwebClientTunables
// 0x0000 (0x0030 - 0x0030)
class UBloodwebClientTunables final : public UBloodwebTunables
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodwebClientTunables">();
	}
	static class UBloodwebClientTunables* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodwebClientTunables>();
	}
};
static_assert(alignof(UBloodwebClientTunables) == 0x000008, "Wrong alignment on UBloodwebClientTunables");
static_assert(sizeof(UBloodwebClientTunables) == 0x000030, "Wrong size on UBloodwebClientTunables");

// Class DeadByDaylight.ActorSpawner
// 0x00E0 (0x03B0 - 0x02D0)
class UActorSpawner : public USceneComponent
{
public:
	uint8                                         Pad_2D0[0x10];                                     // 0x02D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EGameplayElementType                          Type;                                              // 0x02E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E1[0x7];                                      // 0x02E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   Visualization;                                     // 0x02E8(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ActivatedByDefault;                                // 0x0320(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_321[0x7];                                      // 0x0321(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FActorSpawnerProperties>        ActivatedSceneElement;                             // 0x0328(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FActorSpawnerProperties>        DeactivatedSceneElement;                           // 0x0338(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	double                                        Weight;                                            // 0x0348(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnCountMax;                                     // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnPriorityTier;                                 // 0x0354(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           TagsToBePassedOverToActor;                         // 0x0358(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          AttachSpawnedActorToAttachedSocket;                // 0x0368(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_369[0x7];                                      // 0x0369(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AActor* actorSpawned)> OnAsyncActorSpawned;                  // 0x0370(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_380[0x8];                                      // 0x0380(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          WeightInfluenceable;                               // 0x0388(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          WeightInfluencer;                                  // 0x0389(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38A[0x2];                                      // 0x038A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Cost;                                              // 0x038C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClass*                                 _toSpawn;                                          // 0x0390(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  _spawnedActorOnAuthority;                          // 0x03A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_SpawnActorAsyncEvent();
	void AuthoritySelect(bool Selected);
	void EditorForceSpawnVisualization();

	class AActor* AuthorityGetSpawnedActor() const;
	bool IsEnabled() const;
	bool UseActivatedElement() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorSpawner">();
	}
	static class UActorSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorSpawner>();
	}
};
static_assert(alignof(UActorSpawner) == 0x000010, "Wrong alignment on UActorSpawner");
static_assert(sizeof(UActorSpawner) == 0x0003B0, "Wrong size on UActorSpawner");
static_assert(offsetof(UActorSpawner, Type) == 0x0002E0, "Member 'UActorSpawner::Type' has a wrong offset!");
static_assert(offsetof(UActorSpawner, Visualization) == 0x0002E8, "Member 'UActorSpawner::Visualization' has a wrong offset!");
static_assert(offsetof(UActorSpawner, ActivatedByDefault) == 0x000320, "Member 'UActorSpawner::ActivatedByDefault' has a wrong offset!");
static_assert(offsetof(UActorSpawner, ActivatedSceneElement) == 0x000328, "Member 'UActorSpawner::ActivatedSceneElement' has a wrong offset!");
static_assert(offsetof(UActorSpawner, DeactivatedSceneElement) == 0x000338, "Member 'UActorSpawner::DeactivatedSceneElement' has a wrong offset!");
static_assert(offsetof(UActorSpawner, Weight) == 0x000348, "Member 'UActorSpawner::Weight' has a wrong offset!");
static_assert(offsetof(UActorSpawner, SpawnCountMax) == 0x000350, "Member 'UActorSpawner::SpawnCountMax' has a wrong offset!");
static_assert(offsetof(UActorSpawner, SpawnPriorityTier) == 0x000354, "Member 'UActorSpawner::SpawnPriorityTier' has a wrong offset!");
static_assert(offsetof(UActorSpawner, TagsToBePassedOverToActor) == 0x000358, "Member 'UActorSpawner::TagsToBePassedOverToActor' has a wrong offset!");
static_assert(offsetof(UActorSpawner, AttachSpawnedActorToAttachedSocket) == 0x000368, "Member 'UActorSpawner::AttachSpawnedActorToAttachedSocket' has a wrong offset!");
static_assert(offsetof(UActorSpawner, OnAsyncActorSpawned) == 0x000370, "Member 'UActorSpawner::OnAsyncActorSpawned' has a wrong offset!");
static_assert(offsetof(UActorSpawner, WeightInfluenceable) == 0x000388, "Member 'UActorSpawner::WeightInfluenceable' has a wrong offset!");
static_assert(offsetof(UActorSpawner, WeightInfluencer) == 0x000389, "Member 'UActorSpawner::WeightInfluencer' has a wrong offset!");
static_assert(offsetof(UActorSpawner, Cost) == 0x00038C, "Member 'UActorSpawner::Cost' has a wrong offset!");
static_assert(offsetof(UActorSpawner, _toSpawn) == 0x000390, "Member 'UActorSpawner::_toSpawn' has a wrong offset!");
static_assert(offsetof(UActorSpawner, _spawnedActorOnAuthority) == 0x0003A0, "Member 'UActorSpawner::_spawnedActorOnAuthority' has a wrong offset!");

// Class DeadByDaylight.ObjectRandomizer
// 0x0020 (0x02F0 - 0x02D0)
#pragma pack(push, 0x1)
class alignas(0x10) UObjectRandomizer : public USceneComponent
{
public:
	TArray<class UActorSpawner*>                  Spawners;                                          // 0x02D0(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         MinPopulation;                                     // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPopulation;                                     // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectRandomizer">();
	}
	static class UObjectRandomizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectRandomizer>();
	}
};
#pragma pack(pop)
static_assert(alignof(UObjectRandomizer) == 0x000010, "Wrong alignment on UObjectRandomizer");
static_assert(sizeof(UObjectRandomizer) == 0x0002F0, "Wrong size on UObjectRandomizer");
static_assert(offsetof(UObjectRandomizer, Spawners) == 0x0002D0, "Member 'UObjectRandomizer::Spawners' has a wrong offset!");
static_assert(offsetof(UObjectRandomizer, MinPopulation) == 0x0002E0, "Member 'UObjectRandomizer::MinPopulation' has a wrong offset!");
static_assert(offsetof(UObjectRandomizer, MaxPopulation) == 0x0002E4, "Member 'UObjectRandomizer::MaxPopulation' has a wrong offset!");

// Class DeadByDaylight.BlockableComponent
// 0x0048 (0x0100 - 0x00B8)
class UBlockableComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlockableReplicatedDatum              _replicatedDatum;                                  // 0x00D0(0x0020)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class UBlockElement*>                  _blockElements;                                    // 0x00F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void Authority_AddBlock(const class UObject* Source, const TSet<class ADBDPlayer*>& affectedPlayers);
	void Authority_AddTimedBlock(const class UObject* Source, const float Duration, const TSet<class ADBDPlayer*>& affectedPlayers);
	void Authority_RemoveBlock(const class UObject* Source);

	void OnRep_ReplicatedDatum() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlockableComponent">();
	}
	static class UBlockableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlockableComponent>();
	}
};
static_assert(alignof(UBlockableComponent) == 0x000008, "Wrong alignment on UBlockableComponent");
static_assert(sizeof(UBlockableComponent) == 0x000100, "Wrong size on UBlockableComponent");
static_assert(offsetof(UBlockableComponent, _replicatedDatum) == 0x0000D0, "Member 'UBlockableComponent::_replicatedDatum' has a wrong offset!");
static_assert(offsetof(UBlockableComponent, _blockElements) == 0x0000F0, "Member 'UBlockableComponent::_blockElements' has a wrong offset!");

// Class DeadByDaylight.ActorSpawnerRandomizer
// 0x0020 (0x0310 - 0x02F0)
class UActorSpawnerRandomizer final : public UObjectRandomizer
{
public:
	TArray<struct FSpawnerElement>                ActivatedSpawnerContentLists;                      // 0x02E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSpawnerElement>                DeactivatedSpawnerContentLists;                    // 0x02F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorSpawnerRandomizer">();
	}
	static class UActorSpawnerRandomizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorSpawnerRandomizer>();
	}
};
static_assert(alignof(UActorSpawnerRandomizer) == 0x000010, "Wrong alignment on UActorSpawnerRandomizer");
static_assert(sizeof(UActorSpawnerRandomizer) == 0x000310, "Wrong size on UActorSpawnerRandomizer");
static_assert(offsetof(UActorSpawnerRandomizer, ActivatedSpawnerContentLists) == 0x0002E8, "Member 'UActorSpawnerRandomizer::ActivatedSpawnerContentLists' has a wrong offset!");
static_assert(offsetof(UActorSpawnerRandomizer, DeactivatedSpawnerContentLists) == 0x0002F8, "Member 'UActorSpawnerRandomizer::DeactivatedSpawnerContentLists' has a wrong offset!");

// Class DeadByDaylight.ActorVariationSpawner
// 0x0060 (0x0330 - 0x02D0)
class UActorVariationSpawner final : public USceneComponent
{
public:
	TSoftClassPtr<class UClass>                   Visualization;                                     // 0x02D0(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FActorVariationElements>        Variations;                                        // 0x0308(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 _toSpawn;                                          // 0x0320(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorVariationSpawner">();
	}
	static class UActorVariationSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorVariationSpawner>();
	}
};
static_assert(alignof(UActorVariationSpawner) == 0x000010, "Wrong alignment on UActorVariationSpawner");
static_assert(sizeof(UActorVariationSpawner) == 0x000330, "Wrong size on UActorVariationSpawner");
static_assert(offsetof(UActorVariationSpawner, Visualization) == 0x0002D0, "Member 'UActorVariationSpawner::Visualization' has a wrong offset!");
static_assert(offsetof(UActorVariationSpawner, Variations) == 0x000308, "Member 'UActorVariationSpawner::Variations' has a wrong offset!");
static_assert(offsetof(UActorVariationSpawner, _toSpawn) == 0x000320, "Member 'UActorVariationSpawner::_toSpawn' has a wrong offset!");

// Class DeadByDaylight.InboxUtilities
// 0x0000 (0x0030 - 0x0030)
class UInboxUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InboxUtilities">();
	}
	static class UInboxUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInboxUtilities>();
	}
};
static_assert(alignof(UInboxUtilities) == 0x000008, "Wrong alignment on UInboxUtilities");
static_assert(sizeof(UInboxUtilities) == 0x000030, "Wrong size on UInboxUtilities");

// Class DeadByDaylight.AIBotsManager
// 0x0038 (0x0070 - 0x0038)
class UAIBotsManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x38];                                      // 0x0038(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIBotsManager">();
	}
	static class UAIBotsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIBotsManager>();
	}
};
static_assert(alignof(UAIBotsManager) == 0x000008, "Wrong alignment on UAIBotsManager");
static_assert(sizeof(UAIBotsManager) == 0x000070, "Wrong size on UAIBotsManager");

// Class DeadByDaylight.HISMMaterialHelperSettings
// 0x0050 (0x0088 - 0x0038)
class UHISMMaterialHelperSettings final : public UDataAsset
{
public:
	TMap<class UStaticMesh*, TSoftClassPtr<class UClass>> _meshMaterialOverride;                     // 0x0038(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HISMMaterialHelperSettings">();
	}
	static class UHISMMaterialHelperSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHISMMaterialHelperSettings>();
	}
};
static_assert(alignof(UHISMMaterialHelperSettings) == 0x000008, "Wrong alignment on UHISMMaterialHelperSettings");
static_assert(sizeof(UHISMMaterialHelperSettings) == 0x000088, "Wrong size on UHISMMaterialHelperSettings");
static_assert(offsetof(UHISMMaterialHelperSettings, _meshMaterialOverride) == 0x000038, "Member 'UHISMMaterialHelperSettings::_meshMaterialOverride' has a wrong offset!");

// Class DeadByDaylight.BehaviourPenalty_InactivityExposer
// 0x0008 (0x0048 - 0x0040)
class UBehaviourPenalty_InactivityExposer final : public UBaseBehaviourPenalty
{
public:
	TSubclassOf<class ASurvivorExposerInstance>   _inactivityExposerInstanceClass;                   // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BehaviourPenalty_InactivityExposer">();
	}
	static class UBehaviourPenalty_InactivityExposer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBehaviourPenalty_InactivityExposer>();
	}
};
static_assert(alignof(UBehaviourPenalty_InactivityExposer) == 0x000008, "Wrong alignment on UBehaviourPenalty_InactivityExposer");
static_assert(sizeof(UBehaviourPenalty_InactivityExposer) == 0x000048, "Wrong size on UBehaviourPenalty_InactivityExposer");
static_assert(offsetof(UBehaviourPenalty_InactivityExposer, _inactivityExposerInstanceClass) == 0x000040, "Member 'UBehaviourPenalty_InactivityExposer::_inactivityExposerInstanceClass' has a wrong offset!");

// Class DeadByDaylight.TimerGateDecrease
// 0x0008 (0x02A8 - 0x02A0)
class ATimerGateDecrease final : public AActor
{
public:
	class ATimerGate*                             TimerGate;                                         // 0x02A0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Update(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimerGateDecrease">();
	}
	static class ATimerGateDecrease* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATimerGateDecrease>();
	}
};
static_assert(alignof(ATimerGateDecrease) == 0x000008, "Wrong alignment on ATimerGateDecrease");
static_assert(sizeof(ATimerGateDecrease) == 0x0002A8, "Wrong size on ATimerGateDecrease");
static_assert(offsetof(ATimerGateDecrease, TimerGate) == 0x0002A0, "Member 'ATimerGateDecrease::TimerGate' has a wrong offset!");

// Class DeadByDaylight.TileEventComponent
// 0x0010 (0x00C8 - 0x00B8)
class UTileEventComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TileEventComponent">();
	}
	static class UTileEventComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTileEventComponent>();
	}
};
static_assert(alignof(UTileEventComponent) == 0x000008, "Wrong alignment on UTileEventComponent");
static_assert(sizeof(UTileEventComponent) == 0x0000C8, "Wrong size on UTileEventComponent");

// Class DeadByDaylight.ScreenshotOniHook
// 0x0020 (0x0050 - 0x0030)
class UScreenshotOniHook final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OniId;                                             // 0x0038(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   DemonModeTag;                                      // 0x0044(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenshotOniHook">();
	}
	static class UScreenshotOniHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenshotOniHook>();
	}
};
static_assert(alignof(UScreenshotOniHook) == 0x000008, "Wrong alignment on UScreenshotOniHook");
static_assert(sizeof(UScreenshotOniHook) == 0x000050, "Wrong size on UScreenshotOniHook");
static_assert(offsetof(UScreenshotOniHook, OniId) == 0x000038, "Member 'UScreenshotOniHook::OniId' has a wrong offset!");
static_assert(offsetof(UScreenshotOniHook, DemonModeTag) == 0x000044, "Member 'UScreenshotOniHook::DemonModeTag' has a wrong offset!");

// Class DeadByDaylight.AICharacterBehaviourInteractWithActorData
// 0x0020 (0x0050 - 0x0030)
class UAICharacterBehaviourInteractWithActorData final : public UAICharacterBehaviourData
{
public:
	class AActor*                                 TargetActor;                                       // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	ECharacterMovementTypes                       characterMovementType;                             // 0x0048(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          usePathfinding;                                    // 0x0049(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class AActor* Actor, ECharacterMovementTypes characterMovementType_0, bool usePathfinding_0);
	void WatchGameEventType(const struct FGameplayTag& gameEventType);
	void WatchGameEventTypes(const TArray<struct FGameplayTag>& gameEventTypes);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterBehaviourInteractWithActorData">();
	}
	static class UAICharacterBehaviourInteractWithActorData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterBehaviourInteractWithActorData>();
	}
};
static_assert(alignof(UAICharacterBehaviourInteractWithActorData) == 0x000008, "Wrong alignment on UAICharacterBehaviourInteractWithActorData");
static_assert(sizeof(UAICharacterBehaviourInteractWithActorData) == 0x000050, "Wrong size on UAICharacterBehaviourInteractWithActorData");
static_assert(offsetof(UAICharacterBehaviourInteractWithActorData, TargetActor) == 0x000030, "Member 'UAICharacterBehaviourInteractWithActorData::TargetActor' has a wrong offset!");
static_assert(offsetof(UAICharacterBehaviourInteractWithActorData, characterMovementType) == 0x000048, "Member 'UAICharacterBehaviourInteractWithActorData::characterMovementType' has a wrong offset!");
static_assert(offsetof(UAICharacterBehaviourInteractWithActorData, usePathfinding) == 0x000049, "Member 'UAICharacterBehaviourInteractWithActorData::usePathfinding' has a wrong offset!");

// Class DeadByDaylight.DBDPlayerPositionOffsetComponent
// 0x0008 (0x00C0 - 0x00B8)
class UDBDPlayerPositionOffsetComponent final : public UActorComponent
{
public:
	struct FPerPlatformFloat                      _menuZHeadOffset;                                  // 0x00B8(0x0004)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerPositionOffsetComponent">();
	}
	static class UDBDPlayerPositionOffsetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDPlayerPositionOffsetComponent>();
	}
};
static_assert(alignof(UDBDPlayerPositionOffsetComponent) == 0x000008, "Wrong alignment on UDBDPlayerPositionOffsetComponent");
static_assert(sizeof(UDBDPlayerPositionOffsetComponent) == 0x0000C0, "Wrong size on UDBDPlayerPositionOffsetComponent");
static_assert(offsetof(UDBDPlayerPositionOffsetComponent, _menuZHeadOffset) == 0x0000B8, "Member 'UDBDPlayerPositionOffsetComponent::_menuZHeadOffset' has a wrong offset!");

// Class DeadByDaylight.PerspectiveEffectActivator
// 0x0078 (0x0130 - 0x00B8)
class UPerspectiveEffectActivator final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FPerspectiveEffectData> _perspectiveEffects;                            // 0x00D0(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x10];                                     // 0x0120(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsEffectActive(class FName effectName);
	void RegisterEffect(class FName effectName, const struct FPerspectiveEffectData& effectData);
	void SetWantsActive(class FName effectName, bool WantsActive);
	void UnregisterEffect(class FName effectName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerspectiveEffectActivator">();
	}
	static class UPerspectiveEffectActivator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerspectiveEffectActivator>();
	}
};
static_assert(alignof(UPerspectiveEffectActivator) == 0x000008, "Wrong alignment on UPerspectiveEffectActivator");
static_assert(sizeof(UPerspectiveEffectActivator) == 0x000130, "Wrong size on UPerspectiveEffectActivator");
static_assert(offsetof(UPerspectiveEffectActivator, _perspectiveEffects) == 0x0000D0, "Member 'UPerspectiveEffectActivator::_perspectiveEffects' has a wrong offset!");

// Class DeadByDaylight.AICharacterBehaviourInteractWithHook
// 0x0008 (0x0090 - 0x0088)
class UAICharacterBehaviourInteractWithHook final : public UAICharacterBehaviourInteractWithActor
{
public:
	class AMeatHook*                              _targetHook;                                       // 0x0088(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterBehaviourInteractWithHook">();
	}
	static class UAICharacterBehaviourInteractWithHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterBehaviourInteractWithHook>();
	}
};
static_assert(alignof(UAICharacterBehaviourInteractWithHook) == 0x000008, "Wrong alignment on UAICharacterBehaviourInteractWithHook");
static_assert(sizeof(UAICharacterBehaviourInteractWithHook) == 0x000090, "Wrong size on UAICharacterBehaviourInteractWithHook");
static_assert(offsetof(UAICharacterBehaviourInteractWithHook, _targetHook) == 0x000088, "Member 'UAICharacterBehaviourInteractWithHook::_targetHook' has a wrong offset!");

// Class DeadByDaylight.CharacterEvasionBehaviourData
// 0x0020 (0x0050 - 0x0030)
class UCharacterEvasionBehaviourData final : public UAICharacterBehaviourData
{
public:
	class AActor*                                 _hunter;                                           // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         _escapePoints;                                     // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         _minEscapeDist;                                    // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class AActor* Hunter, const TArray<class AActor*>& escapePoints, float minEscapeDist);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterEvasionBehaviourData">();
	}
	static class UCharacterEvasionBehaviourData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterEvasionBehaviourData>();
	}
};
static_assert(alignof(UCharacterEvasionBehaviourData) == 0x000008, "Wrong alignment on UCharacterEvasionBehaviourData");
static_assert(sizeof(UCharacterEvasionBehaviourData) == 0x000050, "Wrong size on UCharacterEvasionBehaviourData");
static_assert(offsetof(UCharacterEvasionBehaviourData, _hunter) == 0x000030, "Member 'UCharacterEvasionBehaviourData::_hunter' has a wrong offset!");
static_assert(offsetof(UCharacterEvasionBehaviourData, _escapePoints) == 0x000038, "Member 'UCharacterEvasionBehaviourData::_escapePoints' has a wrong offset!");
static_assert(offsetof(UCharacterEvasionBehaviourData, _minEscapeDist) == 0x000048, "Member 'UCharacterEvasionBehaviourData::_minEscapeDist' has a wrong offset!");

// Class DeadByDaylight.Tile2DataRetrievalSubsystem
// 0x0068 (0x00A0 - 0x0038)
class UTile2DataRetrievalSubsystem final : public UEngineSubsystem
{
public:
	uint8                                         Pad_38[0x68];                                      // 0x0038(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Tile2DataRetrievalSubsystem">();
	}
	static class UTile2DataRetrievalSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTile2DataRetrievalSubsystem>();
	}
};
static_assert(alignof(UTile2DataRetrievalSubsystem) == 0x000008, "Wrong alignment on UTile2DataRetrievalSubsystem");
static_assert(sizeof(UTile2DataRetrievalSubsystem) == 0x0000A0, "Wrong size on UTile2DataRetrievalSubsystem");

// Class DeadByDaylight.DlcHelper
// 0x0080 (0x00B8 - 0x0038)
class UDlcHelper final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x80];                                      // 0x0038(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DlcHelper">();
	}
	static class UDlcHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDlcHelper>();
	}
};
static_assert(alignof(UDlcHelper) == 0x000008, "Wrong alignment on UDlcHelper");
static_assert(sizeof(UDlcHelper) == 0x0000B8, "Wrong size on UDlcHelper");

// Class DeadByDaylight.AICharacterEvasionBehaviour
// 0x0028 (0x0080 - 0x0058)
class UAICharacterEvasionBehaviour final : public UAICharacterBehaviour
{
public:
	class ADBDPlayer*                             _prey;                                             // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDAIPlayerController*                 _preyAIController;                                 // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 _currentEscapePoint;                               // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterEvasionBehaviourData*         _characterEvasionData;                             // 0x0070(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EscapeDestinationReached(const struct FAIRequestID& RequestID, EPathFollowingResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterEvasionBehaviour">();
	}
	static class UAICharacterEvasionBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterEvasionBehaviour>();
	}
};
static_assert(alignof(UAICharacterEvasionBehaviour) == 0x000008, "Wrong alignment on UAICharacterEvasionBehaviour");
static_assert(sizeof(UAICharacterEvasionBehaviour) == 0x000080, "Wrong size on UAICharacterEvasionBehaviour");
static_assert(offsetof(UAICharacterEvasionBehaviour, _prey) == 0x000058, "Member 'UAICharacterEvasionBehaviour::_prey' has a wrong offset!");
static_assert(offsetof(UAICharacterEvasionBehaviour, _preyAIController) == 0x000060, "Member 'UAICharacterEvasionBehaviour::_preyAIController' has a wrong offset!");
static_assert(offsetof(UAICharacterEvasionBehaviour, _currentEscapePoint) == 0x000068, "Member 'UAICharacterEvasionBehaviour::_currentEscapePoint' has a wrong offset!");
static_assert(offsetof(UAICharacterEvasionBehaviour, _characterEvasionData) == 0x000070, "Member 'UAICharacterEvasionBehaviour::_characterEvasionData' has a wrong offset!");

// Class DeadByDaylight.TutorialGameMode
// 0x0038 (0x0490 - 0x0458)
class ATutorialGameMode final : public ADBDBaseMatchGameMode
{
public:
	uint8                                         Pad_458[0x10];                                     // 0x0458(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTutorialObjectiveController*           _tutorialObjectiveController;                      // 0x0468(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTutorialNotificationController*        _tutorialNotificationController;                   // 0x0470(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTutorialHighlightController*           _tutorialHighlightController;                      // 0x0478(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtlantaTutorialPlayerHudController*    _atlantaTutorialPlayerHudController;               // 0x0480(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_488[0x8];                                      // 0x0488(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetEscapeActivated();
	void SetGameObjective(TSubclassOf<class AGameObjective_ActivatedGenerators> gameObjectiveClass);

	class UAtlantaTutorialPlayerHudController* GetAtlantaTutorialPlayerHudController() const;
	class UTutorialHighlightController* GetTutorialHighlightController() const;
	class UTutorialNotificationController* GetTutorialNotificationController() const;
	class UTutorialObjectiveController* GetTutorialObjectiveController() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialGameMode">();
	}
	static class ATutorialGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATutorialGameMode>();
	}
};
static_assert(alignof(ATutorialGameMode) == 0x000008, "Wrong alignment on ATutorialGameMode");
static_assert(sizeof(ATutorialGameMode) == 0x000490, "Wrong size on ATutorialGameMode");
static_assert(offsetof(ATutorialGameMode, _tutorialObjectiveController) == 0x000468, "Member 'ATutorialGameMode::_tutorialObjectiveController' has a wrong offset!");
static_assert(offsetof(ATutorialGameMode, _tutorialNotificationController) == 0x000470, "Member 'ATutorialGameMode::_tutorialNotificationController' has a wrong offset!");
static_assert(offsetof(ATutorialGameMode, _tutorialHighlightController) == 0x000478, "Member 'ATutorialGameMode::_tutorialHighlightController' has a wrong offset!");
static_assert(offsetof(ATutorialGameMode, _atlantaTutorialPlayerHudController) == 0x000480, "Member 'ATutorialGameMode::_atlantaTutorialPlayerHudController' has a wrong offset!");

// Class DeadByDaylight.AICharacterHideInLockerBehaviourData
// 0x0010 (0x0040 - 0x0030)
class UAICharacterHideInLockerBehaviourData final : public UAICharacterBehaviourData
{
public:
	class ALocker*                                targetLocker;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterMovementTypes                       characterMovementType;                             // 0x0038(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class ALocker* Locker, ECharacterMovementTypes characterMovementType_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterHideInLockerBehaviourData">();
	}
	static class UAICharacterHideInLockerBehaviourData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterHideInLockerBehaviourData>();
	}
};
static_assert(alignof(UAICharacterHideInLockerBehaviourData) == 0x000008, "Wrong alignment on UAICharacterHideInLockerBehaviourData");
static_assert(sizeof(UAICharacterHideInLockerBehaviourData) == 0x000040, "Wrong size on UAICharacterHideInLockerBehaviourData");
static_assert(offsetof(UAICharacterHideInLockerBehaviourData, targetLocker) == 0x000030, "Member 'UAICharacterHideInLockerBehaviourData::targetLocker' has a wrong offset!");
static_assert(offsetof(UAICharacterHideInLockerBehaviourData, characterMovementType) == 0x000038, "Member 'UAICharacterHideInLockerBehaviourData::characterMovementType' has a wrong offset!");

// Class DeadByDaylight.FearMarketManager
// 0x00E0 (0x0110 - 0x0030)
class UFearMarketManager final : public UObject
{
public:
	struct FFearMarketItemInstance                PendingPurchaseFearMarketItem;                     // 0x0030(0x0030)(NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x48];                                      // 0x0060(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFearMarketOfferingInstance            _existingFearMarket;                               // 0x00A8(0x0020)(NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UDBDGameInstance>        _gameInstance;                                     // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x40];                                      // 0x00D0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReceivedFearMarketData(bool Success);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FearMarketManager">();
	}
	static class UFearMarketManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFearMarketManager>();
	}
};
static_assert(alignof(UFearMarketManager) == 0x000008, "Wrong alignment on UFearMarketManager");
static_assert(sizeof(UFearMarketManager) == 0x000110, "Wrong size on UFearMarketManager");
static_assert(offsetof(UFearMarketManager, PendingPurchaseFearMarketItem) == 0x000030, "Member 'UFearMarketManager::PendingPurchaseFearMarketItem' has a wrong offset!");
static_assert(offsetof(UFearMarketManager, _existingFearMarket) == 0x0000A8, "Member 'UFearMarketManager::_existingFearMarket' has a wrong offset!");
static_assert(offsetof(UFearMarketManager, _gameInstance) == 0x0000C8, "Member 'UFearMarketManager::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.AICharacterHideInLockerBehaviour
// 0x0030 (0x0088 - 0x0058)
class UAICharacterHideInLockerBehaviour final : public UAICharacterBehaviour
{
public:
	class ADBDPlayer*                             _aiPlayer;                                         // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDAIPlayerController*                 _aiPlayerController;                               // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x10];                                      // 0x0068(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAICharacterHideInLockerBehaviourData*  _characterHideInLockerData;                        // 0x0078(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMovementFinished(const struct FAIRequestID& RequestID, EPathFollowingResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterHideInLockerBehaviour">();
	}
	static class UAICharacterHideInLockerBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterHideInLockerBehaviour>();
	}
};
static_assert(alignof(UAICharacterHideInLockerBehaviour) == 0x000008, "Wrong alignment on UAICharacterHideInLockerBehaviour");
static_assert(sizeof(UAICharacterHideInLockerBehaviour) == 0x000088, "Wrong size on UAICharacterHideInLockerBehaviour");
static_assert(offsetof(UAICharacterHideInLockerBehaviour, _aiPlayer) == 0x000058, "Member 'UAICharacterHideInLockerBehaviour::_aiPlayer' has a wrong offset!");
static_assert(offsetof(UAICharacterHideInLockerBehaviour, _aiPlayerController) == 0x000060, "Member 'UAICharacterHideInLockerBehaviour::_aiPlayerController' has a wrong offset!");
static_assert(offsetof(UAICharacterHideInLockerBehaviour, _characterHideInLockerData) == 0x000078, "Member 'UAICharacterHideInLockerBehaviour::_characterHideInLockerData' has a wrong offset!");

// Class DeadByDaylight.AICharacterRepairGeneratorBehaviourData
// 0x0010 (0x0040 - 0x0030)
class UAICharacterRepairGeneratorBehaviourData final : public UAICharacterBehaviourData
{
public:
	class AGenerator*                             _generator;                                        // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECharacterMovementTypes                       _characterMovementType;                            // 0x0038(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class AGenerator* Generator, ECharacterMovementTypes characterMovementType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterRepairGeneratorBehaviourData">();
	}
	static class UAICharacterRepairGeneratorBehaviourData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterRepairGeneratorBehaviourData>();
	}
};
static_assert(alignof(UAICharacterRepairGeneratorBehaviourData) == 0x000008, "Wrong alignment on UAICharacterRepairGeneratorBehaviourData");
static_assert(sizeof(UAICharacterRepairGeneratorBehaviourData) == 0x000040, "Wrong size on UAICharacterRepairGeneratorBehaviourData");
static_assert(offsetof(UAICharacterRepairGeneratorBehaviourData, _generator) == 0x000030, "Member 'UAICharacterRepairGeneratorBehaviourData::_generator' has a wrong offset!");
static_assert(offsetof(UAICharacterRepairGeneratorBehaviourData, _characterMovementType) == 0x000038, "Member 'UAICharacterRepairGeneratorBehaviourData::_characterMovementType' has a wrong offset!");

// Class DeadByDaylight.MoriableComponent
// 0x00C8 (0x0180 - 0x00B8)
class UMoriableComponent final : public UActorComponent
{
public:
	TArray<class UInteractionDefinition*>         _moriInteractions;                                 // 0x00B8(0x0010)(ExportObject, Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _disruptAuraReadingStatusEffect;                   // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0xB0];                                      // 0x00D0(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMoriFinished(bool hasBeenKilledByMori);
	void OnMoriUpdateStart();
	void OnRep_MoriInteractions();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoriableComponent">();
	}
	static class UMoriableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoriableComponent>();
	}
};
static_assert(alignof(UMoriableComponent) == 0x000008, "Wrong alignment on UMoriableComponent");
static_assert(sizeof(UMoriableComponent) == 0x000180, "Wrong size on UMoriableComponent");
static_assert(offsetof(UMoriableComponent, _moriInteractions) == 0x0000B8, "Member 'UMoriableComponent::_moriInteractions' has a wrong offset!");
static_assert(offsetof(UMoriableComponent, _disruptAuraReadingStatusEffect) == 0x0000C8, "Member 'UMoriableComponent::_disruptAuraReadingStatusEffect' has a wrong offset!");

// Class DeadByDaylight.ScreenshotPreviewWidget
// 0x0000 (0x02A8 - 0x02A8)
class UScreenshotPreviewWidget final : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenshotPreviewWidget">();
	}
	static class UScreenshotPreviewWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenshotPreviewWidget>();
	}
};
static_assert(alignof(UScreenshotPreviewWidget) == 0x000008, "Wrong alignment on UScreenshotPreviewWidget");
static_assert(sizeof(UScreenshotPreviewWidget) == 0x0002A8, "Wrong size on UScreenshotPreviewWidget");

// Class DeadByDaylight.AIHealAllyBehaviourData
// 0x0008 (0x0038 - 0x0030)
class UAIHealAllyBehaviourData final : public UAICharacterBehaviourData
{
public:
	class ASurvivor*                              _targetAlly;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Init(class ASurvivor* allyToHealTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIHealAllyBehaviourData">();
	}
	static class UAIHealAllyBehaviourData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIHealAllyBehaviourData>();
	}
};
static_assert(alignof(UAIHealAllyBehaviourData) == 0x000008, "Wrong alignment on UAIHealAllyBehaviourData");
static_assert(sizeof(UAIHealAllyBehaviourData) == 0x000038, "Wrong size on UAIHealAllyBehaviourData");
static_assert(offsetof(UAIHealAllyBehaviourData, _targetAlly) == 0x000030, "Member 'UAIHealAllyBehaviourData::_targetAlly' has a wrong offset!");

// Class DeadByDaylight.AIHealAllyBehaviour
// 0x0038 (0x0090 - 0x0058)
class UAIHealAllyBehaviour final : public UAICharacterBehaviour
{
public:
	class UAIHealAllyBehaviourData*               _behaviourData;                                    // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDAIPlayerController*                 _aiController;                                     // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDPlayer*                             _aiPlayer;                                         // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x20];                                      // 0x0070(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class ADBDPlayer* Character, class UAICharacterBehaviourData* behaviourData);
	void TargetPositionReached(const struct FAIRequestID& RequestID, EPathFollowingResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIHealAllyBehaviour">();
	}
	static class UAIHealAllyBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIHealAllyBehaviour>();
	}
};
static_assert(alignof(UAIHealAllyBehaviour) == 0x000008, "Wrong alignment on UAIHealAllyBehaviour");
static_assert(sizeof(UAIHealAllyBehaviour) == 0x000090, "Wrong size on UAIHealAllyBehaviour");
static_assert(offsetof(UAIHealAllyBehaviour, _behaviourData) == 0x000058, "Member 'UAIHealAllyBehaviour::_behaviourData' has a wrong offset!");
static_assert(offsetof(UAIHealAllyBehaviour, _aiController) == 0x000060, "Member 'UAIHealAllyBehaviour::_aiController' has a wrong offset!");
static_assert(offsetof(UAIHealAllyBehaviour, _aiPlayer) == 0x000068, "Member 'UAIHealAllyBehaviour::_aiPlayer' has a wrong offset!");

// Class DeadByDaylight.EscapeTile
// 0x0000 (0x0460 - 0x0460)
class AEscapeTile final : public ATile
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EscapeTile">();
	}
	static class AEscapeTile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEscapeTile>();
	}
};
static_assert(alignof(AEscapeTile) == 0x000008, "Wrong alignment on AEscapeTile");
static_assert(sizeof(AEscapeTile) == 0x000460, "Wrong size on AEscapeTile");

// Class DeadByDaylight.GameTypeModifierDefaults
// 0x0050 (0x0088 - 0x0038)
class UGameTypeModifierDefaults final : public UDataAsset
{
public:
	TMap<EGameTypeModifierName, struct FTypeFlexibleTunable> Modifiers;                              // 0x0038(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameTypeModifierDefaults">();
	}
	static class UGameTypeModifierDefaults* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameTypeModifierDefaults>();
	}
};
static_assert(alignof(UGameTypeModifierDefaults) == 0x000008, "Wrong alignment on UGameTypeModifierDefaults");
static_assert(sizeof(UGameTypeModifierDefaults) == 0x000088, "Wrong size on UGameTypeModifierDefaults");
static_assert(offsetof(UGameTypeModifierDefaults, Modifiers) == 0x000038, "Member 'UGameTypeModifierDefaults::Modifiers' has a wrong offset!");

// Class DeadByDaylight.EndGameComponent
// 0x00A0 (0x0158 - 0x00B8)
class UEndGameComponent : public UActorComponent
{
public:
	int32                                         _closedHatchesRequiredCount;                       // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BC[0x9C];                                      // 0x00BC(0x009C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableEndGameScenario();
	void FireEndGameSacrificeScoreEvent(const struct FGameEventData& GameEventData);
	void PauseEndGameTimer();
	void StartEndGame_Cheat();
	void UnpauseEndGameTimer();

	bool GetHasEndGameBegun() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndGameComponent">();
	}
	static class UEndGameComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndGameComponent>();
	}
};
static_assert(alignof(UEndGameComponent) == 0x000008, "Wrong alignment on UEndGameComponent");
static_assert(sizeof(UEndGameComponent) == 0x000158, "Wrong size on UEndGameComponent");
static_assert(offsetof(UEndGameComponent, _closedHatchesRequiredCount) == 0x0000B8, "Member 'UEndGameComponent::_closedHatchesRequiredCount' has a wrong offset!");

// Class DeadByDaylight.TutorialEndGameComponent
// 0x0008 (0x0160 - 0x0158)
class UTutorialEndGameComponent final : public UEndGameComponent
{
public:
	float                                         _timerMaxCompletionPercentage;                     // 0x0158(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetTimerMaxCompletionPercentage(const float& Percentage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialEndGameComponent">();
	}
	static class UTutorialEndGameComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialEndGameComponent>();
	}
};
static_assert(alignof(UTutorialEndGameComponent) == 0x000008, "Wrong alignment on UTutorialEndGameComponent");
static_assert(sizeof(UTutorialEndGameComponent) == 0x000160, "Wrong size on UTutorialEndGameComponent");
static_assert(offsetof(UTutorialEndGameComponent, _timerMaxCompletionPercentage) == 0x000158, "Member 'UTutorialEndGameComponent::_timerMaxCompletionPercentage' has a wrong offset!");

// Class DeadByDaylight.AimableInterface
// 0x0000 (0x0000 - 0x0000)
class IAimableInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimableInterface">();
	}
	static class IAimableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAimableInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IAimableInterface) == 0x000001, "Wrong alignment on IAimableInterface");
static_assert(sizeof(IAimableInterface) == 0x000001, "Wrong size on IAimableInterface");

// Class DeadByDaylight.AIMoveToInteractData
// 0x0018 (0x0048 - 0x0030)
class UAIMoveToInteractData final : public UAICharacterBehaviourData
{
public:
	class AActor*                                 _interactActor;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 _targetPositionActor;                              // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECharacterMovementTypes                       _characterMovementTypes;                           // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class AActor* interactActor, ECharacterMovementTypes characterMovementTypes, class AActor* targetPositionActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIMoveToInteractData">();
	}
	static class UAIMoveToInteractData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIMoveToInteractData>();
	}
};
static_assert(alignof(UAIMoveToInteractData) == 0x000008, "Wrong alignment on UAIMoveToInteractData");
static_assert(sizeof(UAIMoveToInteractData) == 0x000048, "Wrong size on UAIMoveToInteractData");
static_assert(offsetof(UAIMoveToInteractData, _interactActor) == 0x000030, "Member 'UAIMoveToInteractData::_interactActor' has a wrong offset!");
static_assert(offsetof(UAIMoveToInteractData, _targetPositionActor) == 0x000038, "Member 'UAIMoveToInteractData::_targetPositionActor' has a wrong offset!");
static_assert(offsetof(UAIMoveToInteractData, _characterMovementTypes) == 0x000040, "Member 'UAIMoveToInteractData::_characterMovementTypes' has a wrong offset!");

// Class DeadByDaylight.AIMoveToInteract
// 0x0018 (0x0070 - 0x0058)
class UAIMoveToInteract final : public UAICharacterBehaviour
{
public:
	class UAIMoveToInteractData*                  _aiMoveToInteractData;                             // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDAIPlayerController*                 _aiController;                                     // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class ADBDPlayer* Character, class UAICharacterBehaviourData* behaviourData);
	void InteractionPointReached(const struct FAIRequestID& RequestID, EPathFollowingResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIMoveToInteract">();
	}
	static class UAIMoveToInteract* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIMoveToInteract>();
	}
};
static_assert(alignof(UAIMoveToInteract) == 0x000008, "Wrong alignment on UAIMoveToInteract");
static_assert(sizeof(UAIMoveToInteract) == 0x000070, "Wrong size on UAIMoveToInteract");
static_assert(offsetof(UAIMoveToInteract, _aiMoveToInteractData) == 0x000058, "Member 'UAIMoveToInteract::_aiMoveToInteractData' has a wrong offset!");
static_assert(offsetof(UAIMoveToInteract, _aiController) == 0x000060, "Member 'UAIMoveToInteract::_aiController' has a wrong offset!");

// Class DeadByDaylight.StatusEffectCollectionComponent
// 0x0038 (0x00F0 - 0x00B8)
class UStatusEffectCollectionComponent final : public UActorComponent
{
public:
	TArray<class UStatusEffect*>                  _array;                                            // 0x00B8(0x0010)(ExportObject, Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UStatusEffect*>                  _local_oldArray;                                   // 0x00C8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x18];                                      // 0x00D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Array();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusEffectCollectionComponent">();
	}
	static class UStatusEffectCollectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatusEffectCollectionComponent>();
	}
};
static_assert(alignof(UStatusEffectCollectionComponent) == 0x000008, "Wrong alignment on UStatusEffectCollectionComponent");
static_assert(sizeof(UStatusEffectCollectionComponent) == 0x0000F0, "Wrong size on UStatusEffectCollectionComponent");
static_assert(offsetof(UStatusEffectCollectionComponent, _array) == 0x0000B8, "Member 'UStatusEffectCollectionComponent::_array' has a wrong offset!");
static_assert(offsetof(UStatusEffectCollectionComponent, _local_oldArray) == 0x0000C8, "Member 'UStatusEffectCollectionComponent::_local_oldArray' has a wrong offset!");

// Class DeadByDaylight.AIMoveToPositionData
// 0x0010 (0x0040 - 0x0030)
class UAIMoveToPositionData final : public UAICharacterBehaviourData
{
public:
	class AActor*                                 _positionActor;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECharacterMovementTypes                       _movementType;                                     // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _usePathfinding;                                   // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class AActor* positionActor, ECharacterMovementTypes movementType, bool usePathfinding);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIMoveToPositionData">();
	}
	static class UAIMoveToPositionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIMoveToPositionData>();
	}
};
static_assert(alignof(UAIMoveToPositionData) == 0x000008, "Wrong alignment on UAIMoveToPositionData");
static_assert(sizeof(UAIMoveToPositionData) == 0x000040, "Wrong size on UAIMoveToPositionData");
static_assert(offsetof(UAIMoveToPositionData, _positionActor) == 0x000030, "Member 'UAIMoveToPositionData::_positionActor' has a wrong offset!");
static_assert(offsetof(UAIMoveToPositionData, _movementType) == 0x000038, "Member 'UAIMoveToPositionData::_movementType' has a wrong offset!");
static_assert(offsetof(UAIMoveToPositionData, _usePathfinding) == 0x000039, "Member 'UAIMoveToPositionData::_usePathfinding' has a wrong offset!");

// Class DeadByDaylight.DBDHud
// 0x0050 (0x0080 - 0x0030)
class UDBDHud final : public UObject
{
public:
	TMap<class FName, class AStatusView*>         _statusViews;                                      // 0x0030(0x0050)(NativeAccessSpecifierPrivate)

public:
	void RemoveStatusViewOnDestroy(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDHud">();
	}
	static class UDBDHud* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDHud>();
	}
};
static_assert(alignof(UDBDHud) == 0x000008, "Wrong alignment on UDBDHud");
static_assert(sizeof(UDBDHud) == 0x000080, "Wrong size on UDBDHud");
static_assert(offsetof(UDBDHud, _statusViews) == 0x000030, "Member 'UDBDHud::_statusViews' has a wrong offset!");

// Class DeadByDaylight.NavigationQueryFilter_EvadeLoop
// 0x0440 (0x0490 - 0x0050)
class UNavigationQueryFilter_EvadeLoop final : public UNavigationQueryFilter
{
public:
	uint8                                         Pad_50[0x440];                                     // 0x0050(0x0440)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationQueryFilter_EvadeLoop">();
	}
	static class UNavigationQueryFilter_EvadeLoop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationQueryFilter_EvadeLoop>();
	}
};
static_assert(alignof(UNavigationQueryFilter_EvadeLoop) == 0x000008, "Wrong alignment on UNavigationQueryFilter_EvadeLoop");
static_assert(sizeof(UNavigationQueryFilter_EvadeLoop) == 0x000490, "Wrong size on UNavigationQueryFilter_EvadeLoop");

// Class DeadByDaylight.AIPointOfInterestTargetInterface
// 0x0000 (0x0000 - 0x0000)
class IAIPointOfInterestTargetInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIPointOfInterestTargetInterface">();
	}
	static class IAIPointOfInterestTargetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAIPointOfInterestTargetInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IAIPointOfInterestTargetInterface) == 0x000001, "Wrong alignment on IAIPointOfInterestTargetInterface");
static_assert(sizeof(IAIPointOfInterestTargetInterface) == 0x000001, "Wrong size on IAIPointOfInterestTargetInterface");

// Class DeadByDaylight.AISense_PointOfInterest
// 0x0010 (0x00A0 - 0x0090)
class UAISense_PointOfInterest final : public UAISense
{
public:
	TArray<class AActor*>                         _sources;                                          // 0x0090(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISense_PointOfInterest">();
	}
	static class UAISense_PointOfInterest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISense_PointOfInterest>();
	}
};
static_assert(alignof(UAISense_PointOfInterest) == 0x000008, "Wrong alignment on UAISense_PointOfInterest");
static_assert(sizeof(UAISense_PointOfInterest) == 0x0000A0, "Wrong size on UAISense_PointOfInterest");
static_assert(offsetof(UAISense_PointOfInterest, _sources) == 0x000090, "Member 'UAISense_PointOfInterest::_sources' has a wrong offset!");

// Class DeadByDaylight.AISenseEvent_Trail
// 0x0038 (0x0068 - 0x0030)
class UAISenseEvent_Trail final : public UAISenseEvent
{
public:
	struct FAITrailEvent                          Event;                                             // 0x0030(0x0038)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISenseEvent_Trail">();
	}
	static class UAISenseEvent_Trail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISenseEvent_Trail>();
	}
};
static_assert(alignof(UAISenseEvent_Trail) == 0x000008, "Wrong alignment on UAISenseEvent_Trail");
static_assert(sizeof(UAISenseEvent_Trail) == 0x000068, "Wrong size on UAISenseEvent_Trail");
static_assert(offsetof(UAISenseEvent_Trail, Event) == 0x000030, "Member 'UAISenseEvent_Trail::Event' has a wrong offset!");

// Class DeadByDaylight.AISense_Trail
// 0x0060 (0x00F0 - 0x0090)
class UAISense_Trail final : public UAISense
{
public:
	TArray<struct FAITrailEvent>                  Events;                                            // 0x0090(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A0[0x50];                                      // 0x00A0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ReportTrailEvent(class UObject* worldContextObj, const struct FVector& Location, class AActor* Instigator, const struct FGameplayTag& IgnoreOnPerkTag, float Lifetime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISense_Trail">();
	}
	static class UAISense_Trail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISense_Trail>();
	}
};
static_assert(alignof(UAISense_Trail) == 0x000008, "Wrong alignment on UAISense_Trail");
static_assert(sizeof(UAISense_Trail) == 0x0000F0, "Wrong size on UAISense_Trail");
static_assert(offsetof(UAISense_Trail, Events) == 0x000090, "Member 'UAISense_Trail::Events' has a wrong offset!");

// Class DeadByDaylight.GenericPopupScreen
// 0x0020 (0x0148 - 0x0128)
class UGenericPopupScreen : public UBasePopupScreen
{
public:
	class UUMGGenericPopup*                       _popup;                                            // 0x0128(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_130[0x18];                                     // 0x0130(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChoiceSelected(int32 selectedButtonType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericPopupScreen">();
	}
	static class UGenericPopupScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGenericPopupScreen>();
	}
};
static_assert(alignof(UGenericPopupScreen) == 0x000008, "Wrong alignment on UGenericPopupScreen");
static_assert(sizeof(UGenericPopupScreen) == 0x000148, "Wrong size on UGenericPopupScreen");
static_assert(offsetof(UGenericPopupScreen, _popup) == 0x000128, "Member 'UGenericPopupScreen::_popup' has a wrong offset!");

// Class DeadByDaylight.FriendSearchPopupScreen
// 0x0060 (0x01A8 - 0x0148)
class UFriendSearchPopupScreen final : public UGenericPopupScreen
{
public:
	uint8                                         Pad_148[0x60];                                     // 0x0148(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAcceptFriendInvite(const class FString& friendKrakenID);
	void OnFriendSearchStart(const class FString& SearchText);
	void OnInviteFriend(const class FString& friendKrakenID, bool IsOffNetwork);
	void OnUnblockPlayer(const class FString& friendKrakenID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FriendSearchPopupScreen">();
	}
	static class UFriendSearchPopupScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFriendSearchPopupScreen>();
	}
};
static_assert(alignof(UFriendSearchPopupScreen) == 0x000008, "Wrong alignment on UFriendSearchPopupScreen");
static_assert(sizeof(UFriendSearchPopupScreen) == 0x0001A8, "Wrong size on UFriendSearchPopupScreen");

// Class DeadByDaylight.AISenseConfig_UnclearHearing
// 0x00D8 (0x0128 - 0x0050)
class UAISenseConfig_UnclearHearing final : public UAISenseConfig
{
public:
	TSubclassOf<class UAISense_UnclearHearing>    Implementation;                                    // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HearingRange;                                      // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    NoiseRangeMultiplier;                              // 0x0060(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    ReactionTime;                                      // 0x00C0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAISenseAffiliationFilter              DetectionByAffiliation;                            // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISenseConfig_UnclearHearing">();
	}
	static class UAISenseConfig_UnclearHearing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISenseConfig_UnclearHearing>();
	}
};
static_assert(alignof(UAISenseConfig_UnclearHearing) == 0x000008, "Wrong alignment on UAISenseConfig_UnclearHearing");
static_assert(sizeof(UAISenseConfig_UnclearHearing) == 0x000128, "Wrong size on UAISenseConfig_UnclearHearing");
static_assert(offsetof(UAISenseConfig_UnclearHearing, Implementation) == 0x000050, "Member 'UAISenseConfig_UnclearHearing::Implementation' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_UnclearHearing, HearingRange) == 0x000058, "Member 'UAISenseConfig_UnclearHearing::HearingRange' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_UnclearHearing, NoiseRangeMultiplier) == 0x000060, "Member 'UAISenseConfig_UnclearHearing::NoiseRangeMultiplier' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_UnclearHearing, ReactionTime) == 0x0000C0, "Member 'UAISenseConfig_UnclearHearing::ReactionTime' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_UnclearHearing, DetectionByAffiliation) == 0x000120, "Member 'UAISenseConfig_UnclearHearing::DetectionByAffiliation' has a wrong offset!");

// Class DeadByDaylight.AISenseEvent_UnclearHearing
// 0x0040 (0x0070 - 0x0030)
class UAISenseEvent_UnclearHearing final : public UAISenseEvent
{
public:
	struct FAIUnclearNoiseEvent                   Event;                                             // 0x0030(0x0040)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISenseEvent_UnclearHearing">();
	}
	static class UAISenseEvent_UnclearHearing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISenseEvent_UnclearHearing>();
	}
};
static_assert(alignof(UAISenseEvent_UnclearHearing) == 0x000008, "Wrong alignment on UAISenseEvent_UnclearHearing");
static_assert(sizeof(UAISenseEvent_UnclearHearing) == 0x000070, "Wrong size on UAISenseEvent_UnclearHearing");
static_assert(offsetof(UAISenseEvent_UnclearHearing, Event) == 0x000030, "Member 'UAISenseEvent_UnclearHearing::Event' has a wrong offset!");

// Class DeadByDaylight.AISlasherChaseAndAttackBehaviour
// 0x0038 (0x0090 - 0x0058)
class UAISlasherChaseAndAttackBehaviour final : public UAICharacterBehaviour
{
public:
	class UAISlasherChaseAndAttackBehaviourData*  _behaviourData;                                    // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AKiller*                                _killer;                                           // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDAIPlayerController*                 _killerAIPlayerController;                         // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x20];                                      // 0x0070(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISlasherChaseAndAttackBehaviour">();
	}
	static class UAISlasherChaseAndAttackBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISlasherChaseAndAttackBehaviour>();
	}
};
static_assert(alignof(UAISlasherChaseAndAttackBehaviour) == 0x000008, "Wrong alignment on UAISlasherChaseAndAttackBehaviour");
static_assert(sizeof(UAISlasherChaseAndAttackBehaviour) == 0x000090, "Wrong size on UAISlasherChaseAndAttackBehaviour");
static_assert(offsetof(UAISlasherChaseAndAttackBehaviour, _behaviourData) == 0x000058, "Member 'UAISlasherChaseAndAttackBehaviour::_behaviourData' has a wrong offset!");
static_assert(offsetof(UAISlasherChaseAndAttackBehaviour, _killer) == 0x000060, "Member 'UAISlasherChaseAndAttackBehaviour::_killer' has a wrong offset!");
static_assert(offsetof(UAISlasherChaseAndAttackBehaviour, _killerAIPlayerController) == 0x000068, "Member 'UAISlasherChaseAndAttackBehaviour::_killerAIPlayerController' has a wrong offset!");

// Class DeadByDaylight.ExposerInteriorZoneComponent
// 0x0010 (0x05F0 - 0x05E0)
class UExposerInteriorZoneComponent final : public UBoxComponent
{
public:
	TArray<class USceneComponent*>                ExposerSpawnPoints;                                // 0x05E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	void AddExposerSpawnPoint(class USceneComponent* Point);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExposerInteriorZoneComponent">();
	}
	static class UExposerInteriorZoneComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExposerInteriorZoneComponent>();
	}
};
static_assert(alignof(UExposerInteriorZoneComponent) == 0x000010, "Wrong alignment on UExposerInteriorZoneComponent");
static_assert(sizeof(UExposerInteriorZoneComponent) == 0x0005F0, "Wrong size on UExposerInteriorZoneComponent");
static_assert(offsetof(UExposerInteriorZoneComponent, ExposerSpawnPoints) == 0x0005E0, "Member 'UExposerInteriorZoneComponent::ExposerSpawnPoints' has a wrong offset!");

// Class DeadByDaylight.UMGGameplayAlertWidget
// 0x0000 (0x02F0 - 0x02F0)
class UUMGGameplayAlertWidget final : public UUMGBaseAlertWidget
{
public:
	void UpdateWidget(const struct FStatusEffectSlotData& StatusEffectData, const struct FInventorySlotData& originatorData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGGameplayAlertWidget">();
	}
	static class UUMGGameplayAlertWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGGameplayAlertWidget>();
	}
};
static_assert(alignof(UUMGGameplayAlertWidget) == 0x000008, "Wrong alignment on UUMGGameplayAlertWidget");
static_assert(sizeof(UUMGGameplayAlertWidget) == 0x0002F0, "Wrong size on UUMGGameplayAlertWidget");

// Class DeadByDaylight.AISlasherMoveToGrabSurvivorBehaviourData
// 0x0008 (0x0038 - 0x0030)
class UAISlasherMoveToGrabSurvivorBehaviourData final : public UAICharacterBehaviourData
{
public:
	class ASurvivor*                              _targetSurvivor;                                   // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Init(class ASurvivor* TargetSurvivor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISlasherMoveToGrabSurvivorBehaviourData">();
	}
	static class UAISlasherMoveToGrabSurvivorBehaviourData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISlasherMoveToGrabSurvivorBehaviourData>();
	}
};
static_assert(alignof(UAISlasherMoveToGrabSurvivorBehaviourData) == 0x000008, "Wrong alignment on UAISlasherMoveToGrabSurvivorBehaviourData");
static_assert(sizeof(UAISlasherMoveToGrabSurvivorBehaviourData) == 0x000038, "Wrong size on UAISlasherMoveToGrabSurvivorBehaviourData");
static_assert(offsetof(UAISlasherMoveToGrabSurvivorBehaviourData, _targetSurvivor) == 0x000030, "Member 'UAISlasherMoveToGrabSurvivorBehaviourData::_targetSurvivor' has a wrong offset!");

// Class DeadByDaylight.DBD_SoundEventSpawner
// 0x0038 (0x02D8 - 0x02A0)
class ADBD_SoundEventSpawner final : public AActor
{
public:
	TArray<struct FDBD_SoundSpawnerData>          AtlantaSoundDescriptor;                            // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDBD_SoundSpawnerData>          SoundDescriptor;                                   // 0x02B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AActor>>             _loadedSoundAssets;                                // 0x02C8(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void AssetsLoaded();
	void OnLoudNoiseTriggered(class AActor* originator, class AActor* instigatingActor, const struct FVector& Location, bool shouldTrack, float* audibleRange, bool isQuickAction, bool isDeceivingNoise);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBD_SoundEventSpawner">();
	}
	static class ADBD_SoundEventSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBD_SoundEventSpawner>();
	}
};
static_assert(alignof(ADBD_SoundEventSpawner) == 0x000008, "Wrong alignment on ADBD_SoundEventSpawner");
static_assert(sizeof(ADBD_SoundEventSpawner) == 0x0002D8, "Wrong size on ADBD_SoundEventSpawner");
static_assert(offsetof(ADBD_SoundEventSpawner, AtlantaSoundDescriptor) == 0x0002A0, "Member 'ADBD_SoundEventSpawner::AtlantaSoundDescriptor' has a wrong offset!");
static_assert(offsetof(ADBD_SoundEventSpawner, SoundDescriptor) == 0x0002B0, "Member 'ADBD_SoundEventSpawner::SoundDescriptor' has a wrong offset!");
static_assert(offsetof(ADBD_SoundEventSpawner, _loadedSoundAssets) == 0x0002C8, "Member 'ADBD_SoundEventSpawner::_loadedSoundAssets' has a wrong offset!");

// Class DeadByDaylight.AISlasherMoveToGrabSurvivorBehaviour
// 0x0030 (0x0088 - 0x0058)
class UAISlasherMoveToGrabSurvivorBehaviour final : public UAICharacterBehaviour
{
public:
	class UAISlasherMoveToGrabSurvivorBehaviourData* _behaviourData;                                 // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AKiller*                                _killer;                                           // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDAIPlayerController*                 _slasherAIPlayerController;                        // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x18];                                      // 0x0070(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISlasherMoveToGrabSurvivorBehaviour">();
	}
	static class UAISlasherMoveToGrabSurvivorBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISlasherMoveToGrabSurvivorBehaviour>();
	}
};
static_assert(alignof(UAISlasherMoveToGrabSurvivorBehaviour) == 0x000008, "Wrong alignment on UAISlasherMoveToGrabSurvivorBehaviour");
static_assert(sizeof(UAISlasherMoveToGrabSurvivorBehaviour) == 0x000088, "Wrong size on UAISlasherMoveToGrabSurvivorBehaviour");
static_assert(offsetof(UAISlasherMoveToGrabSurvivorBehaviour, _behaviourData) == 0x000058, "Member 'UAISlasherMoveToGrabSurvivorBehaviour::_behaviourData' has a wrong offset!");
static_assert(offsetof(UAISlasherMoveToGrabSurvivorBehaviour, _killer) == 0x000060, "Member 'UAISlasherMoveToGrabSurvivorBehaviour::_killer' has a wrong offset!");
static_assert(offsetof(UAISlasherMoveToGrabSurvivorBehaviour, _slasherAIPlayerController) == 0x000068, "Member 'UAISlasherMoveToGrabSurvivorBehaviour::_slasherAIPlayerController' has a wrong offset!");

// Class DeadByDaylight.DBDPlayerCameraManager
// 0x0020 (0x3380 - 0x3360)
class ADBDPlayerCameraManager final : public APlayerCameraManager
{
public:
	float                                         NormalFOV;                                         // 0x3360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetingFOV;                                      // 0x3364(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TScriptInterface<class IViewRotationStrategy> _viewRotationStrategy;                             // 0x3368(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3378[0x8];                                     // 0x3378(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelCurrentFadeTimeline();
	void StartFadeInTimeline(float Duration);
	void StartFadeOutTimeline(float Duration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerCameraManager">();
	}
	static class ADBDPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDPlayerCameraManager>();
	}
};
static_assert(alignof(ADBDPlayerCameraManager) == 0x000010, "Wrong alignment on ADBDPlayerCameraManager");
static_assert(sizeof(ADBDPlayerCameraManager) == 0x003380, "Wrong size on ADBDPlayerCameraManager");
static_assert(offsetof(ADBDPlayerCameraManager, NormalFOV) == 0x003360, "Member 'ADBDPlayerCameraManager::NormalFOV' has a wrong offset!");
static_assert(offsetof(ADBDPlayerCameraManager, TargetingFOV) == 0x003364, "Member 'ADBDPlayerCameraManager::TargetingFOV' has a wrong offset!");
static_assert(offsetof(ADBDPlayerCameraManager, _viewRotationStrategy) == 0x003368, "Member 'ADBDPlayerCameraManager::_viewRotationStrategy' has a wrong offset!");

// Class DeadByDaylight.DBDLocatorComponent
// 0x0000 (0x02D0 - 0x02D0)
class UDBDLocatorComponent : public USceneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDLocatorComponent">();
	}
	static class UDBDLocatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDLocatorComponent>();
	}
};
static_assert(alignof(UDBDLocatorComponent) == 0x000010, "Wrong alignment on UDBDLocatorComponent");
static_assert(sizeof(UDBDLocatorComponent) == 0x0002D0, "Wrong size on UDBDLocatorComponent");

// Class DeadByDaylight.DBDClipRegionComponent
// 0x0010 (0x02E0 - 0x02D0)
class UDBDClipRegionComponent final : public UDBDLocatorComponent
{
public:
	TArray<struct FAffectedMaterialAndVariant>    AffectedMaterialsAndVariants;                      // 0x02D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static void ApplyArrayOfClipsToDynamicMaterial(const TArray<class UDBDClipRegionComponent*>& InRegions, class UMaterialInstanceDynamic* dynamicInstanceToClip);

	void ApplyClip(class UMaterialInstanceDynamic* InMaterial2clip, int32 InRegionID);
	void ApplyClipToDynamicMaterial(class UMaterialInstanceDynamic* dynamicInstanceToClip, int32 InRegionID);
	float ClipDistance(class UMeshComponent* InMeshComponent);
	void NotifyShouldClipComponent(class UMeshComponent* InMeshComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDClipRegionComponent">();
	}
	static class UDBDClipRegionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDClipRegionComponent>();
	}
};
static_assert(alignof(UDBDClipRegionComponent) == 0x000010, "Wrong alignment on UDBDClipRegionComponent");
static_assert(sizeof(UDBDClipRegionComponent) == 0x0002E0, "Wrong size on UDBDClipRegionComponent");
static_assert(offsetof(UDBDClipRegionComponent, AffectedMaterialsAndVariants) == 0x0002D0, "Member 'UDBDClipRegionComponent::AffectedMaterialsAndVariants' has a wrong offset!");

// Class DeadByDaylight.ManualIconStrategy
// 0x0008 (0x0040 - 0x0038)
class UManualIconStrategy final : public UBasePerkIconStrategy
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ManualIconStrategy">();
	}
	static class UManualIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UManualIconStrategy>();
	}
};
static_assert(alignof(UManualIconStrategy) == 0x000008, "Wrong alignment on UManualIconStrategy");
static_assert(sizeof(UManualIconStrategy) == 0x000040, "Wrong size on UManualIconStrategy");

// Class DeadByDaylight.AnimationMontageSlave
// 0x0010 (0x00C8 - 0x00B8)
class UAnimationMontageSlave final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMontageStarted(const struct FAnimationMontageDescriptor& ID, const float Rate);
	void OnMontageStopped(const struct FAnimationMontageDescriptor& ID);
	void SetLeader(class UMontagePlayer* Leader);
	void SetMontagePlayer(class UMontagePlayer* MontagePlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationMontageSlave">();
	}
	static class UAnimationMontageSlave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimationMontageSlave>();
	}
};
static_assert(alignof(UAnimationMontageSlave) == 0x000008, "Wrong alignment on UAnimationMontageSlave");
static_assert(sizeof(UAnimationMontageSlave) == 0x0000C8, "Wrong size on UAnimationMontageSlave");

// Class DeadByDaylight.TeamworkIconStrategy
// 0x0008 (0x0040 - 0x0038)
class UTeamworkIconStrategy final : public UBasePerkIconStrategy
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamworkIconStrategy">();
	}
	static class UTeamworkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamworkIconStrategy>();
	}
};
static_assert(alignof(UTeamworkIconStrategy) == 0x000008, "Wrong alignment on UTeamworkIconStrategy");
static_assert(sizeof(UTeamworkIconStrategy) == 0x000040, "Wrong size on UTeamworkIconStrategy");

// Class DeadByDaylight.DBDNavModifierComponent
// 0x00A0 (0x0260 - 0x01C0)
class UDBDNavModifierComponent final : public UNavModifierComponent
{
public:
	bool                                          ForceUseFailsafeExtent;                            // 0x01C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0x3];                                      // 0x01C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpdateModifierInterval;                            // 0x01C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StartNavigationRelevant;                           // 0x01C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AlwaysTickToCheckTransform;                        // 0x01C9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RelevantPassiveMode;                               // 0x01CA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CB[0x5];                                      // 0x01CB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BoundCenterOffset;                                 // 0x01D0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E8[0x78];                                     // 0x01E8(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDNavModifierComponent">();
	}
	static class UDBDNavModifierComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDNavModifierComponent>();
	}
};
static_assert(alignof(UDBDNavModifierComponent) == 0x000010, "Wrong alignment on UDBDNavModifierComponent");
static_assert(sizeof(UDBDNavModifierComponent) == 0x000260, "Wrong size on UDBDNavModifierComponent");
static_assert(offsetof(UDBDNavModifierComponent, ForceUseFailsafeExtent) == 0x0001C0, "Member 'UDBDNavModifierComponent::ForceUseFailsafeExtent' has a wrong offset!");
static_assert(offsetof(UDBDNavModifierComponent, UpdateModifierInterval) == 0x0001C4, "Member 'UDBDNavModifierComponent::UpdateModifierInterval' has a wrong offset!");
static_assert(offsetof(UDBDNavModifierComponent, StartNavigationRelevant) == 0x0001C8, "Member 'UDBDNavModifierComponent::StartNavigationRelevant' has a wrong offset!");
static_assert(offsetof(UDBDNavModifierComponent, AlwaysTickToCheckTransform) == 0x0001C9, "Member 'UDBDNavModifierComponent::AlwaysTickToCheckTransform' has a wrong offset!");
static_assert(offsetof(UDBDNavModifierComponent, RelevantPassiveMode) == 0x0001CA, "Member 'UDBDNavModifierComponent::RelevantPassiveMode' has a wrong offset!");
static_assert(offsetof(UDBDNavModifierComponent, BoundCenterOffset) == 0x0001D0, "Member 'UDBDNavModifierComponent::BoundCenterOffset' has a wrong offset!");

// Class DeadByDaylight.AnimationPreviewPreloadRequest
// 0x0020 (0x0050 - 0x0030)
class UAnimationPreviewPreloadRequest final : public UObject
{
public:
	TArray<struct FSoftObjectPath>                RequestedClasses;                                  // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnClassesLoaded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationPreviewPreloadRequest">();
	}
	static class UAnimationPreviewPreloadRequest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimationPreviewPreloadRequest>();
	}
};
static_assert(alignof(UAnimationPreviewPreloadRequest) == 0x000008, "Wrong alignment on UAnimationPreviewPreloadRequest");
static_assert(sizeof(UAnimationPreviewPreloadRequest) == 0x000050, "Wrong size on UAnimationPreviewPreloadRequest");
static_assert(offsetof(UAnimationPreviewPreloadRequest, RequestedClasses) == 0x000030, "Member 'UAnimationPreviewPreloadRequest::RequestedClasses' has a wrong offset!");

// Class DeadByDaylight.AnimationPreviewSubsystem
// 0x0058 (0x0090 - 0x0038)
class UAnimationPreviewSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x48];                                      // 0x0038(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimationPreview*                      _activePreview;                                    // 0x0080(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnimationPreviewEnd(class UAnimationPreview* Preview, bool completedSuccessfully);
	void OnAnimationPreviewStart(class UAnimationPreview* Preview);

	bool CharacterHasSecondaryMori(int32 killerId) const;
	bool IsPreviewingAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationPreviewSubsystem">();
	}
	static class UAnimationPreviewSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimationPreviewSubsystem>();
	}
};
static_assert(alignof(UAnimationPreviewSubsystem) == 0x000008, "Wrong alignment on UAnimationPreviewSubsystem");
static_assert(sizeof(UAnimationPreviewSubsystem) == 0x000090, "Wrong size on UAnimationPreviewSubsystem");
static_assert(offsetof(UAnimationPreviewSubsystem, _activePreview) == 0x000080, "Member 'UAnimationPreviewSubsystem::_activePreview' has a wrong offset!");

// Class DeadByDaylight.ScreenshotVFXCharmHook
// 0x0018 (0x0048 - 0x0030)
class UScreenshotVFXCharmHook final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FScreenshotVFXCharmHookCharm>   Charms;                                            // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenshotVFXCharmHook">();
	}
	static class UScreenshotVFXCharmHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenshotVFXCharmHook>();
	}
};
static_assert(alignof(UScreenshotVFXCharmHook) == 0x000008, "Wrong alignment on UScreenshotVFXCharmHook");
static_assert(sizeof(UScreenshotVFXCharmHook) == 0x000048, "Wrong size on UScreenshotVFXCharmHook");
static_assert(offsetof(UScreenshotVFXCharmHook, Charms) == 0x000038, "Member 'UScreenshotVFXCharmHook::Charms' has a wrong offset!");

// Class DeadByDaylight.DBDMathBlueprintLibrary
// 0x0000 (0x0030 - 0x0030)
class UDBDMathBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static TArray<struct FLinearColor> TransformToMatrix(const struct FTransform& A);
	static struct FVector VectorAbsoluteValue(const struct FVector& A);
	static bool VectorIntersect(const struct FVector& OriginA, const struct FVector& ExtentA, const struct FVector& OriginB, const struct FVector& ExtentB);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDMathBlueprintLibrary">();
	}
	static class UDBDMathBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDMathBlueprintLibrary>();
	}
};
static_assert(alignof(UDBDMathBlueprintLibrary) == 0x000008, "Wrong alignment on UDBDMathBlueprintLibrary");
static_assert(sizeof(UDBDMathBlueprintLibrary) == 0x000030, "Wrong size on UDBDMathBlueprintLibrary");

// Class DeadByDaylight.AnimNotifyState_AttachStaticMeshes
// 0x0020 (0x0058 - 0x0038)
class UAnimNotifyState_AttachStaticMeshes final : public UAnimNotifyState
{
public:
	TArray<struct FAnimNotifyAttachStaticMeshInfo> StaticMeshesToAttach;                             // 0x0038(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_AttachStaticMeshes">();
	}
	static class UAnimNotifyState_AttachStaticMeshes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_AttachStaticMeshes>();
	}
};
static_assert(alignof(UAnimNotifyState_AttachStaticMeshes) == 0x000008, "Wrong alignment on UAnimNotifyState_AttachStaticMeshes");
static_assert(sizeof(UAnimNotifyState_AttachStaticMeshes) == 0x000058, "Wrong size on UAnimNotifyState_AttachStaticMeshes");
static_assert(offsetof(UAnimNotifyState_AttachStaticMeshes, StaticMeshesToAttach) == 0x000038, "Member 'UAnimNotifyState_AttachStaticMeshes::StaticMeshesToAttach' has a wrong offset!");

// Class DeadByDaylight.NavArea_Danger
// 0x0000 (0x0050 - 0x0050)
class UNavArea_Danger final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_Danger">();
	}
	static class UNavArea_Danger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_Danger>();
	}
};
static_assert(alignof(UNavArea_Danger) == 0x000008, "Wrong alignment on UNavArea_Danger");
static_assert(sizeof(UNavArea_Danger) == 0x000050, "Wrong size on UNavArea_Danger");

// Class DeadByDaylight.AnimNotify_AttachStaticMeshes
// 0x0010 (0x0050 - 0x0040)
class UAnimNotify_AttachStaticMeshes final : public UAnimNotify
{
public:
	TArray<struct FAnimNotifyAttachStaticMeshInfoWithTag> StaticMeshesToAttach;                      // 0x0040(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_AttachStaticMeshes">();
	}
	static class UAnimNotify_AttachStaticMeshes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_AttachStaticMeshes>();
	}
};
static_assert(alignof(UAnimNotify_AttachStaticMeshes) == 0x000008, "Wrong alignment on UAnimNotify_AttachStaticMeshes");
static_assert(sizeof(UAnimNotify_AttachStaticMeshes) == 0x000050, "Wrong size on UAnimNotify_AttachStaticMeshes");
static_assert(offsetof(UAnimNotify_AttachStaticMeshes, StaticMeshesToAttach) == 0x000040, "Member 'UAnimNotify_AttachStaticMeshes::StaticMeshesToAttach' has a wrong offset!");

// Class DeadByDaylight.StartupInitializerInterface
// 0x0000 (0x0000 - 0x0000)
class IStartupInitializerInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StartupInitializerInterface">();
	}
	static class IStartupInitializerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStartupInitializerInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IStartupInitializerInterface) == 0x000001, "Wrong alignment on IStartupInitializerInterface");
static_assert(sizeof(IStartupInitializerInterface) == 0x000001, "Wrong size on IStartupInitializerInterface");

// Class DeadByDaylight.AnimNotify_GameplayTag
// 0x0010 (0x0050 - 0x0040)
class UAnimNotify_GameplayTag final : public UAnimNotify
{
public:
	struct FGameplayTag                           InformationTag;                                    // 0x0040(0x000C)(Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_GameplayTag">();
	}
	static class UAnimNotify_GameplayTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_GameplayTag>();
	}
};
static_assert(alignof(UAnimNotify_GameplayTag) == 0x000008, "Wrong alignment on UAnimNotify_GameplayTag");
static_assert(sizeof(UAnimNotify_GameplayTag) == 0x000050, "Wrong size on UAnimNotify_GameplayTag");
static_assert(offsetof(UAnimNotify_GameplayTag, InformationTag) == 0x000040, "Member 'UAnimNotify_GameplayTag::InformationTag' has a wrong offset!");

// Class DeadByDaylight.DisplayStandItemRequesterComponent
// 0x0058 (0x0110 - 0x00B8)
class UDisplayStandItemRequesterComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x58];                                      // 0x00B8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LoadItemsOnCharacter(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisplayStandItemRequesterComponent">();
	}
	static class UDisplayStandItemRequesterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisplayStandItemRequesterComponent>();
	}
};
static_assert(alignof(UDisplayStandItemRequesterComponent) == 0x000008, "Wrong alignment on UDisplayStandItemRequesterComponent");
static_assert(sizeof(UDisplayStandItemRequesterComponent) == 0x000110, "Wrong size on UDisplayStandItemRequesterComponent");

// Class DeadByDaylight.AnimNotify_PlayNiagaraEffectBasedOnTag
// 0x00D0 (0x0110 - 0x0040)
class alignas(0x10) UAnimNotify_PlayNiagaraEffectBasedOnTag final : public UAnimNotify
{
public:
	class UNiagaraSystem*                         DefaultEffectClass;                                // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AlwaysSpawnDefaultEffect;                          // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocationOffset;                                    // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0080(0x0018)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbsoluteScale;                                    // 0x0098(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         Attached : 1;                                      // 0x009C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x00A0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAnimNotifySpawnEffectInfo>     _spawnEffectInfos;                                 // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x50];                                      // 0x00C0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UFXSystemComponent* GetSpawnedDefaultEffect() const;
	class UFXSystemComponent* GetSpawnedTagBasedEffect() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PlayNiagaraEffectBasedOnTag">();
	}
	static class UAnimNotify_PlayNiagaraEffectBasedOnTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PlayNiagaraEffectBasedOnTag>();
	}
};
static_assert(alignof(UAnimNotify_PlayNiagaraEffectBasedOnTag) == 0x000010, "Wrong alignment on UAnimNotify_PlayNiagaraEffectBasedOnTag");
static_assert(sizeof(UAnimNotify_PlayNiagaraEffectBasedOnTag) == 0x000110, "Wrong size on UAnimNotify_PlayNiagaraEffectBasedOnTag");
static_assert(offsetof(UAnimNotify_PlayNiagaraEffectBasedOnTag, DefaultEffectClass) == 0x000040, "Member 'UAnimNotify_PlayNiagaraEffectBasedOnTag::DefaultEffectClass' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlayNiagaraEffectBasedOnTag, AlwaysSpawnDefaultEffect) == 0x000048, "Member 'UAnimNotify_PlayNiagaraEffectBasedOnTag::AlwaysSpawnDefaultEffect' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlayNiagaraEffectBasedOnTag, LocationOffset) == 0x000050, "Member 'UAnimNotify_PlayNiagaraEffectBasedOnTag::LocationOffset' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlayNiagaraEffectBasedOnTag, RotationOffset) == 0x000068, "Member 'UAnimNotify_PlayNiagaraEffectBasedOnTag::RotationOffset' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlayNiagaraEffectBasedOnTag, Scale) == 0x000080, "Member 'UAnimNotify_PlayNiagaraEffectBasedOnTag::Scale' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlayNiagaraEffectBasedOnTag, bAbsoluteScale) == 0x000098, "Member 'UAnimNotify_PlayNiagaraEffectBasedOnTag::bAbsoluteScale' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlayNiagaraEffectBasedOnTag, SocketName) == 0x0000A0, "Member 'UAnimNotify_PlayNiagaraEffectBasedOnTag::SocketName' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlayNiagaraEffectBasedOnTag, _spawnEffectInfos) == 0x0000B0, "Member 'UAnimNotify_PlayNiagaraEffectBasedOnTag::_spawnEffectInfos' has a wrong offset!");

// Class DeadByDaylight.OfferingUtilities
// 0x0000 (0x0030 - 0x0030)
class UOfferingUtilities final : public UBlueprintFunctionLibrary
{
public:
	static bool HasItemLossProtection(const class ADBDPlayer* Player);
	static bool HasOfferingOfType(const class UObject* WorldContextObject, EOfferingEffectType offeringEffectType, int32 PlayerId);
	static bool IsPlayerEquippedWithOfferingWithTag(const class ADBDPlayer* Player, const class FName offeringTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OfferingUtilities">();
	}
	static class UOfferingUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOfferingUtilities>();
	}
};
static_assert(alignof(UOfferingUtilities) == 0x000008, "Wrong alignment on UOfferingUtilities");
static_assert(sizeof(UOfferingUtilities) == 0x000030, "Wrong size on UOfferingUtilities");

// Class DeadByDaylight.SlasherAnimInstance
// 0x0210 (0x0560 - 0x0350)
class USlasherAnimInstance final : public UAnimInstance
{
public:
	TMulticastInlineDelegate<void()>              OnFootTrapped;                                     // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EIntroState                                   _introState;                                       // 0x0360(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrouched;                                       // 0x0361(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isRevvingChainsaw;                                // 0x0362(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAttackSuccessMontagePlaying;                    // 0x0363(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCamOn;                                          // 0x0364(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAttacking;                                      // 0x0365(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAnyMontagePlaying;                              // 0x0366(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isFrenzy;                                         // 0x0367(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isFrenzyCD;                                       // 0x0368(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInParadise;                                     // 0x0369(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _enableArmOverrideTier3;                           // 0x036A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isRingingBell;                                    // 0x036B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCarrying;                                       // 0x036C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36D[0x3];                                      // 0x036D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _firstPersonCarryOffset;                           // 0x0370(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _firstPersonCarryOffsetLookingDown;                // 0x0388(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isPassivePhaseWalking;                            // 0x03A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isActivePhaseWalking;                             // 0x03A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInAir;                                          // 0x03A2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isVaultingToFall;                                 // 0x03A3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isSpectator;                                      // 0x03A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _firstPersonView;                                  // 0x03A5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIdle;                                           // 0x03A6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _validSlasher;                                     // 0x03A7(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animDirection;                                    // 0x03A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animSpeed;                                        // 0x03AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animPitch;                                        // 0x03B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animTurning;                                      // 0x03B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animYaw;                                          // 0x03B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pelvisHeight;                                     // 0x03BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _idleTime;                                         // 0x03C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _directionSwitch;                                  // 0x03C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _leftClearFrontSpaceVector;                        // 0x03C8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _rightClearFrontSpaceVector;                       // 0x03E0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _velocity;                                         // 0x03F8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _rightFootEffectorLocation;                        // 0x0410(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _leftFootEffectorLocation;                         // 0x0428(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               _meshRotation;                                     // 0x0440(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UAnimMontage*>                   _attackSuccessAnimations;                          // 0x0458(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UAnimMontage*>                   _camOnAnimations;                                  // 0x0468(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class AKiller*                                _mySlasher;                                        // 0x0478(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTagStateBool                          _isVaultingToFallState;                            // 0x0480(0x0048)(Transient, Protected, NativeAccessSpecifierProtected)
	EInteractionAnimation                         _interactionType;                                  // 0x04C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C9[0xF];                                      // 0x04C9(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _demogorgonTeleportDuration;                       // 0x04D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4DC[0x4];                                      // 0x04DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargedAttackStateComponent*           _demogorgonChargedAttackStateComponent;            // 0x04E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDemogorgonCharging;                             // 0x04E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E9[0x3];                                      // 0x04E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _demogorgonChargingPercent;                        // 0x04EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOniDemonModeAttackStateComponent*      _oniAttackState;                                   // 0x04F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOniCharging;                                    // 0x04F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOniAttackType                                _oniAttackType;                                    // 0x04F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4FA[0x2];                                      // 0x04FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _oniChargeDuration;                                // 0x04FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttackSubstate                               _previousAttackSubstate;                           // 0x0500(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttackSubstate                               _attackSubState;                                   // 0x0501(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_502[0x6];                                      // 0x0502(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UEvilWithinComponent*                   _evilWithinComponent;                              // 0x0508(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_510[0x10];                                     // 0x0510(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UArmIKSensorComponent*                  _armIKSensorComponent;                             // 0x0520(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_528[0x18];                                     // 0x0528(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimEffectHandler*                     _animEffectHandlerForSFX;                          // 0x0540(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimEffectHandler*                     _animEffectHandlerForVFX;                          // 0x0548(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimEffectHandler>         _animEffectHandlerClassForSFX;                     // 0x0550(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimEffectHandler>         _animEffectHandlerClassForVFX;                     // 0x0558(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CallOnFootTrapped();
	void SetIsCrouched(const bool Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlasherAnimInstance">();
	}
	static class USlasherAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlasherAnimInstance>();
	}
};
static_assert(alignof(USlasherAnimInstance) == 0x000010, "Wrong alignment on USlasherAnimInstance");
static_assert(sizeof(USlasherAnimInstance) == 0x000560, "Wrong size on USlasherAnimInstance");
static_assert(offsetof(USlasherAnimInstance, OnFootTrapped) == 0x000350, "Member 'USlasherAnimInstance::OnFootTrapped' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _introState) == 0x000360, "Member 'USlasherAnimInstance::_introState' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isCrouched) == 0x000361, "Member 'USlasherAnimInstance::_isCrouched' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isRevvingChainsaw) == 0x000362, "Member 'USlasherAnimInstance::_isRevvingChainsaw' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isAttackSuccessMontagePlaying) == 0x000363, "Member 'USlasherAnimInstance::_isAttackSuccessMontagePlaying' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isCamOn) == 0x000364, "Member 'USlasherAnimInstance::_isCamOn' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isAttacking) == 0x000365, "Member 'USlasherAnimInstance::_isAttacking' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isAnyMontagePlaying) == 0x000366, "Member 'USlasherAnimInstance::_isAnyMontagePlaying' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isFrenzy) == 0x000367, "Member 'USlasherAnimInstance::_isFrenzy' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isFrenzyCD) == 0x000368, "Member 'USlasherAnimInstance::_isFrenzyCD' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isInParadise) == 0x000369, "Member 'USlasherAnimInstance::_isInParadise' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _enableArmOverrideTier3) == 0x00036A, "Member 'USlasherAnimInstance::_enableArmOverrideTier3' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isRingingBell) == 0x00036B, "Member 'USlasherAnimInstance::_isRingingBell' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isCarrying) == 0x00036C, "Member 'USlasherAnimInstance::_isCarrying' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _firstPersonCarryOffset) == 0x000370, "Member 'USlasherAnimInstance::_firstPersonCarryOffset' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _firstPersonCarryOffsetLookingDown) == 0x000388, "Member 'USlasherAnimInstance::_firstPersonCarryOffsetLookingDown' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isPassivePhaseWalking) == 0x0003A0, "Member 'USlasherAnimInstance::_isPassivePhaseWalking' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isActivePhaseWalking) == 0x0003A1, "Member 'USlasherAnimInstance::_isActivePhaseWalking' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isInAir) == 0x0003A2, "Member 'USlasherAnimInstance::_isInAir' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isVaultingToFall) == 0x0003A3, "Member 'USlasherAnimInstance::_isVaultingToFall' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isSpectator) == 0x0003A4, "Member 'USlasherAnimInstance::_isSpectator' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _firstPersonView) == 0x0003A5, "Member 'USlasherAnimInstance::_firstPersonView' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isIdle) == 0x0003A6, "Member 'USlasherAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _validSlasher) == 0x0003A7, "Member 'USlasherAnimInstance::_validSlasher' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _animDirection) == 0x0003A8, "Member 'USlasherAnimInstance::_animDirection' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _animSpeed) == 0x0003AC, "Member 'USlasherAnimInstance::_animSpeed' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _animPitch) == 0x0003B0, "Member 'USlasherAnimInstance::_animPitch' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _animTurning) == 0x0003B4, "Member 'USlasherAnimInstance::_animTurning' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _animYaw) == 0x0003B8, "Member 'USlasherAnimInstance::_animYaw' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _pelvisHeight) == 0x0003BC, "Member 'USlasherAnimInstance::_pelvisHeight' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _idleTime) == 0x0003C0, "Member 'USlasherAnimInstance::_idleTime' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _directionSwitch) == 0x0003C4, "Member 'USlasherAnimInstance::_directionSwitch' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _leftClearFrontSpaceVector) == 0x0003C8, "Member 'USlasherAnimInstance::_leftClearFrontSpaceVector' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _rightClearFrontSpaceVector) == 0x0003E0, "Member 'USlasherAnimInstance::_rightClearFrontSpaceVector' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _velocity) == 0x0003F8, "Member 'USlasherAnimInstance::_velocity' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _rightFootEffectorLocation) == 0x000410, "Member 'USlasherAnimInstance::_rightFootEffectorLocation' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _leftFootEffectorLocation) == 0x000428, "Member 'USlasherAnimInstance::_leftFootEffectorLocation' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _meshRotation) == 0x000440, "Member 'USlasherAnimInstance::_meshRotation' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _attackSuccessAnimations) == 0x000458, "Member 'USlasherAnimInstance::_attackSuccessAnimations' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _camOnAnimations) == 0x000468, "Member 'USlasherAnimInstance::_camOnAnimations' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _mySlasher) == 0x000478, "Member 'USlasherAnimInstance::_mySlasher' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isVaultingToFallState) == 0x000480, "Member 'USlasherAnimInstance::_isVaultingToFallState' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _interactionType) == 0x0004C8, "Member 'USlasherAnimInstance::_interactionType' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _demogorgonTeleportDuration) == 0x0004D8, "Member 'USlasherAnimInstance::_demogorgonTeleportDuration' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _demogorgonChargedAttackStateComponent) == 0x0004E0, "Member 'USlasherAnimInstance::_demogorgonChargedAttackStateComponent' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isDemogorgonCharging) == 0x0004E8, "Member 'USlasherAnimInstance::_isDemogorgonCharging' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _demogorgonChargingPercent) == 0x0004EC, "Member 'USlasherAnimInstance::_demogorgonChargingPercent' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _oniAttackState) == 0x0004F0, "Member 'USlasherAnimInstance::_oniAttackState' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isOniCharging) == 0x0004F8, "Member 'USlasherAnimInstance::_isOniCharging' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _oniAttackType) == 0x0004F9, "Member 'USlasherAnimInstance::_oniAttackType' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _oniChargeDuration) == 0x0004FC, "Member 'USlasherAnimInstance::_oniChargeDuration' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _previousAttackSubstate) == 0x000500, "Member 'USlasherAnimInstance::_previousAttackSubstate' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _attackSubState) == 0x000501, "Member 'USlasherAnimInstance::_attackSubState' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _evilWithinComponent) == 0x000508, "Member 'USlasherAnimInstance::_evilWithinComponent' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _armIKSensorComponent) == 0x000520, "Member 'USlasherAnimInstance::_armIKSensorComponent' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _animEffectHandlerForSFX) == 0x000540, "Member 'USlasherAnimInstance::_animEffectHandlerForSFX' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _animEffectHandlerForVFX) == 0x000548, "Member 'USlasherAnimInstance::_animEffectHandlerForVFX' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _animEffectHandlerClassForSFX) == 0x000550, "Member 'USlasherAnimInstance::_animEffectHandlerClassForSFX' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _animEffectHandlerClassForVFX) == 0x000558, "Member 'USlasherAnimInstance::_animEffectHandlerClassForVFX' has a wrong offset!");

// Class DeadByDaylight.AnimNotify_RemoveAllStaticMeshes
// 0x0000 (0x0040 - 0x0040)
class UAnimNotify_RemoveAllStaticMeshes final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_RemoveAllStaticMeshes">();
	}
	static class UAnimNotify_RemoveAllStaticMeshes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_RemoveAllStaticMeshes>();
	}
};
static_assert(alignof(UAnimNotify_RemoveAllStaticMeshes) == 0x000008, "Wrong alignment on UAnimNotify_RemoveAllStaticMeshes");
static_assert(sizeof(UAnimNotify_RemoveAllStaticMeshes) == 0x000040, "Wrong size on UAnimNotify_RemoveAllStaticMeshes");

// Class DeadByDaylight.AnimNotify_RemoveStaticMeshes
// 0x0010 (0x0050 - 0x0040)
class UAnimNotify_RemoveStaticMeshes final : public UAnimNotify
{
public:
	TArray<class FName>                           StaticMeshesToRemoveByTags;                        // 0x0040(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_RemoveStaticMeshes">();
	}
	static class UAnimNotify_RemoveStaticMeshes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_RemoveStaticMeshes>();
	}
};
static_assert(alignof(UAnimNotify_RemoveStaticMeshes) == 0x000008, "Wrong alignment on UAnimNotify_RemoveStaticMeshes");
static_assert(sizeof(UAnimNotify_RemoveStaticMeshes) == 0x000050, "Wrong size on UAnimNotify_RemoveStaticMeshes");
static_assert(offsetof(UAnimNotify_RemoveStaticMeshes, StaticMeshesToRemoveByTags) == 0x000040, "Member 'UAnimNotify_RemoveStaticMeshes::StaticMeshesToRemoveByTags' has a wrong offset!");

// Class DeadByDaylight.FranklinsDemiseConsumedByEntityComponent
// 0x0070 (0x0128 - 0x00B8)
class UFranklinsDemiseConsumedByEntityComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimerObject*                           _consumeTimer;                                     // 0x00D0(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x10];                                      // 0x00D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffect*                          _camperStatus;                                     // 0x00E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDPlayer*                             _previousOwner;                                    // 0x00F0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDPlayer*                             _originatingPerkOwner;                             // 0x00F8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargerComponent*                      _itemChargerComponent;                             // 0x0100(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x20];                                     // 0x0108(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_StartConsume(float Duration, class ADBDPlayer* previousOwner, class ADBDPlayer* Slasher);
	void OnConsumedByEntity();
	void OnRep_ConsumeTimer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FranklinsDemiseConsumedByEntityComponent">();
	}
	static class UFranklinsDemiseConsumedByEntityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFranklinsDemiseConsumedByEntityComponent>();
	}
};
static_assert(alignof(UFranklinsDemiseConsumedByEntityComponent) == 0x000008, "Wrong alignment on UFranklinsDemiseConsumedByEntityComponent");
static_assert(sizeof(UFranklinsDemiseConsumedByEntityComponent) == 0x000128, "Wrong size on UFranklinsDemiseConsumedByEntityComponent");
static_assert(offsetof(UFranklinsDemiseConsumedByEntityComponent, _consumeTimer) == 0x0000D0, "Member 'UFranklinsDemiseConsumedByEntityComponent::_consumeTimer' has a wrong offset!");
static_assert(offsetof(UFranklinsDemiseConsumedByEntityComponent, _camperStatus) == 0x0000E8, "Member 'UFranklinsDemiseConsumedByEntityComponent::_camperStatus' has a wrong offset!");
static_assert(offsetof(UFranklinsDemiseConsumedByEntityComponent, _previousOwner) == 0x0000F0, "Member 'UFranklinsDemiseConsumedByEntityComponent::_previousOwner' has a wrong offset!");
static_assert(offsetof(UFranklinsDemiseConsumedByEntityComponent, _originatingPerkOwner) == 0x0000F8, "Member 'UFranklinsDemiseConsumedByEntityComponent::_originatingPerkOwner' has a wrong offset!");
static_assert(offsetof(UFranklinsDemiseConsumedByEntityComponent, _itemChargerComponent) == 0x000100, "Member 'UFranklinsDemiseConsumedByEntityComponent::_itemChargerComponent' has a wrong offset!");

// Class DeadByDaylight.VisibleHatchRestrictedPlacementAreaStrategy
// 0x0008 (0x00B0 - 0x00A8)
class UVisibleHatchRestrictedPlacementAreaStrategy final : public URestrictedPlacementAreaStrategy
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VisibleHatchRestrictedPlacementAreaStrategy">();
	}
	static class UVisibleHatchRestrictedPlacementAreaStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVisibleHatchRestrictedPlacementAreaStrategy>();
	}
};
static_assert(alignof(UVisibleHatchRestrictedPlacementAreaStrategy) == 0x000008, "Wrong alignment on UVisibleHatchRestrictedPlacementAreaStrategy");
static_assert(sizeof(UVisibleHatchRestrictedPlacementAreaStrategy) == 0x0000B0, "Wrong size on UVisibleHatchRestrictedPlacementAreaStrategy");

// Class DeadByDaylight.AnimStaticMeshesHandlerComponent
// 0x0050 (0x0108 - 0x00B8)
class UAnimStaticMeshesHandlerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x50];                                      // 0x00B8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimStaticMeshesHandlerComponent">();
	}
	static class UAnimStaticMeshesHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimStaticMeshesHandlerComponent>();
	}
};
static_assert(alignof(UAnimStaticMeshesHandlerComponent) == 0x000008, "Wrong alignment on UAnimStaticMeshesHandlerComponent");
static_assert(sizeof(UAnimStaticMeshesHandlerComponent) == 0x000108, "Wrong size on UAnimStaticMeshesHandlerComponent");

// Class DeadByDaylight.AntiCampSelfUnhookComponent
// 0x00E0 (0x0198 - 0x00B8)
class UAntiCampSelfUnhookComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x38];                                      // 0x00B8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	ETimedEffectMeterState                        _state;                                            // 0x00F0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _maxSecondsToChargeAntiCampUnhook;                 // 0x00F8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _antiCampUnhookXYDistanceToChargeCurve;            // 0x0120(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _antiCampUnhookUpperZDistanceToChargeCurve;        // 0x0128(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _antiCampUnhookLowerZDistanceToChargeCurve;        // 0x0130(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _antiCampUnhookBasementZDistanceToChargeCurve;     // 0x0138(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _antiCampUnhookBasementLowerZDistanceToChargeCurve; // 0x0140(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _antiCampGracePeriod;                              // 0x0148(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14C[0x44];                                     // 0x014C(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _progress;                                         // 0x0190(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_194[0x4];                                      // 0x0194(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEscapeDoorActivated();
	void OnHookedSurvivorDrainStageChanged(const int32 drainStage, class ADBDPlayer* Target);
	void OnRep_Progress();
	void OnRep_State(ETimedEffectMeterState previousState);
	void SetAntiCampUnhookChargeable(class UChargeableComponent* Component);

	float GetAntiCampGracePeriod() const;
	float GetAntiCampMaxLowerZCurveDistanceTime() const;
	float GetAntiCampMaxUpperZCurveDistanceTime() const;
	float GetAntiCampMaxXYCurveDistanceTime() const;
	float GetProgress() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AntiCampSelfUnhookComponent">();
	}
	static class UAntiCampSelfUnhookComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAntiCampSelfUnhookComponent>();
	}
};
static_assert(alignof(UAntiCampSelfUnhookComponent) == 0x000008, "Wrong alignment on UAntiCampSelfUnhookComponent");
static_assert(sizeof(UAntiCampSelfUnhookComponent) == 0x000198, "Wrong size on UAntiCampSelfUnhookComponent");
static_assert(offsetof(UAntiCampSelfUnhookComponent, _state) == 0x0000F0, "Member 'UAntiCampSelfUnhookComponent::_state' has a wrong offset!");
static_assert(offsetof(UAntiCampSelfUnhookComponent, _maxSecondsToChargeAntiCampUnhook) == 0x0000F8, "Member 'UAntiCampSelfUnhookComponent::_maxSecondsToChargeAntiCampUnhook' has a wrong offset!");
static_assert(offsetof(UAntiCampSelfUnhookComponent, _antiCampUnhookXYDistanceToChargeCurve) == 0x000120, "Member 'UAntiCampSelfUnhookComponent::_antiCampUnhookXYDistanceToChargeCurve' has a wrong offset!");
static_assert(offsetof(UAntiCampSelfUnhookComponent, _antiCampUnhookUpperZDistanceToChargeCurve) == 0x000128, "Member 'UAntiCampSelfUnhookComponent::_antiCampUnhookUpperZDistanceToChargeCurve' has a wrong offset!");
static_assert(offsetof(UAntiCampSelfUnhookComponent, _antiCampUnhookLowerZDistanceToChargeCurve) == 0x000130, "Member 'UAntiCampSelfUnhookComponent::_antiCampUnhookLowerZDistanceToChargeCurve' has a wrong offset!");
static_assert(offsetof(UAntiCampSelfUnhookComponent, _antiCampUnhookBasementZDistanceToChargeCurve) == 0x000138, "Member 'UAntiCampSelfUnhookComponent::_antiCampUnhookBasementZDistanceToChargeCurve' has a wrong offset!");
static_assert(offsetof(UAntiCampSelfUnhookComponent, _antiCampUnhookBasementLowerZDistanceToChargeCurve) == 0x000140, "Member 'UAntiCampSelfUnhookComponent::_antiCampUnhookBasementLowerZDistanceToChargeCurve' has a wrong offset!");
static_assert(offsetof(UAntiCampSelfUnhookComponent, _antiCampGracePeriod) == 0x000148, "Member 'UAntiCampSelfUnhookComponent::_antiCampGracePeriod' has a wrong offset!");
static_assert(offsetof(UAntiCampSelfUnhookComponent, _progress) == 0x000190, "Member 'UAntiCampSelfUnhookComponent::_progress' has a wrong offset!");

// Class DeadByDaylight.OfferingEffectCollection
// 0x0050 (0x0088 - 0x0038)
class UOfferingEffectCollection final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool HasOfferingOfType(EOfferingEffectType Type, int32 PlayerId, class FName Tag) const;
	bool HasOfferingWithTag(int32 PlayerId, class FName Tag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OfferingEffectCollection">();
	}
	static class UOfferingEffectCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOfferingEffectCollection>();
	}
};
static_assert(alignof(UOfferingEffectCollection) == 0x000008, "Wrong alignment on UOfferingEffectCollection");
static_assert(sizeof(UOfferingEffectCollection) == 0x000088, "Wrong size on UOfferingEffectCollection");

// Class DeadByDaylight.SurvivorHitSprintEffect
// 0x0000 (0x0398 - 0x0398)
class USurvivorHitSprintEffect final : public UStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorHitSprintEffect">();
	}
	static class USurvivorHitSprintEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorHitSprintEffect>();
	}
};
static_assert(alignof(USurvivorHitSprintEffect) == 0x000008, "Wrong alignment on USurvivorHitSprintEffect");
static_assert(sizeof(USurvivorHitSprintEffect) == 0x000398, "Wrong size on USurvivorHitSprintEffect");

// Class DeadByDaylight.SearchableItemStrategy
// 0x0008 (0x0038 - 0x0030)
class USearchableItemStrategy : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SearchableItemStrategy">();
	}
	static class USearchableItemStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USearchableItemStrategy>();
	}
};
static_assert(alignof(USearchableItemStrategy) == 0x000008, "Wrong alignment on USearchableItemStrategy");
static_assert(sizeof(USearchableItemStrategy) == 0x000038, "Wrong size on USearchableItemStrategy");

// Class DeadByDaylight.SpecificTypeChestItemStrategy
// 0x0008 (0x0040 - 0x0038)
class USpecificTypeChestItemStrategy final : public USearchableItemStrategy
{
public:
	EItemRarity                                   ItemRarity;                                        // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecificTypeChestItemStrategy">();
	}
	static class USpecificTypeChestItemStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpecificTypeChestItemStrategy>();
	}
};
static_assert(alignof(USpecificTypeChestItemStrategy) == 0x000008, "Wrong alignment on USpecificTypeChestItemStrategy");
static_assert(sizeof(USpecificTypeChestItemStrategy) == 0x000040, "Wrong size on USpecificTypeChestItemStrategy");
static_assert(offsetof(USpecificTypeChestItemStrategy, ItemRarity) == 0x000038, "Member 'USpecificTypeChestItemStrategy::ItemRarity' has a wrong offset!");

// Class DeadByDaylight.AnyPlayerHasPerkCategoryConditionStrategy
// 0x0008 (0x0038 - 0x0030)
class UAnyPlayerHasPerkCategoryConditionStrategy final : public UBaseSpawnConditionStrategy
{
public:
	class UClass*                                 _parentClass;                                      // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnyPlayerHasPerkCategoryConditionStrategy">();
	}
	static class UAnyPlayerHasPerkCategoryConditionStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnyPlayerHasPerkCategoryConditionStrategy>();
	}
};
static_assert(alignof(UAnyPlayerHasPerkCategoryConditionStrategy) == 0x000008, "Wrong alignment on UAnyPlayerHasPerkCategoryConditionStrategy");
static_assert(sizeof(UAnyPlayerHasPerkCategoryConditionStrategy) == 0x000038, "Wrong size on UAnyPlayerHasPerkCategoryConditionStrategy");
static_assert(offsetof(UAnyPlayerHasPerkCategoryConditionStrategy, _parentClass) == 0x000030, "Member 'UAnyPlayerHasPerkCategoryConditionStrategy::_parentClass' has a wrong offset!");

// Class DeadByDaylight.DBDOutlineComponentConfiguration
// 0x0100 (0x0138 - 0x0038)
class UDBDOutlineComponentConfiguration : public UDataAsset
{
public:
	TMap<TSoftClassPtr<class UClass>, struct FOutlineConfig> OutlineConfigs;                         // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FOutlineColourConfiguration> OutlineColours;                            // 0x0088(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UMaterialInterface>> TranslucencyDefaultMaterials;                   // 0x00D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FOutlineOverrideConfig> OutlineOverrideConfigs;                 // 0x00E8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDOutlineComponentConfiguration">();
	}
	static class UDBDOutlineComponentConfiguration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDOutlineComponentConfiguration>();
	}
};
static_assert(alignof(UDBDOutlineComponentConfiguration) == 0x000008, "Wrong alignment on UDBDOutlineComponentConfiguration");
static_assert(sizeof(UDBDOutlineComponentConfiguration) == 0x000138, "Wrong size on UDBDOutlineComponentConfiguration");
static_assert(offsetof(UDBDOutlineComponentConfiguration, OutlineConfigs) == 0x000038, "Member 'UDBDOutlineComponentConfiguration::OutlineConfigs' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponentConfiguration, OutlineColours) == 0x000088, "Member 'UDBDOutlineComponentConfiguration::OutlineColours' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponentConfiguration, TranslucencyDefaultMaterials) == 0x0000D8, "Member 'UDBDOutlineComponentConfiguration::TranslucencyDefaultMaterials' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponentConfiguration, OutlineOverrideConfigs) == 0x0000E8, "Member 'UDBDOutlineComponentConfiguration::OutlineOverrideConfigs' has a wrong offset!");

// Class DeadByDaylight.DBDOutlineComponentTranslucentConfiguration
// 0x0000 (0x0138 - 0x0138)
class UDBDOutlineComponentTranslucentConfiguration final : public UDBDOutlineComponentConfiguration
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDOutlineComponentTranslucentConfiguration">();
	}
	static class UDBDOutlineComponentTranslucentConfiguration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDOutlineComponentTranslucentConfiguration>();
	}
};
static_assert(alignof(UDBDOutlineComponentTranslucentConfiguration) == 0x000008, "Wrong alignment on UDBDOutlineComponentTranslucentConfiguration");
static_assert(sizeof(UDBDOutlineComponentTranslucentConfiguration) == 0x000138, "Wrong size on UDBDOutlineComponentTranslucentConfiguration");

// Class DeadByDaylight.OverlayMenuScreen
// 0x01E0 (0x0308 - 0x0128)
class UOverlayMenuScreen final : public UScreenBase
{
public:
	uint8                                         Pad_128[0x1E0];                                    // 0x0128(0x01E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAimAssistClick(bool Value);
	void OnAtlantaSettingButtonClick(int32 buttonId);
	void OnBackButtonClick();
	void OnCustomerSupportButtonClick();
	void OnEULAButtonClick();
	void OnForumsButtonClick();
	void OnKillerCameraSensitivityChanged(int32 Value);
	void OnLanguageChange(int32 Value);
	void OnPrivacyPolicyButtonClick();
	void OnQuitButtonClick();
	void OnRequestKeyBindingInput(int32 ID, const class FString& Key);
	void OnResetDefaultKeybindings();
	void OnResetDefaultSettings();
	void OnSelectTab(int32 TabIndex);
	void OnSetScrollPromptVisibility(bool IsVisible);
	void OnSettingsOptionButtonClicked(int32 ID);
	void OnSettingsOptionCheckboxSelected(int32 ID, bool IsSelected);
	void OnSettingsOptionIntValueChanged(int32 ID, int32 Value);
	void OnSurvivorCameraSensitivityChanged(int32 Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OverlayMenuScreen">();
	}
	static class UOverlayMenuScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOverlayMenuScreen>();
	}
};
static_assert(alignof(UOverlayMenuScreen) == 0x000008, "Wrong alignment on UOverlayMenuScreen");
static_assert(sizeof(UOverlayMenuScreen) == 0x000308, "Wrong size on UOverlayMenuScreen");

// Class DeadByDaylight.AnyPlayerHasPerkConditionStrategy
// 0x0018 (0x0048 - 0x0030)
class UAnyPlayerHasPerkConditionStrategy final : public UBaseSpawnConditionStrategy
{
public:
	EPlayerRole                                   _playerRole;                                       // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPerkIdDropdown                        _perk;                                             // 0x0034(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnyPlayerHasPerkConditionStrategy">();
	}
	static class UAnyPlayerHasPerkConditionStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnyPlayerHasPerkConditionStrategy>();
	}
};
static_assert(alignof(UAnyPlayerHasPerkConditionStrategy) == 0x000008, "Wrong alignment on UAnyPlayerHasPerkConditionStrategy");
static_assert(sizeof(UAnyPlayerHasPerkConditionStrategy) == 0x000048, "Wrong size on UAnyPlayerHasPerkConditionStrategy");
static_assert(offsetof(UAnyPlayerHasPerkConditionStrategy, _playerRole) == 0x000030, "Member 'UAnyPlayerHasPerkConditionStrategy::_playerRole' has a wrong offset!");
static_assert(offsetof(UAnyPlayerHasPerkConditionStrategy, _perk) == 0x000034, "Member 'UAnyPlayerHasPerkConditionStrategy::_perk' has a wrong offset!");

// Class DeadByDaylight.StateTagApplyingZone
// 0x0010 (0x0350 - 0x0340)
class UStateTagApplyingZone final : public UConfigurableCollisionComponent
{
public:
	TArray<struct FGameplayTag>                   _tagsToAdd;                                        // 0x0338(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class ADBDPlayer>                 _classFilter;                                      // 0x0348(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateTagApplyingZone">();
	}
	static class UStateTagApplyingZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateTagApplyingZone>();
	}
};
static_assert(alignof(UStateTagApplyingZone) == 0x000010, "Wrong alignment on UStateTagApplyingZone");
static_assert(sizeof(UStateTagApplyingZone) == 0x000350, "Wrong size on UStateTagApplyingZone");
static_assert(offsetof(UStateTagApplyingZone, _tagsToAdd) == 0x000338, "Member 'UStateTagApplyingZone::_tagsToAdd' has a wrong offset!");
static_assert(offsetof(UStateTagApplyingZone, _classFilter) == 0x000348, "Member 'UStateTagApplyingZone::_classFilter' has a wrong offset!");

// Class DeadByDaylight.ApplicableActivationTimerElapsedIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UApplicableActivationTimerElapsedIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ApplicableActivationTimerElapsedIconStrategy">();
	}
	static class UApplicableActivationTimerElapsedIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UApplicableActivationTimerElapsedIconStrategy>();
	}
};
static_assert(alignof(UApplicableActivationTimerElapsedIconStrategy) == 0x000008, "Wrong alignment on UApplicableActivationTimerElapsedIconStrategy");
static_assert(sizeof(UApplicableActivationTimerElapsedIconStrategy) == 0x000038, "Wrong size on UApplicableActivationTimerElapsedIconStrategy");

// Class DeadByDaylight.ApplicableActivationTimerRemainingIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UApplicableActivationTimerRemainingIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ApplicableActivationTimerRemainingIconStrategy">();
	}
	static class UApplicableActivationTimerRemainingIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UApplicableActivationTimerRemainingIconStrategy>();
	}
};
static_assert(alignof(UApplicableActivationTimerRemainingIconStrategy) == 0x000008, "Wrong alignment on UApplicableActivationTimerRemainingIconStrategy");
static_assert(sizeof(UApplicableActivationTimerRemainingIconStrategy) == 0x000038, "Wrong size on UApplicableActivationTimerRemainingIconStrategy");

// Class DeadByDaylight.SurvivorExposerInstanceManagerComponent
// 0x0040 (0x00F8 - 0x00B8)
class USurvivorExposerInstanceManagerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ASurvivorExposerInstance*>       _exposerInstances;                                 // 0x00D0(0x0010)(Net, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UExposerInteriorZoneComponent*          _interiorZone;                                     // 0x00E0(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _aggravationLevel;                                 // 0x00E8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _spawnEnabled;                                     // 0x00EC(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isVisible;                                        // 0x00ED(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EE[0x2];                                       // 0x00EE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _maxNumExposerInstances;                           // 0x00F0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorExposerInstanceManagerComponent">();
	}
	static class USurvivorExposerInstanceManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorExposerInstanceManagerComponent>();
	}
};
static_assert(alignof(USurvivorExposerInstanceManagerComponent) == 0x000008, "Wrong alignment on USurvivorExposerInstanceManagerComponent");
static_assert(sizeof(USurvivorExposerInstanceManagerComponent) == 0x0000F8, "Wrong size on USurvivorExposerInstanceManagerComponent");
static_assert(offsetof(USurvivorExposerInstanceManagerComponent, _exposerInstances) == 0x0000D0, "Member 'USurvivorExposerInstanceManagerComponent::_exposerInstances' has a wrong offset!");
static_assert(offsetof(USurvivorExposerInstanceManagerComponent, _interiorZone) == 0x0000E0, "Member 'USurvivorExposerInstanceManagerComponent::_interiorZone' has a wrong offset!");
static_assert(offsetof(USurvivorExposerInstanceManagerComponent, _aggravationLevel) == 0x0000E8, "Member 'USurvivorExposerInstanceManagerComponent::_aggravationLevel' has a wrong offset!");
static_assert(offsetof(USurvivorExposerInstanceManagerComponent, _spawnEnabled) == 0x0000EC, "Member 'USurvivorExposerInstanceManagerComponent::_spawnEnabled' has a wrong offset!");
static_assert(offsetof(USurvivorExposerInstanceManagerComponent, _isVisible) == 0x0000ED, "Member 'USurvivorExposerInstanceManagerComponent::_isVisible' has a wrong offset!");
static_assert(offsetof(USurvivorExposerInstanceManagerComponent, _maxNumExposerInstances) == 0x0000F0, "Member 'USurvivorExposerInstanceManagerComponent::_maxNumExposerInstances' has a wrong offset!");

// Class DeadByDaylight.DBDOutlineComponent
// 0x00F0 (0x0450 - 0x0360)
class UDBDOutlineComponent final : public UBatchMeshCommands
{
public:
	float                                         InterpolationSpeed;                                // 0x0360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldBeAboveOutlines;                             // 0x0364(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceOutlineFarAway;                               // 0x0365(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LimitToCustomDepthObjects;                         // 0x0366(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FadeOutAsClosingIn;                                // 0x0367(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAlwaysVisible;                                   // 0x0368(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_369[0x3];                                      // 0x0369(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumOutlineDistanceWhenIsAlwaysVisible;         // 0x036C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumOutlineDistance;                            // 0x0370(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_374[0x4];                                      // 0x0374(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 OutlineName;                                       // 0x0378(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_388[0x58];                                     // 0x0388(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDOutlineRenderStrategySelector      _renderStrategySelector;                           // 0x03E0(0x0040)(Transient, NativeAccessSpecifierPrivate)
	class UBatchMeshCommands*                     _batchMeshCommands;                                // 0x0420(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_428[0x10];                                     // 0x0428(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseOutlineRenderStrategy*             _renderingStrategy;                                // 0x0438(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_440[0x10];                                     // 0x0440(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitBatcher();
	void OnLevelReadyToPlay();
	void RefreshOutlineComponent();
	void ResetToTransparent();
	void SetFadeIntensity(float fadeIntensity);
	void SetFadeTexture(class UTexture* inFadeTexture);
	void SetIsOccludingOutlines(const bool isOccluding);
	void SetMaterialCopyTarget(class UMaterialInterface* inMaterialToCopy);
	void SetMinimumOutlineDistance(float distanceWhenIsAlwaysVisible, float Distance);
	void SetOutlineIntensity(float outlineIntensity);
	void SetOutlineMaterialOverride(const struct FGameplayTag& OverrideName);
	void SetTargetColor(const struct FLinearColor& Color);

	const struct FLinearColor GetTargetColor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDOutlineComponent">();
	}
	static class UDBDOutlineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDOutlineComponent>();
	}
};
static_assert(alignof(UDBDOutlineComponent) == 0x000010, "Wrong alignment on UDBDOutlineComponent");
static_assert(sizeof(UDBDOutlineComponent) == 0x000450, "Wrong size on UDBDOutlineComponent");
static_assert(offsetof(UDBDOutlineComponent, InterpolationSpeed) == 0x000360, "Member 'UDBDOutlineComponent::InterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponent, ShouldBeAboveOutlines) == 0x000364, "Member 'UDBDOutlineComponent::ShouldBeAboveOutlines' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponent, ForceOutlineFarAway) == 0x000365, "Member 'UDBDOutlineComponent::ForceOutlineFarAway' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponent, LimitToCustomDepthObjects) == 0x000366, "Member 'UDBDOutlineComponent::LimitToCustomDepthObjects' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponent, FadeOutAsClosingIn) == 0x000367, "Member 'UDBDOutlineComponent::FadeOutAsClosingIn' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponent, IsAlwaysVisible) == 0x000368, "Member 'UDBDOutlineComponent::IsAlwaysVisible' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponent, MinimumOutlineDistanceWhenIsAlwaysVisible) == 0x00036C, "Member 'UDBDOutlineComponent::MinimumOutlineDistanceWhenIsAlwaysVisible' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponent, MinimumOutlineDistance) == 0x000370, "Member 'UDBDOutlineComponent::MinimumOutlineDistance' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponent, OutlineName) == 0x000378, "Member 'UDBDOutlineComponent::OutlineName' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponent, _renderStrategySelector) == 0x0003E0, "Member 'UDBDOutlineComponent::_renderStrategySelector' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponent, _batchMeshCommands) == 0x000420, "Member 'UDBDOutlineComponent::_batchMeshCommands' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponent, _renderingStrategy) == 0x000438, "Member 'UDBDOutlineComponent::_renderingStrategy' has a wrong offset!");

// Class DeadByDaylight.ApplicableAndStealthRatioIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UApplicableAndStealthRatioIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ApplicableAndStealthRatioIconStrategy">();
	}
	static class UApplicableAndStealthRatioIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UApplicableAndStealthRatioIconStrategy>();
	}
};
static_assert(alignof(UApplicableAndStealthRatioIconStrategy) == 0x000008, "Wrong alignment on UApplicableAndStealthRatioIconStrategy");
static_assert(sizeof(UApplicableAndStealthRatioIconStrategy) == 0x000038, "Wrong size on UApplicableAndStealthRatioIconStrategy");

// Class DeadByDaylight.OfferingCard
// 0x0020 (0x02C0 - 0x02A0)
class AOfferingCard final : public AActor
{
public:
	TArray<struct FRarityTexture>                 _rarityTextures;                                   // 0x02A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FOfferingTypeTexture>           _offeringTypeTextures;                             // 0x02B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void ChangeAnimationClass(const TSubclassOf<class UOfferingCardAnim>& animationClass);
	void ChangeState(EOfferingAnimState State);
	void HandleCardDissolved();
	void HandleStateChanged(EOfferingAnimState State);

	class UOfferingCardAnim* GetCardAnimation() const;
	EOfferingAnimState GetState() const;
	bool IsRevealed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OfferingCard">();
	}
	static class AOfferingCard* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOfferingCard>();
	}
};
static_assert(alignof(AOfferingCard) == 0x000008, "Wrong alignment on AOfferingCard");
static_assert(sizeof(AOfferingCard) == 0x0002C0, "Wrong size on AOfferingCard");
static_assert(offsetof(AOfferingCard, _rarityTextures) == 0x0002A0, "Member 'AOfferingCard::_rarityTextures' has a wrong offset!");
static_assert(offsetof(AOfferingCard, _offeringTypeTextures) == 0x0002B0, "Member 'AOfferingCard::_offeringTypeTextures' has a wrong offset!");

// Class DeadByDaylight.TokenCounter
// 0x0028 (0x0058 - 0x0030)
class UTokenCounter final : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _tokenCount;                                       // 0x0048(0x0004)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _maxTokenCount;                                    // 0x004C(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_DecrementToken();
	void Authority_IncrementToken();
	void Authority_SetMaxTokenCount(int32 Value);
	void Authority_SetTokenCount(int32 Value);
	void OnRep_TokenCount(int32 oldCount);

	int32 GetMaxTokenCount() const;
	int32 GetTokenCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TokenCounter">();
	}
	static class UTokenCounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTokenCounter>();
	}
};
static_assert(alignof(UTokenCounter) == 0x000008, "Wrong alignment on UTokenCounter");
static_assert(sizeof(UTokenCounter) == 0x000058, "Wrong size on UTokenCounter");
static_assert(offsetof(UTokenCounter, _tokenCount) == 0x000048, "Member 'UTokenCounter::_tokenCount' has a wrong offset!");
static_assert(offsetof(UTokenCounter, _maxTokenCount) == 0x00004C, "Member 'UTokenCounter::_maxTokenCount' has a wrong offset!");

// Class DeadByDaylight.ApplicableCooldownPerkIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UApplicableCooldownPerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ApplicableCooldownPerkIconStrategy">();
	}
	static class UApplicableCooldownPerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UApplicableCooldownPerkIconStrategy>();
	}
};
static_assert(alignof(UApplicableCooldownPerkIconStrategy) == 0x000008, "Wrong alignment on UApplicableCooldownPerkIconStrategy");
static_assert(sizeof(UApplicableCooldownPerkIconStrategy) == 0x000038, "Wrong size on UApplicableCooldownPerkIconStrategy");

// Class DeadByDaylight.ArchivesHelper
// 0x0000 (0x0030 - 0x0030)
class UArchivesHelper final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchivesHelper">();
	}
	static class UArchivesHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArchivesHelper>();
	}
};
static_assert(alignof(UArchivesHelper) == 0x000008, "Wrong alignment on UArchivesHelper");
static_assert(sizeof(UArchivesHelper) == 0x000030, "Wrong size on UArchivesHelper");

// Class DeadByDaylight.DBD_CrossDissolver
// 0x0030 (0x00E8 - 0x00B8)
class UDBD_CrossDissolver final : public UActorComponent
{
public:
	TArray<class UMaterialInterface*>             NewMaterials;                                      // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class USkeletalMeshComponent*>         BaseSkeletalMesh;                                  // 0x00C8(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USkeletalMeshComponent*>         ClonedSkeletalMeshes;                              // 0x00D8(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	void KillClone();
	void MakeClone();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBD_CrossDissolver">();
	}
	static class UDBD_CrossDissolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBD_CrossDissolver>();
	}
};
static_assert(alignof(UDBD_CrossDissolver) == 0x000008, "Wrong alignment on UDBD_CrossDissolver");
static_assert(sizeof(UDBD_CrossDissolver) == 0x0000E8, "Wrong size on UDBD_CrossDissolver");
static_assert(offsetof(UDBD_CrossDissolver, NewMaterials) == 0x0000B8, "Member 'UDBD_CrossDissolver::NewMaterials' has a wrong offset!");
static_assert(offsetof(UDBD_CrossDissolver, BaseSkeletalMesh) == 0x0000C8, "Member 'UDBD_CrossDissolver::BaseSkeletalMesh' has a wrong offset!");
static_assert(offsetof(UDBD_CrossDissolver, ClonedSkeletalMeshes) == 0x0000D8, "Member 'UDBD_CrossDissolver::ClonedSkeletalMeshes' has a wrong offset!");

// Class DeadByDaylight.StoreSegmentationSubsystem
// 0x0480 (0x04B8 - 0x0038)
class UStoreSegmentationSubsystem final : public UGameInstanceSubsystem
{
public:
	class UDBDGameInstance*                       _dbdGameInstance;                                  // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x478];                                     // 0x0040(0x0478)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreSegmentationSubsystem">();
	}
	static class UStoreSegmentationSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreSegmentationSubsystem>();
	}
};
static_assert(alignof(UStoreSegmentationSubsystem) == 0x000008, "Wrong alignment on UStoreSegmentationSubsystem");
static_assert(sizeof(UStoreSegmentationSubsystem) == 0x0004B8, "Wrong size on UStoreSegmentationSubsystem");
static_assert(offsetof(UStoreSegmentationSubsystem, _dbdGameInstance) == 0x000038, "Member 'UStoreSegmentationSubsystem::_dbdGameInstance' has a wrong offset!");

// Class DeadByDaylight.ArchivesManager
// 0x0038 (0x0070 - 0x0038)
class UArchivesManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UArchiveStoriesContainer*               _storiesContainer;                                 // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UArchiveVignettesContainer*             _vignettesContainer;                               // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URewardTrackContainer*                  _rewardTrackContainer;                             // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchivesManager">();
	}
	static class UArchivesManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArchivesManager>();
	}
};
static_assert(alignof(UArchivesManager) == 0x000008, "Wrong alignment on UArchivesManager");
static_assert(sizeof(UArchivesManager) == 0x000070, "Wrong size on UArchivesManager");
static_assert(offsetof(UArchivesManager, _storiesContainer) == 0x000058, "Member 'UArchivesManager::_storiesContainer' has a wrong offset!");
static_assert(offsetof(UArchivesManager, _vignettesContainer) == 0x000060, "Member 'UArchivesManager::_vignettesContainer' has a wrong offset!");
static_assert(offsetof(UArchivesManager, _rewardTrackContainer) == 0x000068, "Member 'UArchivesManager::_rewardTrackContainer' has a wrong offset!");

// Class DeadByDaylight.ArchivesSpecialBehavioursHelper
// 0x0000 (0x0030 - 0x0030)
class UArchivesSpecialBehavioursHelper final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchivesSpecialBehavioursHelper">();
	}
	static class UArchivesSpecialBehavioursHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArchivesSpecialBehavioursHelper>();
	}
};
static_assert(alignof(UArchivesSpecialBehavioursHelper) == 0x000008, "Wrong alignment on UArchivesSpecialBehavioursHelper");
static_assert(sizeof(UArchivesSpecialBehavioursHelper) == 0x000030, "Wrong size on UArchivesSpecialBehavioursHelper");

// Class DeadByDaylight.Pallet
// 0x01E0 (0x0588 - 0x03A8)
class APallet final : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PalletDownEvadeDoorFrontPointOffset;               // 0x03B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B4[0x1C];                                     // 0x03B4(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(EPalletState newState)> Cosmetic_OnPalletStateChanged;             // 0x03D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EPalletState                                  _state;                                            // 0x03E0(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isPendingDestruction;                             // 0x03E1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIllusionaryPalletDown;                          // 0x03E2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDestroyedByEntity;                              // 0x03E3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E4[0x4];                                      // 0x03E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMontagePlayer*                         _montagePlayer;                                    // 0x03E8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationMontageSlave*                 _animationMontageSlave;                            // 0x03F0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _leftInteractionSceneComponent;                    // 0x03F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _rightInteractionSceneComponent;                   // 0x0400(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionDefinition*                 _destroyLeft;                                      // 0x0408(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractionDefinition*                 _destroyRight;                                     // 0x0410(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          _pushBox;                                          // 0x0418(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          _downedPalletCollider;                             // 0x0420(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPrimitiveComponent*                    _upPalletCollider;                                 // 0x0428(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxDotproductThresholdForPulldownAccross;         // 0x0430(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _fallDuration;                                     // 0x0434(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          _stunBoxLeft;                                      // 0x0438(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          _stunBoxRight;                                     // 0x0440(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class AActor*>                           _stunnedActors;                                    // 0x0448(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class ADBDPlayer*                             _playerExecutingPulldown;                          // 0x0498(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPalletPushSettings                    _pushSettings;                                     // 0x04A0(0x0002)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A2[0x3E];                                     // 0x04A2(0x003E)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDNavEvadeLoopComponent*              _navEvadeLoopComponent;                            // 0x04E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalletPulldownBlockerComponent*        _palletPulldownBlockerComponent;                   // 0x04E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isDreamPallet;                                    // 0x04F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isFragile;                                        // 0x04F1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F2[0x6];                                      // 0x04F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USpawnedActorReplicationComponent*      _spawnedActorReplicationComponent;                 // 0x04F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_500[0x88];                                     // 0x0500(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnOverlapPushBox(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void BP_ExplodePallet(class ADBDPlayer* Player);
	void Cosmetic_OnPalletPulldownBlockedByEntityHide();
	void Cosmetic_OnPalletPulldownBlockedByEntityShow();
	void Cosmetic_PalletPullDownFXImmediateHide();
	void EntityExplodePallet(class ADBDPlayer* Player);
	void ExplodePallet(class ADBDPlayer* Player, bool kickPallet);
	void ExplodeStunPallet(class ADBDPlayer* Player);
	class UPrimitiveComponent* GetZoneForRestrictedPlacement();
	void Multicast_ExplodePallet(class ADBDPlayer* Player, bool byEntity);
	void Multicast_PulldownPallet();
	void Multicast_ResetPallet();
	void Multicast_StunActor(class AActor* Actor, class ADBDPlayer* playerPullingDown, bool stunBreakPallet);
	void OnFallen();
	void OnPalletPulledUp_BP();
	void OnPalletStunHit();
	void OnPulldownOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnStunOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void PullDown(class ADBDPlayer* Player, const struct FPalletPushSettings& pushSettings, const EPalletStunZoneSideStrategy stunZoneSideStrategy);
	void PulldownPallet();
	void ResetPallet();
	void SetPalletState(EPalletState State);
	void SetPendingDestruction(bool IsPendingDestruction);

	bool CanPulldown(const class ADBDPlayer* Player, const struct FVector& interactionAxis, const bool isStationary) const;
	void GetDestructibleAreaPrimitiveComponents(TArray<class UPrimitiveComponent*>* prims) const;
	float GetFallDuration() const;
	bool GetIsDreamPallet() const;
	bool GetIsFragile() const;
	bool GetIsPulledDown() const;
	class USkeletalMeshComponent* GetPalletSkeletalMeshComponent() const;
	class ADBDPlayer* GetPlayerDoingPulldown() const;
	bool IsDestroyedByEntity() const;
	bool IsPendingDestruction() const;
	bool IsPulldownBlockedByEntity() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Pallet">();
	}
	static class APallet* GetDefaultObj()
	{
		return GetDefaultObjImpl<APallet>();
	}
};
static_assert(alignof(APallet) == 0x000008, "Wrong alignment on APallet");
static_assert(sizeof(APallet) == 0x000588, "Wrong size on APallet");
static_assert(offsetof(APallet, PalletDownEvadeDoorFrontPointOffset) == 0x0003B0, "Member 'APallet::PalletDownEvadeDoorFrontPointOffset' has a wrong offset!");
static_assert(offsetof(APallet, Cosmetic_OnPalletStateChanged) == 0x0003D0, "Member 'APallet::Cosmetic_OnPalletStateChanged' has a wrong offset!");
static_assert(offsetof(APallet, _state) == 0x0003E0, "Member 'APallet::_state' has a wrong offset!");
static_assert(offsetof(APallet, _isPendingDestruction) == 0x0003E1, "Member 'APallet::_isPendingDestruction' has a wrong offset!");
static_assert(offsetof(APallet, _isIllusionaryPalletDown) == 0x0003E2, "Member 'APallet::_isIllusionaryPalletDown' has a wrong offset!");
static_assert(offsetof(APallet, _isDestroyedByEntity) == 0x0003E3, "Member 'APallet::_isDestroyedByEntity' has a wrong offset!");
static_assert(offsetof(APallet, _montagePlayer) == 0x0003E8, "Member 'APallet::_montagePlayer' has a wrong offset!");
static_assert(offsetof(APallet, _animationMontageSlave) == 0x0003F0, "Member 'APallet::_animationMontageSlave' has a wrong offset!");
static_assert(offsetof(APallet, _leftInteractionSceneComponent) == 0x0003F8, "Member 'APallet::_leftInteractionSceneComponent' has a wrong offset!");
static_assert(offsetof(APallet, _rightInteractionSceneComponent) == 0x000400, "Member 'APallet::_rightInteractionSceneComponent' has a wrong offset!");
static_assert(offsetof(APallet, _destroyLeft) == 0x000408, "Member 'APallet::_destroyLeft' has a wrong offset!");
static_assert(offsetof(APallet, _destroyRight) == 0x000410, "Member 'APallet::_destroyRight' has a wrong offset!");
static_assert(offsetof(APallet, _pushBox) == 0x000418, "Member 'APallet::_pushBox' has a wrong offset!");
static_assert(offsetof(APallet, _downedPalletCollider) == 0x000420, "Member 'APallet::_downedPalletCollider' has a wrong offset!");
static_assert(offsetof(APallet, _upPalletCollider) == 0x000428, "Member 'APallet::_upPalletCollider' has a wrong offset!");
static_assert(offsetof(APallet, _maxDotproductThresholdForPulldownAccross) == 0x000430, "Member 'APallet::_maxDotproductThresholdForPulldownAccross' has a wrong offset!");
static_assert(offsetof(APallet, _fallDuration) == 0x000434, "Member 'APallet::_fallDuration' has a wrong offset!");
static_assert(offsetof(APallet, _stunBoxLeft) == 0x000438, "Member 'APallet::_stunBoxLeft' has a wrong offset!");
static_assert(offsetof(APallet, _stunBoxRight) == 0x000440, "Member 'APallet::_stunBoxRight' has a wrong offset!");
static_assert(offsetof(APallet, _stunnedActors) == 0x000448, "Member 'APallet::_stunnedActors' has a wrong offset!");
static_assert(offsetof(APallet, _playerExecutingPulldown) == 0x000498, "Member 'APallet::_playerExecutingPulldown' has a wrong offset!");
static_assert(offsetof(APallet, _pushSettings) == 0x0004A0, "Member 'APallet::_pushSettings' has a wrong offset!");
static_assert(offsetof(APallet, _navEvadeLoopComponent) == 0x0004E0, "Member 'APallet::_navEvadeLoopComponent' has a wrong offset!");
static_assert(offsetof(APallet, _palletPulldownBlockerComponent) == 0x0004E8, "Member 'APallet::_palletPulldownBlockerComponent' has a wrong offset!");
static_assert(offsetof(APallet, _isDreamPallet) == 0x0004F0, "Member 'APallet::_isDreamPallet' has a wrong offset!");
static_assert(offsetof(APallet, _isFragile) == 0x0004F1, "Member 'APallet::_isFragile' has a wrong offset!");
static_assert(offsetof(APallet, _spawnedActorReplicationComponent) == 0x0004F8, "Member 'APallet::_spawnedActorReplicationComponent' has a wrong offset!");

// Class DeadByDaylight.ReverseBearTrapRemover
// 0x0030 (0x03D8 - 0x03A8)
class AReverseBearTrapRemover final : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 _keys;                                             // 0x03B0(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<int32>                                 _keysSearched;                                     // 0x03C0(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	class UMapActorComponent*                     _mapActor;                                         // 0x03D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddKey(int32 KeyId);
	void AddSearchedKey(int32 KeyId);
	void PlayRemoveFailMontage();

	class AReverseBearTrap* GetAttachedRBT(class AActor* Player) const;
	class UPrimitiveComponent* GetInteractorPrimitiveComponent() const;
	class UMapActorComponent* GetMapActor() const;
	bool HasKey(int32 KeyId) const;
	bool HasSearchedForKey(int32 KeyId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReverseBearTrapRemover">();
	}
	static class AReverseBearTrapRemover* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReverseBearTrapRemover>();
	}
};
static_assert(alignof(AReverseBearTrapRemover) == 0x000008, "Wrong alignment on AReverseBearTrapRemover");
static_assert(sizeof(AReverseBearTrapRemover) == 0x0003D8, "Wrong size on AReverseBearTrapRemover");
static_assert(offsetof(AReverseBearTrapRemover, _keys) == 0x0003B0, "Member 'AReverseBearTrapRemover::_keys' has a wrong offset!");
static_assert(offsetof(AReverseBearTrapRemover, _keysSearched) == 0x0003C0, "Member 'AReverseBearTrapRemover::_keysSearched' has a wrong offset!");
static_assert(offsetof(AReverseBearTrapRemover, _mapActor) == 0x0003D0, "Member 'AReverseBearTrapRemover::_mapActor' has a wrong offset!");

// Class DeadByDaylight.ArchiveStoriesContainer
// 0x04A0 (0x04D0 - 0x0030)
class UArchiveStoriesContainer final : public UObject
{
public:
	uint8                                         Pad_30[0x290];                                     // 0x0030(0x0290)(Fixing Size After Last Property [ Dumper-7 ])
	class URewardTrackContainer*                  _rewardTrackContainer;                             // 0x02C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C8[0xA0];                                     // 0x02C8(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class UWalletHandler*                         _wallet;                                           // 0x0368(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UArchiveVignettesContainer*             _vignettesContainer;                               // 0x0370(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_378[0x158];                                    // 0x0378(0x0158)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveStoriesContainer">();
	}
	static class UArchiveStoriesContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArchiveStoriesContainer>();
	}
};
static_assert(alignof(UArchiveStoriesContainer) == 0x000008, "Wrong alignment on UArchiveStoriesContainer");
static_assert(sizeof(UArchiveStoriesContainer) == 0x0004D0, "Wrong size on UArchiveStoriesContainer");
static_assert(offsetof(UArchiveStoriesContainer, _rewardTrackContainer) == 0x0002C0, "Member 'UArchiveStoriesContainer::_rewardTrackContainer' has a wrong offset!");
static_assert(offsetof(UArchiveStoriesContainer, _wallet) == 0x000368, "Member 'UArchiveStoriesContainer::_wallet' has a wrong offset!");
static_assert(offsetof(UArchiveStoriesContainer, _vignettesContainer) == 0x000370, "Member 'UArchiveStoriesContainer::_vignettesContainer' has a wrong offset!");

// Class DeadByDaylight.DBDCurrencyConversionTunables
// 0x0050 (0x0088 - 0x0038)
class UDBDCurrencyConversionTunables final : public UDataAsset
{
public:
	TMap<ECurrencyType, struct FCurrencyConversion> Currencies;                                      // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDCurrencyConversionTunables">();
	}
	static class UDBDCurrencyConversionTunables* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDCurrencyConversionTunables>();
	}
};
static_assert(alignof(UDBDCurrencyConversionTunables) == 0x000008, "Wrong alignment on UDBDCurrencyConversionTunables");
static_assert(sizeof(UDBDCurrencyConversionTunables) == 0x000088, "Wrong size on UDBDCurrencyConversionTunables");
static_assert(offsetof(UDBDCurrencyConversionTunables, Currencies) == 0x000038, "Member 'UDBDCurrencyConversionTunables::Currencies' has a wrong offset!");

// Class DeadByDaylight.AspectRatioComponentUtilities
// 0x0000 (0x0030 - 0x0030)
class UAspectRatioComponentUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AspectRatioComponentUtilities">();
	}
	static class UAspectRatioComponentUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAspectRatioComponentUtilities>();
	}
};
static_assert(alignof(UAspectRatioComponentUtilities) == 0x000008, "Wrong alignment on UAspectRatioComponentUtilities");
static_assert(sizeof(UAspectRatioComponentUtilities) == 0x000030, "Wrong size on UAspectRatioComponentUtilities");

// Class DeadByDaylight.ReportPlayerPopupScreen
// 0x0030 (0x0178 - 0x0148)
class UReportPlayerPopupScreen final : public UGenericPopupScreen
{
public:
	uint8                                         Pad_148[0x30];                                     // 0x0148(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnConfirmReportPlayer(const class FString& category, const class FString& Comment);
	void OnTextInputMouseOver(bool IsMouseOver);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReportPlayerPopupScreen">();
	}
	static class UReportPlayerPopupScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReportPlayerPopupScreen>();
	}
};
static_assert(alignof(UReportPlayerPopupScreen) == 0x000008, "Wrong alignment on UReportPlayerPopupScreen");
static_assert(sizeof(UReportPlayerPopupScreen) == 0x000178, "Wrong size on UReportPlayerPopupScreen");

// Class DeadByDaylight.Window
// 0x00A8 (0x0450 - 0x03A8)
class AWindow final : public AInteractable
{
public:
	class UBoxComponent*                          _windowCollider;                                   // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          _collisionBox1;                                    // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          _collisionBox2;                                    // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          _interactionZone1;                                 // 0x03C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          _interactionZone2;                                 // 0x03C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBlockedByLevel;                                 // 0x03D0(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D1[0x7];                                      // 0x03D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ASurvivor*, struct FVaultData>     _survivorVaultData;                                // 0x03D8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_428[0x8];                                      // 0x0428(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlockableComponent*                    _blockableComponent;                               // 0x0430(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_438[0x10];                                     // 0x0438(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDNavEvadeLoopComponent*              _navEvadeLoopComponent;                            // 0x0448(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnVaultInternal(class ADBDPlayer* Player, bool canBlockVault);
	void Authority_SetBlockedByLevel(bool isBlockedByLevel);
	void NotifyOnFastVault(class ADBDPlayer* Player, class UInteractionDefinition* Interaction);
	void OnFastVault(class ADBDPlayer* Player, class UInteractionDefinition* Interaction);
	void OnRep_blockedByLevel();

	bool IsWindowVaultBlockedFor(const class ADBDPlayer* Player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Window">();
	}
	static class AWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWindow>();
	}
};
static_assert(alignof(AWindow) == 0x000008, "Wrong alignment on AWindow");
static_assert(sizeof(AWindow) == 0x000450, "Wrong size on AWindow");
static_assert(offsetof(AWindow, _windowCollider) == 0x0003A8, "Member 'AWindow::_windowCollider' has a wrong offset!");
static_assert(offsetof(AWindow, _collisionBox1) == 0x0003B0, "Member 'AWindow::_collisionBox1' has a wrong offset!");
static_assert(offsetof(AWindow, _collisionBox2) == 0x0003B8, "Member 'AWindow::_collisionBox2' has a wrong offset!");
static_assert(offsetof(AWindow, _interactionZone1) == 0x0003C0, "Member 'AWindow::_interactionZone1' has a wrong offset!");
static_assert(offsetof(AWindow, _interactionZone2) == 0x0003C8, "Member 'AWindow::_interactionZone2' has a wrong offset!");
static_assert(offsetof(AWindow, _isBlockedByLevel) == 0x0003D0, "Member 'AWindow::_isBlockedByLevel' has a wrong offset!");
static_assert(offsetof(AWindow, _survivorVaultData) == 0x0003D8, "Member 'AWindow::_survivorVaultData' has a wrong offset!");
static_assert(offsetof(AWindow, _blockableComponent) == 0x000430, "Member 'AWindow::_blockableComponent' has a wrong offset!");
static_assert(offsetof(AWindow, _navEvadeLoopComponent) == 0x000448, "Member 'AWindow::_navEvadeLoopComponent' has a wrong offset!");

// Class DeadByDaylight.AssetLibraryManager
// 0x00C8 (0x00F8 - 0x0030)
class UAssetLibraryManager final : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                _worldContextObject;                               // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<int32, class UCharacterItemsAssetLibrary*> _characterItemsAssetLibrary;                     // 0x0048(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class UIniAssetLibrary*                       _globalAssetLibrary;                               // 0x0098(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMenuAssetLibrary*                      _menuAssetLibrary;                                 // 0x00A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameAssetLibrary*                      _gameAssetLibrary;                                 // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTutorialAssetLibrary*                  _tutorialAssetLibrary;                             // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class Ushopmanager*                           _shopManager;                                      // 0x00C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x10];                                      // 0x00C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAssetLibraryLoader>            _loadingList;                                      // 0x00D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	int32                                         CharacterItemsAssetLoadCountPerChunk;              // 0x00E8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MenuAssetLoadCountPerChunk;                        // 0x00EC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         GlobalAssetLoadCountPerChunk;                      // 0x00F0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         GameAssetLoadCountPerChunk;                        // 0x00F4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssetLibraryManager">();
	}
	static class UAssetLibraryManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetLibraryManager>();
	}
};
static_assert(alignof(UAssetLibraryManager) == 0x000008, "Wrong alignment on UAssetLibraryManager");
static_assert(sizeof(UAssetLibraryManager) == 0x0000F8, "Wrong size on UAssetLibraryManager");
static_assert(offsetof(UAssetLibraryManager, _worldContextObject) == 0x000040, "Member 'UAssetLibraryManager::_worldContextObject' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, _characterItemsAssetLibrary) == 0x000048, "Member 'UAssetLibraryManager::_characterItemsAssetLibrary' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, _globalAssetLibrary) == 0x000098, "Member 'UAssetLibraryManager::_globalAssetLibrary' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, _menuAssetLibrary) == 0x0000A0, "Member 'UAssetLibraryManager::_menuAssetLibrary' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, _gameAssetLibrary) == 0x0000A8, "Member 'UAssetLibraryManager::_gameAssetLibrary' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, _tutorialAssetLibrary) == 0x0000B0, "Member 'UAssetLibraryManager::_tutorialAssetLibrary' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, _shopManager) == 0x0000C0, "Member 'UAssetLibraryManager::_shopManager' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, _loadingList) == 0x0000D8, "Member 'UAssetLibraryManager::_loadingList' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, CharacterItemsAssetLoadCountPerChunk) == 0x0000E8, "Member 'UAssetLibraryManager::CharacterItemsAssetLoadCountPerChunk' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, MenuAssetLoadCountPerChunk) == 0x0000EC, "Member 'UAssetLibraryManager::MenuAssetLoadCountPerChunk' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, GlobalAssetLoadCountPerChunk) == 0x0000F0, "Member 'UAssetLibraryManager::GlobalAssetLoadCountPerChunk' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, GameAssetLoadCountPerChunk) == 0x0000F4, "Member 'UAssetLibraryManager::GameAssetLoadCountPerChunk' has a wrong offset!");

// Class DeadByDaylight.AssetUtilities
// 0x0000 (0x0030 - 0x0030)
class UAssetUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssetUtilities">();
	}
	static class UAssetUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetUtilities>();
	}
};
static_assert(alignof(UAssetUtilities) == 0x000008, "Wrong alignment on UAssetUtilities");
static_assert(sizeof(UAssetUtilities) == 0x000030, "Wrong size on UAssetUtilities");

// Class DeadByDaylight.DBDSRComponent
// 0x0080 (0x0138 - 0x00B8)
class UDBDSRComponent : public UActorComponent
{
public:
	struct FGameplayTagContainer                  _gameEventTags;                                    // 0x00B8(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	EDBDSRState                                   _state;                                            // 0x00D8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D9[0x5F];                                      // 0x00D9(0x005F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_State();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDSRComponent">();
	}
	static class UDBDSRComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDSRComponent>();
	}
};
static_assert(alignof(UDBDSRComponent) == 0x000008, "Wrong alignment on UDBDSRComponent");
static_assert(sizeof(UDBDSRComponent) == 0x000138, "Wrong size on UDBDSRComponent");
static_assert(offsetof(UDBDSRComponent, _gameEventTags) == 0x0000B8, "Member 'UDBDSRComponent::_gameEventTags' has a wrong offset!");
static_assert(offsetof(UDBDSRComponent, _state) == 0x0000D8, "Member 'UDBDSRComponent::_state' has a wrong offset!");

// Class DeadByDaylight.SteamProfileDAL
// 0x0000 (0x0088 - 0x0088)
class USteamProfileDAL final : public UPlayerProfileDAL
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamProfileDAL">();
	}
	static class USteamProfileDAL* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamProfileDAL>();
	}
};
static_assert(alignof(USteamProfileDAL) == 0x000008, "Wrong alignment on USteamProfileDAL");
static_assert(sizeof(USteamProfileDAL) == 0x000088, "Wrong size on USteamProfileDAL");

// Class DeadByDaylight.AsynchronousLoadingElement
// 0x0000 (0x0000 - 0x0000)
class IAsynchronousLoadingElement final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsynchronousLoadingElement">();
	}
	static class IAsynchronousLoadingElement* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAsynchronousLoadingElement>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IAsynchronousLoadingElement) == 0x000001, "Wrong alignment on IAsynchronousLoadingElement");
static_assert(sizeof(IAsynchronousLoadingElement) == 0x000001, "Wrong size on IAsynchronousLoadingElement");

// Class DeadByDaylight.DisplayStand
// 0x01B0 (0x0450 - 0x02A0)
#pragma pack(push, 0x1)
class alignas(0x10) ADisplayStand : public AActor
{
public:
	uint8                                         Pad_2A0[0x18];                                     // 0x02A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _currentActorDisplayed;                            // 0x02B8(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 _currentActorDisplayedClass;                       // 0x02C8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClass*                                 _nextActorToDisplayClass;                          // 0x02D0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D8[0x28];                                     // 0x02D8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UClass*, struct FTransform>        _offsetByClass;                                    // 0x0300(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	TMap<TSoftClassPtr<class UClass>, bool>       _enableRotationByClass;                            // 0x0350(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   _defaultCharmClassDisplayable;                     // 0x03A0(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D8[0x61];                                     // 0x03D8(0x0061)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _useOffsetMenuAnimations;                          // 0x0439(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _displayDummyCharacter;                            // 0x043A(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_43B[0x1];                                      // 0x043B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterDropdown                     _characterDropdown;                                // 0x043C(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_444[0x4];                                      // 0x0444(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlockRotation(bool shouldBlockRotation);
	void OnCurrentActorDestroyed(class AActor* DestroyedActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisplayStand">();
	}
	static class ADisplayStand* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADisplayStand>();
	}
};
#pragma pack(pop)
static_assert(alignof(ADisplayStand) == 0x000010, "Wrong alignment on ADisplayStand");
static_assert(sizeof(ADisplayStand) == 0x000450, "Wrong size on ADisplayStand");
static_assert(offsetof(ADisplayStand, _currentActorDisplayed) == 0x0002B8, "Member 'ADisplayStand::_currentActorDisplayed' has a wrong offset!");
static_assert(offsetof(ADisplayStand, _currentActorDisplayedClass) == 0x0002C8, "Member 'ADisplayStand::_currentActorDisplayedClass' has a wrong offset!");
static_assert(offsetof(ADisplayStand, _nextActorToDisplayClass) == 0x0002D0, "Member 'ADisplayStand::_nextActorToDisplayClass' has a wrong offset!");
static_assert(offsetof(ADisplayStand, _offsetByClass) == 0x000300, "Member 'ADisplayStand::_offsetByClass' has a wrong offset!");
static_assert(offsetof(ADisplayStand, _enableRotationByClass) == 0x000350, "Member 'ADisplayStand::_enableRotationByClass' has a wrong offset!");
static_assert(offsetof(ADisplayStand, _defaultCharmClassDisplayable) == 0x0003A0, "Member 'ADisplayStand::_defaultCharmClassDisplayable' has a wrong offset!");
static_assert(offsetof(ADisplayStand, _useOffsetMenuAnimations) == 0x000439, "Member 'ADisplayStand::_useOffsetMenuAnimations' has a wrong offset!");
static_assert(offsetof(ADisplayStand, _displayDummyCharacter) == 0x00043A, "Member 'ADisplayStand::_displayDummyCharacter' has a wrong offset!");
static_assert(offsetof(ADisplayStand, _characterDropdown) == 0x00043C, "Member 'ADisplayStand::_characterDropdown' has a wrong offset!");

// Class DeadByDaylight.AtlantaDisplayStand
// 0x0010 (0x0460 - 0x0450)
class AAtlantaDisplayStand final : public ADisplayStand
{
public:
	EAtlantaDisplayStandPosition                  StandPosition;                                     // 0x0448(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_449[0x7];                                      // 0x0449(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SurvivorPositionMarker;                            // 0x0450(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        KillerPositionMarker;                              // 0x0458(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaDisplayStand">();
	}
	static class AAtlantaDisplayStand* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAtlantaDisplayStand>();
	}
};
static_assert(alignof(AAtlantaDisplayStand) == 0x000010, "Wrong alignment on AAtlantaDisplayStand");
static_assert(sizeof(AAtlantaDisplayStand) == 0x000460, "Wrong size on AAtlantaDisplayStand");
static_assert(offsetof(AAtlantaDisplayStand, StandPosition) == 0x000448, "Member 'AAtlantaDisplayStand::StandPosition' has a wrong offset!");
static_assert(offsetof(AAtlantaDisplayStand, SurvivorPositionMarker) == 0x000450, "Member 'AAtlantaDisplayStand::SurvivorPositionMarker' has a wrong offset!");
static_assert(offsetof(AAtlantaDisplayStand, KillerPositionMarker) == 0x000458, "Member 'AAtlantaDisplayStand::KillerPositionMarker' has a wrong offset!");

// Class DeadByDaylight.WeightBasedSearchableItemStrategy
// 0x0010 (0x0048 - 0x0038)
class UWeightBasedSearchableItemStrategy final : public USearchableItemStrategy
{
public:
	TArray<struct FWeightBasedItemData>           _weightBasedItems;                                 // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeightBasedSearchableItemStrategy">();
	}
	static class UWeightBasedSearchableItemStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeightBasedSearchableItemStrategy>();
	}
};
static_assert(alignof(UWeightBasedSearchableItemStrategy) == 0x000008, "Wrong alignment on UWeightBasedSearchableItemStrategy");
static_assert(sizeof(UWeightBasedSearchableItemStrategy) == 0x000048, "Wrong size on UWeightBasedSearchableItemStrategy");
static_assert(offsetof(UWeightBasedSearchableItemStrategy, _weightBasedItems) == 0x000038, "Member 'UWeightBasedSearchableItemStrategy::_weightBasedItems' has a wrong offset!");

// Class DeadByDaylight.AtlantaSaveGame
// 0x0030 (0x0060 - 0x0030)
class UAtlantaSaveGame final : public USaveGame
{
public:
	class FString                                 SaveSlotName;                                      // 0x0030(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        UserIndex;                                         // 0x0040(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LastGenericLoadingImageId;                         // 0x0044(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LastSpecificLoadingImageId;                        // 0x0050(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLastSpecificImage;                               // 0x005C(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaSaveGame">();
	}
	static class UAtlantaSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaSaveGame>();
	}
};
static_assert(alignof(UAtlantaSaveGame) == 0x000008, "Wrong alignment on UAtlantaSaveGame");
static_assert(sizeof(UAtlantaSaveGame) == 0x000060, "Wrong size on UAtlantaSaveGame");
static_assert(offsetof(UAtlantaSaveGame, SaveSlotName) == 0x000030, "Member 'UAtlantaSaveGame::SaveSlotName' has a wrong offset!");
static_assert(offsetof(UAtlantaSaveGame, UserIndex) == 0x000040, "Member 'UAtlantaSaveGame::UserIndex' has a wrong offset!");
static_assert(offsetof(UAtlantaSaveGame, LastGenericLoadingImageId) == 0x000044, "Member 'UAtlantaSaveGame::LastGenericLoadingImageId' has a wrong offset!");
static_assert(offsetof(UAtlantaSaveGame, LastSpecificLoadingImageId) == 0x000050, "Member 'UAtlantaSaveGame::LastSpecificLoadingImageId' has a wrong offset!");
static_assert(offsetof(UAtlantaSaveGame, IsLastSpecificImage) == 0x00005C, "Member 'UAtlantaSaveGame::IsLastSpecificImage' has a wrong offset!");

// Class DeadByDaylight.AtlantaTutorialPlayerHudController
// 0x0048 (0x0078 - 0x0030)
class UAtlantaTutorialPlayerHudController final : public UObject
{
public:
	uint8                                         Pad_30[0x48];                                      // 0x0030(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HideHudComponent(EHudComponent hudComponentToHide);
	void SetVirtualJoystickInputEnabled(bool Enable);
	void ShowHudComponent(EHudComponent hudComponentToShow);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaTutorialPlayerHudController">();
	}
	static class UAtlantaTutorialPlayerHudController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaTutorialPlayerHudController>();
	}
};
static_assert(alignof(UAtlantaTutorialPlayerHudController) == 0x000008, "Wrong alignment on UAtlantaTutorialPlayerHudController");
static_assert(sizeof(UAtlantaTutorialPlayerHudController) == 0x000078, "Wrong size on UAtlantaTutorialPlayerHudController");

// Class DeadByDaylight.AttachInteractionComponent
// 0x0010 (0x00C8 - 0x00B8)
class UAttachInteractionComponent final : public UActorComponent
{
public:
	TArray<class USceneComponent*>                _interactionsAttachPoints;                         // 0x00B8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void Authority_SetInteractionAttachPoints(const TArray<class USceneComponent*>& interactionsAttachPoints);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttachInteractionComponent">();
	}
	static class UAttachInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttachInteractionComponent>();
	}
};
static_assert(alignof(UAttachInteractionComponent) == 0x000008, "Wrong alignment on UAttachInteractionComponent");
static_assert(sizeof(UAttachInteractionComponent) == 0x0000C8, "Wrong size on UAttachInteractionComponent");
static_assert(offsetof(UAttachInteractionComponent, _interactionsAttachPoints) == 0x0000B8, "Member 'UAttachInteractionComponent::_interactionsAttachPoints' has a wrong offset!");

// Class DeadByDaylight.DBDEasyAntiCheat
// 0x0020 (0x0050 - 0x0030)
class UDBDEasyAntiCheat : public UObject
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDEasyAntiCheat">();
	}
	static class UDBDEasyAntiCheat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDEasyAntiCheat>();
	}
};
static_assert(alignof(UDBDEasyAntiCheat) == 0x000008, "Wrong alignment on UDBDEasyAntiCheat");
static_assert(sizeof(UDBDEasyAntiCheat) == 0x000050, "Wrong size on UDBDEasyAntiCheat");

// Class DeadByDaylight.DBDEasyAntiCheatEnable
// 0x0000 (0x0050 - 0x0050)
class UDBDEasyAntiCheatEnable : public UDBDEasyAntiCheat
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDEasyAntiCheatEnable">();
	}
	static class UDBDEasyAntiCheatEnable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDEasyAntiCheatEnable>();
	}
};
static_assert(alignof(UDBDEasyAntiCheatEnable) == 0x000008, "Wrong alignment on UDBDEasyAntiCheatEnable");
static_assert(sizeof(UDBDEasyAntiCheatEnable) == 0x000050, "Wrong size on UDBDEasyAntiCheatEnable");

// Class DeadByDaylight.DBDEasyAntiCheatClient
// 0x0070 (0x00C0 - 0x0050)
class UDBDEasyAntiCheatClient : public UDBDEasyAntiCheatEnable
{
public:
	uint8                                         Pad_50[0x70];                                      // 0x0050(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDEasyAntiCheatClient">();
	}
	static class UDBDEasyAntiCheatClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDEasyAntiCheatClient>();
	}
};
static_assert(alignof(UDBDEasyAntiCheatClient) == 0x000008, "Wrong alignment on UDBDEasyAntiCheatClient");
static_assert(sizeof(UDBDEasyAntiCheatClient) == 0x0000C0, "Wrong size on UDBDEasyAntiCheatClient");

// Class DeadByDaylight.AttackTypeEventComponent
// 0x0010 (0x00C8 - 0x00B8)
class UAttackTypeEventComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttackTypeEventComponent">();
	}
	static class UAttackTypeEventComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttackTypeEventComponent>();
	}
};
static_assert(alignof(UAttackTypeEventComponent) == 0x000008, "Wrong alignment on UAttackTypeEventComponent");
static_assert(sizeof(UAttackTypeEventComponent) == 0x0000C8, "Wrong size on UAttackTypeEventComponent");

// Class DeadByDaylight.AudioFXComponent
// 0x0070 (0x0128 - 0x00B8)
class UAudioFXComponent final : public UActorComponent
{
public:
	class UPrimitiveComponent*                    _audioAmbientDetector;                             // 0x00B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x68];                                      // 0x00C0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_Deafen(float Duration);
	void Multicast_Deafen(float Duration);
	void OnDeafenCompleted();
	void OnLocallyObservedChanged(bool locallyObserved);
	void SetAudioAmbientDetector(class UPrimitiveComponent* audioAmbientDetector);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AudioFXComponent">();
	}
	static class UAudioFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAudioFXComponent>();
	}
};
static_assert(alignof(UAudioFXComponent) == 0x000008, "Wrong alignment on UAudioFXComponent");
static_assert(sizeof(UAudioFXComponent) == 0x000128, "Wrong size on UAudioFXComponent");
static_assert(offsetof(UAudioFXComponent, _audioAmbientDetector) == 0x0000B8, "Member 'UAudioFXComponent::_audioAmbientDetector' has a wrong offset!");

// Class DeadByDaylight.StoreControllerSubsystem
// 0x0008 (0x0040 - 0x0038)
class UStoreControllerSubsystem final : public UGameInstanceSubsystem
{
public:
	class UStoreDisplayStandController*           _displayStandController;                           // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreControllerSubsystem">();
	}
	static class UStoreControllerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreControllerSubsystem>();
	}
};
static_assert(alignof(UStoreControllerSubsystem) == 0x000008, "Wrong alignment on UStoreControllerSubsystem");
static_assert(sizeof(UStoreControllerSubsystem) == 0x000040, "Wrong size on UStoreControllerSubsystem");
static_assert(offsetof(UStoreControllerSubsystem, _displayStandController) == 0x000038, "Member 'UStoreControllerSubsystem::_displayStandController' has a wrong offset!");

// Class DeadByDaylight.AudioMultipleEmitterActor
// 0x0018 (0x02B8 - 0x02A0)
class AAudioMultipleEmitterActor final : public AActor
{
public:
	class UAudioMultipleEmitterComponent*         AudioMultiEmitter;                                 // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         EmitterActors;                                     // 0x02A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AudioMultipleEmitterActor">();
	}
	static class AAudioMultipleEmitterActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAudioMultipleEmitterActor>();
	}
};
static_assert(alignof(AAudioMultipleEmitterActor) == 0x000008, "Wrong alignment on AAudioMultipleEmitterActor");
static_assert(sizeof(AAudioMultipleEmitterActor) == 0x0002B8, "Wrong size on AAudioMultipleEmitterActor");
static_assert(offsetof(AAudioMultipleEmitterActor, AudioMultiEmitter) == 0x0002A0, "Member 'AAudioMultipleEmitterActor::AudioMultiEmitter' has a wrong offset!");
static_assert(offsetof(AAudioMultipleEmitterActor, EmitterActors) == 0x0002A8, "Member 'AAudioMultipleEmitterActor::EmitterActors' has a wrong offset!");

// Class DeadByDaylight.PlayerDataStorageFacade
// 0x0078 (0x00A8 - 0x0030)
class UPlayerDataStorageFacade final : public UObject
{
public:
	uint8                                         Pad_30[0x78];                                      // 0x0030(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerDataStorageFacade">();
	}
	static class UPlayerDataStorageFacade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerDataStorageFacade>();
	}
};
static_assert(alignof(UPlayerDataStorageFacade) == 0x000008, "Wrong alignment on UPlayerDataStorageFacade");
static_assert(sizeof(UPlayerDataStorageFacade) == 0x0000A8, "Wrong size on UPlayerDataStorageFacade");

// Class DeadByDaylight.AudioMultipleEmitterComponent
// 0x0010 (0x0560 - 0x0550)
class UAudioMultipleEmitterComponent final : public UAkComponent
{
public:
	TArray<class UActorComponent*>                EmitterActorsComponents;                           // 0x0548(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_558[0x8];                                      // 0x0558(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AudioMultipleEmitterComponent">();
	}
	static class UAudioMultipleEmitterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAudioMultipleEmitterComponent>();
	}
};
static_assert(alignof(UAudioMultipleEmitterComponent) == 0x000010, "Wrong alignment on UAudioMultipleEmitterComponent");
static_assert(sizeof(UAudioMultipleEmitterComponent) == 0x000560, "Wrong size on UAudioMultipleEmitterComponent");
static_assert(offsetof(UAudioMultipleEmitterComponent, EmitterActorsComponents) == 0x000548, "Member 'UAudioMultipleEmitterComponent::EmitterActorsComponents' has a wrong offset!");

// Class DeadByDaylight.AuthoritativeMovementComponent
// 0x0060 (0x0118 - 0x00B8)
class UAuthoritativeMovementComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACharacter*>                     _charactersToPush;                                 // 0x00C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ACharacter*>                     _stopIgnoreCharacterOnEndOverlap;                  // 0x00D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      _pawnDetector;                                     // 0x00F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ACharacter*>                     _authoritativeIgnoreOverlapCharacters;             // 0x00F8(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class ACharacter*>                     _previousAuthoritativeIgnoreOverlapCharacters;     // 0x0108(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void OnPawnDetectorOverlapEnter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnPawnDetectorOverlapExit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnRep_AuthoritativeIgnoreOverlapCharacters();
	void SetPawnDetector(class UCapsuleComponent* pawnDetector);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuthoritativeMovementComponent">();
	}
	static class UAuthoritativeMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuthoritativeMovementComponent>();
	}
};
static_assert(alignof(UAuthoritativeMovementComponent) == 0x000008, "Wrong alignment on UAuthoritativeMovementComponent");
static_assert(sizeof(UAuthoritativeMovementComponent) == 0x000118, "Wrong size on UAuthoritativeMovementComponent");
static_assert(offsetof(UAuthoritativeMovementComponent, _charactersToPush) == 0x0000C8, "Member 'UAuthoritativeMovementComponent::_charactersToPush' has a wrong offset!");
static_assert(offsetof(UAuthoritativeMovementComponent, _stopIgnoreCharacterOnEndOverlap) == 0x0000D8, "Member 'UAuthoritativeMovementComponent::_stopIgnoreCharacterOnEndOverlap' has a wrong offset!");
static_assert(offsetof(UAuthoritativeMovementComponent, _pawnDetector) == 0x0000F0, "Member 'UAuthoritativeMovementComponent::_pawnDetector' has a wrong offset!");
static_assert(offsetof(UAuthoritativeMovementComponent, _authoritativeIgnoreOverlapCharacters) == 0x0000F8, "Member 'UAuthoritativeMovementComponent::_authoritativeIgnoreOverlapCharacters' has a wrong offset!");
static_assert(offsetof(UAuthoritativeMovementComponent, _previousAuthoritativeIgnoreOverlapCharacters) == 0x000108, "Member 'UAuthoritativeMovementComponent::_previousAuthoritativeIgnoreOverlapCharacters' has a wrong offset!");

// Class DeadByDaylight.TrapIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UTrapIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrapIconStrategy">();
	}
	static class UTrapIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTrapIconStrategy>();
	}
};
static_assert(alignof(UTrapIconStrategy) == 0x000008, "Wrong alignment on UTrapIconStrategy");
static_assert(sizeof(UTrapIconStrategy) == 0x000038, "Wrong size on UTrapIconStrategy");

// Class DeadByDaylight.AutoQualityAdjuster
// 0x0028 (0x02C8 - 0x02A0)
class AAutoQualityAdjuster final : public AActor
{
public:
	float                                         TargetResolutionScale;                             // 0x02A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimumMS;                                         // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaximumMS;                                         // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScaleIncreaseRate;                                 // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScaleDecreaseRate;                                 // 0x02B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimumAllowableScale;                             // 0x02B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B8[0x10];                                     // 0x02B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoQualityAdjuster">();
	}
	static class AAutoQualityAdjuster* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAutoQualityAdjuster>();
	}
};
static_assert(alignof(AAutoQualityAdjuster) == 0x000008, "Wrong alignment on AAutoQualityAdjuster");
static_assert(sizeof(AAutoQualityAdjuster) == 0x0002C8, "Wrong size on AAutoQualityAdjuster");
static_assert(offsetof(AAutoQualityAdjuster, TargetResolutionScale) == 0x0002A0, "Member 'AAutoQualityAdjuster::TargetResolutionScale' has a wrong offset!");
static_assert(offsetof(AAutoQualityAdjuster, MinimumMS) == 0x0002A4, "Member 'AAutoQualityAdjuster::MinimumMS' has a wrong offset!");
static_assert(offsetof(AAutoQualityAdjuster, MaximumMS) == 0x0002A8, "Member 'AAutoQualityAdjuster::MaximumMS' has a wrong offset!");
static_assert(offsetof(AAutoQualityAdjuster, ScaleIncreaseRate) == 0x0002AC, "Member 'AAutoQualityAdjuster::ScaleIncreaseRate' has a wrong offset!");
static_assert(offsetof(AAutoQualityAdjuster, ScaleDecreaseRate) == 0x0002B0, "Member 'AAutoQualityAdjuster::ScaleDecreaseRate' has a wrong offset!");
static_assert(offsetof(AAutoQualityAdjuster, MinimumAllowableScale) == 0x0002B4, "Member 'AAutoQualityAdjuster::MinimumAllowableScale' has a wrong offset!");

// Class DeadByDaylight.AxisMovementComponent
// 0x0138 (0x01F0 - 0x00B8)
class UAxisMovementComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x138];                                     // 0x00B8(0x0138)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AxisMovementComponent">();
	}
	static class UAxisMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAxisMovementComponent>();
	}
};
static_assert(alignof(UAxisMovementComponent) == 0x000008, "Wrong alignment on UAxisMovementComponent");
static_assert(sizeof(UAxisMovementComponent) == 0x0001F0, "Wrong size on UAxisMovementComponent");

// Class DeadByDaylight.DedicatedServerManager
// 0x0048 (0x0080 - 0x0038)
class UDedicatedServerManager final : public UGameInstanceSubsystem
{
public:
	TScriptInterface<class IDedicatedServerStartupInitializerInterface> _startupInitializer;         // 0x0038(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOnlineSystemHandler*                   _onlineSystemHandler;                              // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x30];                                      // 0x0050(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DedicatedServerManager">();
	}
	static class UDedicatedServerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDedicatedServerManager>();
	}
};
static_assert(alignof(UDedicatedServerManager) == 0x000008, "Wrong alignment on UDedicatedServerManager");
static_assert(sizeof(UDedicatedServerManager) == 0x000080, "Wrong size on UDedicatedServerManager");
static_assert(offsetof(UDedicatedServerManager, _startupInitializer) == 0x000038, "Member 'UDedicatedServerManager::_startupInitializer' has a wrong offset!");
static_assert(offsetof(UDedicatedServerManager, _onlineSystemHandler) == 0x000048, "Member 'UDedicatedServerManager::_onlineSystemHandler' has a wrong offset!");

// Class DeadByDaylight.Survivor
// 0x0490 (0x1A40 - 0x15B0)
class ASurvivor final : public ADBDPlayer
{
public:
	uint8                                         Pad_15B0[0x10];                                    // 0x15B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnHookedStateChanged;                              // 0x15C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_15D0[0x20];                                    // 0x15D0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ADBDPlayer* picker)> OnPickedUpEndDelegate;                  // 0x15F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnHPSlotChanged;                                   // 0x1600(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1610[0x40];                                    // 0x1610(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(EImmobilizedState oldState, EImmobilizedState newState)> OnImmobilizeStateChanged; // 0x1650(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1660[0x30];                                    // 0x1660(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnHookEscapeFailedCosmetic;                        // 0x1690(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   ReverseBearTrapAttachSocket;                       // 0x16A0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isBeingDissolved;                                  // 0x16AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16AD[0x3];                                     // 0x16AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FootprintAudibleRange;                             // 0x16B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16B4[0x4];                                     // 0x16B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStalkedComponent*                      StalkedComponent;                                  // 0x16B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraResetToleranceYaw;                           // 0x16C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraResetTolerancePitch;                         // 0x16C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraRecenterOffsetYaw;                           // 0x16C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraRecenterOffsetPitch;                         // 0x16CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGender                                       gender;                                            // 0x16D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16D1[0x7];                                     // 0x16D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DropStaggerDuration;                               // 0x16D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DropStaggerMaxSpeed;                               // 0x16E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeforDeathWhileCrawling;                         // 0x16E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeforDeathWhileHooked;                           // 0x16EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondsUntilFootprintTrigger;                      // 0x16F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TriggerAfflictionHUDIntro;                         // 0x16F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16F5[0x83];                                    // 0x16F5(0x0083)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      _storedPlayerController;                           // 0x1778(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 _escape;                                           // 0x1780(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 _overlappingEscape;                                // 0x1788(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpherePlayerOverlapComponent*          ProximityZone;                                     // 0x1790(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1798[0x18];                                    // 0x1798(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      SlashableZone;                                     // 0x17B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      HookSlashableZone;                                 // 0x17B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USurvivorSlashableComponent*            _camperSlashable;                                  // 0x17C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMoriableComponent*                     _moriableComponent;                                // 0x17C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CrouchCapsuleHalfHeight;                           // 0x17D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IKOffsetRightFoot;                                 // 0x17D4(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IKOffsetLeftFoot;                                  // 0x17D8(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_17DC[0x54];                                    // 0x17DC(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDPawnSensingComponent*               _camperSensor;                                     // 0x1830(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USurviveTimerScoreEventComponent*       _surviveTimerScoreComponent;                       // 0x1838(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1840[0x10];                                    // 0x1840(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADBDPlayer*>                     _foundCampers;                                     // 0x1850(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ADBDPlayer*>                     _potentialSaviors;                                 // 0x1860(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UHealthComponent*                       _healthComponent;                                  // 0x1870(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _hpSlot01;                                         // 0x1878(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _hpSlot02;                                         // 0x1880(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _mendChargeable;                                   // 0x1888(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _antiCampUnhookChargeable;                         // 0x1890(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBloodTrailSettings*                    _bloodTrailSettings;                               // 0x1898(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USurvivorBloodTrailComponent*           _bloodTrailComponent;                              // 0x18A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCameraAttachmentComponent*             _cameraAttachment;                                 // 0x18A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharmSpawnerComponent*                 _charmSpawnerComponent;                            // 0x18B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHookableComponent*                     _hookableComponent;                                // 0x18B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UProtectionHitComponent*                _protectionHitComponent;                           // 0x18C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UScreamComponent*                       _screamComponent;                                  // 0x18C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterPositionRecorderComponent*    _positionRecorder;                                 // 0x18D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18D8[0x65];                                    // 0x18D8(0x0065)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _lastEscaped;                                      // 0x193D(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _runInputPressed;                                  // 0x193E(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_193F[0x31];                                    // 0x193F(0x0031)(Fixing Size After Last Property [ Dumper-7 ])
	class USurvivorEndGameComponent*              _camperEndGameComponent;                           // 0x1970(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkComponent*                           _noOcclusionAkComponent;                           // 0x1978(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkComponent*                           _attenuationAkComponent;                           // 0x1980(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isBeingSacrificed;                                // 0x1988(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isWiggleProgressionAllowed;                       // 0x1989(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_198A[0x4E];                                    // 0x198A(0x004E)(Fixing Size After Last Property [ Dumper-7 ])
	class UMoveComponentToComponent*              _meshMover;                                        // 0x19D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCarriedMovementComponent*              _carriedMovementComponent;                         // 0x19E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UAntiCampSelfUnhookComponent> _antiCampSelfUnhookComponent;                 // 0x19E8(0x0008)(Edit, BlueprintVisible, ExportObject, Net, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USurvivorHitSprintEffect*               _sprintEffect;                                     // 0x19F0(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _sprintOnHitEffectClass;                           // 0x19F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A00[0x40];                                    // 0x1A00(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateLocalPlayerExposedVFX();
	void ActivatePlayerExposedVFX();
	void AddBloodDecalToGK_Mori();
	void AddBloodDrippingToGK_Mori();
	void AddBloodDropsToLeftHand();
	void AddBloodDropsToRightHand();
	void Authority_OnSlashed(class ADBDPlayer* Attacker);
	void DBD_CheatEscaped();
	void DBD_ForceRun(bool Forced);
	void DBD_LeaveParadise();
	void DBD_SetImmobilized(EImmobilizedState State);
	void DBD_SetSurvivorCameraArmLength(float cameraArmLength);
	void DBD_SetSurvivorCameraArmLengthCommand(float cameraArmLength);
	void DecalBlood_Puddles();
	void DoSacrificialDissolve();
	void EventOnDeath();
	void Input_ToggleRun();
	void Kill(EHealthType healthType);
	void Local_SetImmobilized(EImmobilizedState State);
	void MakeCamperDisappear();
	void MakeCamperDisappearBleedOut();
	void Multicast_EscapeItemEvents(bool isItemFromSpawn);
	void Multicast_RemoveReverseBearTrap();
	void Multicast_SetAuthoritativeMovementFlag(EAuthoritativeMovementFlag Flag, bool Value);
	void Multicast_SetHookEscapeAutoFail(bool Enabled);
	void Multicast_SetImmobilized(EImmobilizedState State);
	void Multicast_SetOverlappingEscape(class AActor* Escape);
	void OnDroppedEnd(bool clearLeader);
	void OnDroppedStart(class ADBDPlayer* dropper);
	void OnHooked();
	void OnHookedStateChangedCosmetic(bool hooked);
	void OnHpSlotSkillCheckResponseAesthetic(bool Success, bool Bonus, class ADBDPlayer* Player, bool TriggerLoudNoise, bool hadInput, ESkillCheckCustomType Type, float ChargeChange);
	void OnObsessionChanged(class ASurvivor* newObsession, class ASurvivor* previousObsession);
	void OnPawnSensed(class APawn* Pawn);
	void OnProximityEntered(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnRep_RunInputPressed();
	void OnRep_SprintEffect();
	void RemoveReverseBearTrap();
	void ResetCameraAttach();
	void Server_SetOverlappingEscape(class AActor* Escape);
	void Server_SetRunInput(bool Pressed);
	void SetPlayerExposedVFX();
	void SetVignetteVisible(bool Visible);
	void SurvivorDissolve(bool shouldDissolve, float timeToDissolve);
	void TriggerAfflictionHUDFeedback();

	bool AcceptsHealing() const;
	bool CanBePickedUp() const;
	bool CanRushQuietly() const;
	TArray<class UDBDClipRegionComponent*> GetAllEntityRenderRegions() const;
	class UAntiCampSelfUnhookComponent* GetAntiCampSelfUnhookComponent() const;
	class USurvivorBloodTrailComponent* GetBloodTrailComponent() const;
	class UChaseeCharacterComponent* GetChaseeCharacterComponent() const;
	EGuidedState GetGuidedAction() const;
	class UHealthComponent* GetHealthComponent() const;
	class UHookableComponent* GetHookableComponent() const;
	EImmobilizedState GetImmobilizedState() const;
	class UAnimationMontageSlave* GetMontageFollower() const;
	class UAkComponent* GetNoOcclusionAudioComponent() const;
	class AReverseBearTrap* GetReverseBearTrap() const;
	class UChargeableComponent* GetWiggleChargeable() const;
	bool HasGuidedAction() const;
	bool HasReverseBearTrap() const;
	bool IsBeingCarried() const;
	bool IsBeingHealed() const;
	bool IsBeingInteractedWith() const;
	bool IsBeingMended() const;
	bool IsBeingPickedUp() const;
	bool IsBeingPutDown() const;
	bool IsBeingPutOnHook() const;
	bool IsBeingUnhooked() const;
	bool IsCrawling() const;
	bool IsDeadOrInParadise() const;
	bool IsEscaped() const;
	bool IsGuidedBySlasher() const;
	bool IsHooked() const;
	bool IsInDeathBed() const;
	bool IsObsessionTarget() const;
	bool IsTrapped() const;
	bool IsVaulting() const;
	bool IsWalking() const;
	void NotifySurvivorDissolveFinished(bool isDissolved) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Survivor">();
	}
	static class ASurvivor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASurvivor>();
	}
};
static_assert(alignof(ASurvivor) == 0x000010, "Wrong alignment on ASurvivor");
static_assert(sizeof(ASurvivor) == 0x001A40, "Wrong size on ASurvivor");
static_assert(offsetof(ASurvivor, OnHookedStateChanged) == 0x0015C0, "Member 'ASurvivor::OnHookedStateChanged' has a wrong offset!");
static_assert(offsetof(ASurvivor, OnPickedUpEndDelegate) == 0x0015F0, "Member 'ASurvivor::OnPickedUpEndDelegate' has a wrong offset!");
static_assert(offsetof(ASurvivor, OnHPSlotChanged) == 0x001600, "Member 'ASurvivor::OnHPSlotChanged' has a wrong offset!");
static_assert(offsetof(ASurvivor, OnImmobilizeStateChanged) == 0x001650, "Member 'ASurvivor::OnImmobilizeStateChanged' has a wrong offset!");
static_assert(offsetof(ASurvivor, OnHookEscapeFailedCosmetic) == 0x001690, "Member 'ASurvivor::OnHookEscapeFailedCosmetic' has a wrong offset!");
static_assert(offsetof(ASurvivor, ReverseBearTrapAttachSocket) == 0x0016A0, "Member 'ASurvivor::ReverseBearTrapAttachSocket' has a wrong offset!");
static_assert(offsetof(ASurvivor, isBeingDissolved) == 0x0016AC, "Member 'ASurvivor::isBeingDissolved' has a wrong offset!");
static_assert(offsetof(ASurvivor, FootprintAudibleRange) == 0x0016B0, "Member 'ASurvivor::FootprintAudibleRange' has a wrong offset!");
static_assert(offsetof(ASurvivor, StalkedComponent) == 0x0016B8, "Member 'ASurvivor::StalkedComponent' has a wrong offset!");
static_assert(offsetof(ASurvivor, CameraResetToleranceYaw) == 0x0016C0, "Member 'ASurvivor::CameraResetToleranceYaw' has a wrong offset!");
static_assert(offsetof(ASurvivor, CameraResetTolerancePitch) == 0x0016C4, "Member 'ASurvivor::CameraResetTolerancePitch' has a wrong offset!");
static_assert(offsetof(ASurvivor, CameraRecenterOffsetYaw) == 0x0016C8, "Member 'ASurvivor::CameraRecenterOffsetYaw' has a wrong offset!");
static_assert(offsetof(ASurvivor, CameraRecenterOffsetPitch) == 0x0016CC, "Member 'ASurvivor::CameraRecenterOffsetPitch' has a wrong offset!");
static_assert(offsetof(ASurvivor, gender) == 0x0016D0, "Member 'ASurvivor::gender' has a wrong offset!");
static_assert(offsetof(ASurvivor, DropStaggerDuration) == 0x0016D8, "Member 'ASurvivor::DropStaggerDuration' has a wrong offset!");
static_assert(offsetof(ASurvivor, DropStaggerMaxSpeed) == 0x0016E0, "Member 'ASurvivor::DropStaggerMaxSpeed' has a wrong offset!");
static_assert(offsetof(ASurvivor, TimeforDeathWhileCrawling) == 0x0016E8, "Member 'ASurvivor::TimeforDeathWhileCrawling' has a wrong offset!");
static_assert(offsetof(ASurvivor, TimeforDeathWhileHooked) == 0x0016EC, "Member 'ASurvivor::TimeforDeathWhileHooked' has a wrong offset!");
static_assert(offsetof(ASurvivor, SecondsUntilFootprintTrigger) == 0x0016F0, "Member 'ASurvivor::SecondsUntilFootprintTrigger' has a wrong offset!");
static_assert(offsetof(ASurvivor, TriggerAfflictionHUDIntro) == 0x0016F4, "Member 'ASurvivor::TriggerAfflictionHUDIntro' has a wrong offset!");
static_assert(offsetof(ASurvivor, _storedPlayerController) == 0x001778, "Member 'ASurvivor::_storedPlayerController' has a wrong offset!");
static_assert(offsetof(ASurvivor, _escape) == 0x001780, "Member 'ASurvivor::_escape' has a wrong offset!");
static_assert(offsetof(ASurvivor, _overlappingEscape) == 0x001788, "Member 'ASurvivor::_overlappingEscape' has a wrong offset!");
static_assert(offsetof(ASurvivor, ProximityZone) == 0x001790, "Member 'ASurvivor::ProximityZone' has a wrong offset!");
static_assert(offsetof(ASurvivor, SlashableZone) == 0x0017B0, "Member 'ASurvivor::SlashableZone' has a wrong offset!");
static_assert(offsetof(ASurvivor, HookSlashableZone) == 0x0017B8, "Member 'ASurvivor::HookSlashableZone' has a wrong offset!");
static_assert(offsetof(ASurvivor, _camperSlashable) == 0x0017C0, "Member 'ASurvivor::_camperSlashable' has a wrong offset!");
static_assert(offsetof(ASurvivor, _moriableComponent) == 0x0017C8, "Member 'ASurvivor::_moriableComponent' has a wrong offset!");
static_assert(offsetof(ASurvivor, CrouchCapsuleHalfHeight) == 0x0017D0, "Member 'ASurvivor::CrouchCapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(ASurvivor, IKOffsetRightFoot) == 0x0017D4, "Member 'ASurvivor::IKOffsetRightFoot' has a wrong offset!");
static_assert(offsetof(ASurvivor, IKOffsetLeftFoot) == 0x0017D8, "Member 'ASurvivor::IKOffsetLeftFoot' has a wrong offset!");
static_assert(offsetof(ASurvivor, _camperSensor) == 0x001830, "Member 'ASurvivor::_camperSensor' has a wrong offset!");
static_assert(offsetof(ASurvivor, _surviveTimerScoreComponent) == 0x001838, "Member 'ASurvivor::_surviveTimerScoreComponent' has a wrong offset!");
static_assert(offsetof(ASurvivor, _foundCampers) == 0x001850, "Member 'ASurvivor::_foundCampers' has a wrong offset!");
static_assert(offsetof(ASurvivor, _potentialSaviors) == 0x001860, "Member 'ASurvivor::_potentialSaviors' has a wrong offset!");
static_assert(offsetof(ASurvivor, _healthComponent) == 0x001870, "Member 'ASurvivor::_healthComponent' has a wrong offset!");
static_assert(offsetof(ASurvivor, _hpSlot01) == 0x001878, "Member 'ASurvivor::_hpSlot01' has a wrong offset!");
static_assert(offsetof(ASurvivor, _hpSlot02) == 0x001880, "Member 'ASurvivor::_hpSlot02' has a wrong offset!");
static_assert(offsetof(ASurvivor, _mendChargeable) == 0x001888, "Member 'ASurvivor::_mendChargeable' has a wrong offset!");
static_assert(offsetof(ASurvivor, _antiCampUnhookChargeable) == 0x001890, "Member 'ASurvivor::_antiCampUnhookChargeable' has a wrong offset!");
static_assert(offsetof(ASurvivor, _bloodTrailSettings) == 0x001898, "Member 'ASurvivor::_bloodTrailSettings' has a wrong offset!");
static_assert(offsetof(ASurvivor, _bloodTrailComponent) == 0x0018A0, "Member 'ASurvivor::_bloodTrailComponent' has a wrong offset!");
static_assert(offsetof(ASurvivor, _cameraAttachment) == 0x0018A8, "Member 'ASurvivor::_cameraAttachment' has a wrong offset!");
static_assert(offsetof(ASurvivor, _charmSpawnerComponent) == 0x0018B0, "Member 'ASurvivor::_charmSpawnerComponent' has a wrong offset!");
static_assert(offsetof(ASurvivor, _hookableComponent) == 0x0018B8, "Member 'ASurvivor::_hookableComponent' has a wrong offset!");
static_assert(offsetof(ASurvivor, _protectionHitComponent) == 0x0018C0, "Member 'ASurvivor::_protectionHitComponent' has a wrong offset!");
static_assert(offsetof(ASurvivor, _screamComponent) == 0x0018C8, "Member 'ASurvivor::_screamComponent' has a wrong offset!");
static_assert(offsetof(ASurvivor, _positionRecorder) == 0x0018D0, "Member 'ASurvivor::_positionRecorder' has a wrong offset!");
static_assert(offsetof(ASurvivor, _lastEscaped) == 0x00193D, "Member 'ASurvivor::_lastEscaped' has a wrong offset!");
static_assert(offsetof(ASurvivor, _runInputPressed) == 0x00193E, "Member 'ASurvivor::_runInputPressed' has a wrong offset!");
static_assert(offsetof(ASurvivor, _camperEndGameComponent) == 0x001970, "Member 'ASurvivor::_camperEndGameComponent' has a wrong offset!");
static_assert(offsetof(ASurvivor, _noOcclusionAkComponent) == 0x001978, "Member 'ASurvivor::_noOcclusionAkComponent' has a wrong offset!");
static_assert(offsetof(ASurvivor, _attenuationAkComponent) == 0x001980, "Member 'ASurvivor::_attenuationAkComponent' has a wrong offset!");
static_assert(offsetof(ASurvivor, _isBeingSacrificed) == 0x001988, "Member 'ASurvivor::_isBeingSacrificed' has a wrong offset!");
static_assert(offsetof(ASurvivor, _isWiggleProgressionAllowed) == 0x001989, "Member 'ASurvivor::_isWiggleProgressionAllowed' has a wrong offset!");
static_assert(offsetof(ASurvivor, _meshMover) == 0x0019D8, "Member 'ASurvivor::_meshMover' has a wrong offset!");
static_assert(offsetof(ASurvivor, _carriedMovementComponent) == 0x0019E0, "Member 'ASurvivor::_carriedMovementComponent' has a wrong offset!");
static_assert(offsetof(ASurvivor, _antiCampSelfUnhookComponent) == 0x0019E8, "Member 'ASurvivor::_antiCampSelfUnhookComponent' has a wrong offset!");
static_assert(offsetof(ASurvivor, _sprintEffect) == 0x0019F0, "Member 'ASurvivor::_sprintEffect' has a wrong offset!");
static_assert(offsetof(ASurvivor, _sprintOnHitEffectClass) == 0x0019F8, "Member 'ASurvivor::_sprintOnHitEffectClass' has a wrong offset!");

// Class DeadByDaylight.BaseBloodwebContentAdapter
// 0x0028 (0x0058 - 0x0030)
class UBaseBloodwebContentAdapter : public UObject
{
public:
	class UBloodwebTunables*                      _bloodwebTunables;                                 // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBloodwebEntity*                        _entity;                                           // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TScriptInterface<class IDBDBloodwebDefinitionBase> _bloodwebDefinition;                          // 0x0040(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseBloodwebContentAdapter">();
	}
	static class UBaseBloodwebContentAdapter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseBloodwebContentAdapter>();
	}
};
static_assert(alignof(UBaseBloodwebContentAdapter) == 0x000008, "Wrong alignment on UBaseBloodwebContentAdapter");
static_assert(sizeof(UBaseBloodwebContentAdapter) == 0x000058, "Wrong size on UBaseBloodwebContentAdapter");
static_assert(offsetof(UBaseBloodwebContentAdapter, _bloodwebTunables) == 0x000030, "Member 'UBaseBloodwebContentAdapter::_bloodwebTunables' has a wrong offset!");
static_assert(offsetof(UBaseBloodwebContentAdapter, _entity) == 0x000038, "Member 'UBaseBloodwebContentAdapter::_entity' has a wrong offset!");
static_assert(offsetof(UBaseBloodwebContentAdapter, _bloodwebDefinition) == 0x000040, "Member 'UBaseBloodwebContentAdapter::_bloodwebDefinition' has a wrong offset!");

// Class DeadByDaylight.DBDServerInstance
// 0x0080 (0x00B0 - 0x0030)
class UDBDServerInstance final : public UObject
{
public:
	uint8                                         Pad_30[0x68];                                      // 0x0030(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDBDHostSettingsParamsBase*>     _pendingSessionUpdates;                            // 0x0098(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UDBDGameInstance>        _gameInstance;                                     // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDServerInstance">();
	}
	static class UDBDServerInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDServerInstance>();
	}
};
static_assert(alignof(UDBDServerInstance) == 0x000008, "Wrong alignment on UDBDServerInstance");
static_assert(sizeof(UDBDServerInstance) == 0x0000B0, "Wrong size on UDBDServerInstance");
static_assert(offsetof(UDBDServerInstance, _pendingSessionUpdates) == 0x000098, "Member 'UDBDServerInstance::_pendingSessionUpdates' has a wrong offset!");
static_assert(offsetof(UDBDServerInstance, _gameInstance) == 0x0000A8, "Member 'UDBDServerInstance::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.BackendBloodwebContentAdapter
// 0x00B8 (0x0110 - 0x0058)
class UBackendBloodwebContentAdapter final : public UBaseBloodwebContentAdapter
{
public:
	uint8                                         Pad_58[0xB0];                                      // 0x0058(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	class UBloodwebGenerator*                     _bloodwebBuilder;                                  // 0x0108(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BackendBloodwebContentAdapter">();
	}
	static class UBackendBloodwebContentAdapter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBackendBloodwebContentAdapter>();
	}
};
static_assert(alignof(UBackendBloodwebContentAdapter) == 0x000008, "Wrong alignment on UBackendBloodwebContentAdapter");
static_assert(sizeof(UBackendBloodwebContentAdapter) == 0x000110, "Wrong size on UBackendBloodwebContentAdapter");
static_assert(offsetof(UBackendBloodwebContentAdapter, _bloodwebBuilder) == 0x000108, "Member 'UBackendBloodwebContentAdapter::_bloodwebBuilder' has a wrong offset!");

// Class DeadByDaylight.BackendCinematicContainer
// 0x00C0 (0x00F0 - 0x0030)
class UBackendCinematicContainer final : public UObject
{
public:
	uint8                                         Pad_30[0xC0];                                      // 0x0030(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BackendCinematicContainer">();
	}
	static class UBackendCinematicContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBackendCinematicContainer>();
	}
};
static_assert(alignof(UBackendCinematicContainer) == 0x000008, "Wrong alignment on UBackendCinematicContainer");
static_assert(sizeof(UBackendCinematicContainer) == 0x0000F0, "Wrong size on UBackendCinematicContainer");

// Class DeadByDaylight.BackendGameplayTunablesManager
// 0x00B0 (0x00E8 - 0x0038)
class UBackendGameplayTunablesManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0xB0];                                      // 0x0038(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BackendGameplayTunablesManager">();
	}
	static class UBackendGameplayTunablesManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBackendGameplayTunablesManager>();
	}
};
static_assert(alignof(UBackendGameplayTunablesManager) == 0x000008, "Wrong alignment on UBackendGameplayTunablesManager");
static_assert(sizeof(UBackendGameplayTunablesManager) == 0x0000E8, "Wrong size on UBackendGameplayTunablesManager");

// Class DeadByDaylight.EnvironmentAnimatedObject
// 0x0000 (0x0320 - 0x0320)
class AEnvironmentAnimatedObject final : public ASkeletalMeshActorBudgeted
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvironmentAnimatedObject">();
	}
	static class AEnvironmentAnimatedObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnvironmentAnimatedObject>();
	}
};
static_assert(alignof(AEnvironmentAnimatedObject) == 0x000008, "Wrong alignment on AEnvironmentAnimatedObject");
static_assert(sizeof(AEnvironmentAnimatedObject) == 0x000320, "Wrong size on AEnvironmentAnimatedObject");

// Class DeadByDaylight.TotemOutlineUpdateStrategy
// 0x0038 (0x0198 - 0x0160)
class UTotemOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _revealedColorToSurvivor;                          // 0x0160(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _boonTotemRevealedColorToSurvivor;                 // 0x0170(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveLinearColor*                      _revealedColorToKiller;                            // 0x0180(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _blockedTotemColor;                                // 0x0188(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TotemOutlineUpdateStrategy">();
	}
	static class UTotemOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTotemOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UTotemOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UTotemOutlineUpdateStrategy");
static_assert(sizeof(UTotemOutlineUpdateStrategy) == 0x000198, "Wrong size on UTotemOutlineUpdateStrategy");
static_assert(offsetof(UTotemOutlineUpdateStrategy, _revealedColorToSurvivor) == 0x000160, "Member 'UTotemOutlineUpdateStrategy::_revealedColorToSurvivor' has a wrong offset!");
static_assert(offsetof(UTotemOutlineUpdateStrategy, _boonTotemRevealedColorToSurvivor) == 0x000170, "Member 'UTotemOutlineUpdateStrategy::_boonTotemRevealedColorToSurvivor' has a wrong offset!");
static_assert(offsetof(UTotemOutlineUpdateStrategy, _revealedColorToKiller) == 0x000180, "Member 'UTotemOutlineUpdateStrategy::_revealedColorToKiller' has a wrong offset!");
static_assert(offsetof(UTotemOutlineUpdateStrategy, _blockedTotemColor) == 0x000188, "Member 'UTotemOutlineUpdateStrategy::_blockedTotemColor' has a wrong offset!");

// Class DeadByDaylight.BackendInventory
// 0x00F8 (0x0130 - 0x0038)
class UBackendInventory final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0xF8];                                      // 0x0038(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BackendInventory">();
	}
	static class UBackendInventory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBackendInventory>();
	}
};
static_assert(alignof(UBackendInventory) == 0x000008, "Wrong alignment on UBackendInventory");
static_assert(sizeof(UBackendInventory) == 0x000130, "Wrong size on UBackendInventory");

// Class DeadByDaylight.BackendMessageManager
// 0x0018 (0x0050 - 0x0038)
class UBackendMessageManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BackendMessageManager">();
	}
	static class UBackendMessageManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBackendMessageManager>();
	}
};
static_assert(alignof(UBackendMessageManager) == 0x000008, "Wrong alignment on UBackendMessageManager");
static_assert(sizeof(UBackendMessageManager) == 0x000050, "Wrong size on UBackendMessageManager");

// Class DeadByDaylight.DBDConsoleCommandUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDConsoleCommandUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDConsoleCommandUtilities">();
	}
	static class UDBDConsoleCommandUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDConsoleCommandUtilities>();
	}
};
static_assert(alignof(UDBDConsoleCommandUtilities) == 0x000008, "Wrong alignment on UDBDConsoleCommandUtilities");
static_assert(sizeof(UDBDConsoleCommandUtilities) == 0x000030, "Wrong size on UDBDConsoleCommandUtilities");

// Class DeadByDaylight.PromoPackUtilities
// 0x0000 (0x0030 - 0x0030)
class UPromoPackUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PromoPackUtilities">();
	}
	static class UPromoPackUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPromoPackUtilities>();
	}
};
static_assert(alignof(UPromoPackUtilities) == 0x000008, "Wrong alignment on UPromoPackUtilities");
static_assert(sizeof(UPromoPackUtilities) == 0x000030, "Wrong size on UPromoPackUtilities");

// Class DeadByDaylight.BaseEscapeThroughHatch
// 0x0000 (0x0770 - 0x0770)
class UBaseEscapeThroughHatch : public UInteractionDefinition
{
public:
	class AHatch* GetHatch() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseEscapeThroughHatch">();
	}
	static class UBaseEscapeThroughHatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseEscapeThroughHatch>();
	}
};
static_assert(alignof(UBaseEscapeThroughHatch) == 0x000010, "Wrong alignment on UBaseEscapeThroughHatch");
static_assert(sizeof(UBaseEscapeThroughHatch) == 0x000770, "Wrong size on UBaseEscapeThroughHatch");

// Class DeadByDaylight.BaseGenerator
// 0x0000 (0x0000 - 0x0000)
class IBaseGenerator final
{
public:
	void Authority_CancelRepairInteractions(const TArray<class ADBDPlayer*>& repairers);
	void SetFireLevelScoreEventOnFix(bool FireLevelScoreEventOnFix);

	float GetChargePercentOnLastUpdate() const;
	class UGeneratorDamageComponent* GetGeneratorDamageComponent() const;
	TArray<class ADBDPlayer*> GetRepairers() const;
	bool IsActivated() const;
	bool IsBeingRepaired() const;
	bool IsBlocked() const;
	bool IsRepaired() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseGenerator">();
	}
	static class IBaseGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBaseGenerator>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IBaseGenerator) == 0x000001, "Wrong alignment on IBaseGenerator");
static_assert(sizeof(IBaseGenerator) == 0x000001, "Wrong size on IBaseGenerator");

// Class DeadByDaylight.PresetControllerSubsystem
// 0x0010 (0x0048 - 0x0038)
class UPresetControllerSubsystem final : public UGameInstanceSubsystem
{
public:
	class ULoadoutPresetController*               _loadoutController;                                // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCustomizationPresetController*         _customizationController;                          // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PresetControllerSubsystem">();
	}
	static class UPresetControllerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPresetControllerSubsystem>();
	}
};
static_assert(alignof(UPresetControllerSubsystem) == 0x000008, "Wrong alignment on UPresetControllerSubsystem");
static_assert(sizeof(UPresetControllerSubsystem) == 0x000048, "Wrong size on UPresetControllerSubsystem");
static_assert(offsetof(UPresetControllerSubsystem, _loadoutController) == 0x000038, "Member 'UPresetControllerSubsystem::_loadoutController' has a wrong offset!");
static_assert(offsetof(UPresetControllerSubsystem, _customizationController) == 0x000040, "Member 'UPresetControllerSubsystem::_customizationController' has a wrong offset!");

// Class DeadByDaylight.PlayerScoreComponent
// 0x00A8 (0x0160 - 0x00B8)
class UPlayerScoreComponent final : public UActorComponent
{
public:
	TSoftObjectPtr<class UDataTable>              _scoreEmitterDB;                                   // 0x00B8(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class UPlayerScoreEmitter*>              _emitters;                                         // 0x00F0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_140[0x20];                                     // 0x0140(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerScoreComponent">();
	}
	static class UPlayerScoreComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerScoreComponent>();
	}
};
static_assert(alignof(UPlayerScoreComponent) == 0x000008, "Wrong alignment on UPlayerScoreComponent");
static_assert(sizeof(UPlayerScoreComponent) == 0x000160, "Wrong size on UPlayerScoreComponent");
static_assert(offsetof(UPlayerScoreComponent, _scoreEmitterDB) == 0x0000B8, "Member 'UPlayerScoreComponent::_scoreEmitterDB' has a wrong offset!");
static_assert(offsetof(UPlayerScoreComponent, _emitters) == 0x0000F0, "Member 'UPlayerScoreComponent::_emitters' has a wrong offset!");

// Class DeadByDaylight.BaseLinkedVomitProjectile
// 0x0078 (0x0450 - 0x03D8)
class ABaseLinkedVomitProjectile final : public AKillerProjectile
{
public:
	bool                                          _passThroughSurvivors;                             // 0x03D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D9[0x7];                                      // 0x03D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPoolableProjectileComponent*           _poolableProjectile;                               // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnDeactivateOrLaunch;                              // 0x03E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               _vomitTrail;                                       // 0x03F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USplineMeshComponent*                   _splineMesh;                                       // 0x0400(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkComponent*                           _akAudioVomitProjectile;                           // 0x0408(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        _vomitSplashCamper;                                // 0x0410(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        _vomitSplash;                                      // 0x0418(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          _akAudioEventAudioEventVomitSplash;                // 0x0420(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              _minDecalSize;                                     // 0x0428(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              _maxDecalSize;                                     // 0x0438(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isSuperVomit;                                     // 0x0448(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasAlreadyAffectedSurvivor;                       // 0x0449(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44A[0x6];                                      // 0x044A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NativeExplode(const struct FImpactInfo& ImpactInfo);
	void OnAffectInteractable(class AInteractable* Interactable, class USceneComponent* HitComponent);
	void OnAffectSurvivor(class ASurvivor* Survivor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseLinkedVomitProjectile">();
	}
	static class ABaseLinkedVomitProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseLinkedVomitProjectile>();
	}
};
static_assert(alignof(ABaseLinkedVomitProjectile) == 0x000008, "Wrong alignment on ABaseLinkedVomitProjectile");
static_assert(sizeof(ABaseLinkedVomitProjectile) == 0x000450, "Wrong size on ABaseLinkedVomitProjectile");
static_assert(offsetof(ABaseLinkedVomitProjectile, _passThroughSurvivors) == 0x0003D8, "Member 'ABaseLinkedVomitProjectile::_passThroughSurvivors' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _poolableProjectile) == 0x0003E0, "Member 'ABaseLinkedVomitProjectile::_poolableProjectile' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, OnDeactivateOrLaunch) == 0x0003E8, "Member 'ABaseLinkedVomitProjectile::OnDeactivateOrLaunch' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _vomitTrail) == 0x0003F8, "Member 'ABaseLinkedVomitProjectile::_vomitTrail' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _splineMesh) == 0x000400, "Member 'ABaseLinkedVomitProjectile::_splineMesh' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _akAudioVomitProjectile) == 0x000408, "Member 'ABaseLinkedVomitProjectile::_akAudioVomitProjectile' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _vomitSplashCamper) == 0x000410, "Member 'ABaseLinkedVomitProjectile::_vomitSplashCamper' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _vomitSplash) == 0x000418, "Member 'ABaseLinkedVomitProjectile::_vomitSplash' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _akAudioEventAudioEventVomitSplash) == 0x000420, "Member 'ABaseLinkedVomitProjectile::_akAudioEventAudioEventVomitSplash' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _minDecalSize) == 0x000428, "Member 'ABaseLinkedVomitProjectile::_minDecalSize' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _maxDecalSize) == 0x000438, "Member 'ABaseLinkedVomitProjectile::_maxDecalSize' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _isSuperVomit) == 0x000448, "Member 'ABaseLinkedVomitProjectile::_isSuperVomit' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _hasAlreadyAffectedSurvivor) == 0x000449, "Member 'ABaseLinkedVomitProjectile::_hasAlreadyAffectedSurvivor' has a wrong offset!");

// Class DeadByDaylight.BasementTile
// 0x0000 (0x0460 - 0x0460)
class ABasementTile final : public ATile
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasementTile">();
	}
	static class ABasementTile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABasementTile>();
	}
};
static_assert(alignof(ABasementTile) == 0x000008, "Wrong alignment on ABasementTile");
static_assert(sizeof(ABasementTile) == 0x000460, "Wrong size on ABasementTile");

// Class DeadByDaylight.BasementTile2
// 0x0000 (0x0300 - 0x0300)
class ABasementTile2 final : public ATile2
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasementTile2">();
	}
	static class ABasementTile2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABasementTile2>();
	}
};
static_assert(alignof(ABasementTile2) == 0x000008, "Wrong alignment on ABasementTile2");
static_assert(sizeof(ABasementTile2) == 0x000300, "Wrong size on ABasementTile2");

// Class DeadByDaylight.DistanceCheckPawnLocationOverride
// 0x0000 (0x0000 - 0x0000)
class IDistanceCheckPawnLocationOverride final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DistanceCheckPawnLocationOverride">();
	}
	static class IDistanceCheckPawnLocationOverride* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDistanceCheckPawnLocationOverride>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IDistanceCheckPawnLocationOverride) == 0x000001, "Wrong alignment on IDistanceCheckPawnLocationOverride");
static_assert(sizeof(IDistanceCheckPawnLocationOverride) == 0x000001, "Wrong size on IDistanceCheckPawnLocationOverride");

// Class DeadByDaylight.DecalCollection
// 0x01C0 (0x01F0 - 0x0030)
class alignas(0x10) UDecalCollection final : public UObject
{
public:
	TArray<class UDBDDecalComponent*>             _decalComponentsArray;                             // 0x0030(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSet<class UDBDDecalComponent*>               _activeDecalComponents;                            // 0x0040(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSet<class UDBDDecalComponent*>               _inactiveDecalComponents;                          // 0x0090(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<bool>                                  _DeltaZPool;                                       // 0x00E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<class UStaticMeshComponent*, int32>      _deltaZMultipliers;                                // 0x00F0(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_140[0x8];                                      // 0x0140(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDecalMaskedMaterialsList*              _decalProperties;                                  // 0x0148(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_150[0xA0];                                     // 0x0150(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DecalCollection">();
	}
	static class UDecalCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDecalCollection>();
	}
};
static_assert(alignof(UDecalCollection) == 0x000010, "Wrong alignment on UDecalCollection");
static_assert(sizeof(UDecalCollection) == 0x0001F0, "Wrong size on UDecalCollection");
static_assert(offsetof(UDecalCollection, _decalComponentsArray) == 0x000030, "Member 'UDecalCollection::_decalComponentsArray' has a wrong offset!");
static_assert(offsetof(UDecalCollection, _activeDecalComponents) == 0x000040, "Member 'UDecalCollection::_activeDecalComponents' has a wrong offset!");
static_assert(offsetof(UDecalCollection, _inactiveDecalComponents) == 0x000090, "Member 'UDecalCollection::_inactiveDecalComponents' has a wrong offset!");
static_assert(offsetof(UDecalCollection, _DeltaZPool) == 0x0000E0, "Member 'UDecalCollection::_DeltaZPool' has a wrong offset!");
static_assert(offsetof(UDecalCollection, _deltaZMultipliers) == 0x0000F0, "Member 'UDecalCollection::_deltaZMultipliers' has a wrong offset!");
static_assert(offsetof(UDecalCollection, _decalProperties) == 0x000148, "Member 'UDecalCollection::_decalProperties' has a wrong offset!");

// Class DeadByDaylight.BehaviourDetectionComponent_AFKBot
// 0x0160 (0x0288 - 0x0128)
class UBehaviourDetectionComponent_AFKBot final : public UBaseBehaviourDetectionComponent
{
public:
	uint8                                         Pad_128[0x28];                                     // 0x0128(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTunableStat                           _afkCheckSeconds;                                  // 0x0150(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _afkMarkThreshold;                                 // 0x01D0(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_250[0x38];                                     // 0x0250(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BehaviourDetectionComponent_AFKBot">();
	}
	static class UBehaviourDetectionComponent_AFKBot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBehaviourDetectionComponent_AFKBot>();
	}
};
static_assert(alignof(UBehaviourDetectionComponent_AFKBot) == 0x000008, "Wrong alignment on UBehaviourDetectionComponent_AFKBot");
static_assert(sizeof(UBehaviourDetectionComponent_AFKBot) == 0x000288, "Wrong size on UBehaviourDetectionComponent_AFKBot");
static_assert(offsetof(UBehaviourDetectionComponent_AFKBot, _afkCheckSeconds) == 0x000150, "Member 'UBehaviourDetectionComponent_AFKBot::_afkCheckSeconds' has a wrong offset!");
static_assert(offsetof(UBehaviourDetectionComponent_AFKBot, _afkMarkThreshold) == 0x0001D0, "Member 'UBehaviourDetectionComponent_AFKBot::_afkMarkThreshold' has a wrong offset!");

// Class DeadByDaylight.DBDTags
// 0x0000 (0x0030 - 0x0030)
class UDBDTags final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDTags">();
	}
	static class UDBDTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDTags>();
	}
};
static_assert(alignof(UDBDTags) == 0x000008, "Wrong alignment on UDBDTags");
static_assert(sizeof(UDBDTags) == 0x000030, "Wrong size on UDBDTags");

// Class DeadByDaylight.BehaviourDetectionComponent_Inactivity
// 0x0140 (0x0268 - 0x0128)
class UBehaviourDetectionComponent_Inactivity final : public UBaseBehaviourDetectionComponent
{
public:
	float                                         _gracePeriod;                                      // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _interactionTimeThreshold;                         // 0x012C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxInactivityTimerBuffer;                         // 0x0130(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 _inactivityStages;                                 // 0x0138(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          _shouldOnHatchVisibilityChangedStopMonitoring;     // 0x0148(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBehaviourDetectionInactivityGameEventInfo> _gameEventsInfo;                       // 0x0150(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         _interactionInactivityReductionFactor;             // 0x0160(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _movementInactivityAccumulationFactor;             // 0x0164(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _movementCursedInactivityAccumulationFactor;       // 0x0168(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _killerProximityInactivityAccumulationFactor;      // 0x016C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _escapeDoorsActivatedInactivityAccumulationFactor; // 0x0170(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _killerProximityRange;                             // 0x0174(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _killerSpecificInteractionBonus;                   // 0x0178(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _generatorCompletedInteractionBonus;               // 0x017C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTagQuery>              _stateQueriesToForceInactivity;                    // 0x0180(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTagQuery>              _stateQueriesToResetInactivity;                    // 0x0190(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTagQuery>              _stateQueriesToIgnoreInactivity;                   // 0x01A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UActorComponent>            _analyticsComponentClass;                          // 0x01B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class AKiller>>         _killersInRange;                                   // 0x01B8(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C8[0xA0];                                     // 0x01C8(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnExitGatesActivated();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BehaviourDetectionComponent_Inactivity">();
	}
	static class UBehaviourDetectionComponent_Inactivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBehaviourDetectionComponent_Inactivity>();
	}
};
static_assert(alignof(UBehaviourDetectionComponent_Inactivity) == 0x000008, "Wrong alignment on UBehaviourDetectionComponent_Inactivity");
static_assert(sizeof(UBehaviourDetectionComponent_Inactivity) == 0x000268, "Wrong size on UBehaviourDetectionComponent_Inactivity");
static_assert(offsetof(UBehaviourDetectionComponent_Inactivity, _gracePeriod) == 0x000128, "Member 'UBehaviourDetectionComponent_Inactivity::_gracePeriod' has a wrong offset!");
static_assert(offsetof(UBehaviourDetectionComponent_Inactivity, _interactionTimeThreshold) == 0x00012C, "Member 'UBehaviourDetectionComponent_Inactivity::_interactionTimeThreshold' has a wrong offset!");
static_assert(offsetof(UBehaviourDetectionComponent_Inactivity, _maxInactivityTimerBuffer) == 0x000130, "Member 'UBehaviourDetectionComponent_Inactivity::_maxInactivityTimerBuffer' has a wrong offset!");
static_assert(offsetof(UBehaviourDetectionComponent_Inactivity, _inactivityStages) == 0x000138, "Member 'UBehaviourDetectionComponent_Inactivity::_inactivityStages' has a wrong offset!");
static_assert(offsetof(UBehaviourDetectionComponent_Inactivity, _shouldOnHatchVisibilityChangedStopMonitoring) == 0x000148, "Member 'UBehaviourDetectionComponent_Inactivity::_shouldOnHatchVisibilityChangedStopMonitoring' has a wrong offset!");
static_assert(offsetof(UBehaviourDetectionComponent_Inactivity, _gameEventsInfo) == 0x000150, "Member 'UBehaviourDetectionComponent_Inactivity::_gameEventsInfo' has a wrong offset!");
static_assert(offsetof(UBehaviourDetectionComponent_Inactivity, _interactionInactivityReductionFactor) == 0x000160, "Member 'UBehaviourDetectionComponent_Inactivity::_interactionInactivityReductionFactor' has a wrong offset!");
static_assert(offsetof(UBehaviourDetectionComponent_Inactivity, _movementInactivityAccumulationFactor) == 0x000164, "Member 'UBehaviourDetectionComponent_Inactivity::_movementInactivityAccumulationFactor' has a wrong offset!");
static_assert(offsetof(UBehaviourDetectionComponent_Inactivity, _movementCursedInactivityAccumulationFactor) == 0x000168, "Member 'UBehaviourDetectionComponent_Inactivity::_movementCursedInactivityAccumulationFactor' has a wrong offset!");
static_assert(offsetof(UBehaviourDetectionComponent_Inactivity, _killerProximityInactivityAccumulationFactor) == 0x00016C, "Member 'UBehaviourDetectionComponent_Inactivity::_killerProximityInactivityAccumulationFactor' has a wrong offset!");
static_assert(offsetof(UBehaviourDetectionComponent_Inactivity, _escapeDoorsActivatedInactivityAccumulationFactor) == 0x000170, "Member 'UBehaviourDetectionComponent_Inactivity::_escapeDoorsActivatedInactivityAccumulationFactor' has a wrong offset!");
static_assert(offsetof(UBehaviourDetectionComponent_Inactivity, _killerProximityRange) == 0x000174, "Member 'UBehaviourDetectionComponent_Inactivity::_killerProximityRange' has a wrong offset!");
static_assert(offsetof(UBehaviourDetectionComponent_Inactivity, _killerSpecificInteractionBonus) == 0x000178, "Member 'UBehaviourDetectionComponent_Inactivity::_killerSpecificInteractionBonus' has a wrong offset!");
static_assert(offsetof(UBehaviourDetectionComponent_Inactivity, _generatorCompletedInteractionBonus) == 0x00017C, "Member 'UBehaviourDetectionComponent_Inactivity::_generatorCompletedInteractionBonus' has a wrong offset!");
static_assert(offsetof(UBehaviourDetectionComponent_Inactivity, _stateQueriesToForceInactivity) == 0x000180, "Member 'UBehaviourDetectionComponent_Inactivity::_stateQueriesToForceInactivity' has a wrong offset!");
static_assert(offsetof(UBehaviourDetectionComponent_Inactivity, _stateQueriesToResetInactivity) == 0x000190, "Member 'UBehaviourDetectionComponent_Inactivity::_stateQueriesToResetInactivity' has a wrong offset!");
static_assert(offsetof(UBehaviourDetectionComponent_Inactivity, _stateQueriesToIgnoreInactivity) == 0x0001A0, "Member 'UBehaviourDetectionComponent_Inactivity::_stateQueriesToIgnoreInactivity' has a wrong offset!");
static_assert(offsetof(UBehaviourDetectionComponent_Inactivity, _analyticsComponentClass) == 0x0001B0, "Member 'UBehaviourDetectionComponent_Inactivity::_analyticsComponentClass' has a wrong offset!");
static_assert(offsetof(UBehaviourDetectionComponent_Inactivity, _killersInRange) == 0x0001B8, "Member 'UBehaviourDetectionComponent_Inactivity::_killersInRange' has a wrong offset!");

// Class DeadByDaylight.EnduranceVFXComponent
// 0x0020 (0x00D8 - 0x00B8)
class UEnduranceVFXComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x20];                                      // 0x00B8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ShowHighlight(class UGameplayModifierContainer* preventKOSource);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnduranceVFXComponent">();
	}
	static class UEnduranceVFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnduranceVFXComponent>();
	}
};
static_assert(alignof(UEnduranceVFXComponent) == 0x000008, "Wrong alignment on UEnduranceVFXComponent");
static_assert(sizeof(UEnduranceVFXComponent) == 0x0000D8, "Wrong size on UEnduranceVFXComponent");

// Class DeadByDaylight.BehaviourDetectionSubsystem
// 0x0070 (0x00A8 - 0x0038)
class UBehaviourDetectionSubsystem final : public UWorldSubsystem
{
public:
	TArray<struct FBehaviourDetectionClassConfiguration> _configurations;                            // 0x0038(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class UBaseBehaviourDetectionComponent>, struct FBehaviourDetectionComponentInfo> _componentsByClassMap; // 0x0048(0x0050)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0x10];                                      // 0x0098(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BehaviourDetectionSubsystem">();
	}
	static class UBehaviourDetectionSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBehaviourDetectionSubsystem>();
	}
};
static_assert(alignof(UBehaviourDetectionSubsystem) == 0x000008, "Wrong alignment on UBehaviourDetectionSubsystem");
static_assert(sizeof(UBehaviourDetectionSubsystem) == 0x0000A8, "Wrong size on UBehaviourDetectionSubsystem");
static_assert(offsetof(UBehaviourDetectionSubsystem, _configurations) == 0x000038, "Member 'UBehaviourDetectionSubsystem::_configurations' has a wrong offset!");
static_assert(offsetof(UBehaviourDetectionSubsystem, _componentsByClassMap) == 0x000048, "Member 'UBehaviourDetectionSubsystem::_componentsByClassMap' has a wrong offset!");

// Class DeadByDaylight.BehaviourPenalty_AwardScoreEvent
// 0x0000 (0x0040 - 0x0040)
class UBehaviourPenalty_AwardScoreEvent final : public UBaseBehaviourPenalty
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BehaviourPenalty_AwardScoreEvent">();
	}
	static class UBehaviourPenalty_AwardScoreEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBehaviourPenalty_AwardScoreEvent>();
	}
};
static_assert(alignof(UBehaviourPenalty_AwardScoreEvent) == 0x000008, "Wrong alignment on UBehaviourPenalty_AwardScoreEvent");
static_assert(sizeof(UBehaviourPenalty_AwardScoreEvent) == 0x000040, "Wrong size on UBehaviourPenalty_AwardScoreEvent");

// Class DeadByDaylight.ProceduralGenerationUtilities
// 0x0000 (0x0030 - 0x0030)
class UProceduralGenerationUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralGenerationUtilities">();
	}
	static class UProceduralGenerationUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralGenerationUtilities>();
	}
};
static_assert(alignof(UProceduralGenerationUtilities) == 0x000008, "Wrong alignment on UProceduralGenerationUtilities");
static_assert(sizeof(UProceduralGenerationUtilities) == 0x000030, "Wrong size on UProceduralGenerationUtilities");

// Class DeadByDaylight.BehaviourPenalty_DisconnectPenalty
// 0x0000 (0x0040 - 0x0040)
class UBehaviourPenalty_DisconnectPenalty final : public UBaseBehaviourPenalty
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BehaviourPenalty_DisconnectPenalty">();
	}
	static class UBehaviourPenalty_DisconnectPenalty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBehaviourPenalty_DisconnectPenalty>();
	}
};
static_assert(alignof(UBehaviourPenalty_DisconnectPenalty) == 0x000008, "Wrong alignment on UBehaviourPenalty_DisconnectPenalty");
static_assert(sizeof(UBehaviourPenalty_DisconnectPenalty) == 0x000040, "Wrong size on UBehaviourPenalty_DisconnectPenalty");

// Class DeadByDaylight.PurpleGlyphBloodTrailComponent
// 0x0010 (0x0290 - 0x0280)
class UPurpleGlyphBloodTrailComponent final : public UBloodTrailComponent
{
public:
	uint8                                         Pad_280[0x10];                                     // 0x0280(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DeactivateGlyphBloodTrail();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PurpleGlyphBloodTrailComponent">();
	}
	static class UPurpleGlyphBloodTrailComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPurpleGlyphBloodTrailComponent>();
	}
};
static_assert(alignof(UPurpleGlyphBloodTrailComponent) == 0x000010, "Wrong alignment on UPurpleGlyphBloodTrailComponent");
static_assert(sizeof(UPurpleGlyphBloodTrailComponent) == 0x000290, "Wrong size on UPurpleGlyphBloodTrailComponent");

// Class DeadByDaylight.BehaviourPenalty_LoudNoiseNotifier
// 0x0028 (0x0068 - 0x0040)
class UBehaviourPenalty_LoudNoiseNotifier final : public UBaseBehaviourPenalty
{
public:
	bool                                          _loop;                                             // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _firstDelay;                                       // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _loudNoiseRate;                                    // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBehaviourPenaltyData_LoudNoise        _data;                                             // 0x004C(0x0010)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C[0xC];                                       // 0x005C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BehaviourPenalty_LoudNoiseNotifier">();
	}
	static class UBehaviourPenalty_LoudNoiseNotifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBehaviourPenalty_LoudNoiseNotifier>();
	}
};
static_assert(alignof(UBehaviourPenalty_LoudNoiseNotifier) == 0x000008, "Wrong alignment on UBehaviourPenalty_LoudNoiseNotifier");
static_assert(sizeof(UBehaviourPenalty_LoudNoiseNotifier) == 0x000068, "Wrong size on UBehaviourPenalty_LoudNoiseNotifier");
static_assert(offsetof(UBehaviourPenalty_LoudNoiseNotifier, _loop) == 0x000040, "Member 'UBehaviourPenalty_LoudNoiseNotifier::_loop' has a wrong offset!");
static_assert(offsetof(UBehaviourPenalty_LoudNoiseNotifier, _firstDelay) == 0x000044, "Member 'UBehaviourPenalty_LoudNoiseNotifier::_firstDelay' has a wrong offset!");
static_assert(offsetof(UBehaviourPenalty_LoudNoiseNotifier, _loudNoiseRate) == 0x000048, "Member 'UBehaviourPenalty_LoudNoiseNotifier::_loudNoiseRate' has a wrong offset!");
static_assert(offsetof(UBehaviourPenalty_LoudNoiseNotifier, _data) == 0x00004C, "Member 'UBehaviourPenalty_LoudNoiseNotifier::_data' has a wrong offset!");

// Class DeadByDaylight.EditorMeshVisualization
// 0x00A0 (0x0370 - 0x02D0)
class UEditorMeshVisualization final : public USceneComponent
{
public:
	TSoftObjectPtr<class USkeletalMesh>           MeshVisualization;                                 // 0x02D0(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RelativeTransform;                                 // 0x0310(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditorMeshVisualization">();
	}
	static class UEditorMeshVisualization* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditorMeshVisualization>();
	}
};
static_assert(alignof(UEditorMeshVisualization) == 0x000010, "Wrong alignment on UEditorMeshVisualization");
static_assert(sizeof(UEditorMeshVisualization) == 0x000370, "Wrong size on UEditorMeshVisualization");
static_assert(offsetof(UEditorMeshVisualization, MeshVisualization) == 0x0002D0, "Member 'UEditorMeshVisualization::MeshVisualization' has a wrong offset!");
static_assert(offsetof(UEditorMeshVisualization, RelativeTransform) == 0x000310, "Member 'UEditorMeshVisualization::RelativeTransform' has a wrong offset!");

// Class DeadByDaylight.BlindableComponent
// 0x0008 (0x0278 - 0x0270)
class UBlindableComponent final : public UBlindableBaseComponent
{
public:
	uint8                                         Pad_270[0x8];                                      // 0x0270(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlindableComponent">();
	}
	static class UBlindableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlindableComponent>();
	}
};
static_assert(alignof(UBlindableComponent) == 0x000008, "Wrong alignment on UBlindableComponent");
static_assert(sizeof(UBlindableComponent) == 0x000278, "Wrong size on UBlindableComponent");

// Class DeadByDaylight.Bloodlust
// 0x0158 (0x04F0 - 0x0398)
class UBloodlust : public UStatusEffect
{
public:
	class UCurveFloat*                            BloodlustCurve;                                    // 0x0398(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A0[0x20];                                     // 0x03A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _bloodlustTime;                                    // 0x03C0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C4[0x2C];                                     // 0x03C4(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   _bloodlustResettingGameEvents;                     // 0x03F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_400[0xF0];                                     // 0x0400(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_SetBloodlust(const int32 Amount, const bool enableDecay);
	void OnAllChaseEndedEvent();
	void OnChaseStartedEvent(class ADBDPlayer* chasedPlayer);
	void OnRep_BloodlustTime(float oldBloodlustTime);

	float GetBloodlustTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Bloodlust">();
	}
	static class UBloodlust* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodlust>();
	}
};
static_assert(alignof(UBloodlust) == 0x000008, "Wrong alignment on UBloodlust");
static_assert(sizeof(UBloodlust) == 0x0004F0, "Wrong size on UBloodlust");
static_assert(offsetof(UBloodlust, BloodlustCurve) == 0x000398, "Member 'UBloodlust::BloodlustCurve' has a wrong offset!");
static_assert(offsetof(UBloodlust, _bloodlustTime) == 0x0003C0, "Member 'UBloodlust::_bloodlustTime' has a wrong offset!");
static_assert(offsetof(UBloodlust, _bloodlustResettingGameEvents) == 0x0003F0, "Member 'UBloodlust::_bloodlustResettingGameEvents' has a wrong offset!");

// Class DeadByDaylight.FeatureGateHelper
// 0x0000 (0x0030 - 0x0030)
class UFeatureGateHelper final : public UObject
{
public:
	static bool GetAll(const class UObject* contextObject, TArray<struct FDBDFeatureLockProgress>* outData);
	static bool GetAllByLockState(const class UObject* contextObject, TArray<struct FDBDFeatureLockProgress>* outData, bool Locked);
	static bool GetAllByRole(const class UObject* contextObject, TArray<struct FDBDFeatureLockProgress>* outData, EPlayerRole Role);
	static bool GetAllBySeenState(const class UObject* contextObject, TArray<struct FDBDFeatureLockProgress>* outData, bool WasSeen_0);
	static bool GetSingle(const class UObject* contextObject, struct FDBDFeatureLockProgress* outData, EDBDFeatureType featureType, EPlayerRole Role);
	static bool IsEnabled(const class UObject* contextObject);
	static bool IsLocked(const class UObject* contextObject, EDBDFeatureType featureType, EPlayerRole Role);
	static bool WasSeen(const class UObject* contextObject, EDBDFeatureType featureType, EPlayerRole Role);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FeatureGateHelper">();
	}
	static class UFeatureGateHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFeatureGateHelper>();
	}
};
static_assert(alignof(UFeatureGateHelper) == 0x000008, "Wrong alignment on UFeatureGateHelper");
static_assert(sizeof(UFeatureGateHelper) == 0x000030, "Wrong size on UFeatureGateHelper");

// Class DeadByDaylight.UMGHudEditorVersionWidget
// 0x0028 (0x02D0 - 0x02A8)
class UUMGHudEditorVersionWidget final : public UUserWidget
{
public:
	class UButton*                                VersionButton;                                     // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGDragWidget_HudEditor*               _onEditWidget;                                     // 0x02B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x18];                                     // 0x02B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Hide();
	void OnButtonClick();
	void Show();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGHudEditorVersionWidget">();
	}
	static class UUMGHudEditorVersionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGHudEditorVersionWidget>();
	}
};
static_assert(alignof(UUMGHudEditorVersionWidget) == 0x000008, "Wrong alignment on UUMGHudEditorVersionWidget");
static_assert(sizeof(UUMGHudEditorVersionWidget) == 0x0002D0, "Wrong size on UUMGHudEditorVersionWidget");
static_assert(offsetof(UUMGHudEditorVersionWidget, VersionButton) == 0x0002A8, "Member 'UUMGHudEditorVersionWidget::VersionButton' has a wrong offset!");
static_assert(offsetof(UUMGHudEditorVersionWidget, _onEditWidget) == 0x0002B0, "Member 'UUMGHudEditorVersionWidget::_onEditWidget' has a wrong offset!");

// Class DeadByDaylight.BloodTrailSettings
// 0x0178 (0x01B0 - 0x0038)
class UBloodTrailSettings final : public UDataAsset
{
public:
	float                                         _initialDelay;                                     // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _numBloodDropsPerBloodPool;                        // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _bloodDropsInterval;                               // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFloatValueStrategy*                    _bloodTrailSpawnIntervalTime;                      // 0x0048(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _randomlyRotateBloodDrops;                         // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _bloodDropsRandomScatter;                          // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               _bloodTraceChannel;                                // 0x0058(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBloodDecalEffect*                      _bloodDecalEffect;                                 // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBHVRPerDetailModeInt                  _decalPoolSize;                                    // 0x0068(0x00A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         _recycleThresholdPercentage;                       // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _recycleDistancePercentage;                        // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBHVRPerDetailModeInt                  _maxOverlapping;                                   // 0x0110(0x00A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodTrailSettings">();
	}
	static class UBloodTrailSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodTrailSettings>();
	}
};
static_assert(alignof(UBloodTrailSettings) == 0x000008, "Wrong alignment on UBloodTrailSettings");
static_assert(sizeof(UBloodTrailSettings) == 0x0001B0, "Wrong size on UBloodTrailSettings");
static_assert(offsetof(UBloodTrailSettings, _initialDelay) == 0x000038, "Member 'UBloodTrailSettings::_initialDelay' has a wrong offset!");
static_assert(offsetof(UBloodTrailSettings, _numBloodDropsPerBloodPool) == 0x00003C, "Member 'UBloodTrailSettings::_numBloodDropsPerBloodPool' has a wrong offset!");
static_assert(offsetof(UBloodTrailSettings, _bloodDropsInterval) == 0x000040, "Member 'UBloodTrailSettings::_bloodDropsInterval' has a wrong offset!");
static_assert(offsetof(UBloodTrailSettings, _bloodTrailSpawnIntervalTime) == 0x000048, "Member 'UBloodTrailSettings::_bloodTrailSpawnIntervalTime' has a wrong offset!");
static_assert(offsetof(UBloodTrailSettings, _randomlyRotateBloodDrops) == 0x000050, "Member 'UBloodTrailSettings::_randomlyRotateBloodDrops' has a wrong offset!");
static_assert(offsetof(UBloodTrailSettings, _bloodDropsRandomScatter) == 0x000054, "Member 'UBloodTrailSettings::_bloodDropsRandomScatter' has a wrong offset!");
static_assert(offsetof(UBloodTrailSettings, _bloodTraceChannel) == 0x000058, "Member 'UBloodTrailSettings::_bloodTraceChannel' has a wrong offset!");
static_assert(offsetof(UBloodTrailSettings, _bloodDecalEffect) == 0x000060, "Member 'UBloodTrailSettings::_bloodDecalEffect' has a wrong offset!");
static_assert(offsetof(UBloodTrailSettings, _decalPoolSize) == 0x000068, "Member 'UBloodTrailSettings::_decalPoolSize' has a wrong offset!");
static_assert(offsetof(UBloodTrailSettings, _recycleThresholdPercentage) == 0x000108, "Member 'UBloodTrailSettings::_recycleThresholdPercentage' has a wrong offset!");
static_assert(offsetof(UBloodTrailSettings, _recycleDistancePercentage) == 0x00010C, "Member 'UBloodTrailSettings::_recycleDistancePercentage' has a wrong offset!");
static_assert(offsetof(UBloodTrailSettings, _maxOverlapping) == 0x000110, "Member 'UBloodTrailSettings::_maxOverlapping' has a wrong offset!");

// Class DeadByDaylight.DBDGameInstance
// 0x0808 (0x0A20 - 0x0218)
class UDBDGameInstance : public UGameInstance
{
public:
	uint8                                         Pad_218[0x48];                                     // 0x0218(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class URegionFinder>              RegionClass;                                       // 0x0260(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class Ushopmanager>               ShopManagerClass;                                  // 0x0268(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AOfferingSequenceManager>   OfferingSequenceManagerClass;                      // 0x0270(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFriendManager>             FriendManagerClass;                                // 0x0278(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             AchievementsDataAsset;                             // 0x0280(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameEventTracker*                      GameEventTracker;                                  // 0x0288(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDBDKeyDisplayInfo*                     KeyDisplayInfo;                                    // 0x0290(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LeaveGameRequested;                                // 0x0298(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayerProfileDAL*                      PlayerProfileDAL;                                  // 0x02A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGenerationParams                      TrialGenerationParameters;                         // 0x02A8(0x0038)(Transient, NativeAccessSpecifierPublic)
	TArray<struct FForceSpawnTileData>            ForceSpawnTileData;                                // 0x02E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F0[0x20];                                     // 0x02F0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class AOfferingSequenceManager*               OfferingSequence;                                  // 0x0310(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FParadiseData>     ParadiseData;                                      // 0x0318(0x0050)(NativeAccessSpecifierPublic)
	bool                                          PlayerProfileLoadFailed;                           // 0x0368(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_369[0x7];                                      // 0x0369(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UContentScheduleManager*                ContentScheduleManager;                            // 0x0370(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCharacterProgressionManager*           CharacterProgressionManager;                       // 0x0378(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AuthOrEACErrorAdditionalInfo;                      // 0x0380(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasServerLeftMatch;                                // 0x0390(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasWrittenGameEndStats;                            // 0x0391(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_392[0x6];                                      // 0x0392(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UFearMarketManager*                     FearMarketManager;                                 // 0x0398(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class Ushopmanager*                           shopmanager;                                       // 0x03A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFriendManager*                         FriendManager;                                     // 0x03A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWalletHandler*                         WalletHandler;                                     // 0x03B0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TutorialRequesterName;                             // 0x03B8(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C4[0x4];                                      // 0x03C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UControllerPairingManager*              ControllerPairingManager;                          // 0x03C8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D0[0xE8];                                     // 0x03D0(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	class UChunkingManager*                       ChunkingManager;                                   // 0x04B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADBDPlayer* Player)> OnPlayerDisconnect;                     // 0x04C0(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D0[0x160];                                    // 0x04D0(0x0160)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLibraryManager*                   _assetLibraryManager;                              // 0x0630(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   _bloodwebManagerClass;                             // 0x0638(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOnlineTransactionServiceComponent*     _onlineTransactionService;                         // 0x0670(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_678[0x90];                                     // 0x0678(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDPersistentData*                     _persistentData;                                   // 0x0708(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerDataStorageFacade*               _playerDataFacade;                                 // 0x0710(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URankManager*                           _rankManager;                                      // 0x0718(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDPlayerLevelManager*                 _playerLevelManager;                               // 0x0720(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerNameRegistration*                _playerNameRegistration;                           // 0x0728(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class Uspecialeventmanager*                   _specialEventManager;                              // 0x0730(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBonusPointEventsManager*               _bonusPointEventsManager;                          // 0x0738(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDTimeTravelManager*                  _timeTravelManager;                                // 0x0740(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UToastManager*                          _toastManager;                                     // 0x0748(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDSocialNotificationFactory*          _socialNotificationFactory;                        // 0x0750(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDPartyFacade*                        _partyFacade;                                      // 0x0758(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPenaltyTracker*                        _penaltyTracker;                                   // 0x0760(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_768[0x28];                                     // 0x0768(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class ULightingHelper*                        _ligthingHelper;                                   // 0x0790(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOfferingHandler*                       _offeringHandler;                                  // 0x0798(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7A0[0x8];                                      // 0x07A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UActorKnowledgeCollection*>      _actorKnowledgeCollections;                        // 0x07A8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UMapActorDB*                            _mapActorDB;                                       // 0x07B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UInteractionProficiency*>        _interactionProficiencies;                         // 0x07C0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UDBDHud*                                _theHud;                                           // 0x07D0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7D8[0x28];                                     // 0x07D8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UBloodwebManager*                       _bloodwebManager;                                  // 0x0800(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPopupSequencer*                        _popupSequencer;                                   // 0x0808(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPopupFactory*                          _popupFactory;                                     // 0x0810(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDAuthentication*                     _auth;                                             // 0x0818(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDEasyAntiCheat*                      _eac;                                              // 0x0820(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_828[0x98];                                     // 0x0828(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class UObject>>         _execObjects;                                      // 0x08C0(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	bool                                          _networkFailureDetected;                           // 0x08D0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _networkConnectionMonitoringOnly;                  // 0x08D1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _achievementStatsUploadEnabled;                    // 0x08D2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isDisconnected;                                   // 0x08D3(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isGamepadReconnected;                             // 0x08D4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isProfileOffline;                                 // 0x08D5(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isAppSuspended;                                   // 0x08D6(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isAppResumed;                                     // 0x08D7(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isInvitationRejected;                             // 0x08D8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isAdditionalContentInstalled;                     // 0x08D9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isCloudInventoryInitialized;                      // 0x08DA(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8DB[0x95];                                     // 0x08DB(0x0095)(Fixing Size After Last Property [ Dumper-7 ])
	class UOfferingEffectCollection*              _resultOfferingAndPerkEffects;                     // 0x0970(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCinematicManager*                      _cinematicManager;                                 // 0x0978(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoftBanManager*                        _softBanManager;                                   // 0x0980(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UConsentManager*                        _consentManager;                                   // 0x0988(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOnlineSystemHandler*                   _onlineSystemHandler;                              // 0x0990(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URegionFinder*                          _regionFinder;                                     // 0x0998(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDecalSpawnerCollection*                _decalSpawnerCollection;                           // 0x09A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPrimitiveCollection*                   _characterClippingPrimitiveCollection;             // 0x09A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        LastProviderErrorCode;                             // 0x09B0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDisconnectErrors                             _disconnectError;                                  // 0x09B4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9B5[0xB];                                      // 0x09B5(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	class UDateTimerUpdater*                      _dateTimerUpdater;                                 // 0x09C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9C8[0x58];                                     // 0x09C8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ForceCloseGame();

	void AddActorKnowledgeCollection(class UActorKnowledgeCollection* Collection);
	void Authority_SimulatePerks(const TArray<class FName>& Perks, int32 Level);
	void BeginLoadingScreen(const class FString& MapName);
	void DBD_ApplyMist(const float fogModifier);
	void DBD_ApplyNoMist();
	void DBD_ChangeSteamOverlayPosition(int32 Position, int32 VerticalOffset, int32 HorizontalOffset);
	void DBD_DeleteLocalSaveFile();
	void DBD_DestroySteamInventory();
	void DBD_DisplayCurrentAchievementStat(class FName StatName);
	void DBD_DumpSessions();
	void DBD_ForceLoad();
	void DBD_ForceSave();
	void DBD_GetRegion();
	void DBD_PIXBeginCapture();
	void DBD_PIXEndCapture();
	void DBD_ResetCurrentAchievementStat(class FName StatName, bool andUpload);
	void DBD_ResetCurrentAchievementStats(bool andUpload, bool andUpdateData);
	void DBD_ResetSaveData();
	void DBD_SetFearMarketDate(const class FString& dateString);
	void DBD_SetStatsUploadEnabled(bool Enabled);
	void DBD_TestDiceRoll(float BaseProbability, float MultiplicativeModifier, float AdditiveModifier);
	void DBD_TestRegion();
	void DBD_TestSaveFile(const class FString& Name_0);
	void DBD_TestTickedDiceRoll(float BaseProbability, float ticks, float MultiplicativeModifier, float AdditiveModifier);
	void DBD_ToggleLightingLoaded();
	void DBD_UpdateSteamInventory();
	void EndLoadingScreen(class UWorld* loadedWorld);
	class ABaseSky* GetLevelLighting();
	class ULightingHelper* GetLightingHelper();
	class ULightingInterpolator* GetLightInterpolator();
	void GotoSplashScreen(bool showDefaultDialogueOnSplashScreen);
	void RemoveActorKnowledgeCollection(class UActorKnowledgeCollection* Collection);
	void SimulateOfferingSequence(const TArray<class FName>& offerings, bool PlaySequence);
	void StartOfferingSequence();

	void DBD_PrintAudioConfig() const;
	class UBonusPointEventsManager* GetBonusPointEventsManager() const;
	class UPrimitiveCollection* GetCharacterClippingPrimitiveCollection() const;
	class FName GetCharacterDefaultItem(int32 inCharacterIndex) const;
	class UCinematicManager* GetCinematicManager() const;
	class UConsentManager* GetConsentManager() const;
	int32 GetDeadOrDisconnectedCampersCount(class ADBDPlayerState* exception) const;
	class UDecalSpawnerCollection* GetDecalSpawnerCollection() const;
	class UDedicatedServerManager* GetDedicatedServerManager() const;
	class UInventoryHandler* GetInventoryHandler() const;
	class ULocalEventManager* GetLocalEventManager() const;
	class ADBDPlayer* GetLocallyControlledCharacter() const;
	class ULocalPlayer* GetLocalPlayer() const;
	class APlayerController* GetLocalPlayerController() const;
	class UMapActorDB* GetMapActorDB() const;
	int32 GetMaxSurvivorCount() const;
	class UDBDPlayerLevelManager* GetPlayerLevelManager() const;
	class UPlayerNameRegistration* GetPlayerNameRegistration() const;
	class URankManager* GetRankManager() const;
	class USoftBanManager* GetSoftBanManager() const;
	class Uspecialeventmanager* GetSpecialEventManager() const;
	class UDBDTimeUtilities* GetTimeUtils() const;
	bool HasOfferingByType(EOfferingEffectType Type) const;
	bool HasOfferingOfType(EOfferingEffectType Type, int32 PlayerId, class FName Tag) const;
	bool IsActorKnown(const class ADBDPlayer* knowledgePossessor, class AActor* possiblyKnownActor) const;
	void OnTimeTravelComplete(bool Success, const class FString& Date) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGameInstance">();
	}
	static class UDBDGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDGameInstance>();
	}
};
static_assert(alignof(UDBDGameInstance) == 0x000008, "Wrong alignment on UDBDGameInstance");
static_assert(sizeof(UDBDGameInstance) == 0x000A20, "Wrong size on UDBDGameInstance");
static_assert(offsetof(UDBDGameInstance, RegionClass) == 0x000260, "Member 'UDBDGameInstance::RegionClass' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, ShopManagerClass) == 0x000268, "Member 'UDBDGameInstance::ShopManagerClass' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, OfferingSequenceManagerClass) == 0x000270, "Member 'UDBDGameInstance::OfferingSequenceManagerClass' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, FriendManagerClass) == 0x000278, "Member 'UDBDGameInstance::FriendManagerClass' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, AchievementsDataAsset) == 0x000280, "Member 'UDBDGameInstance::AchievementsDataAsset' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, GameEventTracker) == 0x000288, "Member 'UDBDGameInstance::GameEventTracker' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, KeyDisplayInfo) == 0x000290, "Member 'UDBDGameInstance::KeyDisplayInfo' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, LeaveGameRequested) == 0x000298, "Member 'UDBDGameInstance::LeaveGameRequested' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, PlayerProfileDAL) == 0x0002A0, "Member 'UDBDGameInstance::PlayerProfileDAL' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, TrialGenerationParameters) == 0x0002A8, "Member 'UDBDGameInstance::TrialGenerationParameters' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, ForceSpawnTileData) == 0x0002E0, "Member 'UDBDGameInstance::ForceSpawnTileData' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, OfferingSequence) == 0x000310, "Member 'UDBDGameInstance::OfferingSequence' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, ParadiseData) == 0x000318, "Member 'UDBDGameInstance::ParadiseData' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, PlayerProfileLoadFailed) == 0x000368, "Member 'UDBDGameInstance::PlayerProfileLoadFailed' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, ContentScheduleManager) == 0x000370, "Member 'UDBDGameInstance::ContentScheduleManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, CharacterProgressionManager) == 0x000378, "Member 'UDBDGameInstance::CharacterProgressionManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, AuthOrEACErrorAdditionalInfo) == 0x000380, "Member 'UDBDGameInstance::AuthOrEACErrorAdditionalInfo' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, HasServerLeftMatch) == 0x000390, "Member 'UDBDGameInstance::HasServerLeftMatch' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, HasWrittenGameEndStats) == 0x000391, "Member 'UDBDGameInstance::HasWrittenGameEndStats' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, FearMarketManager) == 0x000398, "Member 'UDBDGameInstance::FearMarketManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, shopmanager) == 0x0003A0, "Member 'UDBDGameInstance::shopmanager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, FriendManager) == 0x0003A8, "Member 'UDBDGameInstance::FriendManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, WalletHandler) == 0x0003B0, "Member 'UDBDGameInstance::WalletHandler' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, TutorialRequesterName) == 0x0003B8, "Member 'UDBDGameInstance::TutorialRequesterName' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, ControllerPairingManager) == 0x0003C8, "Member 'UDBDGameInstance::ControllerPairingManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, ChunkingManager) == 0x0004B8, "Member 'UDBDGameInstance::ChunkingManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, OnPlayerDisconnect) == 0x0004C0, "Member 'UDBDGameInstance::OnPlayerDisconnect' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _assetLibraryManager) == 0x000630, "Member 'UDBDGameInstance::_assetLibraryManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _bloodwebManagerClass) == 0x000638, "Member 'UDBDGameInstance::_bloodwebManagerClass' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _onlineTransactionService) == 0x000670, "Member 'UDBDGameInstance::_onlineTransactionService' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _persistentData) == 0x000708, "Member 'UDBDGameInstance::_persistentData' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _playerDataFacade) == 0x000710, "Member 'UDBDGameInstance::_playerDataFacade' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _rankManager) == 0x000718, "Member 'UDBDGameInstance::_rankManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _playerLevelManager) == 0x000720, "Member 'UDBDGameInstance::_playerLevelManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _playerNameRegistration) == 0x000728, "Member 'UDBDGameInstance::_playerNameRegistration' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _specialEventManager) == 0x000730, "Member 'UDBDGameInstance::_specialEventManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _bonusPointEventsManager) == 0x000738, "Member 'UDBDGameInstance::_bonusPointEventsManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _timeTravelManager) == 0x000740, "Member 'UDBDGameInstance::_timeTravelManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _toastManager) == 0x000748, "Member 'UDBDGameInstance::_toastManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _socialNotificationFactory) == 0x000750, "Member 'UDBDGameInstance::_socialNotificationFactory' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _partyFacade) == 0x000758, "Member 'UDBDGameInstance::_partyFacade' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _penaltyTracker) == 0x000760, "Member 'UDBDGameInstance::_penaltyTracker' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _ligthingHelper) == 0x000790, "Member 'UDBDGameInstance::_ligthingHelper' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _offeringHandler) == 0x000798, "Member 'UDBDGameInstance::_offeringHandler' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _actorKnowledgeCollections) == 0x0007A8, "Member 'UDBDGameInstance::_actorKnowledgeCollections' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _mapActorDB) == 0x0007B8, "Member 'UDBDGameInstance::_mapActorDB' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _interactionProficiencies) == 0x0007C0, "Member 'UDBDGameInstance::_interactionProficiencies' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _theHud) == 0x0007D0, "Member 'UDBDGameInstance::_theHud' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _bloodwebManager) == 0x000800, "Member 'UDBDGameInstance::_bloodwebManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _popupSequencer) == 0x000808, "Member 'UDBDGameInstance::_popupSequencer' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _popupFactory) == 0x000810, "Member 'UDBDGameInstance::_popupFactory' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _auth) == 0x000818, "Member 'UDBDGameInstance::_auth' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _eac) == 0x000820, "Member 'UDBDGameInstance::_eac' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _execObjects) == 0x0008C0, "Member 'UDBDGameInstance::_execObjects' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _networkFailureDetected) == 0x0008D0, "Member 'UDBDGameInstance::_networkFailureDetected' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _networkConnectionMonitoringOnly) == 0x0008D1, "Member 'UDBDGameInstance::_networkConnectionMonitoringOnly' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _achievementStatsUploadEnabled) == 0x0008D2, "Member 'UDBDGameInstance::_achievementStatsUploadEnabled' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _isDisconnected) == 0x0008D3, "Member 'UDBDGameInstance::_isDisconnected' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _isGamepadReconnected) == 0x0008D4, "Member 'UDBDGameInstance::_isGamepadReconnected' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _isProfileOffline) == 0x0008D5, "Member 'UDBDGameInstance::_isProfileOffline' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _isAppSuspended) == 0x0008D6, "Member 'UDBDGameInstance::_isAppSuspended' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _isAppResumed) == 0x0008D7, "Member 'UDBDGameInstance::_isAppResumed' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _isInvitationRejected) == 0x0008D8, "Member 'UDBDGameInstance::_isInvitationRejected' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _isAdditionalContentInstalled) == 0x0008D9, "Member 'UDBDGameInstance::_isAdditionalContentInstalled' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _isCloudInventoryInitialized) == 0x0008DA, "Member 'UDBDGameInstance::_isCloudInventoryInitialized' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _resultOfferingAndPerkEffects) == 0x000970, "Member 'UDBDGameInstance::_resultOfferingAndPerkEffects' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _cinematicManager) == 0x000978, "Member 'UDBDGameInstance::_cinematicManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _softBanManager) == 0x000980, "Member 'UDBDGameInstance::_softBanManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _consentManager) == 0x000988, "Member 'UDBDGameInstance::_consentManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _onlineSystemHandler) == 0x000990, "Member 'UDBDGameInstance::_onlineSystemHandler' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _regionFinder) == 0x000998, "Member 'UDBDGameInstance::_regionFinder' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _decalSpawnerCollection) == 0x0009A0, "Member 'UDBDGameInstance::_decalSpawnerCollection' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _characterClippingPrimitiveCollection) == 0x0009A8, "Member 'UDBDGameInstance::_characterClippingPrimitiveCollection' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, LastProviderErrorCode) == 0x0009B0, "Member 'UDBDGameInstance::LastProviderErrorCode' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _disconnectError) == 0x0009B4, "Member 'UDBDGameInstance::_disconnectError' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _dateTimerUpdater) == 0x0009C0, "Member 'UDBDGameInstance::_dateTimerUpdater' has a wrong offset!");

// Class DeadByDaylight.EventObjectComponent
// 0x0008 (0x00C0 - 0x00B8)
class UEventObjectComponent : public UActorComponent
{
public:
	struct FColor                                 _eventOutlineColour;                               // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventObjectComponent">();
	}
	static class UEventObjectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventObjectComponent>();
	}
};
static_assert(alignof(UEventObjectComponent) == 0x000008, "Wrong alignment on UEventObjectComponent");
static_assert(sizeof(UEventObjectComponent) == 0x0000C0, "Wrong size on UEventObjectComponent");
static_assert(offsetof(UEventObjectComponent, _eventOutlineColour) == 0x0000B8, "Member 'UEventObjectComponent::_eventOutlineColour' has a wrong offset!");

// Class DeadByDaylight.BloodwebBackendTunables
// 0x00B8 (0x00E8 - 0x0030)
class UBloodwebBackendTunables final : public UBloodwebTunables
{
public:
	uint8                                         Pad_30[0xB8];                                      // 0x0030(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodwebBackendTunables">();
	}
	static class UBloodwebBackendTunables* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodwebBackendTunables>();
	}
};
static_assert(alignof(UBloodwebBackendTunables) == 0x000008, "Wrong alignment on UBloodwebBackendTunables");
static_assert(sizeof(UBloodwebBackendTunables) == 0x0000E8, "Wrong size on UBloodwebBackendTunables");

// Class DeadByDaylight.StalkedComponent
// 0x0078 (0x0130 - 0x00B8)
class UStalkedComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(bool isBeingStalked)> OnBeingStalkedChanged;                       // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         _maxStalkPoints;                                   // 0x00C8(0x0004)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _stalkableWhileSightingStalker;                    // 0x00CC(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isBeingStalked;                                   // 0x00CD(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CE[0x2];                                       // 0x00CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargeableComponent*                   _stalkPointsChargeable;                            // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x58];                                      // 0x00D8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_IsBeingStalked();
	void OnRep_MaxStalkPoints();

	bool HasStalkPoints() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StalkedComponent">();
	}
	static class UStalkedComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStalkedComponent>();
	}
};
static_assert(alignof(UStalkedComponent) == 0x000008, "Wrong alignment on UStalkedComponent");
static_assert(sizeof(UStalkedComponent) == 0x000130, "Wrong size on UStalkedComponent");
static_assert(offsetof(UStalkedComponent, OnBeingStalkedChanged) == 0x0000B8, "Member 'UStalkedComponent::OnBeingStalkedChanged' has a wrong offset!");
static_assert(offsetof(UStalkedComponent, _maxStalkPoints) == 0x0000C8, "Member 'UStalkedComponent::_maxStalkPoints' has a wrong offset!");
static_assert(offsetof(UStalkedComponent, _stalkableWhileSightingStalker) == 0x0000CC, "Member 'UStalkedComponent::_stalkableWhileSightingStalker' has a wrong offset!");
static_assert(offsetof(UStalkedComponent, _isBeingStalked) == 0x0000CD, "Member 'UStalkedComponent::_isBeingStalked' has a wrong offset!");
static_assert(offsetof(UStalkedComponent, _stalkPointsChargeable) == 0x0000D0, "Member 'UStalkedComponent::_stalkPointsChargeable' has a wrong offset!");

// Class DeadByDaylight.BloodwebEntity
// 0x0048 (0x0078 - 0x0030)
class UBloodwebEntity final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDGameInstance*                       _gameInstance;                                     // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBloodwebTunables*                      _bloodwebTunables;                                 // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TScriptInterface<class IDBDBloodwebDefinitionBase> _bloodwebDefinition;                          // 0x0048(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x20];                                      // 0x0058(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodwebEntity">();
	}
	static class UBloodwebEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodwebEntity>();
	}
};
static_assert(alignof(UBloodwebEntity) == 0x000008, "Wrong alignment on UBloodwebEntity");
static_assert(sizeof(UBloodwebEntity) == 0x000078, "Wrong size on UBloodwebEntity");
static_assert(offsetof(UBloodwebEntity, _gameInstance) == 0x000038, "Member 'UBloodwebEntity::_gameInstance' has a wrong offset!");
static_assert(offsetof(UBloodwebEntity, _bloodwebTunables) == 0x000040, "Member 'UBloodwebEntity::_bloodwebTunables' has a wrong offset!");
static_assert(offsetof(UBloodwebEntity, _bloodwebDefinition) == 0x000048, "Member 'UBloodwebEntity::_bloodwebDefinition' has a wrong offset!");

// Class DeadByDaylight.RecoverInteractableDefinition
// 0x0030 (0x08F0 - 0x08C0)
class URecoverInteractableDefinition final : public UChargeableInteractionDefinition
{
public:
	class FName                                   _recoverStopPercentTunableName;                    // 0x08C0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _camperRecoverHealSpeedMultiplierTunableName;      // 0x08CC(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8D8[0x18];                                     // 0x08D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsKillerInteracting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RecoverInteractableDefinition">();
	}
	static class URecoverInteractableDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<URecoverInteractableDefinition>();
	}
};
static_assert(alignof(URecoverInteractableDefinition) == 0x000010, "Wrong alignment on URecoverInteractableDefinition");
static_assert(sizeof(URecoverInteractableDefinition) == 0x0008F0, "Wrong size on URecoverInteractableDefinition");
static_assert(offsetof(URecoverInteractableDefinition, _recoverStopPercentTunableName) == 0x0008C0, "Member 'URecoverInteractableDefinition::_recoverStopPercentTunableName' has a wrong offset!");
static_assert(offsetof(URecoverInteractableDefinition, _camperRecoverHealSpeedMultiplierTunableName) == 0x0008CC, "Member 'URecoverInteractableDefinition::_camperRecoverHealSpeedMultiplierTunableName' has a wrong offset!");

// Class DeadByDaylight.BloodwebGenerator
// 0x00C0 (0x00F0 - 0x0030)
class alignas(0x10) UBloodwebGenerator final : public UObject
{
public:
	uint8                                         Pad_30[0xC];                                       // 0x0030(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRandomStream                          _randomizationStream;                              // 0x003C(0x0008)(ZeroConstructor, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         _selectedNodes;                                    // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _selectedContent;                                  // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x48];                                      // 0x0068(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class IDBDBloodwebDefinitionBase> _bloodwebDefinition;                          // 0x00B0(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBloodwebTunables*                      _bloodwebTunables;                                 // 0x00C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _alternativePathOccurenceFactor;                   // 0x00C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBloodwebDistribution*                  _dataDistribution;                                 // 0x00D0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBloodwebSettings*                      _bloodwebSettings;                                 // 0x00D8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x10];                                      // 0x00E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodwebGenerator">();
	}
	static class UBloodwebGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodwebGenerator>();
	}
};
static_assert(alignof(UBloodwebGenerator) == 0x000010, "Wrong alignment on UBloodwebGenerator");
static_assert(sizeof(UBloodwebGenerator) == 0x0000F0, "Wrong size on UBloodwebGenerator");
static_assert(offsetof(UBloodwebGenerator, _randomizationStream) == 0x00003C, "Member 'UBloodwebGenerator::_randomizationStream' has a wrong offset!");
static_assert(offsetof(UBloodwebGenerator, _selectedNodes) == 0x000048, "Member 'UBloodwebGenerator::_selectedNodes' has a wrong offset!");
static_assert(offsetof(UBloodwebGenerator, _selectedContent) == 0x000058, "Member 'UBloodwebGenerator::_selectedContent' has a wrong offset!");
static_assert(offsetof(UBloodwebGenerator, _bloodwebDefinition) == 0x0000B0, "Member 'UBloodwebGenerator::_bloodwebDefinition' has a wrong offset!");
static_assert(offsetof(UBloodwebGenerator, _bloodwebTunables) == 0x0000C0, "Member 'UBloodwebGenerator::_bloodwebTunables' has a wrong offset!");
static_assert(offsetof(UBloodwebGenerator, _alternativePathOccurenceFactor) == 0x0000C8, "Member 'UBloodwebGenerator::_alternativePathOccurenceFactor' has a wrong offset!");
static_assert(offsetof(UBloodwebGenerator, _dataDistribution) == 0x0000D0, "Member 'UBloodwebGenerator::_dataDistribution' has a wrong offset!");
static_assert(offsetof(UBloodwebGenerator, _bloodwebSettings) == 0x0000D8, "Member 'UBloodwebGenerator::_bloodwebSettings' has a wrong offset!");

// Class DeadByDaylight.BloodwebHandler
// 0x0068 (0x0098 - 0x0030)
class UBloodwebHandler final : public UObject
{
public:
	uint8                                         Pad_30[0x68];                                      // 0x0030(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodwebHandler">();
	}
	static class UBloodwebHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodwebHandler>();
	}
};
static_assert(alignof(UBloodwebHandler) == 0x000008, "Wrong alignment on UBloodwebHandler");
static_assert(sizeof(UBloodwebHandler) == 0x000098, "Wrong size on UBloodwebHandler");

// Class DeadByDaylight.BloodwebPathfinder
// 0x0018 (0x0048 - 0x0030)
class UBloodwebPathfinder final : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodwebPathfinder">();
	}
	static class UBloodwebPathfinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodwebPathfinder>();
	}
};
static_assert(alignof(UBloodwebPathfinder) == 0x000008, "Wrong alignment on UBloodwebPathfinder");
static_assert(sizeof(UBloodwebPathfinder) == 0x000048, "Wrong size on UBloodwebPathfinder");

// Class DeadByDaylight.DBDEasyAntiCheatServer
// 0x0070 (0x00C0 - 0x0050)
class UDBDEasyAntiCheatServer final : public UDBDEasyAntiCheatEnable
{
public:
	uint8                                         Pad_50[0x70];                                      // 0x0050(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDEasyAntiCheatServer">();
	}
	static class UDBDEasyAntiCheatServer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDEasyAntiCheatServer>();
	}
};
static_assert(alignof(UDBDEasyAntiCheatServer) == 0x000008, "Wrong alignment on UDBDEasyAntiCheatServer");
static_assert(sizeof(UDBDEasyAntiCheatServer) == 0x0000C0, "Wrong size on UDBDEasyAntiCheatServer");

// Class DeadByDaylight.EscapeDoor
// 0x00F0 (0x0498 - 0x03A8)
class AEscapeDoor final : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        EscapePositions;                                   // 0x03B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        EscapeFire;                                        // 0x03C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UChargeableComponent*                   _killerOpenChargeable;                             // 0x03D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChargeableComponent*                   _openChargeable;                                   // 0x03D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           _ak_audio_escape;                                  // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEscapeDoorAnimInstance*                _escapeDoorAnimInstance;                           // 0x03E8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _rootComponent;                                    // 0x03F0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _activated;                                        // 0x03F8(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F9[0x7];                                      // 0x03F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USpotLightComponent*                    _spotlight;                                        // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_408[0x48];                                     // 0x0408(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class ASurvivor>>       _localOverlappingSurvivors;                        // 0x0450(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_460[0x8];                                      // 0x0460(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIPerceptionStimuliSourceComponent*    _perceptionStimuliComponent;                       // 0x0468(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_470[0x8];                                      // 0x0470(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlockableComponent*                    _doorSwitchBlockableComponent;                     // 0x0478(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_480[0x18];                                     // 0x0480(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnGateDechargeBegin();
	void Cosmetic_OnGateDechargeEnd();
	void Cosmetic_OnSpectatedPlayerChanged(bool isCurrentlyDecharging, bool isSurvivor);
	class UChargeableInteractionDefinition* GetOpenEscapeInteraction();
	void LightAllLights();
	void OnBlockDoorSwitchCosmetic();
	void OnEscapeZoneBeginOverlap(class AActor* overlappingActor);
	void OnEscapeZoneEndOverlap(class AActor* overlappingActor);
	void OnExitActivationChanged(bool activated);
	void OnExitGateOpened(class ADBDPlayer* Player);
	void OnExitOpenChanged(bool OPENED);
	void OnOpenChargeableDechargeBegin(class UChargeableComponent* ChargeableComponent);
	void OnOpenChargeableDechargeEnd(class UChargeableComponent* ChargeableComponent);
	void OnPlayerEnterExitArea(class ADBDPlayer* Player);
	void OnPlayerExitExitArea(class ADBDPlayer* Player);
	void OnRep_Activated(bool oldActivated);
	void OnSpectatedPlayerChanged();
	void OnUnblockDoorSwitchCosmetic();
	void SetIsActivated(bool IsActivated);

	class USkeletalMeshComponent* GetDoorSkeletalMeshComponent() const;
	struct FVector GetEscapeSwitchFloorLocation() const;
	class UBoxComponent* GetExitArea() const;
	bool GetIsOpen() const;
	float GetOpenTime() const;
	struct FVector GetParadiseServerLocation() const;
	class USceneComponent* GetSwitchSceneComponent() const;
	bool IsActivated() const;
	bool IsDoorSwitchBlocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EscapeDoor">();
	}
	static class AEscapeDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEscapeDoor>();
	}
};
static_assert(alignof(AEscapeDoor) == 0x000008, "Wrong alignment on AEscapeDoor");
static_assert(sizeof(AEscapeDoor) == 0x000498, "Wrong size on AEscapeDoor");
static_assert(offsetof(AEscapeDoor, EscapePositions) == 0x0003B0, "Member 'AEscapeDoor::EscapePositions' has a wrong offset!");
static_assert(offsetof(AEscapeDoor, EscapeFire) == 0x0003C0, "Member 'AEscapeDoor::EscapeFire' has a wrong offset!");
static_assert(offsetof(AEscapeDoor, _killerOpenChargeable) == 0x0003D0, "Member 'AEscapeDoor::_killerOpenChargeable' has a wrong offset!");
static_assert(offsetof(AEscapeDoor, _openChargeable) == 0x0003D8, "Member 'AEscapeDoor::_openChargeable' has a wrong offset!");
static_assert(offsetof(AEscapeDoor, _ak_audio_escape) == 0x0003E0, "Member 'AEscapeDoor::_ak_audio_escape' has a wrong offset!");
static_assert(offsetof(AEscapeDoor, _escapeDoorAnimInstance) == 0x0003E8, "Member 'AEscapeDoor::_escapeDoorAnimInstance' has a wrong offset!");
static_assert(offsetof(AEscapeDoor, _rootComponent) == 0x0003F0, "Member 'AEscapeDoor::_rootComponent' has a wrong offset!");
static_assert(offsetof(AEscapeDoor, _activated) == 0x0003F8, "Member 'AEscapeDoor::_activated' has a wrong offset!");
static_assert(offsetof(AEscapeDoor, _spotlight) == 0x000400, "Member 'AEscapeDoor::_spotlight' has a wrong offset!");
static_assert(offsetof(AEscapeDoor, _localOverlappingSurvivors) == 0x000450, "Member 'AEscapeDoor::_localOverlappingSurvivors' has a wrong offset!");
static_assert(offsetof(AEscapeDoor, _perceptionStimuliComponent) == 0x000468, "Member 'AEscapeDoor::_perceptionStimuliComponent' has a wrong offset!");
static_assert(offsetof(AEscapeDoor, _doorSwitchBlockableComponent) == 0x000478, "Member 'AEscapeDoor::_doorSwitchBlockableComponent' has a wrong offset!");

// Class DeadByDaylight.BloodwebSettings
// 0x0010 (0x0048 - 0x0038)
class UBloodwebSettings final : public UDataAsset
{
public:
	TArray<class FName>                           _duplicableItems;                                  // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodwebSettings">();
	}
	static class UBloodwebSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodwebSettings>();
	}
};
static_assert(alignof(UBloodwebSettings) == 0x000008, "Wrong alignment on UBloodwebSettings");
static_assert(sizeof(UBloodwebSettings) == 0x000048, "Wrong size on UBloodwebSettings");
static_assert(offsetof(UBloodwebSettings, _duplicableItems) == 0x000038, "Member 'UBloodwebSettings::_duplicableItems' has a wrong offset!");

// Class DeadByDaylight.BloodDecalEffectIntensity
// 0x0018 (0x0050 - 0x0038)
class UBloodDecalEffectIntensity final : public UDataAsset
{
public:
	struct FColor                                 IntensifyBloodColor;                               // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 IntensifyBloodColor2;                              // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 IntensifyBloodColorEmissive;                       // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntensifyBloodColorEmissiveMinimumIntensity;       // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntensifyBloodColorEmissiveMaximumIntensity;       // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodDecalEffectIntensity">();
	}
	static class UBloodDecalEffectIntensity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodDecalEffectIntensity>();
	}
};
static_assert(alignof(UBloodDecalEffectIntensity) == 0x000008, "Wrong alignment on UBloodDecalEffectIntensity");
static_assert(sizeof(UBloodDecalEffectIntensity) == 0x000050, "Wrong size on UBloodDecalEffectIntensity");
static_assert(offsetof(UBloodDecalEffectIntensity, IntensifyBloodColor) == 0x000038, "Member 'UBloodDecalEffectIntensity::IntensifyBloodColor' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffectIntensity, IntensifyBloodColor2) == 0x00003C, "Member 'UBloodDecalEffectIntensity::IntensifyBloodColor2' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffectIntensity, IntensifyBloodColorEmissive) == 0x000040, "Member 'UBloodDecalEffectIntensity::IntensifyBloodColorEmissive' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffectIntensity, IntensifyBloodColorEmissiveMinimumIntensity) == 0x000044, "Member 'UBloodDecalEffectIntensity::IntensifyBloodColorEmissiveMinimumIntensity' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffectIntensity, IntensifyBloodColorEmissiveMaximumIntensity) == 0x000048, "Member 'UBloodDecalEffectIntensity::IntensifyBloodColorEmissiveMaximumIntensity' has a wrong offset!");

// Class DeadByDaylight.BloodDecalEffect
// 0x00E8 (0x0120 - 0x0038)
class UBloodDecalEffect final : public UDataAsset
{
public:
	class UCurveFloat*                            AnimationTimelineCurve;                            // 0x0038(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DestroyTimelineCurve;                              // 0x0040(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTexture2D*>                     Textures;                                          // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UTexture2D*>                     Normals;                                           // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          CanVisualEffectBeChangedByPerksAndModifiers;       // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanHideBloodTrail;                                 // 0x0069(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x6];                                       // 0x006A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UBloodDecalEffectIntensity*             BloodDecalEffectIntensity;                         // 0x0070(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorInterpolationSpeed;                           // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     DefaultDecalMaterial;                              // 0x0080(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortOrder;                                         // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x84];                                      // 0x008C(0x0084)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _sizeMin;                                          // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sizeMax;                                          // 0x0114(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _defaultLifetime;                                  // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodDecalEffect">();
	}
	static class UBloodDecalEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodDecalEffect>();
	}
};
static_assert(alignof(UBloodDecalEffect) == 0x000008, "Wrong alignment on UBloodDecalEffect");
static_assert(sizeof(UBloodDecalEffect) == 0x000120, "Wrong size on UBloodDecalEffect");
static_assert(offsetof(UBloodDecalEffect, AnimationTimelineCurve) == 0x000038, "Member 'UBloodDecalEffect::AnimationTimelineCurve' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffect, DestroyTimelineCurve) == 0x000040, "Member 'UBloodDecalEffect::DestroyTimelineCurve' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffect, Textures) == 0x000048, "Member 'UBloodDecalEffect::Textures' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffect, Normals) == 0x000058, "Member 'UBloodDecalEffect::Normals' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffect, CanVisualEffectBeChangedByPerksAndModifiers) == 0x000068, "Member 'UBloodDecalEffect::CanVisualEffectBeChangedByPerksAndModifiers' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffect, CanHideBloodTrail) == 0x000069, "Member 'UBloodDecalEffect::CanHideBloodTrail' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffect, BloodDecalEffectIntensity) == 0x000070, "Member 'UBloodDecalEffect::BloodDecalEffectIntensity' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffect, ColorInterpolationSpeed) == 0x000078, "Member 'UBloodDecalEffect::ColorInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffect, DefaultDecalMaterial) == 0x000080, "Member 'UBloodDecalEffect::DefaultDecalMaterial' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffect, SortOrder) == 0x000088, "Member 'UBloodDecalEffect::SortOrder' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffect, _sizeMin) == 0x000110, "Member 'UBloodDecalEffect::_sizeMin' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffect, _sizeMax) == 0x000114, "Member 'UBloodDecalEffect::_sizeMax' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffect, _defaultLifetime) == 0x000118, "Member 'UBloodDecalEffect::_defaultLifetime' has a wrong offset!");

// Class DeadByDaylight.BlueprintDebugUtilities
// 0x0000 (0x0030 - 0x0030)
class UBlueprintDebugUtilities final : public UBlueprintFunctionLibrary
{
public:
	static void EnsureFalseWithMessage(const class FString& ensureMessage);
	static void EnsureOnConditionWithMessage(const bool Condition, const class FString& ensureMessage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlueprintDebugUtilities">();
	}
	static class UBlueprintDebugUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprintDebugUtilities>();
	}
};
static_assert(alignof(UBlueprintDebugUtilities) == 0x000008, "Wrong alignment on UBlueprintDebugUtilities");
static_assert(sizeof(UBlueprintDebugUtilities) == 0x000030, "Wrong size on UBlueprintDebugUtilities");

// Class DeadByDaylight.DBDChildActorInterface
// 0x0000 (0x0000 - 0x0000)
class IDBDChildActorInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDChildActorInterface">();
	}
	static class IDBDChildActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDBDChildActorInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IDBDChildActorInterface) == 0x000001, "Wrong alignment on IDBDChildActorInterface");
static_assert(sizeof(IDBDChildActorInterface) == 0x000001, "Wrong size on IDBDChildActorInterface");

// Class DeadByDaylight.BonusPointEventsManager
// 0x00B8 (0x00E8 - 0x0030)
class UBonusPointEventsManager final : public UObject
{
public:
	uint8                                         Pad_30[0xB8];                                      // 0x0030(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BonusPointEventsManager">();
	}
	static class UBonusPointEventsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBonusPointEventsManager>();
	}
};
static_assert(alignof(UBonusPointEventsManager) == 0x000008, "Wrong alignment on UBonusPointEventsManager");
static_assert(sizeof(UBonusPointEventsManager) == 0x0000E8, "Wrong size on UBonusPointEventsManager");

// Class DeadByDaylight.BorderTile
// 0x0020 (0x0480 - 0x0460)
class ABorderTile final : public ATile
{
public:
	TArray<struct FBorderElements>                Borders;                                           // 0x0460(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UMapData*                               _map;                                              // 0x0470(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_478[0x8];                                      // 0x0478(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BorderTile">();
	}
	static class ABorderTile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABorderTile>();
	}
};
static_assert(alignof(ABorderTile) == 0x000008, "Wrong alignment on ABorderTile");
static_assert(sizeof(ABorderTile) == 0x000480, "Wrong size on ABorderTile");
static_assert(offsetof(ABorderTile, Borders) == 0x000460, "Member 'ABorderTile::Borders' has a wrong offset!");
static_assert(offsetof(ABorderTile, _map) == 0x000470, "Member 'ABorderTile::_map' has a wrong offset!");

// Class DeadByDaylight.BorderTile2
// 0x0018 (0x0318 - 0x0300)
class ABorderTile2 final : public ATile2
{
public:
	TArray<struct FBorderElements2>               Borders;                                           // 0x0300(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          EnableBorderDirection;                             // 0x0310(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDirection                                    BorderDirection;                                   // 0x0311(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_312[0x6];                                      // 0x0312(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BorderTile2">();
	}
	static class ABorderTile2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABorderTile2>();
	}
};
static_assert(alignof(ABorderTile2) == 0x000008, "Wrong alignment on ABorderTile2");
static_assert(sizeof(ABorderTile2) == 0x000318, "Wrong size on ABorderTile2");
static_assert(offsetof(ABorderTile2, Borders) == 0x000300, "Member 'ABorderTile2::Borders' has a wrong offset!");
static_assert(offsetof(ABorderTile2, EnableBorderDirection) == 0x000310, "Member 'ABorderTile2::EnableBorderDirection' has a wrong offset!");
static_assert(offsetof(ABorderTile2, BorderDirection) == 0x000311, "Member 'ABorderTile2::BorderDirection' has a wrong offset!");

// Class DeadByDaylight.DBDInitPlayerQuery
// 0x0000 (0x0030 - 0x0030)
class UDBDInitPlayerQuery : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDInitPlayerQuery">();
	}
	static class UDBDInitPlayerQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDInitPlayerQuery>();
	}
};
static_assert(alignof(UDBDInitPlayerQuery) == 0x000008, "Wrong alignment on UDBDInitPlayerQuery");
static_assert(sizeof(UDBDInitPlayerQuery) == 0x000030, "Wrong size on UDBDInitPlayerQuery");

// Class DeadByDaylight.DBDInitPlayerQueryYesNo
// 0x0080 (0x00B0 - 0x0030)
class UDBDInitPlayerQueryYesNo : public UDBDInitPlayerQuery
{
public:
	uint8                                         Pad_30[0x80];                                      // 0x0030(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDInitPlayerQueryYesNo">();
	}
	static class UDBDInitPlayerQueryYesNo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDInitPlayerQueryYesNo>();
	}
};
static_assert(alignof(UDBDInitPlayerQueryYesNo) == 0x000008, "Wrong alignment on UDBDInitPlayerQueryYesNo");
static_assert(sizeof(UDBDInitPlayerQueryYesNo) == 0x0000B0, "Wrong size on UDBDInitPlayerQueryYesNo");

// Class DeadByDaylight.BreakableBase
// 0x0028 (0x03D0 - 0x03A8)
class ABreakableBase final : public AInteractable
{
public:
	class UBoxComponent*                          _breakableCollision;                               // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBreakableState                               _state;                                            // 0x03B0(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B1[0x7];                                      // 0x03B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkComponent*                           _akAudioBreakable;                                 // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          _akAudioBreakEvent;                                // 0x03C0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _rootComponent;                                    // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Explode(class ADBDPlayer* Player);
	void ExplodeVfxSfx(const struct FVector& ImpulseDir);
	void PlayAudioBreakable();

	bool IsUnbroken() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BreakableBase">();
	}
	static class ABreakableBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABreakableBase>();
	}
};
static_assert(alignof(ABreakableBase) == 0x000008, "Wrong alignment on ABreakableBase");
static_assert(sizeof(ABreakableBase) == 0x0003D0, "Wrong size on ABreakableBase");
static_assert(offsetof(ABreakableBase, _breakableCollision) == 0x0003A8, "Member 'ABreakableBase::_breakableCollision' has a wrong offset!");
static_assert(offsetof(ABreakableBase, _state) == 0x0003B0, "Member 'ABreakableBase::_state' has a wrong offset!");
static_assert(offsetof(ABreakableBase, _akAudioBreakable) == 0x0003B8, "Member 'ABreakableBase::_akAudioBreakable' has a wrong offset!");
static_assert(offsetof(ABreakableBase, _akAudioBreakEvent) == 0x0003C0, "Member 'ABreakableBase::_akAudioBreakEvent' has a wrong offset!");
static_assert(offsetof(ABreakableBase, _rootComponent) == 0x0003C8, "Member 'ABreakableBase::_rootComponent' has a wrong offset!");

// Class DeadByDaylight.PollableEventListener
// 0x0010 (0x00C8 - 0x00B8)
class UPollableEventListener final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PollableEventListener">();
	}
	static class UPollableEventListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPollableEventListener>();
	}
};
static_assert(alignof(UPollableEventListener) == 0x000008, "Wrong alignment on UPollableEventListener");
static_assert(sizeof(UPollableEventListener) == 0x0000C8, "Wrong size on UPollableEventListener");

// Class DeadByDaylight.BreakableWallOutlineUpdateStrategy
// 0x0000 (0x0160 - 0x0160)
class UBreakableWallOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BreakableWallOutlineUpdateStrategy">();
	}
	static class UBreakableWallOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBreakableWallOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UBreakableWallOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UBreakableWallOutlineUpdateStrategy");
static_assert(sizeof(UBreakableWallOutlineUpdateStrategy) == 0x000160, "Wrong size on UBreakableWallOutlineUpdateStrategy");

// Class DeadByDaylight.CakeModePlayerComponent
// 0x0008 (0x00C0 - 0x00B8)
class UCakeModePlayerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CakeModePlayerComponent">();
	}
	static class UCakeModePlayerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCakeModePlayerComponent>();
	}
};
static_assert(alignof(UCakeModePlayerComponent) == 0x000008, "Wrong alignment on UCakeModePlayerComponent");
static_assert(sizeof(UCakeModePlayerComponent) == 0x0000C0, "Wrong size on UCakeModePlayerComponent");

// Class DeadByDaylight.PlayerPerspectiveComponent
// 0x00A8 (0x0160 - 0x00B8)
class UPlayerPerspectiveComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0xA8];                                      // 0x00B8(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPawnControllerChanged(class APawn* Pawn, class AController* OldController, class AController* NewController);
	void UpdateLocallyObserved();

	bool IsLocallyObserved() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerPerspectiveComponent">();
	}
	static class UPlayerPerspectiveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerPerspectiveComponent>();
	}
};
static_assert(alignof(UPlayerPerspectiveComponent) == 0x000008, "Wrong alignment on UPlayerPerspectiveComponent");
static_assert(sizeof(UPlayerPerspectiveComponent) == 0x000160, "Wrong size on UPlayerPerspectiveComponent");

// Class DeadByDaylight.CameraAttachmentComponent
// 0x00C8 (0x0180 - 0x00B8)
class UCameraAttachmentComponent final : public UActorComponent
{
public:
	class USceneComponent*                        _anchor;                                           // 0x00B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x18];                                      // 0x00C0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCameraAttachment                      _defaultCameraAttachment;                          // 0x00D8(0x0018)(Transient, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FCameraAttachment                      _currentCameraAttachment;                          // 0x00F0(0x0018)(Transient, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x78];                                     // 0x0108(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Detach();
	void Reset();

	bool IsAttached() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraAttachmentComponent">();
	}
	static class UCameraAttachmentComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraAttachmentComponent>();
	}
};
static_assert(alignof(UCameraAttachmentComponent) == 0x000008, "Wrong alignment on UCameraAttachmentComponent");
static_assert(sizeof(UCameraAttachmentComponent) == 0x000180, "Wrong size on UCameraAttachmentComponent");
static_assert(offsetof(UCameraAttachmentComponent, _anchor) == 0x0000B8, "Member 'UCameraAttachmentComponent::_anchor' has a wrong offset!");
static_assert(offsetof(UCameraAttachmentComponent, _defaultCameraAttachment) == 0x0000D8, "Member 'UCameraAttachmentComponent::_defaultCameraAttachment' has a wrong offset!");
static_assert(offsetof(UCameraAttachmentComponent, _currentCameraAttachment) == 0x0000F0, "Member 'UCameraAttachmentComponent::_currentCameraAttachment' has a wrong offset!");

// Class DeadByDaylight.RewardUtilities
// 0x0000 (0x0030 - 0x0030)
class URewardUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RewardUtilities">();
	}
	static class URewardUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<URewardUtilities>();
	}
};
static_assert(alignof(URewardUtilities) == 0x000008, "Wrong alignment on URewardUtilities");
static_assert(sizeof(URewardUtilities) == 0x000030, "Wrong size on URewardUtilities");

// Class DeadByDaylight.CameraFadeComponent
// 0x0038 (0x00F0 - 0x00B8)
class UCameraFadeComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x38];                                      // 0x00B8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFadedIn();
	void OnFadedOut();

	ECameraFadeState GetCameraFadeState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraFadeComponent">();
	}
	static class UCameraFadeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraFadeComponent>();
	}
};
static_assert(alignof(UCameraFadeComponent) == 0x000008, "Wrong alignment on UCameraFadeComponent");
static_assert(sizeof(UCameraFadeComponent) == 0x0000F0, "Wrong size on UCameraFadeComponent");

// Class DeadByDaylight.DisplayStandCharmRequesterComponent
// 0x0028 (0x00E0 - 0x00B8)
class UDisplayStandCharmRequesterComponent final : public UActorComponent
{
public:
	TSubclassOf<class ACharm>                     _menuCharmClass;                                   // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x20];                                      // 0x00C0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCharmDisplayed(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisplayStandCharmRequesterComponent">();
	}
	static class UDisplayStandCharmRequesterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisplayStandCharmRequesterComponent>();
	}
};
static_assert(alignof(UDisplayStandCharmRequesterComponent) == 0x000008, "Wrong alignment on UDisplayStandCharmRequesterComponent");
static_assert(sizeof(UDisplayStandCharmRequesterComponent) == 0x0000E0, "Wrong size on UDisplayStandCharmRequesterComponent");
static_assert(offsetof(UDisplayStandCharmRequesterComponent, _menuCharmClass) == 0x0000B8, "Member 'UDisplayStandCharmRequesterComponent::_menuCharmClass' has a wrong offset!");

// Class DeadByDaylight.CameraHandlerComponent
// 0x0100 (0x01B8 - 0x00B8)
class UCameraHandlerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x38];                                      // 0x00B8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EDBDCameraSocketID, class AActor*>       _cameraMap;                                        // 0x00F0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	EDBDCameraSocketID                            _delayedSocketID;                                  // 0x0140(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDBDCameraSocketID                            _currentSocketID;                                  // 0x0141(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_142[0x47];                                     // 0x0142(0x0047)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _manualZoomAllowPerkModifiers;                     // 0x0189(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18A[0x6];                                      // 0x018A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _manualZoomCurveFloat;                             // 0x0190(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _cameraAttachmentSocket;                           // 0x0198(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A4[0x4];                                      // 0x01A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        _cameraAttachmentComponent;                        // 0x01A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isFOVSystemActive;                                // 0x01B0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B1[0x7];                                      // 0x01B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddCameraToSocket(EDBDCameraSocketID Mode, class AActor* Camera);
	class AActor* GetCurrentCamera();
	EDBDCameraSocketID GetSocketID();
	void OnFirstPersonViewChanged(bool isFirstPerson);
	void OnLevelReadyToPlay();
	void PlayVFXOnCurrentCamera(class UParticleSystemComponent* Component);
	void SetAttachmentComponent(class USceneComponent* attachmentComponent);
	void SetSocketID(EDBDCameraSocketID Mode);

	class UCameraComponent* GetCameraComponentBySocket(EDBDCameraSocketID socket) const;
	float GetDesiredFOV() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraHandlerComponent">();
	}
	static class UCameraHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraHandlerComponent>();
	}
};
static_assert(alignof(UCameraHandlerComponent) == 0x000008, "Wrong alignment on UCameraHandlerComponent");
static_assert(sizeof(UCameraHandlerComponent) == 0x0001B8, "Wrong size on UCameraHandlerComponent");
static_assert(offsetof(UCameraHandlerComponent, _cameraMap) == 0x0000F0, "Member 'UCameraHandlerComponent::_cameraMap' has a wrong offset!");
static_assert(offsetof(UCameraHandlerComponent, _delayedSocketID) == 0x000140, "Member 'UCameraHandlerComponent::_delayedSocketID' has a wrong offset!");
static_assert(offsetof(UCameraHandlerComponent, _currentSocketID) == 0x000141, "Member 'UCameraHandlerComponent::_currentSocketID' has a wrong offset!");
static_assert(offsetof(UCameraHandlerComponent, _manualZoomAllowPerkModifiers) == 0x000189, "Member 'UCameraHandlerComponent::_manualZoomAllowPerkModifiers' has a wrong offset!");
static_assert(offsetof(UCameraHandlerComponent, _manualZoomCurveFloat) == 0x000190, "Member 'UCameraHandlerComponent::_manualZoomCurveFloat' has a wrong offset!");
static_assert(offsetof(UCameraHandlerComponent, _cameraAttachmentSocket) == 0x000198, "Member 'UCameraHandlerComponent::_cameraAttachmentSocket' has a wrong offset!");
static_assert(offsetof(UCameraHandlerComponent, _cameraAttachmentComponent) == 0x0001A8, "Member 'UCameraHandlerComponent::_cameraAttachmentComponent' has a wrong offset!");
static_assert(offsetof(UCameraHandlerComponent, _isFOVSystemActive) == 0x0001B0, "Member 'UCameraHandlerComponent::_isFOVSystemActive' has a wrong offset!");

// Class DeadByDaylight.ScreenshotDBDChildActorHook
// 0x0008 (0x0038 - 0x0030)
class UScreenshotDBDChildActorHook final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenshotDBDChildActorHook">();
	}
	static class UScreenshotDBDChildActorHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenshotDBDChildActorHook>();
	}
};
static_assert(alignof(UScreenshotDBDChildActorHook) == 0x000008, "Wrong alignment on UScreenshotDBDChildActorHook");
static_assert(sizeof(UScreenshotDBDChildActorHook) == 0x000038, "Wrong size on UScreenshotDBDChildActorHook");

// Class DeadByDaylight.CameraOffsetController
// 0x0050 (0x0108 - 0x00B8)
class UCameraOffsetController final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x50];                                      // 0x00B8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraOffsetController">();
	}
	static class UCameraOffsetController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraOffsetController>();
	}
};
static_assert(alignof(UCameraOffsetController) == 0x000008, "Wrong alignment on UCameraOffsetController");
static_assert(sizeof(UCameraOffsetController) == 0x000108, "Wrong size on UCameraOffsetController");

// Class DeadByDaylight.CamperMaterialHelperController
// 0x0070 (0x0128 - 0x00B8)
class UCamperMaterialHelperController final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x60];                                      // 0x00B8(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FManagedMaterialGroup>          _managedGroups;                                    // 0x0118(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void AddManagedGroup(class UObject* Source, const class FString& Group);
	void AddManagedGroupWithColor(class UObject* Source, const class FString& Group, class FName ColorParameterName, const struct FLinearColor& Color);
	void AddManagedWithCondition(class UObject* Source, const class FString& Group, const TDelegate<void()>& Condition);
	void RemoveGroupsBySource(class UObject* Source);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CamperMaterialHelperController">();
	}
	static class UCamperMaterialHelperController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCamperMaterialHelperController>();
	}
};
static_assert(alignof(UCamperMaterialHelperController) == 0x000008, "Wrong alignment on UCamperMaterialHelperController");
static_assert(sizeof(UCamperMaterialHelperController) == 0x000128, "Wrong size on UCamperMaterialHelperController");
static_assert(offsetof(UCamperMaterialHelperController, _managedGroups) == 0x000118, "Member 'UCamperMaterialHelperController::_managedGroups' has a wrong offset!");

// Class DeadByDaylight.DBDGame_Lobby
// 0x0088 (0x0488 - 0x0400)
class ADBDGame_Lobby final : public ADBDBaseGameMode
{
public:
	uint8                                         Pad_400[0x18];                                     // 0x0400(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UIdentityValidation*                    _identityValidation;                               // 0x0418(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_420[0x68];                                     // 0x0420(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_AddBotToLobby(int32 SelectedCharacter, const class FString& Item, const class FString& Addon1, const class FString& Addon2, const class FString& Offering, const class FString& perk1, const class FString& perk2, const class FString& perk3, const class FString& perk4, int32 Rank);
	void DBD_AddBotToLobbyByName(const class FString& SelectedCharacter, const class FString& Item, const class FString& Addon1, const class FString& Addon2, const class FString& Offering, const class FString& perk1, const class FString& perk2, const class FString& perk3, const class FString& perk4, int32 Rank);
	void DBD_AddBotToLobbyNoLoadout(int32 SelectedCharacter);
	void DBD_AddBotToLobbyNoLoadoutByName(const class FString& SelectedCharacter);
	void DBD_FillLobby();
	void DBD_FillLobbyWithBotsByName(const class FString& selectedKiller, int32 Rank);
	void DBD_RemoveBotByIndex(int32 botIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGame_Lobby">();
	}
	static class ADBDGame_Lobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDGame_Lobby>();
	}
};
static_assert(alignof(ADBDGame_Lobby) == 0x000008, "Wrong alignment on ADBDGame_Lobby");
static_assert(sizeof(ADBDGame_Lobby) == 0x000488, "Wrong size on ADBDGame_Lobby");
static_assert(offsetof(ADBDGame_Lobby, _identityValidation) == 0x000418, "Member 'ADBDGame_Lobby::_identityValidation' has a wrong offset!");

// Class DeadByDaylight.ExitGateSwitchesRestrictedPlacementAreaStrategy
// 0x0000 (0x00A8 - 0x00A8)
class UExitGateSwitchesRestrictedPlacementAreaStrategy final : public URestrictedPlacementAreaStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExitGateSwitchesRestrictedPlacementAreaStrategy">();
	}
	static class UExitGateSwitchesRestrictedPlacementAreaStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExitGateSwitchesRestrictedPlacementAreaStrategy>();
	}
};
static_assert(alignof(UExitGateSwitchesRestrictedPlacementAreaStrategy) == 0x000008, "Wrong alignment on UExitGateSwitchesRestrictedPlacementAreaStrategy");
static_assert(sizeof(UExitGateSwitchesRestrictedPlacementAreaStrategy) == 0x0000A8, "Wrong size on UExitGateSwitchesRestrictedPlacementAreaStrategy");

// Class DeadByDaylight.CancellableUnhookComponent
// 0x0088 (0x0140 - 0x00B8)
class UCancellableUnhookComponent final : public UActorComponent
{
public:
	struct FDBDTunableRowHandle                   _maximumCancellableUnhooks;                        // 0x00B8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class ADBDPlayer*, int32>                _cancelledUnhooks;                                 // 0x00E0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_130[0x10];                                     // 0x0130(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CancellableUnhookComponent">();
	}
	static class UCancellableUnhookComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCancellableUnhookComponent>();
	}
};
static_assert(alignof(UCancellableUnhookComponent) == 0x000008, "Wrong alignment on UCancellableUnhookComponent");
static_assert(sizeof(UCancellableUnhookComponent) == 0x000140, "Wrong size on UCancellableUnhookComponent");
static_assert(offsetof(UCancellableUnhookComponent, _maximumCancellableUnhooks) == 0x0000B8, "Member 'UCancellableUnhookComponent::_maximumCancellableUnhooks' has a wrong offset!");
static_assert(offsetof(UCancellableUnhookComponent, _cancelledUnhooks) == 0x0000E0, "Member 'UCancellableUnhookComponent::_cancelledUnhooks' has a wrong offset!");

// Class DeadByDaylight.DBDDecalComponent
// 0x0100 (0x0430 - 0x0330)
class UDBDDecalComponent final : public UDecalComponent
{
public:
	TArray<class UStaticMeshComponent*>           staticMeshDecals;                                  // 0x0330(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<class UStaticMeshComponent*, class UGlassStaticMesh*> staticMeshGlass;                      // 0x0340(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceDynamic*>       materialInstances;                                 // 0x0390(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A0[0x80];                                     // 0x03A0(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class UDecalCollection*                       _decalCollection;                                  // 0x0420(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_428[0x8];                                      // 0x0428(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDDecalComponent">();
	}
	static class UDBDDecalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDDecalComponent>();
	}
};
static_assert(alignof(UDBDDecalComponent) == 0x000010, "Wrong alignment on UDBDDecalComponent");
static_assert(sizeof(UDBDDecalComponent) == 0x000430, "Wrong size on UDBDDecalComponent");
static_assert(offsetof(UDBDDecalComponent, staticMeshDecals) == 0x000330, "Member 'UDBDDecalComponent::staticMeshDecals' has a wrong offset!");
static_assert(offsetof(UDBDDecalComponent, staticMeshGlass) == 0x000340, "Member 'UDBDDecalComponent::staticMeshGlass' has a wrong offset!");
static_assert(offsetof(UDBDDecalComponent, materialInstances) == 0x000390, "Member 'UDBDDecalComponent::materialInstances' has a wrong offset!");
static_assert(offsetof(UDBDDecalComponent, _decalCollection) == 0x000420, "Member 'UDBDDecalComponent::_decalCollection' has a wrong offset!");

// Class DeadByDaylight.CarriedMovementComponent
// 0x00D8 (0x0190 - 0x00B8)
class UCarriedMovementComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0xD8];                                      // 0x00B8(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CarriedMovementComponent">();
	}
	static class UCarriedMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCarriedMovementComponent>();
	}
};
static_assert(alignof(UCarriedMovementComponent) == 0x000008, "Wrong alignment on UCarriedMovementComponent");
static_assert(sizeof(UCarriedMovementComponent) == 0x000190, "Wrong size on UCarriedMovementComponent");

// Class DeadByDaylight.CartersSparkComponent
// 0x0130 (0x01E8 - 0x00B8)
class UCartersSparkComponent final : public UActorComponent
{
public:
	bool                                          _staticBlastEnabled;                               // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B9[0x8F];                                      // 0x00B9(0x008F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADBDPlayer*>                     _totallyInsanePlayers;                             // 0x0148(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class ADBDPlayer*                             _owningPlayer;                                     // 0x0158(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _baseStaticBlastCooldown;                          // 0x0160(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _hitSurvivorStaticBlastCooldown;                   // 0x0188(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B0[0x10];                                     // 0x01B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _maxMadnessTier;                                   // 0x01C0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void Authority_AddTotallyInsaneSurvivor(class ADBDPlayer* insaneSurvivor);
	void Authority_RegisterToGameEvents();
	void Multicast_OnShockTherapyCooldownCheatEntered();
	void OnRequestAndBeginInteraction(class UInteractionDefinition* Interaction);
	void TriggerShockTherapyCooldown();
	void TriggerStaticBlastCooldown(bool hasHitSurvivor);

	float GetShockTherapyCooldownDuration() const;
	float GetStaticBlastCooldownDuration(bool hasHitSurvivor) const;
	float GetStaticBlastCooldownPercentElapsed() const;
	bool IsShockTherapyOnCooldown() const;
	bool IsStaticBlastOnCooldown() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CartersSparkComponent">();
	}
	static class UCartersSparkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCartersSparkComponent>();
	}
};
static_assert(alignof(UCartersSparkComponent) == 0x000008, "Wrong alignment on UCartersSparkComponent");
static_assert(sizeof(UCartersSparkComponent) == 0x0001E8, "Wrong size on UCartersSparkComponent");
static_assert(offsetof(UCartersSparkComponent, _staticBlastEnabled) == 0x0000B8, "Member 'UCartersSparkComponent::_staticBlastEnabled' has a wrong offset!");
static_assert(offsetof(UCartersSparkComponent, _totallyInsanePlayers) == 0x000148, "Member 'UCartersSparkComponent::_totallyInsanePlayers' has a wrong offset!");
static_assert(offsetof(UCartersSparkComponent, _owningPlayer) == 0x000158, "Member 'UCartersSparkComponent::_owningPlayer' has a wrong offset!");
static_assert(offsetof(UCartersSparkComponent, _baseStaticBlastCooldown) == 0x000160, "Member 'UCartersSparkComponent::_baseStaticBlastCooldown' has a wrong offset!");
static_assert(offsetof(UCartersSparkComponent, _hitSurvivorStaticBlastCooldown) == 0x000188, "Member 'UCartersSparkComponent::_hitSurvivorStaticBlastCooldown' has a wrong offset!");
static_assert(offsetof(UCartersSparkComponent, _maxMadnessTier) == 0x0001C0, "Member 'UCartersSparkComponent::_maxMadnessTier' has a wrong offset!");

// Class DeadByDaylight.RenderingFeaturesSequencer
// 0x0048 (0x0078 - 0x0030)
class URenderingFeaturesSequencer final : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDAggregateCullDistanceVolumes*       _aggregateCullDistanceVolumes;                     // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWorld*                                 _world;                                            // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x28];                                      // 0x0050(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RenderingFeaturesSequencer">();
	}
	static class URenderingFeaturesSequencer* GetDefaultObj()
	{
		return GetDefaultObjImpl<URenderingFeaturesSequencer>();
	}
};
static_assert(alignof(URenderingFeaturesSequencer) == 0x000008, "Wrong alignment on URenderingFeaturesSequencer");
static_assert(sizeof(URenderingFeaturesSequencer) == 0x000078, "Wrong size on URenderingFeaturesSequencer");
static_assert(offsetof(URenderingFeaturesSequencer, _aggregateCullDistanceVolumes) == 0x000040, "Member 'URenderingFeaturesSequencer::_aggregateCullDistanceVolumes' has a wrong offset!");
static_assert(offsetof(URenderingFeaturesSequencer, _world) == 0x000048, "Member 'URenderingFeaturesSequencer::_world' has a wrong offset!");

// Class DeadByDaylight.CharacterChaseVisualComponent
// 0x00A8 (0x0160 - 0x00B8)
class UCharacterChaseVisualComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void()>              OnChaseStartEvent;                                 // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnChaseEndEvent;                                   // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UMaterialHelperUnaffectedStaticMeshComponent* _vignetteMeshComp;                           // 0x00D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _relativeLocation;                                 // 0x00E0(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _relativeScale;                                    // 0x00F8(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               _relativeRotation;                                 // 0x0110(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         _fovModifyFactor;                                  // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12C[0x34];                                     // 0x012C(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAllChaseEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterChaseVisualComponent">();
	}
	static class UCharacterChaseVisualComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterChaseVisualComponent>();
	}
};
static_assert(alignof(UCharacterChaseVisualComponent) == 0x000008, "Wrong alignment on UCharacterChaseVisualComponent");
static_assert(sizeof(UCharacterChaseVisualComponent) == 0x000160, "Wrong size on UCharacterChaseVisualComponent");
static_assert(offsetof(UCharacterChaseVisualComponent, OnChaseStartEvent) == 0x0000B8, "Member 'UCharacterChaseVisualComponent::OnChaseStartEvent' has a wrong offset!");
static_assert(offsetof(UCharacterChaseVisualComponent, OnChaseEndEvent) == 0x0000C8, "Member 'UCharacterChaseVisualComponent::OnChaseEndEvent' has a wrong offset!");
static_assert(offsetof(UCharacterChaseVisualComponent, _vignetteMeshComp) == 0x0000D8, "Member 'UCharacterChaseVisualComponent::_vignetteMeshComp' has a wrong offset!");
static_assert(offsetof(UCharacterChaseVisualComponent, _relativeLocation) == 0x0000E0, "Member 'UCharacterChaseVisualComponent::_relativeLocation' has a wrong offset!");
static_assert(offsetof(UCharacterChaseVisualComponent, _relativeScale) == 0x0000F8, "Member 'UCharacterChaseVisualComponent::_relativeScale' has a wrong offset!");
static_assert(offsetof(UCharacterChaseVisualComponent, _relativeRotation) == 0x000110, "Member 'UCharacterChaseVisualComponent::_relativeRotation' has a wrong offset!");
static_assert(offsetof(UCharacterChaseVisualComponent, _fovModifyFactor) == 0x000128, "Member 'UCharacterChaseVisualComponent::_fovModifyFactor' has a wrong offset!");

// Class DeadByDaylight.DBDGameMode
// 0x01D0 (0x0628 - 0x0458)
class ADBDGameMode : public ADBDBaseMatchGameMode
{
public:
	uint8                                         Pad_458[0x58];                                     // 0x0458(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnPlayersLoadoutsCreated;                          // 0x04B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class APlayerController>          _killerPlayerControllerClass;                      // 0x04C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoClear, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class APlayerController>          _survivorPlayerControllerClass;                    // 0x04C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoClear, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D0[0x38];                                     // 0x04D0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 KillerCreationPositions;                           // 0x0508(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	class UStatusEffect*                          _gateBlockedStatus;                                // 0x0518(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_520[0xA8];                                     // 0x0520(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	class UNavmeshGeneratorComponent*             _navmeshGeneratorComponent;                        // 0x05C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D0[0x30];                                     // 0x05D0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APlayerStart*>                   _killerSpawnPoints;                                // 0x0600(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class APlayerStart*>                   _survivorSpawnPoints;                              // 0x0610(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class APlayerStart*                           _observerSpawnPoint;                               // 0x0620(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void HostGame();
	void InitializeEscapeRequirements();
	void LevelLoaded(const class FString& LevelName);
	void SetPlayerCount(int32 playerAmount);

	bool AreLoadoutsCreated() const;
	bool IsEscapeOpen() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGameMode">();
	}
	static class ADBDGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDGameMode>();
	}
};
static_assert(alignof(ADBDGameMode) == 0x000008, "Wrong alignment on ADBDGameMode");
static_assert(sizeof(ADBDGameMode) == 0x000628, "Wrong size on ADBDGameMode");
static_assert(offsetof(ADBDGameMode, OnPlayersLoadoutsCreated) == 0x0004B0, "Member 'ADBDGameMode::OnPlayersLoadoutsCreated' has a wrong offset!");
static_assert(offsetof(ADBDGameMode, _killerPlayerControllerClass) == 0x0004C0, "Member 'ADBDGameMode::_killerPlayerControllerClass' has a wrong offset!");
static_assert(offsetof(ADBDGameMode, _survivorPlayerControllerClass) == 0x0004C8, "Member 'ADBDGameMode::_survivorPlayerControllerClass' has a wrong offset!");
static_assert(offsetof(ADBDGameMode, KillerCreationPositions) == 0x000508, "Member 'ADBDGameMode::KillerCreationPositions' has a wrong offset!");
static_assert(offsetof(ADBDGameMode, _gateBlockedStatus) == 0x000518, "Member 'ADBDGameMode::_gateBlockedStatus' has a wrong offset!");
static_assert(offsetof(ADBDGameMode, _navmeshGeneratorComponent) == 0x0005C8, "Member 'ADBDGameMode::_navmeshGeneratorComponent' has a wrong offset!");
static_assert(offsetof(ADBDGameMode, _killerSpawnPoints) == 0x000600, "Member 'ADBDGameMode::_killerSpawnPoints' has a wrong offset!");
static_assert(offsetof(ADBDGameMode, _survivorSpawnPoints) == 0x000610, "Member 'ADBDGameMode::_survivorSpawnPoints' has a wrong offset!");
static_assert(offsetof(ADBDGameMode, _observerSpawnPoint) == 0x000620, "Member 'ADBDGameMode::_observerSpawnPoint' has a wrong offset!");

// Class DeadByDaylight.CharacterClassUtilities
// 0x0000 (0x0030 - 0x0030)
class UCharacterClassUtilities final : public UObject
{
public:
	static class FName GetEquippedCharacterClass(const class ADBDPlayer* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterClassUtilities">();
	}
	static class UCharacterClassUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterClassUtilities>();
	}
};
static_assert(alignof(UCharacterClassUtilities) == 0x000008, "Wrong alignment on UCharacterClassUtilities");
static_assert(sizeof(UCharacterClassUtilities) == 0x000030, "Wrong size on UCharacterClassUtilities");

// Class DeadByDaylight.PlayerGameRelevancyComponent
// 0x0070 (0x0128 - 0x00B8)
class UPlayerGameRelevancyComponent final : public UActorComponent
{
public:
	struct FTagStateBool                          _isRelevantToGameplay;                             // 0x00B8(0x0048)(Net, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x28];                                     // 0x0100(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerGameRelevancyComponent">();
	}
	static class UPlayerGameRelevancyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerGameRelevancyComponent>();
	}
};
static_assert(alignof(UPlayerGameRelevancyComponent) == 0x000008, "Wrong alignment on UPlayerGameRelevancyComponent");
static_assert(sizeof(UPlayerGameRelevancyComponent) == 0x000128, "Wrong size on UPlayerGameRelevancyComponent");
static_assert(offsetof(UPlayerGameRelevancyComponent, _isRelevantToGameplay) == 0x0000B8, "Member 'UPlayerGameRelevancyComponent::_isRelevantToGameplay' has a wrong offset!");

// Class DeadByDaylight.CharacterCollection
// 0x02D8 (0x0390 - 0x00B8)
class UCharacterCollection final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0xF0];                                      // 0x00B8(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	class AKiller*                                _killer;                                           // 0x01A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class AKiller*>                          _killers;                                          // 0x01B0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<class ASurvivor*>                        _survivors;                                        // 0x0200(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<class ADBDPlayer*>                       _mainDBDPlayers;                                   // 0x0250(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<class ADBDPlayer*>                       _otherCharacters;                                  // 0x02A0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<class ACharacter*>                       _nonPlayableCharacters;                            // 0x02F0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<class ACharacter*>                       _allCharacters;                                    // 0x0340(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	const TArray<class ADBDPlayer*> GetAllDBDPlayers() const;
	class AKiller* GetKiller() const;
	const TSet<class AKiller*> GetKillers() const;
	const TSet<class ADBDPlayer*> GetMainDBDPlayers() const;
	const TSet<class ADBDPlayer*> GetOtherCharacters() const;
	const TSet<class ASurvivor*> GetSurvivors() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterCollection">();
	}
	static class UCharacterCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterCollection>();
	}
};
static_assert(alignof(UCharacterCollection) == 0x000008, "Wrong alignment on UCharacterCollection");
static_assert(sizeof(UCharacterCollection) == 0x000390, "Wrong size on UCharacterCollection");
static_assert(offsetof(UCharacterCollection, _killer) == 0x0001A8, "Member 'UCharacterCollection::_killer' has a wrong offset!");
static_assert(offsetof(UCharacterCollection, _killers) == 0x0001B0, "Member 'UCharacterCollection::_killers' has a wrong offset!");
static_assert(offsetof(UCharacterCollection, _survivors) == 0x000200, "Member 'UCharacterCollection::_survivors' has a wrong offset!");
static_assert(offsetof(UCharacterCollection, _mainDBDPlayers) == 0x000250, "Member 'UCharacterCollection::_mainDBDPlayers' has a wrong offset!");
static_assert(offsetof(UCharacterCollection, _otherCharacters) == 0x0002A0, "Member 'UCharacterCollection::_otherCharacters' has a wrong offset!");
static_assert(offsetof(UCharacterCollection, _nonPlayableCharacters) == 0x0002F0, "Member 'UCharacterCollection::_nonPlayableCharacters' has a wrong offset!");
static_assert(offsetof(UCharacterCollection, _allCharacters) == 0x000340, "Member 'UCharacterCollection::_allCharacters' has a wrong offset!");

// Class DeadByDaylight.CharacterCollectionUtilities
// 0x0000 (0x0030 - 0x0030)
class UCharacterCollectionUtilities final : public UBlueprintFunctionLibrary
{
public:
	static const TSet<class ACharacter*> GetAllCharacters(const class UObject* WorldContextObject);
	static TArray<class ADBDPlayer*> GetAllDBDPlayers(const class UObject* WorldContextObject);
	static TArray<class ADBDPlayer*> GetCharactersByPlayerTeam(EPlayerTeam playerTeam, const class UObject* WorldContextObject);
	static TArray<class AKiller*> GetInGameKillers(const class UObject* WorldContextObject);
	static const TSet<class AKiller*> GetInGameKillersByRef(const class UObject* WorldContextObject);
	static TArray<class ADBDPlayer*> GetInGameOtherCharacters(const class UObject* WorldContextObject);
	static TArray<class ADBDPlayer*> GetInGamePlayers(const class UObject* WorldContextObject);
	static TArray<class ASurvivor*> GetInGameSurvivors(const class UObject* WorldContextObject);
	static TArray<class ADBDPlayer*> GetInGameSurvivorsAsPlayers(const class UObject* WorldContextObject);
	static const TSet<class ASurvivor*> GetInGameSurvivorsByRef(const class UObject* WorldContextObject);
	static class AKiller* GetKiller(const class UObject* WorldContextObject);
	static const int32 GetNumberOfInjuredHookedOrDyingSurvivors(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterCollectionUtilities">();
	}
	static class UCharacterCollectionUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterCollectionUtilities>();
	}
};
static_assert(alignof(UCharacterCollectionUtilities) == 0x000008, "Wrong alignment on UCharacterCollectionUtilities");
static_assert(sizeof(UCharacterCollectionUtilities) == 0x000030, "Wrong size on UCharacterCollectionUtilities");

// Class DeadByDaylight.DBDMoriUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDMoriUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDMoriUtilities">();
	}
	static class UDBDMoriUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDMoriUtilities>();
	}
};
static_assert(alignof(UDBDMoriUtilities) == 0x000008, "Wrong alignment on UDBDMoriUtilities");
static_assert(sizeof(UDBDMoriUtilities) == 0x000030, "Wrong size on UDBDMoriUtilities");

// Class DeadByDaylight.CharacterCollisionsUtilities
// 0x0000 (0x0030 - 0x0030)
class UCharacterCollisionsUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterCollisionsUtilities">();
	}
	static class UCharacterCollisionsUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterCollisionsUtilities>();
	}
};
static_assert(alignof(UCharacterCollisionsUtilities) == 0x000008, "Wrong alignment on UCharacterCollisionsUtilities");
static_assert(sizeof(UCharacterCollisionsUtilities) == 0x000030, "Wrong size on UCharacterCollisionsUtilities");

// Class DeadByDaylight.SelectiveVisibilityComponent
// 0x0000 (0x02D0 - 0x02D0)
class USelectiveVisibilityComponent final : public USceneComponent
{
public:
	void Local_SetVisibility(bool bNewVisibility, bool bPropagateToChildren);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SelectiveVisibilityComponent">();
	}
	static class USelectiveVisibilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USelectiveVisibilityComponent>();
	}
};
static_assert(alignof(USelectiveVisibilityComponent) == 0x000010, "Wrong alignment on USelectiveVisibilityComponent");
static_assert(sizeof(USelectiveVisibilityComponent) == 0x0002D0, "Wrong size on USelectiveVisibilityComponent");

// Class DeadByDaylight.CharacterHelper
// 0x0000 (0x0030 - 0x0030)
class UCharacterHelper final : public UObject
{
public:
	static TArray<class FString> GetAllEnabledCharms(bool sortArray);
	static void GetAllOutfitComponentsOfCharacter(TArray<struct FCustomizationItemData>* returnHeads, TArray<struct FCustomizationItemData>* returnTorsos, TArray<struct FCustomizationItemData>* returnLegsWeapons, const class FString& CharacterId, const bool sortArrays);
	static TArray<struct FCharacterDescription> GetCharactersByRole(const class UObject* WorldContextObject, const EPlayerRole Role, const bool sortArray);
	static void GetOutfitComposition(struct FCustomizationItemData* returnHead, struct FCustomizationItemData* returnTorso, struct FCustomizationItemData* returnLegsWeapon, const class FString& OutfitId);
	static TArray<struct FOutfitData> GetOutfitsByCharacterIndex(int32 characterIndex, const bool sortArray, const bool includeCharacterDescriptionOverrides);
	static struct FCharmIdSlot SetCharmSlot(class ADBDPlayerState* PlayerState, const class FName& CharmId, int32 slotIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterHelper">();
	}
	static class UCharacterHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterHelper>();
	}
};
static_assert(alignof(UCharacterHelper) == 0x000008, "Wrong alignment on UCharacterHelper");
static_assert(sizeof(UCharacterHelper) == 0x000030, "Wrong size on UCharacterHelper");

// Class DeadByDaylight.SearchableOutlineUpdateStrategy
// 0x0010 (0x0170 - 0x0160)
class USearchableOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _blockedChestColor;                                // 0x0160(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SearchableOutlineUpdateStrategy">();
	}
	static class USearchableOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USearchableOutlineUpdateStrategy>();
	}
};
static_assert(alignof(USearchableOutlineUpdateStrategy) == 0x000008, "Wrong alignment on USearchableOutlineUpdateStrategy");
static_assert(sizeof(USearchableOutlineUpdateStrategy) == 0x000170, "Wrong size on USearchableOutlineUpdateStrategy");
static_assert(offsetof(USearchableOutlineUpdateStrategy, _blockedChestColor) == 0x000160, "Member 'USearchableOutlineUpdateStrategy::_blockedChestColor' has a wrong offset!");

// Class DeadByDaylight.CharacterInventoryComponent
// 0x0168 (0x0220 - 0x00B8)
class UCharacterInventoryComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x48];                                      // 0x00B8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   _tagsPreventingItemVisibility;                     // 0x0100(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_110[0x10];                                     // 0x0110(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACollectable*>                   _inventory;                                        // 0x0120(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class UItemAddon*>                     _generalAddons;                                    // 0x0130(0x0010)(ExportObject, Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class ACollectable*>                   _backpackInventory;                                // 0x0140(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class ACollectable*>                   _localInventory;                                   // 0x0150(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ACollectable*>                   _localBackpackInventory;                           // 0x0160(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UItemAddon*>                     _allAddons;                                        // 0x0170(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_180[0xA0];                                     // 0x0180(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_AddToInventory(class ACollectable* Item, EInventoryType inventoryType);
	void Authority_ClearAndDestroyInventory();
	void Authority_Collect(class ACollectable* Item, EInventoryType inventoryType, bool swapItemsAndHideOldAway);
	void Authority_RemoveFromInventory(class ACollectable* Item, EInventoryType inventoryType);
	void Authority_UseInventoryItem();
	void EquipItem();
	class UItemAddon* GetAddon(class FName AddonID);
	const TArray<class UItemAddon*> GetAddons();
	class ACollectable* GetFirstItemFromInventory(TSubclassOf<class ACollectable> Item, EInventoryType inventoryType);
	bool HasInInventory(TSubclassOf<class ACollectable> Item, EInventoryType inventoryType);
	void Multicast_AddToInventory(class ACollectable* Item, EInventoryType inventoryType);
	void Multicast_ClearAndDestroyInventory();
	void Multicast_MoveItemToOtherSlot(class ACollectable* itemBeingMoved, EInventoryType targetInventoryType);
	void Multicast_RemoveFromInventory(class ACollectable* Item, EInventoryType inventoryType);
	void OnRep_BackpackInventory();
	void OnRep_GeneralAddons();
	void OnRep_Inventory();
	class ACollectable* SpawnAndCollectItem(class FName ItemId);
	void StoreItem();

	class ACollectable* GetItem(EInventoryType inventoryType) const;
	int32 GetItemCount() const;
	int32 GetItemCountByID(class FName ItemId) const;
	class FName GetItemID(EInventoryType inventoryType) const;
	bool HasEquippedItem() const;
	bool HasItem(EInventoryType inventoryType) const;
	bool HasMaximumItemCount(const class ACollectable* Item) const;
	bool HasStoredItem() const;
	bool IsUsingAimItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterInventoryComponent">();
	}
	static class UCharacterInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterInventoryComponent>();
	}
};
static_assert(alignof(UCharacterInventoryComponent) == 0x000008, "Wrong alignment on UCharacterInventoryComponent");
static_assert(sizeof(UCharacterInventoryComponent) == 0x000220, "Wrong size on UCharacterInventoryComponent");
static_assert(offsetof(UCharacterInventoryComponent, _tagsPreventingItemVisibility) == 0x000100, "Member 'UCharacterInventoryComponent::_tagsPreventingItemVisibility' has a wrong offset!");
static_assert(offsetof(UCharacterInventoryComponent, _inventory) == 0x000120, "Member 'UCharacterInventoryComponent::_inventory' has a wrong offset!");
static_assert(offsetof(UCharacterInventoryComponent, _generalAddons) == 0x000130, "Member 'UCharacterInventoryComponent::_generalAddons' has a wrong offset!");
static_assert(offsetof(UCharacterInventoryComponent, _backpackInventory) == 0x000140, "Member 'UCharacterInventoryComponent::_backpackInventory' has a wrong offset!");
static_assert(offsetof(UCharacterInventoryComponent, _localInventory) == 0x000150, "Member 'UCharacterInventoryComponent::_localInventory' has a wrong offset!");
static_assert(offsetof(UCharacterInventoryComponent, _localBackpackInventory) == 0x000160, "Member 'UCharacterInventoryComponent::_localBackpackInventory' has a wrong offset!");
static_assert(offsetof(UCharacterInventoryComponent, _allAddons) == 0x000170, "Member 'UCharacterInventoryComponent::_allAddons' has a wrong offset!");

// Class DeadByDaylight.HatchOutlineUpdateStrategy
// 0x0000 (0x0100 - 0x0100)
class UHatchOutlineUpdateStrategy final : public UDefaultOutlineUpdateStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HatchOutlineUpdateStrategy">();
	}
	static class UHatchOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHatchOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UHatchOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UHatchOutlineUpdateStrategy");
static_assert(sizeof(UHatchOutlineUpdateStrategy) == 0x000100, "Wrong size on UHatchOutlineUpdateStrategy");

// Class DeadByDaylight.ScreenshotToolConfigurationAsset
// 0x0378 (0x03B0 - 0x0038)
class UScreenshotToolConfigurationAsset final : public UDataAsset
{
public:
	float                                         CharacterWarmupDelay;                              // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SceneWarmupDelay;                                  // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoSelectActorInEditor;                           // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SaveAndCheckoutAssets;                             // 0x0041(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FScreenshotToolMaterialCollection> Collections;                                    // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FName, class FString>              ConsoleVariables;                                  // 0x0058(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FName>                           ConsoleCommands;                                   // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScreenshotToolPathInfo                TempIconPathInfo;                                  // 0x00B8(0x00C0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScreenshotToolPathInfo                AssetPathInfo;                                     // 0x0178(0x00C0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          ExportAllIconsInOneFrame;                          // 0x0238(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239[0x1];                                      // 0x0239(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        IconsExportedPerFrame;                             // 0x023A(0x0002)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScreenshotPreviewAction               PreviewAction;                                     // 0x0240(0x0098)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScreenshotExportAction                ExportAction;                                      // 0x02D8(0x00C8)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UObject>>            HookClasses;                                       // 0x03A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenshotToolConfigurationAsset">();
	}
	static class UScreenshotToolConfigurationAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenshotToolConfigurationAsset>();
	}
};
static_assert(alignof(UScreenshotToolConfigurationAsset) == 0x000008, "Wrong alignment on UScreenshotToolConfigurationAsset");
static_assert(sizeof(UScreenshotToolConfigurationAsset) == 0x0003B0, "Wrong size on UScreenshotToolConfigurationAsset");
static_assert(offsetof(UScreenshotToolConfigurationAsset, CharacterWarmupDelay) == 0x000038, "Member 'UScreenshotToolConfigurationAsset::CharacterWarmupDelay' has a wrong offset!");
static_assert(offsetof(UScreenshotToolConfigurationAsset, SceneWarmupDelay) == 0x00003C, "Member 'UScreenshotToolConfigurationAsset::SceneWarmupDelay' has a wrong offset!");
static_assert(offsetof(UScreenshotToolConfigurationAsset, AutoSelectActorInEditor) == 0x000040, "Member 'UScreenshotToolConfigurationAsset::AutoSelectActorInEditor' has a wrong offset!");
static_assert(offsetof(UScreenshotToolConfigurationAsset, SaveAndCheckoutAssets) == 0x000041, "Member 'UScreenshotToolConfigurationAsset::SaveAndCheckoutAssets' has a wrong offset!");
static_assert(offsetof(UScreenshotToolConfigurationAsset, Collections) == 0x000048, "Member 'UScreenshotToolConfigurationAsset::Collections' has a wrong offset!");
static_assert(offsetof(UScreenshotToolConfigurationAsset, ConsoleVariables) == 0x000058, "Member 'UScreenshotToolConfigurationAsset::ConsoleVariables' has a wrong offset!");
static_assert(offsetof(UScreenshotToolConfigurationAsset, ConsoleCommands) == 0x0000A8, "Member 'UScreenshotToolConfigurationAsset::ConsoleCommands' has a wrong offset!");
static_assert(offsetof(UScreenshotToolConfigurationAsset, TempIconPathInfo) == 0x0000B8, "Member 'UScreenshotToolConfigurationAsset::TempIconPathInfo' has a wrong offset!");
static_assert(offsetof(UScreenshotToolConfigurationAsset, AssetPathInfo) == 0x000178, "Member 'UScreenshotToolConfigurationAsset::AssetPathInfo' has a wrong offset!");
static_assert(offsetof(UScreenshotToolConfigurationAsset, ExportAllIconsInOneFrame) == 0x000238, "Member 'UScreenshotToolConfigurationAsset::ExportAllIconsInOneFrame' has a wrong offset!");
static_assert(offsetof(UScreenshotToolConfigurationAsset, IconsExportedPerFrame) == 0x00023A, "Member 'UScreenshotToolConfigurationAsset::IconsExportedPerFrame' has a wrong offset!");
static_assert(offsetof(UScreenshotToolConfigurationAsset, PreviewAction) == 0x000240, "Member 'UScreenshotToolConfigurationAsset::PreviewAction' has a wrong offset!");
static_assert(offsetof(UScreenshotToolConfigurationAsset, ExportAction) == 0x0002D8, "Member 'UScreenshotToolConfigurationAsset::ExportAction' has a wrong offset!");
static_assert(offsetof(UScreenshotToolConfigurationAsset, HookClasses) == 0x0003A0, "Member 'UScreenshotToolConfigurationAsset::HookClasses' has a wrong offset!");

// Class DeadByDaylight.ItemsAssetLibrary
// 0x0070 (0x0120 - 0x00B0)
class UItemsAssetLibrary : public UAssetLibrary
{
public:
	uint8                                         Pad_B0[0x70];                                      // 0x00B0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemsAssetLibrary">();
	}
	static class UItemsAssetLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemsAssetLibrary>();
	}
};
static_assert(alignof(UItemsAssetLibrary) == 0x000008, "Wrong alignment on UItemsAssetLibrary");
static_assert(sizeof(UItemsAssetLibrary) == 0x000120, "Wrong size on UItemsAssetLibrary");

// Class DeadByDaylight.DBDPlayerState
// 0x04B0 (0x0870 - 0x03C0)
class ADBDPlayerState : public APlayerState
{
public:
	uint8                                         Pad_3C0[0x8];                                      // 0x03C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnAIFinishedPlayingEvent;                          // 0x03C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 MirrorsId;                                         // 0x03D8(0x0010)(Net, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ContentVersion;                                    // 0x03E8(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIDifficultyLevel                            _difficultyLevel;                                  // 0x03F8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPlayerReady;                                     // 0x03F9(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRole                                   GameRole;                                          // 0x03FA(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3FB[0x5];                                      // 0x03FB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UDedicatedServerHandlerComponent*       DedicatedServerHandler;                            // 0x0400(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDSQuestEventsHandlerComponent*         DSQuestEventsHandler;                              // 0x0408(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCharacterStateData                    CamperData;                                        // 0x0410(0x0020)(Net, Transient, RepNotify, NativeAccessSpecifierPublic)
	struct FCharacterStateData                    SlasherData;                                       // 0x0430(0x0020)(Net, RepNotify, NativeAccessSpecifierPublic)
	struct FPlayerStateData                       PlayerData;                                        // 0x0450(0x0068)(Net, RepNotify, NativeAccessSpecifierPublic)
	bool                                          WasDetectedGoingNext;                              // 0x04B8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B9[0x7];                                      // 0x04B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(EDBDScoreTypes playerGameplayEventType, float Amount, class AActor* effector, class AActor* Target)> OnPlayerGameplayEvent; // 0x04C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADBDPlayerState* PlayerState, const EGameState GameState)> OnPlayerGameStateChanged; // 0x04D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<class FName, struct FAwardedScores>      _awardedScoresByType;                              // 0x04E0(0x0050)(Protected, NativeAccessSpecifierProtected)
	struct FUserGameStats                         _cachedUserGameStats;                              // 0x0530(0x00B0)(Protected, NativeAccessSpecifierProtected)
	TArray<struct FOngoingScoreData>              _ongoingScoreEvents;                               // 0x05E0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F0[0x8];                                      // 0x05F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _inParadise;                                       // 0x05F8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _endOfMatchRpcReceived;                            // 0x05F9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5FA[0x6];                                      // 0x05FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEquippedPlayerCustomization           _playerCustomization;                              // 0x0600(0x0038)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	int32                                         _selectedSurvivorIndex;                            // 0x0638(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _selectedKillerIndex;                              // 0x063C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameplayNotificationManager*           _gameplayNotificationManager;                      // 0x0640(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterStatsHandlerComponent*        _characterStatsHandler;                            // 0x0648(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerScoreComponent*                  _playerScoreComponent;                             // 0x0650(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_658[0x20];                                     // 0x0658(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _platformAccountId;                                // 0x0678(0x0010)(Net, ZeroConstructor, Transient, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 _EOSProductId;                                     // 0x0688(0x0010)(Net, ZeroConstructor, Transient, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_698[0x14C];                                    // 0x0698(0x014C)(Fixing Size After Last Property [ Dumper-7 ])
	EPlatformFlag                                 _platform;                                         // 0x07E4(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EProviderFlag                                 _provider;                                         // 0x07E8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _crossplayAllowed;                                 // 0x07EC(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _offNetworkFlag;                                   // 0x07ED(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7EE[0x2];                                      // 0x07EE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStreamerModePlayerData                _streamerModePlayerData;                           // 0x07F0(0x0008)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          _gameLevelLoaded;                                  // 0x07F8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7F9[0x17];                                     // 0x07F9(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _showPortraitBorder;                               // 0x0810(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_811[0x2];                                      // 0x0811(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _hasActiveSubscription;                            // 0x0813(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FMatchIncentiveBreakdown               _matchIncentiveBreakdown;                          // 0x0814(0x0010)(Net, Transient, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         _emblemBonusMultiplier;                            // 0x0824(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _pktLossPercentage;                                // 0x0828(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_82C[0x4];                                      // 0x082C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDBotStateInfo                       _botInfo;                                          // 0x0830(0x0020)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	int32                                         _disconnectedPlayerScore;                          // 0x0850(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESurrenderType                                _availableSurrenderType;                           // 0x0854(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasActiveArchiveDSQuestUpdate;                    // 0x0855(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _kickOutFlag;                                      // 0x0856(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_857[0x1];                                      // 0x0857(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FStatusViewSourceData>          _statusViewSources;                                // 0x0858(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_868[0x8];                                      // 0x0868(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_CancelOngoingScoreEvent(const struct FGameplayTag& scoreTypeTag);
	void Authority_EndOngoingScoreEvent(const struct FGameplayTag& scoreTypeTag);
	void Authority_HandleScoreEvent(const struct FGameplayTag& scoreTypeTag, const struct FScoreEventData& ScoreEventData);
	void Authority_SetBotStateInfo(const struct FDBDBotStateInfo& Info);
	void Authority_SetPlayerGameState(EGameState newGameState, bool isEscapeHatch);
	void ChangeStartingGameRole(EPlayerRole GameRole_0);
	void Client_FireQuestRepetitionValueChangeEvent(int32 Repetition, const class FString& QuestEventId, const class FString& ChallengeId);
	void Client_HandleEndOfMatch(bool Success, const struct FEndOfMatchRPCData& Response);
	void Client_HandleEscapeScoreEvent();
	void Client_InvalidateIncentives();
	void Client_RemotelyDispatchGameEvent(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData);
	void Client_RemotelyDispatchGameEventWithScore(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData, const struct FAwardedScore& AwardedScore);
	void Client_RemotelyDispatchGameEventWithTaggedScore(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData, const struct FGameplayTag& ScoreTypeId, float BloodpointsAwarded);
	void Client_RemoveElementFromInventory(class FName toRemove, bool updateLoadout);
	void Client_SetDSKickedOutReason(const uint32 Reason);
	void Client_SetGameRole(EPlayerRole newRole);
	void Client_SetHasActiveArchiveDSQuestUpdate(bool IsEnabled);
	void Client_SetInParadise();
	void Client_UpdateWallet(const class FString& currencyId, int32 Amount);
	void FireActiveStatusEffectEvent(class FName statusEffectId, float Percentage, int32 iconFilePathIndex, int32 levelToDisplay);
	void FireScoreEvent(EDBDScoreTypes ScoreType, float PercentToAward);
	void Multicast_FireGameplayEvent(EDBDScoreTypes playerGameplayEventType, float Amount, class AActor* effector, class AActor* Target);
	void Multicast_FireGameplayEventWithScore(EDBDScoreTypes playerGameplayEventType, float Amount, class AActor* effector, class AActor* Target, const struct FAwardedScore& AwardedScore);
	void Multicast_FireGameplayEventWithTaggedScore(EDBDScoreTypes playerGameplayEventType, float Amount, class AActor* effector, class AActor* Target, const struct FGameplayTag& ScoreTypeId, float BloodpointsAwarded);
	void Multicast_SetAsDisconnected(EBotReplacementState botReplacementState);
	void Multicast_SetAsLeftMatch(EBotReplacementState botReplacementState);
	void Multicast_SetInParadise();
	void Multicast_SetPlayerGameState(EGameState newGameState, bool isEscapeHatch);
	void OnRep_AvailableSurrenderType();
	void OnRep_BotDifficultyLevel();
	void OnRep_BotInfo();
	void OnRep_CustomizationData();
	void OnRep_DisplayData();
	void Server_CheatSelectKiller(int32 killerIndex);
	void Server_CheatSelectSurvivor(int32 survivorIndex);
	void Server_SetQuestRepetitionByClientValue(int32 Repetition, const class FString& QuestEventId, const class FString& ChallengeId);
	void UpdateOngoingScores();

	const struct FDBDBotStateInfo GetBotStateInfo() const;
	class UGameplayNotificationManager* GetGameplayNotificationManager() const;
	EPlayerRole GetGameRole() const;
	EGameState GetPlayerGameState() const;
	bool HasEscaped() const;
	bool IsInFinishedPlayingState() const;
	bool IsReplacementBot() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerState">();
	}
	static class ADBDPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDPlayerState>();
	}
};
static_assert(alignof(ADBDPlayerState) == 0x000008, "Wrong alignment on ADBDPlayerState");
static_assert(sizeof(ADBDPlayerState) == 0x000870, "Wrong size on ADBDPlayerState");
static_assert(offsetof(ADBDPlayerState, OnAIFinishedPlayingEvent) == 0x0003C8, "Member 'ADBDPlayerState::OnAIFinishedPlayingEvent' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, MirrorsId) == 0x0003D8, "Member 'ADBDPlayerState::MirrorsId' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, ContentVersion) == 0x0003E8, "Member 'ADBDPlayerState::ContentVersion' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _difficultyLevel) == 0x0003F8, "Member 'ADBDPlayerState::_difficultyLevel' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, IsPlayerReady) == 0x0003F9, "Member 'ADBDPlayerState::IsPlayerReady' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, GameRole) == 0x0003FA, "Member 'ADBDPlayerState::GameRole' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, DedicatedServerHandler) == 0x000400, "Member 'ADBDPlayerState::DedicatedServerHandler' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, DSQuestEventsHandler) == 0x000408, "Member 'ADBDPlayerState::DSQuestEventsHandler' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, CamperData) == 0x000410, "Member 'ADBDPlayerState::CamperData' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, SlasherData) == 0x000430, "Member 'ADBDPlayerState::SlasherData' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, PlayerData) == 0x000450, "Member 'ADBDPlayerState::PlayerData' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, WasDetectedGoingNext) == 0x0004B8, "Member 'ADBDPlayerState::WasDetectedGoingNext' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, OnPlayerGameplayEvent) == 0x0004C0, "Member 'ADBDPlayerState::OnPlayerGameplayEvent' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, OnPlayerGameStateChanged) == 0x0004D0, "Member 'ADBDPlayerState::OnPlayerGameStateChanged' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _awardedScoresByType) == 0x0004E0, "Member 'ADBDPlayerState::_awardedScoresByType' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _cachedUserGameStats) == 0x000530, "Member 'ADBDPlayerState::_cachedUserGameStats' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _ongoingScoreEvents) == 0x0005E0, "Member 'ADBDPlayerState::_ongoingScoreEvents' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _inParadise) == 0x0005F8, "Member 'ADBDPlayerState::_inParadise' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _endOfMatchRpcReceived) == 0x0005F9, "Member 'ADBDPlayerState::_endOfMatchRpcReceived' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _playerCustomization) == 0x000600, "Member 'ADBDPlayerState::_playerCustomization' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _selectedSurvivorIndex) == 0x000638, "Member 'ADBDPlayerState::_selectedSurvivorIndex' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _selectedKillerIndex) == 0x00063C, "Member 'ADBDPlayerState::_selectedKillerIndex' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _gameplayNotificationManager) == 0x000640, "Member 'ADBDPlayerState::_gameplayNotificationManager' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _characterStatsHandler) == 0x000648, "Member 'ADBDPlayerState::_characterStatsHandler' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _playerScoreComponent) == 0x000650, "Member 'ADBDPlayerState::_playerScoreComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _platformAccountId) == 0x000678, "Member 'ADBDPlayerState::_platformAccountId' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _EOSProductId) == 0x000688, "Member 'ADBDPlayerState::_EOSProductId' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _platform) == 0x0007E4, "Member 'ADBDPlayerState::_platform' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _provider) == 0x0007E8, "Member 'ADBDPlayerState::_provider' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _crossplayAllowed) == 0x0007EC, "Member 'ADBDPlayerState::_crossplayAllowed' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _offNetworkFlag) == 0x0007ED, "Member 'ADBDPlayerState::_offNetworkFlag' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _streamerModePlayerData) == 0x0007F0, "Member 'ADBDPlayerState::_streamerModePlayerData' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _gameLevelLoaded) == 0x0007F8, "Member 'ADBDPlayerState::_gameLevelLoaded' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _showPortraitBorder) == 0x000810, "Member 'ADBDPlayerState::_showPortraitBorder' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _hasActiveSubscription) == 0x000813, "Member 'ADBDPlayerState::_hasActiveSubscription' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _matchIncentiveBreakdown) == 0x000814, "Member 'ADBDPlayerState::_matchIncentiveBreakdown' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _emblemBonusMultiplier) == 0x000824, "Member 'ADBDPlayerState::_emblemBonusMultiplier' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _pktLossPercentage) == 0x000828, "Member 'ADBDPlayerState::_pktLossPercentage' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _botInfo) == 0x000830, "Member 'ADBDPlayerState::_botInfo' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _disconnectedPlayerScore) == 0x000850, "Member 'ADBDPlayerState::_disconnectedPlayerScore' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _availableSurrenderType) == 0x000854, "Member 'ADBDPlayerState::_availableSurrenderType' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _hasActiveArchiveDSQuestUpdate) == 0x000855, "Member 'ADBDPlayerState::_hasActiveArchiveDSQuestUpdate' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _kickOutFlag) == 0x000856, "Member 'ADBDPlayerState::_kickOutFlag' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _statusViewSources) == 0x000858, "Member 'ADBDPlayerState::_statusViewSources' has a wrong offset!");

// Class DeadByDaylight.CharacterItemsAssetLibrary
// 0x0018 (0x0138 - 0x0120)
class UCharacterItemsAssetLibrary final : public UItemsAssetLibrary
{
public:
	uint8                                         Pad_120[0x18];                                     // 0x0120(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterItemsAssetLibrary">();
	}
	static class UCharacterItemsAssetLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterItemsAssetLibrary>();
	}
};
static_assert(alignof(UCharacterItemsAssetLibrary) == 0x000008, "Wrong alignment on UCharacterItemsAssetLibrary");
static_assert(sizeof(UCharacterItemsAssetLibrary) == 0x000138, "Wrong size on UCharacterItemsAssetLibrary");

// Class DeadByDaylight.PostProcessUpdate
// 0x0000 (0x02A0 - 0x02A0)
class APostProcessUpdate final : public AActor
{
public:
	void PostProcessToggle(bool toggle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PostProcessUpdate">();
	}
	static class APostProcessUpdate* GetDefaultObj()
	{
		return GetDefaultObjImpl<APostProcessUpdate>();
	}
};
static_assert(alignof(APostProcessUpdate) == 0x000008, "Wrong alignment on APostProcessUpdate");
static_assert(sizeof(APostProcessUpdate) == 0x0002A0, "Wrong size on APostProcessUpdate");

// Class DeadByDaylight.CharacterPositionRecorderConfigurator
// 0x0018 (0x00D8 - 0x00C0)
class UCharacterPositionRecorderConfigurator final : public UBaseHitValidationConfigurator
{
public:
	uint8                                         Pad_C0[0x18];                                      // 0x00C0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterPositionRecorderConfigurator">();
	}
	static class UCharacterPositionRecorderConfigurator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterPositionRecorderConfigurator>();
	}
};
static_assert(alignof(UCharacterPositionRecorderConfigurator) == 0x000008, "Wrong alignment on UCharacterPositionRecorderConfigurator");
static_assert(sizeof(UCharacterPositionRecorderConfigurator) == 0x0000D8, "Wrong size on UCharacterPositionRecorderConfigurator");

// Class DeadByDaylight.AnimationWidget
// 0x0008 (0x02B0 - 0x02A8)
class UAnimationWidget final : public UUserWidget
{
public:
	float                                         _playRate;                                         // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetPlayRate(float Rate);

	float GetPlayRate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationWidget">();
	}
	static class UAnimationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimationWidget>();
	}
};
static_assert(alignof(UAnimationWidget) == 0x000008, "Wrong alignment on UAnimationWidget");
static_assert(sizeof(UAnimationWidget) == 0x0002B0, "Wrong size on UAnimationWidget");
static_assert(offsetof(UAnimationWidget, _playRate) == 0x0002A8, "Member 'UAnimationWidget::_playRate' has a wrong offset!");

// Class DeadByDaylight.CharacterProgressionManager
// 0x0008 (0x0038 - 0x0030)
class UCharacterProgressionManager final : public UObject
{
public:
	TWeakObjectPtr<class UDBDGameInstance>        _gameInstance;                                     // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterProgressionManager">();
	}
	static class UCharacterProgressionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterProgressionManager>();
	}
};
static_assert(alignof(UCharacterProgressionManager) == 0x000008, "Wrong alignment on UCharacterProgressionManager");
static_assert(sizeof(UCharacterProgressionManager) == 0x000038, "Wrong size on UCharacterProgressionManager");
static_assert(offsetof(UCharacterProgressionManager, _gameInstance) == 0x000030, "Member 'UCharacterProgressionManager::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.FoliageActor
// 0x0008 (0x02A8 - 0x02A0)
class AFoliageActor final : public AActor
{
public:
	class UFoliageDensityHISM*                    _foliageHISM;                                      // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FoliageActor">();
	}
	static class AFoliageActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFoliageActor>();
	}
};
static_assert(alignof(AFoliageActor) == 0x000008, "Wrong alignment on AFoliageActor");
static_assert(sizeof(AFoliageActor) == 0x0002A8, "Wrong size on AFoliageActor");
static_assert(offsetof(AFoliageActor, _foliageHISM) == 0x0002A0, "Member 'AFoliageActor::_foliageHISM' has a wrong offset!");

// Class DeadByDaylight.CharacterStatsHandlerComponent
// 0x0010 (0x00C8 - 0x00B8)
class UCharacterStatsHandlerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializePreMatchStats();
	void OnGameEvent(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData);
	void ReceiveGameEvent(EDBDScoreTypes ScoreType, float Amount, class AActor* Instigator, class AActor* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterStatsHandlerComponent">();
	}
	static class UCharacterStatsHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterStatsHandlerComponent>();
	}
};
static_assert(alignof(UCharacterStatsHandlerComponent) == 0x000008, "Wrong alignment on UCharacterStatsHandlerComponent");
static_assert(sizeof(UCharacterStatsHandlerComponent) == 0x0000C8, "Wrong size on UCharacterStatsHandlerComponent");

// Class DeadByDaylight.CharacterStatsUtilities
// 0x0000 (0x0030 - 0x0030)
class UCharacterStatsUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterStatsUtilities">();
	}
	static class UCharacterStatsUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterStatsUtilities>();
	}
};
static_assert(alignof(UCharacterStatsUtilities) == 0x000008, "Wrong alignment on UCharacterStatsUtilities");
static_assert(sizeof(UCharacterStatsUtilities) == 0x000030, "Wrong size on UCharacterStatsUtilities");

// Class DeadByDaylight.DBDUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UActorComponent* AddComponentToActor(class UClass* compClass, class FName compName, class AActor* Actor);
	static bool BoxTraceAgainstActor(const struct FVector& Start, const struct FVector& End, const class UBoxComponent* Box, const class AActor* Actor, struct FHitResult* outHitResult);
	static bool CancelSurvivorInteractionAndItemUse(class ASurvivor* Survivor, bool requireInteractionBeCancelableOnHit);
	static void CrashGameCausingInterrupt();
	static bool DBDCapsuleTraceSingle(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, ECollisionChannel TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf);
	static float DistanceFromPointToPane(const struct FVector& Point, const struct FPlane& Plane);
	static bool FindFloorSingle(const class UObject* WorldContextObject, const struct FVector& Location, float raycastLength, struct FHitResult* OutHit);
	static class AActor* FindParentOfClass(class AActor* InChild, class UClass* InClass);
	static EShadowSystem GetActiveShadowSystem();
	static class FString GetActorOwnerName(class AActor* Actor);
	static void GetActorSpawners(TArray<class UActorSpawner*>* actorSpawners);
	static float GetAnimSequenceLength(const class UAnimSequence* Sequence);
	static class AProceduralLevelBuilder* GetBuilder(const class UObject* WorldContextObject);
	static TArray<class AGenerator*> GetClosestGenerators(const TArray<class AGenerator*>& unrevealedGenerators, const int32 closestGeneratorsCount);
	static struct FVector GetClosestPointOnOrbit(const struct FVector& centerPoint, const struct FVector& orbitterPosition, const float Distance);
	static struct FTransform GetClosestSnapTransformOnOrbit(const struct FVector& centerPoint, const struct FVector& orbitterPosition, const float Distance);
	static class AGenerator* GetClosestUnrepairedGenerator(const class AActor* Actor);
	static class FString GetComponentOwnerName(class UActorComponent* ActorComponent);
	static class ADBDAIPlayerController* GetDBDAIPlayerController(class ADBDPlayer* Player);
	static class UDBDGameInstance* GetDBDGameInstance(const class UObject* WorldContextObject);
	static class ADBDGameMode* GetDBDGameMode(const class UObject* WorldContextObject);
	static class ADBDGameState* GetDBDGameState(const class UObject* WorldContextObject);
	static float GetDistanceToNearestHookedSurvivor(const class ADBDPlayer* Player);
	static float GetEndGameTunableValue(const class UObject* WorldContextObject, class FName valueName);
	static class AActor* GetFirstActorWithTag(class FName Tag, const TArray<class AActor*>& actorsArray);
	static struct FVector GetFloorLocationAt(class UObject* WorldContextObject, const struct FVector& Location, float raycastStartHeight, float raycastEndHeight, bool useComplex);
	static class FString GetFormattedNumberString(float Value, int32 maxDecimals, int32 minDecimals, bool leadingZero);
	static class FText GetFormattedNumberText(float Value, int32 maxDecimals, int32 minDecimals, bool leadingZero);
	static ECollisionChannel GetImpactCollisionObjectType(const class UPrimitiveComponent* Primitive);
	static struct FCollisionResponseContainer GetImpactCollisionResponseContainer(const class UPrimitiveComponent* Primitive);
	static int32 GetInventoryCount(const class UObject* WorldContextObject, int32 characterIndex, class FName ItemId);
	static int32 GetInventoryCountForMultipleCharacters(const class UObject* WorldContextObject, const TArray<int32>& characterIndexes, class FName ItemId);
	static class ADBDPlayerCameraManager* GetLocalDBDCameraManager(class UObject* WorldContextObject);
	static class ADBDPlayerControllerBase* GetLocalDBDPlayerController(const class UObject* WorldContextObject);
	static class ADBDPlayer* GetLocallyControlledCharacter(const class UObject* WorldContextObject);
	static EPlayerRole GetLocallyControlledCharacterRole(const class UObject* WorldContextObject);
	static class AKiller* GetLocallyControlledKiller(const class UObject* WorldContextObject);
	static class ASurvivor* GetLocallyControlledSurvivor(const class UObject* WorldContextObject);
	static class ADBDPlayer* GetLocallyObservedCharacter(const class UObject* WorldContextObject);
	static EPlayerRole GetLocallyObservedCharacterRole(const class UObject* WorldContextObject);
	static class FString GetLogStringMaterialInfo(const class FString& inStr, const class UMaterialInterface* Root);
	static TArray<class UMaterialHelper*> GetMaterialHelpersAttachedToPlayerMesh(const class ADBDPlayer* Player);
	static float GetMontageLength(class UAnimMontage* Montage);
	static bool GetNearbyActorsOfType(class UWorld* World, const struct FVector& Center, float Radius, TArray<class AActor*>* outNearbyActors, class UClass* actorClassType, ECollisionChannel CollisionChannel, class AActor* IgnoreActor);
	static void GetNearbyCampers(class UWorld* World, const struct FVector& Center, float Radius, TArray<class ASurvivor*>* outNearbyCampers, const TArray<class AActor*>& ignoredCampers);
	static int32 GetNextPowerOf2(float Value);
	static class AActor* GetOuterMostActor(const class UAnimInstance* AnimInstance);
	static class ASurvivor* GetOwningCamper(const class UAnimInstance* AnimInstance);
	static class ADBDBasePlayer* GetOwningDBDBasePlayer(const class UAnimInstance* AnimInstance);
	static class ADBDBasePlayer* GetOwningDBDBasePlayerFromActor(const class AActor* Actor, bool recursiveSearch);
	static class AKiller* GetOwningKillerFromActor(const class AActor* Actor, bool recursiveSearch);
	static class AKiller* GetOwningSlasher(const class UAnimInstance* AnimInstance);
	static class ASurvivor* GetOwningSurvivorFromActor(const class AActor* Actor, bool recursiveSearch);
	static float GetPercentOfRange(const float Val, const float Min, const float Max);
	static float GetPlayRateForMontage(class UAnimMontage* Montage, float Time);
	static struct FVector GetSimilarVector(const struct FVector& Vector, float maximumDeviation);
	static float GetSlasherTunableValue(const class UObject* WorldContextObject, class FName valueName);
	static float GetSquaredDistanceToKiller(const class AActor* Actor);
	static void GetTileSpawnPoints(TArray<class UTileSpawnPoint*>* tileSpawnPoints);
	static struct FTimespan GetTotalPlaytime(const class UObject* WorldContextObject, bool Update);
	static float GetVelocityXYAngleDegrees(const class AActor* Actor);
	static struct FVector GetXYVector(const struct FVector& Vector);
	static struct FRotator GetYawOnly(const struct FRotator& Rotation);
	static bool HasFloorForward(class UObject* WorldContextObject, const struct FVector& Location, const struct FVector& fowardVector, float Distance, float raycastStartHeight, float raycastEndHeight, TArray<struct FHitResult>* OutHits, struct FVector* raycastStart);
	static bool HasLineOfSightToTarget(class UObject* WorldContextObject, const struct FVector& StartPosition, const struct FVector& TargetPosition, const class AActor* ignoredActor, const bool useComplex, const bool useDebugLogs);
	static bool HasWalkableSurfaceForward(class UObject* WorldContextObject, const struct FVector& Location, const struct FVector& fowardVector, float Distance, float raycastStartHeight, float raycastEndHeight, TArray<struct FHitResult>* OutHits, struct FVector* raycastStart);
	static bool IsClassChildOfOtherClasses(const class UClass* classToCheck, const TArray<class UClass*>& otherClasses);
	static bool IsInKillerTeam(const class UObject* WorldContextObject);
	static bool IsInSurvivorTeam(const class UObject* WorldContextObject);
	static bool IsInTutorialLevel(const class UObject* WorldContextObject);
	static bool IsLocallyObservedCharacterInRange(const class AActor* Target, const float Range);
	static bool IsLocallyObservingAKiller(const class UObject* WorldContextObject);
	static bool IsLocallyObservingASurvivor(const class UObject* WorldContextObject);
	static bool IsNonViolent();
	static bool IsReplaceDisconnectedPlayersWithBotsActive();
	static bool IsServer(const class UObject* WorldContextObject);
	static bool IsSteamPIEGame(const class UObject* contextObject);
	static bool KillerInterruptSurvivorInteraction(class AKiller* Killer, class ASurvivor* Survivor, bool requireInteractionBeCancelableOnHit);
	static void LogMeshMaterialInfo(const class FString& inStr, const class UMeshComponent* Root);
	static void LogString(const class FString& inStr);
	static bool NormalizeXY(struct FVector* Vector, float Tolerance);
	static int64 PointerToInt(class UObject* Obj);
	static void PrintStringEmbiggened(const class UObject* WorldContextObject, const class FString& InString, const struct FLinearColor& TextColor, float Duration, int32 Key, float Scale);
	static int32 ResolveCharacterIdFromPlayerState(const class ADBDPlayerState* PlayerState);
	static float Saturate(float Value);
	static void SetComponentCastHiddenShadow(class UPrimitiveComponent* Component, bool CastShadow);
	static bool SphereTraceAgainstActor(const struct FVector& Start, const struct FVector& End, const class USphereComponent* Sphere, const class AActor* Actor, struct FHitResult* outHitResult);
	static bool SphereTraceSingle(const struct FVector& Start, const struct FVector& End, const class USphereComponent* Sphere, struct FHitResult* outHitResult, const TArray<class AActor*>& IgnoredActors);
	static float ToAngle_negative180to180(float Angle);
	static bool WithinRange(float Min, float Max, float Value);
	static bool WithinRangeExclusive(float Min, float Max, float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDUtilities">();
	}
	static class UDBDUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDUtilities>();
	}
};
static_assert(alignof(UDBDUtilities) == 0x000008, "Wrong alignment on UDBDUtilities");
static_assert(sizeof(UDBDUtilities) == 0x000030, "Wrong size on UDBDUtilities");

// Class DeadByDaylight.DBDEditorActor
// 0x0000 (0x02A0 - 0x02A0)
class ADBDEditorActor : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDEditorActor">();
	}
	static class ADBDEditorActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDEditorActor>();
	}
};
static_assert(alignof(ADBDEditorActor) == 0x000008, "Wrong alignment on ADBDEditorActor");
static_assert(sizeof(ADBDEditorActor) == 0x0002A0, "Wrong size on ADBDEditorActor");

// Class DeadByDaylight.DBDGameUserSettings
// 0x03C8 (0x0518 - 0x0150)
class UDBDGameUserSettings final : public UGameUserSettings
{
public:
	TArray<struct FInputActionKeyMapping>         ActionMappings;                                    // 0x0150(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FInputAxisKeyMapping>           AxisMappings;                                      // 0x0160(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSetCustomizedHudsTimestamp;                      // 0x0170(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_180[0x18];                                     // 0x0180(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DeviceLoginTokenID;                                // 0x0198(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ScalabilityLevel;                                  // 0x01A8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          AutoScalabilitySet;                                // 0x01AC(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          AutoAdjust;                                        // 0x01AD(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1AE[0x2];                                      // 0x01AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ScreenRenderSize;                                  // 0x01B0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HUDConstrainedAspectRatio;                         // 0x01B4(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B5[0x3];                                      // 0x01B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MenuScaleFactor;                                   // 0x01B8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         HudScaleFactor;                                    // 0x01BC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SkillCheckScaleFactor;                             // 0x01C0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          LargeText;                                         // 0x01C4(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          BloodwebInteractionBehaviour;                      // 0x01C5(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          TerrorRadiusVisualFeedback;                        // 0x01C6(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          DeepWoundBarVisibility;                            // 0x01C7(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         FieldOfView;                                       // 0x01C8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HUDPlayerNamesVisibility;                          // 0x01CC(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HUDKillerHookCountVisibility;                      // 0x01CD(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HUDScoreEventsVisibility;                          // 0x01CE(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HUDUseItemPickupPopupAbridgedVersion;              // 0x01CF(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          LegacyPrestigePortraits;                           // 0x01D0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          ShowHudStatusEffectValueNumber;                    // 0x01D1(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D2[0x2];                                      // 0x01D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        FPSLimitMode;                                      // 0x01D4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AntiAliasingMode;                                  // 0x01D8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          EnableFSR;                                         // 0x01DC(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1DD[0x3];                                      // 0x01DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SharpnessValue;                                    // 0x01E0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         XeSSMode;                                          // 0x01E4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MainVolume;                                        // 0x01E8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          MainVolumeOn;                                      // 0x01EC(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1ED[0x3];                                      // 0x01ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MenuMusicVolume;                                   // 0x01F0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          MenuMusicVolumeOn;                                 // 0x01F4(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          UseHeadphones;                                     // 0x01F5(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          MuteOnFocusLost;                                   // 0x01F6(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HapticsVibrationPS5;                               // 0x01F7(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         KillerCameraSensitivity;                           // 0x01F8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SurvivorCameraSensitivity;                         // 0x01FC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         KillerMouseSensitivity;                            // 0x0200(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SurvivorMouseSensitivity;                          // 0x0204(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         KillerControllerSensitivity;                       // 0x0208(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SurvivorControllerSensitivity;                     // 0x020C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          AimAssist;                                         // 0x0210(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_211[0x3];                                      // 0x0211(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ControlType;                                       // 0x0214(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          InvertY;                                           // 0x0218(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          SurvivorInvertY;                                   // 0x0219(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          KillerToggleInteractions;                          // 0x021A(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          SurvivorToggleInteractions;                        // 0x021B(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          SprintToCancel;                                    // 0x021C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_21D[0x3];                                      // 0x021D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Language;                                          // 0x0220(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         VoiceOverLanguage;                                 // 0x0230(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          LanguageIsDefinedByPlayer;                         // 0x0234(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_235[0x3];                                      // 0x0235(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HighestWeightSeenNews;                             // 0x0238(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSharedAuthenticationTokenInformation  SharedLoginInformation;                            // 0x0240(0x0030)(Config, NativeAccessSpecifierPrivate)
	uint32                                        LastPanelContextId;                                // 0x0270(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          ArchivesAutoPlayVoiceOver;                         // 0x0274(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          ArchivesFullscreenTextVisibility;                  // 0x0275(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HasAcceptedCrossplayPopup;                         // 0x0276(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HasAcceptedProgressionSystemInfoPopup;             // 0x0277(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HasAcceptedHapticsVibrationPopup;                  // 0x0278(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          UseAtlantaCustomizedHuds;                          // 0x0279(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          UseAtlantaSurvivorQuickTurn;                       // 0x027A(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          UseAtlantaKillerQuickTurn;                         // 0x027B(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAtlantaCustomizedHudSettings>  AtlantaCustomizedHuds;                             // 0x0280(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ShowPortraitBorder;                                // 0x0298(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PartyPrivacyState;                                 // 0x02A0(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ColorBlindMode;                                    // 0x02B0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ColorBlindModeIntensity;                           // 0x02B4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          BeginnerMode;                                      // 0x02B8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          Subtitles;                                         // 0x02B9(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BA[0x2];                                      // 0x02BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SubtitlesBackgroundOpacity;                        // 0x02BC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SubtitlesSize;                                     // 0x02C0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsAnonymousMode;                                   // 0x02C4(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          AllowCopyrightedMusic;                             // 0x02C5(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HideYourName;                                      // 0x02C6(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HideOtherNames;                                    // 0x02C7(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HiddenMatchmakingDelay;                            // 0x02C8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C9[0x3];                                      // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayerCardAnimationMode;                           // 0x02CC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          AnimateRarityBackgrounds;                          // 0x02D0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D1[0x3];                                      // 0x02D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TomesChallengeNotification;                        // 0x02D4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         DailyChallengeNotification;                        // 0x02D8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         EventChallengeNotification;                        // 0x02DC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         BattlePassChallengeNotification;                   // 0x02E0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MilestoneChallengeNotification;                    // 0x02E4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         gamma;                                             // 0x02E8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2EC[0x22C];                                    // 0x02EC(0x022C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDBDGameUserSettings* GetDBDGameUserSettings();

	bool GetBloodwebInteractionBehaviour() const;
	EColorVisionDeficiency GetColorBlindMode() const;
	int32 GetColorBlindModeIntensity() const;
	bool GetDeepWoundBarVisibility() const;
	int32 GetFieldOfView() const;
	bool GetHUDKillerHookCountVisibility() const;
	bool GetHUDPlayerNamesVisibility() const;
	int32 GetHudScaleFactor() const;
	bool GetHUDScoreEventsVisibility() const;
	bool GetHUDUseItemPickupPopupAbridgedVersion() const;
	bool GetLargeText() const;
	bool GetLegacyPrestigePortraits() const;
	int32 GetMenuScaleFactor() const;
	int32 GetSkillCheckScaleFactor() const;
	bool GetTerrorRadiusVisualFeedback() const;
	EChallengeTrackerNotificationMode GetTomesChallengeNotification() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGameUserSettings">();
	}
	static class UDBDGameUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDGameUserSettings>();
	}
};
static_assert(alignof(UDBDGameUserSettings) == 0x000008, "Wrong alignment on UDBDGameUserSettings");
static_assert(sizeof(UDBDGameUserSettings) == 0x000518, "Wrong size on UDBDGameUserSettings");
static_assert(offsetof(UDBDGameUserSettings, ActionMappings) == 0x000150, "Member 'UDBDGameUserSettings::ActionMappings' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, AxisMappings) == 0x000160, "Member 'UDBDGameUserSettings::AxisMappings' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, OnSetCustomizedHudsTimestamp) == 0x000170, "Member 'UDBDGameUserSettings::OnSetCustomizedHudsTimestamp' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, DeviceLoginTokenID) == 0x000198, "Member 'UDBDGameUserSettings::DeviceLoginTokenID' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, ScalabilityLevel) == 0x0001A8, "Member 'UDBDGameUserSettings::ScalabilityLevel' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, AutoScalabilitySet) == 0x0001AC, "Member 'UDBDGameUserSettings::AutoScalabilitySet' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, AutoAdjust) == 0x0001AD, "Member 'UDBDGameUserSettings::AutoAdjust' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, ScreenRenderSize) == 0x0001B0, "Member 'UDBDGameUserSettings::ScreenRenderSize' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HUDConstrainedAspectRatio) == 0x0001B4, "Member 'UDBDGameUserSettings::HUDConstrainedAspectRatio' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, MenuScaleFactor) == 0x0001B8, "Member 'UDBDGameUserSettings::MenuScaleFactor' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HudScaleFactor) == 0x0001BC, "Member 'UDBDGameUserSettings::HudScaleFactor' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, SkillCheckScaleFactor) == 0x0001C0, "Member 'UDBDGameUserSettings::SkillCheckScaleFactor' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, LargeText) == 0x0001C4, "Member 'UDBDGameUserSettings::LargeText' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, BloodwebInteractionBehaviour) == 0x0001C5, "Member 'UDBDGameUserSettings::BloodwebInteractionBehaviour' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, TerrorRadiusVisualFeedback) == 0x0001C6, "Member 'UDBDGameUserSettings::TerrorRadiusVisualFeedback' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, DeepWoundBarVisibility) == 0x0001C7, "Member 'UDBDGameUserSettings::DeepWoundBarVisibility' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, FieldOfView) == 0x0001C8, "Member 'UDBDGameUserSettings::FieldOfView' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HUDPlayerNamesVisibility) == 0x0001CC, "Member 'UDBDGameUserSettings::HUDPlayerNamesVisibility' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HUDKillerHookCountVisibility) == 0x0001CD, "Member 'UDBDGameUserSettings::HUDKillerHookCountVisibility' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HUDScoreEventsVisibility) == 0x0001CE, "Member 'UDBDGameUserSettings::HUDScoreEventsVisibility' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HUDUseItemPickupPopupAbridgedVersion) == 0x0001CF, "Member 'UDBDGameUserSettings::HUDUseItemPickupPopupAbridgedVersion' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, LegacyPrestigePortraits) == 0x0001D0, "Member 'UDBDGameUserSettings::LegacyPrestigePortraits' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, ShowHudStatusEffectValueNumber) == 0x0001D1, "Member 'UDBDGameUserSettings::ShowHudStatusEffectValueNumber' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, FPSLimitMode) == 0x0001D4, "Member 'UDBDGameUserSettings::FPSLimitMode' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, AntiAliasingMode) == 0x0001D8, "Member 'UDBDGameUserSettings::AntiAliasingMode' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, EnableFSR) == 0x0001DC, "Member 'UDBDGameUserSettings::EnableFSR' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, SharpnessValue) == 0x0001E0, "Member 'UDBDGameUserSettings::SharpnessValue' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, XeSSMode) == 0x0001E4, "Member 'UDBDGameUserSettings::XeSSMode' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, MainVolume) == 0x0001E8, "Member 'UDBDGameUserSettings::MainVolume' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, MainVolumeOn) == 0x0001EC, "Member 'UDBDGameUserSettings::MainVolumeOn' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, MenuMusicVolume) == 0x0001F0, "Member 'UDBDGameUserSettings::MenuMusicVolume' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, MenuMusicVolumeOn) == 0x0001F4, "Member 'UDBDGameUserSettings::MenuMusicVolumeOn' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, UseHeadphones) == 0x0001F5, "Member 'UDBDGameUserSettings::UseHeadphones' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, MuteOnFocusLost) == 0x0001F6, "Member 'UDBDGameUserSettings::MuteOnFocusLost' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HapticsVibrationPS5) == 0x0001F7, "Member 'UDBDGameUserSettings::HapticsVibrationPS5' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, KillerCameraSensitivity) == 0x0001F8, "Member 'UDBDGameUserSettings::KillerCameraSensitivity' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, SurvivorCameraSensitivity) == 0x0001FC, "Member 'UDBDGameUserSettings::SurvivorCameraSensitivity' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, KillerMouseSensitivity) == 0x000200, "Member 'UDBDGameUserSettings::KillerMouseSensitivity' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, SurvivorMouseSensitivity) == 0x000204, "Member 'UDBDGameUserSettings::SurvivorMouseSensitivity' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, KillerControllerSensitivity) == 0x000208, "Member 'UDBDGameUserSettings::KillerControllerSensitivity' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, SurvivorControllerSensitivity) == 0x00020C, "Member 'UDBDGameUserSettings::SurvivorControllerSensitivity' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, AimAssist) == 0x000210, "Member 'UDBDGameUserSettings::AimAssist' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, ControlType) == 0x000214, "Member 'UDBDGameUserSettings::ControlType' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, InvertY) == 0x000218, "Member 'UDBDGameUserSettings::InvertY' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, SurvivorInvertY) == 0x000219, "Member 'UDBDGameUserSettings::SurvivorInvertY' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, KillerToggleInteractions) == 0x00021A, "Member 'UDBDGameUserSettings::KillerToggleInteractions' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, SurvivorToggleInteractions) == 0x00021B, "Member 'UDBDGameUserSettings::SurvivorToggleInteractions' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, SprintToCancel) == 0x00021C, "Member 'UDBDGameUserSettings::SprintToCancel' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, Language) == 0x000220, "Member 'UDBDGameUserSettings::Language' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, VoiceOverLanguage) == 0x000230, "Member 'UDBDGameUserSettings::VoiceOverLanguage' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, LanguageIsDefinedByPlayer) == 0x000234, "Member 'UDBDGameUserSettings::LanguageIsDefinedByPlayer' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HighestWeightSeenNews) == 0x000238, "Member 'UDBDGameUserSettings::HighestWeightSeenNews' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, SharedLoginInformation) == 0x000240, "Member 'UDBDGameUserSettings::SharedLoginInformation' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, LastPanelContextId) == 0x000270, "Member 'UDBDGameUserSettings::LastPanelContextId' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, ArchivesAutoPlayVoiceOver) == 0x000274, "Member 'UDBDGameUserSettings::ArchivesAutoPlayVoiceOver' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, ArchivesFullscreenTextVisibility) == 0x000275, "Member 'UDBDGameUserSettings::ArchivesFullscreenTextVisibility' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HasAcceptedCrossplayPopup) == 0x000276, "Member 'UDBDGameUserSettings::HasAcceptedCrossplayPopup' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HasAcceptedProgressionSystemInfoPopup) == 0x000277, "Member 'UDBDGameUserSettings::HasAcceptedProgressionSystemInfoPopup' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HasAcceptedHapticsVibrationPopup) == 0x000278, "Member 'UDBDGameUserSettings::HasAcceptedHapticsVibrationPopup' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, UseAtlantaCustomizedHuds) == 0x000279, "Member 'UDBDGameUserSettings::UseAtlantaCustomizedHuds' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, UseAtlantaSurvivorQuickTurn) == 0x00027A, "Member 'UDBDGameUserSettings::UseAtlantaSurvivorQuickTurn' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, UseAtlantaKillerQuickTurn) == 0x00027B, "Member 'UDBDGameUserSettings::UseAtlantaKillerQuickTurn' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, AtlantaCustomizedHuds) == 0x000280, "Member 'UDBDGameUserSettings::AtlantaCustomizedHuds' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, ShowPortraitBorder) == 0x000298, "Member 'UDBDGameUserSettings::ShowPortraitBorder' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, PartyPrivacyState) == 0x0002A0, "Member 'UDBDGameUserSettings::PartyPrivacyState' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, ColorBlindMode) == 0x0002B0, "Member 'UDBDGameUserSettings::ColorBlindMode' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, ColorBlindModeIntensity) == 0x0002B4, "Member 'UDBDGameUserSettings::ColorBlindModeIntensity' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, BeginnerMode) == 0x0002B8, "Member 'UDBDGameUserSettings::BeginnerMode' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, Subtitles) == 0x0002B9, "Member 'UDBDGameUserSettings::Subtitles' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, SubtitlesBackgroundOpacity) == 0x0002BC, "Member 'UDBDGameUserSettings::SubtitlesBackgroundOpacity' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, SubtitlesSize) == 0x0002C0, "Member 'UDBDGameUserSettings::SubtitlesSize' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, IsAnonymousMode) == 0x0002C4, "Member 'UDBDGameUserSettings::IsAnonymousMode' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, AllowCopyrightedMusic) == 0x0002C5, "Member 'UDBDGameUserSettings::AllowCopyrightedMusic' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HideYourName) == 0x0002C6, "Member 'UDBDGameUserSettings::HideYourName' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HideOtherNames) == 0x0002C7, "Member 'UDBDGameUserSettings::HideOtherNames' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HiddenMatchmakingDelay) == 0x0002C8, "Member 'UDBDGameUserSettings::HiddenMatchmakingDelay' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, PlayerCardAnimationMode) == 0x0002CC, "Member 'UDBDGameUserSettings::PlayerCardAnimationMode' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, AnimateRarityBackgrounds) == 0x0002D0, "Member 'UDBDGameUserSettings::AnimateRarityBackgrounds' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, TomesChallengeNotification) == 0x0002D4, "Member 'UDBDGameUserSettings::TomesChallengeNotification' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, DailyChallengeNotification) == 0x0002D8, "Member 'UDBDGameUserSettings::DailyChallengeNotification' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, EventChallengeNotification) == 0x0002DC, "Member 'UDBDGameUserSettings::EventChallengeNotification' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, BattlePassChallengeNotification) == 0x0002E0, "Member 'UDBDGameUserSettings::BattlePassChallengeNotification' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, MilestoneChallengeNotification) == 0x0002E4, "Member 'UDBDGameUserSettings::MilestoneChallengeNotification' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, gamma) == 0x0002E8, "Member 'UDBDGameUserSettings::gamma' has a wrong offset!");

// Class DeadByDaylight.CharacterTool
// 0x0158 (0x03F8 - 0x02A0)
class ACharacterTool : public ADBDEditorActor
{
public:
	TArray<class ATargetPoint*>                   spawnLocations;                                    // 0x02A0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FCharacterToolData                     _customizationData;                                // 0x02B0(0x0080)(Edit, NativeAccessSpecifierPrivate)
	struct FCharacterToolSpawnParameters          _defaultSpawnParams;                               // 0x0330(0x0003)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_333[0x1];                                      // 0x0333(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _powerSocket;                                      // 0x0334(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAttachmentRule                               _powerAttachmentRule;                              // 0x0340(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _muteAudioInPIE;                                   // 0x0341(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isUsingGameSkeleton;                              // 0x0342(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_343[0x5];                                      // 0x0343(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   _overallLightingClass;                             // 0x0348(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FNamedButton                           _showHelp;                                         // 0x0380(0x0018)(Edit, Transient, NativeAccessSpecifierPrivate)
	TMap<class ADBDMenuPlayer*, struct FCharacterToolSpawnParameters> _characters;                   // 0x0398(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class AActor*                                 _lighting;                                         // 0x03E8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F0[0x8];                                      // 0x03F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterTool">();
	}
	static class ACharacterTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharacterTool>();
	}
};
static_assert(alignof(ACharacterTool) == 0x000008, "Wrong alignment on ACharacterTool");
static_assert(sizeof(ACharacterTool) == 0x0003F8, "Wrong size on ACharacterTool");
static_assert(offsetof(ACharacterTool, spawnLocations) == 0x0002A0, "Member 'ACharacterTool::spawnLocations' has a wrong offset!");
static_assert(offsetof(ACharacterTool, _customizationData) == 0x0002B0, "Member 'ACharacterTool::_customizationData' has a wrong offset!");
static_assert(offsetof(ACharacterTool, _defaultSpawnParams) == 0x000330, "Member 'ACharacterTool::_defaultSpawnParams' has a wrong offset!");
static_assert(offsetof(ACharacterTool, _powerSocket) == 0x000334, "Member 'ACharacterTool::_powerSocket' has a wrong offset!");
static_assert(offsetof(ACharacterTool, _powerAttachmentRule) == 0x000340, "Member 'ACharacterTool::_powerAttachmentRule' has a wrong offset!");
static_assert(offsetof(ACharacterTool, _muteAudioInPIE) == 0x000341, "Member 'ACharacterTool::_muteAudioInPIE' has a wrong offset!");
static_assert(offsetof(ACharacterTool, _isUsingGameSkeleton) == 0x000342, "Member 'ACharacterTool::_isUsingGameSkeleton' has a wrong offset!");
static_assert(offsetof(ACharacterTool, _overallLightingClass) == 0x000348, "Member 'ACharacterTool::_overallLightingClass' has a wrong offset!");
static_assert(offsetof(ACharacterTool, _showHelp) == 0x000380, "Member 'ACharacterTool::_showHelp' has a wrong offset!");
static_assert(offsetof(ACharacterTool, _characters) == 0x000398, "Member 'ACharacterTool::_characters' has a wrong offset!");
static_assert(offsetof(ACharacterTool, _lighting) == 0x0003E8, "Member 'ACharacterTool::_lighting' has a wrong offset!");

// Class DeadByDaylight.CharacterToolAnimation
// 0x0010 (0x0360 - 0x0350)
class UCharacterToolAnimation final : public UAnimInstance
{
public:
	TArray<struct FCharacterToolItemData>         SelectedItems;                                     // 0x0350(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterToolAnimation">();
	}
	static class UCharacterToolAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterToolAnimation>();
	}
};
static_assert(alignof(UCharacterToolAnimation) == 0x000010, "Wrong alignment on UCharacterToolAnimation");
static_assert(sizeof(UCharacterToolAnimation) == 0x000360, "Wrong size on UCharacterToolAnimation");
static_assert(offsetof(UCharacterToolAnimation, SelectedItems) == 0x000350, "Member 'UCharacterToolAnimation::SelectedItems' has a wrong offset!");

// Class DeadByDaylight.EventSpawnableComponent
// 0x0050 (0x0320 - 0x02D0)
class UEventSpawnableComponent final : public USceneComponent
{
public:
	TArray<struct FEventSpawnablePositionDropdown> SpawnPositionPreferences;                         // 0x02D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                Bound;                                             // 0x02E0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BudgetOverride;                                    // 0x02F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          _boundBox;                                         // 0x0300(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_308[0x18];                                     // 0x0308(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventSpawnableComponent">();
	}
	static class UEventSpawnableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventSpawnableComponent>();
	}
};
static_assert(alignof(UEventSpawnableComponent) == 0x000010, "Wrong alignment on UEventSpawnableComponent");
static_assert(sizeof(UEventSpawnableComponent) == 0x000320, "Wrong size on UEventSpawnableComponent");
static_assert(offsetof(UEventSpawnableComponent, SpawnPositionPreferences) == 0x0002D0, "Member 'UEventSpawnableComponent::SpawnPositionPreferences' has a wrong offset!");
static_assert(offsetof(UEventSpawnableComponent, Bound) == 0x0002E0, "Member 'UEventSpawnableComponent::Bound' has a wrong offset!");
static_assert(offsetof(UEventSpawnableComponent, BudgetOverride) == 0x0002F8, "Member 'UEventSpawnableComponent::BudgetOverride' has a wrong offset!");
static_assert(offsetof(UEventSpawnableComponent, _boundBox) == 0x000300, "Member 'UEventSpawnableComponent::_boundBox' has a wrong offset!");

// Class DeadByDaylight.DBDGameAnalyticsComponent
// 0x0010 (0x00C8 - 0x00B8)
class UDBDGameAnalyticsComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGameAnalyticsComponent">();
	}
	static class UDBDGameAnalyticsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDGameAnalyticsComponent>();
	}
};
static_assert(alignof(UDBDGameAnalyticsComponent) == 0x000008, "Wrong alignment on UDBDGameAnalyticsComponent");
static_assert(sizeof(UDBDGameAnalyticsComponent) == 0x0000C8, "Wrong size on UDBDGameAnalyticsComponent");

// Class DeadByDaylight.TutorialsUtilities
// 0x0038 (0x02D8 - 0x02A0)
class ATutorialsUtilities final : public AActor
{
public:
	TMulticastInlineDelegate<void()>              OnTutorialUIReady;                                 // 0x02A0(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0[0x28];                                     // 0x02B0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void DestroyAI(class AAIController* AIController);
	static class ATutorialsUtilities* GetTutorialsUtilities(class UObject* WorldContextObject);

	void TriggerTutorialHudFadeIn();
	void TriggerTutorialHudFadeOut();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialsUtilities">();
	}
	static class ATutorialsUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATutorialsUtilities>();
	}
};
static_assert(alignof(ATutorialsUtilities) == 0x000008, "Wrong alignment on ATutorialsUtilities");
static_assert(sizeof(ATutorialsUtilities) == 0x0002D8, "Wrong size on ATutorialsUtilities");
static_assert(offsetof(ATutorialsUtilities, OnTutorialUIReady) == 0x0002A0, "Member 'ATutorialsUtilities::OnTutorialUIReady' has a wrong offset!");

// Class DeadByDaylight.CharacterUtilities
// 0x0000 (0x0030 - 0x0030)
class UCharacterUtilities final : public UBlueprintFunctionLibrary
{
public:
	static struct FVector GetActorLocationFromFeetLocation(const class ACharacter* Character, const struct FVector& feetLocation);
	static struct FVector GetFeetPosition(const class ACharacter* Character);
	static struct FVector GetFeetPositionAtTargetLocation(const class ACharacter* Character, const struct FVector& Location);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterUtilities">();
	}
	static class UCharacterUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterUtilities>();
	}
};
static_assert(alignof(UCharacterUtilities) == 0x000008, "Wrong alignment on UCharacterUtilities");
static_assert(sizeof(UCharacterUtilities) == 0x000030, "Wrong size on UCharacterUtilities");

// Class DeadByDaylight.ChargeableComponent
// 0x0270 (0x0328 - 0x00B8)
class UChargeableComponent : public UActorComponent
{
public:
	TMulticastInlineDelegate<void()>              OnInteractionEmptiedEvent;                         // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x18];                                      // 0x00C8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool COMPLETED, const TArray<class AActor*>& instigatorsForCompletion)> OnInteractionCompletionStateChanged; // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0x18];                                      // 0x00F0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool Success, bool Bonus, class ADBDPlayer* Player, bool TriggerLoudNoise, bool hadInput, ESkillCheckCustomType Type, float ChargeChange)> SkillCheckResponseAestheticDelegate; // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool Success, bool Bonus, class ADBDPlayer* Player, bool TriggerLoudNoise, bool hadInput, ESkillCheckCustomType Type, float ChargeChange)> SkillCheckResponseAuthorityDelegate; // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float IndividualChargeAmount, float TotalChargeAmount, class AActor* ChargeInstigator, bool WasCoop, float DeltaTime)> ChargeAppliedAuthorityDelegate; // 0x0128(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UChargeableComponent* ChargeableComponent, float PercentCompletionChange, float TotalPercentComplete)> ChargeableCompletionPercentChangeAuthorityDelegate; // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UChargeableComponent* ChargeableComponent, float TotalPercentComplete)> ChargeableCompletionPercentChangeCosmeticDelegate; // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UChargeableComponent* ChargeableComponent)> DechargeBeginDelegate; // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UChargeableComponent* ChargeableComponent)> DechargeEndDelegate; // 0x0168(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          AllowSkillChecksAtFullCharge;                      // 0x0178(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_179[0x7];                                      // 0x0179(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ChargeableComponentID;                             // 0x0180(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DechargeDelay;                                     // 0x0190(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartingChargePercent;                             // 0x0194(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSpeedBasedNetSyncedValue              _currentCharge;                                    // 0x0198(0x0038)(Net, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D0[0x10];                                     // 0x01D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTimer                              _skillCheckFailurePenaltyTimer;                    // 0x01E0(0x0028)(Transient, NativeAccessSpecifierPrivate)
	struct FDBDTimer                              _dechargeTimer;                                    // 0x0208(0x0028)(Transient, NativeAccessSpecifierPrivate)
	TArray<struct FChargeData>                    _chargesThisFrame;                                 // 0x0230(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FChargeData>                    _redirectedChargesThisFrame;                       // 0x0240(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<uint32, class UChargeStrategy*>          _activeChargeStrategies;                           // 0x0250(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         _instigatorsSinceEmpty;                            // 0x02A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, float>                      _tunableValueMap;                                  // 0x02B0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	bool                                          _isCharging;                                       // 0x0300(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_301[0x7];                                      // 0x0301(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 _playersWhoDidSkillCheck;                          // 0x0308(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	bool                                          _isChargeBlocked;                                  // 0x0318(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_319[0x3];                                      // 0x0319(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _dechargeRate;                                     // 0x031C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _enableAddCharge;                                  // 0x0320(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _enableSkillCheckFailurePenalty;                   // 0x0321(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isDecharging;                                     // 0x0322(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _stopDechargingWhenComplete;                       // 0x0323(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_AddCharge(float ChargeAmount, class AActor* Instigator, bool BypassSkillCheckFail, bool IsOneTimeIncrease, bool isChargeWithItem);
	void Authority_AddChargePercent(float ChargePercent, class AActor* Instigator, bool BypassSkillCheckFail, bool IsOneTimeIncrease, bool isChargeWithItem);
	void Authority_ApplyStartingCharge();
	void Authority_Reset();
	void Authority_SetEnableAddCharge(const bool Enable);
	void Authority_SetEnableSkillCheckFailurePenalty(const bool Enable);
	void IncreaseMaxCharge(float Percent);
	void Multicast_SetPermanentCharge(float ChargePercent);
	void OnCurrentChargeChanged(float Value);
	void OnRep_CurrentCharge();
	void SetDechargeRate(float dechargeRate);
	void SetSecondsToCharge(float SecondsToCharge);

	float GetChargeRemaining() const;
	float GetChargingSpeed() const;
	float GetCurrentCharge() const;
	float GetMaxCharge() const;
	float GetPercentComplete() const;
	float GetPermanentChargePercent() const;
	float GetPlayerCountPenaltyModifier(int32 PlayerCount) const;
	float GetTunableValue(class FName tunableValueID) const;
	bool HasPlayerDoneSkillCheck(int32 PlayerId) const;
	bool IsChargeComplete() const;
	bool IsSkillCheckTimePenaltyActive() const;
	void Multicast_OnCompleteChanged(bool COMPLETED) const;
	void Multicast_OnEmptied() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChargeableComponent">();
	}
	static class UChargeableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChargeableComponent>();
	}
};
static_assert(alignof(UChargeableComponent) == 0x000008, "Wrong alignment on UChargeableComponent");
static_assert(sizeof(UChargeableComponent) == 0x000328, "Wrong size on UChargeableComponent");
static_assert(offsetof(UChargeableComponent, OnInteractionEmptiedEvent) == 0x0000B8, "Member 'UChargeableComponent::OnInteractionEmptiedEvent' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, OnInteractionCompletionStateChanged) == 0x0000E0, "Member 'UChargeableComponent::OnInteractionCompletionStateChanged' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, SkillCheckResponseAestheticDelegate) == 0x000108, "Member 'UChargeableComponent::SkillCheckResponseAestheticDelegate' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, SkillCheckResponseAuthorityDelegate) == 0x000118, "Member 'UChargeableComponent::SkillCheckResponseAuthorityDelegate' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, ChargeAppliedAuthorityDelegate) == 0x000128, "Member 'UChargeableComponent::ChargeAppliedAuthorityDelegate' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, ChargeableCompletionPercentChangeAuthorityDelegate) == 0x000138, "Member 'UChargeableComponent::ChargeableCompletionPercentChangeAuthorityDelegate' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, ChargeableCompletionPercentChangeCosmeticDelegate) == 0x000148, "Member 'UChargeableComponent::ChargeableCompletionPercentChangeCosmeticDelegate' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, DechargeBeginDelegate) == 0x000158, "Member 'UChargeableComponent::DechargeBeginDelegate' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, DechargeEndDelegate) == 0x000168, "Member 'UChargeableComponent::DechargeEndDelegate' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, AllowSkillChecksAtFullCharge) == 0x000178, "Member 'UChargeableComponent::AllowSkillChecksAtFullCharge' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, ChargeableComponentID) == 0x000180, "Member 'UChargeableComponent::ChargeableComponentID' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, DechargeDelay) == 0x000190, "Member 'UChargeableComponent::DechargeDelay' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, StartingChargePercent) == 0x000194, "Member 'UChargeableComponent::StartingChargePercent' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _currentCharge) == 0x000198, "Member 'UChargeableComponent::_currentCharge' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _skillCheckFailurePenaltyTimer) == 0x0001E0, "Member 'UChargeableComponent::_skillCheckFailurePenaltyTimer' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _dechargeTimer) == 0x000208, "Member 'UChargeableComponent::_dechargeTimer' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _chargesThisFrame) == 0x000230, "Member 'UChargeableComponent::_chargesThisFrame' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _redirectedChargesThisFrame) == 0x000240, "Member 'UChargeableComponent::_redirectedChargesThisFrame' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _activeChargeStrategies) == 0x000250, "Member 'UChargeableComponent::_activeChargeStrategies' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _instigatorsSinceEmpty) == 0x0002A0, "Member 'UChargeableComponent::_instigatorsSinceEmpty' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _tunableValueMap) == 0x0002B0, "Member 'UChargeableComponent::_tunableValueMap' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _isCharging) == 0x000300, "Member 'UChargeableComponent::_isCharging' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _playersWhoDidSkillCheck) == 0x000308, "Member 'UChargeableComponent::_playersWhoDidSkillCheck' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _isChargeBlocked) == 0x000318, "Member 'UChargeableComponent::_isChargeBlocked' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _dechargeRate) == 0x00031C, "Member 'UChargeableComponent::_dechargeRate' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _enableAddCharge) == 0x000320, "Member 'UChargeableComponent::_enableAddCharge' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _enableSkillCheckFailurePenalty) == 0x000321, "Member 'UChargeableComponent::_enableSkillCheckFailurePenalty' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _isDecharging) == 0x000322, "Member 'UChargeableComponent::_isDecharging' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _stopDechargingWhenComplete) == 0x000323, "Member 'UChargeableComponent::_stopDechargingWhenComplete' has a wrong offset!");

// Class DeadByDaylight.ChargeableProgressProviderComponent
// 0x0010 (0x00C8 - 0x00B8)
class UChargeableProgressProviderComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChargeableProgressProviderComponent">();
	}
	static class UChargeableProgressProviderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChargeableProgressProviderComponent>();
	}
};
static_assert(alignof(UChargeableProgressProviderComponent) == 0x000008, "Wrong alignment on UChargeableProgressProviderComponent");
static_assert(sizeof(UChargeableProgressProviderComponent) == 0x0000C8, "Wrong size on UChargeableProgressProviderComponent");

// Class DeadByDaylight.ChargedAttackStateComponent
// 0x0008 (0x00C0 - 0x00B8)
class UChargedAttackStateComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetChargingPercent(float ChargePercent);
	void SetIsCharging(bool IsCharging);

	float GetChargingPercent() const;
	bool GetIsCharging() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChargedAttackStateComponent">();
	}
	static class UChargedAttackStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChargedAttackStateComponent>();
	}
};
static_assert(alignof(UChargedAttackStateComponent) == 0x000008, "Wrong alignment on UChargedAttackStateComponent");
static_assert(sizeof(UChargedAttackStateComponent) == 0x0000C0, "Wrong size on UChargedAttackStateComponent");

// Class DeadByDaylight.Charm
// 0x0048 (0x02E8 - 0x02A0)
class ACharm final : public AActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDSkeletalMeshComponentBudgeted*      _skeletalMeshComponent;                            // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B0[0x18];                                     // 0x02B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AItemVfx*                               _actorVfx;                                         // 0x02C8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D0[0x18];                                     // 0x02D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginDestroySequence_Internal();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Charm">();
	}
	static class ACharm* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharm>();
	}
};
static_assert(alignof(ACharm) == 0x000008, "Wrong alignment on ACharm");
static_assert(sizeof(ACharm) == 0x0002E8, "Wrong size on ACharm");
static_assert(offsetof(ACharm, _skeletalMeshComponent) == 0x0002A8, "Member 'ACharm::_skeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(ACharm, _actorVfx) == 0x0002C8, "Member 'ACharm::_actorVfx' has a wrong offset!");

// Class DeadByDaylight.TileSpawnPoint
// 0x00A0 (0x0370 - 0x02D0)
#pragma pack(push, 0x1)
class alignas(0x10) UTileSpawnPoint : public USceneComponent
{
public:
	uint8                                         Pad_2D0[0x10];                                     // 0x02D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	ETileSpawnPointType                           TileSpawnPointType;                                // 0x02E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E1[0x7];                                      // 0x02E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        Weight;                                            // 0x02E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   Visualization;                                     // 0x02F0(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_328[0x20];                                     // 0x0328(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _spawnedObject;                                    // 0x0348(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftClassPtr<class UClass>>           ObjectSpawnModifier;                               // 0x0350(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	int32                                         _spawnPriorityTier;                                // 0x0360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _weightInfluenceable;                              // 0x0364(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _weightInfluencer;                                 // 0x0365(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _activated;                                        // 0x0366(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_367[0x1];                                      // 0x0367(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_SpawnObject();
	void SetActivated(bool activated);

	class AActor* GetSpawnedObject() const;
	bool IsActivated() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TileSpawnPoint">();
	}
	static class UTileSpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTileSpawnPoint>();
	}
};
#pragma pack(pop)
static_assert(alignof(UTileSpawnPoint) == 0x000010, "Wrong alignment on UTileSpawnPoint");
static_assert(sizeof(UTileSpawnPoint) == 0x000370, "Wrong size on UTileSpawnPoint");
static_assert(offsetof(UTileSpawnPoint, TileSpawnPointType) == 0x0002E0, "Member 'UTileSpawnPoint::TileSpawnPointType' has a wrong offset!");
static_assert(offsetof(UTileSpawnPoint, Weight) == 0x0002E8, "Member 'UTileSpawnPoint::Weight' has a wrong offset!");
static_assert(offsetof(UTileSpawnPoint, Visualization) == 0x0002F0, "Member 'UTileSpawnPoint::Visualization' has a wrong offset!");
static_assert(offsetof(UTileSpawnPoint, _spawnedObject) == 0x000348, "Member 'UTileSpawnPoint::_spawnedObject' has a wrong offset!");
static_assert(offsetof(UTileSpawnPoint, ObjectSpawnModifier) == 0x000350, "Member 'UTileSpawnPoint::ObjectSpawnModifier' has a wrong offset!");
static_assert(offsetof(UTileSpawnPoint, _spawnPriorityTier) == 0x000360, "Member 'UTileSpawnPoint::_spawnPriorityTier' has a wrong offset!");
static_assert(offsetof(UTileSpawnPoint, _weightInfluenceable) == 0x000364, "Member 'UTileSpawnPoint::_weightInfluenceable' has a wrong offset!");
static_assert(offsetof(UTileSpawnPoint, _weightInfluencer) == 0x000365, "Member 'UTileSpawnPoint::_weightInfluencer' has a wrong offset!");
static_assert(offsetof(UTileSpawnPoint, _activated) == 0x000366, "Member 'UTileSpawnPoint::_activated' has a wrong offset!");

// Class DeadByDaylight.SearchableSpawnPoint
// 0x0000 (0x0370 - 0x0370)
class USearchableSpawnPoint final : public UTileSpawnPoint
{
public:
	TSubclassOf<class AActor>                     ActorToSpawn;                                      // 0x0368(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SearchableSpawnPoint">();
	}
	static class USearchableSpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<USearchableSpawnPoint>();
	}
};
static_assert(alignof(USearchableSpawnPoint) == 0x000010, "Wrong alignment on USearchableSpawnPoint");
static_assert(sizeof(USearchableSpawnPoint) == 0x000370, "Wrong size on USearchableSpawnPoint");
static_assert(offsetof(USearchableSpawnPoint, ActorToSpawn) == 0x000368, "Member 'USearchableSpawnPoint::ActorToSpawn' has a wrong offset!");

// Class DeadByDaylight.CharmAttachable
// 0x0000 (0x0000 - 0x0000)
class ICharmAttachable final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharmAttachable">();
	}
	static class ICharmAttachable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICharmAttachable>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ICharmAttachable) == 0x000001, "Wrong alignment on ICharmAttachable");
static_assert(sizeof(ICharmAttachable) == 0x000001, "Wrong size on ICharmAttachable");

// Class DeadByDaylight.DBDInstancedFoliageComponent
// 0x0068 (0x0120 - 0x00B8)
class UDBDInstancedFoliageComponent final : public UActorComponent
{
public:
	int32                                         NextBaseId;                                        // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class USceneComponent*>           InstanceBaseMap;                                   // 0x00C0(0x0050)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FDBDFoliageInfo>                Foliage;                                           // 0x0110(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDInstancedFoliageComponent">();
	}
	static class UDBDInstancedFoliageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDInstancedFoliageComponent>();
	}
};
static_assert(alignof(UDBDInstancedFoliageComponent) == 0x000008, "Wrong alignment on UDBDInstancedFoliageComponent");
static_assert(sizeof(UDBDInstancedFoliageComponent) == 0x000120, "Wrong size on UDBDInstancedFoliageComponent");
static_assert(offsetof(UDBDInstancedFoliageComponent, NextBaseId) == 0x0000B8, "Member 'UDBDInstancedFoliageComponent::NextBaseId' has a wrong offset!");
static_assert(offsetof(UDBDInstancedFoliageComponent, InstanceBaseMap) == 0x0000C0, "Member 'UDBDInstancedFoliageComponent::InstanceBaseMap' has a wrong offset!");
static_assert(offsetof(UDBDInstancedFoliageComponent, Foliage) == 0x000110, "Member 'UDBDInstancedFoliageComponent::Foliage' has a wrong offset!");

// Class DeadByDaylight.CharmAttacher
// 0x0040 (0x02E0 - 0x02A0)
class ACharmAttacher final : public AActor
{
public:
	TMulticastInlineDelegate<void()>              OnAttachedOnActor;                                 // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCharmAnimationTagsChanged;                       // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UDBDSkeletalMeshComponentBudgeted*      _chain;                                            // 0x02C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACharm*                                 _attachedCharm;                                    // 0x02C8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _charmAttachSocketName;                            // 0x02D0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindOnCharmAnimationTagsChanged();
	void DispatchOnCharmAnimationTagsChanged();
	class AActor* GetActorAttachedOn();
	struct FCharmAttacherAnimationTweak GetAnimationTweak();
	class ACharm* GetAttachedCharm();
	class USkeletalMeshComponent* GetSkeletalMeshComponentAttachedOn();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharmAttacher">();
	}
	static class ACharmAttacher* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharmAttacher>();
	}
};
static_assert(alignof(ACharmAttacher) == 0x000008, "Wrong alignment on ACharmAttacher");
static_assert(sizeof(ACharmAttacher) == 0x0002E0, "Wrong size on ACharmAttacher");
static_assert(offsetof(ACharmAttacher, OnAttachedOnActor) == 0x0002A0, "Member 'ACharmAttacher::OnAttachedOnActor' has a wrong offset!");
static_assert(offsetof(ACharmAttacher, OnCharmAnimationTagsChanged) == 0x0002B0, "Member 'ACharmAttacher::OnCharmAnimationTagsChanged' has a wrong offset!");
static_assert(offsetof(ACharmAttacher, _chain) == 0x0002C0, "Member 'ACharmAttacher::_chain' has a wrong offset!");
static_assert(offsetof(ACharmAttacher, _attachedCharm) == 0x0002C8, "Member 'ACharmAttacher::_attachedCharm' has a wrong offset!");
static_assert(offsetof(ACharmAttacher, _charmAttachSocketName) == 0x0002D0, "Member 'ACharmAttacher::_charmAttachSocketName' has a wrong offset!");

// Class DeadByDaylight.SkillData
// 0x0028 (0x0060 - 0x0038)
class USkillData final : public UDataAsset
{
public:
	TArray<TSubclassOf<class USkill>>             Skills;                                            // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          IsInnateSkill;                                     // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDBDTunableRowHandleOverride>   TunableOverrides;                                  // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillData">();
	}
	static class USkillData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillData>();
	}
};
static_assert(alignof(USkillData) == 0x000008, "Wrong alignment on USkillData");
static_assert(sizeof(USkillData) == 0x000060, "Wrong size on USkillData");
static_assert(offsetof(USkillData, Skills) == 0x000038, "Member 'USkillData::Skills' has a wrong offset!");
static_assert(offsetof(USkillData, IsInnateSkill) == 0x000048, "Member 'USkillData::IsInnateSkill' has a wrong offset!");
static_assert(offsetof(USkillData, TunableOverrides) == 0x000050, "Member 'USkillData::TunableOverrides' has a wrong offset!");

// Class DeadByDaylight.CharmSpawnerComponent
// 0x0040 (0x00F8 - 0x00B8)
class UCharmSpawnerComponent final : public UActorComponent
{
public:
	class FName                                   SocketRootName;                                    // 0x00B8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCharmSlot>                     CharmSlots;                                        // 0x00C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                ScaleCharm;                                        // 0x00D8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _forcedLOD;                                        // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReplaceCharmTextures(const TArray<struct FCharmIdSlot>& Customization);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharmSpawnerComponent">();
	}
	static class UCharmSpawnerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharmSpawnerComponent>();
	}
};
static_assert(alignof(UCharmSpawnerComponent) == 0x000008, "Wrong alignment on UCharmSpawnerComponent");
static_assert(sizeof(UCharmSpawnerComponent) == 0x0000F8, "Wrong size on UCharmSpawnerComponent");
static_assert(offsetof(UCharmSpawnerComponent, SocketRootName) == 0x0000B8, "Member 'UCharmSpawnerComponent::SocketRootName' has a wrong offset!");
static_assert(offsetof(UCharmSpawnerComponent, CharmSlots) == 0x0000C8, "Member 'UCharmSpawnerComponent::CharmSlots' has a wrong offset!");
static_assert(offsetof(UCharmSpawnerComponent, ScaleCharm) == 0x0000D8, "Member 'UCharmSpawnerComponent::ScaleCharm' has a wrong offset!");
static_assert(offsetof(UCharmSpawnerComponent, _forcedLOD) == 0x0000F0, "Member 'UCharmSpawnerComponent::_forcedLOD' has a wrong offset!");

// Class DeadByDaylight.ChaseeCharacterComponent
// 0x0068 (0x01A8 - 0x0140)
class UChaseeCharacterComponent final : public UChaseComponent
{
public:
	uint8                                         Pad_140[0x8];                                      // 0x0140(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _totalChaseTimeThisMatchDebugReplicated;           // 0x0148(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14C[0x5C];                                     // 0x014C(0x005C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnGeneratorPercentChanged(class UChargeableComponent* ChargeableComponent, float PercentCompletionChange, float TotalPercentComplete);
	void Authority_OnInvocationPercentChanged(class UChargeableComponent* ChargeableComponent, float PercentCompletionChange, float TotalPercentComplete);
	void Authority_OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChaseeCharacterComponent">();
	}
	static class UChaseeCharacterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChaseeCharacterComponent>();
	}
};
static_assert(alignof(UChaseeCharacterComponent) == 0x000008, "Wrong alignment on UChaseeCharacterComponent");
static_assert(sizeof(UChaseeCharacterComponent) == 0x0001A8, "Wrong size on UChaseeCharacterComponent");
static_assert(offsetof(UChaseeCharacterComponent, _totalChaseTimeThisMatchDebugReplicated) == 0x000148, "Member 'UChaseeCharacterComponent::_totalChaseTimeThisMatchDebugReplicated' has a wrong offset!");

// Class DeadByDaylight.ChatManager
// 0x0040 (0x02E0 - 0x02A0)
class AChatManager final : public AActor
{
public:
	class UDBDGameInstance*                       _gameInstance;                                     // 0x02A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A8[0x18];                                     // 0x02A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FChatHistory                           _chatHistory;                                      // 0x02C0(0x0020)(Net, NativeAccessSpecifierPrivate)

public:
	void Multicast_DisplayMessage(const class FString& chatIdentifier, int32 PlayerIndex, const class FString& MirrorsId, const class FString& Msg);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChatManager">();
	}
	static class AChatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChatManager>();
	}
};
static_assert(alignof(AChatManager) == 0x000008, "Wrong alignment on AChatManager");
static_assert(sizeof(AChatManager) == 0x0002E0, "Wrong size on AChatManager");
static_assert(offsetof(AChatManager, _gameInstance) == 0x0002A0, "Member 'AChatManager::_gameInstance' has a wrong offset!");
static_assert(offsetof(AChatManager, _chatHistory) == 0x0002C0, "Member 'AChatManager::_chatHistory' has a wrong offset!");

// Class DeadByDaylight.DBDBloodWebDefinition
// 0x0110 (0x0140 - 0x0030)
class UDBDBloodWebDefinition final : public UObject
{
public:
	uint8                                         Pad_30[0x110];                                     // 0x0030(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBloodWebDefinition">();
	}
	static class UDBDBloodWebDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDBloodWebDefinition>();
	}
};
static_assert(alignof(UDBDBloodWebDefinition) == 0x000008, "Wrong alignment on UDBDBloodWebDefinition");
static_assert(sizeof(UDBDBloodWebDefinition) == 0x000140, "Wrong size on UDBDBloodWebDefinition");

// Class DeadByDaylight.ChatMastermindSubsystem
// 0x0120 (0x0158 - 0x0038)
class UChatMastermindSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x120];                                     // 0x0038(0x0120)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChatMastermindSubsystem">();
	}
	static class UChatMastermindSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChatMastermindSubsystem>();
	}
};
static_assert(alignof(UChatMastermindSubsystem) == 0x000008, "Wrong alignment on UChatMastermindSubsystem");
static_assert(sizeof(UChatMastermindSubsystem) == 0x000158, "Wrong size on UChatMastermindSubsystem");

// Class DeadByDaylight.ChatSimulator
// 0x0030 (0x0060 - 0x0030)
class UChatSimulator final : public UObject
{
public:
	uint8                                         Pad_30[0x30];                                      // 0x0030(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChatSimulator">();
	}
	static class UChatSimulator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChatSimulator>();
	}
};
static_assert(alignof(UChatSimulator) == 0x000008, "Wrong alignment on UChatSimulator");
static_assert(sizeof(UChatSimulator) == 0x000060, "Wrong size on UChatSimulator");

// Class DeadByDaylight.ProceduralLevelData
// 0x03C0 (0x0660 - 0x02A0)
class AProceduralLevelData final : public AActor
{
public:
	TSoftObjectPtr<class UPaperTileMap>           SelectedPaperMap;                                  // 0x02A0(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GenerationSeed;                                    // 0x02D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameType                                     gameType;                                          // 0x02DC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DD[0x3];                                      // 0x02DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SpecialEventId;                                    // 0x02E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGeneratedLevelData                    GeneratedData;                                     // 0x02F0(0x0330)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class FName>                           offerings;                                         // 0x0620(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         PerksLevel;                                        // 0x0630(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_634[0x4];                                      // 0x0634(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Perks;                                             // 0x0638(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          SkipGameplayElementGeneration;                     // 0x0648(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_649[0x7];                                      // 0x0649(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _builder;                                          // 0x0650(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClass*                                 _builderClassDef;                                  // 0x0658(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralLevelData">();
	}
	static class AProceduralLevelData* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProceduralLevelData>();
	}
};
static_assert(alignof(AProceduralLevelData) == 0x000008, "Wrong alignment on AProceduralLevelData");
static_assert(sizeof(AProceduralLevelData) == 0x000660, "Wrong size on AProceduralLevelData");
static_assert(offsetof(AProceduralLevelData, SelectedPaperMap) == 0x0002A0, "Member 'AProceduralLevelData::SelectedPaperMap' has a wrong offset!");
static_assert(offsetof(AProceduralLevelData, GenerationSeed) == 0x0002D8, "Member 'AProceduralLevelData::GenerationSeed' has a wrong offset!");
static_assert(offsetof(AProceduralLevelData, gameType) == 0x0002DC, "Member 'AProceduralLevelData::gameType' has a wrong offset!");
static_assert(offsetof(AProceduralLevelData, SpecialEventId) == 0x0002E0, "Member 'AProceduralLevelData::SpecialEventId' has a wrong offset!");
static_assert(offsetof(AProceduralLevelData, GeneratedData) == 0x0002F0, "Member 'AProceduralLevelData::GeneratedData' has a wrong offset!");
static_assert(offsetof(AProceduralLevelData, offerings) == 0x000620, "Member 'AProceduralLevelData::offerings' has a wrong offset!");
static_assert(offsetof(AProceduralLevelData, PerksLevel) == 0x000630, "Member 'AProceduralLevelData::PerksLevel' has a wrong offset!");
static_assert(offsetof(AProceduralLevelData, Perks) == 0x000638, "Member 'AProceduralLevelData::Perks' has a wrong offset!");
static_assert(offsetof(AProceduralLevelData, SkipGameplayElementGeneration) == 0x000648, "Member 'AProceduralLevelData::SkipGameplayElementGeneration' has a wrong offset!");
static_assert(offsetof(AProceduralLevelData, _builder) == 0x000650, "Member 'AProceduralLevelData::_builder' has a wrong offset!");
static_assert(offsetof(AProceduralLevelData, _builderClassDef) == 0x000658, "Member 'AProceduralLevelData::_builderClassDef' has a wrong offset!");

// Class DeadByDaylight.CinematicManager
// 0x0060 (0x0090 - 0x0030)
class UCinematicManager final : public UObject
{
public:
	uint8                                         Pad_30[0x48];                                      // 0x0030(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCinematic>                     _cinematicQueue;                                   // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UBackendCinematicContainer*             _backendContainer;                                 // 0x0088(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CancelAllCinematicToPlay();
	struct FCinematic GetNextCinematicToPlay();
	void PlayMultiple(const TArray<struct FCinematic>& Cinematics);
	void PlaySingle(const struct FCinematic& Cinematic);
	void SetVideoThumbnailProperties(struct FCinematic* Cinematic);

	bool HasCinematicToPlay() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CinematicManager">();
	}
	static class UCinematicManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCinematicManager>();
	}
};
static_assert(alignof(UCinematicManager) == 0x000008, "Wrong alignment on UCinematicManager");
static_assert(sizeof(UCinematicManager) == 0x000090, "Wrong size on UCinematicManager");
static_assert(offsetof(UCinematicManager, _cinematicQueue) == 0x000078, "Member 'UCinematicManager::_cinematicQueue' has a wrong offset!");
static_assert(offsetof(UCinematicManager, _backendContainer) == 0x000088, "Member 'UCinematicManager::_backendContainer' has a wrong offset!");

// Class DeadByDaylight.ClientBloodwebContentAdapter
// 0x0010 (0x0068 - 0x0058)
class UClientBloodwebContentAdapter final : public UBaseBloodwebContentAdapter
{
public:
	class UBloodwebGenerator*                     _bloodwebBuilder;                                  // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClientBloodwebContentAdapter">();
	}
	static class UClientBloodwebContentAdapter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClientBloodwebContentAdapter>();
	}
};
static_assert(alignof(UClientBloodwebContentAdapter) == 0x000008, "Wrong alignment on UClientBloodwebContentAdapter");
static_assert(sizeof(UClientBloodwebContentAdapter) == 0x000068, "Wrong size on UClientBloodwebContentAdapter");
static_assert(offsetof(UClientBloodwebContentAdapter, _bloodwebBuilder) == 0x000058, "Member 'UClientBloodwebContentAdapter::_bloodwebBuilder' has a wrong offset!");

// Class DeadByDaylight.DBDPlayerStart
// 0x0008 (0x02E0 - 0x02D8)
class ADBDPlayerStart final : public APlayerStart
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerStart">();
	}
	static class ADBDPlayerStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDPlayerStart>();
	}
};
static_assert(alignof(ADBDPlayerStart) == 0x000008, "Wrong alignment on ADBDPlayerStart");
static_assert(sizeof(ADBDPlayerStart) == 0x0002E0, "Wrong size on ADBDPlayerStart");

// Class DeadByDaylight.ClientStartupInitializerInterface
// 0x0000 (0x0000 - 0x0000)
class IClientStartupInitializerInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClientStartupInitializerInterface">();
	}
	static class IClientStartupInitializerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IClientStartupInitializerInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IClientStartupInitializerInterface) == 0x000001, "Wrong alignment on IClientStartupInitializerInterface");
static_assert(sizeof(IClientStartupInitializerInterface) == 0x000001, "Wrong size on IClientStartupInitializerInterface");

// Class DeadByDaylight.PlayerInteractionHandler
// 0x0648 (0x0700 - 0x00B8)
class alignas(0x10) UPlayerInteractionHandler final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x68];                                      // 0x00B8(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PriorityConeAngle;                                 // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BotPriorityConeAngle;                              // 0x0124(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x10];                                     // 0x0128(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              Authority_SecondaryActionDoneDelegate;             // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              NewInteractionRequestedDelegate;                   // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              ServerValidatedInteractionStartedDelegate;         // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              ServerValidatedInteractionEndedDelegate;           // 0x0168(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EInteractionLayer                             InteractionLayer;                                  // 0x0178(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_179[0xF];                                      // 0x0179(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool hadInput, bool Success, bool Bonus, ESkillCheckCustomType Type)> OnDeactivateSkillCheckDelegate; // 0x0188(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_198[0x60];                                     // 0x0198(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _hasInteractionRequest;                            // 0x01F8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasInteractionRequestInBuffer;                    // 0x01F9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1FA[0x1E];                                     // 0x01FA(0x001E)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionDefinition*                 _interactionToSwapTo;                              // 0x0218(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_220[0x18];                                     // 0x0220(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionDefinition*                 _currentInteraction;                               // 0x0238(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_240[0xC8];                                     // 0x0240(0x00C8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADBDPlayer*>                     _currentPlayerDependencies;                        // 0x0308(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	EInputInteractionType                         _currentInteractionType;                           // 0x0318(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_319[0x7];                                      // 0x0319(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkillCheck*                            _skillCheck;                                       // 0x0320(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 _progressBasedSkillChecks;                         // 0x0330(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_340[0x68];                                     // 0x0340(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _requestedInterruptionOtherParty;                  // 0x03A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInterruptionDefinition*                _requestedInterruptionDefinition;                  // 0x03B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _requestedInterruptionIsInterruptor;               // 0x03B8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B9[0x7];                                      // 0x03B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _currentInterruptionOtherParty;                    // 0x03C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInterruptionDefinition*                _currentInterruptionDefinition;                    // 0x03C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _currentInterruptionIsInterruptor;                 // 0x03D0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _interactionInProgress;                            // 0x03D1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D2[0x5E];                                     // 0x03D2(0x005E)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInteractionDefinition*>         _interactionsInZone;                               // 0x0430(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_440[0x38];                                     // 0x0440(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAvailableInteractionCalculator        _availableInteractionCalculator;                   // 0x0478(0x0208)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_680[0x20];                                     // 0x0680(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UObject*, struct FGameplayTagContainer> _disableInteractionSourcesToExceptions;       // 0x06A0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6F0[0x10];                                     // 0x06F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddInteraction(class UInteractionDefinition* Interaction);
	void Authority_ClearPlayerDependency(class ADBDPlayer* playerDependency);
	void Broadcast_Multicast_ConfirmChargedCompleted(bool chargeComplete);
	void CleanInteractionArray(class AActor* DestroyedActor);
	void Client_Cheat_SetInteractionScanInterval(float Interval);
	void Client_NotifyChargeCompleted(const class UInteractionDefinition* Interaction);
	bool HasAvailableInteraction(EInputInteractionType interactionType);
	void Multicast_CancelCurrentInteractionByInput();
	void Multicast_InteractionPredictionValidationResult(class UInteractionDefinition* Interaction, EInteractionValidationState State);
	void Multicast_InterruptionRequestResult_Interruptor(ERequestState State, bool grantInterruptScore);
	void Multicast_RequestInterruption_Interruptee(class ADBDPlayer* interruptionOtherParty, class UInterruptionDefinition* InterruptionDefinition);
	void Multicast_SetInteractionToSwapTo(class UInteractionDefinition* Interaction);
	void Multicast_StoreInteraction(const struct FStoredInteraction& interactionToStore);
	void Multicast_StoreInterruption_Interruptor(class ADBDPlayer* interruptionOtherParty, class UInterruptionDefinition* InterruptionDefinition);
	void OnAttachedInteractorOwnerEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason);
	void RemoveInteraction(class UInteractionDefinition* Interaction);
	void Server_AnswerInterruption_Interruptee(ERequestState State);
	void Server_Broadcast_ConfirmChargedCompleted(bool chargeComplete);
	void Server_Broadcast_StoreInteraction(const struct FStoredInteraction& interactionToStore);
	void Server_CancelCurrentInteractionByInput();
	void Server_Cheat_SetInteractionScanInterval(float Interval);
	void Server_RequestInterruption_Interruptor();
	void Server_SetInteractionToSwapTo(class UInteractionDefinition* Interaction);
	void Server_StoreInterruption_Interruptor(class ADBDPlayer* interruptionOtherParty, class UInterruptionDefinition* InterruptionDefinition);

	float GetAdditiveSkillCheckProbabilityModifier() const;
	class UInteractionDefinition* GetAvailableInteraction(EInputInteractionType interactionType) const;
	class UInteractionDefinition* GetCurrentInteraction() const;
	float GetMultiplicativeSkillCheckProbabilityModifier() const;
	bool HasActiveSkillCheck() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerInteractionHandler">();
	}
	static class UPlayerInteractionHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerInteractionHandler>();
	}
};
static_assert(alignof(UPlayerInteractionHandler) == 0x000010, "Wrong alignment on UPlayerInteractionHandler");
static_assert(sizeof(UPlayerInteractionHandler) == 0x000700, "Wrong size on UPlayerInteractionHandler");
static_assert(offsetof(UPlayerInteractionHandler, PriorityConeAngle) == 0x000120, "Member 'UPlayerInteractionHandler::PriorityConeAngle' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, BotPriorityConeAngle) == 0x000124, "Member 'UPlayerInteractionHandler::BotPriorityConeAngle' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, Authority_SecondaryActionDoneDelegate) == 0x000138, "Member 'UPlayerInteractionHandler::Authority_SecondaryActionDoneDelegate' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, NewInteractionRequestedDelegate) == 0x000148, "Member 'UPlayerInteractionHandler::NewInteractionRequestedDelegate' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, ServerValidatedInteractionStartedDelegate) == 0x000158, "Member 'UPlayerInteractionHandler::ServerValidatedInteractionStartedDelegate' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, ServerValidatedInteractionEndedDelegate) == 0x000168, "Member 'UPlayerInteractionHandler::ServerValidatedInteractionEndedDelegate' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, InteractionLayer) == 0x000178, "Member 'UPlayerInteractionHandler::InteractionLayer' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, OnDeactivateSkillCheckDelegate) == 0x000188, "Member 'UPlayerInteractionHandler::OnDeactivateSkillCheckDelegate' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _hasInteractionRequest) == 0x0001F8, "Member 'UPlayerInteractionHandler::_hasInteractionRequest' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _hasInteractionRequestInBuffer) == 0x0001F9, "Member 'UPlayerInteractionHandler::_hasInteractionRequestInBuffer' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _interactionToSwapTo) == 0x000218, "Member 'UPlayerInteractionHandler::_interactionToSwapTo' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _currentInteraction) == 0x000238, "Member 'UPlayerInteractionHandler::_currentInteraction' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _currentPlayerDependencies) == 0x000308, "Member 'UPlayerInteractionHandler::_currentPlayerDependencies' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _currentInteractionType) == 0x000318, "Member 'UPlayerInteractionHandler::_currentInteractionType' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _skillCheck) == 0x000320, "Member 'UPlayerInteractionHandler::_skillCheck' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _progressBasedSkillChecks) == 0x000330, "Member 'UPlayerInteractionHandler::_progressBasedSkillChecks' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _requestedInterruptionOtherParty) == 0x0003A8, "Member 'UPlayerInteractionHandler::_requestedInterruptionOtherParty' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _requestedInterruptionDefinition) == 0x0003B0, "Member 'UPlayerInteractionHandler::_requestedInterruptionDefinition' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _requestedInterruptionIsInterruptor) == 0x0003B8, "Member 'UPlayerInteractionHandler::_requestedInterruptionIsInterruptor' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _currentInterruptionOtherParty) == 0x0003C0, "Member 'UPlayerInteractionHandler::_currentInterruptionOtherParty' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _currentInterruptionDefinition) == 0x0003C8, "Member 'UPlayerInteractionHandler::_currentInterruptionDefinition' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _currentInterruptionIsInterruptor) == 0x0003D0, "Member 'UPlayerInteractionHandler::_currentInterruptionIsInterruptor' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _interactionInProgress) == 0x0003D1, "Member 'UPlayerInteractionHandler::_interactionInProgress' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _interactionsInZone) == 0x000430, "Member 'UPlayerInteractionHandler::_interactionsInZone' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _availableInteractionCalculator) == 0x000478, "Member 'UPlayerInteractionHandler::_availableInteractionCalculator' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _disableInteractionSourcesToExceptions) == 0x0006A0, "Member 'UPlayerInteractionHandler::_disableInteractionSourcesToExceptions' has a wrong offset!");

// Class DeadByDaylight.DBDDateTimeProvider
// 0x0000 (0x0030 - 0x0030)
class UDBDDateTimeProvider final : public UDateTimeProvider
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDDateTimeProvider">();
	}
	static class UDBDDateTimeProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDDateTimeProvider>();
	}
};
static_assert(alignof(UDBDDateTimeProvider) == 0x000008, "Wrong alignment on UDBDDateTimeProvider");
static_assert(sizeof(UDBDDateTimeProvider) == 0x000030, "Wrong size on UDBDDateTimeProvider");

// Class DeadByDaylight.ClipManager
// 0x0168 (0x0408 - 0x02A0)
class AClipManager final : public AActor
{
public:
	TArray<class UDBDClipRegionComponent*>        _clippingZones;                                    // 0x02A0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSet<class UMeshComponent*>                   _meshComponents;                                   // 0x02B0(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FMaterialOriginalState>         _dissolvedMeshes;                                  // 0x0300(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class UMaterialInterface*, class UMaterialInterface*> _normal2dissolve;                     // 0x0310(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class UMaterialInterface*, struct FStaticMeshesArrayForClip> _normal2dissolveStaticMeshes;  // 0x0360(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class UMaterialInterface*, class UMaterialInterface*> _dissolve2normal;                     // 0x03B0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class UDataTable*                             _sphericalDissolveMaterials;                       // 0x0400(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void RemoveDissolveMaterials();
	void SphericalDissolveAt(const struct FVector& Location, float Radius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClipManager">();
	}
	static class AClipManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AClipManager>();
	}
};
static_assert(alignof(AClipManager) == 0x000008, "Wrong alignment on AClipManager");
static_assert(sizeof(AClipManager) == 0x000408, "Wrong size on AClipManager");
static_assert(offsetof(AClipManager, _clippingZones) == 0x0002A0, "Member 'AClipManager::_clippingZones' has a wrong offset!");
static_assert(offsetof(AClipManager, _meshComponents) == 0x0002B0, "Member 'AClipManager::_meshComponents' has a wrong offset!");
static_assert(offsetof(AClipManager, _dissolvedMeshes) == 0x000300, "Member 'AClipManager::_dissolvedMeshes' has a wrong offset!");
static_assert(offsetof(AClipManager, _normal2dissolve) == 0x000310, "Member 'AClipManager::_normal2dissolve' has a wrong offset!");
static_assert(offsetof(AClipManager, _normal2dissolveStaticMeshes) == 0x000360, "Member 'AClipManager::_normal2dissolveStaticMeshes' has a wrong offset!");
static_assert(offsetof(AClipManager, _dissolve2normal) == 0x0003B0, "Member 'AClipManager::_dissolve2normal' has a wrong offset!");
static_assert(offsetof(AClipManager, _sphericalDissolveMaterials) == 0x000400, "Member 'AClipManager::_sphericalDissolveMaterials' has a wrong offset!");

// Class DeadByDaylight.CollectableAudioComponent
// 0x0010 (0x00C8 - 0x00B8)
class UCollectableAudioComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddonConsumed(class UItemAddon* addon);
	void EnableComponent();
	void OnChargeEmpty();
	void OnItemDropped(EItemDropType dropType);
	void PlayerPickedUpCollectable(class ADBDPlayer* Player);

	void PostAudioEvent(const class FString& audioCall) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectableAudioComponent">();
	}
	static class UCollectableAudioComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollectableAudioComponent>();
	}
};
static_assert(alignof(UCollectableAudioComponent) == 0x000008, "Wrong alignment on UCollectableAudioComponent");
static_assert(sizeof(UCollectableAudioComponent) == 0x0000C8, "Wrong size on UCollectableAudioComponent");

// Class DeadByDaylight.PlatformHelper
// 0x0000 (0x0030 - 0x0030)
class UPlatformHelper final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformHelper">();
	}
	static class UPlatformHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformHelper>();
	}
};
static_assert(alignof(UPlatformHelper) == 0x000008, "Wrong alignment on UPlatformHelper");
static_assert(sizeof(UPlatformHelper) == 0x000030, "Wrong size on UPlatformHelper");

// Class DeadByDaylight.CollectableCollection
// 0x0058 (0x0110 - 0x00B8)
class UCollectableCollection final : public UActorComponent
{
public:
	TArray<class ACollectable*>                   _collectables;                                     // 0x00B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _collectableSpawning;                              // 0x00C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x38];                                      // 0x00D8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectableCollection">();
	}
	static class UCollectableCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollectableCollection>();
	}
};
static_assert(alignof(UCollectableCollection) == 0x000008, "Wrong alignment on UCollectableCollection");
static_assert(sizeof(UCollectableCollection) == 0x000110, "Wrong size on UCollectableCollection");
static_assert(offsetof(UCollectableCollection, _collectables) == 0x0000B8, "Member 'UCollectableCollection::_collectables' has a wrong offset!");
static_assert(offsetof(UCollectableCollection, _collectableSpawning) == 0x0000C8, "Member 'UCollectableCollection::_collectableSpawning' has a wrong offset!");

// Class DeadByDaylight.DecalMaskedMaterialsList
// 0x0060 (0x0098 - 0x0038)
class UDecalMaskedMaterialsList final : public UDataAsset
{
public:
	class UStaticMesh*                            decalPlaneStaticMesh;                              // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         decalPlaneExtent;                                  // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UMaterialInterface*>  decalMaskedMaterials;                              // 0x0048(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DecalMaskedMaterialsList">();
	}
	static class UDecalMaskedMaterialsList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDecalMaskedMaterialsList>();
	}
};
static_assert(alignof(UDecalMaskedMaterialsList) == 0x000008, "Wrong alignment on UDecalMaskedMaterialsList");
static_assert(sizeof(UDecalMaskedMaterialsList) == 0x000098, "Wrong size on UDecalMaskedMaterialsList");
static_assert(offsetof(UDecalMaskedMaterialsList, decalPlaneStaticMesh) == 0x000038, "Member 'UDecalMaskedMaterialsList::decalPlaneStaticMesh' has a wrong offset!");
static_assert(offsetof(UDecalMaskedMaterialsList, decalPlaneExtent) == 0x000040, "Member 'UDecalMaskedMaterialsList::decalPlaneExtent' has a wrong offset!");
static_assert(offsetof(UDecalMaskedMaterialsList, decalMaskedMaterials) == 0x000048, "Member 'UDecalMaskedMaterialsList::decalMaskedMaterials' has a wrong offset!");

// Class DeadByDaylight.GeneratorDrivenActor
// 0x0028 (0x02C8 - 0x02A0)
class AGeneratorDrivenActor : public AActor
{
public:
	float                                         LightPriority;                                     // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EComponentMobility                            TargetMobileLightMobility;                         // 0x02A4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A5[0x3];                                      // 0x02A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  _activated;                                        // 0x02A8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                        _generators;                                       // 0x02B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void Authority_CheckActivation(bool isAutoCompleted, int32 generatorId);
	void Authority_CheckGeneratorRepairedBySurvivor(class ADBDPlayer* repairingSurvivor, int32 generatorId);
	struct FRandomStream GetSharedTileRandomizer();
	void Multicast_ActivationChecked(bool activated, bool isAutoCompleted, int32 generatorId);
	void Multicast_GeneratorRepairedBySurvivor(class ADBDPlayer* repairingSurvivor, int32 generatorId);
	void OnActivateGeneratorDrivenActor(bool isAutoCompleted, int32 generatorId);
	void OnGeneratorRepairedBySurvivor(class ADBDPlayer* repairingSurvivor, int32 generatorId);
	void OnInitGeneratorDrivenActor(class UObject* Generator, int32 generatorId);
	void SetSpawnedObject(class UObject* spawnedObject, int32 generatorId);

	bool IsActivated(int32 generatorId) const;
	bool IsValidGeneratorId(int32 generatorId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratorDrivenActor">();
	}
	static class AGeneratorDrivenActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGeneratorDrivenActor>();
	}
};
static_assert(alignof(AGeneratorDrivenActor) == 0x000008, "Wrong alignment on AGeneratorDrivenActor");
static_assert(sizeof(AGeneratorDrivenActor) == 0x0002C8, "Wrong size on AGeneratorDrivenActor");
static_assert(offsetof(AGeneratorDrivenActor, LightPriority) == 0x0002A0, "Member 'AGeneratorDrivenActor::LightPriority' has a wrong offset!");
static_assert(offsetof(AGeneratorDrivenActor, TargetMobileLightMobility) == 0x0002A4, "Member 'AGeneratorDrivenActor::TargetMobileLightMobility' has a wrong offset!");
static_assert(offsetof(AGeneratorDrivenActor, _activated) == 0x0002A8, "Member 'AGeneratorDrivenActor::_activated' has a wrong offset!");
static_assert(offsetof(AGeneratorDrivenActor, _generators) == 0x0002B8, "Member 'AGeneratorDrivenActor::_generators' has a wrong offset!");

// Class DeadByDaylight.DBDGeneratorDrivenReflectionCaptureActor
// 0x0018 (0x02E0 - 0x02C8)
class ADBDGeneratorDrivenReflectionCaptureActor final : public AGeneratorDrivenActor
{
public:
	class UGenyReflectionCaptureComponent*        genyReflectionCapture;                             // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D0[0x10];                                     // 0x02D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SwapToSecondState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGeneratorDrivenReflectionCaptureActor">();
	}
	static class ADBDGeneratorDrivenReflectionCaptureActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDGeneratorDrivenReflectionCaptureActor>();
	}
};
static_assert(alignof(ADBDGeneratorDrivenReflectionCaptureActor) == 0x000008, "Wrong alignment on ADBDGeneratorDrivenReflectionCaptureActor");
static_assert(sizeof(ADBDGeneratorDrivenReflectionCaptureActor) == 0x0002E0, "Wrong size on ADBDGeneratorDrivenReflectionCaptureActor");
static_assert(offsetof(ADBDGeneratorDrivenReflectionCaptureActor, genyReflectionCapture) == 0x0002C8, "Member 'ADBDGeneratorDrivenReflectionCaptureActor::genyReflectionCapture' has a wrong offset!");

// Class DeadByDaylight.CombinedSpecialEventDataUtilities
// 0x0000 (0x0030 - 0x0030)
class UCombinedSpecialEventDataUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class FName GetSpecialMusicState(const struct FCombinedSpecialEventData& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CombinedSpecialEventDataUtilities">();
	}
	static class UCombinedSpecialEventDataUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCombinedSpecialEventDataUtilities>();
	}
};
static_assert(alignof(UCombinedSpecialEventDataUtilities) == 0x000008, "Wrong alignment on UCombinedSpecialEventDataUtilities");
static_assert(sizeof(UCombinedSpecialEventDataUtilities) == 0x000030, "Wrong size on UCombinedSpecialEventDataUtilities");

// Class DeadByDaylight.TileMatrix
// 0x0058 (0x0088 - 0x0030)
class UTileMatrix final : public UObject
{
public:
	TArray<struct FArrayOfATile>                  _matrix;                                           // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ATile*>                          _tiles;                                            // 0x0040(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ATile*>                          _extraTiles;                                       // 0x0050(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class AActor*                                 _basementActor;                                    // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FQuadrantInfo>                  _quadInfoArray;                                    // 0x0068(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FArrayOfInt32>                  _quadIndexMatrix;                                  // 0x0078(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TileMatrix">();
	}
	static class UTileMatrix* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTileMatrix>();
	}
};
static_assert(alignof(UTileMatrix) == 0x000008, "Wrong alignment on UTileMatrix");
static_assert(sizeof(UTileMatrix) == 0x000088, "Wrong size on UTileMatrix");
static_assert(offsetof(UTileMatrix, _matrix) == 0x000030, "Member 'UTileMatrix::_matrix' has a wrong offset!");
static_assert(offsetof(UTileMatrix, _tiles) == 0x000040, "Member 'UTileMatrix::_tiles' has a wrong offset!");
static_assert(offsetof(UTileMatrix, _extraTiles) == 0x000050, "Member 'UTileMatrix::_extraTiles' has a wrong offset!");
static_assert(offsetof(UTileMatrix, _basementActor) == 0x000060, "Member 'UTileMatrix::_basementActor' has a wrong offset!");
static_assert(offsetof(UTileMatrix, _quadInfoArray) == 0x000068, "Member 'UTileMatrix::_quadInfoArray' has a wrong offset!");
static_assert(offsetof(UTileMatrix, _quadIndexMatrix) == 0x000078, "Member 'UTileMatrix::_quadIndexMatrix' has a wrong offset!");

// Class DeadByDaylight.CommentatorActorBase
// 0x0010 (0x02B0 - 0x02A0)
class ACommentatorActorBase : public AActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkComponent*                           _audioComponent;                                   // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommentatorActorBase">();
	}
	static class ACommentatorActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACommentatorActorBase>();
	}
};
static_assert(alignof(ACommentatorActorBase) == 0x000008, "Wrong alignment on ACommentatorActorBase");
static_assert(sizeof(ACommentatorActorBase) == 0x0002B0, "Wrong size on ACommentatorActorBase");
static_assert(offsetof(ACommentatorActorBase, _audioComponent) == 0x0002A8, "Member 'ACommentatorActorBase::_audioComponent' has a wrong offset!");

// Class DeadByDaylight.CommentatorActorInterface
// 0x0000 (0x0000 - 0x0000)
class ICommentatorActorInterface final
{
public:
	void OnAudioEnded();
	void OnAudioStarted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommentatorActorInterface">();
	}
	static class ICommentatorActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICommentatorActorInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ICommentatorActorInterface) == 0x000001, "Wrong alignment on ICommentatorActorInterface");
static_assert(sizeof(ICommentatorActorInterface) == 0x000001, "Wrong size on ICommentatorActorInterface");

// Class DeadByDaylight.DBDPlayerControllerBase
// 0x00D8 (0x0938 - 0x0860)
class ADBDPlayerControllerBase : public APlayerController
{
public:
	uint8                                         Pad_860[0x58];                                     // 0x0860(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const class APlayerState* PlayerState)> OnPlayerStateChanged;      // 0x08B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C8[0x40];                                     // 0x08C8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _EOSProductId;                                     // 0x0908(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_918[0x8];                                      // 0x0918(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _mainCharacter;                                    // 0x0920(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_928[0x10];                                     // 0x0928(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client(const class FString& commandLine);
	void Client_CallConsoleCmdOnClient(const class FString& commandLine);
	void Client_DisplayChatMessage(const class FString& chatIdentifier, int32 PlayerIndex, const class FString& MirrorsId, const class FString& Msg);
	void Client_EACBeginSession();
	void Client_EACDestroySession();
	void Client_EACMessageFromServer(const TArray<uint8>& Message);
	void Client_FinishedPlaying(const struct FEndGameInfo& Info);
	void Client_GameEnded(const struct FEndGameInfo& Info);
	void Client_RequestPlayerProfile();
	void Client_SendLogs(const TArray<class FString>& ensures);
	void Client_SendServerAuthentication(const class FString& authServerTicket, uint64 SteamId, uint32 ticketLength);
	void Client_SendWarning(bool penaltyStarts, float Seconds);
	void DBD_BuildFromMap(const class FString& Map);
	void DBD_BuildFromPlayerCount(int32 Count);
	void DBD_BuildFromSeed(int32 Seed);
	void DBD_BuildFromTile(int32 matrixX, int32 matrixY, int32 Rotation, const class FString& Name_0);
	void DBD_DebugSendChatMessage(const class FString& Msg);
	void DBD_FillAllScoreCategories();
	void DBD_FillScoreCategory(int32 category);
	void DBD_FireTestScore(int32 category, float Value);
	void DBD_SetCurrentCharacterPrestigeDatesFuture();
	void DBD_SetCurrentCharacterPrestigeDatesNow();
	void DBD_SetCurrentCharacterPrestigeDatesPast();
	void DBD_UpdateLocalStats();
	void Server(const class FString& commandLine);
	void Server_CallConsoleCmdOnServer(const class FString& commandLine);
	void Server_EACMessageFromClient(const TArray<uint8>& Message);
	void Server_ReceivePlayerProfile(const struct FPlayerSavedProfileDataShared& savedProfileData, const struct FPlayerLoadoutData& playerLoadout);
	void Server_SendClientAuthentication(const class FString& authClientTicket, uint64 SteamId, uint32 ticketLength);
	void Server_SendMessage(const class FString& Message);
	void Server_SetConsecutiveMatchStreak(int32 consecutiveMatch);
	void Server_SetPlayerCard(const class FString& badgeId, const class FString& bannerId);
	void Server_UpdateReplicatedPips(int32 pipsToAdd);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerControllerBase">();
	}
	static class ADBDPlayerControllerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDPlayerControllerBase>();
	}
};
static_assert(alignof(ADBDPlayerControllerBase) == 0x000008, "Wrong alignment on ADBDPlayerControllerBase");
static_assert(sizeof(ADBDPlayerControllerBase) == 0x000938, "Wrong size on ADBDPlayerControllerBase");
static_assert(offsetof(ADBDPlayerControllerBase, OnPlayerStateChanged) == 0x0008B8, "Member 'ADBDPlayerControllerBase::OnPlayerStateChanged' has a wrong offset!");
static_assert(offsetof(ADBDPlayerControllerBase, _EOSProductId) == 0x000908, "Member 'ADBDPlayerControllerBase::_EOSProductId' has a wrong offset!");
static_assert(offsetof(ADBDPlayerControllerBase, _mainCharacter) == 0x000920, "Member 'ADBDPlayerControllerBase::_mainCharacter' has a wrong offset!");

// Class DeadByDaylight.CommentatorAudioData
// 0x0070 (0x00A8 - 0x0038)
class UCommentatorAudioData final : public UDataAsset
{
public:
	TMap<struct FGameplayTag, struct FCommentatorAudioContext> _commentatorAudioContexts;            // 0x0038(0x0050)(Edit, NativeAccessSpecifierPrivate)
	struct FFloatRange                            _secondsBetweenEvents;                             // 0x0088(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ACommentatorActorBase>      _commentatorActorClass;                            // 0x0098(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommentatorSpawnStrategy*              _commentatorSpawnStrategy;                         // 0x00A0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommentatorAudioData">();
	}
	static class UCommentatorAudioData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommentatorAudioData>();
	}
};
static_assert(alignof(UCommentatorAudioData) == 0x000008, "Wrong alignment on UCommentatorAudioData");
static_assert(sizeof(UCommentatorAudioData) == 0x0000A8, "Wrong size on UCommentatorAudioData");
static_assert(offsetof(UCommentatorAudioData, _commentatorAudioContexts) == 0x000038, "Member 'UCommentatorAudioData::_commentatorAudioContexts' has a wrong offset!");
static_assert(offsetof(UCommentatorAudioData, _secondsBetweenEvents) == 0x000088, "Member 'UCommentatorAudioData::_secondsBetweenEvents' has a wrong offset!");
static_assert(offsetof(UCommentatorAudioData, _commentatorActorClass) == 0x000098, "Member 'UCommentatorAudioData::_commentatorActorClass' has a wrong offset!");
static_assert(offsetof(UCommentatorAudioData, _commentatorSpawnStrategy) == 0x0000A0, "Member 'UCommentatorAudioData::_commentatorSpawnStrategy' has a wrong offset!");

// Class DeadByDaylight.PhaseWalkingInterface
// 0x0000 (0x0000 - 0x0000)
class IPhaseWalkingInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhaseWalkingInterface">();
	}
	static class IPhaseWalkingInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPhaseWalkingInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPhaseWalkingInterface) == 0x000001, "Wrong alignment on IPhaseWalkingInterface");
static_assert(sizeof(IPhaseWalkingInterface) == 0x000001, "Wrong size on IPhaseWalkingInterface");

// Class DeadByDaylight.ColorBlindFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UColorBlindFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void CallOnColorBlindSettingsChange(class UObject* callingObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ColorBlindFunctionLibrary">();
	}
	static class UColorBlindFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UColorBlindFunctionLibrary>();
	}
};
static_assert(alignof(UColorBlindFunctionLibrary) == 0x000008, "Wrong alignment on UColorBlindFunctionLibrary");
static_assert(sizeof(UColorBlindFunctionLibrary) == 0x000030, "Wrong size on UColorBlindFunctionLibrary");

// Class DeadByDaylight.CommentatorSubsystem
// 0x0090 (0x00C8 - 0x0038)
class UCommentatorSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x90];                                      // 0x0038(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCommentatorAudioFinished(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommentatorSubsystem">();
	}
	static class UCommentatorSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommentatorSubsystem>();
	}
};
static_assert(alignof(UCommentatorSubsystem) == 0x000008, "Wrong alignment on UCommentatorSubsystem");
static_assert(sizeof(UCommentatorSubsystem) == 0x0000C8, "Wrong size on UCommentatorSubsystem");

// Class DeadByDaylight.RedStainComponent
// 0x0010 (0x0540 - 0x0530)
class URedStainComponent : public USpotLightComponent
{
public:
	struct FLinearColor                           _initialSpotLightColor;                            // 0x0528(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_538[0x8];                                      // 0x0538(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_HideRedStain(const bool hideStain);
	void UpdateRedStain(bool shouldBeHidden, const float alpha);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RedStainComponent">();
	}
	static class URedStainComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URedStainComponent>();
	}
};
static_assert(alignof(URedStainComponent) == 0x000010, "Wrong alignment on URedStainComponent");
static_assert(sizeof(URedStainComponent) == 0x000540, "Wrong size on URedStainComponent");
static_assert(offsetof(URedStainComponent, _initialSpotLightColor) == 0x000528, "Member 'URedStainComponent::_initialSpotLightColor' has a wrong offset!");

// Class DeadByDaylight.SkillCheck
// 0x0230 (0x02E8 - 0x00B8)
class USkillCheck final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0xE0];                                      // 0x00B8(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _owner;                                            // 0x0198(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableInteractionDefinition*       _currentInteraction;                               // 0x01A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A8[0x70];                                     // 0x01A8(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ESkillCheckCustomType>                 _customSkillCheckTypesAffectedByWarningModifiers;  // 0x0218(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_228[0xC0];                                     // 0x0228(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool CanSkillCheckTypeGrantScore(ESkillCheckCustomType Type);

	void Authority_OnSkillCheckTimeout();
	void Multicast_ActivateSkillCheck(class UChargeableInteractionDefinition* Interaction, ESkillCheckCustomType skillCheckCustomType, const struct FSkillCheckDefinition& definition, bool executeOnlyOnNotControlled);
	void Multicast_DeactivateSkillCheck();
	void Multicast_OnTriggerContinuousCustomSkillCheck(class UChargeableInteractionDefinition* currentInteraction, ESkillCheckCustomType skillCheckCustomType, const struct FSkillCheckDefinition& definition);
	void Multicast_OnTriggerCustomSkillCheck(class UChargeableInteractionDefinition* currentInteraction, ESkillCheckCustomType skillCheckCustomType, const class FString& ID, const class FString& salt, const struct FSkillCheckDefinition& definition);
	void Multicast_SkillCheckResponse(const struct FSkillCheckResponse& SkillCheckResponse, bool executeOnlyOnNotControlled);
	void Server_ActivateSkillCheck(class UChargeableInteractionDefinition* Interaction, ESkillCheckCustomType skillCheckCustomType, const struct FSkillCheckDefinition& definition);
	void Server_DeactivateSkillCheck();
	void Server_OnSkillCheckFailure(const struct FSkillCheckResponse& SkillCheckResponse);
	void Server_OnSkillCheckSuccess(const struct FSkillCheckResponse& SkillCheckResponse);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillCheck">();
	}
	static class USkillCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillCheck>();
	}
};
static_assert(alignof(USkillCheck) == 0x000008, "Wrong alignment on USkillCheck");
static_assert(sizeof(USkillCheck) == 0x0002E8, "Wrong size on USkillCheck");
static_assert(offsetof(USkillCheck, _owner) == 0x000198, "Member 'USkillCheck::_owner' has a wrong offset!");
static_assert(offsetof(USkillCheck, _currentInteraction) == 0x0001A0, "Member 'USkillCheck::_currentInteraction' has a wrong offset!");
static_assert(offsetof(USkillCheck, _customSkillCheckTypesAffectedByWarningModifiers) == 0x000218, "Member 'USkillCheck::_customSkillCheckTypesAffectedByWarningModifiers' has a wrong offset!");

// Class DeadByDaylight.CondemnedUIDataInterface
// 0x0000 (0x0000 - 0x0000)
class ICondemnedUIDataInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CondemnedUIDataInterface">();
	}
	static class ICondemnedUIDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICondemnedUIDataInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ICondemnedUIDataInterface) == 0x000001, "Wrong alignment on ICondemnedUIDataInterface");
static_assert(sizeof(ICondemnedUIDataInterface) == 0x000001, "Wrong size on ICondemnedUIDataInterface");

// Class DeadByDaylight.DBDHookUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDHookUtilities final : public UBlueprintFunctionLibrary
{
public:
	static float ComputeHookStrugglePercent(const class ASurvivor* hookedCamper, float hookStruggleThreshold);
	static bool IsFreddyHook(class AMeatHook* targetHook);
	static bool IsHagHook(class AMeatHook* targetHook);
	static bool IsHookOf(class AMeatHook* targetHook, const struct FGameplayTag& hookTag);
	static bool IsHuntressHook(class AMeatHook* targetHook);
	static bool IsLegionHook(class AMeatHook* targetHook);
	static bool IsNurseHook(class AMeatHook* targetHook);
	static bool IsPigHook(class AMeatHook* targetHook);
	static bool IsWraithHook(class AMeatHook* targetHook);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDHookUtilities">();
	}
	static class UDBDHookUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDHookUtilities>();
	}
};
static_assert(alignof(UDBDHookUtilities) == 0x000008, "Wrong alignment on UDBDHookUtilities");
static_assert(sizeof(UDBDHookUtilities) == 0x000030, "Wrong size on UDBDHookUtilities");

// Class DeadByDaylight.ConeAroundDirectionCameraStrategy
// 0x0038 (0x0068 - 0x0030)
class UConeAroundDirectionCameraStrategy final : public UObject
{
public:
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _maxPitchDifference;                               // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxYawDifference;                                 // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxRollDifference;                                // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConeAroundDirectionCameraStrategy">();
	}
	static class UConeAroundDirectionCameraStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConeAroundDirectionCameraStrategy>();
	}
};
static_assert(alignof(UConeAroundDirectionCameraStrategy) == 0x000008, "Wrong alignment on UConeAroundDirectionCameraStrategy");
static_assert(sizeof(UConeAroundDirectionCameraStrategy) == 0x000068, "Wrong size on UConeAroundDirectionCameraStrategy");
static_assert(offsetof(UConeAroundDirectionCameraStrategy, _maxPitchDifference) == 0x000058, "Member 'UConeAroundDirectionCameraStrategy::_maxPitchDifference' has a wrong offset!");
static_assert(offsetof(UConeAroundDirectionCameraStrategy, _maxYawDifference) == 0x00005C, "Member 'UConeAroundDirectionCameraStrategy::_maxYawDifference' has a wrong offset!");
static_assert(offsetof(UConeAroundDirectionCameraStrategy, _maxRollDifference) == 0x000060, "Member 'UConeAroundDirectionCameraStrategy::_maxRollDifference' has a wrong offset!");

// Class DeadByDaylight.ConsentManager
// 0x0090 (0x00C0 - 0x0030)
class UConsentManager final : public UObject
{
public:
	uint8                                         Pad_30[0x90];                                      // 0x0030(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsentManager">();
	}
	static class UConsentManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsentManager>();
	}
};
static_assert(alignof(UConsentManager) == 0x000008, "Wrong alignment on UConsentManager");
static_assert(sizeof(UConsentManager) == 0x0000C0, "Wrong size on UConsentManager");

// Class DeadByDaylight.PlayerOverlapHISMComponent
// 0x0010 (0x09A0 - 0x0990)
class UPlayerOverlapHISMComponent final : public UHISMMaterialHelperComponent
{
public:
	int32                                         _playerInfluenceRadius;                            // 0x0988(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_98C[0x4];                                      // 0x098C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInterface*>             _playerOverlapOverrides;                           // 0x0990(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerOverlapHISMComponent">();
	}
	static class UPlayerOverlapHISMComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerOverlapHISMComponent>();
	}
};
static_assert(alignof(UPlayerOverlapHISMComponent) == 0x000010, "Wrong alignment on UPlayerOverlapHISMComponent");
static_assert(sizeof(UPlayerOverlapHISMComponent) == 0x0009A0, "Wrong size on UPlayerOverlapHISMComponent");
static_assert(offsetof(UPlayerOverlapHISMComponent, _playerInfluenceRadius) == 0x000988, "Member 'UPlayerOverlapHISMComponent::_playerInfluenceRadius' has a wrong offset!");
static_assert(offsetof(UPlayerOverlapHISMComponent, _playerOverlapOverrides) == 0x000990, "Member 'UPlayerOverlapHISMComponent::_playerOverlapOverrides' has a wrong offset!");

// Class DeadByDaylight.ScreenshotToolAnimationAsset
// 0x0020 (0x0058 - 0x0038)
class UScreenshotToolAnimationAsset final : public UDataAsset
{
public:
	TArray<struct FOutfitAnimation>               AnimByOutfit;                                      // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCharacterRoleAnimation>        AnimByCharacter;                                   // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenshotToolAnimationAsset">();
	}
	static class UScreenshotToolAnimationAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenshotToolAnimationAsset>();
	}
};
static_assert(alignof(UScreenshotToolAnimationAsset) == 0x000008, "Wrong alignment on UScreenshotToolAnimationAsset");
static_assert(sizeof(UScreenshotToolAnimationAsset) == 0x000058, "Wrong size on UScreenshotToolAnimationAsset");
static_assert(offsetof(UScreenshotToolAnimationAsset, AnimByOutfit) == 0x000038, "Member 'UScreenshotToolAnimationAsset::AnimByOutfit' has a wrong offset!");
static_assert(offsetof(UScreenshotToolAnimationAsset, AnimByCharacter) == 0x000048, "Member 'UScreenshotToolAnimationAsset::AnimByCharacter' has a wrong offset!");

// Class DeadByDaylight.DisplayStandMeatHookRequesterComponent
// 0x0018 (0x00D0 - 0x00B8)
class UDisplayStandMeatHookRequesterComponent final : public UActorComponent
{
public:
	TSubclassOf<class AMenuMeatHook>              _meatHookClass;                                    // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisplayStandMeatHookRequesterComponent">();
	}
	static class UDisplayStandMeatHookRequesterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisplayStandMeatHookRequesterComponent>();
	}
};
static_assert(alignof(UDisplayStandMeatHookRequesterComponent) == 0x000008, "Wrong alignment on UDisplayStandMeatHookRequesterComponent");
static_assert(sizeof(UDisplayStandMeatHookRequesterComponent) == 0x0000D0, "Wrong size on UDisplayStandMeatHookRequesterComponent");
static_assert(offsetof(UDisplayStandMeatHookRequesterComponent, _meatHookClass) == 0x0000B8, "Member 'UDisplayStandMeatHookRequesterComponent::_meatHookClass' has a wrong offset!");

// Class DeadByDaylight.ConstrainAspectRatioComponent
// 0x00B8 (0x0170 - 0x00B8)
class UConstrainAspectRatioComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0xB8];                                      // 0x00B8(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_ToggleBlackBars(int32 Option);
	void OnIntroCompleted();
	void SetCinematicMode(bool cinematicMode);

	struct FIntPoint GetCameraConstrainedViewSize() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConstrainAspectRatioComponent">();
	}
	static class UConstrainAspectRatioComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConstrainAspectRatioComponent>();
	}
};
static_assert(alignof(UConstrainAspectRatioComponent) == 0x000008, "Wrong alignment on UConstrainAspectRatioComponent");
static_assert(sizeof(UConstrainAspectRatioComponent) == 0x000170, "Wrong size on UConstrainAspectRatioComponent");

// Class DeadByDaylight.HasTokenOrCooldownTimerRemainingActivationElapsedIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UHasTokenOrCooldownTimerRemainingActivationElapsedIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HasTokenOrCooldownTimerRemainingActivationElapsedIconStrategy">();
	}
	static class UHasTokenOrCooldownTimerRemainingActivationElapsedIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHasTokenOrCooldownTimerRemainingActivationElapsedIconStrategy>();
	}
};
static_assert(alignof(UHasTokenOrCooldownTimerRemainingActivationElapsedIconStrategy) == 0x000008, "Wrong alignment on UHasTokenOrCooldownTimerRemainingActivationElapsedIconStrategy");
static_assert(sizeof(UHasTokenOrCooldownTimerRemainingActivationElapsedIconStrategy) == 0x000038, "Wrong size on UHasTokenOrCooldownTimerRemainingActivationElapsedIconStrategy");

// Class DeadByDaylight.ContainsItemInterface
// 0x0000 (0x0000 - 0x0000)
class IContainsItemInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContainsItemInterface">();
	}
	static class IContainsItemInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IContainsItemInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IContainsItemInterface) == 0x000001, "Wrong alignment on IContainsItemInterface");
static_assert(sizeof(IContainsItemInterface) == 0x000001, "Wrong size on IContainsItemInterface");

// Class DeadByDaylight.ScreenshotSpiritHook
// 0x0060 (0x0090 - 0x0030)
class UScreenshotSpiritHook final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SpiritId;                                          // 0x0038(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMaterial>               MaterialToFind;                                    // 0x0048(0x0038)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MaterialFieldName;                                 // 0x0080(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaterialFieldValue;                                // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenshotSpiritHook">();
	}
	static class UScreenshotSpiritHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenshotSpiritHook>();
	}
};
static_assert(alignof(UScreenshotSpiritHook) == 0x000008, "Wrong alignment on UScreenshotSpiritHook");
static_assert(sizeof(UScreenshotSpiritHook) == 0x000090, "Wrong size on UScreenshotSpiritHook");
static_assert(offsetof(UScreenshotSpiritHook, SpiritId) == 0x000038, "Member 'UScreenshotSpiritHook::SpiritId' has a wrong offset!");
static_assert(offsetof(UScreenshotSpiritHook, MaterialToFind) == 0x000048, "Member 'UScreenshotSpiritHook::MaterialToFind' has a wrong offset!");
static_assert(offsetof(UScreenshotSpiritHook, MaterialFieldName) == 0x000080, "Member 'UScreenshotSpiritHook::MaterialFieldName' has a wrong offset!");
static_assert(offsetof(UScreenshotSpiritHook, MaterialFieldValue) == 0x00008C, "Member 'UScreenshotSpiritHook::MaterialFieldValue' has a wrong offset!");

// Class DeadByDaylight.DBDClientSyncer
// 0x01E0 (0x0480 - 0x02A0)
class ADBDClientSyncer final : public AActor
{
public:
	TArray<struct FSpawnInfo>                     _actorsToSpawnLocally;                             // 0x02A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FSpawnInfo>                     _currentQueue;                                     // 0x02B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPaperTileMap*                          _tileMap;                                          // 0x02C8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D0[0x1B0];                                    // 0x02D0(0x01B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_SyncActorToSpawnLocally(const TArray<struct FSpawnInfo>& spawnInfos, int32 startIndex);
	void Multicast_SyncFinalLocallySpawnCount(int32 numLocal);
	void Multicast_SyncSeed(int32 Seed, class UPaperTileMap* TileMap, int32 GenerationPlayerCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDClientSyncer">();
	}
	static class ADBDClientSyncer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDClientSyncer>();
	}
};
static_assert(alignof(ADBDClientSyncer) == 0x000008, "Wrong alignment on ADBDClientSyncer");
static_assert(sizeof(ADBDClientSyncer) == 0x000480, "Wrong size on ADBDClientSyncer");
static_assert(offsetof(ADBDClientSyncer, _actorsToSpawnLocally) == 0x0002A0, "Member 'ADBDClientSyncer::_actorsToSpawnLocally' has a wrong offset!");
static_assert(offsetof(ADBDClientSyncer, _currentQueue) == 0x0002B0, "Member 'ADBDClientSyncer::_currentQueue' has a wrong offset!");
static_assert(offsetof(ADBDClientSyncer, _tileMap) == 0x0002C8, "Member 'ADBDClientSyncer::_tileMap' has a wrong offset!");

// Class DeadByDaylight.ContentScheduleManager
// 0x0110 (0x0140 - 0x0030)
class UContentScheduleManager final : public UObject
{
public:
	uint8                                         Pad_30[0x108];                                     // 0x0030(0x0108)(Fixing Size After Last Property [ Dumper-7 ])
	class UObjectLibrary*                         _availableMapLibrary;                              // 0x0138(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContentScheduleManager">();
	}
	static class UContentScheduleManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContentScheduleManager>();
	}
};
static_assert(alignof(UContentScheduleManager) == 0x000008, "Wrong alignment on UContentScheduleManager");
static_assert(sizeof(UContentScheduleManager) == 0x000140, "Wrong size on UContentScheduleManager");
static_assert(offsetof(UContentScheduleManager, _availableMapLibrary) == 0x000138, "Member 'UContentScheduleManager::_availableMapLibrary' has a wrong offset!");

// Class DeadByDaylight.GestureInteractionDefinition
// 0x0000 (0x0770 - 0x0770)
class UGestureInteractionDefinition final : public UInteractionDefinition
{
public:
	EGestureID                                    _gestureID;                                        // 0x0768(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_769[0x7];                                      // 0x0769(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GestureInteractionDefinition">();
	}
	static class UGestureInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGestureInteractionDefinition>();
	}
};
static_assert(alignof(UGestureInteractionDefinition) == 0x000010, "Wrong alignment on UGestureInteractionDefinition");
static_assert(sizeof(UGestureInteractionDefinition) == 0x000770, "Wrong size on UGestureInteractionDefinition");
static_assert(offsetof(UGestureInteractionDefinition, _gestureID) == 0x000768, "Member 'UGestureInteractionDefinition::_gestureID' has a wrong offset!");

// Class DeadByDaylight.StartLitActivationTimerRemainingCooldownElapsedIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UStartLitActivationTimerRemainingCooldownElapsedIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StartLitActivationTimerRemainingCooldownElapsedIconStrategy">();
	}
	static class UStartLitActivationTimerRemainingCooldownElapsedIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStartLitActivationTimerRemainingCooldownElapsedIconStrategy>();
	}
};
static_assert(alignof(UStartLitActivationTimerRemainingCooldownElapsedIconStrategy) == 0x000008, "Wrong alignment on UStartLitActivationTimerRemainingCooldownElapsedIconStrategy");
static_assert(sizeof(UStartLitActivationTimerRemainingCooldownElapsedIconStrategy) == 0x000038, "Wrong size on UStartLitActivationTimerRemainingCooldownElapsedIconStrategy");

// Class DeadByDaylight.ContentVersionManager
// 0x00B8 (0x00F0 - 0x0038)
class UContentVersionManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0xB8];                                      // 0x0038(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContentVersionManager">();
	}
	static class UContentVersionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContentVersionManager>();
	}
};
static_assert(alignof(UContentVersionManager) == 0x000008, "Wrong alignment on UContentVersionManager");
static_assert(sizeof(UContentVersionManager) == 0x0000F0, "Wrong size on UContentVersionManager");

// Class DeadByDaylight.Halloween2018EventComponent
// 0x0080 (0x0138 - 0x00B8)
class UHalloween2018EventComponent final : public UActorComponent
{
public:
	class USectionnedChargeableComponent*         _toxinVialComponent;                               // 0x00B8(0x0008)(Edit, ExportObject, Net, ZeroConstructor, EditConst, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x78];                                      // 0x00C0(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishedPlaying(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData);
	void OnRep_Vial();
	void Server_SpawnVial(float initialCharge);

	class USectionnedChargeableComponent* GetVial() const;
	bool IsVialFull() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Halloween2018EventComponent">();
	}
	static class UHalloween2018EventComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHalloween2018EventComponent>();
	}
};
static_assert(alignof(UHalloween2018EventComponent) == 0x000008, "Wrong alignment on UHalloween2018EventComponent");
static_assert(sizeof(UHalloween2018EventComponent) == 0x000138, "Wrong size on UHalloween2018EventComponent");
static_assert(offsetof(UHalloween2018EventComponent, _toxinVialComponent) == 0x0000B8, "Member 'UHalloween2018EventComponent::_toxinVialComponent' has a wrong offset!");

// Class DeadByDaylight.ContextTransitionDataSubsystem
// 0x00A8 (0x00E0 - 0x0038)
class UContextTransitionDataSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0xA8];                                      // 0x0038(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextTransitionDataSubsystem">();
	}
	static class UContextTransitionDataSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextTransitionDataSubsystem>();
	}
};
static_assert(alignof(UContextTransitionDataSubsystem) == 0x000008, "Wrong alignment on UContextTransitionDataSubsystem");
static_assert(sizeof(UContextTransitionDataSubsystem) == 0x0000E0, "Wrong size on UContextTransitionDataSubsystem");

// Class DeadByDaylight.GameplayModifierContainerDataAsset
// 0x0048 (0x0090 - 0x0048)
class UGameplayModifierContainerDataAsset : public UDBDPrimaryDataAsset
{
public:
	TSoftClassPtr<class UClass>                   ModifierContainerComponent;                        // 0x0048(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UGameplayModifierContainerDataAsset>> RequiredModifierContainers;    // 0x0080(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayModifierContainerDataAsset">();
	}
	static class UGameplayModifierContainerDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayModifierContainerDataAsset>();
	}
};
static_assert(alignof(UGameplayModifierContainerDataAsset) == 0x000008, "Wrong alignment on UGameplayModifierContainerDataAsset");
static_assert(sizeof(UGameplayModifierContainerDataAsset) == 0x000090, "Wrong size on UGameplayModifierContainerDataAsset");
static_assert(offsetof(UGameplayModifierContainerDataAsset, ModifierContainerComponent) == 0x000048, "Member 'UGameplayModifierContainerDataAsset::ModifierContainerComponent' has a wrong offset!");
static_assert(offsetof(UGameplayModifierContainerDataAsset, RequiredModifierContainers) == 0x000080, "Member 'UGameplayModifierContainerDataAsset::RequiredModifierContainers' has a wrong offset!");

// Class DeadByDaylight.StatusEffectDataAsset
// 0x0000 (0x0090 - 0x0090)
class UStatusEffectDataAsset final : public UGameplayModifierContainerDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusEffectDataAsset">();
	}
	static class UStatusEffectDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatusEffectDataAsset>();
	}
};
static_assert(alignof(UStatusEffectDataAsset) == 0x000008, "Wrong alignment on UStatusEffectDataAsset");
static_assert(sizeof(UStatusEffectDataAsset) == 0x000090, "Wrong size on UStatusEffectDataAsset");

// Class DeadByDaylight.ContextualQuestComponent
// 0x0040 (0x00F8 - 0x00B8)
class UContextualQuestComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x28];                                      // 0x00B8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpecialBehaviourObjectsInfo>   _specialBehaviourObjectsInfo;                      // 0x00E0(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	bool                                          _isInitialized;                                    // 0x00F0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_DebugAddSpecialBehaviour(class FName ID, int32 amountRequired);
	void Authority_DebugRemoveSpecialBehaviour(class FName ID);
	void OnRep_SpecialBehaviourObjectsInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualQuestComponent">();
	}
	static class UContextualQuestComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualQuestComponent>();
	}
};
static_assert(alignof(UContextualQuestComponent) == 0x000008, "Wrong alignment on UContextualQuestComponent");
static_assert(sizeof(UContextualQuestComponent) == 0x0000F8, "Wrong size on UContextualQuestComponent");
static_assert(offsetof(UContextualQuestComponent, _specialBehaviourObjectsInfo) == 0x0000E0, "Member 'UContextualQuestComponent::_specialBehaviourObjectsInfo' has a wrong offset!");
static_assert(offsetof(UContextualQuestComponent, _isInitialized) == 0x0000F0, "Member 'UContextualQuestComponent::_isInitialized' has a wrong offset!");

// Class DeadByDaylight.ControllerPairingManager
// 0x0060 (0x0090 - 0x0030)
class UControllerPairingManager final : public UObject
{
public:
	uint8                                         Pad_30[0x54];                                      // 0x0030(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UDBDGameInstance>        _gameInstance;                                     // 0x0084(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControllerPairingManager">();
	}
	static class UControllerPairingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UControllerPairingManager>();
	}
};
static_assert(alignof(UControllerPairingManager) == 0x000008, "Wrong alignment on UControllerPairingManager");
static_assert(sizeof(UControllerPairingManager) == 0x000090, "Wrong size on UControllerPairingManager");
static_assert(offsetof(UControllerPairingManager, _gameInstance) == 0x000084, "Member 'UControllerPairingManager::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.DBDRichPresenceSubsystem
// 0x0018 (0x0050 - 0x0038)
class UDBDRichPresenceSubsystem final : public UGameInstanceSubsystem
{
public:
	ERichPresenceUserType                         _userType;                                         // 0x0038(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERichPresenceStatus                           _richPresenceStatus;                               // 0x0039(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _timerRate;                                        // 0x003C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _timerDelay;                                       // 0x0040(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isValidSetup;                                     // 0x0044(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_45[0xB];                                       // 0x0045(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDRichPresenceSubsystem">();
	}
	static class UDBDRichPresenceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDRichPresenceSubsystem>();
	}
};
static_assert(alignof(UDBDRichPresenceSubsystem) == 0x000008, "Wrong alignment on UDBDRichPresenceSubsystem");
static_assert(sizeof(UDBDRichPresenceSubsystem) == 0x000050, "Wrong size on UDBDRichPresenceSubsystem");
static_assert(offsetof(UDBDRichPresenceSubsystem, _userType) == 0x000038, "Member 'UDBDRichPresenceSubsystem::_userType' has a wrong offset!");
static_assert(offsetof(UDBDRichPresenceSubsystem, _richPresenceStatus) == 0x000039, "Member 'UDBDRichPresenceSubsystem::_richPresenceStatus' has a wrong offset!");
static_assert(offsetof(UDBDRichPresenceSubsystem, _timerRate) == 0x00003C, "Member 'UDBDRichPresenceSubsystem::_timerRate' has a wrong offset!");
static_assert(offsetof(UDBDRichPresenceSubsystem, _timerDelay) == 0x000040, "Member 'UDBDRichPresenceSubsystem::_timerDelay' has a wrong offset!");
static_assert(offsetof(UDBDRichPresenceSubsystem, _isValidSetup) == 0x000044, "Member 'UDBDRichPresenceSubsystem::_isValidSetup' has a wrong offset!");

// Class DeadByDaylight.DBDParadiseGameMode
// 0x0000 (0x0400 - 0x0400)
class ADBDParadiseGameMode final : public ADBDBaseGameMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDParadiseGameMode">();
	}
	static class ADBDParadiseGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDParadiseGameMode>();
	}
};
static_assert(alignof(ADBDParadiseGameMode) == 0x000008, "Wrong alignment on ADBDParadiseGameMode");
static_assert(sizeof(ADBDParadiseGameMode) == 0x000400, "Wrong size on ADBDParadiseGameMode");

// Class DeadByDaylight.CoreCursor
// 0x0008 (0x02B0 - 0x02A8)
class UCoreCursor : public UUserWidget
{
public:
	class UScaleBox*                              CursorScaleBox;                                    // 0x02A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreCursor">();
	}
	static class UCoreCursor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreCursor>();
	}
};
static_assert(alignof(UCoreCursor) == 0x000008, "Wrong alignment on UCoreCursor");
static_assert(sizeof(UCoreCursor) == 0x0002B0, "Wrong size on UCoreCursor");
static_assert(offsetof(UCoreCursor, CursorScaleBox) == 0x0002A8, "Member 'UCoreCursor::CursorScaleBox' has a wrong offset!");

// Class DeadByDaylight.CoreHudRootWidget
// 0x00A8 (0x0350 - 0x02A8)
class UCoreHudRootWidget final : public UUserWidget
{
public:
	class UOverlay*                               WidgetContainer;                                   // 0x02A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverlay*                               OuterContainer;                                    // 0x02B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverlay*                               SpectateContainer;                                 // 0x02B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScaleBox*                              ScaleHud;                                          // 0x02C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnfocusedOpacity;                                  // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidget>                ExternalEffectsWidgetClass;                        // 0x02D0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                HudAlertWidgetClass;                               // 0x02D8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                InteractionProgressWidgetClass;                    // 0x02E0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                InteractionPromptsContainerWidgetClass;            // 0x02E8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                ItemInteractionWidgetClass;                        // 0x02F0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                OfferingInteractionWidgetClass;                    // 0x02F8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                CompetenceContainerWidgetClass;                    // 0x0300(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                PingStatusWidgetClass;                             // 0x0308(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                PlayerStatusesWidgetClass;                         // 0x0310(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                ScreenIndicatorWidgetClass;                        // 0x0318(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                StartSequenceWidgetClass;                          // 0x0320(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                StatusEffectWidgetClass;                           // 0x0328(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TScriptInterface<class ICoreBaseViewInterface>> _coreBaseViewInterfaces;                  // 0x0330(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void()>              HUDWidgetsFadeOutCompletedDelegate;                // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintCallable, NativeAccessSpecifierPrivate)

public:
	void ApplyConstrainedAspectRatio(bool isConstrained, float AspectRatio);
	void FadeInWidgets();
	void FadeOutWidgets();
	void SetWidgetsVisibility(bool Visible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreHudRootWidget">();
	}
	static class UCoreHudRootWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreHudRootWidget>();
	}
};
static_assert(alignof(UCoreHudRootWidget) == 0x000008, "Wrong alignment on UCoreHudRootWidget");
static_assert(sizeof(UCoreHudRootWidget) == 0x000350, "Wrong size on UCoreHudRootWidget");
static_assert(offsetof(UCoreHudRootWidget, WidgetContainer) == 0x0002A8, "Member 'UCoreHudRootWidget::WidgetContainer' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, OuterContainer) == 0x0002B0, "Member 'UCoreHudRootWidget::OuterContainer' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, SpectateContainer) == 0x0002B8, "Member 'UCoreHudRootWidget::SpectateContainer' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, ScaleHud) == 0x0002C0, "Member 'UCoreHudRootWidget::ScaleHud' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, UnfocusedOpacity) == 0x0002C8, "Member 'UCoreHudRootWidget::UnfocusedOpacity' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, ExternalEffectsWidgetClass) == 0x0002D0, "Member 'UCoreHudRootWidget::ExternalEffectsWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, HudAlertWidgetClass) == 0x0002D8, "Member 'UCoreHudRootWidget::HudAlertWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, InteractionProgressWidgetClass) == 0x0002E0, "Member 'UCoreHudRootWidget::InteractionProgressWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, InteractionPromptsContainerWidgetClass) == 0x0002E8, "Member 'UCoreHudRootWidget::InteractionPromptsContainerWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, ItemInteractionWidgetClass) == 0x0002F0, "Member 'UCoreHudRootWidget::ItemInteractionWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, OfferingInteractionWidgetClass) == 0x0002F8, "Member 'UCoreHudRootWidget::OfferingInteractionWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, CompetenceContainerWidgetClass) == 0x000300, "Member 'UCoreHudRootWidget::CompetenceContainerWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, PingStatusWidgetClass) == 0x000308, "Member 'UCoreHudRootWidget::PingStatusWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, PlayerStatusesWidgetClass) == 0x000310, "Member 'UCoreHudRootWidget::PlayerStatusesWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, ScreenIndicatorWidgetClass) == 0x000318, "Member 'UCoreHudRootWidget::ScreenIndicatorWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, StartSequenceWidgetClass) == 0x000320, "Member 'UCoreHudRootWidget::StartSequenceWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, StatusEffectWidgetClass) == 0x000328, "Member 'UCoreHudRootWidget::StatusEffectWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, _coreBaseViewInterfaces) == 0x000330, "Member 'UCoreHudRootWidget::_coreBaseViewInterfaces' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, HUDWidgetsFadeOutCompletedDelegate) == 0x000340, "Member 'UCoreHudRootWidget::HUDWidgetsFadeOutCompletedDelegate' has a wrong offset!");

// Class DeadByDaylight.PlayerLockerStateComponent
// 0x00A8 (0x0160 - 0x00B8)
class UPlayerLockerStateComponent final : public UActorComponent
{
public:
	TWeakObjectPtr<class ALocker>                 _lockerPlayerIsHidingIn;                           // 0x00B8(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ALocker>                 _lockerBeingOpenedByPlayer;                        // 0x00C0(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x98];                                      // 0x00C8(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnSurvivorEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason);
	void Multicast_EjectSurvivor(class ALocker* Locker);
	void OnRep_LockerBeingOpenedByPlayer();
	void OnRep_LockerPlayerIsHidingIn();
	void OnSurvivorHealthChanged(EHealthState before, EHealthState after);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerLockerStateComponent">();
	}
	static class UPlayerLockerStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerLockerStateComponent>();
	}
};
static_assert(alignof(UPlayerLockerStateComponent) == 0x000008, "Wrong alignment on UPlayerLockerStateComponent");
static_assert(sizeof(UPlayerLockerStateComponent) == 0x000160, "Wrong size on UPlayerLockerStateComponent");
static_assert(offsetof(UPlayerLockerStateComponent, _lockerPlayerIsHidingIn) == 0x0000B8, "Member 'UPlayerLockerStateComponent::_lockerPlayerIsHidingIn' has a wrong offset!");
static_assert(offsetof(UPlayerLockerStateComponent, _lockerBeingOpenedByPlayer) == 0x0000C0, "Member 'UPlayerLockerStateComponent::_lockerBeingOpenedByPlayer' has a wrong offset!");

// Class DeadByDaylight.DisplayStandCurrencyRequesterComponent
// 0x0010 (0x00C8 - 0x00B8)
class UDisplayStandCurrencyRequesterComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 _menuCurrencyDisplayableClass;                     // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisplayStandCurrencyRequesterComponent">();
	}
	static class UDisplayStandCurrencyRequesterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisplayStandCurrencyRequesterComponent>();
	}
};
static_assert(alignof(UDisplayStandCurrencyRequesterComponent) == 0x000008, "Wrong alignment on UDisplayStandCurrencyRequesterComponent");
static_assert(sizeof(UDisplayStandCurrencyRequesterComponent) == 0x0000C8, "Wrong size on UDisplayStandCurrencyRequesterComponent");
static_assert(offsetof(UDisplayStandCurrencyRequesterComponent, _menuCurrencyDisplayableClass) == 0x0000C0, "Member 'UDisplayStandCurrencyRequesterComponent::_menuCurrencyDisplayableClass' has a wrong offset!");

// Class DeadByDaylight.CrossPlatformManager
// 0x0008 (0x0038 - 0x0030)
class UCrossPlatformManager final : public UObject
{
public:
	bool                                          _crossPlayAllowedByPlatform;                       // 0x0030(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _crossPlayAllowedByKraken;                         // 0x0031(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrossPlatformManager">();
	}
	static class UCrossPlatformManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrossPlatformManager>();
	}
};
static_assert(alignof(UCrossPlatformManager) == 0x000008, "Wrong alignment on UCrossPlatformManager");
static_assert(sizeof(UCrossPlatformManager) == 0x000038, "Wrong size on UCrossPlatformManager");
static_assert(offsetof(UCrossPlatformManager, _crossPlayAllowedByPlatform) == 0x000030, "Member 'UCrossPlatformManager::_crossPlayAllowedByPlatform' has a wrong offset!");
static_assert(offsetof(UCrossPlatformManager, _crossPlayAllowedByKraken) == 0x000031, "Member 'UCrossPlatformManager::_crossPlayAllowedByKraken' has a wrong offset!");

// Class DeadByDaylight.SpecialEventsContainer
// 0x0278 (0x02A8 - 0x0030)
class USpecialEventsContainer final : public UObject
{
public:
	uint8                                         Pad_30[0x278];                                     // 0x0030(0x0278)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecialEventsContainer">();
	}
	static class USpecialEventsContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpecialEventsContainer>();
	}
};
static_assert(alignof(USpecialEventsContainer) == 0x000008, "Wrong alignment on USpecialEventsContainer");
static_assert(sizeof(USpecialEventsContainer) == 0x0002A8, "Wrong size on USpecialEventsContainer");

// Class DeadByDaylight.CrossPromoCampaignsSubsystem
// 0x0058 (0x0090 - 0x0038)
class UCrossPromoCampaignsSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x58];                                      // 0x0038(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrossPromoCampaignsSubsystem">();
	}
	static class UCrossPromoCampaignsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrossPromoCampaignsSubsystem>();
	}
};
static_assert(alignof(UCrossPromoCampaignsSubsystem) == 0x000008, "Wrong alignment on UCrossPromoCampaignsSubsystem");
static_assert(sizeof(UCrossPromoCampaignsSubsystem) == 0x000090, "Wrong size on UCrossPromoCampaignsSubsystem");

// Class DeadByDaylight.CrossPromotionManager
// 0x0028 (0x0060 - 0x0038)
class UCrossPromotionManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x28];                                      // 0x0038(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrossPromotionManager">();
	}
	static class UCrossPromotionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrossPromotionManager>();
	}
};
static_assert(alignof(UCrossPromotionManager) == 0x000008, "Wrong alignment on UCrossPromotionManager");
static_assert(sizeof(UCrossPromotionManager) == 0x000060, "Wrong size on UCrossPromotionManager");

// Class DeadByDaylight.RPCMonitor
// 0x0050 (0x0088 - 0x0038)
class URPCMonitor final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RPCMonitor">();
	}
	static class URPCMonitor* GetDefaultObj()
	{
		return GetDefaultObjImpl<URPCMonitor>();
	}
};
static_assert(alignof(URPCMonitor) == 0x000008, "Wrong alignment on URPCMonitor");
static_assert(sizeof(URPCMonitor) == 0x000088, "Wrong size on URPCMonitor");

// Class DeadByDaylight.CrowBomb
// 0x00A0 (0x0368 - 0x02C8)
class ACrowBomb final : public AGeneratorDrivenActor
{
public:
	float                                         _innerRadius;                                      // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _outerRadius;                                      // 0x02CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxTakeoffDelay;                                  // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _numCrows;                                         // 0x02D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _crowCenterDistance;                               // 0x02D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _eliminationSamples;                               // 0x02DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _eliminationStddev;                                // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   _meshComponentClass;                               // 0x02E8(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UWorldRunawayMeshComponent*>     _crows;                                            // 0x0320(0x0010)(ExportObject, Net, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_330[0x18];                                     // 0x0330(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        _root;                                             // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        _traceStart;                                       // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        _traceEnd;                                         // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _landed;                                           // 0x0360(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_361[0x7];                                      // 0x0361(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void TriggerLand();
	void TriggerTakeOff(const struct FVector& triggerLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrowBomb">();
	}
	static class ACrowBomb* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrowBomb>();
	}
};
static_assert(alignof(ACrowBomb) == 0x000008, "Wrong alignment on ACrowBomb");
static_assert(sizeof(ACrowBomb) == 0x000368, "Wrong size on ACrowBomb");
static_assert(offsetof(ACrowBomb, _innerRadius) == 0x0002C8, "Member 'ACrowBomb::_innerRadius' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _outerRadius) == 0x0002CC, "Member 'ACrowBomb::_outerRadius' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _maxTakeoffDelay) == 0x0002D0, "Member 'ACrowBomb::_maxTakeoffDelay' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _numCrows) == 0x0002D4, "Member 'ACrowBomb::_numCrows' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _crowCenterDistance) == 0x0002D8, "Member 'ACrowBomb::_crowCenterDistance' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _eliminationSamples) == 0x0002DC, "Member 'ACrowBomb::_eliminationSamples' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _eliminationStddev) == 0x0002E0, "Member 'ACrowBomb::_eliminationStddev' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _meshComponentClass) == 0x0002E8, "Member 'ACrowBomb::_meshComponentClass' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _crows) == 0x000320, "Member 'ACrowBomb::_crows' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _root) == 0x000348, "Member 'ACrowBomb::_root' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _traceStart) == 0x000350, "Member 'ACrowBomb::_traceStart' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _traceEnd) == 0x000358, "Member 'ACrowBomb::_traceEnd' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _landed) == 0x000360, "Member 'ACrowBomb::_landed' has a wrong offset!");

// Class DeadByDaylight.DBD_SoundClipUtil
// 0x00C8 (0x0180 - 0x00B8)
class UDBD_SoundClipUtil : public UActorComponent
{
public:
	TArray<struct FMapMeshToAkAudioEvent>         AudioMap;                                          // 0x00B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FMapMeshToAkAudioEvent> _audioEventMap;                                 // 0x00C8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FMapSoundsToAvoid>              _objectsWhoHavePlayedASound;                       // 0x0118(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class UAkAudioEvent*, float>             _nextSoundPlayTime;                                // 0x0128(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnSoundTriggered(class AActor* Actor);
	class UAkAudioEvent* GetAudioEventForMesh(class UStaticMeshComponent* usm);
	void OnCharacterEnterSoundRegion(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBD_SoundClipUtil">();
	}
	static class UDBD_SoundClipUtil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBD_SoundClipUtil>();
	}
};
static_assert(alignof(UDBD_SoundClipUtil) == 0x000008, "Wrong alignment on UDBD_SoundClipUtil");
static_assert(sizeof(UDBD_SoundClipUtil) == 0x000180, "Wrong size on UDBD_SoundClipUtil");
static_assert(offsetof(UDBD_SoundClipUtil, AudioMap) == 0x0000B8, "Member 'UDBD_SoundClipUtil::AudioMap' has a wrong offset!");
static_assert(offsetof(UDBD_SoundClipUtil, _audioEventMap) == 0x0000C8, "Member 'UDBD_SoundClipUtil::_audioEventMap' has a wrong offset!");
static_assert(offsetof(UDBD_SoundClipUtil, _objectsWhoHavePlayedASound) == 0x000118, "Member 'UDBD_SoundClipUtil::_objectsWhoHavePlayedASound' has a wrong offset!");
static_assert(offsetof(UDBD_SoundClipUtil, _nextSoundPlayTime) == 0x000128, "Member 'UDBD_SoundClipUtil::_nextSoundPlayTime' has a wrong offset!");

// Class DeadByDaylight.CurrencyDisplayable
// 0x0068 (0x0308 - 0x02A0)
class ACurrencyDisplayable final : public AActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDSkeletalMeshComponentBudgeted*      SkeletalMeshComponent;                             // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ECurrencyType, class USkeletalMesh*>     _currencyMeshes;                                   // 0x02B0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_300[0x8];                                      // 0x0300(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginDestroySequence_Internal();
	void FinishSpawningCurrency(ECurrencyType currencyType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurrencyDisplayable">();
	}
	static class ACurrencyDisplayable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACurrencyDisplayable>();
	}
};
static_assert(alignof(ACurrencyDisplayable) == 0x000008, "Wrong alignment on ACurrencyDisplayable");
static_assert(sizeof(ACurrencyDisplayable) == 0x000308, "Wrong size on ACurrencyDisplayable");
static_assert(offsetof(ACurrencyDisplayable, SkeletalMeshComponent) == 0x0002A8, "Member 'ACurrencyDisplayable::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(ACurrencyDisplayable, _currencyMeshes) == 0x0002B0, "Member 'ACurrencyDisplayable::_currencyMeshes' has a wrong offset!");

// Class DeadByDaylight.IgnorePlayersCollisionsComponent
// 0x0010 (0x0118 - 0x0108)
class UIgnorePlayersCollisionsComponent final : public UIgnoreCollisionsComponent
{
public:
	uint8                                         Pad_108[0x10];                                     // 0x0108(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgnorePlayersCollisionsComponent">();
	}
	static class UIgnorePlayersCollisionsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgnorePlayersCollisionsComponent>();
	}
};
static_assert(alignof(UIgnorePlayersCollisionsComponent) == 0x000008, "Wrong alignment on UIgnorePlayersCollisionsComponent");
static_assert(sizeof(UIgnorePlayersCollisionsComponent) == 0x000118, "Wrong size on UIgnorePlayersCollisionsComponent");

// Class DeadByDaylight.SurvivorDisconnectionComponent
// 0x0000 (0x00B8 - 0x00B8)
class USurvivorDisconnectionComponent final : public UActorComponent
{
public:
	void Authority_OnPlayerDisconnected(class ADBDPlayer* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorDisconnectionComponent">();
	}
	static class USurvivorDisconnectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorDisconnectionComponent>();
	}
};
static_assert(alignof(USurvivorDisconnectionComponent) == 0x000008, "Wrong alignment on USurvivorDisconnectionComponent");
static_assert(sizeof(USurvivorDisconnectionComponent) == 0x0000B8, "Wrong size on USurvivorDisconnectionComponent");

// Class DeadByDaylight.CurveFloatNetIdSubsystem
// 0x0060 (0x0098 - 0x0038)
class UCurveFloatNetIdSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x60];                                      // 0x0038(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurveFloatNetIdSubsystem">();
	}
	static class UCurveFloatNetIdSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurveFloatNetIdSubsystem>();
	}
};
static_assert(alignof(UCurveFloatNetIdSubsystem) == 0x000008, "Wrong alignment on UCurveFloatNetIdSubsystem");
static_assert(sizeof(UCurveFloatNetIdSubsystem) == 0x000098, "Wrong size on UCurveFloatNetIdSubsystem");

// Class DeadByDaylight.HudUIUtilities
// 0x0000 (0x0030 - 0x0030)
class UHudUIUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HudUIUtilities">();
	}
	static class UHudUIUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHudUIUtilities>();
	}
};
static_assert(alignof(UHudUIUtilities) == 0x000008, "Wrong alignment on UHudUIUtilities");
static_assert(sizeof(UHudUIUtilities) == 0x000030, "Wrong size on UHudUIUtilities");

// Class DeadByDaylight.CustomizationDescription
// 0x0010 (0x0048 - 0x0038)
class UCustomizationDescription final : public UDataAsset
{
public:
	TArray<struct FCustomizedMeshPart>            Parts;                                             // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationDescription">();
	}
	static class UCustomizationDescription* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationDescription>();
	}
};
static_assert(alignof(UCustomizationDescription) == 0x000008, "Wrong alignment on UCustomizationDescription");
static_assert(sizeof(UCustomizationDescription) == 0x000048, "Wrong size on UCustomizationDescription");
static_assert(offsetof(UCustomizationDescription, Parts) == 0x000038, "Member 'UCustomizationDescription::Parts' has a wrong offset!");

// Class DeadByDaylight.SurvivorAttackableComponent
// 0x0028 (0x00E0 - 0x00B8)
class USurvivorAttackableComponent final : public UAttackableComponent
{
public:
	uint8                                         Pad_B8[0x28];                                      // 0x00B8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_HitCosmetic(const class AActor* Attacker, EAttackType attackType, bool causeKO, bool IsWeaponHit);
	void Multicast_HitCosmetic(const struct FPlayerHitCosmeticParams& params);
	void Multicast_HitCosmetic_NonLocal(const struct FPlayerHitCosmeticParams& params);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorAttackableComponent">();
	}
	static class USurvivorAttackableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorAttackableComponent>();
	}
};
static_assert(alignof(USurvivorAttackableComponent) == 0x000008, "Wrong alignment on USurvivorAttackableComponent");
static_assert(sizeof(USurvivorAttackableComponent) == 0x0000E0, "Wrong size on USurvivorAttackableComponent");

// Class DeadByDaylight.DBDDebugInputComponent
// 0x0020 (0x00D8 - 0x00B8)
class UDBDDebugInputComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x20];                                      // 0x00B8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_ItsAlive(bool aliveEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDDebugInputComponent">();
	}
	static class UDBDDebugInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDDebugInputComponent>();
	}
};
static_assert(alignof(UDBDDebugInputComponent) == 0x000008, "Wrong alignment on UDBDDebugInputComponent");
static_assert(sizeof(UDBDDebugInputComponent) == 0x0000D8, "Wrong size on UDBDDebugInputComponent");

// Class DeadByDaylight.CustomizationHelper
// 0x0000 (0x0030 - 0x0030)
class UCustomizationHelper final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationHelper">();
	}
	static class UCustomizationHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationHelper>();
	}
};
static_assert(alignof(UCustomizationHelper) == 0x000008, "Wrong alignment on UCustomizationHelper");
static_assert(sizeof(UCustomizationHelper) == 0x000030, "Wrong size on UCustomizationHelper");

// Class DeadByDaylight.HookAnalyticEvents
// 0x0000 (0x0000 - 0x0000)
class IHookAnalyticEvents final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HookAnalyticEvents">();
	}
	static class IHookAnalyticEvents* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHookAnalyticEvents>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHookAnalyticEvents) == 0x000001, "Wrong alignment on IHookAnalyticEvents");
static_assert(sizeof(IHookAnalyticEvents) == 0x000001, "Wrong size on IHookAnalyticEvents");

// Class DeadByDaylight.CustomizedAnimationComponent
// 0x0020 (0x00D8 - 0x00B8)
class UCustomizedAnimationComponent final : public UActorComponent
{
public:
	class ADBDBasePlayer*                         _owner;                                            // 0x00B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCustomizedSkeletalMesh*                _customizedSkeletalMesh;                           // 0x00C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UAnimInstance>              _defaultAnimClass;                                 // 0x00C8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCustomizationChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizedAnimationComponent">();
	}
	static class UCustomizedAnimationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizedAnimationComponent>();
	}
};
static_assert(alignof(UCustomizedAnimationComponent) == 0x000008, "Wrong alignment on UCustomizedAnimationComponent");
static_assert(sizeof(UCustomizedAnimationComponent) == 0x0000D8, "Wrong size on UCustomizedAnimationComponent");
static_assert(offsetof(UCustomizedAnimationComponent, _owner) == 0x0000B8, "Member 'UCustomizedAnimationComponent::_owner' has a wrong offset!");
static_assert(offsetof(UCustomizedAnimationComponent, _customizedSkeletalMesh) == 0x0000C0, "Member 'UCustomizedAnimationComponent::_customizedSkeletalMesh' has a wrong offset!");
static_assert(offsetof(UCustomizedAnimationComponent, _defaultAnimClass) == 0x0000C8, "Member 'UCustomizedAnimationComponent::_defaultAnimClass' has a wrong offset!");

// Class DeadByDaylight.SeancePerkIconStrategy
// 0x0000 (0x0038 - 0x0038)
class USeancePerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeancePerkIconStrategy">();
	}
	static class USeancePerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeancePerkIconStrategy>();
	}
};
static_assert(alignof(USeancePerkIconStrategy) == 0x000008, "Wrong alignment on USeancePerkIconStrategy");
static_assert(sizeof(USeancePerkIconStrategy) == 0x000038, "Wrong size on USeancePerkIconStrategy");

// Class DeadByDaylight.CustomizedAudioComponent
// 0x0160 (0x0218 - 0x00B8)
class UCustomizedAudioComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(EAudioCustomizationCategory category, const class FString& switchState)> OnCustomizedAudioSwitchStateChanged; // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FName& outfitAudioStateCollection)> OnOutfitCustomizedAudioStateCollectionChanged; // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0xB0];                                      // 0x00D8(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AudioCharacterNameDefaultSwitchState;              // 0x0188(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AudioCharacterSubNameDefaultSwitchState;           // 0x0198(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AudioCharacterHeadDefaultSwitchState;              // 0x01A8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AudioCharacterClothesDefaultSwitchState;           // 0x01B8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AudioCharacterShoesDefaultSwitchState;             // 0x01C8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AudioCharacterWeaponDefaultSwitchState;            // 0x01D8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AudioCharacterAmbianceDefaultSwitchState;          // 0x01E8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AudioCharacterStateDefaultSwitchState;             // 0x01F8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   AudioCharacterDefaultOutfitCollectionState;        // 0x0208(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_214[0x4];                                      // 0x0214(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString GetAudioSwitchState(EAudioCustomizationCategory audioCustomizationCategory) const;
	class FName GetOutfitCustomizedAudioCollectionState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizedAudioComponent">();
	}
	static class UCustomizedAudioComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizedAudioComponent>();
	}
};
static_assert(alignof(UCustomizedAudioComponent) == 0x000008, "Wrong alignment on UCustomizedAudioComponent");
static_assert(sizeof(UCustomizedAudioComponent) == 0x000218, "Wrong size on UCustomizedAudioComponent");
static_assert(offsetof(UCustomizedAudioComponent, OnCustomizedAudioSwitchStateChanged) == 0x0000B8, "Member 'UCustomizedAudioComponent::OnCustomizedAudioSwitchStateChanged' has a wrong offset!");
static_assert(offsetof(UCustomizedAudioComponent, OnOutfitCustomizedAudioStateCollectionChanged) == 0x0000C8, "Member 'UCustomizedAudioComponent::OnOutfitCustomizedAudioStateCollectionChanged' has a wrong offset!");
static_assert(offsetof(UCustomizedAudioComponent, AudioCharacterNameDefaultSwitchState) == 0x000188, "Member 'UCustomizedAudioComponent::AudioCharacterNameDefaultSwitchState' has a wrong offset!");
static_assert(offsetof(UCustomizedAudioComponent, AudioCharacterSubNameDefaultSwitchState) == 0x000198, "Member 'UCustomizedAudioComponent::AudioCharacterSubNameDefaultSwitchState' has a wrong offset!");
static_assert(offsetof(UCustomizedAudioComponent, AudioCharacterHeadDefaultSwitchState) == 0x0001A8, "Member 'UCustomizedAudioComponent::AudioCharacterHeadDefaultSwitchState' has a wrong offset!");
static_assert(offsetof(UCustomizedAudioComponent, AudioCharacterClothesDefaultSwitchState) == 0x0001B8, "Member 'UCustomizedAudioComponent::AudioCharacterClothesDefaultSwitchState' has a wrong offset!");
static_assert(offsetof(UCustomizedAudioComponent, AudioCharacterShoesDefaultSwitchState) == 0x0001C8, "Member 'UCustomizedAudioComponent::AudioCharacterShoesDefaultSwitchState' has a wrong offset!");
static_assert(offsetof(UCustomizedAudioComponent, AudioCharacterWeaponDefaultSwitchState) == 0x0001D8, "Member 'UCustomizedAudioComponent::AudioCharacterWeaponDefaultSwitchState' has a wrong offset!");
static_assert(offsetof(UCustomizedAudioComponent, AudioCharacterAmbianceDefaultSwitchState) == 0x0001E8, "Member 'UCustomizedAudioComponent::AudioCharacterAmbianceDefaultSwitchState' has a wrong offset!");
static_assert(offsetof(UCustomizedAudioComponent, AudioCharacterStateDefaultSwitchState) == 0x0001F8, "Member 'UCustomizedAudioComponent::AudioCharacterStateDefaultSwitchState' has a wrong offset!");
static_assert(offsetof(UCustomizedAudioComponent, AudioCharacterDefaultOutfitCollectionState) == 0x000208, "Member 'UCustomizedAudioComponent::AudioCharacterDefaultOutfitCollectionState' has a wrong offset!");

// Class DeadByDaylight.CustomizedSkeletalMesh
// 0x0378 (0x0430 - 0x00B8)
class UCustomizedSkeletalMesh final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(ECustomizationCategory category, class USkeletalMeshComponent* Mesh)> OnMeshSwitchBP; // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x18];                                      // 0x00C8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnCustomizationReady;                              // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0x30];                                      // 0x00F0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class USkinnedMeshComponent*                  _meshOwner;                                        // 0x0120(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<ECustomizationCategory>                  _ignoredItemCategories;                            // 0x0130(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<class USkeletalMeshComponent*>         _cosmeticPiecesMesh;                               // 0x0180(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<ECustomizationCategory, class USkeletalMeshComponent*> _cosmeticPiecesMeshPerCategory;      // 0x0190(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class USkeletalMeshComponent*>         _slaves;                                           // 0x01E0(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<ECustomizationCategory, class AItemVfx*> _itemVfxs;                                         // 0x01F0(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_240[0xA0];                                     // 0x0240(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _characterIdOverride;                              // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E4[0x5C];                                     // 0x02E4(0x005C)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECustomizationCategory, struct FCosmeticPieceMeshLoadingData> _cosmeticPieceMeshesBeingLoaded; // 0x0340(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_390[0xA0];                                     // 0x0390(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearAllVfxs();
	void CopyCustomization(const class UCustomizedSkeletalMesh* CopyFrom);
	class USkinnedMeshComponent* GetMeshOwner();
	void SetAllAccessoriesVisibility(bool Visible);
	void SetAllVfxsVisibility(bool Visible);
	void SetCastShadow(bool CastShadow);
	void SetMeshOwner(class USkinnedMeshComponent* Mesh);
	void SetMeshVisibility(bool Visible);
	void SetVfxsVisibility(ECustomizationCategory category, bool Visible);

	bool Contains(const TArray<class FName>& itemIds) const;
	const TArray<class USkeletalMeshComponent*> GetComponents() const;
	TArray<class FName> GetCurrentCustomizationItems() const;
	bool GetMeshVisibility() const;
	class USkeletalMeshComponent* GetSkeletalMesh(ECustomizationCategory category) const;
	bool HasValidCustomization() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizedSkeletalMesh">();
	}
	static class UCustomizedSkeletalMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizedSkeletalMesh>();
	}
};
static_assert(alignof(UCustomizedSkeletalMesh) == 0x000008, "Wrong alignment on UCustomizedSkeletalMesh");
static_assert(sizeof(UCustomizedSkeletalMesh) == 0x000430, "Wrong size on UCustomizedSkeletalMesh");
static_assert(offsetof(UCustomizedSkeletalMesh, OnMeshSwitchBP) == 0x0000B8, "Member 'UCustomizedSkeletalMesh::OnMeshSwitchBP' has a wrong offset!");
static_assert(offsetof(UCustomizedSkeletalMesh, OnCustomizationReady) == 0x0000E0, "Member 'UCustomizedSkeletalMesh::OnCustomizationReady' has a wrong offset!");
static_assert(offsetof(UCustomizedSkeletalMesh, _meshOwner) == 0x000120, "Member 'UCustomizedSkeletalMesh::_meshOwner' has a wrong offset!");
static_assert(offsetof(UCustomizedSkeletalMesh, _ignoredItemCategories) == 0x000130, "Member 'UCustomizedSkeletalMesh::_ignoredItemCategories' has a wrong offset!");
static_assert(offsetof(UCustomizedSkeletalMesh, _cosmeticPiecesMesh) == 0x000180, "Member 'UCustomizedSkeletalMesh::_cosmeticPiecesMesh' has a wrong offset!");
static_assert(offsetof(UCustomizedSkeletalMesh, _cosmeticPiecesMeshPerCategory) == 0x000190, "Member 'UCustomizedSkeletalMesh::_cosmeticPiecesMeshPerCategory' has a wrong offset!");
static_assert(offsetof(UCustomizedSkeletalMesh, _slaves) == 0x0001E0, "Member 'UCustomizedSkeletalMesh::_slaves' has a wrong offset!");
static_assert(offsetof(UCustomizedSkeletalMesh, _itemVfxs) == 0x0001F0, "Member 'UCustomizedSkeletalMesh::_itemVfxs' has a wrong offset!");
static_assert(offsetof(UCustomizedSkeletalMesh, _characterIdOverride) == 0x0002E0, "Member 'UCustomizedSkeletalMesh::_characterIdOverride' has a wrong offset!");
static_assert(offsetof(UCustomizedSkeletalMesh, _cosmeticPieceMeshesBeingLoaded) == 0x000340, "Member 'UCustomizedSkeletalMesh::_cosmeticPieceMeshesBeingLoaded' has a wrong offset!");

// Class DeadByDaylight.DBDCharacterUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDCharacterUtilities final : public UBlueprintFunctionLibrary
{
public:
	static EPlayerRole GetLocallyObservedPlayerRole(const class UObject* WorldContextObject);
	static bool IsAceVisconti(const class ADBDBasePlayer* TargetPlayer);
	static bool IsAdamFrancis(const class ADBDBasePlayer* TargetPlayer);
	static bool IsAshleyWilliams(const class ADBDBasePlayer* TargetPlayer);
	static bool IsClaudetteMorel(const class ADBDBasePlayer* TargetPlayer);
	static bool IsDavidKing(const class ADBDBasePlayer* TargetPlayer);
	static bool IsDavidTapp(const class ADBDBasePlayer* TargetPlayer);
	static bool IsDwightFairfield(const class ADBDBasePlayer* TargetPlayer);
	static bool IsFengMin(const class ADBDBasePlayer* TargetPlayer);
	static bool IsInDreamworld(const class ADBDPlayer* Player);
	static bool IsInSameTeamAsLocallyObservedPlayer(const class ADBDPlayer* TargetPlayer);
	static bool IsJakePark(const class ADBDBasePlayer* TargetPlayer);
	static bool IsJaneRomero(const class ADBDBasePlayer* TargetPlayer);
	static bool IsJeffJohansen(const class ADBDBasePlayer* TargetPlayer);
	static bool IsKateDenson(const class ADBDBasePlayer* TargetPlayer);
	static bool IsLaurieStrode(const class ADBDBasePlayer* TargetPlayer);
	static bool IsMegThomas(const class ADBDBasePlayer* TargetPlayer);
	static bool IsNancyWheeler(const class ADBDBasePlayer* TargetPlayer);
	static bool IsNeaKarlsson(const class ADBDBasePlayer* TargetPlayer);
	static bool IsPlague(const class ADBDBasePlayer* TargetPlayer);
	static bool IsQuentinSmith(const class ADBDBasePlayer* TargetPlayer);
	static bool IsSlasherLocallyObserved(const class UObject* WorldContextObject);
	static bool IsSteveHarrington(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheBlight(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheCannibal(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheClown(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheDemogorgon(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheDoctor(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheExecutioner(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheGhost(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheGoodGuy(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheHag(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheHillBilly(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheHuntress(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheLegion(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheNightmare(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheNurse(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheOni(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheOnryo(const class ADBDBasePlayer* TargetPlayer);
	static bool IsThePig(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheShape(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheSpirit(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheTrapper(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheTrickster(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheTwins(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheTwins_Brother(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheTwins_Sister(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheWraith(const class ADBDBasePlayer* TargetPlayer);
	static bool IsWilliamBillOverbeck(const class ADBDBasePlayer* TargetPlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDCharacterUtilities">();
	}
	static class UDBDCharacterUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDCharacterUtilities>();
	}
};
static_assert(alignof(UDBDCharacterUtilities) == 0x000008, "Wrong alignment on UDBDCharacterUtilities");
static_assert(sizeof(UDBDCharacterUtilities) == 0x000030, "Wrong size on UDBDCharacterUtilities");

// Class DeadByDaylight.CustomWidgetWrapperInitializer
// 0x0010 (0x02B8 - 0x02A8)
class UCustomWidgetWrapperInitializer final : public UUserWidget
{
public:
	class UCustomWidgetWrapper*                   ListeningWrapper;                                  // 0x02A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomWidgetWrapperInitializer">();
	}
	static class UCustomWidgetWrapperInitializer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomWidgetWrapperInitializer>();
	}
};
static_assert(alignof(UCustomWidgetWrapperInitializer) == 0x000008, "Wrong alignment on UCustomWidgetWrapperInitializer");
static_assert(sizeof(UCustomWidgetWrapperInitializer) == 0x0002B8, "Wrong size on UCustomWidgetWrapperInitializer");
static_assert(offsetof(UCustomWidgetWrapperInitializer, ListeningWrapper) == 0x0002A8, "Member 'UCustomWidgetWrapperInitializer::ListeningWrapper' has a wrong offset!");

// Class DeadByDaylight.PremiumTransactionSubsystem
// 0x0020 (0x0058 - 0x0038)
class UPremiumTransactionSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PremiumTransactionSubsystem">();
	}
	static class UPremiumTransactionSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPremiumTransactionSubsystem>();
	}
};
static_assert(alignof(UPremiumTransactionSubsystem) == 0x000008, "Wrong alignment on UPremiumTransactionSubsystem");
static_assert(sizeof(UPremiumTransactionSubsystem) == 0x000058, "Wrong size on UPremiumTransactionSubsystem");

// Class DeadByDaylight.CustomWidgetWrapper
// 0x0050 (0x01E8 - 0x0198)
class UCustomWidgetWrapper : public UCanvasPanel
{
public:
	TMulticastInlineDelegate<void(int32 Version)> OnVersion;                                         // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ID;                                                // 0x01A8(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B4[0x4];                                      // 0x01B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCustomWidgetWrapper*                   ManuallyParentWrapper;                             // 0x01B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UCustomWidgetWrapper*>           ManuallyChildWrappers;                             // 0x01C0(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UCustomWidgetWrapperInitializer*        InitializerWidget;                                 // 0x01D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D8[0x10];                                     // 0x01D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyOpacity(float Opacity);
	void ApplyScale(float Scale);
	void ApplyVersion(int32 Version);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomWidgetWrapper">();
	}
	static class UCustomWidgetWrapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomWidgetWrapper>();
	}
};
static_assert(alignof(UCustomWidgetWrapper) == 0x000008, "Wrong alignment on UCustomWidgetWrapper");
static_assert(sizeof(UCustomWidgetWrapper) == 0x0001E8, "Wrong size on UCustomWidgetWrapper");
static_assert(offsetof(UCustomWidgetWrapper, OnVersion) == 0x000198, "Member 'UCustomWidgetWrapper::OnVersion' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper, ID) == 0x0001A8, "Member 'UCustomWidgetWrapper::ID' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper, ManuallyParentWrapper) == 0x0001B8, "Member 'UCustomWidgetWrapper::ManuallyParentWrapper' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper, ManuallyChildWrappers) == 0x0001C0, "Member 'UCustomWidgetWrapper::ManuallyChildWrappers' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper, InitializerWidget) == 0x0001D0, "Member 'UCustomWidgetWrapper::InitializerWidget' has a wrong offset!");

// Class DeadByDaylight.DBDPlayerState_Menu
// 0x0008 (0x0878 - 0x0870)
class ADBDPlayerState_Menu : public ADBDPlayerState
{
public:
	uint8                                         Pad_870[0x8];                                      // 0x0870(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_ChangeCharacterClass(const class FName& CharacterClass, const class FName& previousClass, const int32 CharacterId, int32 classChangeAttempt);
	void Multicast_SetSelectedCharacterCustomization(EPlayerRole forRole, int32 ID, const struct FEquippedPlayerCustomization& Customization);
	void Multicast_SetSelectedCharacterId(EPlayerRole forRole, int32 ID, bool updateDisplayData);
	void Server_NotifyOnRep();
	void Server_SetCharacterClass(const class FName& CharacterClass, const class FName& previousClass, const int32 CharacterId, int32 classChangeAttempt, bool callOnRep);
	void Server_SetEquipment(ELoadoutSlot Slot, class FName ItemId, bool callOnRep);
	void Server_SetEquipmentAddons(const TArray<class FName>& addonItemIds, bool callOnRep);
	void Server_SetSelectedCharacterId(int32 ID, bool updateDisplayData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerState_Menu">();
	}
	static class ADBDPlayerState_Menu* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDPlayerState_Menu>();
	}
};
static_assert(alignof(ADBDPlayerState_Menu) == 0x000008, "Wrong alignment on ADBDPlayerState_Menu");
static_assert(sizeof(ADBDPlayerState_Menu) == 0x000878, "Wrong size on ADBDPlayerState_Menu");

// Class DeadByDaylight.DBDPlayerState_Lobby
// 0x0008 (0x0880 - 0x0878)
class ADBDPlayerState_Lobby final : public ADBDPlayerState_Menu
{
public:
	bool                                          IsOwnershipValidated;                              // 0x0878(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_879[0x7];                                      // 0x0879(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerState_Lobby">();
	}
	static class ADBDPlayerState_Lobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDPlayerState_Lobby>();
	}
};
static_assert(alignof(ADBDPlayerState_Lobby) == 0x000008, "Wrong alignment on ADBDPlayerState_Lobby");
static_assert(sizeof(ADBDPlayerState_Lobby) == 0x000880, "Wrong size on ADBDPlayerState_Lobby");
static_assert(offsetof(ADBDPlayerState_Lobby, IsOwnershipValidated) == 0x000878, "Member 'ADBDPlayerState_Lobby::IsOwnershipValidated' has a wrong offset!");

// Class DeadByDaylight.CustomWidgetWrapper_HudEditor
// 0x00E8 (0x02D0 - 0x01E8)
class UCustomWidgetWrapper_HudEditor final : public UCustomWidgetWrapper
{
public:
	float                                         MinOpacity;                                        // 0x01E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxOpacity;                                        // 0x01EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinScale;                                          // 0x01F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxScale;                                          // 0x01F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NbVersions;                                        // 0x01F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HideUnderOpacity;                                  // 0x01FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 HiddenStatusTintColor;                             // 0x0200(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HiddenStatusOpacity;                               // 0x0204(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverlapAboveSizeRatio;                             // 0x0208(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20C[0x4];                                      // 0x020C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  IgnoreOverlapIds;                                  // 0x0210(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FHudEditorDragFromParentAxisLimit      ParentDragLimitX;                                  // 0x0230(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FHudEditorDragFromParentAxisLimit      ParentDragLimitY;                                  // 0x0244(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsEditingHudByInput;                               // 0x0258(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_259[0x3];                                      // 0x0259(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 OverlapStatusTintColor;                            // 0x025C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_260[0x70];                                     // 0x0260(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddToTranslation(const struct FVector2D& Translation);
	void ApplyScaleWithOverlappingWrappers(float Scale, class UWidget* Widget, const TArray<class UCustomWidgetWrapper_HudEditor*>& allEditableWrappers, bool needDetectOverlapping);
	void ClampToViewport();
	void FlipPositionWithChildLinkWidget();
	void FlipScreenPosition();

	bool CanEditOpacity() const;
	bool CanEditScale() const;
	float GetOpacity() const;
	float GetScale() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomWidgetWrapper_HudEditor">();
	}
	static class UCustomWidgetWrapper_HudEditor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomWidgetWrapper_HudEditor>();
	}
};
static_assert(alignof(UCustomWidgetWrapper_HudEditor) == 0x000008, "Wrong alignment on UCustomWidgetWrapper_HudEditor");
static_assert(sizeof(UCustomWidgetWrapper_HudEditor) == 0x0002D0, "Wrong size on UCustomWidgetWrapper_HudEditor");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, MinOpacity) == 0x0001E8, "Member 'UCustomWidgetWrapper_HudEditor::MinOpacity' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, MaxOpacity) == 0x0001EC, "Member 'UCustomWidgetWrapper_HudEditor::MaxOpacity' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, MinScale) == 0x0001F0, "Member 'UCustomWidgetWrapper_HudEditor::MinScale' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, MaxScale) == 0x0001F4, "Member 'UCustomWidgetWrapper_HudEditor::MaxScale' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, NbVersions) == 0x0001F8, "Member 'UCustomWidgetWrapper_HudEditor::NbVersions' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, HideUnderOpacity) == 0x0001FC, "Member 'UCustomWidgetWrapper_HudEditor::HideUnderOpacity' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, HiddenStatusTintColor) == 0x000200, "Member 'UCustomWidgetWrapper_HudEditor::HiddenStatusTintColor' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, HiddenStatusOpacity) == 0x000204, "Member 'UCustomWidgetWrapper_HudEditor::HiddenStatusOpacity' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, OverlapAboveSizeRatio) == 0x000208, "Member 'UCustomWidgetWrapper_HudEditor::OverlapAboveSizeRatio' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, IgnoreOverlapIds) == 0x000210, "Member 'UCustomWidgetWrapper_HudEditor::IgnoreOverlapIds' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, ParentDragLimitX) == 0x000230, "Member 'UCustomWidgetWrapper_HudEditor::ParentDragLimitX' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, ParentDragLimitY) == 0x000244, "Member 'UCustomWidgetWrapper_HudEditor::ParentDragLimitY' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, IsEditingHudByInput) == 0x000258, "Member 'UCustomWidgetWrapper_HudEditor::IsEditingHudByInput' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, OverlapStatusTintColor) == 0x00025C, "Member 'UCustomWidgetWrapper_HudEditor::OverlapStatusTintColor' has a wrong offset!");

// Class DeadByDaylight.PlayerNameRegistration
// 0x0068 (0x0098 - 0x0030)
class UPlayerNameRegistration final : public UObject
{
public:
	uint8                                         Pad_30[0x68];                                      // 0x0030(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerNameRegistration">();
	}
	static class UPlayerNameRegistration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerNameRegistration>();
	}
};
static_assert(alignof(UPlayerNameRegistration) == 0x000008, "Wrong alignment on UPlayerNameRegistration");
static_assert(sizeof(UPlayerNameRegistration) == 0x000098, "Wrong size on UPlayerNameRegistration");

// Class DeadByDaylight.CustomWidgetWrapper_InGame
// 0x0038 (0x0220 - 0x01E8)
class UCustomWidgetWrapper_InGame final : public UCustomWidgetWrapper
{
public:
	int32                                         VirtualJoystickIndex;                              // 0x01E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EC[0x34];                                     // 0x01EC(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateSettings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomWidgetWrapper_InGame">();
	}
	static class UCustomWidgetWrapper_InGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomWidgetWrapper_InGame>();
	}
};
static_assert(alignof(UCustomWidgetWrapper_InGame) == 0x000008, "Wrong alignment on UCustomWidgetWrapper_InGame");
static_assert(sizeof(UCustomWidgetWrapper_InGame) == 0x000220, "Wrong size on UCustomWidgetWrapper_InGame");
static_assert(offsetof(UCustomWidgetWrapper_InGame, VirtualJoystickIndex) == 0x0001E8, "Member 'UCustomWidgetWrapper_InGame::VirtualJoystickIndex' has a wrong offset!");

// Class DeadByDaylight.DBDPlayerController_Menu
// 0x0000 (0x0938 - 0x0938)
class ADBDPlayerController_Menu final : public ADBDPlayerControllerBase
{
public:
	void Authority_SetPlayerReady(bool IsReady);
	void Authority_TogglePlayerReadyState();
	void Server_GamePresetDataFromClient(const struct FGamePresetData& GameState);
	void Server_OverrideBackendGameplayTunables(const struct FBackendGameplayTunablesContainer& tunablesOverride);
	void Server_SetCharacterData(int32 characterIndex, const struct FPlayerDataSync& PlayerDataSync);
	void Server_SetCharacterLevel(int32 CharacterLevel, int32 PrestigeLevel, bool callOnRep);
	void Server_SetCustomizationCharm(class FName CharmId, int8 slotIndex);
	void Server_SetCustomizationMeshes(const struct FCharacterCustomization& Customization);
	void Server_SetEquipedPerks(const TArray<class FName>& perkIds, const TArray<int32>& perkLevels, bool callOnRep, bool areRandomPerks);
	void Server_SetPlayerLoadout(const struct FPlayerLoadoutData& desiredLoadout);
	void Server_SetPlayerReady(bool IsReady);
	void Server_SetReadyToTravel();
	void SetPlayerReady(bool IsReady);
	void TogglePlayerReadyState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerController_Menu">();
	}
	static class ADBDPlayerController_Menu* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDPlayerController_Menu>();
	}
};
static_assert(alignof(ADBDPlayerController_Menu) == 0x000008, "Wrong alignment on ADBDPlayerController_Menu");
static_assert(sizeof(ADBDPlayerController_Menu) == 0x000938, "Wrong size on ADBDPlayerController_Menu");

// Class DeadByDaylight.DataAssetStatFloatValueStrategy
// 0x0088 (0x0128 - 0x00A0)
class UDataAssetStatFloatValueStrategy final : public UDataAssetFloatValueStrategy
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FStatModifier>                  _statModifiers;                                    // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x60];                                      // 0x00C8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataAssetStatFloatValueStrategy">();
	}
	static class UDataAssetStatFloatValueStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataAssetStatFloatValueStrategy>();
	}
};
static_assert(alignof(UDataAssetStatFloatValueStrategy) == 0x000008, "Wrong alignment on UDataAssetStatFloatValueStrategy");
static_assert(sizeof(UDataAssetStatFloatValueStrategy) == 0x000128, "Wrong size on UDataAssetStatFloatValueStrategy");
static_assert(offsetof(UDataAssetStatFloatValueStrategy, _statModifiers) == 0x0000B8, "Member 'UDataAssetStatFloatValueStrategy::_statModifiers' has a wrong offset!");

// Class DeadByDaylight.PlayerSkeletalMeshComponentBudgeted
// 0x0000 (0x1140 - 0x1140)
class UPlayerSkeletalMeshComponentBudgeted final : public UDBDSkeletalMeshComponentBudgeted
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerSkeletalMeshComponentBudgeted">();
	}
	static class UPlayerSkeletalMeshComponentBudgeted* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerSkeletalMeshComponentBudgeted>();
	}
};
static_assert(alignof(UPlayerSkeletalMeshComponentBudgeted) == 0x000010, "Wrong alignment on UPlayerSkeletalMeshComponentBudgeted");
static_assert(sizeof(UPlayerSkeletalMeshComponentBudgeted) == 0x001140, "Wrong size on UPlayerSkeletalMeshComponentBudgeted");

// Class DeadByDaylight.DBDActorSpawnerActor2
// 0x0008 (0x02B8 - 0x02B0)
class ADBDActorSpawnerActor2 final : public ADBDBaseActorSpawnerActor2
{
public:
	class UActorSpawner*                          actorSpawnerComponent;                             // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDActorSpawnerActor2">();
	}
	static class ADBDActorSpawnerActor2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDActorSpawnerActor2>();
	}
};
static_assert(alignof(ADBDActorSpawnerActor2) == 0x000008, "Wrong alignment on ADBDActorSpawnerActor2");
static_assert(sizeof(ADBDActorSpawnerActor2) == 0x0002B8, "Wrong size on ADBDActorSpawnerActor2");
static_assert(offsetof(ADBDActorSpawnerActor2, actorSpawnerComponent) == 0x0002B0, "Member 'ADBDActorSpawnerActor2::actorSpawnerComponent' has a wrong offset!");

// Class DeadByDaylight.DisableOutlineComponent
// 0x0020 (0x00D8 - 0x00B8)
class UDisableOutlineComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   _enableOutlineEvents;                              // 0x00C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisableOutlineComponent">();
	}
	static class UDisableOutlineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisableOutlineComponent>();
	}
};
static_assert(alignof(UDisableOutlineComponent) == 0x000008, "Wrong alignment on UDisableOutlineComponent");
static_assert(sizeof(UDisableOutlineComponent) == 0x0000D8, "Wrong size on UDisableOutlineComponent");
static_assert(offsetof(UDisableOutlineComponent, _enableOutlineEvents) == 0x0000C8, "Member 'UDisableOutlineComponent::_enableOutlineEvents' has a wrong offset!");

// Class DeadByDaylight.DBDLobbyHud
// 0x0000 (0x03A0 - 0x03A0)
class ADBDLobbyHud final : public ADBDBaseHud
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDLobbyHud">();
	}
	static class ADBDLobbyHud* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDLobbyHud>();
	}
};
static_assert(alignof(ADBDLobbyHud) == 0x000008, "Wrong alignment on ADBDLobbyHud");
static_assert(sizeof(ADBDLobbyHud) == 0x0003A0, "Wrong size on ADBDLobbyHud");

// Class DeadByDaylight.DBDActorVariationSpawnerActor2
// 0x0008 (0x02B8 - 0x02B0)
class ADBDActorVariationSpawnerActor2 final : public ADBDBaseActorSpawnerActor2
{
public:
	class UActorVariationSpawner*                 actorVariationSpawnerComponent;                    // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDActorVariationSpawnerActor2">();
	}
	static class ADBDActorVariationSpawnerActor2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDActorVariationSpawnerActor2>();
	}
};
static_assert(alignof(ADBDActorVariationSpawnerActor2) == 0x000008, "Wrong alignment on ADBDActorVariationSpawnerActor2");
static_assert(sizeof(ADBDActorVariationSpawnerActor2) == 0x0002B8, "Wrong size on ADBDActorVariationSpawnerActor2");
static_assert(offsetof(ADBDActorVariationSpawnerActor2, actorVariationSpawnerComponent) == 0x0002B0, "Member 'ADBDActorVariationSpawnerActor2::actorVariationSpawnerComponent' has a wrong offset!");

// Class DeadByDaylight.DBDGameEngine
// 0x0008 (0x1178 - 0x1170)
class UDBDGameEngine final : public UGameEngine
{
public:
	uint8                                         Pad_1170[0x8];                                     // 0x1170(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGameEngine">();
	}
	static class UDBDGameEngine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDGameEngine>();
	}
};
static_assert(alignof(UDBDGameEngine) == 0x000008, "Wrong alignment on UDBDGameEngine");
static_assert(sizeof(UDBDGameEngine) == 0x001178, "Wrong size on UDBDGameEngine");

// Class DeadByDaylight.ActorSpawner2Component
// 0x0000 (0x0320 - 0x0320)
class UActorSpawner2Component final : public UChildActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorSpawner2Component">();
	}
	static class UActorSpawner2Component* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorSpawner2Component>();
	}
};
static_assert(alignof(UActorSpawner2Component) == 0x000010, "Wrong alignment on UActorSpawner2Component");
static_assert(sizeof(UActorSpawner2Component) == 0x000320, "Wrong size on UActorSpawner2Component");

// Class DeadByDaylight.ChainLinkable
// 0x0000 (0x0000 - 0x0000)
class IChainLinkable final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChainLinkable">();
	}
	static class IChainLinkable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IChainLinkable>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IChainLinkable) == 0x000001, "Wrong alignment on IChainLinkable");
static_assert(sizeof(IChainLinkable) == 0x000001, "Wrong size on IChainLinkable");

// Class DeadByDaylight.SurvivorBeingKilledStatusEffect
// 0x0000 (0x0398 - 0x0398)
class USurvivorBeingKilledStatusEffect final : public UStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorBeingKilledStatusEffect">();
	}
	static class USurvivorBeingKilledStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorBeingKilledStatusEffect>();
	}
};
static_assert(alignof(USurvivorBeingKilledStatusEffect) == 0x000008, "Wrong alignment on USurvivorBeingKilledStatusEffect");
static_assert(sizeof(USurvivorBeingKilledStatusEffect) == 0x000398, "Wrong size on USurvivorBeingKilledStatusEffect");

// Class DeadByDaylight.DBDAggregateCullDistanceVolumes
// 0x0000 (0x02A0 - 0x02A0)
class ADBDAggregateCullDistanceVolumes final : public AActor
{
public:
	void SpawnCullDistanceVolumes();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAggregateCullDistanceVolumes">();
	}
	static class ADBDAggregateCullDistanceVolumes* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDAggregateCullDistanceVolumes>();
	}
};
static_assert(alignof(ADBDAggregateCullDistanceVolumes) == 0x000008, "Wrong alignment on ADBDAggregateCullDistanceVolumes");
static_assert(sizeof(ADBDAggregateCullDistanceVolumes) == 0x0002A0, "Wrong size on ADBDAggregateCullDistanceVolumes");

// Class DeadByDaylight.SurvivorInteractable
// 0x00E0 (0x04C0 - 0x03E0)
class ASurvivorInteractable final : public APlayerInteractable
{
public:
	uint8                                         Pad_3E0[0x8];                                      // 0x03E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInteractor*>                    HealingInteractors;                                // 0x03E8(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UChargeableInteractionDefinition*> _healInteractions;                               // 0x03F8(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UChargeableComponent*                   _killCharge;                                       // 0x0408(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UActivatorComponent*                    _activator;                                        // 0x0410(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_418[0x68];                                     // 0x0418(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractor*                            _killInteractor;                                   // 0x0480(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          _killInteractionZone;                              // 0x0488(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       _killHealthyInteractionZone;                       // 0x0490(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractor*                            _healingInteractor1;                               // 0x0498(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractor*                            _killerInteractor;                                 // 0x04A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       _killerInteractionZone;                            // 0x04A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B0[0x10];                                     // 0x04B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ServerMoveOut();
	void SetKillInteraction(class UInteractionDefinition* killInteraction);
	void UpdateTargetHPSlot();

	class ASurvivor* GetOwningSurvivor() const;
	class UInteractor* GetSlasherInteractor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorInteractable">();
	}
	static class ASurvivorInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASurvivorInteractable>();
	}
};
static_assert(alignof(ASurvivorInteractable) == 0x000008, "Wrong alignment on ASurvivorInteractable");
static_assert(sizeof(ASurvivorInteractable) == 0x0004C0, "Wrong size on ASurvivorInteractable");
static_assert(offsetof(ASurvivorInteractable, HealingInteractors) == 0x0003E8, "Member 'ASurvivorInteractable::HealingInteractors' has a wrong offset!");
static_assert(offsetof(ASurvivorInteractable, _healInteractions) == 0x0003F8, "Member 'ASurvivorInteractable::_healInteractions' has a wrong offset!");
static_assert(offsetof(ASurvivorInteractable, _killCharge) == 0x000408, "Member 'ASurvivorInteractable::_killCharge' has a wrong offset!");
static_assert(offsetof(ASurvivorInteractable, _activator) == 0x000410, "Member 'ASurvivorInteractable::_activator' has a wrong offset!");
static_assert(offsetof(ASurvivorInteractable, _killInteractor) == 0x000480, "Member 'ASurvivorInteractable::_killInteractor' has a wrong offset!");
static_assert(offsetof(ASurvivorInteractable, _killInteractionZone) == 0x000488, "Member 'ASurvivorInteractable::_killInteractionZone' has a wrong offset!");
static_assert(offsetof(ASurvivorInteractable, _killHealthyInteractionZone) == 0x000490, "Member 'ASurvivorInteractable::_killHealthyInteractionZone' has a wrong offset!");
static_assert(offsetof(ASurvivorInteractable, _healingInteractor1) == 0x000498, "Member 'ASurvivorInteractable::_healingInteractor1' has a wrong offset!");
static_assert(offsetof(ASurvivorInteractable, _killerInteractor) == 0x0004A0, "Member 'ASurvivorInteractable::_killerInteractor' has a wrong offset!");
static_assert(offsetof(ASurvivorInteractable, _killerInteractionZone) == 0x0004A8, "Member 'ASurvivorInteractable::_killerInteractionZone' has a wrong offset!");

// Class DeadByDaylight.DBDAggregateParticleSystemComponent
// 0x0060 (0x0930 - 0x08D0)
class UDBDAggregateParticleSystemComponent final : public UParticleSystemComponent
{
public:
	float                                         CullAngle;                                         // 0x08C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndFadeDistance;                                   // 0x08CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class USceneComponent*>                  LocatorComponentCache;                             // 0x08D0(0x0050)(ExportObject, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          PendingReset;                                      // 0x0920(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_921[0xF];                                      // 0x0921(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAggregateParticleSystemComponent">();
	}
	static class UDBDAggregateParticleSystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAggregateParticleSystemComponent>();
	}
};
static_assert(alignof(UDBDAggregateParticleSystemComponent) == 0x000010, "Wrong alignment on UDBDAggregateParticleSystemComponent");
static_assert(sizeof(UDBDAggregateParticleSystemComponent) == 0x000930, "Wrong size on UDBDAggregateParticleSystemComponent");
static_assert(offsetof(UDBDAggregateParticleSystemComponent, CullAngle) == 0x0008C8, "Member 'UDBDAggregateParticleSystemComponent::CullAngle' has a wrong offset!");
static_assert(offsetof(UDBDAggregateParticleSystemComponent, EndFadeDistance) == 0x0008CC, "Member 'UDBDAggregateParticleSystemComponent::EndFadeDistance' has a wrong offset!");
static_assert(offsetof(UDBDAggregateParticleSystemComponent, LocatorComponentCache) == 0x0008D0, "Member 'UDBDAggregateParticleSystemComponent::LocatorComponentCache' has a wrong offset!");
static_assert(offsetof(UDBDAggregateParticleSystemComponent, PendingReset) == 0x000920, "Member 'UDBDAggregateParticleSystemComponent::PendingReset' has a wrong offset!");

// Class DeadByDaylight.DBDAggregateParticleManager
// 0x0000 (0x02A0 - 0x02A0)
class ADBDAggregateParticleManager final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAggregateParticleManager">();
	}
	static class ADBDAggregateParticleManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDAggregateParticleManager>();
	}
};
static_assert(alignof(ADBDAggregateParticleManager) == 0x000008, "Wrong alignment on ADBDAggregateParticleManager");
static_assert(sizeof(ADBDAggregateParticleManager) == 0x0002A0, "Wrong size on ADBDAggregateParticleManager");

// Class DeadByDaylight.QuickTimeEventComponent
// 0x00F0 (0x01A8 - 0x00B8)
class UQuickTimeEventComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x48];                                      // 0x00B8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isInProgress;                                     // 0x0100(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_101[0x3];                                      // 0x0101(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ADBDPlayer>              _currentPlayer;                                    // 0x0104(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQuickTimeEventDefinition              _quickTimeEventDefinition;                         // 0x010C(0x000C)(Net, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x90];                                     // 0x0118(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_IsInProgress();
	void Server_CompleteQuickTimeEvent(bool isSuccess);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuickTimeEventComponent">();
	}
	static class UQuickTimeEventComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuickTimeEventComponent>();
	}
};
static_assert(alignof(UQuickTimeEventComponent) == 0x000008, "Wrong alignment on UQuickTimeEventComponent");
static_assert(sizeof(UQuickTimeEventComponent) == 0x0001A8, "Wrong size on UQuickTimeEventComponent");
static_assert(offsetof(UQuickTimeEventComponent, _isInProgress) == 0x000100, "Member 'UQuickTimeEventComponent::_isInProgress' has a wrong offset!");
static_assert(offsetof(UQuickTimeEventComponent, _currentPlayer) == 0x000104, "Member 'UQuickTimeEventComponent::_currentPlayer' has a wrong offset!");
static_assert(offsetof(UQuickTimeEventComponent, _quickTimeEventDefinition) == 0x00010C, "Member 'UQuickTimeEventComponent::_quickTimeEventDefinition' has a wrong offset!");

// Class DeadByDaylight.DBDAggregateParticleLocatorComponent
// 0x0010 (0x02E0 - 0x02D0)
class UDBDAggregateParticleLocatorComponent final : public UDBDLocatorComponent
{
public:
	class UParticleSystem*                        Template;                                          // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAggregateParticleLocatorComponent">();
	}
	static class UDBDAggregateParticleLocatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAggregateParticleLocatorComponent>();
	}
};
static_assert(alignof(UDBDAggregateParticleLocatorComponent) == 0x000010, "Wrong alignment on UDBDAggregateParticleLocatorComponent");
static_assert(sizeof(UDBDAggregateParticleLocatorComponent) == 0x0002E0, "Wrong size on UDBDAggregateParticleLocatorComponent");
static_assert(offsetof(UDBDAggregateParticleLocatorComponent, Template) == 0x0002D0, "Member 'UDBDAggregateParticleLocatorComponent::Template' has a wrong offset!");

// Class DeadByDaylight.DBDAIPlayerController
// 0x0028 (0x08A0 - 0x0878)
class ADBDAIPlayerController final : public ADBDAIController
{
public:
	uint8                                         Pad_878[0x18];                                     // 0x0878(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAICharacterBehaviour*>          _currentBehaviours;                                // 0x0890(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void MovePlayerToActor(class AActor* Goal, float AcceptanceRadius);
	void OnBehaviourEndedHandler(class UAICharacterBehaviour* behaviourEnded);
	void PauseCharacterBehaviour(const class UClass* behaviourClass);
	void ResumeCharacterBehaviour(const class UClass* behaviourClass);
	void StartCharacterBehaviour(class UClass* behaviourClass, class UAICharacterBehaviourData* characterBehaviourData);
	void StopAllCharacterBehaviours();
	void StopCharacterBehaviour(const class UClass* behaviourClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAIPlayerController">();
	}
	static class ADBDAIPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDAIPlayerController>();
	}
};
static_assert(alignof(ADBDAIPlayerController) == 0x000008, "Wrong alignment on ADBDAIPlayerController");
static_assert(sizeof(ADBDAIPlayerController) == 0x0008A0, "Wrong size on ADBDAIPlayerController");
static_assert(offsetof(ADBDAIPlayerController, _currentBehaviours) == 0x000890, "Member 'ADBDAIPlayerController::_currentBehaviours' has a wrong offset!");

// Class DeadByDaylight.ProximityToActorsIterativeWeightAdjustmentStrategy
// 0x0060 (0x00A0 - 0x0040)
class UProximityToActorsIterativeWeightAdjustmentStrategy : public UIterativeWeightAdjustmentStrategy
{
public:
	TArray<class USceneComponent*>                _unmatchedActorLocations;                          // 0x0040(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	int32                                         _currentPass;                                      // 0x0050(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _penaltyFromDistanceToClosestSpawnObject;          // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _penaltyFromDistanceToClosestSpawnObjectWhenActorHasOtherSpawnObjectNearby; // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _scoreFromDistanceFromClosestActor;                // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _actorCloseToSpawnObjectDistanceThreshold;         // 0x0070(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	int32                                         _spawnerCountPerActor;                             // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProximityToActorsIterativeWeightAdjustmentStrategy">();
	}
	static class UProximityToActorsIterativeWeightAdjustmentStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProximityToActorsIterativeWeightAdjustmentStrategy>();
	}
};
static_assert(alignof(UProximityToActorsIterativeWeightAdjustmentStrategy) == 0x000008, "Wrong alignment on UProximityToActorsIterativeWeightAdjustmentStrategy");
static_assert(sizeof(UProximityToActorsIterativeWeightAdjustmentStrategy) == 0x0000A0, "Wrong size on UProximityToActorsIterativeWeightAdjustmentStrategy");
static_assert(offsetof(UProximityToActorsIterativeWeightAdjustmentStrategy, _unmatchedActorLocations) == 0x000040, "Member 'UProximityToActorsIterativeWeightAdjustmentStrategy::_unmatchedActorLocations' has a wrong offset!");
static_assert(offsetof(UProximityToActorsIterativeWeightAdjustmentStrategy, _currentPass) == 0x000050, "Member 'UProximityToActorsIterativeWeightAdjustmentStrategy::_currentPass' has a wrong offset!");
static_assert(offsetof(UProximityToActorsIterativeWeightAdjustmentStrategy, _penaltyFromDistanceToClosestSpawnObject) == 0x000058, "Member 'UProximityToActorsIterativeWeightAdjustmentStrategy::_penaltyFromDistanceToClosestSpawnObject' has a wrong offset!");
static_assert(offsetof(UProximityToActorsIterativeWeightAdjustmentStrategy, _penaltyFromDistanceToClosestSpawnObjectWhenActorHasOtherSpawnObjectNearby) == 0x000060, "Member 'UProximityToActorsIterativeWeightAdjustmentStrategy::_penaltyFromDistanceToClosestSpawnObjectWhenActorHasOtherSpawnObjectNearby' has a wrong offset!");
static_assert(offsetof(UProximityToActorsIterativeWeightAdjustmentStrategy, _scoreFromDistanceFromClosestActor) == 0x000068, "Member 'UProximityToActorsIterativeWeightAdjustmentStrategy::_scoreFromDistanceFromClosestActor' has a wrong offset!");
static_assert(offsetof(UProximityToActorsIterativeWeightAdjustmentStrategy, _actorCloseToSpawnObjectDistanceThreshold) == 0x000070, "Member 'UProximityToActorsIterativeWeightAdjustmentStrategy::_actorCloseToSpawnObjectDistanceThreshold' has a wrong offset!");
static_assert(offsetof(UProximityToActorsIterativeWeightAdjustmentStrategy, _spawnerCountPerActor) == 0x000098, "Member 'UProximityToActorsIterativeWeightAdjustmentStrategy::_spawnerCountPerActor' has a wrong offset!");

// Class DeadByDaylight.DBDKeyDisplayInfo
// 0x0190 (0x01C0 - 0x0030)
class UDBDKeyDisplayInfo final : public UObject
{
public:
	TMap<class FName, struct FKeyDisplayInfo>     _keyDisplayInfoMap;                                // 0x0030(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0xA0];                                      // 0x0080(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EInputInteractionType, class FName>      _interactionTypeToActionMap_Camper;                // 0x0120(0x0050)(NativeAccessSpecifierPrivate)
	TMap<EInputInteractionType, class FName>      _interactionTypeToActionMap_Slasher;               // 0x0170(0x0050)(NativeAccessSpecifierPrivate)

public:
	const class FName GetActionForInteractionType(EPlayerRole PlayerRole, EInputInteractionType inputInteractionType, bool useGamePad, bool ignoreInteractMash);
	const struct FKey GetFirstKeyForAction(class UPlayerInput* PlayerInput, class FName ActionName, bool useGamePad);
	const struct FKeyDisplayInfo GetKeyDisplayInfo(const struct FKey& Key);
	const struct FKeyDisplayInfo GetKeyDisplayInfoForInteractionType(class UPlayerInput* PlayerInput, EPlayerRole PlayerRole, EInputInteractionType interactionType, bool useGamePad);
	const bool IsExcludedKey(const struct FKey& Key);
	const bool IsIgnoredKey(const struct FKey& Key);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDKeyDisplayInfo">();
	}
	static class UDBDKeyDisplayInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDKeyDisplayInfo>();
	}
};
static_assert(alignof(UDBDKeyDisplayInfo) == 0x000008, "Wrong alignment on UDBDKeyDisplayInfo");
static_assert(sizeof(UDBDKeyDisplayInfo) == 0x0001C0, "Wrong size on UDBDKeyDisplayInfo");
static_assert(offsetof(UDBDKeyDisplayInfo, _keyDisplayInfoMap) == 0x000030, "Member 'UDBDKeyDisplayInfo::_keyDisplayInfoMap' has a wrong offset!");
static_assert(offsetof(UDBDKeyDisplayInfo, _interactionTypeToActionMap_Camper) == 0x000120, "Member 'UDBDKeyDisplayInfo::_interactionTypeToActionMap_Camper' has a wrong offset!");
static_assert(offsetof(UDBDKeyDisplayInfo, _interactionTypeToActionMap_Slasher) == 0x000170, "Member 'UDBDKeyDisplayInfo::_interactionTypeToActionMap_Slasher' has a wrong offset!");

// Class DeadByDaylight.DBDAITypes
// 0x0258 (0x0288 - 0x0030)
class UDBDAITypes final : public UObject
{
public:
	struct FGameplayTag                           AISkills_Context_Service_Root;                     // 0x0030(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Task_Slasher_AttackTarget;        // 0x003C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Slasher_AttackTarget;     // 0x0048(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Task_Slasher_CrawlingTarget;      // 0x0054(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Slasher_Goals;            // 0x0060(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Slasher_CrawlingTarget;   // 0x006C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Slasher_Investigate_NotInChase; // 0x0078(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Slasher_Investigate_InChase; // 0x0084(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Slasher_Investigate_MoveAround; // 0x0090(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Slasher_Patrol;           // 0x009C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Slasher_Patrol_MoveAround; // 0x00A8(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Slasher_BreakPallet;      // 0x00B4(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Slasher_DynamicSubtree_KillZombie; // 0x00C0(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_Standing;          // 0x00CC(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_Crawling;          // 0x00D8(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_Guided;            // 0x00E4(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_Flee_Run_Always;   // 0x00F0(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_Flee_Run_InChase;  // 0x00FC(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_Flee_Run_NotInChase; // 0x0108(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_Patrol;            // 0x0114(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_RescueCarriedFriend; // 0x0120(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_RemoveTrap;        // 0x012C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_Chained;           // 0x0138(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_HelpOther;         // 0x0144(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_GoalInTerror;      // 0x0150(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_Carried;           // 0x015C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_UseSelfItem;       // 0x0168(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_Hiding;            // 0x0174(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_InLocker;          // 0x0180(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_Flee_InLocker;     // 0x018C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_RepairGenerator;   // 0x0198(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_UnhookSurvivor;    // 0x01A4(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_BeforeGoals;       // 0x01B0(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_UseK32Emp;         // 0x01BC(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AIBlackboard_InteractableWishList_FindSkill;       // 0x01C8(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AIBlackboard_ActorWishList_FindSkill;              // 0x01D4(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PointOfInterest_ActivatedDoor;                  // 0x01E0(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PointOfInterest_ActivatedDoor_Opened;           // 0x01EC(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PointOfInterest_BrokenGenerator;                // 0x01F8(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PointOfInterest_OccupiedMeatHook;               // 0x0204(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PointOfInterest_HexTotem;                       // 0x0210(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_Hearing_SilenceStatusEffect_Header;             // 0x021C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PinLocation_WarpStart;                          // 0x0228(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PinLocation_WarpEnd;                            // 0x0234(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PinLocation_EQS;                                // 0x0240(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PinLocation_WishedObj;                          // 0x024C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PinLocation_GoTo;                               // 0x0258(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PinObject_EQS;                                  // 0x0264(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PinObject_WishedObj;                            // 0x0270(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PinObject_GoTo;                                 // 0x027C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAITypes">();
	}
	static class UDBDAITypes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAITypes>();
	}
};
static_assert(alignof(UDBDAITypes) == 0x000008, "Wrong alignment on UDBDAITypes");
static_assert(sizeof(UDBDAITypes) == 0x000288, "Wrong size on UDBDAITypes");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Root) == 0x000030, "Member 'UDBDAITypes::AISkills_Context_Service_Root' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Task_Slasher_AttackTarget) == 0x00003C, "Member 'UDBDAITypes::AISkills_Context_Task_Slasher_AttackTarget' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Slasher_AttackTarget) == 0x000048, "Member 'UDBDAITypes::AISkills_Context_Service_Slasher_AttackTarget' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Task_Slasher_CrawlingTarget) == 0x000054, "Member 'UDBDAITypes::AISkills_Context_Task_Slasher_CrawlingTarget' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Slasher_Goals) == 0x000060, "Member 'UDBDAITypes::AISkills_Context_Service_Slasher_Goals' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Slasher_CrawlingTarget) == 0x00006C, "Member 'UDBDAITypes::AISkills_Context_Service_Slasher_CrawlingTarget' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Slasher_Investigate_NotInChase) == 0x000078, "Member 'UDBDAITypes::AISkills_Context_Service_Slasher_Investigate_NotInChase' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Slasher_Investigate_InChase) == 0x000084, "Member 'UDBDAITypes::AISkills_Context_Service_Slasher_Investigate_InChase' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Slasher_Investigate_MoveAround) == 0x000090, "Member 'UDBDAITypes::AISkills_Context_Service_Slasher_Investigate_MoveAround' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Slasher_Patrol) == 0x00009C, "Member 'UDBDAITypes::AISkills_Context_Service_Slasher_Patrol' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Slasher_Patrol_MoveAround) == 0x0000A8, "Member 'UDBDAITypes::AISkills_Context_Service_Slasher_Patrol_MoveAround' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Slasher_BreakPallet) == 0x0000B4, "Member 'UDBDAITypes::AISkills_Context_Service_Slasher_BreakPallet' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Slasher_DynamicSubtree_KillZombie) == 0x0000C0, "Member 'UDBDAITypes::AISkills_Context_Service_Slasher_DynamicSubtree_KillZombie' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_Standing) == 0x0000CC, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_Standing' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_Crawling) == 0x0000D8, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_Crawling' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_Guided) == 0x0000E4, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_Guided' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_Flee_Run_Always) == 0x0000F0, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_Flee_Run_Always' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_Flee_Run_InChase) == 0x0000FC, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_Flee_Run_InChase' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_Flee_Run_NotInChase) == 0x000108, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_Flee_Run_NotInChase' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_Patrol) == 0x000114, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_Patrol' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_RescueCarriedFriend) == 0x000120, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_RescueCarriedFriend' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_RemoveTrap) == 0x00012C, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_RemoveTrap' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_Chained) == 0x000138, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_Chained' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_HelpOther) == 0x000144, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_HelpOther' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_GoalInTerror) == 0x000150, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_GoalInTerror' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_Carried) == 0x00015C, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_Carried' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_UseSelfItem) == 0x000168, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_UseSelfItem' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_Hiding) == 0x000174, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_Hiding' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_InLocker) == 0x000180, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_InLocker' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_Flee_InLocker) == 0x00018C, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_Flee_InLocker' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_RepairGenerator) == 0x000198, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_RepairGenerator' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_UnhookSurvivor) == 0x0001A4, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_UnhookSurvivor' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_BeforeGoals) == 0x0001B0, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_BeforeGoals' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_UseK32Emp) == 0x0001BC, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_UseK32Emp' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AIBlackboard_InteractableWishList_FindSkill) == 0x0001C8, "Member 'UDBDAITypes::AIBlackboard_InteractableWishList_FindSkill' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AIBlackboard_ActorWishList_FindSkill) == 0x0001D4, "Member 'UDBDAITypes::AIBlackboard_ActorWishList_FindSkill' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PointOfInterest_ActivatedDoor) == 0x0001E0, "Member 'UDBDAITypes::AI_PointOfInterest_ActivatedDoor' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PointOfInterest_ActivatedDoor_Opened) == 0x0001EC, "Member 'UDBDAITypes::AI_PointOfInterest_ActivatedDoor_Opened' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PointOfInterest_BrokenGenerator) == 0x0001F8, "Member 'UDBDAITypes::AI_PointOfInterest_BrokenGenerator' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PointOfInterest_OccupiedMeatHook) == 0x000204, "Member 'UDBDAITypes::AI_PointOfInterest_OccupiedMeatHook' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PointOfInterest_HexTotem) == 0x000210, "Member 'UDBDAITypes::AI_PointOfInterest_HexTotem' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_Hearing_SilenceStatusEffect_Header) == 0x00021C, "Member 'UDBDAITypes::AI_Hearing_SilenceStatusEffect_Header' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PinLocation_WarpStart) == 0x000228, "Member 'UDBDAITypes::AI_PinLocation_WarpStart' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PinLocation_WarpEnd) == 0x000234, "Member 'UDBDAITypes::AI_PinLocation_WarpEnd' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PinLocation_EQS) == 0x000240, "Member 'UDBDAITypes::AI_PinLocation_EQS' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PinLocation_WishedObj) == 0x00024C, "Member 'UDBDAITypes::AI_PinLocation_WishedObj' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PinLocation_GoTo) == 0x000258, "Member 'UDBDAITypes::AI_PinLocation_GoTo' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PinObject_EQS) == 0x000264, "Member 'UDBDAITypes::AI_PinObject_EQS' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PinObject_WishedObj) == 0x000270, "Member 'UDBDAITypes::AI_PinObject_WishedObj' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PinObject_GoTo) == 0x00027C, "Member 'UDBDAITypes::AI_PinObject_GoTo' has a wrong offset!");

// Class DeadByDaylight.SectionnedChargeableComponent
// 0x0008 (0x0330 - 0x0328)
class USectionnedChargeableComponent final : public UChargeableComponent
{
public:
	uint8                                         _sections;                                         // 0x0328(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_329[0x7];                                      // 0x0329(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetSectionChargeRemaining() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SectionnedChargeableComponent">();
	}
	static class USectionnedChargeableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USectionnedChargeableComponent>();
	}
};
static_assert(alignof(USectionnedChargeableComponent) == 0x000008, "Wrong alignment on USectionnedChargeableComponent");
static_assert(sizeof(USectionnedChargeableComponent) == 0x000330, "Wrong size on USectionnedChargeableComponent");
static_assert(offsetof(USectionnedChargeableComponent, _sections) == 0x000328, "Member 'USectionnedChargeableComponent::_sections' has a wrong offset!");

// Class DeadByDaylight.DBDAssetManager
// 0x0000 (0x04F0 - 0x04F0)
class UDBDAssetManager final : public UAssetManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAssetManager">();
	}
	static class UDBDAssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAssetManager>();
	}
};
static_assert(alignof(UDBDAssetManager) == 0x000008, "Wrong alignment on UDBDAssetManager");
static_assert(sizeof(UDBDAssetManager) == 0x0004F0, "Wrong size on UDBDAssetManager");

// Class DeadByDaylight.VaultableOutlineUpdateStrategy
// 0x0008 (0x0168 - 0x0160)
class UVaultableOutlineUpdateStrategy : public USourceBasedOutlineUpdateStrategy
{
public:
	bool                                          _canBeRevealedToLocalPlayer;                       // 0x0160(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_161[0x7];                                      // 0x0161(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCanBeRevealedToLocalPlayer(bool canBeRevealedToLocalPlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VaultableOutlineUpdateStrategy">();
	}
	static class UVaultableOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVaultableOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UVaultableOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UVaultableOutlineUpdateStrategy");
static_assert(sizeof(UVaultableOutlineUpdateStrategy) == 0x000168, "Wrong size on UVaultableOutlineUpdateStrategy");
static_assert(offsetof(UVaultableOutlineUpdateStrategy, _canBeRevealedToLocalPlayer) == 0x000160, "Member 'UVaultableOutlineUpdateStrategy::_canBeRevealedToLocalPlayer' has a wrong offset!");

// Class DeadByDaylight.PalletOutlineUpdateStrategy
// 0x0010 (0x0178 - 0x0168)
class UPalletOutlineUpdateStrategy : public UVaultableOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _revealedByPowerColor;                             // 0x0168(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalletOutlineUpdateStrategy">();
	}
	static class UPalletOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalletOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UPalletOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UPalletOutlineUpdateStrategy");
static_assert(sizeof(UPalletOutlineUpdateStrategy) == 0x000178, "Wrong size on UPalletOutlineUpdateStrategy");
static_assert(offsetof(UPalletOutlineUpdateStrategy, _revealedByPowerColor) == 0x000168, "Member 'UPalletOutlineUpdateStrategy::_revealedByPowerColor' has a wrong offset!");

// Class DeadByDaylight.DreamPalletOutlineUpdateStrategy
// 0x0028 (0x01A0 - 0x0178)
class UDreamPalletOutlineUpdateStrategy final : public UPalletOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _revealedByMapColor;                               // 0x0178(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_188[0x18];                                     // 0x0188(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeTunableValues(class AKiller* Killer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DreamPalletOutlineUpdateStrategy">();
	}
	static class UDreamPalletOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDreamPalletOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UDreamPalletOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UDreamPalletOutlineUpdateStrategy");
static_assert(sizeof(UDreamPalletOutlineUpdateStrategy) == 0x0001A0, "Wrong size on UDreamPalletOutlineUpdateStrategy");
static_assert(offsetof(UDreamPalletOutlineUpdateStrategy, _revealedByMapColor) == 0x000178, "Member 'UDreamPalletOutlineUpdateStrategy::_revealedByMapColor' has a wrong offset!");

// Class DeadByDaylight.DBDAtlantaTutorialParameters
// 0x0008 (0x0038 - 0x0030)
class UDBDAtlantaTutorialParameters final : public UObject
{
public:
	float                                         SurvTutorial_WiggleChargeRateMultiplier;           // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAtlantaTutorialParameters">();
	}
	static class UDBDAtlantaTutorialParameters* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAtlantaTutorialParameters>();
	}
};
static_assert(alignof(UDBDAtlantaTutorialParameters) == 0x000008, "Wrong alignment on UDBDAtlantaTutorialParameters");
static_assert(sizeof(UDBDAtlantaTutorialParameters) == 0x000038, "Wrong size on UDBDAtlantaTutorialParameters");
static_assert(offsetof(UDBDAtlantaTutorialParameters, SurvTutorial_WiggleChargeRateMultiplier) == 0x000030, "Member 'UDBDAtlantaTutorialParameters::SurvTutorial_WiggleChargeRateMultiplier' has a wrong offset!");

// Class DeadByDaylight.DBDAttackerComponent
// 0x0120 (0x01D8 - 0x00B8)
class UDBDAttackerComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(const EAttackType attackType)> OnAttackStartDelegate;              // 0x00B8(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const EAttackType attackType)> OnAttackFinishDelegate;             // 0x00C8(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x38];                                      // 0x00D8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _autonomousHitPredictionDelay;                     // 0x0110(0x0028)(Edit, NativeAccessSpecifierPrivate)
	TArray<class UDBDAttack*>                     _attacks;                                          // 0x0138(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x10];                                     // 0x0148(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDAttack*                             _requestedAttack;                                  // 0x0158(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDAttack*                             _currentAttack;                                    // 0x0160(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_168[0x60];                                     // 0x0168(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAttackDelegatePair>            _attackHitDelegates;                               // 0x01C8(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void Local_RequestAttack(const EAttackType attackType);
	void Multicast_StoreAttack(const EAttackType attackType);
	void Server_StoreAttack(const EAttackType attackType);

	bool IsAnyAttackTransitionRequested() const;
	bool IsAttacking() const;
	bool IsAttackTransitionRequested(const EAttackType attackType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAttackerComponent">();
	}
	static class UDBDAttackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAttackerComponent>();
	}
};
static_assert(alignof(UDBDAttackerComponent) == 0x000008, "Wrong alignment on UDBDAttackerComponent");
static_assert(sizeof(UDBDAttackerComponent) == 0x0001D8, "Wrong size on UDBDAttackerComponent");
static_assert(offsetof(UDBDAttackerComponent, OnAttackStartDelegate) == 0x0000B8, "Member 'UDBDAttackerComponent::OnAttackStartDelegate' has a wrong offset!");
static_assert(offsetof(UDBDAttackerComponent, OnAttackFinishDelegate) == 0x0000C8, "Member 'UDBDAttackerComponent::OnAttackFinishDelegate' has a wrong offset!");
static_assert(offsetof(UDBDAttackerComponent, _autonomousHitPredictionDelay) == 0x000110, "Member 'UDBDAttackerComponent::_autonomousHitPredictionDelay' has a wrong offset!");
static_assert(offsetof(UDBDAttackerComponent, _attacks) == 0x000138, "Member 'UDBDAttackerComponent::_attacks' has a wrong offset!");
static_assert(offsetof(UDBDAttackerComponent, _requestedAttack) == 0x000158, "Member 'UDBDAttackerComponent::_requestedAttack' has a wrong offset!");
static_assert(offsetof(UDBDAttackerComponent, _currentAttack) == 0x000160, "Member 'UDBDAttackerComponent::_currentAttack' has a wrong offset!");
static_assert(offsetof(UDBDAttackerComponent, _attackHitDelegates) == 0x0001C8, "Member 'UDBDAttackerComponent::_attackHitDelegates' has a wrong offset!");

// Class DeadByDaylight.S3GameConfigsDS
// 0x01C8 (0x0200 - 0x0038)
class US3GameConfigsDS final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x1C8];                                     // 0x0038(0x01C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S3GameConfigsDS">();
	}
	static class US3GameConfigsDS* GetDefaultObj()
	{
		return GetDefaultObjImpl<US3GameConfigsDS>();
	}
};
static_assert(alignof(US3GameConfigsDS) == 0x000008, "Wrong alignment on US3GameConfigsDS");
static_assert(sizeof(US3GameConfigsDS) == 0x000200, "Wrong size on US3GameConfigsDS");

// Class DeadByDaylight.DBDOnlineSessionClient
// 0x0028 (0x0240 - 0x0218)
class UDBDOnlineSessionClient final : public UOnlineSessionClient
{
public:
	uint8                                         Pad_218[0x28];                                     // 0x0218(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDOnlineSessionClient">();
	}
	static class UDBDOnlineSessionClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDOnlineSessionClient>();
	}
};
static_assert(alignof(UDBDOnlineSessionClient) == 0x000008, "Wrong alignment on UDBDOnlineSessionClient");
static_assert(sizeof(UDBDOnlineSessionClient) == 0x000240, "Wrong size on UDBDOnlineSessionClient");

// Class DeadByDaylight.DBDAttackUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDAttackUtilities final : public UBlueprintFunctionLibrary
{
public:
	static float GetCurrentAttackSubstateRemainingTime(const class AActor* Attacker);
	static EAttackType GetCurrentAttackType(const class AActor* Attacker);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAttackUtilities">();
	}
	static class UDBDAttackUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAttackUtilities>();
	}
};
static_assert(alignof(UDBDAttackUtilities) == 0x000008, "Wrong alignment on UDBDAttackUtilities");
static_assert(sizeof(UDBDAttackUtilities) == 0x000030, "Wrong size on UDBDAttackUtilities");

// Class DeadByDaylight.DBDAuthentication
// 0x0028 (0x0058 - 0x0030)
class UDBDAuthentication final : public UObject
{
public:
	TArray<struct FAuthenticationInfo>            _localInfos;                                       // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FAuthenticationInfo>            _remoteInfos;                                      // 0x0040(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UDBDGameInstance*                       _gameInstance;                                     // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAuthentication">();
	}
	static class UDBDAuthentication* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAuthentication>();
	}
};
static_assert(alignof(UDBDAuthentication) == 0x000008, "Wrong alignment on UDBDAuthentication");
static_assert(sizeof(UDBDAuthentication) == 0x000058, "Wrong size on UDBDAuthentication");
static_assert(offsetof(UDBDAuthentication, _localInfos) == 0x000030, "Member 'UDBDAuthentication::_localInfos' has a wrong offset!");
static_assert(offsetof(UDBDAuthentication, _remoteInfos) == 0x000040, "Member 'UDBDAuthentication::_remoteInfos' has a wrong offset!");
static_assert(offsetof(UDBDAuthentication, _gameInstance) == 0x000050, "Member 'UDBDAuthentication::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.ReverseBearTrapUtilities
// 0x0000 (0x0030 - 0x0030)
class UReverseBearTrapUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class AReverseBearTrap* GetAttachedRBT(class ADBDPlayer* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReverseBearTrapUtilities">();
	}
	static class UReverseBearTrapUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReverseBearTrapUtilities>();
	}
};
static_assert(alignof(UReverseBearTrapUtilities) == 0x000008, "Wrong alignment on UReverseBearTrapUtilities");
static_assert(sizeof(UReverseBearTrapUtilities) == 0x000030, "Wrong size on UReverseBearTrapUtilities");

// Class DeadByDaylight.GameplayNotificationUtilities
// 0x0000 (0x0030 - 0x0030)
class UGameplayNotificationUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayNotificationUtilities">();
	}
	static class UGameplayNotificationUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayNotificationUtilities>();
	}
};
static_assert(alignof(UGameplayNotificationUtilities) == 0x000008, "Wrong alignment on UGameplayNotificationUtilities");
static_assert(sizeof(UGameplayNotificationUtilities) == 0x000030, "Wrong size on UGameplayNotificationUtilities");

// Class DeadByDaylight.SurvivorStateMachine
// 0x0000 (0x0140 - 0x0140)
class USurvivorStateMachine final : public UPlayerStateMachine
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorStateMachine">();
	}
	static class USurvivorStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorStateMachine>();
	}
};
static_assert(alignof(USurvivorStateMachine) == 0x000010, "Wrong alignment on USurvivorStateMachine");
static_assert(sizeof(USurvivorStateMachine) == 0x000140, "Wrong size on USurvivorStateMachine");

// Class DeadByDaylight.AutoBatchingSettings
// 0x0010 (0x0058 - 0x0048)
class UAutoBatchingSettings final : public UDeveloperSettings
{
public:
	TArray<class FName>                           AutoBatchingSpecificComponentTagsToSplit;          // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoBatchingSettings">();
	}
	static class UAutoBatchingSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutoBatchingSettings>();
	}
};
static_assert(alignof(UAutoBatchingSettings) == 0x000008, "Wrong alignment on UAutoBatchingSettings");
static_assert(sizeof(UAutoBatchingSettings) == 0x000058, "Wrong size on UAutoBatchingSettings");
static_assert(offsetof(UAutoBatchingSettings, AutoBatchingSpecificComponentTagsToSplit) == 0x000048, "Member 'UAutoBatchingSettings::AutoBatchingSpecificComponentTagsToSplit' has a wrong offset!");

// Class DeadByDaylight.BatchDrawing
// 0x0080 (0x00B0 - 0x0030)
class UBatchDrawing final : public UObject
{
public:
	class AActor*                                 _actorToSpawnInstancesInto;                        // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class UStaticMesh*, struct FPerMeshInstancingData> _meshesToInstancingData;                 // 0x0038(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UHISMMaterialHelperSettings*            _hismMaterialHelperSettings;                       // 0x0088(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWorld*                                 _currentWorld;                                     // 0x0090(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FStaticMeshAutoBatch>           _meshAutoBatch;                                    // 0x0098(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BatchDrawing">();
	}
	static class UBatchDrawing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBatchDrawing>();
	}
};
static_assert(alignof(UBatchDrawing) == 0x000008, "Wrong alignment on UBatchDrawing");
static_assert(sizeof(UBatchDrawing) == 0x0000B0, "Wrong size on UBatchDrawing");
static_assert(offsetof(UBatchDrawing, _actorToSpawnInstancesInto) == 0x000030, "Member 'UBatchDrawing::_actorToSpawnInstancesInto' has a wrong offset!");
static_assert(offsetof(UBatchDrawing, _meshesToInstancingData) == 0x000038, "Member 'UBatchDrawing::_meshesToInstancingData' has a wrong offset!");
static_assert(offsetof(UBatchDrawing, _hismMaterialHelperSettings) == 0x000088, "Member 'UBatchDrawing::_hismMaterialHelperSettings' has a wrong offset!");
static_assert(offsetof(UBatchDrawing, _currentWorld) == 0x000090, "Member 'UBatchDrawing::_currentWorld' has a wrong offset!");
static_assert(offsetof(UBatchDrawing, _meshAutoBatch) == 0x000098, "Member 'UBatchDrawing::_meshAutoBatch' has a wrong offset!");

// Class DeadByDaylight.DBDBloodwebDefinitionBase
// 0x0000 (0x0000 - 0x0000)
class IDBDBloodwebDefinitionBase final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBloodwebDefinitionBase">();
	}
	static class IDBDBloodwebDefinitionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDBDBloodwebDefinitionBase>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IDBDBloodwebDefinitionBase) == 0x000001, "Wrong alignment on IDBDBloodwebDefinitionBase");
static_assert(sizeof(IDBDBloodwebDefinitionBase) == 0x000001, "Wrong size on IDBDBloodwebDefinitionBase");

// Class DeadByDaylight.DBDCharacterMovementUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDCharacterMovementUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDCharacterMovementUtilities">();
	}
	static class UDBDCharacterMovementUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDCharacterMovementUtilities>();
	}
};
static_assert(alignof(UDBDCharacterMovementUtilities) == 0x000008, "Wrong alignment on UDBDCharacterMovementUtilities");
static_assert(sizeof(UDBDCharacterMovementUtilities) == 0x000030, "Wrong size on UDBDCharacterMovementUtilities");

// Class DeadByDaylight.DBDCheatValidatorSubsystem
// 0x0000 (0x0038 - 0x0038)
class UDBDCheatValidatorSubsystem final : public UEngineSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDCheatValidatorSubsystem">();
	}
	static class UDBDCheatValidatorSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDCheatValidatorSubsystem>();
	}
};
static_assert(alignof(UDBDCheatValidatorSubsystem) == 0x000008, "Wrong alignment on UDBDCheatValidatorSubsystem");
static_assert(sizeof(UDBDCheatValidatorSubsystem) == 0x000038, "Wrong size on UDBDCheatValidatorSubsystem");

// Class DeadByDaylight.DBDChildActorSpawnerComponent
// 0x0130 (0x01E8 - 0x00B8)
class UDBDChildActorSpawnerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x30];                                      // 0x00B8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UDBDChildActorSpawnerComponent* Component)> BP_OnChildPostSpawn; // 0x00E8(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UDBDChildActorSpawnerComponent* Component)> BP_OnChildPostDestroy; // 0x00F8(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          _autoSpawnChild;                                   // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDChildActorSpawnParams              _defaultChildSpawnParams;                          // 0x0110(0x0068)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 _child;                                            // 0x0178(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDChildActorSpawnParams              _childSpawnParams;                                 // 0x0180(0x0068)(Net, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	bool BP_DestroyChild();
	bool BP_SpawnChild();
	bool BP_SpawnChildWithParams(const struct FDBDChildActorSpawnParams& SpawnParams);
	void OnRep_Child();

	class AActor* BP_GetChild() const;
	bool BP_IsChildAttached() const;
	bool BP_IsChildSpawned() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDChildActorSpawnerComponent">();
	}
	static class UDBDChildActorSpawnerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDChildActorSpawnerComponent>();
	}
};
static_assert(alignof(UDBDChildActorSpawnerComponent) == 0x000008, "Wrong alignment on UDBDChildActorSpawnerComponent");
static_assert(sizeof(UDBDChildActorSpawnerComponent) == 0x0001E8, "Wrong size on UDBDChildActorSpawnerComponent");
static_assert(offsetof(UDBDChildActorSpawnerComponent, BP_OnChildPostSpawn) == 0x0000E8, "Member 'UDBDChildActorSpawnerComponent::BP_OnChildPostSpawn' has a wrong offset!");
static_assert(offsetof(UDBDChildActorSpawnerComponent, BP_OnChildPostDestroy) == 0x0000F8, "Member 'UDBDChildActorSpawnerComponent::BP_OnChildPostDestroy' has a wrong offset!");
static_assert(offsetof(UDBDChildActorSpawnerComponent, _autoSpawnChild) == 0x000108, "Member 'UDBDChildActorSpawnerComponent::_autoSpawnChild' has a wrong offset!");
static_assert(offsetof(UDBDChildActorSpawnerComponent, _defaultChildSpawnParams) == 0x000110, "Member 'UDBDChildActorSpawnerComponent::_defaultChildSpawnParams' has a wrong offset!");
static_assert(offsetof(UDBDChildActorSpawnerComponent, _child) == 0x000178, "Member 'UDBDChildActorSpawnerComponent::_child' has a wrong offset!");
static_assert(offsetof(UDBDChildActorSpawnerComponent, _childSpawnParams) == 0x000180, "Member 'UDBDChildActorSpawnerComponent::_childSpawnParams' has a wrong offset!");

// Class DeadByDaylight.DBDCoreUMGDesignTunables
// 0x0070 (0x00A0 - 0x0030)
class UDBDCoreUMGDesignTunables : public UObject
{
public:
	TSoftClassPtr<class UClass>                   CoreHudRootWidgetClass;                            // 0x0030(0x0038)(Edit, NoClear, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CorePlayerControllerClass;                         // 0x0068(0x0038)(Edit, NoClear, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDCoreUMGDesignTunables">();
	}
	static class UDBDCoreUMGDesignTunables* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDCoreUMGDesignTunables>();
	}
};
static_assert(alignof(UDBDCoreUMGDesignTunables) == 0x000008, "Wrong alignment on UDBDCoreUMGDesignTunables");
static_assert(sizeof(UDBDCoreUMGDesignTunables) == 0x0000A0, "Wrong size on UDBDCoreUMGDesignTunables");
static_assert(offsetof(UDBDCoreUMGDesignTunables, CoreHudRootWidgetClass) == 0x000030, "Member 'UDBDCoreUMGDesignTunables::CoreHudRootWidgetClass' has a wrong offset!");
static_assert(offsetof(UDBDCoreUMGDesignTunables, CorePlayerControllerClass) == 0x000068, "Member 'UDBDCoreUMGDesignTunables::CorePlayerControllerClass' has a wrong offset!");

// Class DeadByDaylight.DBDCustomizationTool
// 0x1328 (0x15C8 - 0x02A0)
class ADBDCustomizationTool final : public AActor
{
public:
	TSoftClassPtr<class UClass>                   OverallLightingClass;                              // 0x02A0(0x0038)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDCustomizationToolData              CustomizationData;                                 // 0x02D8(0x12D8)(Edit, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         _spawnedActors;                                    // 0x15B0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_15C0[0x8];                                     // 0x15C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDCustomizationTool">();
	}
	static class ADBDCustomizationTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDCustomizationTool>();
	}
};
static_assert(alignof(ADBDCustomizationTool) == 0x000008, "Wrong alignment on ADBDCustomizationTool");
static_assert(sizeof(ADBDCustomizationTool) == 0x0015C8, "Wrong size on ADBDCustomizationTool");
static_assert(offsetof(ADBDCustomizationTool, OverallLightingClass) == 0x0002A0, "Member 'ADBDCustomizationTool::OverallLightingClass' has a wrong offset!");
static_assert(offsetof(ADBDCustomizationTool, CustomizationData) == 0x0002D8, "Member 'ADBDCustomizationTool::CustomizationData' has a wrong offset!");
static_assert(offsetof(ADBDCustomizationTool, _spawnedActors) == 0x0015B0, "Member 'ADBDCustomizationTool::_spawnedActors' has a wrong offset!");

// Class DeadByDaylight.DBDDebugCameraController
// 0x0000 (0x09E8 - 0x09E8)
class ADBDDebugCameraController final : public ADebugCameraController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDDebugCameraController">();
	}
	static class ADBDDebugCameraController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDDebugCameraController>();
	}
};
static_assert(alignof(ADBDDebugCameraController) == 0x000008, "Wrong alignment on ADBDDebugCameraController");
static_assert(sizeof(ADBDDebugCameraController) == 0x0009E8, "Wrong size on ADBDDebugCameraController");

// Class DeadByDaylight.DBDDebugGameMode
// 0x00F8 (0x0720 - 0x0628)
class ADBDDebugGameMode final : public ADBDGameMode
{
public:
	uint8                                         Pad_628[0x8];                                      // 0x0628(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ADBDPlayerController*, int32>      LoadoutIndex;                                      // 0x0630(0x0050)(NativeAccessSpecifierPrivate)
	TSet<class ADBDPlayer*>                       PlayersWithItems;                                  // 0x0680(0x0050)(NativeAccessSpecifierPrivate)
	TArray<struct FCamperLoadout>                 CamperPawnOverrides;                               // 0x06D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSlasherLoadout>                SlasherPawnOverrides;                              // 0x06E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FDebugQuestModelExtArchiveObjective> _questObjectives;                             // 0x06F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         _spawnSurvivorBotsCount;                           // 0x0700(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _disableSpawnedSurvivorAI;                         // 0x0704(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_705[0x3];                                      // 0x0705(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _spawnKillerBotsCount;                             // 0x0708(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _disableSpawnedKillerAI;                           // 0x070C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70D[0x13];                                     // 0x070D(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDDebugGameMode">();
	}
	static class ADBDDebugGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDDebugGameMode>();
	}
};
static_assert(alignof(ADBDDebugGameMode) == 0x000008, "Wrong alignment on ADBDDebugGameMode");
static_assert(sizeof(ADBDDebugGameMode) == 0x000720, "Wrong size on ADBDDebugGameMode");
static_assert(offsetof(ADBDDebugGameMode, LoadoutIndex) == 0x000630, "Member 'ADBDDebugGameMode::LoadoutIndex' has a wrong offset!");
static_assert(offsetof(ADBDDebugGameMode, PlayersWithItems) == 0x000680, "Member 'ADBDDebugGameMode::PlayersWithItems' has a wrong offset!");
static_assert(offsetof(ADBDDebugGameMode, CamperPawnOverrides) == 0x0006D0, "Member 'ADBDDebugGameMode::CamperPawnOverrides' has a wrong offset!");
static_assert(offsetof(ADBDDebugGameMode, SlasherPawnOverrides) == 0x0006E0, "Member 'ADBDDebugGameMode::SlasherPawnOverrides' has a wrong offset!");
static_assert(offsetof(ADBDDebugGameMode, _questObjectives) == 0x0006F0, "Member 'ADBDDebugGameMode::_questObjectives' has a wrong offset!");
static_assert(offsetof(ADBDDebugGameMode, _spawnSurvivorBotsCount) == 0x000700, "Member 'ADBDDebugGameMode::_spawnSurvivorBotsCount' has a wrong offset!");
static_assert(offsetof(ADBDDebugGameMode, _disableSpawnedSurvivorAI) == 0x000704, "Member 'ADBDDebugGameMode::_disableSpawnedSurvivorAI' has a wrong offset!");
static_assert(offsetof(ADBDDebugGameMode, _spawnKillerBotsCount) == 0x000708, "Member 'ADBDDebugGameMode::_spawnKillerBotsCount' has a wrong offset!");
static_assert(offsetof(ADBDDebugGameMode, _disableSpawnedKillerAI) == 0x00070C, "Member 'ADBDDebugGameMode::_disableSpawnedKillerAI' has a wrong offset!");

// Class DeadByDaylight.DBDDiceRoller
// 0x0000 (0x0030 - 0x0030)
class UDBDDiceRoller final : public UBlueprintFunctionLibrary
{
public:
	static bool CalculateOverTimeRollResult(const class AActor* RollingActor, float BaseProbability, float DeltaTime, float ExpectedTime, float MultiplicativeModifier, float AdditiveModifier);
	static bool CalculateRollResult(const class AActor* RollingActor, float BaseProbability, float MultiplicativeModifier, float AdditiveModifier);
	static bool CalculateTickedRollResult(const class AActor* RollingActor, float BaseProbability, float ticks, float MultiplicativeModifier, float AdditiveModifier);
	static float GetInteractionRollSuccessPercentageByDiceRollType(const class UInteractionDefinition* Interaction, const class ADBDPlayer* rollingPlayer, EDiceRollType DiceRollType);
	static bool GetRollResultByDiceRollType(const class ADBDPlayer* rollingPlayer, EDiceRollType DiceRollType);
	static bool GetRollResultByTunableValue(const class AActor* RollingActor, class FName TunableValueName, float MultiplicativeModifier, float AdditiveModifier);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDDiceRoller">();
	}
	static class UDBDDiceRoller* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDDiceRoller>();
	}
};
static_assert(alignof(UDBDDiceRoller) == 0x000008, "Wrong alignment on UDBDDiceRoller");
static_assert(sizeof(UDBDDiceRoller) == 0x000030, "Wrong size on UDBDDiceRoller");

// Class DeadByDaylight.DBDEasyAntiCheatEGS
// 0x0000 (0x00C0 - 0x00C0)
class UDBDEasyAntiCheatEGS final : public UDBDEasyAntiCheatClient
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDEasyAntiCheatEGS">();
	}
	static class UDBDEasyAntiCheatEGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDEasyAntiCheatEGS>();
	}
};
static_assert(alignof(UDBDEasyAntiCheatEGS) == 0x000008, "Wrong alignment on UDBDEasyAntiCheatEGS");
static_assert(sizeof(UDBDEasyAntiCheatEGS) == 0x0000C0, "Wrong size on UDBDEasyAntiCheatEGS");

// Class DeadByDaylight.DBDEngineUtils
// 0x0000 (0x0030 - 0x0030)
class UDBDEngineUtils final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDEngineUtils">();
	}
	static class UDBDEngineUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDEngineUtils>();
	}
};
static_assert(alignof(UDBDEngineUtils) == 0x000008, "Wrong alignment on UDBDEngineUtils");
static_assert(sizeof(UDBDEngineUtils) == 0x000030, "Wrong size on UDBDEngineUtils");

// Class DeadByDaylight.DBDGameEventForwarderComponent
// 0x0010 (0x00C8 - 0x00B8)
class UDBDGameEventForwarderComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGameEventForwarderComponent">();
	}
	static class UDBDGameEventForwarderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDGameEventForwarderComponent>();
	}
};
static_assert(alignof(UDBDGameEventForwarderComponent) == 0x000008, "Wrong alignment on UDBDGameEventForwarderComponent");
static_assert(sizeof(UDBDGameEventForwarderComponent) == 0x0000C8, "Wrong size on UDBDGameEventForwarderComponent");

// Class DeadByDaylight.DBDGameEventUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDGameEventUtilities final : public UBlueprintFunctionLibrary
{
public:
	static void Authority_AccumulateOngoingGameEvent(const class UObject* WorldContextObject, const struct FGameplayTag& gameEventType, class ADBDPlayer* Instigator, class AActor* Target, float CustomValue, float OngoingWaitTime, class UObject* CustomObjectParameter, int32 CustomIntValue);
	static void Authority_DispatcherFireGameEvent(const class UObject* WorldContextObject, const struct FGameplayTag& gameEventType, bool broadcastOverNetwork, class ADBDPlayer* Instigator, class AActor* Target, float CustomValue, class UObject* CustomObjectParameter, int32 CustomIntValue);
	static void DispatcherFireGameEvent(const class UObject* WorldContextObject, const struct FGameplayTag& gameEventType, bool broadcastOverNetwork, class ADBDPlayer* Instigator, class AActor* Target, float CustomValue, class UObject* CustomObjectParameter, int32 CustomIntValue);
	static void LocallyDispatchGameEvent(const class UObject* WorldContextObject, const struct FGameplayTag& gameEventType, class ADBDPlayer* Instigator, class AActor* Target, float CustomValue, class UObject* CustomObjectParameter, int32 CustomIntValue);
	static void RemotelyDispatchGameEvent(const class UObject* WorldContextObject, const struct FGameplayTag& gameEventType, class ADBDPlayer* Instigator, class AActor* Target, float CustomValue, class UObject* CustomObjectParameter, int32 CustomIntValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGameEventUtilities">();
	}
	static class UDBDGameEventUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDGameEventUtilities>();
	}
};
static_assert(alignof(UDBDGameEventUtilities) == 0x000008, "Wrong alignment on UDBDGameEventUtilities");
static_assert(sizeof(UDBDGameEventUtilities) == 0x000030, "Wrong size on UDBDGameEventUtilities");

// Class DeadByDaylight.DBDGameFlowUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDGameFlowUtilities final : public UBlueprintFunctionLibrary
{
public:
	static bool IsCurrentlyInGame(const class UDBDGameInstance* GameInstance);
	static void TriggerUIFlowEvent(class UObject* WorldContextObject, EUIFlowEvent uiFlowEvent, bool forceChange);
	static void TriggerWorldFlowEvent(class UObject* WorldContextObject, EWorldFlowEvent worldFlowEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGameFlowUtilities">();
	}
	static class UDBDGameFlowUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDGameFlowUtilities>();
	}
};
static_assert(alignof(UDBDGameFlowUtilities) == 0x000008, "Wrong alignment on UDBDGameFlowUtilities");
static_assert(sizeof(UDBDGameFlowUtilities) == 0x000030, "Wrong size on UDBDGameFlowUtilities");

// Class DeadByDaylight.DBDGame_Menu
// 0x0020 (0x0420 - 0x0400)
class ADBDGame_Menu final : public ADBDBaseGameMode
{
public:
	bool                                          StartWithSlasher;                                  // 0x0400(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_401[0x7];                                      // 0x0401(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ALevelSequenceActor*                    _sequenceFadeActor;                                // 0x0408(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ALevelSequenceActor*                    _sequenceIntroActor;                               // 0x0410(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ALevelSequenceActor*                    _sequenceLoopActor;                                // 0x0418(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGame_Menu">();
	}
	static class ADBDGame_Menu* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDGame_Menu>();
	}
};
static_assert(alignof(ADBDGame_Menu) == 0x000008, "Wrong alignment on ADBDGame_Menu");
static_assert(sizeof(ADBDGame_Menu) == 0x000420, "Wrong size on ADBDGame_Menu");
static_assert(offsetof(ADBDGame_Menu, StartWithSlasher) == 0x000400, "Member 'ADBDGame_Menu::StartWithSlasher' has a wrong offset!");
static_assert(offsetof(ADBDGame_Menu, _sequenceFadeActor) == 0x000408, "Member 'ADBDGame_Menu::_sequenceFadeActor' has a wrong offset!");
static_assert(offsetof(ADBDGame_Menu, _sequenceIntroActor) == 0x000410, "Member 'ADBDGame_Menu::_sequenceIntroActor' has a wrong offset!");
static_assert(offsetof(ADBDGame_Menu, _sequenceLoopActor) == 0x000418, "Member 'ADBDGame_Menu::_sequenceLoopActor' has a wrong offset!");

// Class DeadByDaylight.DBDInitPlayerQueryYesNoSizeWifi
// 0x0010 (0x00C0 - 0x00B0)
class UDBDInitPlayerQueryYesNoSizeWifi final : public UDBDInitPlayerQueryYesNo
{
public:
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDInitPlayerQueryYesNoSizeWifi">();
	}
	static class UDBDInitPlayerQueryYesNoSizeWifi* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDInitPlayerQueryYesNoSizeWifi>();
	}
};
static_assert(alignof(UDBDInitPlayerQueryYesNoSizeWifi) == 0x000008, "Wrong alignment on UDBDInitPlayerQueryYesNoSizeWifi");
static_assert(sizeof(UDBDInitPlayerQueryYesNoSizeWifi) == 0x0000C0, "Wrong size on UDBDInitPlayerQueryYesNoSizeWifi");

// Class DeadByDaylight.DBDInventoryUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDInventoryUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDInventoryUtilities">();
	}
	static class UDBDInventoryUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDInventoryUtilities>();
	}
};
static_assert(alignof(UDBDInventoryUtilities) == 0x000008, "Wrong alignment on UDBDInventoryUtilities");
static_assert(sizeof(UDBDInventoryUtilities) == 0x000030, "Wrong size on UDBDInventoryUtilities");

// Class DeadByDaylight.DBDKillerItemDependenciesOverrides
// 0x0020 (0x0058 - 0x0038)
class UDBDKillerItemDependenciesOverrides final : public UDataAsset
{
public:
	TArray<struct FKillerItemDependencies>        _overrides;                                        // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FKillerComboItemDependencies>   _comboOverrides;                                   // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDKillerItemDependenciesOverrides">();
	}
	static class UDBDKillerItemDependenciesOverrides* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDKillerItemDependenciesOverrides>();
	}
};
static_assert(alignof(UDBDKillerItemDependenciesOverrides) == 0x000008, "Wrong alignment on UDBDKillerItemDependenciesOverrides");
static_assert(sizeof(UDBDKillerItemDependenciesOverrides) == 0x000058, "Wrong size on UDBDKillerItemDependenciesOverrides");
static_assert(offsetof(UDBDKillerItemDependenciesOverrides, _overrides) == 0x000038, "Member 'UDBDKillerItemDependenciesOverrides::_overrides' has a wrong offset!");
static_assert(offsetof(UDBDKillerItemDependenciesOverrides, _comboOverrides) == 0x000048, "Member 'UDBDKillerItemDependenciesOverrides::_comboOverrides' has a wrong offset!");

// Class DeadByDaylight.DBDMaterialBlueprintLibrary
// 0x0000 (0x0030 - 0x0030)
class UDBDMaterialBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class UMaterialInstanceDynamic*> CreateDynamicMaterialInstanceForParticleSystem(class UParticleSystemComponent* System);
	static void SetTransformParameterInverseValueOnMaterialDynamic(class UMaterialInstanceDynamic* Material, class FName ParameterName, const struct FTransform& Value);
	static void SetTransformParameterValueOnMaterialDynamic(class UMaterialInstanceDynamic* Material, class FName ParameterName, const struct FTransform& Value);
	static void SetTransformParameterValueOnMeshComponent(class UMeshComponent* Mesh, class FName ParameterName, const struct FTransform& Value);
	static void SetVectorParameterValueOnMeshComponent(class UMeshComponent* Mesh, class FName ParameterName, const struct FLinearColor& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDMaterialBlueprintLibrary">();
	}
	static class UDBDMaterialBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDMaterialBlueprintLibrary>();
	}
};
static_assert(alignof(UDBDMaterialBlueprintLibrary) == 0x000008, "Wrong alignment on UDBDMaterialBlueprintLibrary");
static_assert(sizeof(UDBDMaterialBlueprintLibrary) == 0x000030, "Wrong size on UDBDMaterialBlueprintLibrary");

// Class DeadByDaylight.DBDMenuGameState
// 0x0008 (0x0A98 - 0x0A90)
class ADBDMenuGameState final : public ADBDGameState
{
public:
	class UMenuForcedLODHandler*                  _menuForcedLODHandler;                             // 0x0A90(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDMenuGameState">();
	}
	static class ADBDMenuGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDMenuGameState>();
	}
};
static_assert(alignof(ADBDMenuGameState) == 0x000008, "Wrong alignment on ADBDMenuGameState");
static_assert(sizeof(ADBDMenuGameState) == 0x000A98, "Wrong size on ADBDMenuGameState");
static_assert(offsetof(ADBDMenuGameState, _menuForcedLODHandler) == 0x000A90, "Member 'ADBDMenuGameState::_menuForcedLODHandler' has a wrong offset!");

// Class DeadByDaylight.DBDMistLocatorComponent
// 0x0000 (0x02D0 - 0x02D0)
class UDBDMistLocatorComponent final : public UDBDLocatorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDMistLocatorComponent">();
	}
	static class UDBDMistLocatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDMistLocatorComponent>();
	}
};
static_assert(alignof(UDBDMistLocatorComponent) == 0x000010, "Wrong alignment on UDBDMistLocatorComponent");
static_assert(sizeof(UDBDMistLocatorComponent) == 0x0002D0, "Wrong size on UDBDMistLocatorComponent");

// Class DeadByDaylight.DBDMistManager
// 0x0008 (0x02A8 - 0x02A0)
class ADBDMistManager final : public AActor
{
public:
	class UDBDAggregateParticleSystemComponent*   _particleSystemComp;                               // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDMistManager">();
	}
	static class ADBDMistManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDMistManager>();
	}
};
static_assert(alignof(ADBDMistManager) == 0x000008, "Wrong alignment on ADBDMistManager");
static_assert(sizeof(ADBDMistManager) == 0x0002A8, "Wrong size on ADBDMistManager");
static_assert(offsetof(ADBDMistManager, _particleSystemComp) == 0x0002A0, "Member 'ADBDMistManager::_particleSystemComp' has a wrong offset!");

// Class DeadByDaylight.DBDNavEvadeLoopComponent
// 0x00B0 (0x0168 - 0x00B8)
class UDBDNavEvadeLoopComponent final : public UActorComponent
{
public:
	struct FVector                                EvadeDoorExtent;                                   // 0x00B8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EvadeDoorFrontPointOffset;                         // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EvadeDoorSideOffset;                               // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SideBlockerOffset;                                 // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoSnapPointsUpHeight;                            // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoSnapPointsDownHeight;                          // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             AutoSnapCollisionChannel;                          // 0x00E4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     EvadeLoopFilterClass;                              // 0x00E8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSafetyLength;                                   // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSafetyLength;                                   // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIEvadeLoopSides                             LimitToSide;                                       // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RequiresEvadeLoopModifier;                         // 0x00F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DrawDebugFilter;                                   // 0x00FA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FB[0x6D];                                      // 0x00FB(0x006D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDNavEvadeLoopComponent">();
	}
	static class UDBDNavEvadeLoopComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDNavEvadeLoopComponent>();
	}
};
static_assert(alignof(UDBDNavEvadeLoopComponent) == 0x000008, "Wrong alignment on UDBDNavEvadeLoopComponent");
static_assert(sizeof(UDBDNavEvadeLoopComponent) == 0x000168, "Wrong size on UDBDNavEvadeLoopComponent");
static_assert(offsetof(UDBDNavEvadeLoopComponent, EvadeDoorExtent) == 0x0000B8, "Member 'UDBDNavEvadeLoopComponent::EvadeDoorExtent' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, EvadeDoorFrontPointOffset) == 0x0000D0, "Member 'UDBDNavEvadeLoopComponent::EvadeDoorFrontPointOffset' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, EvadeDoorSideOffset) == 0x0000D4, "Member 'UDBDNavEvadeLoopComponent::EvadeDoorSideOffset' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, SideBlockerOffset) == 0x0000D8, "Member 'UDBDNavEvadeLoopComponent::SideBlockerOffset' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, AutoSnapPointsUpHeight) == 0x0000DC, "Member 'UDBDNavEvadeLoopComponent::AutoSnapPointsUpHeight' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, AutoSnapPointsDownHeight) == 0x0000E0, "Member 'UDBDNavEvadeLoopComponent::AutoSnapPointsDownHeight' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, AutoSnapCollisionChannel) == 0x0000E4, "Member 'UDBDNavEvadeLoopComponent::AutoSnapCollisionChannel' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, EvadeLoopFilterClass) == 0x0000E8, "Member 'UDBDNavEvadeLoopComponent::EvadeLoopFilterClass' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, MinSafetyLength) == 0x0000F0, "Member 'UDBDNavEvadeLoopComponent::MinSafetyLength' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, MaxSafetyLength) == 0x0000F4, "Member 'UDBDNavEvadeLoopComponent::MaxSafetyLength' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, LimitToSide) == 0x0000F8, "Member 'UDBDNavEvadeLoopComponent::LimitToSide' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, RequiresEvadeLoopModifier) == 0x0000F9, "Member 'UDBDNavEvadeLoopComponent::RequiresEvadeLoopModifier' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, DrawDebugFilter) == 0x0000FA, "Member 'UDBDNavEvadeLoopComponent::DrawDebugFilter' has a wrong offset!");

// Class DeadByDaylight.DBDObserverPlayer
// 0x0040 (0x0690 - 0x0650)
class ADBDObserverPlayer final : public ACharacter
{
public:
	class UDBDPlayerData*                         _playerData;                                       // 0x0650(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_658[0x38];                                     // 0x0658(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Server_PlayerReady();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDObserverPlayer">();
	}
	static class ADBDObserverPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDObserverPlayer>();
	}
};
static_assert(alignof(ADBDObserverPlayer) == 0x000010, "Wrong alignment on ADBDObserverPlayer");
static_assert(sizeof(ADBDObserverPlayer) == 0x000690, "Wrong size on ADBDObserverPlayer");
static_assert(offsetof(ADBDObserverPlayer, _playerData) == 0x000650, "Member 'ADBDObserverPlayer::_playerData' has a wrong offset!");

// Class DeadByDaylight.DBDOutlineComponentCustomDepthConfiguration
// 0x0000 (0x0138 - 0x0138)
class UDBDOutlineComponentCustomDepthConfiguration final : public UDBDOutlineComponentConfiguration
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDOutlineComponentCustomDepthConfiguration">();
	}
	static class UDBDOutlineComponentCustomDepthConfiguration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDOutlineComponentCustomDepthConfiguration>();
	}
};
static_assert(alignof(UDBDOutlineComponentCustomDepthConfiguration) == 0x000008, "Wrong alignment on UDBDOutlineComponentCustomDepthConfiguration");
static_assert(sizeof(UDBDOutlineComponentCustomDepthConfiguration) == 0x000138, "Wrong size on UDBDOutlineComponentCustomDepthConfiguration");

// Class DeadByDaylight.DBDOutlineComponentStencilConfiguration
// 0x0000 (0x0138 - 0x0138)
class UDBDOutlineComponentStencilConfiguration final : public UDBDOutlineComponentConfiguration
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDOutlineComponentStencilConfiguration">();
	}
	static class UDBDOutlineComponentStencilConfiguration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDOutlineComponentStencilConfiguration>();
	}
};
static_assert(alignof(UDBDOutlineComponentStencilConfiguration) == 0x000008, "Wrong alignment on UDBDOutlineComponentStencilConfiguration");
static_assert(sizeof(UDBDOutlineComponentStencilConfiguration) == 0x000138, "Wrong size on UDBDOutlineComponentStencilConfiguration");

// Class DeadByDaylight.DBDPartyFacade
// 0x0010 (0x04F8 - 0x04E8)
class UDBDPartyFacade final : public UPartyFacade
{
public:
	uint8                                         Pad_4E8[0x10];                                     // 0x04E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPartyFacade">();
	}
	static class UDBDPartyFacade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDPartyFacade>();
	}
};
static_assert(alignof(UDBDPartyFacade) == 0x000008, "Wrong alignment on UDBDPartyFacade");
static_assert(sizeof(UDBDPartyFacade) == 0x0004F8, "Wrong size on UDBDPartyFacade");

// Class DeadByDaylight.DBDPawnSensingComponent
// 0x0010 (0x0110 - 0x0100)
class UDBDPawnSensingComponent final : public UPawnSensingComponent
{
public:
	bool                                          bSenseEverywhere;                                  // 0x0100(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x3];                                      // 0x0101(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PartiallyHiddenSensingDistance;                    // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPawnSensingComponent">();
	}
	static class UDBDPawnSensingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDPawnSensingComponent>();
	}
};
static_assert(alignof(UDBDPawnSensingComponent) == 0x000008, "Wrong alignment on UDBDPawnSensingComponent");
static_assert(sizeof(UDBDPawnSensingComponent) == 0x000110, "Wrong size on UDBDPawnSensingComponent");
static_assert(offsetof(UDBDPawnSensingComponent, bSenseEverywhere) == 0x000100, "Member 'UDBDPawnSensingComponent::bSenseEverywhere' has a wrong offset!");
static_assert(offsetof(UDBDPawnSensingComponent, PartiallyHiddenSensingDistance) == 0x000104, "Member 'UDBDPawnSensingComponent::PartiallyHiddenSensingDistance' has a wrong offset!");

// Class DeadByDaylight.DBDPlayerAudioHandlerComponent
// 0x00A0 (0x0158 - 0x00B8)
class UDBDPlayerAudioHandlerComponent : public UActorComponent
{
public:
	class FString                                 _stopMovingRTPC;                                   // 0x00B8(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FDBDCharacterMovementSpeedRTPC> _movementRTPCs;                                    // 0x00C8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x80];                                      // 0x00D8(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerAudioHandlerComponent">();
	}
	static class UDBDPlayerAudioHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDPlayerAudioHandlerComponent>();
	}
};
static_assert(alignof(UDBDPlayerAudioHandlerComponent) == 0x000008, "Wrong alignment on UDBDPlayerAudioHandlerComponent");
static_assert(sizeof(UDBDPlayerAudioHandlerComponent) == 0x000158, "Wrong size on UDBDPlayerAudioHandlerComponent");
static_assert(offsetof(UDBDPlayerAudioHandlerComponent, _stopMovingRTPC) == 0x0000B8, "Member 'UDBDPlayerAudioHandlerComponent::_stopMovingRTPC' has a wrong offset!");
static_assert(offsetof(UDBDPlayerAudioHandlerComponent, _movementRTPCs) == 0x0000C8, "Member 'UDBDPlayerAudioHandlerComponent::_movementRTPCs' has a wrong offset!");

// Class DeadByDaylight.DBDPlayerController
// 0x0108 (0x0A40 - 0x0938)
class ADBDPlayerController final : public ADBDPlayerControllerBase
{
public:
	TMulticastInlineDelegate<void(class ADBDPlayer* leavingPlayer)> OnPawnLeavingGame;               // 0x0938(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLocallyObservedChanged;                          // 0x0948(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_958[0x98];                                     // 0x0958(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	class ANetworkFenceActor*                     _theFence;                                         // 0x09F0(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9F8[0x8];                                      // 0x09F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDBaseInputHandler*                   _inputHandler;                                     // 0x0A00(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A08[0x20];                                     // 0x0A08(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  _aiPawn;                                           // 0x0A28(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A30[0x8];                                      // 0x0A30(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EPlayerRole                                   _controllerGameRole;                               // 0x0A38(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A39[0x7];                                      // 0x0A39(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateAI(bool Activate, int32 playerRank);
	void Client_SetPlayerFinishStats(const struct FPlayerFinishStats& Stats);
	void Client_SetSpectatorMode(bool On);
	void Client_SetSpectatorModeInEditor(bool On, class ADBDPlayerState* spectatingPlayerState);
	void Client_SpectateAI(class APawn* aiPawn);
	void ImplementRunLockMechanic();
	void OnRep_Fence();
	void Server_ClientTimeSinceLastLoadingProgress(float lastProgression);
	void Server_DebugSend(const class FString& Data);
	void Server_ForceGameObjectivesCompleted(bool COMPLETED);
	void Server_InitiateSecretRewardProcess(const TArray<class FName>& unclaimedIds);
	void Server_LeaveGame(bool joiningLobby);
	void Server_NotifyHasMoved();
	void Server_RequestEndGame();
	void Server_SetReadyToTravel();
	void Server_SetSpectatorMode(bool On);
	void Server_SetSpectatorModeInEditor(bool On, class ADBDPlayerState* spectatingPlayerState);
	void Server_ViewPlayerWithId(const class FString& PlayerId);
	void ServerViewPlayer(const class FString& PlayerName);

	class APawn* GetAIPawn() const;
	class ADBDPlayer* GetControlledPlayer() const;
	class ADBDPlayer* GetSpectatedPlayer() const;
	class ADBDPlayerState* GetSpectatedPlayerState() const;
	bool IsSpectating() const;
	bool MobileJoystickInput_Pressed(int32 joystickIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerController">();
	}
	static class ADBDPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDPlayerController>();
	}
};
static_assert(alignof(ADBDPlayerController) == 0x000008, "Wrong alignment on ADBDPlayerController");
static_assert(sizeof(ADBDPlayerController) == 0x000A40, "Wrong size on ADBDPlayerController");
static_assert(offsetof(ADBDPlayerController, OnPawnLeavingGame) == 0x000938, "Member 'ADBDPlayerController::OnPawnLeavingGame' has a wrong offset!");
static_assert(offsetof(ADBDPlayerController, OnLocallyObservedChanged) == 0x000948, "Member 'ADBDPlayerController::OnLocallyObservedChanged' has a wrong offset!");
static_assert(offsetof(ADBDPlayerController, _theFence) == 0x0009F0, "Member 'ADBDPlayerController::_theFence' has a wrong offset!");
static_assert(offsetof(ADBDPlayerController, _inputHandler) == 0x000A00, "Member 'ADBDPlayerController::_inputHandler' has a wrong offset!");
static_assert(offsetof(ADBDPlayerController, _aiPawn) == 0x000A28, "Member 'ADBDPlayerController::_aiPawn' has a wrong offset!");
static_assert(offsetof(ADBDPlayerController, _controllerGameRole) == 0x000A38, "Member 'ADBDPlayerController::_controllerGameRole' has a wrong offset!");

// Class DeadByDaylight.DBDPlayerData
// 0x00A8 (0x0160 - 0x00B8)
class UDBDPlayerData final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(bool IsPressed)> OnItemUseButtonStateChanged;                      // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x80];                                      // 0x00C8(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	struct FYawAndPitchRotator_NetQuantize16      _controlRotation;                                  // 0x0148(0x0018)(Net, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void Server_CampaignDataSynced();
	void Server_LoadoutSpawned();
	void Server_NotifyAIPawnReady();
	void Server_RenderingFeaturesCompleted();
	void Server_SetIntroCompleted();
	void Server_SetKillerSpecificComponentReady();
	void Server_SetMapSpecificComponentReady(const class FString& componentName);
	void Server_SetMutatorComponentReady();
	void Server_SetPlayerReady();

	struct FRotator GetControlRotation() const;
	bool IsInteractionInputPressed(EInputInteractionType interactionType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerData">();
	}
	static class UDBDPlayerData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDPlayerData>();
	}
};
static_assert(alignof(UDBDPlayerData) == 0x000008, "Wrong alignment on UDBDPlayerData");
static_assert(sizeof(UDBDPlayerData) == 0x000160, "Wrong size on UDBDPlayerData");
static_assert(offsetof(UDBDPlayerData, OnItemUseButtonStateChanged) == 0x0000B8, "Member 'UDBDPlayerData::OnItemUseButtonStateChanged' has a wrong offset!");
static_assert(offsetof(UDBDPlayerData, _controlRotation) == 0x000148, "Member 'UDBDPlayerData::_controlRotation' has a wrong offset!");

// Class DeadByDaylight.DBDPlayerLevelManager
// 0x0168 (0x0198 - 0x0030)
class UDBDPlayerLevelManager final : public UObject
{
public:
	uint8                                         Pad_30[0x168];                                     // 0x0030(0x0168)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerLevelManager">();
	}
	static class UDBDPlayerLevelManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDPlayerLevelManager>();
	}
};
static_assert(alignof(UDBDPlayerLevelManager) == 0x000008, "Wrong alignment on UDBDPlayerLevelManager");
static_assert(sizeof(UDBDPlayerLevelManager) == 0x000198, "Wrong size on UDBDPlayerLevelManager");

// Class DeadByDaylight.DBDProjectileUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDProjectileUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UAuthoritativePoolProjectileProviderAdapter* CreateProjectilePoolAdapter(class UObject* Outer_0, class UAuthoritativeActorPoolComponent* Pool);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDProjectileUtilities">();
	}
	static class UDBDProjectileUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDProjectileUtilities>();
	}
};
static_assert(alignof(UDBDProjectileUtilities) == 0x000008, "Wrong alignment on UDBDProjectileUtilities");
static_assert(sizeof(UDBDProjectileUtilities) == 0x000030, "Wrong size on UDBDProjectileUtilities");

// Class DeadByDaylight.DBDHostSettingsParamsBase
// 0x0010 (0x0040 - 0x0030)
class UDBDHostSettingsParamsBase : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDHostSettingsParamsBase">();
	}
	static class UDBDHostSettingsParamsBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDHostSettingsParamsBase>();
	}
};
static_assert(alignof(UDBDHostSettingsParamsBase) == 0x000008, "Wrong alignment on UDBDHostSettingsParamsBase");
static_assert(sizeof(UDBDHostSettingsParamsBase) == 0x000040, "Wrong size on UDBDHostSettingsParamsBase");

// Class DeadByDaylight.DBDHostSettingsParamsSessionInvalid
// 0x0000 (0x0040 - 0x0040)
class UDBDHostSettingsParamsSessionInvalid final : public UDBDHostSettingsParamsBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDHostSettingsParamsSessionInvalid">();
	}
	static class UDBDHostSettingsParamsSessionInvalid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDHostSettingsParamsSessionInvalid>();
	}
};
static_assert(alignof(UDBDHostSettingsParamsSessionInvalid) == 0x000008, "Wrong alignment on UDBDHostSettingsParamsSessionInvalid");
static_assert(sizeof(UDBDHostSettingsParamsSessionInvalid) == 0x000040, "Wrong size on UDBDHostSettingsParamsSessionInvalid");

// Class DeadByDaylight.DBDHostSettingsParamsJoinabilityPreset
// 0x0008 (0x0048 - 0x0040)
class UDBDHostSettingsParamsJoinabilityPreset final : public UDBDHostSettingsParamsBase
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDHostSettingsParamsJoinabilityPreset">();
	}
	static class UDBDHostSettingsParamsJoinabilityPreset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDHostSettingsParamsJoinabilityPreset>();
	}
};
static_assert(alignof(UDBDHostSettingsParamsJoinabilityPreset) == 0x000008, "Wrong alignment on UDBDHostSettingsParamsJoinabilityPreset");
static_assert(sizeof(UDBDHostSettingsParamsJoinabilityPreset) == 0x000048, "Wrong size on UDBDHostSettingsParamsJoinabilityPreset");

// Class DeadByDaylight.DBDHostSettingsParamsRanking
// 0x0008 (0x0048 - 0x0040)
class UDBDHostSettingsParamsRanking final : public UDBDHostSettingsParamsBase
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDHostSettingsParamsRanking">();
	}
	static class UDBDHostSettingsParamsRanking* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDHostSettingsParamsRanking>();
	}
};
static_assert(alignof(UDBDHostSettingsParamsRanking) == 0x000008, "Wrong alignment on UDBDHostSettingsParamsRanking");
static_assert(sizeof(UDBDHostSettingsParamsRanking) == 0x000048, "Wrong size on UDBDHostSettingsParamsRanking");

// Class DeadByDaylight.DBDSocialNotificationFactory
// 0x0040 (0x0070 - 0x0030)
class UDBDSocialNotificationFactory final : public UObject
{
public:
	TWeakObjectPtr<class UDBDGameInstance>        _gameInstance;                                     // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UToastManager*                          _toastMgr;                                         // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDPartyFacade*                        _partyFacade;                                      // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFriendManager*                         _friendManager;                                    // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             _toastTable;                                       // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x18];                                      // 0x0058(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDSocialNotificationFactory">();
	}
	static class UDBDSocialNotificationFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDSocialNotificationFactory>();
	}
};
static_assert(alignof(UDBDSocialNotificationFactory) == 0x000008, "Wrong alignment on UDBDSocialNotificationFactory");
static_assert(sizeof(UDBDSocialNotificationFactory) == 0x000070, "Wrong size on UDBDSocialNotificationFactory");
static_assert(offsetof(UDBDSocialNotificationFactory, _gameInstance) == 0x000030, "Member 'UDBDSocialNotificationFactory::_gameInstance' has a wrong offset!");
static_assert(offsetof(UDBDSocialNotificationFactory, _toastMgr) == 0x000038, "Member 'UDBDSocialNotificationFactory::_toastMgr' has a wrong offset!");
static_assert(offsetof(UDBDSocialNotificationFactory, _partyFacade) == 0x000040, "Member 'UDBDSocialNotificationFactory::_partyFacade' has a wrong offset!");
static_assert(offsetof(UDBDSocialNotificationFactory, _friendManager) == 0x000048, "Member 'UDBDSocialNotificationFactory::_friendManager' has a wrong offset!");
static_assert(offsetof(UDBDSocialNotificationFactory, _toastTable) == 0x000050, "Member 'UDBDSocialNotificationFactory::_toastTable' has a wrong offset!");

// Class DeadByDaylight.DBDSpecialEventUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDSpecialEventUtilities final : public UBlueprintFunctionLibrary
{
public:
	static bool DoesPlayerHasEventOffering(const class ADBDPlayer* Player, EOfferingEffectType offeringEffectType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDSpecialEventUtilities">();
	}
	static class UDBDSpecialEventUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDSpecialEventUtilities>();
	}
};
static_assert(alignof(UDBDSpecialEventUtilities) == 0x000008, "Wrong alignment on UDBDSpecialEventUtilities");
static_assert(sizeof(UDBDSpecialEventUtilities) == 0x000030, "Wrong size on UDBDSpecialEventUtilities");

// Class DeadByDaylight.DBDSurfaceTypeName
// 0x0000 (0x0030 - 0x0030)
class UDBDSurfaceTypeName final : public UBlueprintFunctionLibrary
{
public:
	static class FName Convert(const EPhysicalSurface SurfaceType);
	static class FName ConvertFromPhysicalMaterial(const class UPhysicalMaterial* Material);
	static class FString GetSurfaceName(const class UPhysicalMaterial* PhysicalMaterial);
	static EPhysicalSurface GetSurfaceType(const class UPhysicalMaterial* PhysicalMaterial);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDSurfaceTypeName">();
	}
	static class UDBDSurfaceTypeName* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDSurfaceTypeName>();
	}
};
static_assert(alignof(UDBDSurfaceTypeName) == 0x000008, "Wrong alignment on UDBDSurfaceTypeName");
static_assert(sizeof(UDBDSurfaceTypeName) == 0x000030, "Wrong size on UDBDSurfaceTypeName");

// Class DeadByDaylight.DBDTagUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDTagUtilities final : public UBlueprintFunctionLibrary
{
public:
	static bool ActorHasReplicatedTag(const class AActor* Actor, class FName Tag);
	static void GetAllActorsOfClassWithReplicatedTag(const class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, class FName Tag, TArray<class AActor*>* OutActors);
	static void GetAllActorsWithReplicatedTag(const class UObject* WorldContextObject, class FName Tag, TArray<class AActor*>* OutActors);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDTagUtilities">();
	}
	static class UDBDTagUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDTagUtilities>();
	}
};
static_assert(alignof(UDBDTagUtilities) == 0x000008, "Wrong alignment on UDBDTagUtilities");
static_assert(sizeof(UDBDTagUtilities) == 0x000030, "Wrong size on UDBDTagUtilities");

// Class DeadByDaylight.DBDTimerComponent
// 0x0030 (0x00E8 - 0x00B8)
class UDBDTimerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x30];                                      // 0x00B8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Pause();
	void Reset();
	void ResetTo(float Time);
	void Stop();
	void Unpause();
	void Update(float DeltaTime);

	float GetPercentTimeElapsed() const;
	float GetPercentTimeLeft() const;
	float GetStartTime() const;
	float GetTimeElapsed() const;
	float GetTimeLeft() const;
	bool IsDone() const;
	bool IsOnPause() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDTimerComponent">();
	}
	static class UDBDTimerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDTimerComponent>();
	}
};
static_assert(alignof(UDBDTimerComponent) == 0x000008, "Wrong alignment on UDBDTimerComponent");
static_assert(sizeof(UDBDTimerComponent) == 0x0000E8, "Wrong size on UDBDTimerComponent");

// Class DeadByDaylight.DBDUtilTimer
// 0x0000 (0x0030 - 0x0030)
class UDBDUtilTimer final : public UBlueprintFunctionLibrary
{
public:
	static float GetPercentTimeElapsed(const struct FDBDTimer& Timer);
	static float GetPercentTimeLeft(const struct FDBDTimer& Timer);
	static float GetStartTime(const struct FDBDTimer& Timer);
	static float GetTimeElapsed(const struct FDBDTimer& Timer);
	static float GetTimeLeft(const struct FDBDTimer& Timer);
	static bool IsDone(const struct FDBDTimer& Timer);
	static void Reset(struct FDBDTimer& Timer);
	static void ResetTo(struct FDBDTimer& Timer, float Time);
	static void Stop(struct FDBDTimer& Timer);
	static void Update(struct FDBDTimer& Timer, float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDUtilTimer">();
	}
	static class UDBDUtilTimer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDUtilTimer>();
	}
};
static_assert(alignof(UDBDUtilTimer) == 0x000008, "Wrong alignment on UDBDUtilTimer");
static_assert(sizeof(UDBDUtilTimer) == 0x000030, "Wrong size on UDBDUtilTimer");

// Class DeadByDaylight.DedicatedServerHandlerComponent
// 0x0018 (0x00D0 - 0x00B8)
class UDedicatedServerHandlerComponent final : public UActorComponent
{
public:
	TArray<class FString>                         _ownedCharacters;                                  // 0x00B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DedicatedServerHandlerComponent">();
	}
	static class UDedicatedServerHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDedicatedServerHandlerComponent>();
	}
};
static_assert(alignof(UDedicatedServerHandlerComponent) == 0x000008, "Wrong alignment on UDedicatedServerHandlerComponent");
static_assert(sizeof(UDedicatedServerHandlerComponent) == 0x0000D0, "Wrong size on UDedicatedServerHandlerComponent");
static_assert(offsetof(UDedicatedServerHandlerComponent, _ownedCharacters) == 0x0000B8, "Member 'UDedicatedServerHandlerComponent::_ownedCharacters' has a wrong offset!");

// Class DeadByDaylight.DedicatedServerStartupInitializerInterface
// 0x0000 (0x0000 - 0x0000)
class IDedicatedServerStartupInitializerInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DedicatedServerStartupInitializerInterface">();
	}
	static class IDedicatedServerStartupInitializerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDedicatedServerStartupInitializerInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IDedicatedServerStartupInitializerInterface) == 0x000001, "Wrong alignment on IDedicatedServerStartupInitializerInterface");
static_assert(sizeof(IDedicatedServerStartupInitializerInterface) == 0x000001, "Wrong size on IDedicatedServerStartupInitializerInterface");

// Class DeadByDaylight.DesignTunablesSearchableItemStrategy
// 0x0010 (0x0048 - 0x0038)
class UDesignTunablesSearchableItemStrategy final : public USearchableItemStrategy
{
public:
	EItemRarity                                   ItemRarity;                                        // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFixedRarity;                                     // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _itemIdToSpawn;                                    // 0x003C(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DesignTunablesSearchableItemStrategy">();
	}
	static class UDesignTunablesSearchableItemStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDesignTunablesSearchableItemStrategy>();
	}
};
static_assert(alignof(UDesignTunablesSearchableItemStrategy) == 0x000008, "Wrong alignment on UDesignTunablesSearchableItemStrategy");
static_assert(sizeof(UDesignTunablesSearchableItemStrategy) == 0x000048, "Wrong size on UDesignTunablesSearchableItemStrategy");
static_assert(offsetof(UDesignTunablesSearchableItemStrategy, ItemRarity) == 0x000038, "Member 'UDesignTunablesSearchableItemStrategy::ItemRarity' has a wrong offset!");
static_assert(offsetof(UDesignTunablesSearchableItemStrategy, IsFixedRarity) == 0x000039, "Member 'UDesignTunablesSearchableItemStrategy::IsFixedRarity' has a wrong offset!");
static_assert(offsetof(UDesignTunablesSearchableItemStrategy, _itemIdToSpawn) == 0x00003C, "Member 'UDesignTunablesSearchableItemStrategy::_itemIdToSpawn' has a wrong offset!");

// Class DeadByDaylight.DestroyBreakableDefinition
// 0x0060 (0x07D0 - 0x0770)
class UDestroyBreakableDefinition final : public UInteractionDefinition
{
public:
	float                                         _interactionTimePercentForDestroyEvent;            // 0x0768(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_76C[0x2C];                                     // 0x076C(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	class ABreakableBase*                         _breakable;                                        // 0x0798(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _fastInteractionAnimThreshold;                     // 0x07A0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C8[0x8];                                      // 0x07C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ABreakableBase* GetBreakable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DestroyBreakableDefinition">();
	}
	static class UDestroyBreakableDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDestroyBreakableDefinition>();
	}
};
static_assert(alignof(UDestroyBreakableDefinition) == 0x000010, "Wrong alignment on UDestroyBreakableDefinition");
static_assert(sizeof(UDestroyBreakableDefinition) == 0x0007D0, "Wrong size on UDestroyBreakableDefinition");
static_assert(offsetof(UDestroyBreakableDefinition, _interactionTimePercentForDestroyEvent) == 0x000768, "Member 'UDestroyBreakableDefinition::_interactionTimePercentForDestroyEvent' has a wrong offset!");
static_assert(offsetof(UDestroyBreakableDefinition, _breakable) == 0x000798, "Member 'UDestroyBreakableDefinition::_breakable' has a wrong offset!");
static_assert(offsetof(UDestroyBreakableDefinition, _fastInteractionAnimThreshold) == 0x0007A0, "Member 'UDestroyBreakableDefinition::_fastInteractionAnimThreshold' has a wrong offset!");

// Class DeadByDaylight.DirectionalMinigameComponent
// 0x0078 (0x0130 - 0x00B8)
class UDirectionalMinigameComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(const TArray<EDirectionalInputKey>& Sequence)> OnDirectionalMinigameStart; // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x20];                                      // 0x00C8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class ASurvivor*                              _currentlyEngagedSurvivor;                         // 0x00E8(0x0008)(Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<EDirectionalInputKey>                  _currentSequence;                                  // 0x00F0(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          _isInProgress;                                     // 0x0100(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_101[0x3];                                      // 0x0101(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _currentKeyIndex;                                  // 0x0104(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDirectionalMiniGameDefinition         _miniGameDefinition;                               // 0x0108(0x0020)(Net, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_StartMinigameForSurvivor(class ASurvivor* Survivor, const struct FDirectionalMiniGameDefinition& miniGameDefinition);
	void Local_EnterKey(EDirectionalInputKey enteredKey);
	void OnRep_IsInProgress();
	void Server_CancelMinigame();
	void Server_EnterKey(EDirectionalInputKey enteredKey);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DirectionalMinigameComponent">();
	}
	static class UDirectionalMinigameComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDirectionalMinigameComponent>();
	}
};
static_assert(alignof(UDirectionalMinigameComponent) == 0x000008, "Wrong alignment on UDirectionalMinigameComponent");
static_assert(sizeof(UDirectionalMinigameComponent) == 0x000130, "Wrong size on UDirectionalMinigameComponent");
static_assert(offsetof(UDirectionalMinigameComponent, OnDirectionalMinigameStart) == 0x0000B8, "Member 'UDirectionalMinigameComponent::OnDirectionalMinigameStart' has a wrong offset!");
static_assert(offsetof(UDirectionalMinigameComponent, _currentlyEngagedSurvivor) == 0x0000E8, "Member 'UDirectionalMinigameComponent::_currentlyEngagedSurvivor' has a wrong offset!");
static_assert(offsetof(UDirectionalMinigameComponent, _currentSequence) == 0x0000F0, "Member 'UDirectionalMinigameComponent::_currentSequence' has a wrong offset!");
static_assert(offsetof(UDirectionalMinigameComponent, _isInProgress) == 0x000100, "Member 'UDirectionalMinigameComponent::_isInProgress' has a wrong offset!");
static_assert(offsetof(UDirectionalMinigameComponent, _currentKeyIndex) == 0x000104, "Member 'UDirectionalMinigameComponent::_currentKeyIndex' has a wrong offset!");
static_assert(offsetof(UDirectionalMinigameComponent, _miniGameDefinition) == 0x000108, "Member 'UDirectionalMinigameComponent::_miniGameDefinition' has a wrong offset!");

// Class DeadByDaylight.DirectionalMinigameSurvivorComponent
// 0x0068 (0x0120 - 0x00B8)
class UDirectionalMinigameSurvivorComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x68];                                      // 0x00B8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_StopInteraction(class UDirectionalMinigameComponent* directionalMinigame, EDirectionalMinigameResult Result);
	void Server_CancelMinigame(class UDirectionalMinigameComponent* directionalMinigame);
	void Server_EnterKey(class UDirectionalMinigameComponent* directionalMinigame, EDirectionalInputKey Key);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DirectionalMinigameSurvivorComponent">();
	}
	static class UDirectionalMinigameSurvivorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDirectionalMinigameSurvivorComponent>();
	}
};
static_assert(alignof(UDirectionalMinigameSurvivorComponent) == 0x000008, "Wrong alignment on UDirectionalMinigameSurvivorComponent");
static_assert(sizeof(UDirectionalMinigameSurvivorComponent) == 0x000120, "Wrong size on UDirectionalMinigameSurvivorComponent");

// Class DeadByDaylight.DischargeUntilThresholdIsReachedComponent
// 0x0058 (0x0110 - 0x00B8)
class UDischargeUntilThresholdIsReachedComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _threshold;                                        // 0x00D0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _chargeableComponent;                              // 0x00F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x10];                                     // 0x0100(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnChargePercentChanged(class UChargeableComponent* ChargeableComponent, float PercentCompletionChange, float TotalPercentComplete);
	void OnChargePercentChanged(class UChargeableComponent* ChargeableComponent, float TotalPercentComplete);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DischargeUntilThresholdIsReachedComponent">();
	}
	static class UDischargeUntilThresholdIsReachedComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDischargeUntilThresholdIsReachedComponent>();
	}
};
static_assert(alignof(UDischargeUntilThresholdIsReachedComponent) == 0x000008, "Wrong alignment on UDischargeUntilThresholdIsReachedComponent");
static_assert(sizeof(UDischargeUntilThresholdIsReachedComponent) == 0x000110, "Wrong size on UDischargeUntilThresholdIsReachedComponent");
static_assert(offsetof(UDischargeUntilThresholdIsReachedComponent, _threshold) == 0x0000D0, "Member 'UDischargeUntilThresholdIsReachedComponent::_threshold' has a wrong offset!");
static_assert(offsetof(UDischargeUntilThresholdIsReachedComponent, _chargeableComponent) == 0x0000F8, "Member 'UDischargeUntilThresholdIsReachedComponent::_chargeableComponent' has a wrong offset!");

// Class DeadByDaylight.DistanceFromActorsIterativeWeightAdjustmentStrategy
// 0x00B8 (0x00F8 - 0x0040)
class UDistanceFromActorsIterativeWeightAdjustmentStrategy final : public UIterativeWeightAdjustmentStrategy
{
public:
	TArray<class USceneComponent*>                _actorLocations;                                   // 0x0040(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   _actorToCompareDistanceFrom;                       // 0x0050(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGameplayElementType                          _actorGameplayElementSpawnerType;                  // 0x0088(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETileSpawnPointType                           _actorTileSpawnPointType;                          // 0x0089(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8A[0x6];                                       // 0x008A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDistanceFromActorsStrategyData        _strategyData;                                     // 0x0090(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	TMap<class FString, struct FDistanceFromActorsStrategyData> _strategyDataMapOverrides;           // 0x00A0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x8];                                       // 0x00F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DistanceFromActorsIterativeWeightAdjustmentStrategy">();
	}
	static class UDistanceFromActorsIterativeWeightAdjustmentStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDistanceFromActorsIterativeWeightAdjustmentStrategy>();
	}
};
static_assert(alignof(UDistanceFromActorsIterativeWeightAdjustmentStrategy) == 0x000008, "Wrong alignment on UDistanceFromActorsIterativeWeightAdjustmentStrategy");
static_assert(sizeof(UDistanceFromActorsIterativeWeightAdjustmentStrategy) == 0x0000F8, "Wrong size on UDistanceFromActorsIterativeWeightAdjustmentStrategy");
static_assert(offsetof(UDistanceFromActorsIterativeWeightAdjustmentStrategy, _actorLocations) == 0x000040, "Member 'UDistanceFromActorsIterativeWeightAdjustmentStrategy::_actorLocations' has a wrong offset!");
static_assert(offsetof(UDistanceFromActorsIterativeWeightAdjustmentStrategy, _actorToCompareDistanceFrom) == 0x000050, "Member 'UDistanceFromActorsIterativeWeightAdjustmentStrategy::_actorToCompareDistanceFrom' has a wrong offset!");
static_assert(offsetof(UDistanceFromActorsIterativeWeightAdjustmentStrategy, _actorGameplayElementSpawnerType) == 0x000088, "Member 'UDistanceFromActorsIterativeWeightAdjustmentStrategy::_actorGameplayElementSpawnerType' has a wrong offset!");
static_assert(offsetof(UDistanceFromActorsIterativeWeightAdjustmentStrategy, _actorTileSpawnPointType) == 0x000089, "Member 'UDistanceFromActorsIterativeWeightAdjustmentStrategy::_actorTileSpawnPointType' has a wrong offset!");
static_assert(offsetof(UDistanceFromActorsIterativeWeightAdjustmentStrategy, _strategyData) == 0x000090, "Member 'UDistanceFromActorsIterativeWeightAdjustmentStrategy::_strategyData' has a wrong offset!");
static_assert(offsetof(UDistanceFromActorsIterativeWeightAdjustmentStrategy, _strategyDataMapOverrides) == 0x0000A0, "Member 'UDistanceFromActorsIterativeWeightAdjustmentStrategy::_strategyDataMapOverrides' has a wrong offset!");

// Class DeadByDaylight.DoctorPowerAnimStateComponent
// 0x0008 (0x00C0 - 0x00B8)
class UDoctorPowerAnimStateComponent final : public UActorComponent
{
public:
	EDoctorAbilityType                            _abilityType;                                      // 0x00B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDoctorAbilityPhase                           _abilityPhase;                                     // 0x00B9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x6];                                       // 0x00BA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCurrentAbilityPhase(EDoctorAbilityPhase abilityPhase);
	void SetCurrentAbilityType(EDoctorAbilityType abilityType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoctorPowerAnimStateComponent">();
	}
	static class UDoctorPowerAnimStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDoctorPowerAnimStateComponent>();
	}
};
static_assert(alignof(UDoctorPowerAnimStateComponent) == 0x000008, "Wrong alignment on UDoctorPowerAnimStateComponent");
static_assert(sizeof(UDoctorPowerAnimStateComponent) == 0x0000C0, "Wrong size on UDoctorPowerAnimStateComponent");
static_assert(offsetof(UDoctorPowerAnimStateComponent, _abilityType) == 0x0000B8, "Member 'UDoctorPowerAnimStateComponent::_abilityType' has a wrong offset!");
static_assert(offsetof(UDoctorPowerAnimStateComponent, _abilityPhase) == 0x0000B9, "Member 'UDoctorPowerAnimStateComponent::_abilityPhase' has a wrong offset!");

// Class DeadByDaylight.WorldObjectTriggeringPlayerComponent
// 0x0000 (0x00C0 - 0x00C0)
class UWorldObjectTriggeringPlayerComponent : public UWorldObjectTriggeringActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldObjectTriggeringPlayerComponent">();
	}
	static class UWorldObjectTriggeringPlayerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldObjectTriggeringPlayerComponent>();
	}
};
static_assert(alignof(UWorldObjectTriggeringPlayerComponent) == 0x000008, "Wrong alignment on UWorldObjectTriggeringPlayerComponent");
static_assert(sizeof(UWorldObjectTriggeringPlayerComponent) == 0x0000C0, "Wrong size on UWorldObjectTriggeringPlayerComponent");

// Class DeadByDaylight.WorldObjectTriggeringSurvivorComponent
// 0x0000 (0x00C0 - 0x00C0)
class UWorldObjectTriggeringSurvivorComponent final : public UWorldObjectTriggeringPlayerComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldObjectTriggeringSurvivorComponent">();
	}
	static class UWorldObjectTriggeringSurvivorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldObjectTriggeringSurvivorComponent>();
	}
};
static_assert(alignof(UWorldObjectTriggeringSurvivorComponent) == 0x000008, "Wrong alignment on UWorldObjectTriggeringSurvivorComponent");
static_assert(sizeof(UWorldObjectTriggeringSurvivorComponent) == 0x0000C0, "Wrong size on UWorldObjectTriggeringSurvivorComponent");

// Class DeadByDaylight.DragDropOperation_Widget
// 0x0128 (0x01C0 - 0x0098)
class UDragDropOperation_Widget final : public UDragDropOperation
{
public:
	class UUMGDragWidget*                         Widget;                                            // 0x0098(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPanelWidget*                           WidgetParent;                                      // 0x00A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              StartPosition;                                     // 0x00A8(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              WidgetLocalScale;                                  // 0x00B8(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x18];                                      // 0x00C8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WidgetLocalOpacity;                                // 0x00E0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              OnDropOffset;                                      // 0x00E8(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OnDragOffset;                                      // 0x00F8(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnchors                               WidgetSlotAnchors;                                 // 0x0108(0x0020)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FMargin                                WidgetSlotOffsets;                                 // 0x0128(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              WidgetSlotPosition;                                // 0x0138(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              WidgetSlotSize;                                    // 0x0148(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WidgetSlotAutoSize;                                // 0x0158(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              WidgetSlotAlignment;                               // 0x0160(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WidgetSlotZOrder;                                  // 0x0170(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUMGDragWidget*                         ChildLinkWidget;                                   // 0x0178(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_180[0x40];                                     // 0x0180(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DragDropOperation_Widget">();
	}
	static class UDragDropOperation_Widget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDragDropOperation_Widget>();
	}
};
static_assert(alignof(UDragDropOperation_Widget) == 0x000008, "Wrong alignment on UDragDropOperation_Widget");
static_assert(sizeof(UDragDropOperation_Widget) == 0x0001C0, "Wrong size on UDragDropOperation_Widget");
static_assert(offsetof(UDragDropOperation_Widget, Widget) == 0x000098, "Member 'UDragDropOperation_Widget::Widget' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, WidgetParent) == 0x0000A0, "Member 'UDragDropOperation_Widget::WidgetParent' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, StartPosition) == 0x0000A8, "Member 'UDragDropOperation_Widget::StartPosition' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, WidgetLocalScale) == 0x0000B8, "Member 'UDragDropOperation_Widget::WidgetLocalScale' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, WidgetLocalOpacity) == 0x0000E0, "Member 'UDragDropOperation_Widget::WidgetLocalOpacity' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, OnDropOffset) == 0x0000E8, "Member 'UDragDropOperation_Widget::OnDropOffset' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, OnDragOffset) == 0x0000F8, "Member 'UDragDropOperation_Widget::OnDragOffset' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, WidgetSlotAnchors) == 0x000108, "Member 'UDragDropOperation_Widget::WidgetSlotAnchors' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, WidgetSlotOffsets) == 0x000128, "Member 'UDragDropOperation_Widget::WidgetSlotOffsets' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, WidgetSlotPosition) == 0x000138, "Member 'UDragDropOperation_Widget::WidgetSlotPosition' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, WidgetSlotSize) == 0x000148, "Member 'UDragDropOperation_Widget::WidgetSlotSize' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, WidgetSlotAutoSize) == 0x000158, "Member 'UDragDropOperation_Widget::WidgetSlotAutoSize' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, WidgetSlotAlignment) == 0x000160, "Member 'UDragDropOperation_Widget::WidgetSlotAlignment' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, WidgetSlotZOrder) == 0x000170, "Member 'UDragDropOperation_Widget::WidgetSlotZOrder' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, ChildLinkWidget) == 0x000178, "Member 'UDragDropOperation_Widget::ChildLinkWidget' has a wrong offset!");

// Class DeadByDaylight.DSQuestEventsHandlerComponent
// 0x00A0 (0x0158 - 0x00B8)
class UDSQuestEventsHandlerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x70];                                      // 0x00B8(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UQuestEventEvaluatorBase*>       _evaluatorList;                                    // 0x0128(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_138[0x20];                                     // 0x0138(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DSQuestEventsHandlerComponent">();
	}
	static class UDSQuestEventsHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDSQuestEventsHandlerComponent>();
	}
};
static_assert(alignof(UDSQuestEventsHandlerComponent) == 0x000008, "Wrong alignment on UDSQuestEventsHandlerComponent");
static_assert(sizeof(UDSQuestEventsHandlerComponent) == 0x000158, "Wrong size on UDSQuestEventsHandlerComponent");
static_assert(offsetof(UDSQuestEventsHandlerComponent, _evaluatorList) == 0x000128, "Member 'UDSQuestEventsHandlerComponent::_evaluatorList' has a wrong offset!");

// Class DeadByDaylight.DSQuestEventsHelper
// 0x0000 (0x0030 - 0x0030)
class UDSQuestEventsHelper final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DSQuestEventsHelper">();
	}
	static class UDSQuestEventsHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDSQuestEventsHelper>();
	}
};
static_assert(alignof(UDSQuestEventsHelper) == 0x000008, "Wrong alignment on UDSQuestEventsHelper");
static_assert(sizeof(UDSQuestEventsHelper) == 0x000030, "Wrong size on UDSQuestEventsHelper");

// Class DeadByDaylight.DynamicGrassEffectorInterface
// 0x0000 (0x0000 - 0x0000)
class IDynamicGrassEffectorInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicGrassEffectorInterface">();
	}
	static class IDynamicGrassEffectorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDynamicGrassEffectorInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IDynamicGrassEffectorInterface) == 0x000001, "Wrong alignment on IDynamicGrassEffectorInterface");
static_assert(sizeof(IDynamicGrassEffectorInterface) == 0x000001, "Wrong size on IDynamicGrassEffectorInterface");

// Class DeadByDaylight.EdgeObjectHandlingStrategy
// 0x0128 (0x0158 - 0x0030)
class UEdgeObjectHandlingStrategy final : public UObject
{
public:
	TArray<class UActorSpawner*>                  _edgeObjectSpawners;                               // 0x0030(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UActorSpawner*>                  _edgeObjectBlockers;                               // 0x0040(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x108];                                     // 0x0050(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EdgeObjectHandlingStrategy">();
	}
	static class UEdgeObjectHandlingStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEdgeObjectHandlingStrategy>();
	}
};
static_assert(alignof(UEdgeObjectHandlingStrategy) == 0x000008, "Wrong alignment on UEdgeObjectHandlingStrategy");
static_assert(sizeof(UEdgeObjectHandlingStrategy) == 0x000158, "Wrong size on UEdgeObjectHandlingStrategy");
static_assert(offsetof(UEdgeObjectHandlingStrategy, _edgeObjectSpawners) == 0x000030, "Member 'UEdgeObjectHandlingStrategy::_edgeObjectSpawners' has a wrong offset!");
static_assert(offsetof(UEdgeObjectHandlingStrategy, _edgeObjectBlockers) == 0x000040, "Member 'UEdgeObjectHandlingStrategy::_edgeObjectBlockers' has a wrong offset!");

// Class DeadByDaylight.EditorActorVisualization
// 0x00A0 (0x0370 - 0x02D0)
class UEditorActorVisualization final : public USceneComponent
{
public:
	TSoftClassPtr<class UClass>                   ActorVisualization;                                // 0x02D0(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RelativeTransform;                                 // 0x0310(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditorActorVisualization">();
	}
	static class UEditorActorVisualization* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditorActorVisualization>();
	}
};
static_assert(alignof(UEditorActorVisualization) == 0x000010, "Wrong alignment on UEditorActorVisualization");
static_assert(sizeof(UEditorActorVisualization) == 0x000370, "Wrong size on UEditorActorVisualization");
static_assert(offsetof(UEditorActorVisualization, ActorVisualization) == 0x0002D0, "Member 'UEditorActorVisualization::ActorVisualization' has a wrong offset!");
static_assert(offsetof(UEditorActorVisualization, RelativeTransform) == 0x000310, "Member 'UEditorActorVisualization::RelativeTransform' has a wrong offset!");

// Class DeadByDaylight.EffectsLocator
// 0x0068 (0x0308 - 0x02A0)
class AEffectsLocator final : public AActor
{
public:
	TArray<struct FEffectsLocatorTargets>         AffectedActors;                                    // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ActorCaptureRadius;                                // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AActor*>                           _encountered;                                      // 0x02B8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	void OnActorTick(class UMaterialInstanceDynamic* actorMaterialInstanceDynamic);
	void OnEnterCollisionArea(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnFoundActor(class AActor* foundActor);
	void OnLeaveCollisionArea(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnLostActor(class AActor* lostActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectsLocator">();
	}
	static class AEffectsLocator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEffectsLocator>();
	}
};
static_assert(alignof(AEffectsLocator) == 0x000008, "Wrong alignment on AEffectsLocator");
static_assert(sizeof(AEffectsLocator) == 0x000308, "Wrong size on AEffectsLocator");
static_assert(offsetof(AEffectsLocator, AffectedActors) == 0x0002A0, "Member 'AEffectsLocator::AffectedActors' has a wrong offset!");
static_assert(offsetof(AEffectsLocator, ActorCaptureRadius) == 0x0002B0, "Member 'AEffectsLocator::ActorCaptureRadius' has a wrong offset!");
static_assert(offsetof(AEffectsLocator, _encountered) == 0x0002B8, "Member 'AEffectsLocator::_encountered' has a wrong offset!");

// Class DeadByDaylight.EmblemRankContainer
// 0x0228 (0x0260 - 0x0038)
class UEmblemRankContainer final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x228];                                     // 0x0038(0x0228)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EmblemRankContainer">();
	}
	static class UEmblemRankContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEmblemRankContainer>();
	}
};
static_assert(alignof(UEmblemRankContainer) == 0x000008, "Wrong alignment on UEmblemRankContainer");
static_assert(sizeof(UEmblemRankContainer) == 0x000260, "Wrong size on UEmblemRankContainer");

// Class DeadByDaylight.EmblemRankUtilities
// 0x0000 (0x0030 - 0x0030)
class UEmblemRankUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EmblemRankUtilities">();
	}
	static class UEmblemRankUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEmblemRankUtilities>();
	}
};
static_assert(alignof(UEmblemRankUtilities) == 0x000008, "Wrong alignment on UEmblemRankUtilities");
static_assert(sizeof(UEmblemRankUtilities) == 0x000030, "Wrong size on UEmblemRankUtilities");

// Class DeadByDaylight.EndGameEntity
// 0x0008 (0x02A8 - 0x02A0)
class AEndGameEntity final : public AActor
{
public:
	class UDBDSkeletalMeshComponentBudgeted*      _skeletalMeshComponent;                            // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndGameEntity">();
	}
	static class AEndGameEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndGameEntity>();
	}
};
static_assert(alignof(AEndGameEntity) == 0x000008, "Wrong alignment on AEndGameEntity");
static_assert(sizeof(AEndGameEntity) == 0x0002A8, "Wrong size on AEndGameEntity");
static_assert(offsetof(AEndGameEntity, _skeletalMeshComponent) == 0x0002A0, "Member 'AEndGameEntity::_skeletalMeshComponent' has a wrong offset!");

// Class DeadByDaylight.EndGameEntityAnimInstance
// 0x0010 (0x0360 - 0x0350)
class UEndGameEntityAnimInstance final : public UAnimInstance
{
public:
	bool                                          _isFront;                                          // 0x0350(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBack;                                           // 0x0351(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_352[0xE];                                      // 0x0352(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndGameEntityAnimInstance">();
	}
	static class UEndGameEntityAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndGameEntityAnimInstance>();
	}
};
static_assert(alignof(UEndGameEntityAnimInstance) == 0x000010, "Wrong alignment on UEndGameEntityAnimInstance");
static_assert(sizeof(UEndGameEntityAnimInstance) == 0x000360, "Wrong size on UEndGameEntityAnimInstance");
static_assert(offsetof(UEndGameEntityAnimInstance, _isFront) == 0x000350, "Member 'UEndGameEntityAnimInstance::_isFront' has a wrong offset!");
static_assert(offsetof(UEndGameEntityAnimInstance, _isBack) == 0x000351, "Member 'UEndGameEntityAnimInstance::_isBack' has a wrong offset!");

// Class DeadByDaylight.EndGameStateComponent
// 0x0068 (0x0120 - 0x00B8)
class UEndGameStateComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0xC];                                       // 0x00B8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isEndGameOver;                                    // 0x00C4(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _worldTimeAtLastModification;                      // 0x00C8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CC[0x44];                                      // 0x00CC(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _timeDilation;                                     // 0x0110(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isTimerPaused;                                    // 0x0114(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_115[0x3];                                      // 0x0115(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _normalTotalTimeElapsedAtLastTimeModification;     // 0x0118(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEndGameScenarioTrigger                       _endGameScenarioTrigger;                           // 0x011C(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11D[0x3];                                      // 0x011D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_SetIsInEndGameSimulation(bool endGameSimulation);
	void OnRep_IsEndGameOver();
	void OnRep_IsTimerPaused();
	void OnRep_TimeDilation();
	void OnRep_WorldTimeAtLastDilationModification();

	float GetElapsedTimePercent() const;
	bool HasEndGameBegun() const;
	bool IsEndGameOver() const;
	bool IsTimerSlowedDown() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndGameStateComponent">();
	}
	static class UEndGameStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndGameStateComponent>();
	}
};
static_assert(alignof(UEndGameStateComponent) == 0x000008, "Wrong alignment on UEndGameStateComponent");
static_assert(sizeof(UEndGameStateComponent) == 0x000120, "Wrong size on UEndGameStateComponent");
static_assert(offsetof(UEndGameStateComponent, _isEndGameOver) == 0x0000C4, "Member 'UEndGameStateComponent::_isEndGameOver' has a wrong offset!");
static_assert(offsetof(UEndGameStateComponent, _worldTimeAtLastModification) == 0x0000C8, "Member 'UEndGameStateComponent::_worldTimeAtLastModification' has a wrong offset!");
static_assert(offsetof(UEndGameStateComponent, _timeDilation) == 0x000110, "Member 'UEndGameStateComponent::_timeDilation' has a wrong offset!");
static_assert(offsetof(UEndGameStateComponent, _isTimerPaused) == 0x000114, "Member 'UEndGameStateComponent::_isTimerPaused' has a wrong offset!");
static_assert(offsetof(UEndGameStateComponent, _normalTotalTimeElapsedAtLastTimeModification) == 0x000118, "Member 'UEndGameStateComponent::_normalTotalTimeElapsedAtLastTimeModification' has a wrong offset!");
static_assert(offsetof(UEndGameStateComponent, _endGameScenarioTrigger) == 0x00011C, "Member 'UEndGameStateComponent::_endGameScenarioTrigger' has a wrong offset!");

// Class DeadByDaylight.EnergyPoweredInterface
// 0x0000 (0x0000 - 0x0000)
class IEnergyPoweredInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnergyPoweredInterface">();
	}
	static class IEnergyPoweredInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEnergyPoweredInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IEnergyPoweredInterface) == 0x000001, "Wrong alignment on IEnergyPoweredInterface");
static_assert(sizeof(IEnergyPoweredInterface) == 0x000001, "Wrong size on IEnergyPoweredInterface");

// Class DeadByDaylight.EnsureLoggingSubsystem
// 0x0038 (0x0070 - 0x0038)
class UEnsureLoggingSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x38];                                      // 0x0038(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnsureLoggingSubsystem">();
	}
	static class UEnsureLoggingSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnsureLoggingSubsystem>();
	}
};
static_assert(alignof(UEnsureLoggingSubsystem) == 0x000008, "Wrong alignment on UEnsureLoggingSubsystem");
static_assert(sizeof(UEnsureLoggingSubsystem) == 0x000070, "Wrong size on UEnsureLoggingSubsystem");

// Class DeadByDaylight.Entity
// 0x0020 (0x02C0 - 0x02A0)
class AEntity final : public AActor
{
public:
	class UCurveFloat*                            _dissolveCurve;                                    // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _revealsCurve;                                     // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialHelper*                        _materialHelper;                                   // 0x02B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 _skeletalMesh;                                     // 0x02B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ChangeToIdleState();
	void ChangeToSacrificeState();
	void ChangeToStruggleState();
	void CompleteSacrifice(bool isBasementHook);
	void HideEntity();
	void InitEntity(class AMeatHook* MeatHook);
	void OnReactionStart();
	void SetAnimationIsStruggling(bool isStruggling);
	void SetAnimationStrugglePercent(float Percent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Entity">();
	}
	static class AEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEntity>();
	}
};
static_assert(alignof(AEntity) == 0x000008, "Wrong alignment on AEntity");
static_assert(sizeof(AEntity) == 0x0002C0, "Wrong size on AEntity");
static_assert(offsetof(AEntity, _dissolveCurve) == 0x0002A0, "Member 'AEntity::_dissolveCurve' has a wrong offset!");
static_assert(offsetof(AEntity, _revealsCurve) == 0x0002A8, "Member 'AEntity::_revealsCurve' has a wrong offset!");
static_assert(offsetof(AEntity, _materialHelper) == 0x0002B0, "Member 'AEntity::_materialHelper' has a wrong offset!");
static_assert(offsetof(AEntity, _skeletalMesh) == 0x0002B8, "Member 'AEntity::_skeletalMesh' has a wrong offset!");

// Class DeadByDaylight.EpicProfileDAL
// 0x0000 (0x0088 - 0x0088)
class UEpicProfileDAL final : public UPlayerProfileDAL
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EpicProfileDAL">();
	}
	static class UEpicProfileDAL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEpicProfileDAL>();
	}
};
static_assert(alignof(UEpicProfileDAL) == 0x000008, "Wrong alignment on UEpicProfileDAL");
static_assert(sizeof(UEpicProfileDAL) == 0x000088, "Wrong size on UEpicProfileDAL");

// Class DeadByDaylight.EscapeBlocker
// 0x0040 (0x02E0 - 0x02A0)
class AEscapeBlocker final : public AActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          _camperBlocker;                                    // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          _playerDetectionZone;                              // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x28];                                     // 0x02B8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivatePlayerBlockerFX();
	void DeactivatePlayerBlockerFX();
	void OnPlayerDetectionZoneBeginOverlap(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnPlayerDetectionZoneEndOverlap(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void SetCamperBlocker(class UBoxComponent* camperBlocker);
	void SetPlayerDetectionZone(class UBoxComponent* playerDetectionZone);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EscapeBlocker">();
	}
	static class AEscapeBlocker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEscapeBlocker>();
	}
};
static_assert(alignof(AEscapeBlocker) == 0x000008, "Wrong alignment on AEscapeBlocker");
static_assert(sizeof(AEscapeBlocker) == 0x0002E0, "Wrong size on AEscapeBlocker");
static_assert(offsetof(AEscapeBlocker, _camperBlocker) == 0x0002A8, "Member 'AEscapeBlocker::_camperBlocker' has a wrong offset!");
static_assert(offsetof(AEscapeBlocker, _playerDetectionZone) == 0x0002B0, "Member 'AEscapeBlocker::_playerDetectionZone' has a wrong offset!");

// Class DeadByDaylight.EscapeDoorAnimInstance
// 0x0010 (0x0370 - 0x0360)
class UEscapeDoorAnimInstance final : public USleepingAnimInstance
{
public:
	bool                                          _isOpen;                                           // 0x0360(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOpenByKiller;                                   // 0x0361(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_362[0xE];                                      // 0x0362(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlaySound(class UAkAudioEvent* akEvent);
	void SetIsOpen(bool IsOpen);
	void SetIsOpenByKiller(const bool isOpenByKiller);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EscapeDoorAnimInstance">();
	}
	static class UEscapeDoorAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEscapeDoorAnimInstance>();
	}
};
static_assert(alignof(UEscapeDoorAnimInstance) == 0x000010, "Wrong alignment on UEscapeDoorAnimInstance");
static_assert(sizeof(UEscapeDoorAnimInstance) == 0x000370, "Wrong size on UEscapeDoorAnimInstance");
static_assert(offsetof(UEscapeDoorAnimInstance, _isOpen) == 0x000360, "Member 'UEscapeDoorAnimInstance::_isOpen' has a wrong offset!");
static_assert(offsetof(UEscapeDoorAnimInstance, _isOpenByKiller) == 0x000361, "Member 'UEscapeDoorAnimInstance::_isOpenByKiller' has a wrong offset!");

// Class DeadByDaylight.EscapeOutlineUpdateStrategy
// 0x0020 (0x0100 - 0x00E0)
class UEscapeOutlineUpdateStrategy final : public UOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _doorOpenColorForSurvivor;                         // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _doorOpenColorForKiller;                           // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EscapeOutlineUpdateStrategy">();
	}
	static class UEscapeOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEscapeOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UEscapeOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UEscapeOutlineUpdateStrategy");
static_assert(sizeof(UEscapeOutlineUpdateStrategy) == 0x000100, "Wrong size on UEscapeOutlineUpdateStrategy");
static_assert(offsetof(UEscapeOutlineUpdateStrategy, _doorOpenColorForSurvivor) == 0x0000E0, "Member 'UEscapeOutlineUpdateStrategy::_doorOpenColorForSurvivor' has a wrong offset!");
static_assert(offsetof(UEscapeOutlineUpdateStrategy, _doorOpenColorForKiller) == 0x0000F0, "Member 'UEscapeOutlineUpdateStrategy::_doorOpenColorForKiller' has a wrong offset!");

// Class DeadByDaylight.EscapeThroughHatch
// 0x0000 (0x0770 - 0x0770)
class UEscapeThroughHatch final : public UBaseEscapeThroughHatch
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EscapeThroughHatch">();
	}
	static class UEscapeThroughHatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEscapeThroughHatch>();
	}
};
static_assert(alignof(UEscapeThroughHatch) == 0x000010, "Wrong alignment on UEscapeThroughHatch");
static_assert(sizeof(UEscapeThroughHatch) == 0x000770, "Wrong size on UEscapeThroughHatch");

// Class DeadByDaylight.ESSRComponent
// 0x0020 (0x0158 - 0x0138)
class UESSRComponent : public UDBDSRComponent
{
public:
	TArray<struct FCharacterOverrideDropdown>     _eligibleCharacters;                               // 0x0138(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FCharmDropdown>                 _requiredCharms;                                   // 0x0148(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ESSRComponent">();
	}
	static class UESSRComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UESSRComponent>();
	}
};
static_assert(alignof(UESSRComponent) == 0x000008, "Wrong alignment on UESSRComponent");
static_assert(sizeof(UESSRComponent) == 0x000158, "Wrong size on UESSRComponent");
static_assert(offsetof(UESSRComponent, _eligibleCharacters) == 0x000138, "Member 'UESSRComponent::_eligibleCharacters' has a wrong offset!");
static_assert(offsetof(UESSRComponent, _requiredCharms) == 0x000148, "Member 'UESSRComponent::_requiredCharms' has a wrong offset!");

// Class DeadByDaylight.EventCustomizationHelper
// 0x0000 (0x0030 - 0x0030)
class UEventCustomizationHelper final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventCustomizationHelper">();
	}
	static class UEventCustomizationHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventCustomizationHelper>();
	}
};
static_assert(alignof(UEventCustomizationHelper) == 0x000008, "Wrong alignment on UEventCustomizationHelper");
static_assert(sizeof(UEventCustomizationHelper) == 0x000030, "Wrong size on UEventCustomizationHelper");

// Class DeadByDaylight.EventGeneratorComponent
// 0x0020 (0x00E0 - 0x00C0)
class UEventGeneratorComponent final : public UEventObjectComponent
{
public:
	struct FGameplayTag                           _genCompletedScoreEvent;                           // 0x00C0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _genCompletedNoOfferingScoreEvent;                 // 0x00CC(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOfferingEffectType                           _offeringEffectTypeNeeded;                         // 0x00D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _updateOutlineForSurvivor;                         // 0x00D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _updateOutlineForSlasher;                          // 0x00DA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DB[0x5];                                       // 0x00DB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_FireGenCompletedEventScore(bool isAutoCompleted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventGeneratorComponent">();
	}
	static class UEventGeneratorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventGeneratorComponent>();
	}
};
static_assert(alignof(UEventGeneratorComponent) == 0x000008, "Wrong alignment on UEventGeneratorComponent");
static_assert(sizeof(UEventGeneratorComponent) == 0x0000E0, "Wrong size on UEventGeneratorComponent");
static_assert(offsetof(UEventGeneratorComponent, _genCompletedScoreEvent) == 0x0000C0, "Member 'UEventGeneratorComponent::_genCompletedScoreEvent' has a wrong offset!");
static_assert(offsetof(UEventGeneratorComponent, _genCompletedNoOfferingScoreEvent) == 0x0000CC, "Member 'UEventGeneratorComponent::_genCompletedNoOfferingScoreEvent' has a wrong offset!");
static_assert(offsetof(UEventGeneratorComponent, _offeringEffectTypeNeeded) == 0x0000D8, "Member 'UEventGeneratorComponent::_offeringEffectTypeNeeded' has a wrong offset!");
static_assert(offsetof(UEventGeneratorComponent, _updateOutlineForSurvivor) == 0x0000D9, "Member 'UEventGeneratorComponent::_updateOutlineForSurvivor' has a wrong offset!");
static_assert(offsetof(UEventGeneratorComponent, _updateOutlineForSlasher) == 0x0000DA, "Member 'UEventGeneratorComponent::_updateOutlineForSlasher' has a wrong offset!");

// Class DeadByDaylight.EventHookComponent
// 0x0030 (0x00F0 - 0x00C0)
class UEventHookComponent final : public UEventObjectComponent
{
public:
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _hookedOnEventHookScoreEvent;                      // 0x00D0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _hookedOnEventHookNoOfferingScoreEvent;            // 0x00DC(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOfferingEffectType                           _offeringEffectTypeNeeded;                         // 0x00E8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _rewardScoreOnFirstHookOnly;                       // 0x00E9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _updateOutlineForSurvivor;                         // 0x00EA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _updateOutlineForSlasher;                          // 0x00EB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_FireHookedScoreEvent(class ADBDPlayer* hookedPlayer);
	void SetOutlineCarryingColorToDefault();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventHookComponent">();
	}
	static class UEventHookComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventHookComponent>();
	}
};
static_assert(alignof(UEventHookComponent) == 0x000008, "Wrong alignment on UEventHookComponent");
static_assert(sizeof(UEventHookComponent) == 0x0000F0, "Wrong size on UEventHookComponent");
static_assert(offsetof(UEventHookComponent, _hookedOnEventHookScoreEvent) == 0x0000D0, "Member 'UEventHookComponent::_hookedOnEventHookScoreEvent' has a wrong offset!");
static_assert(offsetof(UEventHookComponent, _hookedOnEventHookNoOfferingScoreEvent) == 0x0000DC, "Member 'UEventHookComponent::_hookedOnEventHookNoOfferingScoreEvent' has a wrong offset!");
static_assert(offsetof(UEventHookComponent, _offeringEffectTypeNeeded) == 0x0000E8, "Member 'UEventHookComponent::_offeringEffectTypeNeeded' has a wrong offset!");
static_assert(offsetof(UEventHookComponent, _rewardScoreOnFirstHookOnly) == 0x0000E9, "Member 'UEventHookComponent::_rewardScoreOnFirstHookOnly' has a wrong offset!");
static_assert(offsetof(UEventHookComponent, _updateOutlineForSurvivor) == 0x0000EA, "Member 'UEventHookComponent::_updateOutlineForSurvivor' has a wrong offset!");
static_assert(offsetof(UEventHookComponent, _updateOutlineForSlasher) == 0x0000EB, "Member 'UEventHookComponent::_updateOutlineForSlasher' has a wrong offset!");

// Class DeadByDaylight.EventObjectItemWidgetInterface
// 0x0000 (0x0000 - 0x0000)
class IEventObjectItemWidgetInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventObjectItemWidgetInterface">();
	}
	static class IEventObjectItemWidgetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEventObjectItemWidgetInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IEventObjectItemWidgetInterface) == 0x000001, "Wrong alignment on IEventObjectItemWidgetInterface");
static_assert(sizeof(IEventObjectItemWidgetInterface) == 0x000001, "Wrong size on IEventObjectItemWidgetInterface");

// Class DeadByDaylight.EventSpawnableStaticMeshActor
// 0x0008 (0x02B8 - 0x02B0)
class AEventSpawnableStaticMeshActor final : public AStaticMeshActor
{
public:
	class UEventSpawnableComponent*               _eventSpawnableComponent;                          // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventSpawnableStaticMeshActor">();
	}
	static class AEventSpawnableStaticMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEventSpawnableStaticMeshActor>();
	}
};
static_assert(alignof(AEventSpawnableStaticMeshActor) == 0x000008, "Wrong alignment on AEventSpawnableStaticMeshActor");
static_assert(sizeof(AEventSpawnableStaticMeshActor) == 0x0002B8, "Wrong size on AEventSpawnableStaticMeshActor");
static_assert(offsetof(AEventSpawnableStaticMeshActor, _eventSpawnableComponent) == 0x0002B0, "Member 'AEventSpawnableStaticMeshActor::_eventSpawnableComponent' has a wrong offset!");

// Class DeadByDaylight.EventSpawner
// 0x00E0 (0x0490 - 0x03B0)
class UEventSpawner final : public UActorSpawner
{
public:
	struct FEventSpawnablePositionDropdown        EventSpawnablePosition;                            // 0x03B0(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FDataTableDropdown                     EventSpawnableShapePreset;                         // 0x03E0(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FVector                                MinBoundOverride;                                  // 0x0410(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MaxBoundOverride;                                  // 0x0428(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          _minBoundBox;                                      // 0x0440(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          _maxBoundBox;                                      // 0x0448(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_450[0x40];                                     // 0x0450(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventSpawner">();
	}
	static class UEventSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventSpawner>();
	}
};
static_assert(alignof(UEventSpawner) == 0x000010, "Wrong alignment on UEventSpawner");
static_assert(sizeof(UEventSpawner) == 0x000490, "Wrong size on UEventSpawner");
static_assert(offsetof(UEventSpawner, EventSpawnablePosition) == 0x0003B0, "Member 'UEventSpawner::EventSpawnablePosition' has a wrong offset!");
static_assert(offsetof(UEventSpawner, EventSpawnableShapePreset) == 0x0003E0, "Member 'UEventSpawner::EventSpawnableShapePreset' has a wrong offset!");
static_assert(offsetof(UEventSpawner, MinBoundOverride) == 0x000410, "Member 'UEventSpawner::MinBoundOverride' has a wrong offset!");
static_assert(offsetof(UEventSpawner, MaxBoundOverride) == 0x000428, "Member 'UEventSpawner::MaxBoundOverride' has a wrong offset!");
static_assert(offsetof(UEventSpawner, _minBoundBox) == 0x000440, "Member 'UEventSpawner::_minBoundBox' has a wrong offset!");
static_assert(offsetof(UEventSpawner, _maxBoundBox) == 0x000448, "Member 'UEventSpawner::_maxBoundBox' has a wrong offset!");

// Class DeadByDaylight.EvilWithinComponent
// 0x0088 (0x0140 - 0x00B8)
class UEvilWithinComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(int32 previousTier, int32 currentTier, bool isFirstTime)> OnTierChange; // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         _currentTier;                                      // 0x00C8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _lastTierTimeStart;                                // 0x00CC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x60];                                      // 0x00D0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         _allowedSurvivorInteractionsForKill;               // 0x0130(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void Authority_NotifyKill();
	void Authority_OnPlayerDisconnect(class ADBDPlayer* Player);
	void Authority_OnStalkPointsAdded(float stalkPoints);
	void OnLevelReadyToPlay();
	void OnRep_CurrentTier(int32 previousTier);

	bool CanBeStandingKilled(const class ADBDPlayer* Player) const;
	bool CanStandKill(const class ADBDPlayer* Player) const;
	int32 GetCurrentTier() const;
	int32 GetMaxTier() const;
	float GetPercentStalkingPointsInCurrentTier() const;
	float GetRequirementForTier(int32 tier) const;
	bool IsAtLastTier() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EvilWithinComponent">();
	}
	static class UEvilWithinComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEvilWithinComponent>();
	}
};
static_assert(alignof(UEvilWithinComponent) == 0x000008, "Wrong alignment on UEvilWithinComponent");
static_assert(sizeof(UEvilWithinComponent) == 0x000140, "Wrong size on UEvilWithinComponent");
static_assert(offsetof(UEvilWithinComponent, OnTierChange) == 0x0000B8, "Member 'UEvilWithinComponent::OnTierChange' has a wrong offset!");
static_assert(offsetof(UEvilWithinComponent, _currentTier) == 0x0000C8, "Member 'UEvilWithinComponent::_currentTier' has a wrong offset!");
static_assert(offsetof(UEvilWithinComponent, _lastTierTimeStart) == 0x0000CC, "Member 'UEvilWithinComponent::_lastTierTimeStart' has a wrong offset!");
static_assert(offsetof(UEvilWithinComponent, _allowedSurvivorInteractionsForKill) == 0x000130, "Member 'UEvilWithinComponent::_allowedSurvivorInteractionsForKill' has a wrong offset!");

// Class DeadByDaylight.ExperimentsHelper
// 0x0000 (0x0030 - 0x0030)
class UExperimentsHelper final : public UObject
{
public:
	static bool GetAllActive(const class UObject* contextObject, TArray<struct FCombinedExperimentData>* outData);
	static bool GetCombinedData(const class UObject* contextObject, class FName experimentId, struct FCombinedExperimentData* outData);
	static bool IsActive(const class UObject* contextObject, class FName experimentId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExperimentsHelper">();
	}
	static class UExperimentsHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExperimentsHelper>();
	}
};
static_assert(alignof(UExperimentsHelper) == 0x000008, "Wrong alignment on UExperimentsHelper");
static_assert(sizeof(UExperimentsHelper) == 0x000030, "Wrong size on UExperimentsHelper");

// Class DeadByDaylight.ExperimentsSubsystem
// 0x0070 (0x00A8 - 0x0038)
class UExperimentsSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x70];                                      // 0x0038(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExperimentsSubsystem">();
	}
	static class UExperimentsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExperimentsSubsystem>();
	}
};
static_assert(alignof(UExperimentsSubsystem) == 0x000008, "Wrong alignment on UExperimentsSubsystem");
static_assert(sizeof(UExperimentsSubsystem) == 0x0000A8, "Wrong size on UExperimentsSubsystem");

// Class DeadByDaylight.ExposerCirclingComponent
// 0x0070 (0x0340 - 0x02D0)
class UExposerCirclingComponent final : public USceneComponent
{
public:
	bool                                          DirectionFollows;                                  // 0x02D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D1[0x3];                                      // 0x02D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinHeight;                                         // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHeight;                                         // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRadius;                                         // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRadius;                                         // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CirclingSpeed;                                     // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceBetweenPoints;                             // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BezierModifier;                                    // 0x02EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Samples;                                           // 0x02F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F4[0x4C];                                     // 0x02F4(0x004C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Reset();
	void SetIsCircling(bool circling);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExposerCirclingComponent">();
	}
	static class UExposerCirclingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExposerCirclingComponent>();
	}
};
static_assert(alignof(UExposerCirclingComponent) == 0x000010, "Wrong alignment on UExposerCirclingComponent");
static_assert(sizeof(UExposerCirclingComponent) == 0x000340, "Wrong size on UExposerCirclingComponent");
static_assert(offsetof(UExposerCirclingComponent, DirectionFollows) == 0x0002D0, "Member 'UExposerCirclingComponent::DirectionFollows' has a wrong offset!");
static_assert(offsetof(UExposerCirclingComponent, MinHeight) == 0x0002D4, "Member 'UExposerCirclingComponent::MinHeight' has a wrong offset!");
static_assert(offsetof(UExposerCirclingComponent, MaxHeight) == 0x0002D8, "Member 'UExposerCirclingComponent::MaxHeight' has a wrong offset!");
static_assert(offsetof(UExposerCirclingComponent, MinRadius) == 0x0002DC, "Member 'UExposerCirclingComponent::MinRadius' has a wrong offset!");
static_assert(offsetof(UExposerCirclingComponent, MaxRadius) == 0x0002E0, "Member 'UExposerCirclingComponent::MaxRadius' has a wrong offset!");
static_assert(offsetof(UExposerCirclingComponent, CirclingSpeed) == 0x0002E4, "Member 'UExposerCirclingComponent::CirclingSpeed' has a wrong offset!");
static_assert(offsetof(UExposerCirclingComponent, DistanceBetweenPoints) == 0x0002E8, "Member 'UExposerCirclingComponent::DistanceBetweenPoints' has a wrong offset!");
static_assert(offsetof(UExposerCirclingComponent, BezierModifier) == 0x0002EC, "Member 'UExposerCirclingComponent::BezierModifier' has a wrong offset!");
static_assert(offsetof(UExposerCirclingComponent, Samples) == 0x0002F0, "Member 'UExposerCirclingComponent::Samples' has a wrong offset!");

// Class DeadByDaylight.Fadeable
// 0x0000 (0x0000 - 0x0000)
class IFadeable final
{
public:
	void OnAlphaChanged(float newAlpha, class AActor* Other);
	void OnFadeBegin(class AActor* Other);
	void OnFadeEnd(class AActor* Other);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Fadeable">();
	}
	static class IFadeable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFadeable>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IFadeable) == 0x000001, "Wrong alignment on IFadeable");
static_assert(sizeof(IFadeable) == 0x000001, "Wrong size on IFadeable");

// Class DeadByDaylight.FadeManager
// 0x00B8 (0x0358 - 0x02A0)
class AFadeManager final : public AActor
{
public:
	uint8                                         Pad_2A0[0xB8];                                     // 0x02A0(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AreAnyMaterialsFaded();
	void DBD_ContinuousCameraFading(bool IsEnabled);
	void DBD_FadeAtCurrentCameraLocation(bool IsEnabled);
	void DBD_ForceDestroySomeFadedMeshes(const int32 numberOfMeshToDestroy);
	void DBD_TurnCameraAroundPlayerWithFading(bool isTurning);
	void FadeAt(const struct FVector& Location, bool adjustAudioOcclusions);
	void RemoveFadeMaterials(bool adjustAudioOcclusions);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FadeManager">();
	}
	static class AFadeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFadeManager>();
	}
};
static_assert(alignof(AFadeManager) == 0x000008, "Wrong alignment on AFadeManager");
static_assert(sizeof(AFadeManager) == 0x000358, "Wrong size on AFadeManager");

// Class DeadByDaylight.FasterChestSearch
// 0x0000 (0x0398 - 0x0398)
class UFasterChestSearch final : public UStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FasterChestSearch">();
	}
	static class UFasterChestSearch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFasterChestSearch>();
	}
};
static_assert(alignof(UFasterChestSearch) == 0x000008, "Wrong alignment on UFasterChestSearch");
static_assert(sizeof(UFasterChestSearch) == 0x000398, "Wrong size on UFasterChestSearch");

// Class DeadByDaylight.FearMarketPopupScreen
// 0x0000 (0x0148 - 0x0148)
class UFearMarketPopupScreen final : public UGenericPopupScreen
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FearMarketPopupScreen">();
	}
	static class UFearMarketPopupScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFearMarketPopupScreen>();
	}
};
static_assert(alignof(UFearMarketPopupScreen) == 0x000008, "Wrong alignment on UFearMarketPopupScreen");
static_assert(sizeof(UFearMarketPopupScreen) == 0x000148, "Wrong size on UFearMarketPopupScreen");

// Class DeadByDaylight.FeatureGate
// 0x0140 (0x0178 - 0x0038)
class UFeatureGate final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x140];                                     // 0x0038(0x0140)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FeatureGate">();
	}
	static class UFeatureGate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFeatureGate>();
	}
};
static_assert(alignof(UFeatureGate) == 0x000008, "Wrong alignment on UFeatureGate");
static_assert(sizeof(UFeatureGate) == 0x000178, "Wrong size on UFeatureGate");

// Class DeadByDaylight.FinisherMoriHandlerComponent
// 0x0020 (0x00D8 - 0x00B8)
class UFinisherMoriHandlerComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(class ADBDPlayer* Killer)> Cosmetic_OnMoriBecameAvailable;         // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x10];                                      // 0x00C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHealthStateChanged(EHealthState oldHealthState, EHealthState newHealthState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FinisherMoriHandlerComponent">();
	}
	static class UFinisherMoriHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFinisherMoriHandlerComponent>();
	}
};
static_assert(alignof(UFinisherMoriHandlerComponent) == 0x000008, "Wrong alignment on UFinisherMoriHandlerComponent");
static_assert(sizeof(UFinisherMoriHandlerComponent) == 0x0000D8, "Wrong size on UFinisherMoriHandlerComponent");
static_assert(offsetof(UFinisherMoriHandlerComponent, Cosmetic_OnMoriBecameAvailable) == 0x0000B8, "Member 'UFinisherMoriHandlerComponent::Cosmetic_OnMoriBecameAvailable' has a wrong offset!");

// Class DeadByDaylight.FleeComponent
// 0x0028 (0x00E0 - 0x00B8)
class UFleeComponent final : public UActorComponent
{
public:
	class AActor*                                 _threat;                                           // 0x00B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x20];                                      // 0x00C0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FleeComponent">();
	}
	static class UFleeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFleeComponent>();
	}
};
static_assert(alignof(UFleeComponent) == 0x000008, "Wrong alignment on UFleeComponent");
static_assert(sizeof(UFleeComponent) == 0x0000E0, "Wrong size on UFleeComponent");
static_assert(offsetof(UFleeComponent, _threat) == 0x0000B8, "Member 'UFleeComponent::_threat' has a wrong offset!");

// Class DeadByDaylight.FlickeringLight
// 0x03C8 (0x0690 - 0x02C8)
class AFlickeringLight final : public AGeneratorDrivenActor
{
public:
	EFlickeringLightType                          _lightComponentType;                               // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDetailMode                                   _detailLevelBeforeCastShadows;                     // 0x02CC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPerPlatformBool                       _castShadow;                                       // 0x02CD(0x0001)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CE[0x2];                                      // 0x02CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBHVRPerDetailModeBool                 _isCastingShadow;                                  // 0x02D0(0x00A0)(Edit, NativeAccessSpecifierPrivate)
	struct FBHVRPerDetailModeFloat                _maxDrawDistance;                                  // 0x0370(0x00A0)(Edit, NativeAccessSpecifierPrivate)
	struct FBHVRPerDetailModeFloat                _maxDistanceFadeRange;                             // 0x0410(0x00A0)(Edit, NativeAccessSpecifierPrivate)
	struct FBHVRPerDetailModeBool                 _castCinematicShadowsOnly;                         // 0x04B0(0x00A0)(Edit, NativeAccessSpecifierPrivate)
	float                                         _innerConneAngle;                                  // 0x0550(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _outerConneAngle;                                  // 0x0554(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sourceLength;                                     // 0x0558(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sourceRadius;                                     // 0x055C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _intensity;                                        // 0x0560(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _generatorActivated;                               // 0x0564(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isTimelineSpeedRandom;                            // 0x0565(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_566[0x2];                                      // 0x0566(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _maximumTimelimeSpeed;                             // 0x0568(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minimumTimelimeSpeed;                             // 0x056C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBHVRPerDetailModeBool                 _secondaryLightVisibility;                         // 0x0570(0x00A0)(Edit, NativeAccessSpecifierPrivate)
	float                                         _secondaryLightIntensity;                          // 0x0610(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_614[0x4];                                      // 0x0614(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _secondaryLightTransform;                          // 0x0618(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               _secondaryLightRotation;                           // 0x0630(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         _secondaryLightAttenuationRadius;                  // 0x0648(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _secondaryLightColor;                              // 0x064C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _secondaryLightSpecularScale;                      // 0x065C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         _isAlwaysCapturedAsON : 1;                         // 0x0660(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_661[0x7];                                      // 0x0661(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULightIntensityTimelineComponent*       _lightIntensityTimeline;                           // 0x0668(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPointLightComponent*                   _pointLightComponent;                              // 0x0670(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPointLightComponent*                   _secondaryPointLightComponent;                     // 0x0678(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URectLightComponent*                    _rectLightComponent;                               // 0x0680(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpotLightComponent*                    _spotLightComponent;                               // 0x0688(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class ULocalLightComponent* GetActiveLightComponent();
	class ULocalLightComponent* GetSecondaryLightComponent();
	bool GetSecondaryLightVisibilty();
	void Init();
	void StartFlickering();
	void StopFlickering();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlickeringLight">();
	}
	static class AFlickeringLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlickeringLight>();
	}
};
static_assert(alignof(AFlickeringLight) == 0x000008, "Wrong alignment on AFlickeringLight");
static_assert(sizeof(AFlickeringLight) == 0x000690, "Wrong size on AFlickeringLight");
static_assert(offsetof(AFlickeringLight, _lightComponentType) == 0x0002C8, "Member 'AFlickeringLight::_lightComponentType' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _detailLevelBeforeCastShadows) == 0x0002CC, "Member 'AFlickeringLight::_detailLevelBeforeCastShadows' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _castShadow) == 0x0002CD, "Member 'AFlickeringLight::_castShadow' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _isCastingShadow) == 0x0002D0, "Member 'AFlickeringLight::_isCastingShadow' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _maxDrawDistance) == 0x000370, "Member 'AFlickeringLight::_maxDrawDistance' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _maxDistanceFadeRange) == 0x000410, "Member 'AFlickeringLight::_maxDistanceFadeRange' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _castCinematicShadowsOnly) == 0x0004B0, "Member 'AFlickeringLight::_castCinematicShadowsOnly' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _innerConneAngle) == 0x000550, "Member 'AFlickeringLight::_innerConneAngle' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _outerConneAngle) == 0x000554, "Member 'AFlickeringLight::_outerConneAngle' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _sourceLength) == 0x000558, "Member 'AFlickeringLight::_sourceLength' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _sourceRadius) == 0x00055C, "Member 'AFlickeringLight::_sourceRadius' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _intensity) == 0x000560, "Member 'AFlickeringLight::_intensity' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _generatorActivated) == 0x000564, "Member 'AFlickeringLight::_generatorActivated' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _isTimelineSpeedRandom) == 0x000565, "Member 'AFlickeringLight::_isTimelineSpeedRandom' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _maximumTimelimeSpeed) == 0x000568, "Member 'AFlickeringLight::_maximumTimelimeSpeed' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _minimumTimelimeSpeed) == 0x00056C, "Member 'AFlickeringLight::_minimumTimelimeSpeed' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _secondaryLightVisibility) == 0x000570, "Member 'AFlickeringLight::_secondaryLightVisibility' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _secondaryLightIntensity) == 0x000610, "Member 'AFlickeringLight::_secondaryLightIntensity' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _secondaryLightTransform) == 0x000618, "Member 'AFlickeringLight::_secondaryLightTransform' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _secondaryLightRotation) == 0x000630, "Member 'AFlickeringLight::_secondaryLightRotation' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _secondaryLightAttenuationRadius) == 0x000648, "Member 'AFlickeringLight::_secondaryLightAttenuationRadius' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _secondaryLightColor) == 0x00064C, "Member 'AFlickeringLight::_secondaryLightColor' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _secondaryLightSpecularScale) == 0x00065C, "Member 'AFlickeringLight::_secondaryLightSpecularScale' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _lightIntensityTimeline) == 0x000668, "Member 'AFlickeringLight::_lightIntensityTimeline' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _pointLightComponent) == 0x000670, "Member 'AFlickeringLight::_pointLightComponent' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _secondaryPointLightComponent) == 0x000678, "Member 'AFlickeringLight::_secondaryPointLightComponent' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _rectLightComponent) == 0x000680, "Member 'AFlickeringLight::_rectLightComponent' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _spotLightComponent) == 0x000688, "Member 'AFlickeringLight::_spotLightComponent' has a wrong offset!");

// Class DeadByDaylight.FrenzyData
// 0x0000 (0x0000 - 0x0000)
class IFrenzyData final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FrenzyData">();
	}
	static class IFrenzyData* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFrenzyData>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IFrenzyData) == 0x000001, "Wrong alignment on IFrenzyData");
static_assert(sizeof(IFrenzyData) == 0x000001, "Wrong size on IFrenzyData");

// Class DeadByDaylight.FriendManager
// 0x0238 (0x0268 - 0x0030)
class UFriendManager final : public UObject
{
public:
	uint8                                         Pad_30[0x238];                                     // 0x0030(0x0238)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FriendManager">();
	}
	static class UFriendManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFriendManager>();
	}
};
static_assert(alignof(UFriendManager) == 0x000008, "Wrong alignment on UFriendManager");
static_assert(sizeof(UFriendManager) == 0x000268, "Wrong size on UFriendManager");

// Class DeadByDaylight.FriendsListScreen
// 0x0128 (0x0250 - 0x0128)
class UFriendsListScreen final : public UScreenBase
{
public:
	uint8                                         Pad_128[0x128];                                    // 0x0128(0x0128)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAcceptFriendInvite(const class FString& friendId);
	void OnBlockPlayer(const class FString& PlayerId);
	void OnCancelFriendInvite(const class FString& friendId);
	void OnDeclineFriendInvite(const class FString& friendId);
	void OnHideNameSelected(const class FString& PlayerId);
	void OnPartyJoinRequest(const class FString& friendId);
	void OnRemoveFriend(const class FString& friendId);
	void OnSearchForFriend();
	void OnSendPartyInvite(const class FString& friendId);
	void OnShowNameSelected(const class FString& PlayerId);
	void OnUnblockPlayer(const class FString& PlayerId);
	void OnViewProfile(const class FString& friendId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FriendsListScreen">();
	}
	static class UFriendsListScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFriendsListScreen>();
	}
};
static_assert(alignof(UFriendsListScreen) == 0x000008, "Wrong alignment on UFriendsListScreen");
static_assert(sizeof(UFriendsListScreen) == 0x000250, "Wrong size on UFriendsListScreen");

// Class DeadByDaylight.GameAssetLibrary
// 0x0018 (0x00C8 - 0x00B0)
class UGameAssetLibrary final : public UAssetLibrary
{
public:
	class UDBDGameInstance*                       _gameInstance;                                     // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameAssetLibrary">();
	}
	static class UGameAssetLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameAssetLibrary>();
	}
};
static_assert(alignof(UGameAssetLibrary) == 0x000008, "Wrong alignment on UGameAssetLibrary");
static_assert(sizeof(UGameAssetLibrary) == 0x0000C8, "Wrong size on UGameAssetLibrary");
static_assert(offsetof(UGameAssetLibrary, _gameInstance) == 0x0000B0, "Member 'UGameAssetLibrary::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.OngoingGameEvent
// 0x0078 (0x00A8 - 0x0030)
class UOngoingGameEvent final : public UObject
{
public:
	struct FGameEventData                         _eventData;                                        // 0x0030(0x0030)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x48];                                      // 0x0060(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OngoingGameEvent">();
	}
	static class UOngoingGameEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOngoingGameEvent>();
	}
};
static_assert(alignof(UOngoingGameEvent) == 0x000008, "Wrong alignment on UOngoingGameEvent");
static_assert(sizeof(UOngoingGameEvent) == 0x0000A8, "Wrong size on UOngoingGameEvent");
static_assert(offsetof(UOngoingGameEvent, _eventData) == 0x000030, "Member 'UOngoingGameEvent::_eventData' has a wrong offset!");

// Class DeadByDaylight.GameEventDispatcher
// 0x00B0 (0x00E8 - 0x0038)
class UGameEventDispatcher final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UOngoingGameEvent*>              _ongoingEvents;                                    // 0x0088(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x50];                                      // 0x0098(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_AccumulateOngoingGameEvent(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData, float OngoingWaitTime);
	void Authority_RemotelyDispatch(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData);
	void LocallyDispatch(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData);
	void RegisterListener(const struct FGameEventDispatcherHandleBP& GameEventDispatcherHandle);
	void RemotelyDispatch(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData);
	void UnregisterListener(const struct FGameEventDispatcherHandleBP& GameEventDispatcherHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameEventDispatcher">();
	}
	static class UGameEventDispatcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameEventDispatcher>();
	}
};
static_assert(alignof(UGameEventDispatcher) == 0x000008, "Wrong alignment on UGameEventDispatcher");
static_assert(sizeof(UGameEventDispatcher) == 0x0000E8, "Wrong size on UGameEventDispatcher");
static_assert(offsetof(UGameEventDispatcher, _ongoingEvents) == 0x000088, "Member 'UGameEventDispatcher::_ongoingEvents' has a wrong offset!");

// Class DeadByDaylight.GameEventListenerCollectionComponent
// 0x0018 (0x00D0 - 0x00B8)
class UGameEventListenerCollectionComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ListenToGameEvent(const struct FGameplayTag& EventType, TDelegate<void(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData)> delegateToBind);
	void UnlistenToAllGameEvents();
	void UnlistenToGameEvent(const struct FGameplayTag& EventType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameEventListenerCollectionComponent">();
	}
	static class UGameEventListenerCollectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameEventListenerCollectionComponent>();
	}
};
static_assert(alignof(UGameEventListenerCollectionComponent) == 0x000008, "Wrong alignment on UGameEventListenerCollectionComponent");
static_assert(sizeof(UGameEventListenerCollectionComponent) == 0x0000D0, "Wrong size on UGameEventListenerCollectionComponent");

// Class DeadByDaylight.GameEventTracker
// 0x0038 (0x0068 - 0x0030)
class UGameEventTracker final : public UObject
{
public:
	TMulticastInlineDelegate<void(EDBDScoreTypes playerGameplayEventType, float Amount, class AActor* effector, class AActor* Target)> OnGameplayEvent; // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EDBDScoreTypes playerGameplayEventType, float Amount, const class ADBDPlayerState* effector)> OnGameflowEvent; // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FireGameEvent(EDBDScoreTypes EventType, float Amount, class AActor* Instigator, class AActor* Target);
	void FireGameflowEvent(EDBDScoreTypes EventType, float Amount, const class ADBDPlayerState* Instigator, class FName Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameEventTracker">();
	}
	static class UGameEventTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameEventTracker>();
	}
};
static_assert(alignof(UGameEventTracker) == 0x000008, "Wrong alignment on UGameEventTracker");
static_assert(sizeof(UGameEventTracker) == 0x000068, "Wrong size on UGameEventTracker");
static_assert(offsetof(UGameEventTracker, OnGameplayEvent) == 0x000030, "Member 'UGameEventTracker::OnGameplayEvent' has a wrong offset!");
static_assert(offsetof(UGameEventTracker, OnGameflowEvent) == 0x000040, "Member 'UGameEventTracker::OnGameflowEvent' has a wrong offset!");

// Class DeadByDaylight.GameObjectivesComponent
// 0x0028 (0x00E0 - 0x00B8)
class UGameObjectivesComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGameObjectiveBase*>             _gameObjectives;                                   // 0x00D0(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)

public:
	void OnRep_GameObjectives(const TArray<class AGameObjectiveBase*>& oldArray);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameObjectivesComponent">();
	}
	static class UGameObjectivesComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameObjectivesComponent>();
	}
};
static_assert(alignof(UGameObjectivesComponent) == 0x000008, "Wrong alignment on UGameObjectivesComponent");
static_assert(sizeof(UGameObjectivesComponent) == 0x0000E0, "Wrong size on UGameObjectivesComponent");
static_assert(offsetof(UGameObjectivesComponent, _gameObjectives) == 0x0000D0, "Member 'UGameObjectivesComponent::_gameObjectives' has a wrong offset!");

// Class DeadByDaylight.GameObjectivesUtilities
// 0x0000 (0x0030 - 0x0030)
class UGameObjectivesUtilities final : public UBlueprintFunctionLibrary
{
public:
	static bool AreAllGameObjectivesCompleted(const class UObject* WorldContextObject);
	static int32 GetRemainingGeneratorsNeeded(const class UObject* WorldContextObject);
	static int32 GetRequiredActivatedGeneratorCount(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameObjectivesUtilities">();
	}
	static class UGameObjectivesUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameObjectivesUtilities>();
	}
};
static_assert(alignof(UGameObjectivesUtilities) == 0x000008, "Wrong alignment on UGameObjectivesUtilities");
static_assert(sizeof(UGameObjectivesUtilities) == 0x000030, "Wrong size on UGameObjectivesUtilities");

// Class DeadByDaylight.GameObjective_ActivatedGenerators
// 0x0010 (0x0308 - 0x02F8)
class AGameObjective_ActivatedGenerators : public AGameObjective_ActorInterfaceList
{
public:
	EActivatedGenerators_ObjectiveCountType       _objectiveCountType;                               // 0x02F8(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F9[0x3];                                      // 0x02F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _requiredCount;                                    // 0x02FC(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _activatedCount;                                   // 0x0300(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnGeneratorActivated(bool isAutoCompleted, class AActor* generatorActor);
	void OnRep_ActivatedCount(int32 oldCount);
	void OnRep_RequiredCount(int32 oldCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameObjective_ActivatedGenerators">();
	}
	static class AGameObjective_ActivatedGenerators* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameObjective_ActivatedGenerators>();
	}
};
static_assert(alignof(AGameObjective_ActivatedGenerators) == 0x000008, "Wrong alignment on AGameObjective_ActivatedGenerators");
static_assert(sizeof(AGameObjective_ActivatedGenerators) == 0x000308, "Wrong size on AGameObjective_ActivatedGenerators");
static_assert(offsetof(AGameObjective_ActivatedGenerators, _objectiveCountType) == 0x0002F8, "Member 'AGameObjective_ActivatedGenerators::_objectiveCountType' has a wrong offset!");
static_assert(offsetof(AGameObjective_ActivatedGenerators, _requiredCount) == 0x0002FC, "Member 'AGameObjective_ActivatedGenerators::_requiredCount' has a wrong offset!");
static_assert(offsetof(AGameObjective_ActivatedGenerators, _activatedCount) == 0x000300, "Member 'AGameObjective_ActivatedGenerators::_activatedCount' has a wrong offset!");

// Class DeadByDaylight.SurvivorOutlineUpdateStrategy
// 0x0088 (0x01E8 - 0x0160)
class USurvivorOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _inDangerColorForSurvivor;                         // 0x0160(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _noRecoveryDyingColor;                             // 0x0170(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _fullRecoveryDyingColor;                           // 0x0180(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _saviourColorForSurvivor;                          // 0x0190(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _colorForKiller;                                   // 0x01A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _locallyObservedSurvivorColor;                     // 0x01B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture*                               _revealedGradient;                                 // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture*                               _nonRevealedGradient;                              // 0x01C8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                   _revealToKillerDurationTags;                       // 0x01D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _revealToKillerLingerTimer;                        // 0x01E0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _trappedIconActive;                                // 0x01E4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E5[0x3];                                      // 0x01E5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static TArray<class UGameplayModifierContainer*> GetEffectsProtectingFromKillerAuraReading(const class ASurvivor* Subject, const class AKiller* Killer);
	static bool IsActivelyHidingAuraFromKiller(const class ASurvivor* Subject, const class AKiller* witness);

	void SetTrappedIconActive(bool Value);

	bool IsBlockingAuraReadingFromKiller(const class AKiller* Killer) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorOutlineUpdateStrategy">();
	}
	static class USurvivorOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorOutlineUpdateStrategy>();
	}
};
static_assert(alignof(USurvivorOutlineUpdateStrategy) == 0x000008, "Wrong alignment on USurvivorOutlineUpdateStrategy");
static_assert(sizeof(USurvivorOutlineUpdateStrategy) == 0x0001E8, "Wrong size on USurvivorOutlineUpdateStrategy");
static_assert(offsetof(USurvivorOutlineUpdateStrategy, _inDangerColorForSurvivor) == 0x000160, "Member 'USurvivorOutlineUpdateStrategy::_inDangerColorForSurvivor' has a wrong offset!");
static_assert(offsetof(USurvivorOutlineUpdateStrategy, _noRecoveryDyingColor) == 0x000170, "Member 'USurvivorOutlineUpdateStrategy::_noRecoveryDyingColor' has a wrong offset!");
static_assert(offsetof(USurvivorOutlineUpdateStrategy, _fullRecoveryDyingColor) == 0x000180, "Member 'USurvivorOutlineUpdateStrategy::_fullRecoveryDyingColor' has a wrong offset!");
static_assert(offsetof(USurvivorOutlineUpdateStrategy, _saviourColorForSurvivor) == 0x000190, "Member 'USurvivorOutlineUpdateStrategy::_saviourColorForSurvivor' has a wrong offset!");
static_assert(offsetof(USurvivorOutlineUpdateStrategy, _colorForKiller) == 0x0001A0, "Member 'USurvivorOutlineUpdateStrategy::_colorForKiller' has a wrong offset!");
static_assert(offsetof(USurvivorOutlineUpdateStrategy, _locallyObservedSurvivorColor) == 0x0001B0, "Member 'USurvivorOutlineUpdateStrategy::_locallyObservedSurvivorColor' has a wrong offset!");
static_assert(offsetof(USurvivorOutlineUpdateStrategy, _revealedGradient) == 0x0001C0, "Member 'USurvivorOutlineUpdateStrategy::_revealedGradient' has a wrong offset!");
static_assert(offsetof(USurvivorOutlineUpdateStrategy, _nonRevealedGradient) == 0x0001C8, "Member 'USurvivorOutlineUpdateStrategy::_nonRevealedGradient' has a wrong offset!");
static_assert(offsetof(USurvivorOutlineUpdateStrategy, _revealToKillerDurationTags) == 0x0001D0, "Member 'USurvivorOutlineUpdateStrategy::_revealToKillerDurationTags' has a wrong offset!");
static_assert(offsetof(USurvivorOutlineUpdateStrategy, _revealToKillerLingerTimer) == 0x0001E0, "Member 'USurvivorOutlineUpdateStrategy::_revealToKillerLingerTimer' has a wrong offset!");
static_assert(offsetof(USurvivorOutlineUpdateStrategy, _trappedIconActive) == 0x0001E4, "Member 'USurvivorOutlineUpdateStrategy::_trappedIconActive' has a wrong offset!");

// Class DeadByDaylight.GameplayModifierFunctionLibraryStatusEffect
// 0x0000 (0x0398 - 0x0398)
class UGameplayModifierFunctionLibraryStatusEffect final : public UStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayModifierFunctionLibraryStatusEffect">();
	}
	static class UGameplayModifierFunctionLibraryStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayModifierFunctionLibraryStatusEffect>();
	}
};
static_assert(alignof(UGameplayModifierFunctionLibraryStatusEffect) == 0x000008, "Wrong alignment on UGameplayModifierFunctionLibraryStatusEffect");
static_assert(sizeof(UGameplayModifierFunctionLibraryStatusEffect) == 0x000398, "Wrong size on UGameplayModifierFunctionLibraryStatusEffect");

// Class DeadByDaylight.GameStateWatchdog
// 0x0018 (0x0050 - 0x0038)
class UGameStateWatchdog final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnWorldLoaded(class UWorld* newWorld);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateWatchdog">();
	}
	static class UGameStateWatchdog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStateWatchdog>();
	}
};
static_assert(alignof(UGameStateWatchdog) == 0x000008, "Wrong alignment on UGameStateWatchdog");
static_assert(sizeof(UGameStateWatchdog) == 0x000050, "Wrong size on UGameStateWatchdog");

// Class DeadByDaylight.MutatorData
// 0x0010 (0x0048 - 0x0038)
class UMutatorData final : public UDataAsset
{
public:
	TArray<class UMutator*>                       _mutators;                                         // 0x0038(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MutatorData">();
	}
	static class UMutatorData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMutatorData>();
	}
};
static_assert(alignof(UMutatorData) == 0x000008, "Wrong alignment on UMutatorData");
static_assert(sizeof(UMutatorData) == 0x000048, "Wrong size on UMutatorData");
static_assert(offsetof(UMutatorData, _mutators) == 0x000038, "Member 'UMutatorData::_mutators' has a wrong offset!");

// Class DeadByDaylight.GateFactory
// 0x0000 (0x02A0 - 0x02A0)
class AGateFactory final : public AActor
{
public:
	class AGate* GetGate(EGateType GateType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GateFactory">();
	}
	static class AGateFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGateFactory>();
	}
};
static_assert(alignof(AGateFactory) == 0x000008, "Wrong alignment on AGateFactory");
static_assert(sizeof(AGateFactory) == 0x0002A0, "Wrong size on AGateFactory");

// Class DeadByDaylight.TallyUIUtilities
// 0x0000 (0x0030 - 0x0030)
class UTallyUIUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TallyUIUtilities">();
	}
	static class UTallyUIUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTallyUIUtilities>();
	}
};
static_assert(alignof(UTallyUIUtilities) == 0x000008, "Wrong alignment on UTallyUIUtilities");
static_assert(sizeof(UTallyUIUtilities) == 0x000030, "Wrong size on UTallyUIUtilities");

// Class DeadByDaylight.CoopRepairTracker
// 0x0010 (0x0040 - 0x0030)
class UCoopRepairTracker final : public UObject
{
public:
	TArray<class ADBDPlayer*>                     _coopRepairerHistory;                              // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void SetHasEverCoopRepaired(const class ADBDPlayer* Player);

	bool HasEverCoopRepaired(const class ADBDPlayer* Player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoopRepairTracker">();
	}
	static class UCoopRepairTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoopRepairTracker>();
	}
};
static_assert(alignof(UCoopRepairTracker) == 0x000008, "Wrong alignment on UCoopRepairTracker");
static_assert(sizeof(UCoopRepairTracker) == 0x000040, "Wrong size on UCoopRepairTracker");
static_assert(offsetof(UCoopRepairTracker, _coopRepairerHistory) == 0x000030, "Member 'UCoopRepairTracker::_coopRepairerHistory' has a wrong offset!");

// Class DeadByDaylight.GeneratorDamageComponent
// 0x0078 (0x0130 - 0x00B8)
class UGeneratorDamageComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool intense)>  Cosmetic_OnGeneratorDamaged;                       // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	struct FDamageData                            _damageData;                                       // 0x00D8(0x0020)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _gradualRegressionPercentPerDamage;                // 0x00F8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x10];                                     // 0x0120(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_DamageEffects(const float immediateRegressionPercent, const TArray<class ADBDPlayer*>& repairers, const bool playLoudNoise);
	void OnRep_DamageData();

	bool IsIntenseDamage() const;
	bool IsRegressing() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratorDamageComponent">();
	}
	static class UGeneratorDamageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneratorDamageComponent>();
	}
};
static_assert(alignof(UGeneratorDamageComponent) == 0x000008, "Wrong alignment on UGeneratorDamageComponent");
static_assert(sizeof(UGeneratorDamageComponent) == 0x000130, "Wrong size on UGeneratorDamageComponent");
static_assert(offsetof(UGeneratorDamageComponent, Cosmetic_OnGeneratorDamaged) == 0x0000C8, "Member 'UGeneratorDamageComponent::Cosmetic_OnGeneratorDamaged' has a wrong offset!");
static_assert(offsetof(UGeneratorDamageComponent, _damageData) == 0x0000D8, "Member 'UGeneratorDamageComponent::_damageData' has a wrong offset!");
static_assert(offsetof(UGeneratorDamageComponent, _gradualRegressionPercentPerDamage) == 0x0000F8, "Member 'UGeneratorDamageComponent::_gradualRegressionPercentPerDamage' has a wrong offset!");

// Class DeadByDaylight.GeneratorDrivenActorLinkerComponent
// 0x0008 (0x00C0 - 0x00B8)
class UGeneratorDrivenActorLinkerComponent final : public UActorComponent
{
public:
	class UActorSpawner*                          _owningSpawner;                                    // 0x00B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratorDrivenActorLinkerComponent">();
	}
	static class UGeneratorDrivenActorLinkerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneratorDrivenActorLinkerComponent>();
	}
};
static_assert(alignof(UGeneratorDrivenActorLinkerComponent) == 0x000008, "Wrong alignment on UGeneratorDrivenActorLinkerComponent");
static_assert(sizeof(UGeneratorDrivenActorLinkerComponent) == 0x0000C0, "Wrong size on UGeneratorDrivenActorLinkerComponent");
static_assert(offsetof(UGeneratorDrivenActorLinkerComponent, _owningSpawner) == 0x0000B8, "Member 'UGeneratorDrivenActorLinkerComponent::_owningSpawner' has a wrong offset!");

// Class DeadByDaylight.TileBank
// 0x0160 (0x0190 - 0x0030)
class UTileBank final : public UObject
{
public:
	uint8                                         Pad_30[0x140];                                     // 0x0030(0x0140)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ATile*>                          _outOfWorldTileBlueprints;                         // 0x0170(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ATile*>                          _allTileBlueprints;                                // 0x0180(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TileBank">();
	}
	static class UTileBank* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTileBank>();
	}
};
static_assert(alignof(UTileBank) == 0x000008, "Wrong alignment on UTileBank");
static_assert(sizeof(UTileBank) == 0x000190, "Wrong size on UTileBank");
static_assert(offsetof(UTileBank, _outOfWorldTileBlueprints) == 0x000170, "Member 'UTileBank::_outOfWorldTileBlueprints' has a wrong offset!");
static_assert(offsetof(UTileBank, _allTileBlueprints) == 0x000180, "Member 'UTileBank::_allTileBlueprints' has a wrong offset!");

// Class DeadByDaylight.GeneratorEntity
// 0x0030 (0x02D0 - 0x02A0)
class AGeneratorEntity final : public AActor
{
public:
	class UObject*                                _associatedGenerator;                              // 0x02A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMontagePlayer*                         _montagePlayer;                                    // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0[0x20];                                     // 0x02B0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayMontage(const struct FAnimationMontageDescriptor& animMontageID, float PlayRate, bool isFollower);
	void SetAssociatedGenerator(class UObject* Generator);
	void SetSkeletalMeshActive(bool Active);

	class UMontagePlayer* GetMontagePlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratorEntity">();
	}
	static class AGeneratorEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGeneratorEntity>();
	}
};
static_assert(alignof(AGeneratorEntity) == 0x000008, "Wrong alignment on AGeneratorEntity");
static_assert(sizeof(AGeneratorEntity) == 0x0002D0, "Wrong size on AGeneratorEntity");
static_assert(offsetof(AGeneratorEntity, _associatedGenerator) == 0x0002A0, "Member 'AGeneratorEntity::_associatedGenerator' has a wrong offset!");
static_assert(offsetof(AGeneratorEntity, _montagePlayer) == 0x0002A8, "Member 'AGeneratorEntity::_montagePlayer' has a wrong offset!");

// Class DeadByDaylight.GeneratorEntityAnimInstance
// 0x0010 (0x0360 - 0x0350)
class UGeneratorEntityAnimInstance final : public UAnimInstance
{
public:
	bool                                          IsCorrupted;                                       // 0x0350(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsCorrupted_End;                                   // 0x0351(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsUncorrupted;                                     // 0x0352(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsUncorrupted_End;                                 // 0x0353(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_354[0xC];                                      // 0x0354(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratorEntityAnimInstance">();
	}
	static class UGeneratorEntityAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneratorEntityAnimInstance>();
	}
};
static_assert(alignof(UGeneratorEntityAnimInstance) == 0x000010, "Wrong alignment on UGeneratorEntityAnimInstance");
static_assert(sizeof(UGeneratorEntityAnimInstance) == 0x000360, "Wrong size on UGeneratorEntityAnimInstance");
static_assert(offsetof(UGeneratorEntityAnimInstance, IsCorrupted) == 0x000350, "Member 'UGeneratorEntityAnimInstance::IsCorrupted' has a wrong offset!");
static_assert(offsetof(UGeneratorEntityAnimInstance, IsCorrupted_End) == 0x000351, "Member 'UGeneratorEntityAnimInstance::IsCorrupted_End' has a wrong offset!");
static_assert(offsetof(UGeneratorEntityAnimInstance, IsUncorrupted) == 0x000352, "Member 'UGeneratorEntityAnimInstance::IsUncorrupted' has a wrong offset!");
static_assert(offsetof(UGeneratorEntityAnimInstance, IsUncorrupted_End) == 0x000353, "Member 'UGeneratorEntityAnimInstance::IsUncorrupted_End' has a wrong offset!");

// Class DeadByDaylight.GeneratorOutlineUpdateStrategy
// 0x0060 (0x01C0 - 0x0160)
class UGeneratorOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _unrepairedAuraColor;                              // 0x0160(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _fullyRepairedAuraColor;                           // 0x0170(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _fullyRepairedOrangeAuraColor;                     // 0x0180(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FKillerOutlineRevealSettings           _killerRevealSettings;                             // 0x0190(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_198[0x28];                                     // 0x0198(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FLinearColor GetWhiteColor() const;
	struct FLinearColor GetYellowColor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratorOutlineUpdateStrategy">();
	}
	static class UGeneratorOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneratorOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UGeneratorOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UGeneratorOutlineUpdateStrategy");
static_assert(sizeof(UGeneratorOutlineUpdateStrategy) == 0x0001C0, "Wrong size on UGeneratorOutlineUpdateStrategy");
static_assert(offsetof(UGeneratorOutlineUpdateStrategy, _unrepairedAuraColor) == 0x000160, "Member 'UGeneratorOutlineUpdateStrategy::_unrepairedAuraColor' has a wrong offset!");
static_assert(offsetof(UGeneratorOutlineUpdateStrategy, _fullyRepairedAuraColor) == 0x000170, "Member 'UGeneratorOutlineUpdateStrategy::_fullyRepairedAuraColor' has a wrong offset!");
static_assert(offsetof(UGeneratorOutlineUpdateStrategy, _fullyRepairedOrangeAuraColor) == 0x000180, "Member 'UGeneratorOutlineUpdateStrategy::_fullyRepairedOrangeAuraColor' has a wrong offset!");
static_assert(offsetof(UGeneratorOutlineUpdateStrategy, _killerRevealSettings) == 0x000190, "Member 'UGeneratorOutlineUpdateStrategy::_killerRevealSettings' has a wrong offset!");

// Class DeadByDaylight.SpringArmCameraTargetingStrategy
// 0x0018 (0x0068 - 0x0050)
class USpringArmCameraTargetingStrategy final : public UBaseCameraTargetingStrategy
{
public:
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpringArmCameraTargetingStrategy">();
	}
	static class USpringArmCameraTargetingStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpringArmCameraTargetingStrategy>();
	}
};
static_assert(alignof(USpringArmCameraTargetingStrategy) == 0x000008, "Wrong alignment on USpringArmCameraTargetingStrategy");
static_assert(sizeof(USpringArmCameraTargetingStrategy) == 0x000068, "Wrong size on USpringArmCameraTargetingStrategy");

// Class DeadByDaylight.GeneratorProgressSurrenderOptionComponent
// 0x0048 (0x0100 - 0x00B8)
class UGeneratorProgressSurrenderOptionComponent final : public UActorComponent
{
public:
	bool                                          _allowSurrenderIfGeneratorsAreNotCompleted;        // 0x00B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _timeBetweenGeneratorCompletionBeforeAllowSurrender; // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x40];                                      // 0x00C0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratorProgressSurrenderOptionComponent">();
	}
	static class UGeneratorProgressSurrenderOptionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneratorProgressSurrenderOptionComponent>();
	}
};
static_assert(alignof(UGeneratorProgressSurrenderOptionComponent) == 0x000008, "Wrong alignment on UGeneratorProgressSurrenderOptionComponent");
static_assert(sizeof(UGeneratorProgressSurrenderOptionComponent) == 0x000100, "Wrong size on UGeneratorProgressSurrenderOptionComponent");
static_assert(offsetof(UGeneratorProgressSurrenderOptionComponent, _allowSurrenderIfGeneratorsAreNotCompleted) == 0x0000B8, "Member 'UGeneratorProgressSurrenderOptionComponent::_allowSurrenderIfGeneratorsAreNotCompleted' has a wrong offset!");
static_assert(offsetof(UGeneratorProgressSurrenderOptionComponent, _timeBetweenGeneratorCompletionBeforeAllowSurrender) == 0x0000BC, "Member 'UGeneratorProgressSurrenderOptionComponent::_timeBetweenGeneratorCompletionBeforeAllowSurrender' has a wrong offset!");

// Class DeadByDaylight.GeneratorRepairWithGenericPerksEscapeAchievement
// 0x0020 (0x00D8 - 0x00B8)
class UGeneratorRepairWithGenericPerksEscapeAchievement final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x20];                                      // 0x00B8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratorRepairWithGenericPerksEscapeAchievement">();
	}
	static class UGeneratorRepairWithGenericPerksEscapeAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneratorRepairWithGenericPerksEscapeAchievement>();
	}
};
static_assert(alignof(UGeneratorRepairWithGenericPerksEscapeAchievement) == 0x000008, "Wrong alignment on UGeneratorRepairWithGenericPerksEscapeAchievement");
static_assert(sizeof(UGeneratorRepairWithGenericPerksEscapeAchievement) == 0x0000D8, "Wrong size on UGeneratorRepairWithGenericPerksEscapeAchievement");

// Class DeadByDaylight.GenyReflectionCaptureComponent
// 0x0010 (0x02E0 - 0x02D0)
class UGenyReflectionCaptureComponent final : public USceneComponent
{
public:
	TArray<struct FReflectionCaptureTwoStates>    generatorDrivenReflectionCapture;                  // 0x02D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenyReflectionCaptureComponent">();
	}
	static class UGenyReflectionCaptureComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGenyReflectionCaptureComponent>();
	}
};
static_assert(alignof(UGenyReflectionCaptureComponent) == 0x000010, "Wrong alignment on UGenyReflectionCaptureComponent");
static_assert(sizeof(UGenyReflectionCaptureComponent) == 0x0002E0, "Wrong size on UGenyReflectionCaptureComponent");
static_assert(offsetof(UGenyReflectionCaptureComponent, generatorDrivenReflectionCapture) == 0x0002D0, "Member 'UGenyReflectionCaptureComponent::generatorDrivenReflectionCapture' has a wrong offset!");

// Class DeadByDaylight.GhostStalkedUIData
// 0x0000 (0x0000 - 0x0000)
class IGhostStalkedUIData final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GhostStalkedUIData">();
	}
	static class IGhostStalkedUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGhostStalkedUIData>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IGhostStalkedUIData) == 0x000001, "Wrong alignment on IGhostStalkedUIData");
static_assert(sizeof(IGhostStalkedUIData) == 0x000001, "Wrong size on IGhostStalkedUIData");

// Class DeadByDaylight.GhostStealthUIData
// 0x0000 (0x0000 - 0x0000)
class IGhostStealthUIData final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GhostStealthUIData">();
	}
	static class IGhostStealthUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGhostStealthUIData>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IGhostStealthUIData) == 0x000001, "Wrong alignment on IGhostStealthUIData");
static_assert(sizeof(IGhostStealthUIData) == 0x000001, "Wrong size on IGhostStealthUIData");

// Class DeadByDaylight.GiftManager
// 0x0038 (0x0070 - 0x0038)
class UGiftManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x38];                                      // 0x0038(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GiftManager">();
	}
	static class UGiftManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGiftManager>();
	}
};
static_assert(alignof(UGiftManager) == 0x000008, "Wrong alignment on UGiftManager");
static_assert(sizeof(UGiftManager) == 0x000070, "Wrong size on UGiftManager");

// Class DeadByDaylight.GlassStaticMesh
// 0x00A0 (0x0730 - 0x0690)
class UGlassStaticMesh final : public UStaticMeshComponent
{
public:
	uint8                                         Pad_688[0x88];                                     // 0x0688(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                defaultGlassNormalVector;                          // 0x0710(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_728[0x8];                                      // 0x0728(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlassStaticMesh">();
	}
	static class UGlassStaticMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlassStaticMesh>();
	}
};
static_assert(alignof(UGlassStaticMesh) == 0x000010, "Wrong alignment on UGlassStaticMesh");
static_assert(sizeof(UGlassStaticMesh) == 0x000730, "Wrong size on UGlassStaticMesh");
static_assert(offsetof(UGlassStaticMesh, defaultGlassNormalVector) == 0x000710, "Member 'UGlassStaticMesh::defaultGlassNormalVector' has a wrong offset!");

// Class DeadByDaylight.StateSpeedCurveApplier
// 0x0110 (0x01C8 - 0x00B8)
class UStateSpeedCurveApplier final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x110];                                     // 0x00B8(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateSpeedCurveApplier">();
	}
	static class UStateSpeedCurveApplier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateSpeedCurveApplier>();
	}
};
static_assert(alignof(UStateSpeedCurveApplier) == 0x000008, "Wrong alignment on UStateSpeedCurveApplier");
static_assert(sizeof(UStateSpeedCurveApplier) == 0x0001C8, "Wrong size on UStateSpeedCurveApplier");

// Class DeadByDaylight.GlassCollectionSubsystem
// 0x0010 (0x0048 - 0x0038)
class UGlassCollectionSubsystem final : public UGameInstanceSubsystem
{
public:
	TArray<class UGlassStaticMesh*>               _glassCollection;                                  // 0x0038(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlassCollectionSubsystem">();
	}
	static class UGlassCollectionSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlassCollectionSubsystem>();
	}
};
static_assert(alignof(UGlassCollectionSubsystem) == 0x000008, "Wrong alignment on UGlassCollectionSubsystem");
static_assert(sizeof(UGlassCollectionSubsystem) == 0x000048, "Wrong size on UGlassCollectionSubsystem");
static_assert(offsetof(UGlassCollectionSubsystem, _glassCollection) == 0x000038, "Member 'UGlassCollectionSubsystem::_glassCollection' has a wrong offset!");

// Class DeadByDaylight.GRDKProfileDAL
// 0x0000 (0x0088 - 0x0088)
class UGRDKProfileDAL final : public UPS4GRDKBaseProfileDAL
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GRDKProfileDAL">();
	}
	static class UGRDKProfileDAL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGRDKProfileDAL>();
	}
};
static_assert(alignof(UGRDKProfileDAL) == 0x000008, "Wrong alignment on UGRDKProfileDAL");
static_assert(sizeof(UGRDKProfileDAL) == 0x000088, "Wrong size on UGRDKProfileDAL");

// Class DeadByDaylight.HangDiagnosticSubsystem
// 0x0068 (0x00A0 - 0x0038)
class UHangDiagnosticSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x68];                                      // 0x0038(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HangDiagnosticSubsystem">();
	}
	static class UHangDiagnosticSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHangDiagnosticSubsystem>();
	}
};
static_assert(alignof(UHangDiagnosticSubsystem) == 0x000008, "Wrong alignment on UHangDiagnosticSubsystem");
static_assert(sizeof(UHangDiagnosticSubsystem) == 0x0000A0, "Wrong size on UHangDiagnosticSubsystem");

// Class DeadByDaylight.HasTokenAndIsApplicableOrActivationTimerElapsedIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UHasTokenAndIsApplicableOrActivationTimerElapsedIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HasTokenAndIsApplicableOrActivationTimerElapsedIconStrategy">();
	}
	static class UHasTokenAndIsApplicableOrActivationTimerElapsedIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHasTokenAndIsApplicableOrActivationTimerElapsedIconStrategy>();
	}
};
static_assert(alignof(UHasTokenAndIsApplicableOrActivationTimerElapsedIconStrategy) == 0x000008, "Wrong alignment on UHasTokenAndIsApplicableOrActivationTimerElapsedIconStrategy");
static_assert(sizeof(UHasTokenAndIsApplicableOrActivationTimerElapsedIconStrategy) == 0x000038, "Wrong size on UHasTokenAndIsApplicableOrActivationTimerElapsedIconStrategy");

// Class DeadByDaylight.HasTokenOrActivationTimerElapsedIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UHasTokenOrActivationTimerElapsedIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HasTokenOrActivationTimerElapsedIconStrategy">();
	}
	static class UHasTokenOrActivationTimerElapsedIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHasTokenOrActivationTimerElapsedIconStrategy>();
	}
};
static_assert(alignof(UHasTokenOrActivationTimerElapsedIconStrategy) == 0x000008, "Wrong alignment on UHasTokenOrActivationTimerElapsedIconStrategy");
static_assert(sizeof(UHasTokenOrActivationTimerElapsedIconStrategy) == 0x000038, "Wrong size on UHasTokenOrActivationTimerElapsedIconStrategy");

// Class DeadByDaylight.ScreenshotPhysicsWeaponHook
// 0x0018 (0x0048 - 0x0030)
class UScreenshotPhysicsWeaponHook final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           KillersId;                                         // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenshotPhysicsWeaponHook">();
	}
	static class UScreenshotPhysicsWeaponHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenshotPhysicsWeaponHook>();
	}
};
static_assert(alignof(UScreenshotPhysicsWeaponHook) == 0x000008, "Wrong alignment on UScreenshotPhysicsWeaponHook");
static_assert(sizeof(UScreenshotPhysicsWeaponHook) == 0x000048, "Wrong size on UScreenshotPhysicsWeaponHook");
static_assert(offsetof(UScreenshotPhysicsWeaponHook, KillersId) == 0x000038, "Member 'UScreenshotPhysicsWeaponHook::KillersId' has a wrong offset!");

// Class DeadByDaylight.HasTokenPerkIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UHasTokenPerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HasTokenPerkIconStrategy">();
	}
	static class UHasTokenPerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHasTokenPerkIconStrategy>();
	}
};
static_assert(alignof(UHasTokenPerkIconStrategy) == 0x000008, "Wrong alignment on UHasTokenPerkIconStrategy");
static_assert(sizeof(UHasTokenPerkIconStrategy) == 0x000038, "Wrong size on UHasTokenPerkIconStrategy");

// Class DeadByDaylight.Hatch
// 0x00A0 (0x0448 - 0x03A8)
class AHatch final : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x48];                                     // 0x03A8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	EHatchState                                   _hatchState;                                       // 0x03F0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F1[0x1];                                      // 0x03F1(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isEndGameOver;                                    // 0x03F2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isForceOpen;                                      // 0x03F3(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F4[0x4];                                      // 0x03F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    _baseCollision;                                    // 0x03F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_400[0x10];                                     // 0x0400(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _hatchCloseDelay;                                  // 0x0410(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_438[0x10];                                     // 0x0438(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_CheckedChangeActiveState();
	void Authority_CheckedCloseHatch();
	void Authority_CheckedOpenForceClosedHatch();
	void Authority_CheckedOpenHatch();
	void Authority_OnCloseTimerComplete();
	void Authority_OnEndGameOver(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData);
	void Authority_OnHatchVisibilityChanged(bool IsVisible);
	void Authority_ResetTimer(float Duration);
	void Authority_SetHatchState(EHatchState newState);
	void Authority_SetIsForceOpen(bool isForcedOpen);
	void FXCloseHatch();
	void FXEndSmoke();
	void FXOpenHatch();
	void OnHatchStateModified(EHatchState oldState, EHatchState newState);
	void OnHatchStateUnhidden();
	void OnRep_HatchState(EHatchState oldState);

	class UAnimationMontageSlave* GetAnimationMontageSlave() const;
	class USceneComponent* GetEscapeFocalPoint() const;
	class USceneComponent* GetHatchCenter() const;
	EHatchState GetHatchState() const;
	bool IsOpen() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Hatch">();
	}
	static class AHatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHatch>();
	}
};
static_assert(alignof(AHatch) == 0x000008, "Wrong alignment on AHatch");
static_assert(sizeof(AHatch) == 0x000448, "Wrong size on AHatch");
static_assert(offsetof(AHatch, _hatchState) == 0x0003F0, "Member 'AHatch::_hatchState' has a wrong offset!");
static_assert(offsetof(AHatch, _isEndGameOver) == 0x0003F2, "Member 'AHatch::_isEndGameOver' has a wrong offset!");
static_assert(offsetof(AHatch, _isForceOpen) == 0x0003F3, "Member 'AHatch::_isForceOpen' has a wrong offset!");
static_assert(offsetof(AHatch, _baseCollision) == 0x0003F8, "Member 'AHatch::_baseCollision' has a wrong offset!");
static_assert(offsetof(AHatch, _hatchCloseDelay) == 0x000410, "Member 'AHatch::_hatchCloseDelay' has a wrong offset!");

// Class DeadByDaylight.HealthComponent
// 0x02D0 (0x0388 - 0x00B8)
class UHealthComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x38];                                      // 0x00B8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FHealResult& HealResult)> OnHealedDelegate;           // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnInjuredBleedoutStarted;                          // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnInjuredBleedoutEnded;                            // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADBDPlayer* injuredBleedoutInstigator)> OnInjuredBleedoutKO; // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_130[0x30];                                     // 0x0130(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(EHealthState oldDamageState, EHealthState newDamageState)> OnDamageStateChanged; // 0x0160(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDamageStateChangedCosmetic;                      // 0x0170(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_180[0x30];                                     // 0x0180(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _bleedoutBaseDuration;                             // 0x01B0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTagStateBool                          _inInjuredBleedOut;                                // 0x01D8(0x0048)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	bool                                          _isInjuredBleedOutPaused;                          // 0x0220(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isKOByInjuredBleedout;                            // 0x0221(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_222[0x6];                                      // 0x0222(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTimer                              _bleedOutTimer;                                    // 0x0228(0x0028)(Net, Transient, NativeAccessSpecifierPrivate)
	bool                                          _canBleedout;                                      // 0x0250(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_251[0x7];                                      // 0x0251(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UInteractionDefinition>> _pauseInjuredBleedoutTimerInteractions;        // 0x0258(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	int32                                         _currentHealthStateCount;                          // 0x0268(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_26C[0x4];                                      // 0x026C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _numHealthyHeals;                                  // 0x0270(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_274[0x4];                                      // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTimer                              _dyingTimer;                                       // 0x0278(0x0028)(Net, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargeableComponent*                   _healFromDyingChargeable;                          // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _healFromInjuredChargeable;                        // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _mendChargeable;                                   // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDPlayer*                             _injuredBleedoutInstigator;                        // 0x02C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C8[0xC0];                                     // 0x02C8(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_ApplyDamage(class AActor* damageSource, class ACharacter* damagePlayerOwner, bool bypassInjuredBleedout);
	void Authority_ApplyDeepWound(class AActor* damageSource, class ACharacter* damagePlayerOwner);
	void Authority_ApplyDoubleDamage(class AActor* damageSource, class ACharacter* damagePlayerOwner);
	void Authority_EndInjuredBleedout();
	void Authority_HealTryGrantScoresOnChargeApplied(float IndividualChargeAmount, float TotalChargeAmount, class AActor* ChargeInstigator, bool WasCoop, float DeltaTime);
	void Authority_MendTryGrantScoresOnChargeApplied(float IndividualChargeAmount, float TotalChargeAmount, class AActor* ChargeInstigator, bool WasCoop, float DeltaTime);
	void Authority_OnHealChargeChange(class UChargeableComponent* ChargeableComponent, float PercentCompletionChange, float TotalPercentComplete);
	void Authority_OnHealthBarCharged(bool complete, const TArray<class AActor*>& instigators);
	void Authority_OnMendChargeCompletionStateChanged(bool complete, const TArray<class AActor*>& instigators);
	void Authority_OnSurvivorRemoved(class ASurvivor* Survivor);
	void Authority_SetDamageState(EHealthState damageState, bool FireScoreEvent, bool sacrificed);
	class UChargeableComponent* GetCurrentHPSlot();
	void Multicast_OnHealed(const struct FHealResult& HealResult);
	void Multicast_OnInjuredBleedoutKO(class ADBDPlayer* injuredBleedoutInstigator);
	void Multicast_OnSurvivorGainedHealthStateByOthersEvents(const bool healedFromKO, class ADBDPlayer* healedSurvivor, const TArray<class ADBDPlayer*>& Healers, const TArray<bool>& healedSurvivorFarEnoughAway);
	void Multicast_SetCurrentHealthStateCount(int32 newHealth, bool FireScoreEvent);
	void Multicast_SetHealthState(EHealthState healthState, bool FireScoreEvent, bool sacrificed);
	void Multicast_SetHealthStateCountFromHealthState(EHealthState healthState, bool FireScoreEvent);
	void Multicast_SetHealthType(EHealthType healthType);
	void Multicast_StartInjuredBleedout(class ADBDPlayer* Killer, class UGameplayModifierContainer* container);
	void Multicast_SurvivorDowned(class ADBDPlayer* Killer, class ASurvivor* Survivor);
	void OnImmobilizedStateChanged(const EImmobilizedState oldImmobilizeState, const EImmobilizedState newImmobilizeState);
	void OnRep_InInjuredBleedOut();
	void OnRep_IsInjuredBleedOutPaused();
	void SetCanBleedout(bool canBleedout);

	bool CanBecomeHealthy() const;
	bool CanBeHealed() const;
	bool CanBeHealedFromInjured() const;
	bool CanHealSelf() const;
	float GetCurrentTotalHealthBarPercent() const;
	EHealthState GetDamageState() const;
	float GetPercentDyingTimer() const;
	float GetPercentInjuredBleedoutTimer() const;
	bool IsDead() const;
	bool IsDyingTimerExpired() const;
	bool IsHealthy() const;
	bool IsInInjuredBleedout() const;
	bool IsInjured() const;
	bool IsInjuredBleedoutTimerExpired() const;
	bool IsKO() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HealthComponent">();
	}
	static class UHealthComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHealthComponent>();
	}
};
static_assert(alignof(UHealthComponent) == 0x000008, "Wrong alignment on UHealthComponent");
static_assert(sizeof(UHealthComponent) == 0x000388, "Wrong size on UHealthComponent");
static_assert(offsetof(UHealthComponent, OnHealedDelegate) == 0x0000F0, "Member 'UHealthComponent::OnHealedDelegate' has a wrong offset!");
static_assert(offsetof(UHealthComponent, OnInjuredBleedoutStarted) == 0x000100, "Member 'UHealthComponent::OnInjuredBleedoutStarted' has a wrong offset!");
static_assert(offsetof(UHealthComponent, OnInjuredBleedoutEnded) == 0x000110, "Member 'UHealthComponent::OnInjuredBleedoutEnded' has a wrong offset!");
static_assert(offsetof(UHealthComponent, OnInjuredBleedoutKO) == 0x000120, "Member 'UHealthComponent::OnInjuredBleedoutKO' has a wrong offset!");
static_assert(offsetof(UHealthComponent, OnDamageStateChanged) == 0x000160, "Member 'UHealthComponent::OnDamageStateChanged' has a wrong offset!");
static_assert(offsetof(UHealthComponent, OnDamageStateChangedCosmetic) == 0x000170, "Member 'UHealthComponent::OnDamageStateChangedCosmetic' has a wrong offset!");
static_assert(offsetof(UHealthComponent, _bleedoutBaseDuration) == 0x0001B0, "Member 'UHealthComponent::_bleedoutBaseDuration' has a wrong offset!");
static_assert(offsetof(UHealthComponent, _inInjuredBleedOut) == 0x0001D8, "Member 'UHealthComponent::_inInjuredBleedOut' has a wrong offset!");
static_assert(offsetof(UHealthComponent, _isInjuredBleedOutPaused) == 0x000220, "Member 'UHealthComponent::_isInjuredBleedOutPaused' has a wrong offset!");
static_assert(offsetof(UHealthComponent, _isKOByInjuredBleedout) == 0x000221, "Member 'UHealthComponent::_isKOByInjuredBleedout' has a wrong offset!");
static_assert(offsetof(UHealthComponent, _bleedOutTimer) == 0x000228, "Member 'UHealthComponent::_bleedOutTimer' has a wrong offset!");
static_assert(offsetof(UHealthComponent, _canBleedout) == 0x000250, "Member 'UHealthComponent::_canBleedout' has a wrong offset!");
static_assert(offsetof(UHealthComponent, _pauseInjuredBleedoutTimerInteractions) == 0x000258, "Member 'UHealthComponent::_pauseInjuredBleedoutTimerInteractions' has a wrong offset!");
static_assert(offsetof(UHealthComponent, _currentHealthStateCount) == 0x000268, "Member 'UHealthComponent::_currentHealthStateCount' has a wrong offset!");
static_assert(offsetof(UHealthComponent, _numHealthyHeals) == 0x000270, "Member 'UHealthComponent::_numHealthyHeals' has a wrong offset!");
static_assert(offsetof(UHealthComponent, _dyingTimer) == 0x000278, "Member 'UHealthComponent::_dyingTimer' has a wrong offset!");
static_assert(offsetof(UHealthComponent, _healFromDyingChargeable) == 0x0002A8, "Member 'UHealthComponent::_healFromDyingChargeable' has a wrong offset!");
static_assert(offsetof(UHealthComponent, _healFromInjuredChargeable) == 0x0002B0, "Member 'UHealthComponent::_healFromInjuredChargeable' has a wrong offset!");
static_assert(offsetof(UHealthComponent, _mendChargeable) == 0x0002B8, "Member 'UHealthComponent::_mendChargeable' has a wrong offset!");
static_assert(offsetof(UHealthComponent, _injuredBleedoutInstigator) == 0x0002C0, "Member 'UHealthComponent::_injuredBleedoutInstigator' has a wrong offset!");

// Class DeadByDaylight.HeldInputInteractionStarter
// 0x00F0 (0x01A8 - 0x00B8)
class UHeldInputInteractionStarter final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0xF0];                                      // 0x00B8(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeldInputInteractionStarter">();
	}
	static class UHeldInputInteractionStarter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeldInputInteractionStarter>();
	}
};
static_assert(alignof(UHeldInputInteractionStarter) == 0x000008, "Wrong alignment on UHeldInputInteractionStarter");
static_assert(sizeof(UHeldInputInteractionStarter) == 0x0001A8, "Wrong size on UHeldInputInteractionStarter");

// Class DeadByDaylight.HitValidationConfigsComponent
// 0x0050 (0x0108 - 0x00B8)
class UHitValidationConfigsComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x50];                                      // 0x00B8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_PrintInGameHitValidationConfigs();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitValidationConfigsComponent">();
	}
	static class UHitValidationConfigsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitValidationConfigsComponent>();
	}
};
static_assert(alignof(UHitValidationConfigsComponent) == 0x000008, "Wrong alignment on UHitValidationConfigsComponent");
static_assert(sizeof(UHitValidationConfigsComponent) == 0x000108, "Wrong size on UHitValidationConfigsComponent");

// Class DeadByDaylight.HitValidatorComponent
// 0x0030 (0x00E8 - 0x00B8)
class UHitValidatorComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x28];                                      // 0x00B8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UHitValidationConfigsComponent> _hitValidationConfigComponent;              // 0x00E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Multicast_DrawDebugHit(const struct FHitValidationReport& report);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitValidatorComponent">();
	}
	static class UHitValidatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitValidatorComponent>();
	}
};
static_assert(alignof(UHitValidatorComponent) == 0x000008, "Wrong alignment on UHitValidatorComponent");
static_assert(sizeof(UHitValidatorComponent) == 0x0000E8, "Wrong size on UHitValidatorComponent");
static_assert(offsetof(UHitValidatorComponent, _hitValidationConfigComponent) == 0x0000E0, "Member 'UHitValidatorComponent::_hitValidationConfigComponent' has a wrong offset!");

// Class DeadByDaylight.HitValidatorConfigurator
// 0x0018 (0x00D8 - 0x00C0)
class UHitValidatorConfigurator final : public UBaseHitValidationConfigurator
{
public:
	uint8                                         Pad_C0[0x18];                                      // 0x00C0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitValidatorConfigurator">();
	}
	static class UHitValidatorConfigurator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitValidatorConfigurator>();
	}
};
static_assert(alignof(UHitValidatorConfigurator) == 0x000008, "Wrong alignment on UHitValidatorConfigurator");
static_assert(sizeof(UHitValidatorConfigurator) == 0x0000D8, "Wrong size on UHitValidatorConfigurator");

// Class DeadByDaylight.HookableComponent
// 0x0180 (0x0238 - 0x00B8)
class UHookableComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(int32 drainState)> Cosmetic_OnDrainStateChanged;                   // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x170];                                     // 0x00C8(0x0170)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_DebugSetHookDrainStage(int32 drainStage);
	void Authority_DebugSetHookEscapeAutoFail(const bool fail);
	void Authority_DebugSetHookEscapeAutoSuccess(const bool Success);
	void Multicast_SetDrainStage(int32 newDrainStage, class ADBDPlayer* Instigator, const bool forceUpdateDrainTimer);
	void Multicast_SetDrainTimerPercentLeft(float percentTime);

	int32 GetDrainStage() const;
	float GetDrainTimerPercentLeft() const;
	int32 GetHookedCount() const;
	int32 GetSacrificeStageIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HookableComponent">();
	}
	static class UHookableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHookableComponent>();
	}
};
static_assert(alignof(UHookableComponent) == 0x000008, "Wrong alignment on UHookableComponent");
static_assert(sizeof(UHookableComponent) == 0x000238, "Wrong size on UHookableComponent");
static_assert(offsetof(UHookableComponent, Cosmetic_OnDrainStateChanged) == 0x0000B8, "Member 'UHookableComponent::Cosmetic_OnDrainStateChanged' has a wrong offset!");

// Class DeadByDaylight.ScreenSpaceLocationComponent
// 0x0040 (0x0310 - 0x02D0)
class UScreenSpaceLocationComponent final : public USceneComponent
{
public:
	float                                         ScreenSpaceX;                                      // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScreenSpaceY;                                      // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FrameDelay;                                        // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _updatePositionOnFovChanged;                       // 0x02DC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _updatePositionOnViewportSizeChanged;              // 0x02DD(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DE[0x2];                                      // 0x02DE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              _currentResolution;                                // 0x02E0(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FTransform>                     _previousTransforms;                               // 0x02F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_300[0x10];                                     // 0x0300(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector2D GetCurrentResolution() const;
	bool HasValidPosition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenSpaceLocationComponent">();
	}
	static class UScreenSpaceLocationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenSpaceLocationComponent>();
	}
};
static_assert(alignof(UScreenSpaceLocationComponent) == 0x000010, "Wrong alignment on UScreenSpaceLocationComponent");
static_assert(sizeof(UScreenSpaceLocationComponent) == 0x000310, "Wrong size on UScreenSpaceLocationComponent");
static_assert(offsetof(UScreenSpaceLocationComponent, ScreenSpaceX) == 0x0002D0, "Member 'UScreenSpaceLocationComponent::ScreenSpaceX' has a wrong offset!");
static_assert(offsetof(UScreenSpaceLocationComponent, ScreenSpaceY) == 0x0002D4, "Member 'UScreenSpaceLocationComponent::ScreenSpaceY' has a wrong offset!");
static_assert(offsetof(UScreenSpaceLocationComponent, FrameDelay) == 0x0002D8, "Member 'UScreenSpaceLocationComponent::FrameDelay' has a wrong offset!");
static_assert(offsetof(UScreenSpaceLocationComponent, _updatePositionOnFovChanged) == 0x0002DC, "Member 'UScreenSpaceLocationComponent::_updatePositionOnFovChanged' has a wrong offset!");
static_assert(offsetof(UScreenSpaceLocationComponent, _updatePositionOnViewportSizeChanged) == 0x0002DD, "Member 'UScreenSpaceLocationComponent::_updatePositionOnViewportSizeChanged' has a wrong offset!");
static_assert(offsetof(UScreenSpaceLocationComponent, _currentResolution) == 0x0002E0, "Member 'UScreenSpaceLocationComponent::_currentResolution' has a wrong offset!");
static_assert(offsetof(UScreenSpaceLocationComponent, _previousTransforms) == 0x0002F0, "Member 'UScreenSpaceLocationComponent::_previousTransforms' has a wrong offset!");

// Class DeadByDaylight.HudScreen
// 0x0318 (0x0440 - 0x0128)
class UHudScreen final : public UScreenBase
{
public:
	uint8                                         Pad_128[0xD8];                                     // 0x0128(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	class UCoreHudRootWidget*                     _rootWidget;                                       // 0x0200(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_208[0xB0];                                     // 0x0208(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	class ATutorialsUtilities*                    _tutorialsUtilities;                               // 0x02B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TScriptInterface<class IPlayerStatusViewInterface>> _playerStatusInterfaces;              // 0x02C0(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FInteractionProgressViewData           _interactionProgressViewData;                      // 0x02D0(0x0078)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_348[0x50];                                     // 0x0348(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlayerStatusViewData>          _playerStatusViewData;                             // 0x0398(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A8[0x98];                                     // 0x03A8(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHemorrhageAnimationComplete();
	void OnHideStartSequenceCompleted();
	void OnHUDWidgetFadeOutCompleted();
	void OnTutorialHudFadeInTriggered();
	void OnTutorialHudFadeOutTriggered();

	void OnHUDWidgetDelayCompleted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HudScreen">();
	}
	static class UHudScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHudScreen>();
	}
};
static_assert(alignof(UHudScreen) == 0x000008, "Wrong alignment on UHudScreen");
static_assert(sizeof(UHudScreen) == 0x000440, "Wrong size on UHudScreen");
static_assert(offsetof(UHudScreen, _rootWidget) == 0x000200, "Member 'UHudScreen::_rootWidget' has a wrong offset!");
static_assert(offsetof(UHudScreen, _tutorialsUtilities) == 0x0002B8, "Member 'UHudScreen::_tutorialsUtilities' has a wrong offset!");
static_assert(offsetof(UHudScreen, _playerStatusInterfaces) == 0x0002C0, "Member 'UHudScreen::_playerStatusInterfaces' has a wrong offset!");
static_assert(offsetof(UHudScreen, _interactionProgressViewData) == 0x0002D0, "Member 'UHudScreen::_interactionProgressViewData' has a wrong offset!");
static_assert(offsetof(UHudScreen, _playerStatusViewData) == 0x000398, "Member 'UHudScreen::_playerStatusViewData' has a wrong offset!");

// Class DeadByDaylight.HudStateComponent
// 0x0038 (0x00F0 - 0x00B8)
class UHudStateComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x30];                                      // 0x00B8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isHudVisible;                                     // 0x00E8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isSurvivorActivityHUDForciblyVisible;             // 0x00E9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EA[0x6];                                       // 0x00EA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_IsHudVisible(const bool OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HudStateComponent">();
	}
	static class UHudStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHudStateComponent>();
	}
};
static_assert(alignof(UHudStateComponent) == 0x000008, "Wrong alignment on UHudStateComponent");
static_assert(sizeof(UHudStateComponent) == 0x0000F0, "Wrong size on UHudStateComponent");
static_assert(offsetof(UHudStateComponent, _isHudVisible) == 0x0000E8, "Member 'UHudStateComponent::_isHudVisible' has a wrong offset!");
static_assert(offsetof(UHudStateComponent, _isSurvivorActivityHUDForciblyVisible) == 0x0000E9, "Member 'UHudStateComponent::_isSurvivorActivityHUDForciblyVisible' has a wrong offset!");

// Class DeadByDaylight.SurvivorActivityData
// 0x0010 (0x0048 - 0x0038)
class USurvivorActivityData final : public UDataAsset
{
public:
	TArray<struct FSurvivorActivity>              _allPossibleActivities;                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorActivityData">();
	}
	static class USurvivorActivityData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorActivityData>();
	}
};
static_assert(alignof(USurvivorActivityData) == 0x000008, "Wrong alignment on USurvivorActivityData");
static_assert(sizeof(USurvivorActivityData) == 0x000048, "Wrong size on USurvivorActivityData");
static_assert(offsetof(USurvivorActivityData, _allPossibleActivities) == 0x000038, "Member 'USurvivorActivityData::_allPossibleActivities' has a wrong offset!");

// Class DeadByDaylight.ButtonPromptSource
// 0x0000 (0x0000 - 0x0000)
class IButtonPromptSource final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ButtonPromptSource">();
	}
	static class IButtonPromptSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<IButtonPromptSource>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IButtonPromptSource) == 0x000001, "Wrong alignment on IButtonPromptSource");
static_assert(sizeof(IButtonPromptSource) == 0x000001, "Wrong size on IButtonPromptSource");

// Class DeadByDaylight.CannibalChainsawPower
// 0x0000 (0x0000 - 0x0000)
class ICannibalChainsawPower final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CannibalChainsawPower">();
	}
	static class ICannibalChainsawPower* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICannibalChainsawPower>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ICannibalChainsawPower) == 0x000001, "Wrong alignment on ICannibalChainsawPower");
static_assert(sizeof(ICannibalChainsawPower) == 0x000001, "Wrong size on ICannibalChainsawPower");

// Class DeadByDaylight.ChargeableProgressSource
// 0x0000 (0x0000 - 0x0000)
class IChargeableProgressSource final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChargeableProgressSource">();
	}
	static class IChargeableProgressSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<IChargeableProgressSource>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IChargeableProgressSource) == 0x000001, "Wrong alignment on IChargeableProgressSource");
static_assert(sizeof(IChargeableProgressSource) == 0x000001, "Wrong size on IChargeableProgressSource");

// Class DeadByDaylight.IdentityValidation
// 0x0000 (0x0030 - 0x0030)
class UIdentityValidation final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IdentityValidation">();
	}
	static class UIdentityValidation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIdentityValidation>();
	}
};
static_assert(alignof(UIdentityValidation) == 0x000008, "Wrong alignment on UIdentityValidation");
static_assert(sizeof(UIdentityValidation) == 0x000030, "Wrong size on UIdentityValidation");

// Class DeadByDaylight.Ethereal
// 0x0000 (0x0000 - 0x0000)
class IEthereal final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ethereal">();
	}
	static class IEthereal* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEthereal>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IEthereal) == 0x000001, "Wrong alignment on IEthereal");
static_assert(sizeof(IEthereal) == 0x000001, "Wrong size on IEthereal");

// Class DeadByDaylight.Highlightable
// 0x0000 (0x0000 - 0x0000)
class IHighlightable final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Highlightable">();
	}
	static class IHighlightable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHighlightable>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHighlightable) == 0x000001, "Wrong alignment on IHighlightable");
static_assert(sizeof(IHighlightable) == 0x000001, "Wrong size on IHighlightable");

// Class DeadByDaylight.KillerControls
// 0x0000 (0x0000 - 0x0000)
class IKillerControls final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerControls">();
	}
	static class IKillerControls* GetDefaultObj()
	{
		return GetDefaultObjImpl<IKillerControls>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IKillerControls) == 0x000001, "Wrong alignment on IKillerControls");
static_assert(sizeof(IKillerControls) == 0x000001, "Wrong size on IKillerControls");

// Class DeadByDaylight.ImmobilizeUtilities
// 0x0000 (0x0030 - 0x0030)
class UImmobilizeUtilities final : public UBlueprintFunctionLibrary
{
public:
	static EGuidedState GetGuidedState(const class ADBDPlayer* Player);
	static EImmobilizedState GetImmobilizeState(const class ADBDPlayer* Player);
	static bool HasGuidedState(const class ADBDPlayer* Player, EGuidedState GuidedState);
	static bool HasImmobilizeState(const class ADBDPlayer* Player, EImmobilizedState ImmobilizeState);
	static bool IsGuided(const class ADBDPlayer* Player);
	static bool IsGuidedByPlayer(const class ADBDPlayer* Player, const class ADBDPlayer* guidingPlayer);
	static bool IsImmobilized(const class ADBDPlayer* Player);
	static void RemoveAllGuidingPlayers(class ADBDPlayer* Player);
	static void SetImmobilizeState(class ADBDPlayer* Player, EImmobilizedState ImmobilizeState);
	static void StartGuiding(class ADBDPlayer* Player, EGuidedState GuidedState, class ADBDPlayer* guidingPlayer);
	static void StopGuiding(class ADBDPlayer* Player, class ADBDPlayer* previouslyGuidingPlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImmobilizeUtilities">();
	}
	static class UImmobilizeUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImmobilizeUtilities>();
	}
};
static_assert(alignof(UImmobilizeUtilities) == 0x000008, "Wrong alignment on UImmobilizeUtilities");
static_assert(sizeof(UImmobilizeUtilities) == 0x000030, "Wrong size on UImmobilizeUtilities");

// Class DeadByDaylight.InactiveCooldownTimerPerkIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UInactiveCooldownTimerPerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InactiveCooldownTimerPerkIconStrategy">();
	}
	static class UInactiveCooldownTimerPerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInactiveCooldownTimerPerkIconStrategy>();
	}
};
static_assert(alignof(UInactiveCooldownTimerPerkIconStrategy) == 0x000008, "Wrong alignment on UInactiveCooldownTimerPerkIconStrategy");
static_assert(sizeof(UInactiveCooldownTimerPerkIconStrategy) == 0x000038, "Wrong size on UInactiveCooldownTimerPerkIconStrategy");

// Class DeadByDaylight.InfectedInteractableComponent
// 0x00E8 (0x01A0 - 0x00B8)
class UInfectedInteractableComponent final : public UActorComponent
{
public:
	class UCurveFloat*                            VomitAlphaCurve;                                   // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   VomitAlphaParameterName;                           // 0x00C0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimelineComponent*                     _vomitAlphaTimeline;                               // 0x00D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0xC8];                                      // 0x00D8(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnHitWithVomit();
	void Authority_OnOwningInteractableBeginOrEndUse(bool InUse, class ADBDPlayer* interactingPlayer);
	void Multicast_DebugDisplayLifetime(float RemainingLifeTime);
	void Multicast_DestroyComponent();
	void Multicast_FadeInVomit();
	void Multicast_FadeOutVomit();
	void OnVomitAlphaUpdate(float alpha);
	void SetInteractableMeshAlpha(float alpha);

	class ASurvivor* Authority_GetEquippingPlayer() const;
	bool Authority_IsAMaxSicknessSurvivorInteracting() const;
	class AInteractable* GetOwningInteractable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InfectedInteractableComponent">();
	}
	static class UInfectedInteractableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInfectedInteractableComponent>();
	}
};
static_assert(alignof(UInfectedInteractableComponent) == 0x000008, "Wrong alignment on UInfectedInteractableComponent");
static_assert(sizeof(UInfectedInteractableComponent) == 0x0001A0, "Wrong size on UInfectedInteractableComponent");
static_assert(offsetof(UInfectedInteractableComponent, VomitAlphaCurve) == 0x0000B8, "Member 'UInfectedInteractableComponent::VomitAlphaCurve' has a wrong offset!");
static_assert(offsetof(UInfectedInteractableComponent, VomitAlphaParameterName) == 0x0000C0, "Member 'UInfectedInteractableComponent::VomitAlphaParameterName' has a wrong offset!");
static_assert(offsetof(UInfectedInteractableComponent, _vomitAlphaTimeline) == 0x0000D0, "Member 'UInfectedInteractableComponent::_vomitAlphaTimeline' has a wrong offset!");

// Class DeadByDaylight.UsableWithPerkFlagPerkIconStrategy
// 0x0018 (0x0050 - 0x0038)
class UUsableWithPerkFlagPerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	TArray<struct FGameplayTag>                   _perkTagsOnPlayer;                                 // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          _playerShouldHaveTags;                             // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UsableWithPerkFlagPerkIconStrategy">();
	}
	static class UUsableWithPerkFlagPerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUsableWithPerkFlagPerkIconStrategy>();
	}
};
static_assert(alignof(UUsableWithPerkFlagPerkIconStrategy) == 0x000008, "Wrong alignment on UUsableWithPerkFlagPerkIconStrategy");
static_assert(sizeof(UUsableWithPerkFlagPerkIconStrategy) == 0x000050, "Wrong size on UUsableWithPerkFlagPerkIconStrategy");
static_assert(offsetof(UUsableWithPerkFlagPerkIconStrategy, _perkTagsOnPlayer) == 0x000038, "Member 'UUsableWithPerkFlagPerkIconStrategy::_perkTagsOnPlayer' has a wrong offset!");
static_assert(offsetof(UUsableWithPerkFlagPerkIconStrategy, _playerShouldHaveTags) == 0x000048, "Member 'UUsableWithPerkFlagPerkIconStrategy::_playerShouldHaveTags' has a wrong offset!");

// Class DeadByDaylight.InGameAssetPreloaderComponent
// 0x01A8 (0x0260 - 0x00B8)
class UInGameAssetPreloaderComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FPrimaryAssetId>                  _generalPrimaryAssetIds;                           // 0x00D0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSet<TSoftClassPtr<class UClass>>             _generalRegularAssets;                             // 0x0120(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UInGameAssetPreloaderGatherer>> _assetGathererClasses;                  // 0x0170(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UInGameAssetPreloaderGatherer*>  _assetGatherers;                                   // 0x0180(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_190[0xD0];                                     // 0x0190(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InGameAssetPreloaderComponent">();
	}
	static class UInGameAssetPreloaderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInGameAssetPreloaderComponent>();
	}
};
static_assert(alignof(UInGameAssetPreloaderComponent) == 0x000008, "Wrong alignment on UInGameAssetPreloaderComponent");
static_assert(sizeof(UInGameAssetPreloaderComponent) == 0x000260, "Wrong size on UInGameAssetPreloaderComponent");
static_assert(offsetof(UInGameAssetPreloaderComponent, _generalPrimaryAssetIds) == 0x0000D0, "Member 'UInGameAssetPreloaderComponent::_generalPrimaryAssetIds' has a wrong offset!");
static_assert(offsetof(UInGameAssetPreloaderComponent, _generalRegularAssets) == 0x000120, "Member 'UInGameAssetPreloaderComponent::_generalRegularAssets' has a wrong offset!");
static_assert(offsetof(UInGameAssetPreloaderComponent, _assetGathererClasses) == 0x000170, "Member 'UInGameAssetPreloaderComponent::_assetGathererClasses' has a wrong offset!");
static_assert(offsetof(UInGameAssetPreloaderComponent, _assetGatherers) == 0x000180, "Member 'UInGameAssetPreloaderComponent::_assetGatherers' has a wrong offset!");

// Class DeadByDaylight.InGameAssetPreloaderGatherer
// 0x0000 (0x0030 - 0x0030)
class UInGameAssetPreloaderGatherer : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InGameAssetPreloaderGatherer">();
	}
	static class UInGameAssetPreloaderGatherer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInGameAssetPreloaderGatherer>();
	}
};
static_assert(alignof(UInGameAssetPreloaderGatherer) == 0x000008, "Wrong alignment on UInGameAssetPreloaderGatherer");
static_assert(sizeof(UInGameAssetPreloaderGatherer) == 0x000030, "Wrong size on UInGameAssetPreloaderGatherer");

// Class DeadByDaylight.InGameLoadoutAssetGatherer
// 0x0000 (0x0030 - 0x0030)
class UInGameLoadoutAssetGatherer final : public UInGameAssetPreloaderGatherer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InGameLoadoutAssetGatherer">();
	}
	static class UInGameLoadoutAssetGatherer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInGameLoadoutAssetGatherer>();
	}
};
static_assert(alignof(UInGameLoadoutAssetGatherer) == 0x000008, "Wrong alignment on UInGameLoadoutAssetGatherer");
static_assert(sizeof(UInGameLoadoutAssetGatherer) == 0x000030, "Wrong size on UInGameLoadoutAssetGatherer");

// Class DeadByDaylight.VisualFXOverrideInterface
// 0x0000 (0x0000 - 0x0000)
class IVisualFXOverrideInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VisualFXOverrideInterface">();
	}
	static class IVisualFXOverrideInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IVisualFXOverrideInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IVisualFXOverrideInterface) == 0x000001, "Wrong alignment on IVisualFXOverrideInterface");
static_assert(sizeof(IVisualFXOverrideInterface) == 0x000001, "Wrong size on IVisualFXOverrideInterface");

// Class DeadByDaylight.InteractableTransformOptimizer
// 0x0008 (0x00C0 - 0x00B8)
class UInteractableTransformOptimizer final : public UActorComponent
{
public:
	bool                                          _optimizeTransformUpdate;                          // 0x00B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractableTransformOptimizer">();
	}
	static class UInteractableTransformOptimizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractableTransformOptimizer>();
	}
};
static_assert(alignof(UInteractableTransformOptimizer) == 0x000008, "Wrong alignment on UInteractableTransformOptimizer");
static_assert(sizeof(UInteractableTransformOptimizer) == 0x0000C0, "Wrong size on UInteractableTransformOptimizer");
static_assert(offsetof(UInteractableTransformOptimizer, _optimizeTransformUpdate) == 0x0000B8, "Member 'UInteractableTransformOptimizer::_optimizeTransformUpdate' has a wrong offset!");

// Class DeadByDaylight.WalesCypherParameters
// 0x0018 (0x0050 - 0x0038)
class UWalesCypherParameters final : public UDataAsset
{
public:
	class FString                                 AUDIO_EVENT;                                       // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SLASHER_INDEX;                                     // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CAMPER_INDEX;                                      // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WalesCypherParameters">();
	}
	static class UWalesCypherParameters* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWalesCypherParameters>();
	}
};
static_assert(alignof(UWalesCypherParameters) == 0x000008, "Wrong alignment on UWalesCypherParameters");
static_assert(sizeof(UWalesCypherParameters) == 0x000050, "Wrong size on UWalesCypherParameters");
static_assert(offsetof(UWalesCypherParameters, AUDIO_EVENT) == 0x000038, "Member 'UWalesCypherParameters::AUDIO_EVENT' has a wrong offset!");
static_assert(offsetof(UWalesCypherParameters, SLASHER_INDEX) == 0x000048, "Member 'UWalesCypherParameters::SLASHER_INDEX' has a wrong offset!");
static_assert(offsetof(UWalesCypherParameters, CAMPER_INDEX) == 0x00004C, "Member 'UWalesCypherParameters::CAMPER_INDEX' has a wrong offset!");

// Class DeadByDaylight.InteractionProficiency
// 0x0018 (0x0048 - 0x0030)
class UInteractionProficiency : public UObject
{
public:
	TArray<class FString>                         InteractionIds;                                    // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetIsActive(const class UChargeableInteractionDefinition* chargeableInteraction, const class ADBDPlayer* Player) const;
	int32 GetLevel(const class UChargeableInteractionDefinition* chargeableInteraction, const class ADBDPlayer* Player) const;
	EStatusEffectType GetType(const float Value) const;
	float GetValue(const class UChargeableInteractionDefinition* chargeableInteraction, const class ADBDPlayer* Player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionProficiency">();
	}
	static class UInteractionProficiency* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionProficiency>();
	}
};
static_assert(alignof(UInteractionProficiency) == 0x000008, "Wrong alignment on UInteractionProficiency");
static_assert(sizeof(UInteractionProficiency) == 0x000048, "Wrong size on UInteractionProficiency");
static_assert(offsetof(UInteractionProficiency, InteractionIds) == 0x000030, "Member 'UInteractionProficiency::InteractionIds' has a wrong offset!");

// Class DeadByDaylight.Interactor
// 0x0080 (0x0350 - 0x02D0)
class UInteractor final : public USceneComponent
{
public:
	class FString                                 InteractorName;                                    // 0x02D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E0[0x30];                                     // 0x02E0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool IsUsable)> OnIsUsableChanged;                                 // 0x0310(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          IsUsable;                                          // 0x0320(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_321[0x3];                                      // 0x0321(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FObjectLock                            _lock;                                             // 0x0324(0x0008)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	struct FObjectLock                            _reservation;                                      // 0x032C(0x0008)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_334[0x4];                                      // 0x0334(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionDefinition*                 _currentInteraction;                               // 0x0338(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UInteractionDefinition*>         _interactionDefinitions;                           // 0x0340(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void BPPostInitializeComponents();
	void Multicast_LockStatus(class ADBDPlayer* Player, class UInteractionDefinition* currentInteraction, bool lock);
	void Multicast_ReservationStatus(class ADBDPlayer* Player, bool lock);
	void OnRep_IsUsable();
	void SetIsUsable(bool isUsableParam);

	class ADBDPlayer* Authority_GetInteractingPlayer() const;
	bool CanPerformInteraction(const class ADBDPlayer* Player, const class UInteractionDefinition* definition) const;
	class UInteractionDefinition* GetCurrentInteraction() const;
	class AInteractable* GetInteractable() const;
	class ADBDPlayer* GetInteractingPlayerRaw() const;
	const TArray<class UInteractionDefinition*> GetInteractionDefinitions() const;
	bool GetIsUsable() const;
	bool IsInteracting() const;
	bool IsInterruptionPossible(const class ADBDPlayer* interruptor, const class ADBDPlayer* interruptee, const class UInteractionDefinition* definition, const class UInterruptionDefinition* interruption) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Interactor">();
	}
	static class UInteractor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractor>();
	}
};
static_assert(alignof(UInteractor) == 0x000010, "Wrong alignment on UInteractor");
static_assert(sizeof(UInteractor) == 0x000350, "Wrong size on UInteractor");
static_assert(offsetof(UInteractor, InteractorName) == 0x0002D0, "Member 'UInteractor::InteractorName' has a wrong offset!");
static_assert(offsetof(UInteractor, OnIsUsableChanged) == 0x000310, "Member 'UInteractor::OnIsUsableChanged' has a wrong offset!");
static_assert(offsetof(UInteractor, IsUsable) == 0x000320, "Member 'UInteractor::IsUsable' has a wrong offset!");
static_assert(offsetof(UInteractor, _lock) == 0x000324, "Member 'UInteractor::_lock' has a wrong offset!");
static_assert(offsetof(UInteractor, _reservation) == 0x00032C, "Member 'UInteractor::_reservation' has a wrong offset!");
static_assert(offsetof(UInteractor, _currentInteraction) == 0x000338, "Member 'UInteractor::_currentInteraction' has a wrong offset!");
static_assert(offsetof(UInteractor, _interactionDefinitions) == 0x000340, "Member 'UInteractor::_interactionDefinitions' has a wrong offset!");

// Class DeadByDaylight.InterruptionDefinition
// 0x0110 (0x03E0 - 0x02D0)
class UInterruptionDefinition final : public USceneComponent
{
public:
	class FName                                   InterruptionID;                                    // 0x02D0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _usesWorldCoordinates;                             // 0x02DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _snapInterruptor;                                  // 0x02DD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DE[0x2];                                      // 0x02DE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             _interruptionSnapPointForInterruptor;              // 0x02E0(0x0060)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _animationMontageToPlayOnInterruptionEnterForInterruptor; // 0x0340(0x0020)(Edit, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _animationMontageToPlayOnInterruptionForInterruptorNew; // 0x0360(0x0020)(Edit, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _animationMontageToPlayOnInterruptionForInterrupteeNew; // 0x0380(0x0020)(Edit, NativeAccessSpecifierPrivate)
	bool                                          _pickUpOnInterrupt;                                // 0x03A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _canInterruptWhileCarrying;                        // 0x03A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _useMontageFollower;                               // 0x03A2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A3[0x1];                                      // 0x03A3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _maxHeightDeltaBetweenCharacters;                  // 0x03A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _interruptionScoreEvent;                           // 0x03A8(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSpecialEventScoreHandler              _specialEventScoreHandler;                         // 0x03B4(0x0028)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3DC[0x4];                                      // 0x03DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInterruptionEnterStart(class ADBDPlayer* interruptor, class ADBDPlayer* interruptee);
	void OnInterruptionExitEnd(class ADBDPlayer* interruptor, class ADBDPlayer* interruptee);
	void OnInterruptionUpdateStart(class ADBDPlayer* interruptor, class ADBDPlayer* interruptee);
	void SetInterruptorSnapPoint(const struct FTransform& Point);

	bool CanInterruptWhileCarrying() const;
	class AInteractable* GetInteractable() const;
	class UInteractionDefinition* GetInteractionDefinition() const;
	struct FVector GetInterruptionSnapPointPositionForInterruptor(const class ADBDPlayer* interruptor, const class ADBDPlayer* interruptee) const;
	struct FRotator GetInterruptionSnapPointRotationForInterruptor(const class ADBDPlayer* interruptor, const class ADBDPlayer* interruptee) const;
	bool InteractionCheckHeightDelta(const class ADBDPlayer* interruptor, const class ADBDPlayer* interruptee) const;
	bool IsInterruptionPossible(const class ADBDPlayer* interruptor, const class ADBDPlayer* interruptee) const;
	bool IsUsingAttack() const;
	bool IsUsingMontageFollower() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterruptionDefinition">();
	}
	static class UInterruptionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterruptionDefinition>();
	}
};
static_assert(alignof(UInterruptionDefinition) == 0x000010, "Wrong alignment on UInterruptionDefinition");
static_assert(sizeof(UInterruptionDefinition) == 0x0003E0, "Wrong size on UInterruptionDefinition");
static_assert(offsetof(UInterruptionDefinition, InterruptionID) == 0x0002D0, "Member 'UInterruptionDefinition::InterruptionID' has a wrong offset!");
static_assert(offsetof(UInterruptionDefinition, _usesWorldCoordinates) == 0x0002DC, "Member 'UInterruptionDefinition::_usesWorldCoordinates' has a wrong offset!");
static_assert(offsetof(UInterruptionDefinition, _snapInterruptor) == 0x0002DD, "Member 'UInterruptionDefinition::_snapInterruptor' has a wrong offset!");
static_assert(offsetof(UInterruptionDefinition, _interruptionSnapPointForInterruptor) == 0x0002E0, "Member 'UInterruptionDefinition::_interruptionSnapPointForInterruptor' has a wrong offset!");
static_assert(offsetof(UInterruptionDefinition, _animationMontageToPlayOnInterruptionEnterForInterruptor) == 0x000340, "Member 'UInterruptionDefinition::_animationMontageToPlayOnInterruptionEnterForInterruptor' has a wrong offset!");
static_assert(offsetof(UInterruptionDefinition, _animationMontageToPlayOnInterruptionForInterruptorNew) == 0x000360, "Member 'UInterruptionDefinition::_animationMontageToPlayOnInterruptionForInterruptorNew' has a wrong offset!");
static_assert(offsetof(UInterruptionDefinition, _animationMontageToPlayOnInterruptionForInterrupteeNew) == 0x000380, "Member 'UInterruptionDefinition::_animationMontageToPlayOnInterruptionForInterrupteeNew' has a wrong offset!");
static_assert(offsetof(UInterruptionDefinition, _pickUpOnInterrupt) == 0x0003A0, "Member 'UInterruptionDefinition::_pickUpOnInterrupt' has a wrong offset!");
static_assert(offsetof(UInterruptionDefinition, _canInterruptWhileCarrying) == 0x0003A1, "Member 'UInterruptionDefinition::_canInterruptWhileCarrying' has a wrong offset!");
static_assert(offsetof(UInterruptionDefinition, _useMontageFollower) == 0x0003A2, "Member 'UInterruptionDefinition::_useMontageFollower' has a wrong offset!");
static_assert(offsetof(UInterruptionDefinition, _maxHeightDeltaBetweenCharacters) == 0x0003A4, "Member 'UInterruptionDefinition::_maxHeightDeltaBetweenCharacters' has a wrong offset!");
static_assert(offsetof(UInterruptionDefinition, _interruptionScoreEvent) == 0x0003A8, "Member 'UInterruptionDefinition::_interruptionScoreEvent' has a wrong offset!");
static_assert(offsetof(UInterruptionDefinition, _specialEventScoreHandler) == 0x0003B4, "Member 'UInterruptionDefinition::_specialEventScoreHandler' has a wrong offset!");

// Class DeadByDaylight.InventoryHandler
// 0x0060 (0x0098 - 0x0038)
class UInventoryHandler final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x60];                                      // 0x0038(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryHandler">();
	}
	static class UInventoryHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryHandler>();
	}
};
static_assert(alignof(UInventoryHandler) == 0x000008, "Wrong alignment on UInventoryHandler");
static_assert(sizeof(UInventoryHandler) == 0x000098, "Wrong size on UInventoryHandler");

// Class DeadByDaylight.WeightedElement
// 0x0000 (0x0000 - 0x0000)
class IWeightedElement final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeightedElement">();
	}
	static class IWeightedElement* GetDefaultObj()
	{
		return GetDefaultObjImpl<IWeightedElement>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IWeightedElement) == 0x000001, "Wrong alignment on IWeightedElement");
static_assert(sizeof(IWeightedElement) == 0x000001, "Wrong size on IWeightedElement");

// Class DeadByDaylight.PalletPulldownBlockable
// 0x0000 (0x0000 - 0x0000)
class IPalletPulldownBlockable final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalletPulldownBlockable">();
	}
	static class IPalletPulldownBlockable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalletPulldownBlockable>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPalletPulldownBlockable) == 0x000001, "Wrong alignment on IPalletPulldownBlockable");
static_assert(sizeof(IPalletPulldownBlockable) == 0x000001, "Wrong size on IPalletPulldownBlockable");

// Class DeadByDaylight.PresentablePower
// 0x0000 (0x0000 - 0x0000)
class IPresentablePower final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PresentablePower">();
	}
	static class IPresentablePower* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPresentablePower>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPresentablePower) == 0x000001, "Wrong alignment on IPresentablePower");
static_assert(sizeof(IPresentablePower) == 0x000001, "Wrong size on IPresentablePower");

// Class DeadByDaylight.IsMaximumInfected
// 0x0000 (0x00D0 - 0x00D0)
class UIsMaximumInfected final : public UGameplayModifierCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsMaximumInfected">();
	}
	static class UIsMaximumInfected* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsMaximumInfected>();
	}
};
static_assert(alignof(UIsMaximumInfected) == 0x000008, "Wrong alignment on UIsMaximumInfected");
static_assert(sizeof(UIsMaximumInfected) == 0x0000D0, "Wrong size on UIsMaximumInfected");

// Class DeadByDaylight.IsNotSightedByAnyCharacter
// 0x0008 (0x00F8 - 0x00F0)
class UIsNotSightedByAnyCharacter : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_F0[0x8];                                       // 0x00F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsNotSightedByAnyCharacter">();
	}
	static class UIsNotSightedByAnyCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsNotSightedByAnyCharacter>();
	}
};
static_assert(alignof(UIsNotSightedByAnyCharacter) == 0x000008, "Wrong alignment on UIsNotSightedByAnyCharacter");
static_assert(sizeof(UIsNotSightedByAnyCharacter) == 0x0000F8, "Wrong size on UIsNotSightedByAnyCharacter");

// Class DeadByDaylight.PresenterUtilities
// 0x0000 (0x0030 - 0x0030)
class UPresenterUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PresenterUtilities">();
	}
	static class UPresenterUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPresenterUtilities>();
	}
};
static_assert(alignof(UPresenterUtilities) == 0x000008, "Wrong alignment on UPresenterUtilities");
static_assert(sizeof(UPresenterUtilities) == 0x000030, "Wrong size on UPresenterUtilities");

// Class DeadByDaylight.TileVisitedAnalyticsComponent
// 0x0050 (0x0108 - 0x00B8)
class UTileVisitedAnalyticsComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x50];                                      // 0x00B8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TileVisitedAnalyticsComponent">();
	}
	static class UTileVisitedAnalyticsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTileVisitedAnalyticsComponent>();
	}
};
static_assert(alignof(UTileVisitedAnalyticsComponent) == 0x000008, "Wrong alignment on UTileVisitedAnalyticsComponent");
static_assert(sizeof(UTileVisitedAnalyticsComponent) == 0x000108, "Wrong size on UTileVisitedAnalyticsComponent");

// Class DeadByDaylight.IsNotSightedByAnySurvivor
// 0x0000 (0x00F8 - 0x00F8)
class UIsNotSightedByAnySurvivor final : public UIsNotSightedByAnyCharacter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsNotSightedByAnySurvivor">();
	}
	static class UIsNotSightedByAnySurvivor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsNotSightedByAnySurvivor>();
	}
};
static_assert(alignof(UIsNotSightedByAnySurvivor) == 0x000008, "Wrong alignment on UIsNotSightedByAnySurvivor");
static_assert(sizeof(UIsNotSightedByAnySurvivor) == 0x0000F8, "Wrong size on UIsNotSightedByAnySurvivor");

// Class DeadByDaylight.SpectatingActorLinker
// 0x0000 (0x0000 - 0x0000)
class ISpectatingActorLinker final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpectatingActorLinker">();
	}
	static class ISpectatingActorLinker* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISpectatingActorLinker>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ISpectatingActorLinker) == 0x000001, "Wrong alignment on ISpectatingActorLinker");
static_assert(sizeof(ISpectatingActorLinker) == 0x000001, "Wrong size on ISpectatingActorLinker");

// Class DeadByDaylight.StruggleSkillCheck
// 0x0000 (0x0000 - 0x0000)
class IStruggleSkillCheck final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StruggleSkillCheck">();
	}
	static class IStruggleSkillCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStruggleSkillCheck>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IStruggleSkillCheck) == 0x000001, "Wrong alignment on IStruggleSkillCheck");
static_assert(sizeof(IStruggleSkillCheck) == 0x000001, "Wrong size on IStruggleSkillCheck");

// Class DeadByDaylight.TeleportInteractable
// 0x0000 (0x0000 - 0x0000)
class ITeleportInteractable final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeleportInteractable">();
	}
	static class ITeleportInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITeleportInteractable>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITeleportInteractable) == 0x000001, "Wrong alignment on ITeleportInteractable");
static_assert(sizeof(ITeleportInteractable) == 0x000001, "Wrong size on ITeleportInteractable");

// Class DeadByDaylight.ProceduralLevelBuilder
// 0x0E18 (0x10B8 - 0x02A0)
class AProceduralLevelBuilder : public AActor
{
public:
	uint8                                         Pad_2A0[0x40];                                     // 0x02A0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PathToMapDirectory;                                // 0x02E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PathToTilesDirectory;                              // 0x02F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PathToEventSpawnablesDirectory;                    // 0x0300(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         EventSpawnablesParentDirectories;                  // 0x0310(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         EventSpawnablePositionWeightCoefficient;           // 0x0320(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EventSpawnablePositionWeightPowerBase;             // 0x0324(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EGameplayElementType, float>             StaticActorSpawnerDecorationBudgets;               // 0x0328(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<ETileSpawnPointType, float>              StaticSpawnPointDecorationBudgets;                 // 0x0378(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         KillerMinProximityFromCamper;                      // 0x03C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurvivorMinProximityFromOtherCamper;               // 0x03CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinProximityBetweenGenerators;                     // 0x03D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExtraGeneratorCount;                               // 0x03D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinProximityBetweenChests;                         // 0x03D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinProximityBetweenTotems;                         // 0x03DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinProximityBetweenHatches;                        // 0x03E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurvivorMinProximityFromGenerator;                 // 0x03E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurvivorMinProximityFromTotem;                     // 0x03E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurvivorMaxLineOfSightFromTotem;                   // 0x03EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinProximityBetweenSpecialBehaviourItems;          // 0x03F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpecialBehaviourItemMinProximityFromSurvivor;      // 0x03F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpecialBehaviourItemMinProximityFromKiller;        // 0x03F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3FC[0x4];                                      // 0x03FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UPaperTileMap>              DebugMap;                                          // 0x0400(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ATile>>              DebugTiles;                                        // 0x0408(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         SmallMeatLockerMinProximityFromKillerLair;         // 0x0418(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FactorToAdjustToWhenOutOfProximity;                // 0x041C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FactorToAdjustToWhenInLineOfSight;                 // 0x0420(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightAmplifier;                                   // 0x0424(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightAmplifierActivationHeight;                   // 0x0428(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42C[0x4];                                      // 0x042C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UProceduralGenerationData*              ProceduralGenerationData;                          // 0x0430(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              AmbiancePriorities;                                // 0x0438(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataAsset>              PerMapLightData;                                   // 0x0470(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TileWeightRateOfDecay;                             // 0x04A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuadTileWeightRateOfDecay;                         // 0x04AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B0[0x18];                                     // 0x04B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 _tileClass;                                        // 0x04C8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D0[0x1F0];                                    // 0x04D0(0x01F0)(Fixing Size After Last Property [ Dumper-7 ])
	class UMapData*                               _mapData;                                          // 0x06C0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ATile*>                          _outOfWorldTiles;                                  // 0x06C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UAkAudioBank*                           _ambientAudioBank;                                 // 0x06D8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UObjectLibrary*                         _availableTilesLibrary;                            // 0x06E0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UObjectLibrary*                         _availableEventSpawnablesLibrary;                  // 0x06E8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6F0[0xE8];                                     // 0x06F0(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	class UObjectLibrary*                         _availableDerivedTileLibrary;                      // 0x07D8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7E0[0x38];                                     // 0x07E0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGeneratedLevelData                    _generatedData;                                    // 0x0818(0x0330)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UTileMatrix*                            _tileMatrix;                                       // 0x0B48(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTileBank*                              _tileBank;                                         // 0x0B50(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B58[0x68];                                     // 0x0B58(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UActorSpawner*                          _killerLairSpawner;                                // 0x0BC0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BC8[0x8];                                      // 0x0BC8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSoftObjectPath>                _preloadAssetReferences;                           // 0x0BD0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class AActor>>             _chestItemAssetReferences;                         // 0x0BE0(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UClass*>                         _killerPawns;                                      // 0x0BF0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C00[0x20];                                     // 0x0C00(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ATile*>                          _tilesThatHaveBeenSpawned;                         // 0x0C20(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C30[0x18];                                     // 0x0C30(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         _eventSpawnablesThatHaveBeenStreamed;              // 0x0C48(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C58[0x18];                                     // 0x0C58(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AProceduralLevelData*                   _debugProceduralDatas;                             // 0x0C70(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDClientSyncer*                       _syncer;                                           // 0x0C78(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlackboardComponent*                   _blackboardComp;                                   // 0x0C80(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C88[0x50];                                     // 0x0C88(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UEdgeObjectHandlingStrategy*            _edgeObjectHandlingStrategy;                       // 0x0CD8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CE0[0x300];                                    // 0x0CE0(0x0300)(Fixing Size After Last Property [ Dumper-7 ])
	class ATile*                                  _backupKillerLairTile;                             // 0x0FE0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FE8[0x78];                                     // 0x0FE8(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AActor*, struct FSpawnInfo>        _spawnedActorAttachmentInfo;                       // 0x1060(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10B0[0x8];                                     // 0x10B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyMist(float Modifier);
	void BuildFromSeed();
	void Multicast_DebugShareGenerationData(const struct FGenerationParams& usedParams);
	void RemoveMist();
	class AActor* SpawnActor(class UClass* ActorClass, ETileSpawnPointType spawnPointType);
	void StartGenerationOnSyncerReady();
	void SyncSeeds();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralLevelBuilder">();
	}
	static class AProceduralLevelBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProceduralLevelBuilder>();
	}
};
static_assert(alignof(AProceduralLevelBuilder) == 0x000008, "Wrong alignment on AProceduralLevelBuilder");
static_assert(sizeof(AProceduralLevelBuilder) == 0x0010B8, "Wrong size on AProceduralLevelBuilder");
static_assert(offsetof(AProceduralLevelBuilder, PathToMapDirectory) == 0x0002E0, "Member 'AProceduralLevelBuilder::PathToMapDirectory' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, PathToTilesDirectory) == 0x0002F0, "Member 'AProceduralLevelBuilder::PathToTilesDirectory' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, PathToEventSpawnablesDirectory) == 0x000300, "Member 'AProceduralLevelBuilder::PathToEventSpawnablesDirectory' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, EventSpawnablesParentDirectories) == 0x000310, "Member 'AProceduralLevelBuilder::EventSpawnablesParentDirectories' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, EventSpawnablePositionWeightCoefficient) == 0x000320, "Member 'AProceduralLevelBuilder::EventSpawnablePositionWeightCoefficient' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, EventSpawnablePositionWeightPowerBase) == 0x000324, "Member 'AProceduralLevelBuilder::EventSpawnablePositionWeightPowerBase' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, StaticActorSpawnerDecorationBudgets) == 0x000328, "Member 'AProceduralLevelBuilder::StaticActorSpawnerDecorationBudgets' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, StaticSpawnPointDecorationBudgets) == 0x000378, "Member 'AProceduralLevelBuilder::StaticSpawnPointDecorationBudgets' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, KillerMinProximityFromCamper) == 0x0003C8, "Member 'AProceduralLevelBuilder::KillerMinProximityFromCamper' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, SurvivorMinProximityFromOtherCamper) == 0x0003CC, "Member 'AProceduralLevelBuilder::SurvivorMinProximityFromOtherCamper' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, MinProximityBetweenGenerators) == 0x0003D0, "Member 'AProceduralLevelBuilder::MinProximityBetweenGenerators' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, ExtraGeneratorCount) == 0x0003D4, "Member 'AProceduralLevelBuilder::ExtraGeneratorCount' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, MinProximityBetweenChests) == 0x0003D8, "Member 'AProceduralLevelBuilder::MinProximityBetweenChests' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, MinProximityBetweenTotems) == 0x0003DC, "Member 'AProceduralLevelBuilder::MinProximityBetweenTotems' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, MinProximityBetweenHatches) == 0x0003E0, "Member 'AProceduralLevelBuilder::MinProximityBetweenHatches' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, SurvivorMinProximityFromGenerator) == 0x0003E4, "Member 'AProceduralLevelBuilder::SurvivorMinProximityFromGenerator' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, SurvivorMinProximityFromTotem) == 0x0003E8, "Member 'AProceduralLevelBuilder::SurvivorMinProximityFromTotem' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, SurvivorMaxLineOfSightFromTotem) == 0x0003EC, "Member 'AProceduralLevelBuilder::SurvivorMaxLineOfSightFromTotem' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, MinProximityBetweenSpecialBehaviourItems) == 0x0003F0, "Member 'AProceduralLevelBuilder::MinProximityBetweenSpecialBehaviourItems' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, SpecialBehaviourItemMinProximityFromSurvivor) == 0x0003F4, "Member 'AProceduralLevelBuilder::SpecialBehaviourItemMinProximityFromSurvivor' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, SpecialBehaviourItemMinProximityFromKiller) == 0x0003F8, "Member 'AProceduralLevelBuilder::SpecialBehaviourItemMinProximityFromKiller' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, DebugMap) == 0x000400, "Member 'AProceduralLevelBuilder::DebugMap' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, DebugTiles) == 0x000408, "Member 'AProceduralLevelBuilder::DebugTiles' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, SmallMeatLockerMinProximityFromKillerLair) == 0x000418, "Member 'AProceduralLevelBuilder::SmallMeatLockerMinProximityFromKillerLair' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, FactorToAdjustToWhenOutOfProximity) == 0x00041C, "Member 'AProceduralLevelBuilder::FactorToAdjustToWhenOutOfProximity' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, FactorToAdjustToWhenInLineOfSight) == 0x000420, "Member 'AProceduralLevelBuilder::FactorToAdjustToWhenInLineOfSight' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, HeightAmplifier) == 0x000424, "Member 'AProceduralLevelBuilder::HeightAmplifier' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, HeightAmplifierActivationHeight) == 0x000428, "Member 'AProceduralLevelBuilder::HeightAmplifierActivationHeight' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, ProceduralGenerationData) == 0x000430, "Member 'AProceduralLevelBuilder::ProceduralGenerationData' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, AmbiancePriorities) == 0x000438, "Member 'AProceduralLevelBuilder::AmbiancePriorities' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, PerMapLightData) == 0x000470, "Member 'AProceduralLevelBuilder::PerMapLightData' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, TileWeightRateOfDecay) == 0x0004A8, "Member 'AProceduralLevelBuilder::TileWeightRateOfDecay' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, QuadTileWeightRateOfDecay) == 0x0004AC, "Member 'AProceduralLevelBuilder::QuadTileWeightRateOfDecay' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _tileClass) == 0x0004C8, "Member 'AProceduralLevelBuilder::_tileClass' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _mapData) == 0x0006C0, "Member 'AProceduralLevelBuilder::_mapData' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _outOfWorldTiles) == 0x0006C8, "Member 'AProceduralLevelBuilder::_outOfWorldTiles' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _ambientAudioBank) == 0x0006D8, "Member 'AProceduralLevelBuilder::_ambientAudioBank' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _availableTilesLibrary) == 0x0006E0, "Member 'AProceduralLevelBuilder::_availableTilesLibrary' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _availableEventSpawnablesLibrary) == 0x0006E8, "Member 'AProceduralLevelBuilder::_availableEventSpawnablesLibrary' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _availableDerivedTileLibrary) == 0x0007D8, "Member 'AProceduralLevelBuilder::_availableDerivedTileLibrary' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _generatedData) == 0x000818, "Member 'AProceduralLevelBuilder::_generatedData' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _tileMatrix) == 0x000B48, "Member 'AProceduralLevelBuilder::_tileMatrix' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _tileBank) == 0x000B50, "Member 'AProceduralLevelBuilder::_tileBank' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _killerLairSpawner) == 0x000BC0, "Member 'AProceduralLevelBuilder::_killerLairSpawner' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _preloadAssetReferences) == 0x000BD0, "Member 'AProceduralLevelBuilder::_preloadAssetReferences' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _chestItemAssetReferences) == 0x000BE0, "Member 'AProceduralLevelBuilder::_chestItemAssetReferences' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _killerPawns) == 0x000BF0, "Member 'AProceduralLevelBuilder::_killerPawns' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _tilesThatHaveBeenSpawned) == 0x000C20, "Member 'AProceduralLevelBuilder::_tilesThatHaveBeenSpawned' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _eventSpawnablesThatHaveBeenStreamed) == 0x000C48, "Member 'AProceduralLevelBuilder::_eventSpawnablesThatHaveBeenStreamed' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _debugProceduralDatas) == 0x000C70, "Member 'AProceduralLevelBuilder::_debugProceduralDatas' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _syncer) == 0x000C78, "Member 'AProceduralLevelBuilder::_syncer' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _blackboardComp) == 0x000C80, "Member 'AProceduralLevelBuilder::_blackboardComp' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _edgeObjectHandlingStrategy) == 0x000CD8, "Member 'AProceduralLevelBuilder::_edgeObjectHandlingStrategy' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _backupKillerLairTile) == 0x000FE0, "Member 'AProceduralLevelBuilder::_backupKillerLairTile' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _spawnedActorAttachmentInfo) == 0x001060, "Member 'AProceduralLevelBuilder::_spawnedActorAttachmentInfo' has a wrong offset!");

// Class DeadByDaylight.DBDTimeTravelManager
// 0x0070 (0x00A0 - 0x0030)
class UDBDTimeTravelManager final : public UObject
{
public:
	uint8                                         Pad_30[0x70];                                      // 0x0030(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDTimeTravelManager">();
	}
	static class UDBDTimeTravelManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDTimeTravelManager>();
	}
};
static_assert(alignof(UDBDTimeTravelManager) == 0x000008, "Wrong alignment on UDBDTimeTravelManager");
static_assert(sizeof(UDBDTimeTravelManager) == 0x0000A0, "Wrong size on UDBDTimeTravelManager");

// Class DeadByDaylight.ItemAddonDataAsset
// 0x0000 (0x0090 - 0x0090)
class UItemAddonDataAsset final : public UGameplayModifierContainerDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAddonDataAsset">();
	}
	static class UItemAddonDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAddonDataAsset>();
	}
};
static_assert(alignof(UItemAddonDataAsset) == 0x000008, "Wrong alignment on UItemAddonDataAsset");
static_assert(sizeof(UItemAddonDataAsset) == 0x000090, "Wrong size on UItemAddonDataAsset");

// Class DeadByDaylight.ItemDataAsset
// 0x0048 (0x0090 - 0x0048)
class UItemDataAsset final : public UDBDPrimaryDataAsset
{
public:
	TSoftClassPtr<class UClass>                   ActorClass;                                        // 0x0048(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UGameplayModifierContainerDataAsset>> RequiredModifierContainers;    // 0x0080(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemDataAsset">();
	}
	static class UItemDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemDataAsset>();
	}
};
static_assert(alignof(UItemDataAsset) == 0x000008, "Wrong alignment on UItemDataAsset");
static_assert(sizeof(UItemDataAsset) == 0x000090, "Wrong size on UItemDataAsset");
static_assert(offsetof(UItemDataAsset, ActorClass) == 0x000048, "Member 'UItemDataAsset::ActorClass' has a wrong offset!");
static_assert(offsetof(UItemDataAsset, RequiredModifierContainers) == 0x000080, "Member 'UItemDataAsset::RequiredModifierContainers' has a wrong offset!");

// Class DeadByDaylight.ItemPickupAdditionalDataInterface
// 0x0000 (0x0000 - 0x0000)
class IItemPickupAdditionalDataInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemPickupAdditionalDataInterface">();
	}
	static class IItemPickupAdditionalDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IItemPickupAdditionalDataInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IItemPickupAdditionalDataInterface) == 0x000001, "Wrong alignment on IItemPickupAdditionalDataInterface");
static_assert(sizeof(IItemPickupAdditionalDataInterface) == 0x000001, "Wrong size on IItemPickupAdditionalDataInterface");

// Class DeadByDaylight.ProtectionHitComponent
// 0x0070 (0x0128 - 0x00B8)
class UProtectionHitComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x50];                                      // 0x00B8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ASurvivor*>                      _nearbyInjuredSurvivors;                           // 0x0108(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x10];                                     // 0x0118(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_HandleProtectionScoringEvents();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProtectionHitComponent">();
	}
	static class UProtectionHitComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProtectionHitComponent>();
	}
};
static_assert(alignof(UProtectionHitComponent) == 0x000008, "Wrong alignment on UProtectionHitComponent");
static_assert(sizeof(UProtectionHitComponent) == 0x000128, "Wrong size on UProtectionHitComponent");
static_assert(offsetof(UProtectionHitComponent, _nearbyInjuredSurvivors) == 0x000108, "Member 'UProtectionHitComponent::_nearbyInjuredSurvivors' has a wrong offset!");

// Class DeadByDaylight.TormentAttackDamageCooldownInterface
// 0x0000 (0x0000 - 0x0000)
class ITormentAttackDamageCooldownInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TormentAttackDamageCooldownInterface">();
	}
	static class ITormentAttackDamageCooldownInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITormentAttackDamageCooldownInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITormentAttackDamageCooldownInterface) == 0x000001, "Wrong alignment on ITormentAttackDamageCooldownInterface");
static_assert(sizeof(ITormentAttackDamageCooldownInterface) == 0x000001, "Wrong size on ITormentAttackDamageCooldownInterface");

// Class DeadByDaylight.ItemVfx
// 0x0010 (0x02B8 - 0x02A8)
class AItemVfx final : public ABaseVFX
{
public:
	TArray<class UFXSystemComponent*>             _particleSystems;                                  // 0x02A8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void AddNiagaraComponent(class UNiagaraComponent* NiagaraComponent);
	void AddParticleSystemComponent(class UParticleSystemComponent* ParticleSystemComponent);
	void AttachToSkeletalMesh(class USkeletalMeshComponent* SkeletonPart);
	void ClearParticleSystems();
	void OnAttackBegin();
	void OnAttackEnd();
	class UNiagaraComponent* SpawnNiagaraSystemAttached(class UNiagaraSystem* SystemTemplate, class USceneComponent* AttachToComponent, class FName attachPointName, EAttachLocation LocationType, bool AutoDestroy, ENCPoolMethod PoolingMethod, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, bool autoActivate, bool preCullCheck, bool absoluteRotation, bool hideInFPV);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemVfx">();
	}
	static class AItemVfx* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemVfx>();
	}
};
static_assert(alignof(AItemVfx) == 0x000008, "Wrong alignment on AItemVfx");
static_assert(sizeof(AItemVfx) == 0x0002B8, "Wrong size on AItemVfx");
static_assert(offsetof(AItemVfx, _particleSystems) == 0x0002A8, "Member 'AItemVfx::_particleSystems' has a wrong offset!");

// Class DeadByDaylight.ItemWillBeConsumedEffect
// 0x0000 (0x0398 - 0x0398)
class UItemWillBeConsumedEffect final : public UStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemWillBeConsumedEffect">();
	}
	static class UItemWillBeConsumedEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemWillBeConsumedEffect>();
	}
};
static_assert(alignof(UItemWillBeConsumedEffect) == 0x000008, "Wrong alignment on UItemWillBeConsumedEffect");
static_assert(sizeof(UItemWillBeConsumedEffect) == 0x000398, "Wrong size on UItemWillBeConsumedEffect");

// Class DeadByDaylight.ViewRotationStrategy
// 0x0000 (0x0000 - 0x0000)
class IViewRotationStrategy final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ViewRotationStrategy">();
	}
	static class IViewRotationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<IViewRotationStrategy>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IViewRotationStrategy) == 0x000001, "Wrong alignment on IViewRotationStrategy");
static_assert(sizeof(IViewRotationStrategy) == 0x000001, "Wrong size on IViewRotationStrategy");

// Class DeadByDaylight.TrapChemicalBomb
// 0x0018 (0x02B8 - 0x02A0)
class ATrapChemicalBomb final : public AActor
{
public:
	ETrapBombState                                _currentState;                                     // 0x02A0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _trapPlacer;                                       // 0x02A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APallet*                                _placedPallet;                                     // 0x02B0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_CurrentState();

	class APallet* GetPallet() const;
	ETrapBombState GetState() const;
	class ADBDPlayer* GetTrapPlacer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrapChemicalBomb">();
	}
	static class ATrapChemicalBomb* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATrapChemicalBomb>();
	}
};
static_assert(alignof(ATrapChemicalBomb) == 0x000008, "Wrong alignment on ATrapChemicalBomb");
static_assert(sizeof(ATrapChemicalBomb) == 0x0002B8, "Wrong size on ATrapChemicalBomb");
static_assert(offsetof(ATrapChemicalBomb, _currentState) == 0x0002A0, "Member 'ATrapChemicalBomb::_currentState' has a wrong offset!");
static_assert(offsetof(ATrapChemicalBomb, _trapPlacer) == 0x0002A8, "Member 'ATrapChemicalBomb::_trapPlacer' has a wrong offset!");
static_assert(offsetof(ATrapChemicalBomb, _placedPallet) == 0x0002B0, "Member 'ATrapChemicalBomb::_placedPallet' has a wrong offset!");

// Class DeadByDaylight.Killer
// 0x0560 (0x1B10 - 0x15B0)
class AKiller : public ADBDPlayer
{
public:
	uint8                                         Pad_15B0[0x48];                                    // 0x15B0(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _setFirstPersonModeEnabledOnKillerIntroCompleted;  // 0x15F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15F9[0x27];                                    // 0x15F9(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PutDownTraceLocation;                              // 0x1620(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultSlasherPower;                               // 0x1638(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoudNoiseDisplayTime;                              // 0x1644(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetPriorityFactor;                              // 0x1648(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldDisplayAttackZones;                          // 0x1660(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1661[0x7];                                     // 0x1661(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ASurvivorExposerInstance>   CamperExposer;                                     // 0x1668(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EKillerAbilities>                      KillerAbilities;                                   // 0x1670(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UKillerSoundCuesComponent*              KillerSoundCuesComponent;                          // 0x1680(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowKillerPowerDebugInfo;                          // 0x1688(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1689[0x7];                                     // 0x1689(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool IsInStalkMode)> OnStalkModeChangedEvent;                      // 0x1690(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_16A0[0x18];                                    // 0x16A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UAkComponent>            _audioComponent;                                   // 0x16B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDNavModifierComponent*               _terrorNavModifierComponent;                       // 0x16C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UKillerBloodFXComponent*                _bloodFXComponent;                                 // 0x16C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _slasherLightIntensity;                            // 0x16D0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _defaultAmountToSquish;                            // 0x16D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16D8[0x8];                                     // 0x16D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ADBDPlayer*, struct FTargetFocusTimer> _stalkTimers;                                  // 0x16E0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FDBDTimer                              _recentlyCloakedTimer;                             // 0x1730(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FDBDTimer                              _flashlightBlindEvasionScoreTimer;                 // 0x1758(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FDBDTimer                              _flashlightBurnoutEvasionScoreTimer;               // 0x1780(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class ADBDPlayer*, struct FAnimationMontageDescriptor> _predictedCamperHitMontages;         // 0x17A8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	class FName                                   CameraSocketName;                                  // 0x17F8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1804[0xC];                                     // 0x1804(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class ULoudNoiseHUDIndicator*                 _loudNoiseIndicator;                               // 0x1810(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UKillerHitsWhileCarryingTrackerComponent* _hitsWhileCarryingTracker;                       // 0x1818(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _stealthIncreaseRate;                              // 0x1820(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _stealthDecreaseRate;                              // 0x1824(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1828[0x50];                                    // 0x1828(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTagStateBool                          _isInStalkMode;                                    // 0x1878(0x0048)(Net, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18C0[0x120];                                   // 0x18C0(0x0120)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isKilling;                                        // 0x19E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int8                                          _allowedKillCount;                                 // 0x19E1(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int8                                          _allowedKillAfterStrugglePhase;                    // 0x19E2(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_19E3[0x9];                                     // 0x19E3(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _cachedBloodlustTier;                              // 0x19EC(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_19F0[0x4];                                     // 0x19F0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        _killerPowerDebugFlags;                            // 0x19F4(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _presenceTag;                                      // 0x19F8(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A04[0x4];                                     // 0x1A04(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _persistantStateTags;                              // 0x1A08(0x0020)(Edit, NativeAccessSpecifierPrivate)
	bool                                          _enableKillerCrouchInput;                          // 0x1A28(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _canStartAttackWhileCrouched;                      // 0x1A29(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A2A[0x6];                                     // 0x1A2A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ASurvivor*                              _carriedSurvivor;                                  // 0x1A30(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMoriComponent*                         _moriComponent;                                    // 0x1A38(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFinisherMoriHandlerComponent*          _finisherMoriHandlerComponent;                     // 0x1A40(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHitValidatorComponent*                 _hitValidator;                                     // 0x1A48(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHitValidatorConfigurator*              _hitValidationConfigurator;                        // 0x1A50(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDAttackerComponent*                  _attackerComponent;                                // 0x1A58(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A60[0x14];                                    // 0x1A60(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	EAttackType                                   _basicAttackType;                                  // 0x1A74(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A75[0x3];                                     // 0x1A75(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UArmIKSensorComponent*                  _armIKSensorComponent;                             // 0x1A78(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ASurvivor*                              _survivorBeingKilled;                              // 0x1A80(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A88[0x8];                                     // 0x1A88(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UFirstPersonViewComponent>  _firstPersonViewComponentClass;                    // 0x1A90(0x0008)(Edit, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFirstPersonViewComponent*              _firstPersonViewComponent;                         // 0x1A98(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UKillerIntroComponent*                  _killerIntroComponent;                             // 0x1AA0(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UKillerBlindingFXComponent*             _blindingFXComponent;                              // 0x1AA8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1AB0[0x8];                                     // 0x1AB0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UKillerRedStainUpdateStrategy*          _redStainUpdateStrategy;                           // 0x1AB8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _squishFactorParameter;                            // 0x1AC0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1ACC[0x4];                                     // 0x1ACC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        _attackZonePivot;                                  // 0x1AD0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UKillerStunnableComponent*              _slasherStunnableComponent;                        // 0x1AD8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1AE0[0x30];                                    // 0x1AE0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_AllowKilling(int32 numKills);
	void Authority_RequestStun(EStunType stunType, class ADBDPlayer* requester, float stunQueueTime);
	void Authority_SetInStalkMode(bool stalkMode, bool Forced);
	void BroadcastOnInstantTeleport();
	bool CancelAttackByInput();
	void Client_RequestStun(EStunType stunType, class ADBDPlayer* stunner, float stunQueueTime);
	void Cosmetic_OnCancelCarry();
	void Cosmetic_OnDropCamperEnd();
	void Cosmetic_OnPickUpEnd();
	void DBD_AllowKilling();
	void DBD_DisplayAttackZones(bool Display);
	void DBD_MergeLockOnDamageZones(bool Enable);
	void DBD_SetAttackZones(EAttackZoneSet attackZoneSet);
	void DecrementInterruptBlock();
	void DisplayAttackZones(bool Display);
	class USceneComponent* GetAttackZonePivot();
	float GetCurrentRotationYaw();
	void IncrementInterruptBlock();
	bool IsCrouchAvailable_BP();
	bool IsIdling();
	bool Local_CancelAttack();
	void MergeLockOnDamageZones(bool Enable);
	void Multicast_Cheat_SetAttackDetectionZoneSet(EAttackZoneSet attackZoneSet);
	void Multicast_DisplayAttackZones(bool Display);
	void Multicast_MergeLockOnDamageZones(bool Enable);
	void OnAttackFinish(const EAttackType attackType);
	void OnAttackStart(const EAttackType attackType);
	void OnIsKillingSurvivorWithMoriUpdated(bool isKillingSurvivorWithMori);
	void OnKillerAbilityBeginActivate(EKillerAbilities killerAbility);
	void OnKillerAbilityBeginDeactivate(EKillerAbilities killerAbility, bool Forced);
	void OnKillerAbilityEndActivate(EKillerAbilities killerAbility);
	void OnKillerAbilityEndDeactivate(EKillerAbilities killerAbility, bool Forced);
	void OnLoudNoiseIndicatorDestroyed();
	void OnLoudNoiseTriggered(class AActor* originator, class AActor* instigatingActor, const struct FVector& Location, bool shouldTrack, float* audibleRange, bool isQuickAction, bool isDeceivingNoise);
	void OnPerformingChargableInteraction(float Progress);
	void OnStalkModeChangedCosmetic(bool stalkMode);
	void OnStealthChanged(bool stealth);
	void OnSurvivorHit(class ASurvivor* Survivor);
	void PlayBloodHitsEffects();
	void Server_SendActionKillerInput(bool Pressed);
	void Server_SendAttackInput(bool Pressed);
	void SetAttackDetectionZoneSet(EAttackZoneSet attackZoneSet);
	void SetAttackZonePivot(class USceneComponent* attackZonePivot);
	void SetCarriedSurvivor(class ASurvivor* Survivor);
	void SetIsCloaked(bool IsCloaked_0, bool Forced);
	void SetIsHookingSurvivor(const bool Value);
	void SetIsKilling(bool IsKilling);
	void SetLightIntensity(float Intensity);
	void SetStalkTierWalkSpeedMultiplier(float stalkTierWalkSpeedMultiplier);
	void SetSurvivorBeingKilled(class ASurvivor* Survivor);
	void SpawnSlasherPower();
	void UpdateRageTierEffect(int32 previousTier, int32 currentTier);

	bool CanAffectLocalPlayer() const;
	bool CanAttack(const EAttackType attackType) const;
	bool CanAttack_BP(const EAttackType attackType) const;
	bool CanGainRage() const;
	bool CanPerformKillerAbility(EKillerAbilities killerAbility) const;
	bool CanSlashAttack_BP() const;
	float GetAnimDirection() const;
	float GetBlindedPercent() const;
	class ASurvivor* GetCarriedSurvivor() const;
	TArray<class FName> GetCharacterCustomAnimTags() const;
	class UChaserCharacterComponent* GetChaserCharacterComponent() const;
	bool GetIsAttacking() const;
	EKillerCarryAnimWeight GetKillerCarryAnimWeight() const;
	class UKillerMovementComponent* GetKillerMovement() const;
	float GetLightIntensity() const;
	struct FRotator GetLookRotation() const;
	class ASurvivor* GetObsessionTarget() const;
	struct FVector GetPlayerDropOffPoint() const;
	struct FGameplayTag GetPresenceTag() const;
	int32 GetRageTier() const;
	float GetStalkTierWalkSpeedMultiplier() const;
	float GetStealthRatio() const;
	class ASurvivor* GetSurvivorBeingKilled() const;
	bool HasKillerAbility(EKillerAbilities killerAbility) const;
	bool HasPreLevelGenerationModifier(class FName modifierID) const;
	bool IsAllowedToKill(const class ASurvivor* Survivor) const;
	bool IsCarrying() const;
	bool IsCloaking() const;
	bool IsImmuneToObservingPlayerDetection(const class ADBDPlayer* observingPlayer) const;
	bool IsInterruptBlocked() const;
	bool IsKilling() const;
	bool IsStunned() const;
	bool IsUncloaking() const;
	bool ShouldApplyBloodlustSpeedModifier() const;
	bool WasRecentlyCloaked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Killer">();
	}
	static class AKiller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKiller>();
	}
};
static_assert(alignof(AKiller) == 0x000010, "Wrong alignment on AKiller");
static_assert(sizeof(AKiller) == 0x001B10, "Wrong size on AKiller");
static_assert(offsetof(AKiller, _setFirstPersonModeEnabledOnKillerIntroCompleted) == 0x0015F8, "Member 'AKiller::_setFirstPersonModeEnabledOnKillerIntroCompleted' has a wrong offset!");
static_assert(offsetof(AKiller, PutDownTraceLocation) == 0x001620, "Member 'AKiller::PutDownTraceLocation' has a wrong offset!");
static_assert(offsetof(AKiller, DefaultSlasherPower) == 0x001638, "Member 'AKiller::DefaultSlasherPower' has a wrong offset!");
static_assert(offsetof(AKiller, LoudNoiseDisplayTime) == 0x001644, "Member 'AKiller::LoudNoiseDisplayTime' has a wrong offset!");
static_assert(offsetof(AKiller, TargetPriorityFactor) == 0x001648, "Member 'AKiller::TargetPriorityFactor' has a wrong offset!");
static_assert(offsetof(AKiller, ShouldDisplayAttackZones) == 0x001660, "Member 'AKiller::ShouldDisplayAttackZones' has a wrong offset!");
static_assert(offsetof(AKiller, CamperExposer) == 0x001668, "Member 'AKiller::CamperExposer' has a wrong offset!");
static_assert(offsetof(AKiller, KillerAbilities) == 0x001670, "Member 'AKiller::KillerAbilities' has a wrong offset!");
static_assert(offsetof(AKiller, KillerSoundCuesComponent) == 0x001680, "Member 'AKiller::KillerSoundCuesComponent' has a wrong offset!");
static_assert(offsetof(AKiller, ShowKillerPowerDebugInfo) == 0x001688, "Member 'AKiller::ShowKillerPowerDebugInfo' has a wrong offset!");
static_assert(offsetof(AKiller, OnStalkModeChangedEvent) == 0x001690, "Member 'AKiller::OnStalkModeChangedEvent' has a wrong offset!");
static_assert(offsetof(AKiller, _audioComponent) == 0x0016B8, "Member 'AKiller::_audioComponent' has a wrong offset!");
static_assert(offsetof(AKiller, _terrorNavModifierComponent) == 0x0016C0, "Member 'AKiller::_terrorNavModifierComponent' has a wrong offset!");
static_assert(offsetof(AKiller, _bloodFXComponent) == 0x0016C8, "Member 'AKiller::_bloodFXComponent' has a wrong offset!");
static_assert(offsetof(AKiller, _slasherLightIntensity) == 0x0016D0, "Member 'AKiller::_slasherLightIntensity' has a wrong offset!");
static_assert(offsetof(AKiller, _defaultAmountToSquish) == 0x0016D4, "Member 'AKiller::_defaultAmountToSquish' has a wrong offset!");
static_assert(offsetof(AKiller, _stalkTimers) == 0x0016E0, "Member 'AKiller::_stalkTimers' has a wrong offset!");
static_assert(offsetof(AKiller, _recentlyCloakedTimer) == 0x001730, "Member 'AKiller::_recentlyCloakedTimer' has a wrong offset!");
static_assert(offsetof(AKiller, _flashlightBlindEvasionScoreTimer) == 0x001758, "Member 'AKiller::_flashlightBlindEvasionScoreTimer' has a wrong offset!");
static_assert(offsetof(AKiller, _flashlightBurnoutEvasionScoreTimer) == 0x001780, "Member 'AKiller::_flashlightBurnoutEvasionScoreTimer' has a wrong offset!");
static_assert(offsetof(AKiller, _predictedCamperHitMontages) == 0x0017A8, "Member 'AKiller::_predictedCamperHitMontages' has a wrong offset!");
static_assert(offsetof(AKiller, CameraSocketName) == 0x0017F8, "Member 'AKiller::CameraSocketName' has a wrong offset!");
static_assert(offsetof(AKiller, _loudNoiseIndicator) == 0x001810, "Member 'AKiller::_loudNoiseIndicator' has a wrong offset!");
static_assert(offsetof(AKiller, _hitsWhileCarryingTracker) == 0x001818, "Member 'AKiller::_hitsWhileCarryingTracker' has a wrong offset!");
static_assert(offsetof(AKiller, _stealthIncreaseRate) == 0x001820, "Member 'AKiller::_stealthIncreaseRate' has a wrong offset!");
static_assert(offsetof(AKiller, _stealthDecreaseRate) == 0x001824, "Member 'AKiller::_stealthDecreaseRate' has a wrong offset!");
static_assert(offsetof(AKiller, _isInStalkMode) == 0x001878, "Member 'AKiller::_isInStalkMode' has a wrong offset!");
static_assert(offsetof(AKiller, _isKilling) == 0x0019E0, "Member 'AKiller::_isKilling' has a wrong offset!");
static_assert(offsetof(AKiller, _allowedKillCount) == 0x0019E1, "Member 'AKiller::_allowedKillCount' has a wrong offset!");
static_assert(offsetof(AKiller, _allowedKillAfterStrugglePhase) == 0x0019E2, "Member 'AKiller::_allowedKillAfterStrugglePhase' has a wrong offset!");
static_assert(offsetof(AKiller, _cachedBloodlustTier) == 0x0019EC, "Member 'AKiller::_cachedBloodlustTier' has a wrong offset!");
static_assert(offsetof(AKiller, _killerPowerDebugFlags) == 0x0019F4, "Member 'AKiller::_killerPowerDebugFlags' has a wrong offset!");
static_assert(offsetof(AKiller, _presenceTag) == 0x0019F8, "Member 'AKiller::_presenceTag' has a wrong offset!");
static_assert(offsetof(AKiller, _persistantStateTags) == 0x001A08, "Member 'AKiller::_persistantStateTags' has a wrong offset!");
static_assert(offsetof(AKiller, _enableKillerCrouchInput) == 0x001A28, "Member 'AKiller::_enableKillerCrouchInput' has a wrong offset!");
static_assert(offsetof(AKiller, _canStartAttackWhileCrouched) == 0x001A29, "Member 'AKiller::_canStartAttackWhileCrouched' has a wrong offset!");
static_assert(offsetof(AKiller, _carriedSurvivor) == 0x001A30, "Member 'AKiller::_carriedSurvivor' has a wrong offset!");
static_assert(offsetof(AKiller, _moriComponent) == 0x001A38, "Member 'AKiller::_moriComponent' has a wrong offset!");
static_assert(offsetof(AKiller, _finisherMoriHandlerComponent) == 0x001A40, "Member 'AKiller::_finisherMoriHandlerComponent' has a wrong offset!");
static_assert(offsetof(AKiller, _hitValidator) == 0x001A48, "Member 'AKiller::_hitValidator' has a wrong offset!");
static_assert(offsetof(AKiller, _hitValidationConfigurator) == 0x001A50, "Member 'AKiller::_hitValidationConfigurator' has a wrong offset!");
static_assert(offsetof(AKiller, _attackerComponent) == 0x001A58, "Member 'AKiller::_attackerComponent' has a wrong offset!");
static_assert(offsetof(AKiller, _basicAttackType) == 0x001A74, "Member 'AKiller::_basicAttackType' has a wrong offset!");
static_assert(offsetof(AKiller, _armIKSensorComponent) == 0x001A78, "Member 'AKiller::_armIKSensorComponent' has a wrong offset!");
static_assert(offsetof(AKiller, _survivorBeingKilled) == 0x001A80, "Member 'AKiller::_survivorBeingKilled' has a wrong offset!");
static_assert(offsetof(AKiller, _firstPersonViewComponentClass) == 0x001A90, "Member 'AKiller::_firstPersonViewComponentClass' has a wrong offset!");
static_assert(offsetof(AKiller, _firstPersonViewComponent) == 0x001A98, "Member 'AKiller::_firstPersonViewComponent' has a wrong offset!");
static_assert(offsetof(AKiller, _killerIntroComponent) == 0x001AA0, "Member 'AKiller::_killerIntroComponent' has a wrong offset!");
static_assert(offsetof(AKiller, _blindingFXComponent) == 0x001AA8, "Member 'AKiller::_blindingFXComponent' has a wrong offset!");
static_assert(offsetof(AKiller, _redStainUpdateStrategy) == 0x001AB8, "Member 'AKiller::_redStainUpdateStrategy' has a wrong offset!");
static_assert(offsetof(AKiller, _squishFactorParameter) == 0x001AC0, "Member 'AKiller::_squishFactorParameter' has a wrong offset!");
static_assert(offsetof(AKiller, _attackZonePivot) == 0x001AD0, "Member 'AKiller::_attackZonePivot' has a wrong offset!");
static_assert(offsetof(AKiller, _slasherStunnableComponent) == 0x001AD8, "Member 'AKiller::_slasherStunnableComponent' has a wrong offset!");

// Class DeadByDaylight.KillerAudioHandlerComponent
// 0x0080 (0x01D8 - 0x0158)
class UKillerAudioHandlerComponent : public UDBDPlayerAudioHandlerComponent
{
public:
	struct FDBDTunableRowHandle                   _killerMovingShockTime;                            // 0x0158(0x0028)(Edit, NativeAccessSpecifierPrivate)
	class FString                                 _shockEvent;                                       // 0x0180(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTagQuery                      _movingShockCondition;                             // 0x0190(0x0048)(Edit, NativeAccessSpecifierPrivate)

public:
	void ChaseTriggerKillerReactionSpecificSurvivorSFX(class ADBDPlayer* Survivor);
	void HitImpactOnSurvivorSFX(class ASurvivor* Survivor, EAttackType attackType, bool IsWeaponHit);
	void OnChaseStart(class ADBDPlayer* chasedSurvivor);
	void TriggerKillerReactionSpecificSurvivorSFX(class ADBDPlayer* Survivor);
	void TriggerSurvivorDamageHitAudioSFX(class ASurvivor* Survivor, EAttackType attackType, bool CausedKO, bool IsWeaponHit, bool isLightHit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerAudioHandlerComponent">();
	}
	static class UKillerAudioHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerAudioHandlerComponent>();
	}
};
static_assert(alignof(UKillerAudioHandlerComponent) == 0x000008, "Wrong alignment on UKillerAudioHandlerComponent");
static_assert(sizeof(UKillerAudioHandlerComponent) == 0x0001D8, "Wrong size on UKillerAudioHandlerComponent");
static_assert(offsetof(UKillerAudioHandlerComponent, _killerMovingShockTime) == 0x000158, "Member 'UKillerAudioHandlerComponent::_killerMovingShockTime' has a wrong offset!");
static_assert(offsetof(UKillerAudioHandlerComponent, _shockEvent) == 0x000180, "Member 'UKillerAudioHandlerComponent::_shockEvent' has a wrong offset!");
static_assert(offsetof(UKillerAudioHandlerComponent, _movingShockCondition) == 0x000190, "Member 'UKillerAudioHandlerComponent::_movingShockCondition' has a wrong offset!");

// Class DeadByDaylight.KillerAudioMenuReactionComponent
// 0x0010 (0x00C8 - 0x00B8)
class UKillerAudioMenuReactionComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LobbyKillerReactionSpecificSurvivorSFX(const TArray<class ADBDMenuPlayer*>& menuPlayers);
	void OnLobbyTimeChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerAudioMenuReactionComponent">();
	}
	static class UKillerAudioMenuReactionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerAudioMenuReactionComponent>();
	}
};
static_assert(alignof(UKillerAudioMenuReactionComponent) == 0x000008, "Wrong alignment on UKillerAudioMenuReactionComponent");
static_assert(sizeof(UKillerAudioMenuReactionComponent) == 0x0000C8, "Wrong size on UKillerAudioMenuReactionComponent");

// Class DeadByDaylight.KillerBloodFXComponent
// 0x0018 (0x00D0 - 0x00B8)
class UKillerBloodFXComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayBloodSplatter();
	void StopBloodSplatter();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerBloodFXComponent">();
	}
	static class UKillerBloodFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerBloodFXComponent>();
	}
};
static_assert(alignof(UKillerBloodFXComponent) == 0x000008, "Wrong alignment on UKillerBloodFXComponent");
static_assert(sizeof(UKillerBloodFXComponent) == 0x0000D0, "Wrong size on UKillerBloodFXComponent");

// Class DeadByDaylight.StoreCollectionsSubsystem
// 0x0030 (0x0068 - 0x0038)
class UStoreCollectionsSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x30];                                      // 0x0038(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreCollectionsSubsystem">();
	}
	static class UStoreCollectionsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreCollectionsSubsystem>();
	}
};
static_assert(alignof(UStoreCollectionsSubsystem) == 0x000008, "Wrong alignment on UStoreCollectionsSubsystem");
static_assert(sizeof(UStoreCollectionsSubsystem) == 0x000068, "Wrong size on UStoreCollectionsSubsystem");

// Class DeadByDaylight.KillerBloodFXInterface
// 0x0000 (0x0000 - 0x0000)
class IKillerBloodFXInterface final
{
public:
	void PlayBloodSplatter();
	void StopBloodSplatter();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerBloodFXInterface">();
	}
	static class IKillerBloodFXInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IKillerBloodFXInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IKillerBloodFXInterface) == 0x000001, "Wrong alignment on IKillerBloodFXInterface");
static_assert(sizeof(IKillerBloodFXInterface) == 0x000001, "Wrong size on IKillerBloodFXInterface");

// Class DeadByDaylight.KillerDependentObjectInterface
// 0x0000 (0x0000 - 0x0000)
class IKillerDependentObjectInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerDependentObjectInterface">();
	}
	static class IKillerDependentObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IKillerDependentObjectInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IKillerDependentObjectInterface) == 0x000001, "Wrong alignment on IKillerDependentObjectInterface");
static_assert(sizeof(IKillerDependentObjectInterface) == 0x000001, "Wrong size on IKillerDependentObjectInterface");

// Class DeadByDaylight.KillerHitCosmeticHandler
// 0x0018 (0x0048 - 0x0030)
class UKillerHitCosmeticHandler final : public UBaseReversibleInstantActionHandler
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerHitCosmeticHandler">();
	}
	static class UKillerHitCosmeticHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerHitCosmeticHandler>();
	}
};
static_assert(alignof(UKillerHitCosmeticHandler) == 0x000008, "Wrong alignment on UKillerHitCosmeticHandler");
static_assert(sizeof(UKillerHitCosmeticHandler) == 0x000048, "Wrong size on UKillerHitCosmeticHandler");

// Class DeadByDaylight.KillerHitsWhileCarryingTrackerComponent
// 0x0060 (0x0118 - 0x00B8)
class UKillerHitsWhileCarryingTrackerComponent final : public UActorComponent
{
public:
	TSet<class ASurvivor*>                        _survivorsHitDuringLastCarry;                      // 0x00B8(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x10];                                     // 0x0108(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAttack(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData);
	void OnPickup(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData);
	void OnPostAttack(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerHitsWhileCarryingTrackerComponent">();
	}
	static class UKillerHitsWhileCarryingTrackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerHitsWhileCarryingTrackerComponent>();
	}
};
static_assert(alignof(UKillerHitsWhileCarryingTrackerComponent) == 0x000008, "Wrong alignment on UKillerHitsWhileCarryingTrackerComponent");
static_assert(sizeof(UKillerHitsWhileCarryingTrackerComponent) == 0x000118, "Wrong size on UKillerHitsWhileCarryingTrackerComponent");
static_assert(offsetof(UKillerHitsWhileCarryingTrackerComponent, _survivorsHitDuringLastCarry) == 0x0000B8, "Member 'UKillerHitsWhileCarryingTrackerComponent::_survivorsHitDuringLastCarry' has a wrong offset!");

// Class DeadByDaylight.KillerInteractable
// 0x0008 (0x03E8 - 0x03E0)
class AKillerInteractable : public APlayerInteractable
{
public:
	class UInteractor*                            _genericStunInteractor;                            // 0x03E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerInteractable">();
	}
	static class AKillerInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKillerInteractable>();
	}
};
static_assert(alignof(AKillerInteractable) == 0x000008, "Wrong alignment on AKillerInteractable");
static_assert(sizeof(AKillerInteractable) == 0x0003E8, "Wrong size on AKillerInteractable");
static_assert(offsetof(AKillerInteractable, _genericStunInteractor) == 0x0003E0, "Member 'AKillerInteractable::_genericStunInteractor' has a wrong offset!");

// Class DeadByDaylight.StoreSpecialPackSubsystem
// 0x00C0 (0x00F8 - 0x0038)
class UStoreSpecialPackSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0xC0];                                      // 0x0038(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TMulticastInlineDelegate<void()> GetSpecialPacksUpdatedDelegate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreSpecialPackSubsystem">();
	}
	static class UStoreSpecialPackSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreSpecialPackSubsystem>();
	}
};
static_assert(alignof(UStoreSpecialPackSubsystem) == 0x000008, "Wrong alignment on UStoreSpecialPackSubsystem");
static_assert(sizeof(UStoreSpecialPackSubsystem) == 0x0000F8, "Wrong size on UStoreSpecialPackSubsystem");

// Class DeadByDaylight.KillerIntroComponent
// 0x0030 (0x00E8 - 0x00B8)
class UKillerIntroComponent final : public UActorComponent
{
public:
	float                                         _percentOfCameraPanInProgressRequiredToHideKiller; // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _cameraPanInAmountToSquish;                        // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFPVTransitionStrategy                        _cameraPanInHidingStrategy;                        // 0x00C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _startKillerIntroDelay;                            // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x20];                                      // 0x00C8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void KillerCameraPanInUpdateNative(const float killerIntroCompletedPercent);
	void OnIntroCompleted();
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerIntroComponent">();
	}
	static class UKillerIntroComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerIntroComponent>();
	}
};
static_assert(alignof(UKillerIntroComponent) == 0x000008, "Wrong alignment on UKillerIntroComponent");
static_assert(sizeof(UKillerIntroComponent) == 0x0000E8, "Wrong size on UKillerIntroComponent");
static_assert(offsetof(UKillerIntroComponent, _percentOfCameraPanInProgressRequiredToHideKiller) == 0x0000B8, "Member 'UKillerIntroComponent::_percentOfCameraPanInProgressRequiredToHideKiller' has a wrong offset!");
static_assert(offsetof(UKillerIntroComponent, _cameraPanInAmountToSquish) == 0x0000BC, "Member 'UKillerIntroComponent::_cameraPanInAmountToSquish' has a wrong offset!");
static_assert(offsetof(UKillerIntroComponent, _cameraPanInHidingStrategy) == 0x0000C0, "Member 'UKillerIntroComponent::_cameraPanInHidingStrategy' has a wrong offset!");
static_assert(offsetof(UKillerIntroComponent, _startKillerIntroDelay) == 0x0000C4, "Member 'UKillerIntroComponent::_startKillerIntroDelay' has a wrong offset!");

// Class DeadByDaylight.KillerMovementComponent
// 0x0080 (0x14B0 - 0x1430)
class UKillerMovementComponent final : public UDBDCharacterMovementComponent
{
public:
	uint8                                         Pad_1430[0x18];                                    // 0x1430(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnHitLedgeEvent;                                   // 0x1448(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         OnHitLedgeEventCooldown;                           // 0x1458(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_145C[0x54];                                    // 0x145C(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetBaseMaxSpeed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerMovementComponent">();
	}
	static class UKillerMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerMovementComponent>();
	}
};
static_assert(alignof(UKillerMovementComponent) == 0x000010, "Wrong alignment on UKillerMovementComponent");
static_assert(sizeof(UKillerMovementComponent) == 0x0014B0, "Wrong size on UKillerMovementComponent");
static_assert(offsetof(UKillerMovementComponent, OnHitLedgeEvent) == 0x001448, "Member 'UKillerMovementComponent::OnHitLedgeEvent' has a wrong offset!");
static_assert(offsetof(UKillerMovementComponent, OnHitLedgeEventCooldown) == 0x001458, "Member 'UKillerMovementComponent::OnHitLedgeEventCooldown' has a wrong offset!");

// Class DeadByDaylight.KillerOpenGate
// 0x0050 (0x0910 - 0x08C0)
class UKillerOpenGate final : public UChargeableInteractionDefinition
{
public:
	struct FAnimationMontageDescriptor            _openGateMontage;                                  // 0x08C0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_8E0[0x30];                                     // 0x08E0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateSwitch() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerOpenGate">();
	}
	static class UKillerOpenGate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerOpenGate>();
	}
};
static_assert(alignof(UKillerOpenGate) == 0x000010, "Wrong alignment on UKillerOpenGate");
static_assert(sizeof(UKillerOpenGate) == 0x000910, "Wrong size on UKillerOpenGate");
static_assert(offsetof(UKillerOpenGate, _openGateMontage) == 0x0008C0, "Member 'UKillerOpenGate::_openGateMontage' has a wrong offset!");

// Class DeadByDaylight.KillerStunnableComponent
// 0x0040 (0x00F8 - 0x00B8)
class UKillerStunnableComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x40];                                      // 0x00B8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Server_NotifyStunHasBeenProcessed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerStunnableComponent">();
	}
	static class UKillerStunnableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerStunnableComponent>();
	}
};
static_assert(alignof(UKillerStunnableComponent) == 0x000008, "Wrong alignment on UKillerStunnableComponent");
static_assert(sizeof(UKillerStunnableComponent) == 0x0000F8, "Wrong size on UKillerStunnableComponent");

// Class DeadByDaylight.LacerationUIData
// 0x0000 (0x0000 - 0x0000)
class ILacerationUIData final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LacerationUIData">();
	}
	static class ILacerationUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILacerationUIData>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ILacerationUIData) == 0x000001, "Wrong alignment on ILacerationUIData");
static_assert(sizeof(ILacerationUIData) == 0x000001, "Wrong size on ILacerationUIData");

// Class DeadByDaylight.LanternInteractable
// 0x0050 (0x03F8 - 0x03A8)
class ALanternInteractable final : public AInteractable
{
public:
	TMulticastInlineDelegate<void(ELanternState lanternState, ELanternState previousLanternState)> OnLanternStateChanged; // 0x03A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADBDPlayer* Player)> OnLanternCollectedByPlayerCosmetic;     // 0x03B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C8[0x18];                                     // 0x03C8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ALanternLightCollectable>   _collectableClass;                                 // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E8[0x10];                                     // 0x03E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeLanternState(ELanternState newLanternState);
	void CollectLight(class ADBDPlayer* Player);
	void OnBackToCollectableTimerEnd();
	void OnCamperLeavingHook(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData);
	void OnCamperWasHooked(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData);
	void OnSlasherDestroyedLantern(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData);
	void SlasherDestroyLantern(class ADBDPlayer* Player);

	bool CanBeCollected() const;
	bool CanBeDestroyed() const;
	ELanternState GetLanternState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LanternInteractable">();
	}
	static class ALanternInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALanternInteractable>();
	}
};
static_assert(alignof(ALanternInteractable) == 0x000008, "Wrong alignment on ALanternInteractable");
static_assert(sizeof(ALanternInteractable) == 0x0003F8, "Wrong size on ALanternInteractable");
static_assert(offsetof(ALanternInteractable, OnLanternStateChanged) == 0x0003A8, "Member 'ALanternInteractable::OnLanternStateChanged' has a wrong offset!");
static_assert(offsetof(ALanternInteractable, OnLanternCollectedByPlayerCosmetic) == 0x0003B8, "Member 'ALanternInteractable::OnLanternCollectedByPlayerCosmetic' has a wrong offset!");
static_assert(offsetof(ALanternInteractable, _collectableClass) == 0x0003E0, "Member 'ALanternInteractable::_collectableClass' has a wrong offset!");

// Class DeadByDaylight.LegalMenuScreen
// 0x0048 (0x0170 - 0x0128)
class ULegalMenuScreen final : public UScreenBase
{
public:
	uint8                                         Pad_128[0x48];                                     // 0x0128(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAcceptClick();
	void OnDeclineClick();
	void OnOkClick();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LegalMenuScreen">();
	}
	static class ULegalMenuScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULegalMenuScreen>();
	}
};
static_assert(alignof(ULegalMenuScreen) == 0x000008, "Wrong alignment on ULegalMenuScreen");
static_assert(sizeof(ULegalMenuScreen) == 0x000170, "Wrong size on ULegalMenuScreen");

// Class DeadByDaylight.LevelAISetupComponent
// 0x0000 (0x00B8 - 0x00B8)
class ULevelAISetupComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelAISetupComponent">();
	}
	static class ULevelAISetupComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelAISetupComponent>();
	}
};
static_assert(alignof(ULevelAISetupComponent) == 0x000008, "Wrong alignment on ULevelAISetupComponent");
static_assert(sizeof(ULevelAISetupComponent) == 0x0000B8, "Wrong size on ULevelAISetupComponent");

// Class DeadByDaylight.UMGGenericPopup
// 0x0098 (0x03E0 - 0x0348)
class UUMGGenericPopup final : public UMobileBaseUserWidget
{
public:
	class URichTextBlock*                         Title;                                             // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUMGHtmlRichText*                       Message;                                           // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 TitleBackground;                                   // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 TitleSmoke;                                        // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUMGPopupButton*                        RegressionPopupButton;                             // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUMGPopupButton*                        AlternativePopupButton;                            // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUMGPopupButton*                        ProgressionPopupButton;                            // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            ErrorTitleSmokeColor;                              // 0x0380(0x0014)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateColor                            ErrorTitleBackgroundColor;                         // 0x0394(0x0014)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateColor                            DefaultTitleSmokeColor;                            // 0x03A8(0x0014)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateColor                            DefaultTitleBackgroundColor;                       // 0x03BC(0x0014)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D0[0x10];                                     // 0x03D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPopupAppearance();
	void OnPopupDisappearance();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGGenericPopup">();
	}
	static class UUMGGenericPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGGenericPopup>();
	}
};
static_assert(alignof(UUMGGenericPopup) == 0x000008, "Wrong alignment on UUMGGenericPopup");
static_assert(sizeof(UUMGGenericPopup) == 0x0003E0, "Wrong size on UUMGGenericPopup");
static_assert(offsetof(UUMGGenericPopup, Title) == 0x000348, "Member 'UUMGGenericPopup::Title' has a wrong offset!");
static_assert(offsetof(UUMGGenericPopup, Message) == 0x000350, "Member 'UUMGGenericPopup::Message' has a wrong offset!");
static_assert(offsetof(UUMGGenericPopup, TitleBackground) == 0x000358, "Member 'UUMGGenericPopup::TitleBackground' has a wrong offset!");
static_assert(offsetof(UUMGGenericPopup, TitleSmoke) == 0x000360, "Member 'UUMGGenericPopup::TitleSmoke' has a wrong offset!");
static_assert(offsetof(UUMGGenericPopup, RegressionPopupButton) == 0x000368, "Member 'UUMGGenericPopup::RegressionPopupButton' has a wrong offset!");
static_assert(offsetof(UUMGGenericPopup, AlternativePopupButton) == 0x000370, "Member 'UUMGGenericPopup::AlternativePopupButton' has a wrong offset!");
static_assert(offsetof(UUMGGenericPopup, ProgressionPopupButton) == 0x000378, "Member 'UUMGGenericPopup::ProgressionPopupButton' has a wrong offset!");
static_assert(offsetof(UUMGGenericPopup, ErrorTitleSmokeColor) == 0x000380, "Member 'UUMGGenericPopup::ErrorTitleSmokeColor' has a wrong offset!");
static_assert(offsetof(UUMGGenericPopup, ErrorTitleBackgroundColor) == 0x000394, "Member 'UUMGGenericPopup::ErrorTitleBackgroundColor' has a wrong offset!");
static_assert(offsetof(UUMGGenericPopup, DefaultTitleSmokeColor) == 0x0003A8, "Member 'UUMGGenericPopup::DefaultTitleSmokeColor' has a wrong offset!");
static_assert(offsetof(UUMGGenericPopup, DefaultTitleBackgroundColor) == 0x0003BC, "Member 'UUMGGenericPopup::DefaultTitleBackgroundColor' has a wrong offset!");

// Class DeadByDaylight.WorldRunawayMeshComponent
// 0x0030 (0x1170 - 0x1140)
class UWorldRunawayMeshComponent : public UDBDSkeletalMeshComponentBudgeted
{
public:
	float                                         ResetCooldown;                                     // 0x1140(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _runAwayMustTickDuration;                          // 0x1144(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _returnMustTickDuration;                           // 0x1148(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_114C[0x24];                                    // 0x114C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetShouldRunAway(bool should);
	void SetShouldRunAwayWithDelay(bool should, float Delay);
	void SetShouldRunAwayWithRandomDelay(bool should, float delayRange);

	bool GetShouldRunAway() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldRunawayMeshComponent">();
	}
	static class UWorldRunawayMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldRunawayMeshComponent>();
	}
};
static_assert(alignof(UWorldRunawayMeshComponent) == 0x000010, "Wrong alignment on UWorldRunawayMeshComponent");
static_assert(sizeof(UWorldRunawayMeshComponent) == 0x001170, "Wrong size on UWorldRunawayMeshComponent");
static_assert(offsetof(UWorldRunawayMeshComponent, ResetCooldown) == 0x001140, "Member 'UWorldRunawayMeshComponent::ResetCooldown' has a wrong offset!");
static_assert(offsetof(UWorldRunawayMeshComponent, _runAwayMustTickDuration) == 0x001144, "Member 'UWorldRunawayMeshComponent::_runAwayMustTickDuration' has a wrong offset!");
static_assert(offsetof(UWorldRunawayMeshComponent, _returnMustTickDuration) == 0x001148, "Member 'UWorldRunawayMeshComponent::_returnMustTickDuration' has a wrong offset!");

// Class DeadByDaylight.LevelCrowWRMeshComponent
// 0x0000 (0x1170 - 0x1170)
class ULevelCrowWRMeshComponent final : public UWorldRunawayMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelCrowWRMeshComponent">();
	}
	static class ULevelCrowWRMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelCrowWRMeshComponent>();
	}
};
static_assert(alignof(ULevelCrowWRMeshComponent) == 0x000010, "Wrong alignment on ULevelCrowWRMeshComponent");
static_assert(sizeof(ULevelCrowWRMeshComponent) == 0x001170, "Wrong size on ULevelCrowWRMeshComponent");

// Class DeadByDaylight.LightFunctionActorSpawner
// 0x0010 (0x03C0 - 0x03B0)
class ULightFunctionActorSpawner final : public UActorSpawner
{
public:
	class UTexture*                               LightFunctionTexture;                              // 0x03B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B8[0x8];                                      // 0x03B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightFunctionActorSpawner">();
	}
	static class ULightFunctionActorSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightFunctionActorSpawner>();
	}
};
static_assert(alignof(ULightFunctionActorSpawner) == 0x000010, "Wrong alignment on ULightFunctionActorSpawner");
static_assert(sizeof(ULightFunctionActorSpawner) == 0x0003C0, "Wrong size on ULightFunctionActorSpawner");
static_assert(offsetof(ULightFunctionActorSpawner, LightFunctionTexture) == 0x0003B0, "Member 'ULightFunctionActorSpawner::LightFunctionTexture' has a wrong offset!");

// Class DeadByDaylight.LightingData
// 0x0080 (0x00B8 - 0x0038)
class ULightingData final : public UDataAsset
{
public:
	TSoftClassPtr<class UClass>                   DefaultLighting;                                   // 0x0038(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FSceneLightingDescription>      Descriptions;                                      // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   AdaptiveShadowMapControllersActor;                 // 0x0080(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightingData">();
	}
	static class ULightingData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightingData>();
	}
};
static_assert(alignof(ULightingData) == 0x000008, "Wrong alignment on ULightingData");
static_assert(sizeof(ULightingData) == 0x0000B8, "Wrong size on ULightingData");
static_assert(offsetof(ULightingData, DefaultLighting) == 0x000038, "Member 'ULightingData::DefaultLighting' has a wrong offset!");
static_assert(offsetof(ULightingData, Descriptions) == 0x000070, "Member 'ULightingData::Descriptions' has a wrong offset!");
static_assert(offsetof(ULightingData, AdaptiveShadowMapControllersActor) == 0x000080, "Member 'ULightingData::AdaptiveShadowMapControllersActor' has a wrong offset!");

// Class DeadByDaylight.UMGPopupButton
// 0x0030 (0x04F0 - 0x04C0)
class UUMGPopupButton final : public UUMGBaseButtonWidget
{
public:
	uint8                                         Pad_4B8[0x14];                                     // 0x04B8(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DisabledOpacity;                                   // 0x04CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EnabledOpacity;                                    // 0x04D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D4[0x4];                                      // 0x04D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 VFXs;                                              // 0x04D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Line;                                              // 0x04E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 FXSmoke;                                           // 0x04E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnButtonClicked();
	void OnButtonPressed();
	void OnButtonReleased();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGPopupButton">();
	}
	static class UUMGPopupButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGPopupButton>();
	}
};
static_assert(alignof(UUMGPopupButton) == 0x000010, "Wrong alignment on UUMGPopupButton");
static_assert(sizeof(UUMGPopupButton) == 0x0004F0, "Wrong size on UUMGPopupButton");
static_assert(offsetof(UUMGPopupButton, DisabledOpacity) == 0x0004CC, "Member 'UUMGPopupButton::DisabledOpacity' has a wrong offset!");
static_assert(offsetof(UUMGPopupButton, EnabledOpacity) == 0x0004D0, "Member 'UUMGPopupButton::EnabledOpacity' has a wrong offset!");
static_assert(offsetof(UUMGPopupButton, VFXs) == 0x0004D8, "Member 'UUMGPopupButton::VFXs' has a wrong offset!");
static_assert(offsetof(UUMGPopupButton, Line) == 0x0004E0, "Member 'UUMGPopupButton::Line' has a wrong offset!");
static_assert(offsetof(UUMGPopupButton, FXSmoke) == 0x0004E8, "Member 'UUMGPopupButton::FXSmoke' has a wrong offset!");

// Class DeadByDaylight.LightingHelper
// 0x0108 (0x0138 - 0x0030)
class ULightingHelper final : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseSky*                               _levelLighting;                                    // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABaseSky*                               _levelLightingFixed;                               // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABaseSky*                               _levelLightingSpawned;                             // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABaseSky*                               _levelLightingWithoutExposure;                     // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 _adaptiveShadowMapControllersActor;                // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULightingInterpolator*                  _lightingInterpolator;                             // 0x0070(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULightingFactory*                       _lightingFactory;                                  // 0x0078(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPostProcessComponent*                  _postProcessCache;                                 // 0x0080(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bIsChangeCondition;                               // 0x0088(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _changeLightingThemeName;                          // 0x008C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0xA0];                                      // 0x0098(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_ModifyExposure(float Value);
	class AActor* GetASMController();
	class UActorComponent* GetInitialComponentState(class FName componentName);
	class UClass* GetSourceLevelLightingClass();
	class UTextureCube* GetTextureCube(class FName mapTheme);
	void ToggleLightingChange(bool bActivateLightingChange, class FName ThemeName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightingHelper">();
	}
	static class ULightingHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightingHelper>();
	}
};
static_assert(alignof(ULightingHelper) == 0x000008, "Wrong alignment on ULightingHelper");
static_assert(sizeof(ULightingHelper) == 0x000138, "Wrong size on ULightingHelper");
static_assert(offsetof(ULightingHelper, _levelLighting) == 0x000048, "Member 'ULightingHelper::_levelLighting' has a wrong offset!");
static_assert(offsetof(ULightingHelper, _levelLightingFixed) == 0x000050, "Member 'ULightingHelper::_levelLightingFixed' has a wrong offset!");
static_assert(offsetof(ULightingHelper, _levelLightingSpawned) == 0x000058, "Member 'ULightingHelper::_levelLightingSpawned' has a wrong offset!");
static_assert(offsetof(ULightingHelper, _levelLightingWithoutExposure) == 0x000060, "Member 'ULightingHelper::_levelLightingWithoutExposure' has a wrong offset!");
static_assert(offsetof(ULightingHelper, _adaptiveShadowMapControllersActor) == 0x000068, "Member 'ULightingHelper::_adaptiveShadowMapControllersActor' has a wrong offset!");
static_assert(offsetof(ULightingHelper, _lightingInterpolator) == 0x000070, "Member 'ULightingHelper::_lightingInterpolator' has a wrong offset!");
static_assert(offsetof(ULightingHelper, _lightingFactory) == 0x000078, "Member 'ULightingHelper::_lightingFactory' has a wrong offset!");
static_assert(offsetof(ULightingHelper, _postProcessCache) == 0x000080, "Member 'ULightingHelper::_postProcessCache' has a wrong offset!");
static_assert(offsetof(ULightingHelper, _bIsChangeCondition) == 0x000088, "Member 'ULightingHelper::_bIsChangeCondition' has a wrong offset!");
static_assert(offsetof(ULightingHelper, _changeLightingThemeName) == 0x00008C, "Member 'ULightingHelper::_changeLightingThemeName' has a wrong offset!");

// Class DeadByDaylight.LightingInterpolator
// 0x0050 (0x0080 - 0x0030)
class ULightingInterpolator final : public UObject
{
public:
	TMulticastInlineDelegate<void()>              OnInterpolationDone;                               // 0x0030(0x0010)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x38];                                      // 0x0040(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseSky*                               _targetLighting;                                   // 0x0078(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static void LerpHeightFog(class UExponentialHeightFogComponent* Target, const class UExponentialHeightFogComponent* A, const class UExponentialHeightFogComponent* B, float alpha, float thresholdBeforeSwitchingtoB);
	static void LerpLight(class ULightComponent* Target, class ULightComponent* A, class ULightComponent* B, float alpha);
	static void LerpSkylight(class USkyLightComponent* Target, class USkyLightComponent* A, class USkyLightComponent* B, float alpha);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightingInterpolator">();
	}
	static class ULightingInterpolator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightingInterpolator>();
	}
};
static_assert(alignof(ULightingInterpolator) == 0x000008, "Wrong alignment on ULightingInterpolator");
static_assert(sizeof(ULightingInterpolator) == 0x000080, "Wrong size on ULightingInterpolator");
static_assert(offsetof(ULightingInterpolator, OnInterpolationDone) == 0x000030, "Member 'ULightingInterpolator::OnInterpolationDone' has a wrong offset!");
static_assert(offsetof(ULightingInterpolator, _targetLighting) == 0x000078, "Member 'ULightingInterpolator::_targetLighting' has a wrong offset!");

// Class DeadByDaylight.SpawnerStrategy
// 0x0000 (0x0030 - 0x0030)
class USpawnerStrategy : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnerStrategy">();
	}
	static class USpawnerStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnerStrategy>();
	}
};
static_assert(alignof(USpawnerStrategy) == 0x000008, "Wrong alignment on USpawnerStrategy");
static_assert(sizeof(USpawnerStrategy) == 0x000030, "Wrong size on USpawnerStrategy");

// Class DeadByDaylight.LimitAccumulationSpawnerStrategy
// 0x0010 (0x0040 - 0x0030)
class ULimitAccumulationSpawnerStrategy final : public USpawnerStrategy
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMaxOverlapping(int32 maxOverlapping);
	void SetRecycleDistancePercentage(float recycleDistancePercentage);
	void SetRecycleThresholdPercentage(float recycleThresholdPercentage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LimitAccumulationSpawnerStrategy">();
	}
	static class ULimitAccumulationSpawnerStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULimitAccumulationSpawnerStrategy>();
	}
};
static_assert(alignof(ULimitAccumulationSpawnerStrategy) == 0x000008, "Wrong alignment on ULimitAccumulationSpawnerStrategy");
static_assert(sizeof(ULimitAccumulationSpawnerStrategy) == 0x000040, "Wrong size on ULimitAccumulationSpawnerStrategy");

// Class DeadByDaylight.BoxPlayerOverlapComponent
// 0x0000 (0x05E0 - 0x05E0)
class UBoxPlayerOverlapComponent final : public UBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoxPlayerOverlapComponent">();
	}
	static class UBoxPlayerOverlapComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBoxPlayerOverlapComponent>();
	}
};
static_assert(alignof(UBoxPlayerOverlapComponent) == 0x000010, "Wrong alignment on UBoxPlayerOverlapComponent");
static_assert(sizeof(UBoxPlayerOverlapComponent) == 0x0005E0, "Wrong size on UBoxPlayerOverlapComponent");

// Class DeadByDaylight.LoadingUtilities
// 0x0000 (0x0030 - 0x0030)
class ULoadingUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadingUtilities">();
	}
	static class ULoadingUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadingUtilities>();
	}
};
static_assert(alignof(ULoadingUtilities) == 0x000008, "Wrong alignment on ULoadingUtilities");
static_assert(sizeof(ULoadingUtilities) == 0x000030, "Wrong size on ULoadingUtilities");

// Class DeadByDaylight.LoadoutAutoEquipHelper
// 0x0050 (0x0080 - 0x0030)
class ULoadoutAutoEquipHelper final : public UObject
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutAutoEquipHelper">();
	}
	static class ULoadoutAutoEquipHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutAutoEquipHelper>();
	}
};
static_assert(alignof(ULoadoutAutoEquipHelper) == 0x000008, "Wrong alignment on ULoadoutAutoEquipHelper");
static_assert(sizeof(ULoadoutAutoEquipHelper) == 0x000080, "Wrong size on ULoadoutAutoEquipHelper");

// Class DeadByDaylight.LoadoutControllerSubsystem
// 0x0050 (0x0088 - 0x0038)
class ULoadoutControllerSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutControllerSubsystem">();
	}
	static class ULoadoutControllerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutControllerSubsystem>();
	}
};
static_assert(alignof(ULoadoutControllerSubsystem) == 0x000008, "Wrong alignment on ULoadoutControllerSubsystem");
static_assert(sizeof(ULoadoutControllerSubsystem) == 0x000088, "Wrong size on ULoadoutControllerSubsystem");

// Class DeadByDaylight.PlayersInDyingStateSurrenderTrackerComponent
// 0x0020 (0x00D8 - 0x00B8)
class UPlayersInDyingStateSurrenderTrackerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   _stateTagsForDyingStateExemption;                  // 0x00C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayersInDyingStateSurrenderTrackerComponent">();
	}
	static class UPlayersInDyingStateSurrenderTrackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayersInDyingStateSurrenderTrackerComponent>();
	}
};
static_assert(alignof(UPlayersInDyingStateSurrenderTrackerComponent) == 0x000008, "Wrong alignment on UPlayersInDyingStateSurrenderTrackerComponent");
static_assert(sizeof(UPlayersInDyingStateSurrenderTrackerComponent) == 0x0000D8, "Wrong size on UPlayersInDyingStateSurrenderTrackerComponent");
static_assert(offsetof(UPlayersInDyingStateSurrenderTrackerComponent, _stateTagsForDyingStateExemption) == 0x0000C8, "Member 'UPlayersInDyingStateSurrenderTrackerComponent::_stateTagsForDyingStateExemption' has a wrong offset!");

// Class DeadByDaylight.LoadoutInventorySubsystem
// 0x00A8 (0x00E0 - 0x0038)
class ULoadoutInventorySubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0xA8];                                      // 0x0038(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutInventorySubsystem">();
	}
	static class ULoadoutInventorySubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutInventorySubsystem>();
	}
};
static_assert(alignof(ULoadoutInventorySubsystem) == 0x000008, "Wrong alignment on ULoadoutInventorySubsystem");
static_assert(sizeof(ULoadoutInventorySubsystem) == 0x0000E0, "Wrong size on ULoadoutInventorySubsystem");

// Class DeadByDaylight.LoadoutPresetController
// 0x0008 (0x0038 - 0x0030)
class ULoadoutPresetController final : public UObject
{
public:
	class ULoadoutAutoEquipHelper*                _autoEquipHelper;                                  // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutPresetController">();
	}
	static class ULoadoutPresetController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutPresetController>();
	}
};
static_assert(alignof(ULoadoutPresetController) == 0x000008, "Wrong alignment on ULoadoutPresetController");
static_assert(sizeof(ULoadoutPresetController) == 0x000038, "Wrong size on ULoadoutPresetController");
static_assert(offsetof(ULoadoutPresetController, _autoEquipHelper) == 0x000030, "Member 'ULoadoutPresetController::_autoEquipHelper' has a wrong offset!");

// Class DeadByDaylight.LoadoutPresetStorageSubsystem
// 0x00A0 (0x00D8 - 0x0038)
class ULoadoutPresetStorageSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0xA0];                                      // 0x0038(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutPresetStorageSubsystem">();
	}
	static class ULoadoutPresetStorageSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutPresetStorageSubsystem>();
	}
};
static_assert(alignof(ULoadoutPresetStorageSubsystem) == 0x000008, "Wrong alignment on ULoadoutPresetStorageSubsystem");
static_assert(sizeof(ULoadoutPresetStorageSubsystem) == 0x0000D8, "Wrong size on ULoadoutPresetStorageSubsystem");

// Class DeadByDaylight.LobbyControllerSubsystem
// 0x0130 (0x0168 - 0x0038)
class ULobbyControllerSubsystem final : public UGameInstanceSubsystem
{
public:
	TWeakObjectPtr<class ULobbyDisplayStandController> _localPlayerDisplayStandController;           // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FString, class ULobbyDisplayStandController*> _displayStandControllers;               // 0x0040(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0xD8];                                      // 0x0090(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyControllerSubsystem">();
	}
	static class ULobbyControllerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyControllerSubsystem>();
	}
};
static_assert(alignof(ULobbyControllerSubsystem) == 0x000008, "Wrong alignment on ULobbyControllerSubsystem");
static_assert(sizeof(ULobbyControllerSubsystem) == 0x000168, "Wrong size on ULobbyControllerSubsystem");
static_assert(offsetof(ULobbyControllerSubsystem, _localPlayerDisplayStandController) == 0x000038, "Member 'ULobbyControllerSubsystem::_localPlayerDisplayStandController' has a wrong offset!");
static_assert(offsetof(ULobbyControllerSubsystem, _displayStandControllers) == 0x000040, "Member 'ULobbyControllerSubsystem::_displayStandControllers' has a wrong offset!");

// Class DeadByDaylight.LobbyDisplayStandController
// 0x0178 (0x0338 - 0x01C0)
class ULobbyDisplayStandController final : public UDisplayStandController
{
public:
	uint8                                         Pad_1C0[0x178];                                    // 0x01C0(0x0178)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyDisplayStandController">();
	}
	static class ULobbyDisplayStandController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyDisplayStandController>();
	}
};
static_assert(alignof(ULobbyDisplayStandController) == 0x000008, "Wrong alignment on ULobbyDisplayStandController");
static_assert(sizeof(ULobbyDisplayStandController) == 0x000338, "Wrong size on ULobbyDisplayStandController");

// Class DeadByDaylight.LobbyLevel
// 0x00B0 (0x0358 - 0x02A8)
class ALobbyLevel : public ALevelScriptActor
{
public:
	uint8                                         Pad_2A8[0x48];                                     // 0x02A8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADisplayStand*>                  _registeredDisplayStands;                          // 0x02F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	EWorldFlowEvent                               LobbyLoadedEvent;                                  // 0x0300(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_301[0x7];                                      // 0x0301(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _moriPreviewSpawnLocation;                         // 0x0308(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_320[0x38];                                     // 0x0320(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAdditionalSubLevelsLoaded();
	void OnAnimationPreviewCompleted(class UAnimationPreviewSubsystem* Subsystem, const struct FAnimationPreviewRequest& Request, bool completedSuccessfully);
	void OnAnimationPreviewStarted(class UAnimationPreviewSubsystem* Subsystem, const struct FAnimationPreviewRequest& Request);
	void OnEventObjectivesSubLevelLoaded();
	void OnLobbySubLevelLoaded();
	void OnShopSubLevelLoaded();
	void ReceiveAnimationPreviewCompleted();
	void ReceiveAnimationPreviewStarted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyLevel">();
	}
	static class ALobbyLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALobbyLevel>();
	}
};
static_assert(alignof(ALobbyLevel) == 0x000008, "Wrong alignment on ALobbyLevel");
static_assert(sizeof(ALobbyLevel) == 0x000358, "Wrong size on ALobbyLevel");
static_assert(offsetof(ALobbyLevel, _registeredDisplayStands) == 0x0002F0, "Member 'ALobbyLevel::_registeredDisplayStands' has a wrong offset!");
static_assert(offsetof(ALobbyLevel, LobbyLoadedEvent) == 0x000300, "Member 'ALobbyLevel::LobbyLoadedEvent' has a wrong offset!");
static_assert(offsetof(ALobbyLevel, _moriPreviewSpawnLocation) == 0x000308, "Member 'ALobbyLevel::_moriPreviewSpawnLocation' has a wrong offset!");

// Class DeadByDaylight.PopupSequencer
// 0x0040 (0x0070 - 0x0030)
class alignas(0x10) UPopupSequencer final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDGameInstance*                       _gameInstance;                                     // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x30];                                      // 0x0040(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PopupSequencer">();
	}
	static class UPopupSequencer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPopupSequencer>();
	}
};
static_assert(alignof(UPopupSequencer) == 0x000010, "Wrong alignment on UPopupSequencer");
static_assert(sizeof(UPopupSequencer) == 0x000070, "Wrong size on UPopupSequencer");
static_assert(offsetof(UPopupSequencer, _gameInstance) == 0x000038, "Member 'UPopupSequencer::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.LobbyPositionsSubsystem
// 0x00B8 (0x00F0 - 0x0038)
class ULobbyPositionsSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0xB8];                                      // 0x0038(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyPositionsSubsystem">();
	}
	static class ULobbyPositionsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyPositionsSubsystem>();
	}
};
static_assert(alignof(ULobbyPositionsSubsystem) == 0x000008, "Wrong alignment on ULobbyPositionsSubsystem");
static_assert(sizeof(ULobbyPositionsSubsystem) == 0x0000F0, "Wrong size on ULobbyPositionsSubsystem");

// Class DeadByDaylight.LocalEventManager
// 0x1968 (0x19A0 - 0x0038)
class ULocalEventManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x1968];                                    // 0x0038(0x1968)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalEventManager">();
	}
	static class ULocalEventManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalEventManager>();
	}
};
static_assert(alignof(ULocalEventManager) == 0x000008, "Wrong alignment on ULocalEventManager");
static_assert(sizeof(ULocalEventManager) == 0x0019A0, "Wrong size on ULocalEventManager");

// Class DeadByDaylight.LocalizationSearchSubsystem
// 0x0000 (0x0038 - 0x0038)
class ULocalizationSearchSubsystem final : public UGameInstanceSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalizationSearchSubsystem">();
	}
	static class ULocalizationSearchSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalizationSearchSubsystem>();
	}
};
static_assert(alignof(ULocalizationSearchSubsystem) == 0x000008, "Wrong alignment on ULocalizationSearchSubsystem");
static_assert(sizeof(ULocalizationSearchSubsystem) == 0x000038, "Wrong size on ULocalizationSearchSubsystem");

// Class DeadByDaylight.LocalPlayerTrackerComponent
// 0x0010 (0x00C8 - 0x00B8)
class ULocalPlayerTrackerComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void()>              TrackerOnLocallyObservedChanged;                   // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void TriggerOnLocallyObservedChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalPlayerTrackerComponent">();
	}
	static class ULocalPlayerTrackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalPlayerTrackerComponent>();
	}
};
static_assert(alignof(ULocalPlayerTrackerComponent) == 0x000008, "Wrong alignment on ULocalPlayerTrackerComponent");
static_assert(sizeof(ULocalPlayerTrackerComponent) == 0x0000C8, "Wrong size on ULocalPlayerTrackerComponent");
static_assert(offsetof(ULocalPlayerTrackerComponent, TrackerOnLocallyObservedChanged) == 0x0000B8, "Member 'ULocalPlayerTrackerComponent::TrackerOnLocallyObservedChanged' has a wrong offset!");

// Class DeadByDaylight.Searchable
// 0x0150 (0x04F8 - 0x03A8)
class ASearchable final : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x28];                                     // 0x03A8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x03D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool searched)> OnSearchedChanged;                                 // 0x03D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USearchableItemStrategy*                SearchableItemStrategy;                            // 0x03E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USearchableSpawnPoint*                  _searchableSpawnPoint;                             // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F8[0x48];                                     // 0x03F8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class ACollectable*                           _spawnedItem;                                      // 0x0440(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACollectable*                           _itemInsideSearchable;                             // 0x0448(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isOpened;                                         // 0x0450(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasBeenOpened;                                    // 0x0451(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_452[0x6];                                      // 0x0452(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ADBDPlayer*, uint8>                _numberOfSearchesWhileOpenPerPlayer;               // 0x0458(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class UBlockableComponent*                    _searchableBlockableComponent;                     // 0x04A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULocalPlayerTrackerComponent*           _localPlayerTracker;                               // 0x04B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B8[0x40];                                     // 0x04B8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ACollectable* Authority_SpawnObject(class ADBDPlayer* Player);
	void Cosmetic_OnBlockSearchable(class ADBDPlayer* Player);
	void Cosmetic_OnUnblockSearchable(class ADBDPlayer* Player);
	void Multicast_SetHasBeenSearched(bool HasBeenSearched);
	void OnLocallyObservedChanged();
	void OnRep_IsOpened();
	void OnSearchableBlockChanged();
	void SetHasBeenSearched(bool newHasBeenSearched);

	bool ContainsSpawnedItem() const;
	class UPrimitiveComponent* GetInteractorPrimitiveComponent() const;
	bool HasBeenSearched() const;
	bool IsSearchableBlockedForPlayer(const class ADBDPlayer* Player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Searchable">();
	}
	static class ASearchable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASearchable>();
	}
};
static_assert(alignof(ASearchable) == 0x000008, "Wrong alignment on ASearchable");
static_assert(sizeof(ASearchable) == 0x0004F8, "Wrong size on ASearchable");
static_assert(offsetof(ASearchable, Weight) == 0x0003D0, "Member 'ASearchable::Weight' has a wrong offset!");
static_assert(offsetof(ASearchable, OnSearchedChanged) == 0x0003D8, "Member 'ASearchable::OnSearchedChanged' has a wrong offset!");
static_assert(offsetof(ASearchable, SearchableItemStrategy) == 0x0003E8, "Member 'ASearchable::SearchableItemStrategy' has a wrong offset!");
static_assert(offsetof(ASearchable, _searchableSpawnPoint) == 0x0003F0, "Member 'ASearchable::_searchableSpawnPoint' has a wrong offset!");
static_assert(offsetof(ASearchable, _spawnedItem) == 0x000440, "Member 'ASearchable::_spawnedItem' has a wrong offset!");
static_assert(offsetof(ASearchable, _itemInsideSearchable) == 0x000448, "Member 'ASearchable::_itemInsideSearchable' has a wrong offset!");
static_assert(offsetof(ASearchable, _isOpened) == 0x000450, "Member 'ASearchable::_isOpened' has a wrong offset!");
static_assert(offsetof(ASearchable, _hasBeenOpened) == 0x000451, "Member 'ASearchable::_hasBeenOpened' has a wrong offset!");
static_assert(offsetof(ASearchable, _numberOfSearchesWhileOpenPerPlayer) == 0x000458, "Member 'ASearchable::_numberOfSearchesWhileOpenPerPlayer' has a wrong offset!");
static_assert(offsetof(ASearchable, _searchableBlockableComponent) == 0x0004A8, "Member 'ASearchable::_searchableBlockableComponent' has a wrong offset!");
static_assert(offsetof(ASearchable, _localPlayerTracker) == 0x0004B0, "Member 'ASearchable::_localPlayerTracker' has a wrong offset!");

// Class DeadByDaylight.LocalPlayerUtilities
// 0x0000 (0x0030 - 0x0030)
class ULocalPlayerUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class ADBDPlayerState* GetFirstLocalValidHumanPlayerState(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalPlayerUtilities">();
	}
	static class ULocalPlayerUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalPlayerUtilities>();
	}
};
static_assert(alignof(ULocalPlayerUtilities) == 0x000008, "Wrong alignment on ULocalPlayerUtilities");
static_assert(sizeof(ULocalPlayerUtilities) == 0x000030, "Wrong size on ULocalPlayerUtilities");

// Class DeadByDaylight.Locker
// 0x01C0 (0x0568 - 0x03A8)
class ALocker final : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x28];                                     // 0x03A8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ADBDPlayer* playerWhoWasInLocker, class ADBDPlayer* playerNowInLocker)> OnPlayerInLockerChanged; // 0x03D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E0[0x18];                                     // 0x03E0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FastDoorActivationAudibleRange;                    // 0x03F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalDoorActivationAudibleRange;                  // 0x03FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          _boxComponent;                                     // 0x0400(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationMontageSlave*                 _montageFollower;                                  // 0x0408(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMontagePlayer*                         _montagePlayer;                                    // 0x0410(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADBDPlayer*                             _playerOpeningLocker;                              // 0x0418(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADBDPlayer*                             _playerInLocker;                                   // 0x0420(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractor*                            _mainInteractor;                                   // 0x0428(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    _frontInteractionZone;                             // 0x0430(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionDefinition*                 _searchEmpty;                                      // 0x0438(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionDefinition*                 _searchPlayer;                                     // 0x0440(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChildActorComponent*                   _killerInteractionActor;                           // 0x0448(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionDefinition*                 _enterSneak;                                       // 0x0450(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _rootComponent;                                    // 0x0458(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _survivorCameraAttachmentComponent;                // 0x0460(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _camperSocket;                                     // 0x0468(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_474[0x4];                                      // 0x0474(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULockerAnimInstance*                    _lockerAnimInstance;                               // 0x0478(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_480[0x48];                                     // 0x0480(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _preventAllInteractions;                           // 0x04C8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _local_preventAllInteractions;                     // 0x04C9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4CA[0x6];                                      // 0x04CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseLockerItem*                        _spawnedLockerItem;                                // 0x04D0(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _fastEnterInteractionTag;                          // 0x04D8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _fastExitInteractionTag;                           // 0x04E4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F0[0x70];                                     // 0x04F0(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIPerceptionStimuliSourceComponent*    _perceptionStimuliComponent;                       // 0x0560(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_EnableOtherInteractors(const class UInteractor* usableInteractor, bool usable);
	void Authority_ReportOpenLockerNoiseEventToAI(const bool fastActivation);
	void EjectSurvivor();
	class UExposerInteriorZoneComponent* GetExposerInteriorZone();
	struct FVector GetPlayerInLockerLocation();
	void OnRep_PlayerInLocker(class ADBDPlayer* previousPlayerInLocker);
	void OnRep_PlayerOpeningLocker(class ADBDPlayer* playerWhoWasOpeningLocker);
	void OnRep_PreventAllInteractions();
	void StartMinNearOutlineDistLerp(class ADBDPlayer* Player);
	void StopMinNearOutlineDistLerp(class ADBDPlayer* Player);

	class AActor* GetChildInteractionActor() const;
	class UInteractor* GetInteractor() const;
	class UInteractionDefinition* GetLockerHideEnterSneakInteraction() const;
	class USkeletalMeshComponent* GetMesh() const;
	class ADBDPlayer* GetPlayerInLocker() const;
	class UPrimitiveComponent* GetStunZone() const;
	class ASurvivor* GetSurvivorInLocker() const;
	bool IsFacingLocker(const class ADBDPlayer* Player, float toleranceDegreeAngle) const;
	bool IsOccupied() const;
	void SetPlayerInLockerVisibility(const bool IsVisible) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Locker">();
	}
	static class ALocker* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALocker>();
	}
};
static_assert(alignof(ALocker) == 0x000008, "Wrong alignment on ALocker");
static_assert(sizeof(ALocker) == 0x000568, "Wrong size on ALocker");
static_assert(offsetof(ALocker, OnPlayerInLockerChanged) == 0x0003D0, "Member 'ALocker::OnPlayerInLockerChanged' has a wrong offset!");
static_assert(offsetof(ALocker, FastDoorActivationAudibleRange) == 0x0003F8, "Member 'ALocker::FastDoorActivationAudibleRange' has a wrong offset!");
static_assert(offsetof(ALocker, NormalDoorActivationAudibleRange) == 0x0003FC, "Member 'ALocker::NormalDoorActivationAudibleRange' has a wrong offset!");
static_assert(offsetof(ALocker, _boxComponent) == 0x000400, "Member 'ALocker::_boxComponent' has a wrong offset!");
static_assert(offsetof(ALocker, _montageFollower) == 0x000408, "Member 'ALocker::_montageFollower' has a wrong offset!");
static_assert(offsetof(ALocker, _montagePlayer) == 0x000410, "Member 'ALocker::_montagePlayer' has a wrong offset!");
static_assert(offsetof(ALocker, _playerOpeningLocker) == 0x000418, "Member 'ALocker::_playerOpeningLocker' has a wrong offset!");
static_assert(offsetof(ALocker, _playerInLocker) == 0x000420, "Member 'ALocker::_playerInLocker' has a wrong offset!");
static_assert(offsetof(ALocker, _mainInteractor) == 0x000428, "Member 'ALocker::_mainInteractor' has a wrong offset!");
static_assert(offsetof(ALocker, _frontInteractionZone) == 0x000430, "Member 'ALocker::_frontInteractionZone' has a wrong offset!");
static_assert(offsetof(ALocker, _searchEmpty) == 0x000438, "Member 'ALocker::_searchEmpty' has a wrong offset!");
static_assert(offsetof(ALocker, _searchPlayer) == 0x000440, "Member 'ALocker::_searchPlayer' has a wrong offset!");
static_assert(offsetof(ALocker, _killerInteractionActor) == 0x000448, "Member 'ALocker::_killerInteractionActor' has a wrong offset!");
static_assert(offsetof(ALocker, _enterSneak) == 0x000450, "Member 'ALocker::_enterSneak' has a wrong offset!");
static_assert(offsetof(ALocker, _rootComponent) == 0x000458, "Member 'ALocker::_rootComponent' has a wrong offset!");
static_assert(offsetof(ALocker, _survivorCameraAttachmentComponent) == 0x000460, "Member 'ALocker::_survivorCameraAttachmentComponent' has a wrong offset!");
static_assert(offsetof(ALocker, _camperSocket) == 0x000468, "Member 'ALocker::_camperSocket' has a wrong offset!");
static_assert(offsetof(ALocker, _lockerAnimInstance) == 0x000478, "Member 'ALocker::_lockerAnimInstance' has a wrong offset!");
static_assert(offsetof(ALocker, _preventAllInteractions) == 0x0004C8, "Member 'ALocker::_preventAllInteractions' has a wrong offset!");
static_assert(offsetof(ALocker, _local_preventAllInteractions) == 0x0004C9, "Member 'ALocker::_local_preventAllInteractions' has a wrong offset!");
static_assert(offsetof(ALocker, _spawnedLockerItem) == 0x0004D0, "Member 'ALocker::_spawnedLockerItem' has a wrong offset!");
static_assert(offsetof(ALocker, _fastEnterInteractionTag) == 0x0004D8, "Member 'ALocker::_fastEnterInteractionTag' has a wrong offset!");
static_assert(offsetof(ALocker, _fastExitInteractionTag) == 0x0004E4, "Member 'ALocker::_fastExitInteractionTag' has a wrong offset!");
static_assert(offsetof(ALocker, _perceptionStimuliComponent) == 0x000560, "Member 'ALocker::_perceptionStimuliComponent' has a wrong offset!");

// Class DeadByDaylight.LockerAmmoActorOutlineUpdateStrategy
// 0x0000 (0x0100 - 0x0100)
class ULockerAmmoActorOutlineUpdateStrategy final : public UDefaultOutlineUpdateStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LockerAmmoActorOutlineUpdateStrategy">();
	}
	static class ULockerAmmoActorOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULockerAmmoActorOutlineUpdateStrategy>();
	}
};
static_assert(alignof(ULockerAmmoActorOutlineUpdateStrategy) == 0x000008, "Wrong alignment on ULockerAmmoActorOutlineUpdateStrategy");
static_assert(sizeof(ULockerAmmoActorOutlineUpdateStrategy) == 0x000100, "Wrong size on ULockerAmmoActorOutlineUpdateStrategy");

// Class DeadByDaylight.LockerAnimInstance
// 0x0000 (0x0360 - 0x0360)
class ULockerAnimInstance final : public USleepingAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LockerAnimInstance">();
	}
	static class ULockerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULockerAnimInstance>();
	}
};
static_assert(alignof(ULockerAnimInstance) == 0x000010, "Wrong alignment on ULockerAnimInstance");
static_assert(sizeof(ULockerAnimInstance) == 0x000360, "Wrong size on ULockerAnimInstance");

// Class DeadByDaylight.SeasonEndPopupScreen
// 0x0000 (0x0148 - 0x0148)
class USeasonEndPopupScreen final : public UGenericPopupScreen
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeasonEndPopupScreen">();
	}
	static class USeasonEndPopupScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeasonEndPopupScreen>();
	}
};
static_assert(alignof(USeasonEndPopupScreen) == 0x000008, "Wrong alignment on USeasonEndPopupScreen");
static_assert(sizeof(USeasonEndPopupScreen) == 0x000148, "Wrong size on USeasonEndPopupScreen");

// Class DeadByDaylight.LockerOutlineUpdateStrategy
// 0x0018 (0x0178 - 0x0160)
class ULockerOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	uint8                                         Pad_160[0x18];                                     // 0x0160(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FLinearColor GetRedColor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LockerOutlineUpdateStrategy">();
	}
	static class ULockerOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULockerOutlineUpdateStrategy>();
	}
};
static_assert(alignof(ULockerOutlineUpdateStrategy) == 0x000008, "Wrong alignment on ULockerOutlineUpdateStrategy");
static_assert(sizeof(ULockerOutlineUpdateStrategy) == 0x000178, "Wrong size on ULockerOutlineUpdateStrategy");

// Class DeadByDaylight.LoudNoise
// 0x0070 (0x0310 - 0x02A0)
class ALoudNoise final : public AActor
{
public:
	class UDecalComponent*                        _toInfinityDecal;                                  // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               _distortionParticleSystem;                         // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           _ak_audio_loudNoise;                               // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _rootScene;                                        // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _loudNoiseMinDistance;                             // 0x02C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4[0x34];                                     // 0x02C4(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _loudNoiseLifetime;                                // 0x02F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _heightToAddToLoudNoiseLocation;                   // 0x02FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _loudNoiseDecalDistance;                           // 0x0300(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _cameraDecalDistance;                              // 0x0304(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoudNoise">();
	}
	static class ALoudNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALoudNoise>();
	}
};
static_assert(alignof(ALoudNoise) == 0x000008, "Wrong alignment on ALoudNoise");
static_assert(sizeof(ALoudNoise) == 0x000310, "Wrong size on ALoudNoise");
static_assert(offsetof(ALoudNoise, _toInfinityDecal) == 0x0002A0, "Member 'ALoudNoise::_toInfinityDecal' has a wrong offset!");
static_assert(offsetof(ALoudNoise, _distortionParticleSystem) == 0x0002A8, "Member 'ALoudNoise::_distortionParticleSystem' has a wrong offset!");
static_assert(offsetof(ALoudNoise, _ak_audio_loudNoise) == 0x0002B0, "Member 'ALoudNoise::_ak_audio_loudNoise' has a wrong offset!");
static_assert(offsetof(ALoudNoise, _rootScene) == 0x0002B8, "Member 'ALoudNoise::_rootScene' has a wrong offset!");
static_assert(offsetof(ALoudNoise, _loudNoiseMinDistance) == 0x0002C0, "Member 'ALoudNoise::_loudNoiseMinDistance' has a wrong offset!");
static_assert(offsetof(ALoudNoise, _loudNoiseLifetime) == 0x0002F8, "Member 'ALoudNoise::_loudNoiseLifetime' has a wrong offset!");
static_assert(offsetof(ALoudNoise, _heightToAddToLoudNoiseLocation) == 0x0002FC, "Member 'ALoudNoise::_heightToAddToLoudNoiseLocation' has a wrong offset!");
static_assert(offsetof(ALoudNoise, _loudNoiseDecalDistance) == 0x000300, "Member 'ALoudNoise::_loudNoiseDecalDistance' has a wrong offset!");
static_assert(offsetof(ALoudNoise, _cameraDecalDistance) == 0x000304, "Member 'ALoudNoise::_cameraDecalDistance' has a wrong offset!");

// Class DeadByDaylight.LoudNoiseEventSystem
// 0x0090 (0x0148 - 0x00B8)
class ULoudNoiseEventSystem final : public UActorComponent
{
public:
	TArray<struct FGameplayTag>                   _requiredPlayerStateTags;                          // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTag>                   _preventativePlayerStateTags;                      // 0x00C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x70];                                      // 0x00D8(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoudNoiseEventSystem">();
	}
	static class ULoudNoiseEventSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoudNoiseEventSystem>();
	}
};
static_assert(alignof(ULoudNoiseEventSystem) == 0x000008, "Wrong alignment on ULoudNoiseEventSystem");
static_assert(sizeof(ULoudNoiseEventSystem) == 0x000148, "Wrong size on ULoudNoiseEventSystem");
static_assert(offsetof(ULoudNoiseEventSystem, _requiredPlayerStateTags) == 0x0000B8, "Member 'ULoudNoiseEventSystem::_requiredPlayerStateTags' has a wrong offset!");
static_assert(offsetof(ULoudNoiseEventSystem, _preventativePlayerStateTags) == 0x0000C8, "Member 'ULoudNoiseEventSystem::_preventativePlayerStateTags' has a wrong offset!");

// Class DeadByDaylight.LoudNoiseHUDIndicator
// 0x00A0 (0x0370 - 0x02D0)
class ULoudNoiseHUDIndicator final : public USceneComponent
{
public:
	class UStaticMesh*                            MaskMesh;                                          // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            DistortionMesh;                                    // 0x02D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EdgePadding;                                       // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CornerRoundness;                                   // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenFadeOutDistance;                             // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              LoudNoiseAddedEvent;                               // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_300[0x60];                                     // 0x0300(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLoudNoiseIndicatorData>        _trackedNoises;                                    // 0x0360(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void AddTrackedNoise(const struct FVector& Location, float Duration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoudNoiseHUDIndicator">();
	}
	static class ULoudNoiseHUDIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoudNoiseHUDIndicator>();
	}
};
static_assert(alignof(ULoudNoiseHUDIndicator) == 0x000010, "Wrong alignment on ULoudNoiseHUDIndicator");
static_assert(sizeof(ULoudNoiseHUDIndicator) == 0x000370, "Wrong size on ULoudNoiseHUDIndicator");
static_assert(offsetof(ULoudNoiseHUDIndicator, MaskMesh) == 0x0002D0, "Member 'ULoudNoiseHUDIndicator::MaskMesh' has a wrong offset!");
static_assert(offsetof(ULoudNoiseHUDIndicator, DistortionMesh) == 0x0002D8, "Member 'ULoudNoiseHUDIndicator::DistortionMesh' has a wrong offset!");
static_assert(offsetof(ULoudNoiseHUDIndicator, EdgePadding) == 0x0002E0, "Member 'ULoudNoiseHUDIndicator::EdgePadding' has a wrong offset!");
static_assert(offsetof(ULoudNoiseHUDIndicator, CornerRoundness) == 0x0002E4, "Member 'ULoudNoiseHUDIndicator::CornerRoundness' has a wrong offset!");
static_assert(offsetof(ULoudNoiseHUDIndicator, ScreenFadeOutDistance) == 0x0002E8, "Member 'ULoudNoiseHUDIndicator::ScreenFadeOutDistance' has a wrong offset!");
static_assert(offsetof(ULoudNoiseHUDIndicator, LoudNoiseAddedEvent) == 0x0002F0, "Member 'ULoudNoiseHUDIndicator::LoudNoiseAddedEvent' has a wrong offset!");
static_assert(offsetof(ULoudNoiseHUDIndicator, _trackedNoises) == 0x000360, "Member 'ULoudNoiseHUDIndicator::_trackedNoises' has a wrong offset!");

// Class DeadByDaylight.ShopCameraManager
// 0x0028 (0x02C8 - 0x02A0)
class AShopCameraManager final : public AActor
{
public:
	struct FNamedButton                           ReloadDBBtn;                                       // 0x02A0(0x0018)(Edit, NativeAccessSpecifierPrivate)
	TArray<struct FRoleGenderCharacterRotation>   CharacterRotation;                                 // 0x02B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShopCameraManager">();
	}
	static class AShopCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShopCameraManager>();
	}
};
static_assert(alignof(AShopCameraManager) == 0x000008, "Wrong alignment on AShopCameraManager");
static_assert(sizeof(AShopCameraManager) == 0x0002C8, "Wrong size on AShopCameraManager");
static_assert(offsetof(AShopCameraManager, ReloadDBBtn) == 0x0002A0, "Member 'AShopCameraManager::ReloadDBBtn' has a wrong offset!");
static_assert(offsetof(AShopCameraManager, CharacterRotation) == 0x0002B8, "Member 'AShopCameraManager::CharacterRotation' has a wrong offset!");

// Class DeadByDaylight.LoudNoiseUtilities
// 0x0000 (0x0030 - 0x0030)
class ULoudNoiseUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoudNoiseUtilities">();
	}
	static class ULoudNoiseUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoudNoiseUtilities>();
	}
};
static_assert(alignof(ULoudNoiseUtilities) == 0x000008, "Wrong alignment on ULoudNoiseUtilities");
static_assert(sizeof(ULoudNoiseUtilities) == 0x000030, "Wrong size on ULoudNoiseUtilities");

// Class DeadByDaylight.LteUIUtilities
// 0x0000 (0x0030 - 0x0030)
class ULteUIUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LteUIUtilities">();
	}
	static class ULteUIUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULteUIUtilities>();
	}
};
static_assert(alignof(ULteUIUtilities) == 0x000008, "Wrong alignment on ULteUIUtilities");
static_assert(sizeof(ULteUIUtilities) == 0x000030, "Wrong size on ULteUIUtilities");

// Class DeadByDaylight.LunarEventComponent
// 0x0048 (0x0100 - 0x00B8)
class ULunarEventComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _lanternCollectedCount;                            // 0x00C8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _additionalEventProgressCount;                     // 0x00CC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x30];                                      // 0x00D0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnCamperEscape(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData);
	void Authority_OnCamperLostLantern(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData);
	void Authority_OnDestroyCamperLightGameEvent(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData);
	void Authority_OnFixGenerator(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData);
	void Authority_OnPickupLantern(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData);
	void Authority_OnPlayerLeaveGame(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData);
	void Authority_OnSlasherDestroysLantern(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData);
	void Local_OnCamperEscape(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData);
	void Local_OnCamperLostLantern(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData);
	void Multicast_ResetLanternLight(class ALanternInteractable* LanternInteractable);
	void OnFinishedPlaying(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData);
	void OnLanternHoldTimerEnd();
	void OnRep_lanternCollectedCount();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LunarEventComponent">();
	}
	static class ULunarEventComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULunarEventComponent>();
	}
};
static_assert(alignof(ULunarEventComponent) == 0x000008, "Wrong alignment on ULunarEventComponent");
static_assert(sizeof(ULunarEventComponent) == 0x000100, "Wrong size on ULunarEventComponent");
static_assert(offsetof(ULunarEventComponent, _lanternCollectedCount) == 0x0000C8, "Member 'ULunarEventComponent::_lanternCollectedCount' has a wrong offset!");
static_assert(offsetof(ULunarEventComponent, _additionalEventProgressCount) == 0x0000CC, "Member 'ULunarEventComponent::_additionalEventProgressCount' has a wrong offset!");

// Class DeadByDaylight.SkillCollectionComponent
// 0x0038 (0x00F0 - 0x00B8)
class USkillCollectionComponent final : public UActorComponent
{
public:
	TArray<class USkill*>                         _array;                                            // 0x00B8(0x0010)(ExportObject, Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x18];                                      // 0x00C8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _characterClassID;                                 // 0x00E0(0x000C)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Array(const TArray<class USkill*>& oldArray);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillCollectionComponent">();
	}
	static class USkillCollectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillCollectionComponent>();
	}
};
static_assert(alignof(USkillCollectionComponent) == 0x000008, "Wrong alignment on USkillCollectionComponent");
static_assert(sizeof(USkillCollectionComponent) == 0x0000F0, "Wrong size on USkillCollectionComponent");
static_assert(offsetof(USkillCollectionComponent, _array) == 0x0000B8, "Member 'USkillCollectionComponent::_array' has a wrong offset!");
static_assert(offsetof(USkillCollectionComponent, _characterClassID) == 0x0000E0, "Member 'USkillCollectionComponent::_characterClassID' has a wrong offset!");

// Class DeadByDaylight.MagicFountain
// 0x0038 (0x03E0 - 0x03A8)
class AMagicFountain final : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AIInteractionOffset;                               // 0x03B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C8[0x10];                                     // 0x03C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isCorrupted;                                      // 0x03D8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D9[0x7];                                      // 0x03D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_SetCorrupted(bool corrupted, class ADBDPlayer* interactingPlayer);

	bool IsCorrupted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagicFountain">();
	}
	static class AMagicFountain* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMagicFountain>();
	}
};
static_assert(alignof(AMagicFountain) == 0x000008, "Wrong alignment on AMagicFountain");
static_assert(sizeof(AMagicFountain) == 0x0003E0, "Wrong size on AMagicFountain");
static_assert(offsetof(AMagicFountain, AIInteractionOffset) == 0x0003B0, "Member 'AMagicFountain::AIInteractionOffset' has a wrong offset!");
static_assert(offsetof(AMagicFountain, _isCorrupted) == 0x0003D8, "Member 'AMagicFountain::_isCorrupted' has a wrong offset!");

// Class DeadByDaylight.MagicFountainOutlineUpdateStrategy
// 0x0018 (0x00F8 - 0x00E0)
class UMagicFountainOutlineUpdateStrategy final : public UOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _outlineColor;                                     // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AMagicFountain*                         _fountain;                                         // 0x00F0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagicFountainOutlineUpdateStrategy">();
	}
	static class UMagicFountainOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMagicFountainOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UMagicFountainOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UMagicFountainOutlineUpdateStrategy");
static_assert(sizeof(UMagicFountainOutlineUpdateStrategy) == 0x0000F8, "Wrong size on UMagicFountainOutlineUpdateStrategy");
static_assert(offsetof(UMagicFountainOutlineUpdateStrategy, _outlineColor) == 0x0000E0, "Member 'UMagicFountainOutlineUpdateStrategy::_outlineColor' has a wrong offset!");
static_assert(offsetof(UMagicFountainOutlineUpdateStrategy, _fountain) == 0x0000F0, "Member 'UMagicFountainOutlineUpdateStrategy::_fountain' has a wrong offset!");

// Class DeadByDaylight.MapActorComponent
// 0x0030 (0x00E8 - 0x00B8)
class UMapActorComponent final : public UActorComponent
{
public:
	EMapActorCategory                             category;                                          // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    _mapActorCollider;                                 // 0x00C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x18];                                      // 0x00C8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _detectionEnabled;                                 // 0x00E0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_SetDetectionEnabled(bool Enabled);

	bool GetDetectionEnabled() const;
	bool IsKnownBy(const class ADBDPlayer* Character) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapActorComponent">();
	}
	static class UMapActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapActorComponent>();
	}
};
static_assert(alignof(UMapActorComponent) == 0x000008, "Wrong alignment on UMapActorComponent");
static_assert(sizeof(UMapActorComponent) == 0x0000E8, "Wrong size on UMapActorComponent");
static_assert(offsetof(UMapActorComponent, category) == 0x0000B8, "Member 'UMapActorComponent::category' has a wrong offset!");
static_assert(offsetof(UMapActorComponent, _mapActorCollider) == 0x0000C0, "Member 'UMapActorComponent::_mapActorCollider' has a wrong offset!");
static_assert(offsetof(UMapActorComponent, _detectionEnabled) == 0x0000E0, "Member 'UMapActorComponent::_detectionEnabled' has a wrong offset!");

// Class DeadByDaylight.RankManager
// 0x00A8 (0x00D8 - 0x0030)
class URankManager final : public UObject
{
public:
	uint8                                         Pad_30[0xA8];                                      // 0x0030(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RankManager">();
	}
	static class URankManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URankManager>();
	}
};
static_assert(alignof(URankManager) == 0x000008, "Wrong alignment on URankManager");
static_assert(sizeof(URankManager) == 0x0000D8, "Wrong size on URankManager");

// Class DeadByDaylight.TriplanarDecalComponent
// 0x0050 (0x0320 - 0x02D0)
class UTriplanarDecalComponent final : public USceneComponent
{
public:
	float                                         MinHeight;                                         // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaskIntensity;                                     // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             TopTexture;                                        // 0x02E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             BottomTexture;                                     // 0x02E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             MaskTexture;                                       // 0x02F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDetailMode                                   MinQualitySetting;                                 // 0x02F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F9[0x7];                                      // 0x02F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDecalComponent*                        _triPlanarDecal;                                   // 0x0300(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClass*                                 _triPlanarDecalClass;                              // 0x0308(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterial*                              _decalMaterial;                                    // 0x0310(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateTriplanarDecal();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TriplanarDecalComponent">();
	}
	static class UTriplanarDecalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTriplanarDecalComponent>();
	}
};
static_assert(alignof(UTriplanarDecalComponent) == 0x000010, "Wrong alignment on UTriplanarDecalComponent");
static_assert(sizeof(UTriplanarDecalComponent) == 0x000320, "Wrong size on UTriplanarDecalComponent");
static_assert(offsetof(UTriplanarDecalComponent, MinHeight) == 0x0002D0, "Member 'UTriplanarDecalComponent::MinHeight' has a wrong offset!");
static_assert(offsetof(UTriplanarDecalComponent, Height) == 0x0002D4, "Member 'UTriplanarDecalComponent::Height' has a wrong offset!");
static_assert(offsetof(UTriplanarDecalComponent, MaskIntensity) == 0x0002D8, "Member 'UTriplanarDecalComponent::MaskIntensity' has a wrong offset!");
static_assert(offsetof(UTriplanarDecalComponent, TopTexture) == 0x0002E0, "Member 'UTriplanarDecalComponent::TopTexture' has a wrong offset!");
static_assert(offsetof(UTriplanarDecalComponent, BottomTexture) == 0x0002E8, "Member 'UTriplanarDecalComponent::BottomTexture' has a wrong offset!");
static_assert(offsetof(UTriplanarDecalComponent, MaskTexture) == 0x0002F0, "Member 'UTriplanarDecalComponent::MaskTexture' has a wrong offset!");
static_assert(offsetof(UTriplanarDecalComponent, MinQualitySetting) == 0x0002F8, "Member 'UTriplanarDecalComponent::MinQualitySetting' has a wrong offset!");
static_assert(offsetof(UTriplanarDecalComponent, _triPlanarDecal) == 0x000300, "Member 'UTriplanarDecalComponent::_triPlanarDecal' has a wrong offset!");
static_assert(offsetof(UTriplanarDecalComponent, _triPlanarDecalClass) == 0x000308, "Member 'UTriplanarDecalComponent::_triPlanarDecalClass' has a wrong offset!");
static_assert(offsetof(UTriplanarDecalComponent, _decalMaterial) == 0x000310, "Member 'UTriplanarDecalComponent::_decalMaterial' has a wrong offset!");

// Class DeadByDaylight.MapActorDB
// 0x0050 (0x0080 - 0x0030)
class UMapActorDB final : public UObject
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<EMapActorCategory> CopyListMinusCategories(const TArray<EMapActorCategory>& Categories, const TArray<EMapActorCategory>& categoriesToRemove) const;
	class AActor* GetRandom(EMapActorCategory category) const;
	TArray<class AActor*> GetUniqueRandom(const TArray<EMapActorCategory>& Categories, int32 Count) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapActorDB">();
	}
	static class UMapActorDB* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapActorDB>();
	}
};
static_assert(alignof(UMapActorDB) == 0x000008, "Wrong alignment on UMapActorDB");
static_assert(sizeof(UMapActorDB) == 0x000080, "Wrong size on UMapActorDB");

// Class DeadByDaylight.MapActorDetectorComponent
// 0x0028 (0x00E0 - 0x00B8)
class UMapActorDetectorComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(class AActor* Actor)> OnActorDetected;                             // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<EMapActorCategory>                     CollectedCategories;                               // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    _primitive;                                        // 0x00D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnOverlapEnter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void SetDetectionPrimitive(class UPrimitiveComponent* Primitive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapActorDetectorComponent">();
	}
	static class UMapActorDetectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapActorDetectorComponent>();
	}
};
static_assert(alignof(UMapActorDetectorComponent) == 0x000008, "Wrong alignment on UMapActorDetectorComponent");
static_assert(sizeof(UMapActorDetectorComponent) == 0x0000E0, "Wrong size on UMapActorDetectorComponent");
static_assert(offsetof(UMapActorDetectorComponent, OnActorDetected) == 0x0000B8, "Member 'UMapActorDetectorComponent::OnActorDetected' has a wrong offset!");
static_assert(offsetof(UMapActorDetectorComponent, CollectedCategories) == 0x0000C8, "Member 'UMapActorDetectorComponent::CollectedCategories' has a wrong offset!");
static_assert(offsetof(UMapActorDetectorComponent, _primitive) == 0x0000D8, "Member 'UMapActorDetectorComponent::_primitive' has a wrong offset!");

// Class DeadByDaylight.TutorialFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UTutorialFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class ATutorialGameMode* GetTutorialGameMode(class UObject* WorldContextObject);
	static class ATutorialGameState* GetTutorialGameState(class UObject* WorldContextObject);
	static class UTutorialHighlightController* GetTutorialHighlightController(class UObject* WorldContextObject);
	static class UTutorialNotificationController* GetTutorialNotificationController(class UObject* WorldContextObject);
	static class UTutorialObjectiveController* GetTutorialObjectiveController(class UObject* WorldContextObject);
	static bool IsInTutorial(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialFunctionLibrary">();
	}
	static class UTutorialFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialFunctionLibrary>();
	}
};
static_assert(alignof(UTutorialFunctionLibrary) == 0x000008, "Wrong alignment on UTutorialFunctionLibrary");
static_assert(sizeof(UTutorialFunctionLibrary) == 0x000030, "Wrong size on UTutorialFunctionLibrary");

// Class DeadByDaylight.MapSpecificSpawnActorsComponent
// 0x0018 (0x00D0 - 0x00B8)
class UMapSpecificSpawnActorsComponent final : public UMapSpecificGameStateComponent
{
public:
	EGameTypeModifierName                         _shouldSpawnModifier;                              // 0x00B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMapSpecificSpawnActorData>     _actorsToSpawn;                                    // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void Authority_OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapSpecificSpawnActorsComponent">();
	}
	static class UMapSpecificSpawnActorsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapSpecificSpawnActorsComponent>();
	}
};
static_assert(alignof(UMapSpecificSpawnActorsComponent) == 0x000008, "Wrong alignment on UMapSpecificSpawnActorsComponent");
static_assert(sizeof(UMapSpecificSpawnActorsComponent) == 0x0000D0, "Wrong size on UMapSpecificSpawnActorsComponent");
static_assert(offsetof(UMapSpecificSpawnActorsComponent, _shouldSpawnModifier) == 0x0000B8, "Member 'UMapSpecificSpawnActorsComponent::_shouldSpawnModifier' has a wrong offset!");
static_assert(offsetof(UMapSpecificSpawnActorsComponent, _actorsToSpawn) == 0x0000C0, "Member 'UMapSpecificSpawnActorsComponent::_actorsToSpawn' has a wrong offset!");

// Class DeadByDaylight.MarketingInvitationPopupManager
// 0x0018 (0x0050 - 0x0038)
class UMarketingInvitationPopupManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarketingInvitationPopupManager">();
	}
	static class UMarketingInvitationPopupManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarketingInvitationPopupManager>();
	}
};
static_assert(alignof(UMarketingInvitationPopupManager) == 0x000008, "Wrong alignment on UMarketingInvitationPopupManager");
static_assert(sizeof(UMarketingInvitationPopupManager) == 0x000050, "Wrong size on UMarketingInvitationPopupManager");

// Class DeadByDaylight.MatchBonusManager
// 0x0018 (0x0050 - 0x0038)
class UMatchBonusManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchBonusManager">();
	}
	static class UMatchBonusManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchBonusManager>();
	}
};
static_assert(alignof(UMatchBonusManager) == 0x000008, "Wrong alignment on UMatchBonusManager");
static_assert(sizeof(UMatchBonusManager) == 0x000050, "Wrong size on UMatchBonusManager");

// Class DeadByDaylight.MatchHandler
// 0x0000 (0x0030 - 0x0030)
class UMatchHandler final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchHandler">();
	}
	static class UMatchHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchHandler>();
	}
};
static_assert(alignof(UMatchHandler) == 0x000008, "Wrong alignment on UMatchHandler");
static_assert(sizeof(UMatchHandler) == 0x000030, "Wrong size on UMatchHandler");

// Class DeadByDaylight.TutorialLevel
// 0x0040 (0x02E8 - 0x02A8)
class ATutorialLevel final : public ALevelScriptActor
{
public:
	bool                                          _tutorialStarted;                                  // 0x02A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A9[0x3F];                                     // 0x02A9(0x003F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddObjective(class FName ObjectiveId);
	void CompleteObjective(class FName ObjectiveId);
	void DisplayBlockingNotification(class FName notificationId);
	void DisplayNotification(class FName notificationId, float Time);
	void HandleNotificationDismissed(class FName notificationId);
	void HandleTutorialStepReached();
	void OnNotificationDismissed(class FName notificationId);
	void OnTutorialStepUpdated(ETutorialStep tutorialStep);
	void RemoveObjective(class FName ObjectiveId);
	void SetHandledTutorialStep(ETutorialStep tutorialStep);
	void StartTutorial();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialLevel">();
	}
	static class ATutorialLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATutorialLevel>();
	}
};
static_assert(alignof(ATutorialLevel) == 0x000008, "Wrong alignment on ATutorialLevel");
static_assert(sizeof(ATutorialLevel) == 0x0002E8, "Wrong size on ATutorialLevel");
static_assert(offsetof(ATutorialLevel, _tutorialStarted) == 0x0002A8, "Member 'ATutorialLevel::_tutorialStarted' has a wrong offset!");

// Class DeadByDaylight.MatchIncentivesManager
// 0x0078 (0x00B0 - 0x0038)
class UMatchIncentivesManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x78];                                      // 0x0038(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchIncentivesManager">();
	}
	static class UMatchIncentivesManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchIncentivesManager>();
	}
};
static_assert(alignof(UMatchIncentivesManager) == 0x000008, "Wrong alignment on UMatchIncentivesManager");
static_assert(sizeof(UMatchIncentivesManager) == 0x0000B0, "Wrong size on UMatchIncentivesManager");

// Class DeadByDaylight.MatchmakingFlowSubsystem
// 0x0120 (0x0158 - 0x0038)
class UMatchmakingFlowSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x120];                                     // 0x0038(0x0120)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchmakingFlowSubsystem">();
	}
	static class UMatchmakingFlowSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchmakingFlowSubsystem>();
	}
};
static_assert(alignof(UMatchmakingFlowSubsystem) == 0x000008, "Wrong alignment on UMatchmakingFlowSubsystem");
static_assert(sizeof(UMatchmakingFlowSubsystem) == 0x000158, "Wrong size on UMatchmakingFlowSubsystem");

// Class DeadByDaylight.MatchManagementScreen
// 0x00D8 (0x0200 - 0x0128)
class UMatchManagementScreen final : public UScreenBase
{
public:
	uint8                                         Pad_128[0xD8];                                     // 0x0128(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAddMap(const class FString& MapId);
	void OnAllowDlcSettingsClick();
	void OnAllowIdleCrowsSettingsClick();
	void OnApplyChangesClicked();
	void OnBackButtonClick();
	void OnItemsAndAddonsSettingsChange(int32 Value);
	void OnOfferingsSettingsChange(int32 Value);
	void OnPerksSettingsChange(int32 Value);
	void OnRemoveMap(const class FString& MapId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchManagementScreen">();
	}
	static class UMatchManagementScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchManagementScreen>();
	}
};
static_assert(alignof(UMatchManagementScreen) == 0x000008, "Wrong alignment on UMatchManagementScreen");
static_assert(sizeof(UMatchManagementScreen) == 0x000200, "Wrong size on UMatchManagementScreen");

// Class DeadByDaylight.StatusView
// 0x0078 (0x0318 - 0x02A0)
class AStatusView : public AActor
{
public:
	uint8                                         Pad_2A0[0x60];                                     // 0x02A0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _localDBDPlayer;                                   // 0x0300(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0x10];                                     // 0x0308(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusView">();
	}
	static class AStatusView* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStatusView>();
	}
};
static_assert(alignof(AStatusView) == 0x000008, "Wrong alignment on AStatusView");
static_assert(sizeof(AStatusView) == 0x000318, "Wrong size on AStatusView");
static_assert(offsetof(AStatusView, _localDBDPlayer) == 0x000300, "Member 'AStatusView::_localDBDPlayer' has a wrong offset!");

// Class DeadByDaylight.RepairDependantPerkInterface
// 0x0000 (0x0000 - 0x0000)
class IRepairDependantPerkInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RepairDependantPerkInterface">();
	}
	static class IRepairDependantPerkInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRepairDependantPerkInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IRepairDependantPerkInterface) == 0x000001, "Wrong alignment on IRepairDependantPerkInterface");
static_assert(sizeof(IRepairDependantPerkInterface) == 0x000001, "Wrong size on IRepairDependantPerkInterface");

// Class DeadByDaylight.TwinsMoriAnimationPreview
// 0x0000 (0x0188 - 0x0188)
class UTwinsMoriAnimationPreview final : public UMoriAnimationPreview
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinsMoriAnimationPreview">();
	}
	static class UTwinsMoriAnimationPreview* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinsMoriAnimationPreview>();
	}
};
static_assert(alignof(UTwinsMoriAnimationPreview) == 0x000008, "Wrong alignment on UTwinsMoriAnimationPreview");
static_assert(sizeof(UTwinsMoriAnimationPreview) == 0x000188, "Wrong size on UTwinsMoriAnimationPreview");

// Class DeadByDaylight.ModifierBasedStatusView
// 0x0030 (0x0348 - 0x0318)
class AModifierBasedStatusView : public AStatusView
{
public:
	struct FGameplayTag                           _modifierTag;                                      // 0x0318(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EStatusViewDisplayValueType                   _displayValueType;                                 // 0x0324(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_325[0x23];                                     // 0x0325(0x0023)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModifierBasedStatusView">();
	}
	static class AModifierBasedStatusView* GetDefaultObj()
	{
		return GetDefaultObjImpl<AModifierBasedStatusView>();
	}
};
static_assert(alignof(AModifierBasedStatusView) == 0x000008, "Wrong alignment on AModifierBasedStatusView");
static_assert(sizeof(AModifierBasedStatusView) == 0x000348, "Wrong size on AModifierBasedStatusView");
static_assert(offsetof(AModifierBasedStatusView, _modifierTag) == 0x000318, "Member 'AModifierBasedStatusView::_modifierTag' has a wrong offset!");
static_assert(offsetof(AModifierBasedStatusView, _displayValueType) == 0x000324, "Member 'AModifierBasedStatusView::_displayValueType' has a wrong offset!");

// Class DeadByDaylight.MaxModifierValueStatusView
// 0x0000 (0x0348 - 0x0348)
class AMaxModifierValueStatusView final : public AModifierBasedStatusView
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaxModifierValueStatusView">();
	}
	static class AMaxModifierValueStatusView* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMaxModifierValueStatusView>();
	}
};
static_assert(alignof(AMaxModifierValueStatusView) == 0x000008, "Wrong alignment on AMaxModifierValueStatusView");
static_assert(sizeof(AMaxModifierValueStatusView) == 0x000348, "Wrong size on AMaxModifierValueStatusView");

// Class DeadByDaylight.MeatHook
// 0x0318 (0x06C0 - 0x03A8)
class AMeatHook final : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x68];                                     // 0x03A8(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          WasSurvivorStruggleCancelled;                      // 0x0410(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSacrificeEnabled;                                // 0x0411(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_412[0x6];                                      // 0x0412(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AIInteractionOffset;                               // 0x0418(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_430[0x60];                                     // 0x0430(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDBDClipRegionComponent*>        ClipRegions;                                       // 0x0490(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          IsSurvivorStruggling;                              // 0x04A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsInBasement;                                      // 0x04A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsBreakable;                                       // 0x04A2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsSabotageable;                                    // 0x04A3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CanBeScourgeHook;                                  // 0x04A4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A5[0x3];                                      // 0x04A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           HookIdentityTag;                                   // 0x04A8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          SnapHookedCharacter;                               // 0x04B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FullyHooked;                                       // 0x04B5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B6[0x2];                                      // 0x04B6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _struggleThreshold;                                // 0x04B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4BC[0x4];                                      // 0x04BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterPusherComponent*              _characterPusher;                                  // 0x04C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      _slasherCollisionBlocker;                          // 0x04C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      _conditionalSlasherCollisionBlocker;               // 0x04D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  _conditionalSlasherCollisionBlockerPresenceTags;   // 0x04D8(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  _stateTagsToApplyOnBeginPlay;                      // 0x04F8(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _sacrificedHookRespawnDuration;                    // 0x0518(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UPollableEventListener*                 _eventListener;                                    // 0x0540(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ASurvivor*                              _hookedSurvivor;                                   // 0x0548(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDPlayer*                             _hookBreakerPlayer;                                // 0x0550(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_558[0x68];                                     // 0x0558(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class ASurvivor*>                        _campersThatSabotagedMeatHook;                     // 0x05C0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class UInteractor*                            _mainInteractor;                                   // 0x0610(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableInteractionDefinition*       _unhook;                                           // 0x0618(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        _camperHookedSnapTransform;                        // 0x0620(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AEntity*                                _entity;                                           // 0x0628(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_630[0x20];                                     // 0x0630(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIPerceptionStimuliSourceComponent*    _perceptionStimuliComponent;                       // 0x0650(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDPlayer*                             _interactingPlayer;                                // 0x0658(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMapActorComponent*                     _cachedMapActor;                                   // 0x0660(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_668[0x58];                                     // 0x0668(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_SetHookedSurvivor(class ASurvivor* Survivor);
	void Authority_SetIsBrokenFromUnhook(bool isBrokenFromUnhook, class ADBDPlayer* hookBreaker, float overrideBaseHookRespawnDuration);
	void Authority_SetIsSabotaged(bool isSabotaged, class ADBDPlayer* Saboteur, bool useCamperHookRespawnDurationModifiers, float overrideBaseHookRespawnDuration);
	void Authority_SetIsSacrificed(bool isSacrificed);
	void Authority_SignalSurvivorAttemptingEscape();
	void Authority_SignalSurvivorAttemptingEscapeAborted();
	void Authority_SignalUnhookingAborted();
	void Authority_SignalUnhookingCharged();
	void Authority_SignalUnhookingEnter();
	void BP_OnHookInteractionStarted();
	void BroadcastUnhook(class ADBDPlayer* rescuer);
	void Cosmetic_StartScourgeHookVFX(bool isNewScourgeHook);
	void Cosmetic_StopScourgeHookVFX();
	class UChargeableComponent* GetUnhookChargeableComponent();
	void Local_MoveSurvivorToHook(class ASurvivor* Survivor, const float Duration);
	void Multicast_EscapeAttemptResult(class ADBDPlayer* Player, bool Result);
	void Multicast_RefreshCharmCustomization();
	void Multicast_SetHookedSurvivor(class ASurvivor* Survivor);
	void Multicast_SetIsBrokenFromUnhook(bool setIsBrokendFromUnhook, class ADBDPlayer* hookBreaker, float overrideBaseHookRespawnDuration);
	void Multicast_SetIsSabotaged(bool setIsSabotaged, class ADBDPlayer* hookBreaker, bool useCamperHookRespawnDurationModifiers, float overrideBaseHookRespawnDuration);
	void Multicast_SetIsSacrificed(bool isSacrificed);
	void OnAutoRepair();
	void OnHookedEnter();
	void OnHookedExit();
	void OnHookedIdle();
	void OnHookedSurvivorAttacked();
	void OnHookedSurvivorChanged(class ASurvivor* before, class ASurvivor* after);
	void OnHookingEnter();
	void OnHookingExit();
	void OnOwnerReplicated();
	void OnReaction();
	void OnReactionIn();
	void OnSacrificeIn();
	void OnSacrificeOut();
	void OnStartPushingPlayer(class ACharacter* Character);
	void OnStopPushingPlayer(class ACharacter* Character);
	void OnStruggleEnter();
	void OnStruggleExit();
	void OnStruggleSkillCheckFailed_Cosmetic();
	void OnTickStruggle(float DeltaTime);
	void SetEntity(class AEntity* Entity);
	void SetInteractingPlayer(class ADBDPlayer* interactingPlayer);
	void SetIsBeingSabotaged(bool isBeingSabotaged);
	void SetMapActor(class UMapActorComponent* Value);
	void UpdateSlasherBlockerCollision();

	bool CanBeSabotaged() const;
	bool CanHookSurvivor() const;
	bool CanSurvivorAttemptEscape(const class ASurvivor* Survivor) const;
	bool CanSurvivorStruggle(class ASurvivor* Survivor) const;
	bool CanUnhookSurvivor(const class ASurvivor* Survivor) const;
	void DebugHookedSurvivor(class ASurvivor* expectedSurvivor) const;
	void FireHookSoundEvent(const class FName NoiseRangeTunable, const class ADBDPlayer* soundInstigator) const;
	class USceneComponent* GetCamperHookedSnapTransform() const;
	class USceneComponent* GetCamperUnkookFocalPointTransform() const;
	class UCharacterPusherComponent* GetCharacterPusher() const;
	class UChargeableInteractionDefinition* GetEscapeHookInteraction() const;
	class UHookableComponent* GetHookableComponentOfHookedActor() const;
	class ASurvivor* GetHookedSurvivor() const;
	class UShapeComponent* GetHookObstacleZoneComponent() const;
	struct FVector GetHookPosition() const;
	class ADBDPlayer* GetInteractingPlayer() const;
	class UPrimitiveComponent* GetInteractorPrimitiveComponent() const;
	class UBoxComponent* GetInteractorZoneComponent() const;
	bool GetIsBroken() const;
	bool GetIsInBasement() const;
	bool GetIsSabotaged() const;
	bool GetIsSacrificed() const;
	class UInteractor* GetMainInteractor() const;
	class UAkComponent* GetMeatHookAkAudioComponent() const;
	class UMontagePlayer* GetMontagePlayer() const;
	float GetSabotageHookRespawnDuration() const;
	class ADBDPlayer* GetSaboteurPlayer() const;
	TArray<class USceneComponent*> GetSnapPointsArray() const;
	float GetStrugglePercent() const;
	float GetStruggleThreshold() const;
	struct FAnimationMontageDescriptor GetUnhookInMontageDescriptor() const;
	class UChargeableInteractionDefinition* GetUnhookInteraction() const;
	struct FAnimationMontageDescriptor GetUnhookOutMontageDescriptor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeatHook">();
	}
	static class AMeatHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMeatHook>();
	}
};
static_assert(alignof(AMeatHook) == 0x000008, "Wrong alignment on AMeatHook");
static_assert(sizeof(AMeatHook) == 0x0006C0, "Wrong size on AMeatHook");
static_assert(offsetof(AMeatHook, WasSurvivorStruggleCancelled) == 0x000410, "Member 'AMeatHook::WasSurvivorStruggleCancelled' has a wrong offset!");
static_assert(offsetof(AMeatHook, IsSacrificeEnabled) == 0x000411, "Member 'AMeatHook::IsSacrificeEnabled' has a wrong offset!");
static_assert(offsetof(AMeatHook, AIInteractionOffset) == 0x000418, "Member 'AMeatHook::AIInteractionOffset' has a wrong offset!");
static_assert(offsetof(AMeatHook, ClipRegions) == 0x000490, "Member 'AMeatHook::ClipRegions' has a wrong offset!");
static_assert(offsetof(AMeatHook, IsSurvivorStruggling) == 0x0004A0, "Member 'AMeatHook::IsSurvivorStruggling' has a wrong offset!");
static_assert(offsetof(AMeatHook, IsInBasement) == 0x0004A1, "Member 'AMeatHook::IsInBasement' has a wrong offset!");
static_assert(offsetof(AMeatHook, IsBreakable) == 0x0004A2, "Member 'AMeatHook::IsBreakable' has a wrong offset!");
static_assert(offsetof(AMeatHook, IsSabotageable) == 0x0004A3, "Member 'AMeatHook::IsSabotageable' has a wrong offset!");
static_assert(offsetof(AMeatHook, CanBeScourgeHook) == 0x0004A4, "Member 'AMeatHook::CanBeScourgeHook' has a wrong offset!");
static_assert(offsetof(AMeatHook, HookIdentityTag) == 0x0004A8, "Member 'AMeatHook::HookIdentityTag' has a wrong offset!");
static_assert(offsetof(AMeatHook, SnapHookedCharacter) == 0x0004B4, "Member 'AMeatHook::SnapHookedCharacter' has a wrong offset!");
static_assert(offsetof(AMeatHook, FullyHooked) == 0x0004B5, "Member 'AMeatHook::FullyHooked' has a wrong offset!");
static_assert(offsetof(AMeatHook, _struggleThreshold) == 0x0004B8, "Member 'AMeatHook::_struggleThreshold' has a wrong offset!");
static_assert(offsetof(AMeatHook, _characterPusher) == 0x0004C0, "Member 'AMeatHook::_characterPusher' has a wrong offset!");
static_assert(offsetof(AMeatHook, _slasherCollisionBlocker) == 0x0004C8, "Member 'AMeatHook::_slasherCollisionBlocker' has a wrong offset!");
static_assert(offsetof(AMeatHook, _conditionalSlasherCollisionBlocker) == 0x0004D0, "Member 'AMeatHook::_conditionalSlasherCollisionBlocker' has a wrong offset!");
static_assert(offsetof(AMeatHook, _conditionalSlasherCollisionBlockerPresenceTags) == 0x0004D8, "Member 'AMeatHook::_conditionalSlasherCollisionBlockerPresenceTags' has a wrong offset!");
static_assert(offsetof(AMeatHook, _stateTagsToApplyOnBeginPlay) == 0x0004F8, "Member 'AMeatHook::_stateTagsToApplyOnBeginPlay' has a wrong offset!");
static_assert(offsetof(AMeatHook, _sacrificedHookRespawnDuration) == 0x000518, "Member 'AMeatHook::_sacrificedHookRespawnDuration' has a wrong offset!");
static_assert(offsetof(AMeatHook, _eventListener) == 0x000540, "Member 'AMeatHook::_eventListener' has a wrong offset!");
static_assert(offsetof(AMeatHook, _hookedSurvivor) == 0x000548, "Member 'AMeatHook::_hookedSurvivor' has a wrong offset!");
static_assert(offsetof(AMeatHook, _hookBreakerPlayer) == 0x000550, "Member 'AMeatHook::_hookBreakerPlayer' has a wrong offset!");
static_assert(offsetof(AMeatHook, _campersThatSabotagedMeatHook) == 0x0005C0, "Member 'AMeatHook::_campersThatSabotagedMeatHook' has a wrong offset!");
static_assert(offsetof(AMeatHook, _mainInteractor) == 0x000610, "Member 'AMeatHook::_mainInteractor' has a wrong offset!");
static_assert(offsetof(AMeatHook, _unhook) == 0x000618, "Member 'AMeatHook::_unhook' has a wrong offset!");
static_assert(offsetof(AMeatHook, _camperHookedSnapTransform) == 0x000620, "Member 'AMeatHook::_camperHookedSnapTransform' has a wrong offset!");
static_assert(offsetof(AMeatHook, _entity) == 0x000628, "Member 'AMeatHook::_entity' has a wrong offset!");
static_assert(offsetof(AMeatHook, _perceptionStimuliComponent) == 0x000650, "Member 'AMeatHook::_perceptionStimuliComponent' has a wrong offset!");
static_assert(offsetof(AMeatHook, _interactingPlayer) == 0x000658, "Member 'AMeatHook::_interactingPlayer' has a wrong offset!");
static_assert(offsetof(AMeatHook, _cachedMapActor) == 0x000660, "Member 'AMeatHook::_cachedMapActor' has a wrong offset!");

// Class DeadByDaylight.MeatHookAnimInstance
// 0x0010 (0x0360 - 0x0350)
class UMeatHookAnimInstance final : public UAnimInstance
{
public:
	bool                                          IsBroken;                                          // 0x0350(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_351[0x3];                                      // 0x0351(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Yaw;                                               // 0x0354(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsSurvivorStruggling;                              // 0x0358(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_359[0x7];                                      // 0x0359(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeatHookAnimInstance">();
	}
	static class UMeatHookAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeatHookAnimInstance>();
	}
};
static_assert(alignof(UMeatHookAnimInstance) == 0x000010, "Wrong alignment on UMeatHookAnimInstance");
static_assert(sizeof(UMeatHookAnimInstance) == 0x000360, "Wrong size on UMeatHookAnimInstance");
static_assert(offsetof(UMeatHookAnimInstance, IsBroken) == 0x000350, "Member 'UMeatHookAnimInstance::IsBroken' has a wrong offset!");
static_assert(offsetof(UMeatHookAnimInstance, Yaw) == 0x000354, "Member 'UMeatHookAnimInstance::Yaw' has a wrong offset!");
static_assert(offsetof(UMeatHookAnimInstance, IsSurvivorStruggling) == 0x000358, "Member 'UMeatHookAnimInstance::IsSurvivorStruggling' has a wrong offset!");

// Class DeadByDaylight.PlagueUtilities
// 0x0000 (0x0030 - 0x0030)
class UPlagueUtilities final : public UBlueprintFunctionLibrary
{
public:
	static void Authority_AddSicknessToPlayer(class ADBDPlayer* Player, float sicknessToAdd);
	static void Authority_CorruptRandomFountain(class UObject* WorldContext);
	static TArray<class AMagicFountain*> GetAllFountains(class UObject* WorldContext);
	static TArray<class AMagicFountain*> GetCleanFountains(class UObject* WorldContext);
	static TArray<class AMagicFountain*> GetCorruptedFountains(class UObject* WorldContext);
	static class USurvivorPlagueEffect* GetPlagueEffect(const class ADBDPlayer* Player);
	static bool HasMaxLevelSickness(const class ADBDPlayer* Player);
	static bool IsInfected(const class ADBDPlayer* Player);
	static bool IsPlagueDebugModeActive();
	static bool IsSuperVomitActive(const class ADBDPlayer* Player);
	static bool SurvivorCanBeSickened(const class ASurvivor* Survivor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlagueUtilities">();
	}
	static class UPlagueUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlagueUtilities>();
	}
};
static_assert(alignof(UPlagueUtilities) == 0x000008, "Wrong alignment on UPlagueUtilities");
static_assert(sizeof(UPlagueUtilities) == 0x000030, "Wrong size on UPlagueUtilities");

// Class DeadByDaylight.MeatHookEntityVisibilityComponent
// 0x0030 (0x00E8 - 0x00B8)
class UMeatHookEntityVisibilityComponent final : public UActorComponent
{
public:
	class AEntity*                                _entity;                                           // 0x00B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x1C];                                      // 0x00C0(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _entityReappearSpeed;                              // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _entityDisappearSpeed;                             // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeatHookEntityVisibilityComponent">();
	}
	static class UMeatHookEntityVisibilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeatHookEntityVisibilityComponent>();
	}
};
static_assert(alignof(UMeatHookEntityVisibilityComponent) == 0x000008, "Wrong alignment on UMeatHookEntityVisibilityComponent");
static_assert(sizeof(UMeatHookEntityVisibilityComponent) == 0x0000E8, "Wrong size on UMeatHookEntityVisibilityComponent");
static_assert(offsetof(UMeatHookEntityVisibilityComponent, _entity) == 0x0000B8, "Member 'UMeatHookEntityVisibilityComponent::_entity' has a wrong offset!");
static_assert(offsetof(UMeatHookEntityVisibilityComponent, _entityReappearSpeed) == 0x0000DC, "Member 'UMeatHookEntityVisibilityComponent::_entityReappearSpeed' has a wrong offset!");
static_assert(offsetof(UMeatHookEntityVisibilityComponent, _entityDisappearSpeed) == 0x0000E0, "Member 'UMeatHookEntityVisibilityComponent::_entityDisappearSpeed' has a wrong offset!");

// Class DeadByDaylight.MeatHookOutlineUpdateStrategy
// 0x0040 (0x01A0 - 0x0160)
class UMeatHookOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _hookedOutlineColorKiller;                         // 0x0160(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _carryingOutlineColorKiller;                       // 0x0170(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _defaultOutlineColorKiller;                        // 0x0180(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _visibleOutlineColorSurvivor;                      // 0x0190(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_AddBasementHookToPlayerMapItem();
	void Local_AddBasementOfferingReveal();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeatHookOutlineUpdateStrategy">();
	}
	static class UMeatHookOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeatHookOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UMeatHookOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UMeatHookOutlineUpdateStrategy");
static_assert(sizeof(UMeatHookOutlineUpdateStrategy) == 0x0001A0, "Wrong size on UMeatHookOutlineUpdateStrategy");
static_assert(offsetof(UMeatHookOutlineUpdateStrategy, _hookedOutlineColorKiller) == 0x000160, "Member 'UMeatHookOutlineUpdateStrategy::_hookedOutlineColorKiller' has a wrong offset!");
static_assert(offsetof(UMeatHookOutlineUpdateStrategy, _carryingOutlineColorKiller) == 0x000170, "Member 'UMeatHookOutlineUpdateStrategy::_carryingOutlineColorKiller' has a wrong offset!");
static_assert(offsetof(UMeatHookOutlineUpdateStrategy, _defaultOutlineColorKiller) == 0x000180, "Member 'UMeatHookOutlineUpdateStrategy::_defaultOutlineColorKiller' has a wrong offset!");
static_assert(offsetof(UMeatHookOutlineUpdateStrategy, _visibleOutlineColorSurvivor) == 0x000190, "Member 'UMeatHookOutlineUpdateStrategy::_visibleOutlineColorSurvivor' has a wrong offset!");

// Class DeadByDaylight.MemoryTracker
// 0x0000 (0x02A0 - 0x02A0)
class AMemoryTracker final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MemoryTracker">();
	}
	static class AMemoryTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMemoryTracker>();
	}
};
static_assert(alignof(AMemoryTracker) == 0x000008, "Wrong alignment on AMemoryTracker");
static_assert(sizeof(AMemoryTracker) == 0x0002A0, "Wrong size on AMemoryTracker");

// Class DeadByDaylight.PlayerDebugComponent
// 0x0008 (0x00C0 - 0x00B8)
class UPlayerDebugComponent final : public UActorComponent
{
public:
	bool                                          _disableStartUpdateMontageDuringEnter;             // 0x00B8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _allowPalletPullUpInteraction;                     // 0x00B9(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BA[0x6];                                       // 0x00BA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerDebugComponent">();
	}
	static class UPlayerDebugComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerDebugComponent>();
	}
};
static_assert(alignof(UPlayerDebugComponent) == 0x000008, "Wrong alignment on UPlayerDebugComponent");
static_assert(sizeof(UPlayerDebugComponent) == 0x0000C0, "Wrong size on UPlayerDebugComponent");
static_assert(offsetof(UPlayerDebugComponent, _disableStartUpdateMontageDuringEnter) == 0x0000B8, "Member 'UPlayerDebugComponent::_disableStartUpdateMontageDuringEnter' has a wrong offset!");
static_assert(offsetof(UPlayerDebugComponent, _allowPalletPullUpInteraction) == 0x0000B9, "Member 'UPlayerDebugComponent::_allowPalletPullUpInteraction' has a wrong offset!");

// Class DeadByDaylight.MenuAssetLibrary
// 0x0010 (0x0130 - 0x0120)
class UMenuAssetLibrary final : public UItemsAssetLibrary
{
public:
	uint8                                         Pad_120[0x10];                                     // 0x0120(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuAssetLibrary">();
	}
	static class UMenuAssetLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuAssetLibrary>();
	}
};
static_assert(alignof(UMenuAssetLibrary) == 0x000008, "Wrong alignment on UMenuAssetLibrary");
static_assert(sizeof(UMenuAssetLibrary) == 0x000130, "Wrong size on UMenuAssetLibrary");

// Class DeadByDaylight.MenuCameraActor
// 0x0100 (0x0AB0 - 0x09B0)
class AMenuCameraActor : public ACameraActor
{
public:
	uint8                                         Pad_9B0[0x100];                                    // 0x09B0(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanTransition();
	void K2_TransitionFinished(EDBDCameraViewType View);
	void K2_TransitionStarted(EDBDCameraViewType View);

	EDBDCameraViewType GetActiveView() const;
	struct FMenuCameraView GetTransitionInitView() const;
	struct FMenuCameraView GetTransitionTargetView() const;
	bool TransitionInProgress() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuCameraActor">();
	}
	static class AMenuCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMenuCameraActor>();
	}
};
static_assert(alignof(AMenuCameraActor) == 0x000010, "Wrong alignment on AMenuCameraActor");
static_assert(sizeof(AMenuCameraActor) == 0x000AB0, "Wrong size on AMenuCameraActor");

// Class DeadByDaylight.MenuCameraDesignTunables
// 0x0060 (0x0098 - 0x0038)
class UMenuCameraDesignTunables final : public UDataAsset
{
public:
	TSubclassOf<class AMenuCameraActor>           CameraClass;                                       // 0x0038(0x0008)(Edit, ZeroConstructor, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            TransitionCurve;                                   // 0x0040(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EDBDCameraViewType, struct FMenuCameraView> Views;                                          // 0x0048(0x0050)(Edit, EditFixedSize, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuCameraDesignTunables">();
	}
	static class UMenuCameraDesignTunables* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuCameraDesignTunables>();
	}
};
static_assert(alignof(UMenuCameraDesignTunables) == 0x000008, "Wrong alignment on UMenuCameraDesignTunables");
static_assert(sizeof(UMenuCameraDesignTunables) == 0x000098, "Wrong size on UMenuCameraDesignTunables");
static_assert(offsetof(UMenuCameraDesignTunables, CameraClass) == 0x000038, "Member 'UMenuCameraDesignTunables::CameraClass' has a wrong offset!");
static_assert(offsetof(UMenuCameraDesignTunables, TransitionCurve) == 0x000040, "Member 'UMenuCameraDesignTunables::TransitionCurve' has a wrong offset!");
static_assert(offsetof(UMenuCameraDesignTunables, Views) == 0x000048, "Member 'UMenuCameraDesignTunables::Views' has a wrong offset!");

// Class DeadByDaylight.PlayerJoinWatchdog
// 0x0080 (0x00B8 - 0x0038)
class UPlayerJoinWatchdog final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x80];                                      // 0x0038(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayerStateAdded(class APlayerState* PlayerState);
	void OnPlayerStateRemoved(class APlayerState* PlayerState);
	void OnPlayerStateUpdated(class ADBDPlayerState* DBDPlayerState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerJoinWatchdog">();
	}
	static class UPlayerJoinWatchdog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerJoinWatchdog>();
	}
};
static_assert(alignof(UPlayerJoinWatchdog) == 0x000008, "Wrong alignment on UPlayerJoinWatchdog");
static_assert(sizeof(UPlayerJoinWatchdog) == 0x0000B8, "Wrong size on UPlayerJoinWatchdog");

// Class DeadByDaylight.MenuCameraSystem
// 0x00A0 (0x00D8 - 0x0038)
class UMenuCameraSystem final : public UWorldSubsystem
{
public:
	class UMenuCameraDesignTunables*              _tunables;                                         // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AMenuCameraActor*                       _cameraTarget;                                     // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EDBDCameraViewType, class ACameraActor*> _reservedTargets;                                  // 0x0048(0x0050)(Transient, NativeAccessSpecifierPrivate)
	EDBDCameraViewType                            _currentViewType;                                  // 0x0098(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FMenuCameraTransitionParams& params)> _onTransitionStart; // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x18];                                      // 0x00B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(EDBDCameraViewType View)> _onTransitionFinishedBP;                 // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	bool Transition(const struct FMenuCameraTransitionParams& params);

	bool CanTransition() const;
	EDBDCameraViewType GetActiveViewType() const;
	class UCameraComponent* GetCamera() const;
	EDBDCameraViewType GetCurrentCameraViewType() const;
	struct FMenuCameraView GetTransitionInitView() const;
	struct FMenuCameraView GetTransitionTargetView() const;
	bool IsTransitionInProgress() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuCameraSystem">();
	}
	static class UMenuCameraSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuCameraSystem>();
	}
};
static_assert(alignof(UMenuCameraSystem) == 0x000008, "Wrong alignment on UMenuCameraSystem");
static_assert(sizeof(UMenuCameraSystem) == 0x0000D8, "Wrong size on UMenuCameraSystem");
static_assert(offsetof(UMenuCameraSystem, _tunables) == 0x000038, "Member 'UMenuCameraSystem::_tunables' has a wrong offset!");
static_assert(offsetof(UMenuCameraSystem, _cameraTarget) == 0x000040, "Member 'UMenuCameraSystem::_cameraTarget' has a wrong offset!");
static_assert(offsetof(UMenuCameraSystem, _reservedTargets) == 0x000048, "Member 'UMenuCameraSystem::_reservedTargets' has a wrong offset!");
static_assert(offsetof(UMenuCameraSystem, _currentViewType) == 0x000098, "Member 'UMenuCameraSystem::_currentViewType' has a wrong offset!");
static_assert(offsetof(UMenuCameraSystem, _onTransitionStart) == 0x0000A0, "Member 'UMenuCameraSystem::_onTransitionStart' has a wrong offset!");
static_assert(offsetof(UMenuCameraSystem, _onTransitionFinishedBP) == 0x0000C8, "Member 'UMenuCameraSystem::_onTransitionFinishedBP' has a wrong offset!");

// Class DeadByDaylight.MenuMeatHook
// 0x0028 (0x02C8 - 0x02A0)
class AMenuMeatHook final : public AActor
{
public:
	uint8                                         Pad_2A0[0x10];                                     // 0x02A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharmSpawnerComponent*                 _charmSpawnerComponent;                            // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x10];                                     // 0x02B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginDestroySequence_Internal();
	void OnCharmsUpdated(const TArray<struct FCharmIdSlot>& charmIDs);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuMeatHook">();
	}
	static class AMenuMeatHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMenuMeatHook>();
	}
};
static_assert(alignof(AMenuMeatHook) == 0x000008, "Wrong alignment on AMenuMeatHook");
static_assert(sizeof(AMenuMeatHook) == 0x0002C8, "Wrong size on AMenuMeatHook");
static_assert(offsetof(AMenuMeatHook, _charmSpawnerComponent) == 0x0002B0, "Member 'AMenuMeatHook::_charmSpawnerComponent' has a wrong offset!");

// Class DeadByDaylight.MenuUtilities
// 0x0000 (0x0030 - 0x0030)
class UMenuUtilities final : public UBlueprintFunctionLibrary
{
public:
	static bool AreAllGuestCharactersReady();
	static TArray<class ADBDMenuPlayer*> GetAllMenuCharacters();
	static class ADBDMenuPlayer* GetLocalPlayerCharacter(const class UObject* contextObject);
	static class UMenuCameraSystem* GetMenuCameraSystem(const class UObject* contextObject);
	static bool IsInArchive(const class UObject* contextObject);
	static bool IsInChallenges(const class UObject* contextObject);
	static bool IsInGame(const class UObject* contextObject);
	static bool IsInRift(const class UObject* contextObject);
	static bool IsInSomeLobby(const class UObject* contextObject);
	static bool IsInStore(const class UObject* contextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuUtilities">();
	}
	static class UMenuUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuUtilities>();
	}
};
static_assert(alignof(UMenuUtilities) == 0x000008, "Wrong alignment on UMenuUtilities");
static_assert(sizeof(UMenuUtilities) == 0x000030, "Wrong size on UMenuUtilities");

// Class DeadByDaylight.MigrationSubsystem
// 0x0058 (0x0090 - 0x0038)
class UMigrationSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x58];                                      // 0x0038(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MigrationSubsystem">();
	}
	static class UMigrationSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMigrationSubsystem>();
	}
};
static_assert(alignof(UMigrationSubsystem) == 0x000008, "Wrong alignment on UMigrationSubsystem");
static_assert(sizeof(UMigrationSubsystem) == 0x000090, "Wrong size on UMigrationSubsystem");

// Class DeadByDaylight.MobileProfileDAL
// 0x0000 (0x0088 - 0x0088)
class UMobileProfileDAL final : public UPlayerProfileDAL
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MobileProfileDAL">();
	}
	static class UMobileProfileDAL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMobileProfileDAL>();
	}
};
static_assert(alignof(UMobileProfileDAL) == 0x000008, "Wrong alignment on UMobileProfileDAL");
static_assert(sizeof(UMobileProfileDAL) == 0x000088, "Wrong size on UMobileProfileDAL");

// Class DeadByDaylight.MontagePlayer
// 0x01C8 (0x0280 - 0x00B8)
class UMontagePlayer final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(const struct FAnimationMontageDescriptor& animMontageID, const float PlayRate)> OnMontageStarted; // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x48];                                      // 0x00C8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FAnimationMontageDescriptor& animMontageID, bool interrupted)> OnMontageEnded; // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_120[0x30];                                     // 0x0120(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UAnimMontage* AnimMontage, bool interrupted)> BPOnMontageBlendingOut; // 0x0150(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_160[0x30];                                     // 0x0160(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FContextualAnimationMapping>    _contextualAnimationMappings;                      // 0x0190(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UAnimMontage*                           _currentlyPlayingMontage;                          // 0x01A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A8[0x18];                                     // 0x01A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMontageInstanceInfo>           _activeMontagesInfo;                               // 0x01C0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class FName                                   _outSectionName;                                   // 0x01D0(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _timeBeforeOut;                                    // 0x01DC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 _skeletalMeshComponent;                            // 0x01E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E8[0x28];                                     // 0x01E8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UAnimMontage*, class FName>        _montageToNameMap;                                 // 0x0210(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class UDataTable*>                     _loadedMappingTables;                              // 0x0260(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_270[0x10];                                     // 0x0270(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void JumpToSection(class FName sectionName);
	void JumpToSectionEnd(class FName sectionName);
	void OnMontageBlendingOutInternal(const struct FGuid& Guid, class UAnimMontage* Montage, bool interrupted);
	void OnMontageEndedInternal(const struct FGuid& Guid, class UAnimMontage* Montage, bool interrupted);
	class UAnimMontage* Play(const struct FAnimationMontageDescriptor& animMontageID, float PlayRate, bool isFollower);
	class UAnimMontage* PlayLoopForDuration(const struct FAnimationMontageDescriptor& animMontageID, float Duration, float PlayRate, class FName Out);
	void SetPlayRate(float PlayRate);
	void SetSkeletalMesh(class USkeletalMeshComponent* SkeletalMeshComponent);
	void SignalAnimInstanceChanged();
	void Stop(float BlendOutTime);

	class UAnimInstance* GetAnimInstance() const;
	bool IsPlaying(const struct FAnimationMontageDescriptor& montageDescriptor) const;
	bool IsPlayingAnyMontage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MontagePlayer">();
	}
	static class UMontagePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMontagePlayer>();
	}
};
static_assert(alignof(UMontagePlayer) == 0x000008, "Wrong alignment on UMontagePlayer");
static_assert(sizeof(UMontagePlayer) == 0x000280, "Wrong size on UMontagePlayer");
static_assert(offsetof(UMontagePlayer, OnMontageStarted) == 0x0000B8, "Member 'UMontagePlayer::OnMontageStarted' has a wrong offset!");
static_assert(offsetof(UMontagePlayer, OnMontageEnded) == 0x000110, "Member 'UMontagePlayer::OnMontageEnded' has a wrong offset!");
static_assert(offsetof(UMontagePlayer, BPOnMontageBlendingOut) == 0x000150, "Member 'UMontagePlayer::BPOnMontageBlendingOut' has a wrong offset!");
static_assert(offsetof(UMontagePlayer, _contextualAnimationMappings) == 0x000190, "Member 'UMontagePlayer::_contextualAnimationMappings' has a wrong offset!");
static_assert(offsetof(UMontagePlayer, _currentlyPlayingMontage) == 0x0001A0, "Member 'UMontagePlayer::_currentlyPlayingMontage' has a wrong offset!");
static_assert(offsetof(UMontagePlayer, _activeMontagesInfo) == 0x0001C0, "Member 'UMontagePlayer::_activeMontagesInfo' has a wrong offset!");
static_assert(offsetof(UMontagePlayer, _outSectionName) == 0x0001D0, "Member 'UMontagePlayer::_outSectionName' has a wrong offset!");
static_assert(offsetof(UMontagePlayer, _timeBeforeOut) == 0x0001DC, "Member 'UMontagePlayer::_timeBeforeOut' has a wrong offset!");
static_assert(offsetof(UMontagePlayer, _skeletalMeshComponent) == 0x0001E0, "Member 'UMontagePlayer::_skeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(UMontagePlayer, _montageToNameMap) == 0x000210, "Member 'UMontagePlayer::_montageToNameMap' has a wrong offset!");
static_assert(offsetof(UMontagePlayer, _loadedMappingTables) == 0x000260, "Member 'UMontagePlayer::_loadedMappingTables' has a wrong offset!");

// Class DeadByDaylight.MoriComponent
// 0x00F8 (0x01B0 - 0x00B8)
class UMoriComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnMoriBegin;                                       // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnMoriEnd;                                         // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UInteractionDefinition>> _moriInteractionClasses;                       // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _disruptAuraReadingStatusEffect;                   // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0xA0];                                     // 0x0110(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMoriChargeCompleted(class ASurvivor* survivorTarget);
	void OnMoriFinished();
	void OnMoriUpdateStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoriComponent">();
	}
	static class UMoriComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoriComponent>();
	}
};
static_assert(alignof(UMoriComponent) == 0x000008, "Wrong alignment on UMoriComponent");
static_assert(sizeof(UMoriComponent) == 0x0001B0, "Wrong size on UMoriComponent");
static_assert(offsetof(UMoriComponent, OnMoriBegin) == 0x0000D0, "Member 'UMoriComponent::OnMoriBegin' has a wrong offset!");
static_assert(offsetof(UMoriComponent, OnMoriEnd) == 0x0000E0, "Member 'UMoriComponent::OnMoriEnd' has a wrong offset!");
static_assert(offsetof(UMoriComponent, _moriInteractionClasses) == 0x0000F0, "Member 'UMoriComponent::_moriInteractionClasses' has a wrong offset!");
static_assert(offsetof(UMoriComponent, _disruptAuraReadingStatusEffect) == 0x000108, "Member 'UMoriComponent::_disruptAuraReadingStatusEffect' has a wrong offset!");

// Class DeadByDaylight.MovementModifierActor
// 0x0008 (0x02A8 - 0x02A0)
class AMovementModifierActor final : public AActor
{
public:
	float                                         maxSpeedMultiplier;                                // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovementModifierActor">();
	}
	static class AMovementModifierActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMovementModifierActor>();
	}
};
static_assert(alignof(AMovementModifierActor) == 0x000008, "Wrong alignment on AMovementModifierActor");
static_assert(sizeof(AMovementModifierActor) == 0x0002A8, "Wrong size on AMovementModifierActor");
static_assert(offsetof(AMovementModifierActor, maxSpeedMultiplier) == 0x0002A0, "Member 'AMovementModifierActor::maxSpeedMultiplier' has a wrong offset!");

// Class DeadByDaylight.MultipleLightsFader
// 0x0028 (0x02C8 - 0x02A0)
class AMultipleLightsFader final : public AActor
{
public:
	TArray<class ULightComponent*>                _affectedLights;                                   // 0x02A0(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 _lightOriginalIntensities;                         // 0x02B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         _timeMultiplier;                                   // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAffectedLights(const TArray<class ULightComponent*>& affectedLights);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MultipleLightsFader">();
	}
	static class AMultipleLightsFader* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMultipleLightsFader>();
	}
};
static_assert(alignof(AMultipleLightsFader) == 0x000008, "Wrong alignment on AMultipleLightsFader");
static_assert(sizeof(AMultipleLightsFader) == 0x0002C8, "Wrong size on AMultipleLightsFader");
static_assert(offsetof(AMultipleLightsFader, _affectedLights) == 0x0002A0, "Member 'AMultipleLightsFader::_affectedLights' has a wrong offset!");
static_assert(offsetof(AMultipleLightsFader, _lightOriginalIntensities) == 0x0002B0, "Member 'AMultipleLightsFader::_lightOriginalIntensities' has a wrong offset!");
static_assert(offsetof(AMultipleLightsFader, _timeMultiplier) == 0x0002C0, "Member 'AMultipleLightsFader::_timeMultiplier' has a wrong offset!");

// Class DeadByDaylight.ScreenshotToolSettingAsset
// 0x0008 (0x0040 - 0x0038)
class UScreenshotToolSettingAsset : public UDataAsset
{
public:
	class UDataTable*                             OverridesDB;                                       // 0x0038(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenshotToolSettingAsset">();
	}
	static class UScreenshotToolSettingAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenshotToolSettingAsset>();
	}
};
static_assert(alignof(UScreenshotToolSettingAsset) == 0x000008, "Wrong alignment on UScreenshotToolSettingAsset");
static_assert(sizeof(UScreenshotToolSettingAsset) == 0x000040, "Wrong size on UScreenshotToolSettingAsset");
static_assert(offsetof(UScreenshotToolSettingAsset, OverridesDB) == 0x000038, "Member 'UScreenshotToolSettingAsset::OverridesDB' has a wrong offset!");

// Class DeadByDaylight.Mutator
// 0x0010 (0x0040 - 0x0030)
class UMutator : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Mutator">();
	}
	static class UMutator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMutator>();
	}
};
static_assert(alignof(UMutator) == 0x000008, "Wrong alignment on UMutator");
static_assert(sizeof(UMutator) == 0x000040, "Wrong size on UMutator");

// Class DeadByDaylight.MutatorSpawnerComponent
// 0x0018 (0x0108 - 0x00F0)
class UMutatorSpawnerComponent final : public UGameplaySpawnerComponent
{
public:
	TArray<class UMutator*>                       _spawnedMutators;                                  // 0x00F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MutatorSpawnerComponent">();
	}
	static class UMutatorSpawnerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMutatorSpawnerComponent>();
	}
};
static_assert(alignof(UMutatorSpawnerComponent) == 0x000008, "Wrong alignment on UMutatorSpawnerComponent");
static_assert(sizeof(UMutatorSpawnerComponent) == 0x000108, "Wrong size on UMutatorSpawnerComponent");
static_assert(offsetof(UMutatorSpawnerComponent, _spawnedMutators) == 0x0000F0, "Member 'UMutatorSpawnerComponent::_spawnedMutators' has a wrong offset!");

// Class DeadByDaylight.MysteryBoxSubsystem
// 0x0178 (0x01B0 - 0x0038)
class UMysteryBoxSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x178];                                     // 0x0038(0x0178)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCurrentClaimEndTimeTimerElapsed(const class FString& Campaign);
	void OnGameInstanceInitialized();
	void OnNextClaimTimeTimerElapsed(const class FString& Campaign);
	void OnTimeTravel(bool Success, const class FString& Date);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MysteryBoxSubsystem">();
	}
	static class UMysteryBoxSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMysteryBoxSubsystem>();
	}
};
static_assert(alignof(UMysteryBoxSubsystem) == 0x000008, "Wrong alignment on UMysteryBoxSubsystem");
static_assert(sizeof(UMysteryBoxSubsystem) == 0x0001B0, "Wrong size on UMysteryBoxSubsystem");

// Class DeadByDaylight.NatAudioAmbienceBox
// 0x0010 (0x05F0 - 0x05E0)
class UNatAudioAmbienceBox final : public UAmbienceBoxComponent
{
public:
	class UAkAudioEvent*                          _onBeginOverlapAudioEvent;                         // 0x05E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          _onEndOverlapAudioEvent;                           // 0x05E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnBeginOverlapAudioAmbience(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlapAudioAmbience(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NatAudioAmbienceBox">();
	}
	static class UNatAudioAmbienceBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNatAudioAmbienceBox>();
	}
};
static_assert(alignof(UNatAudioAmbienceBox) == 0x000010, "Wrong alignment on UNatAudioAmbienceBox");
static_assert(sizeof(UNatAudioAmbienceBox) == 0x0005F0, "Wrong size on UNatAudioAmbienceBox");
static_assert(offsetof(UNatAudioAmbienceBox, _onBeginOverlapAudioEvent) == 0x0005E0, "Member 'UNatAudioAmbienceBox::_onBeginOverlapAudioEvent' has a wrong offset!");
static_assert(offsetof(UNatAudioAmbienceBox, _onEndOverlapAudioEvent) == 0x0005E8, "Member 'UNatAudioAmbienceBox::_onEndOverlapAudioEvent' has a wrong offset!");

// Class DeadByDaylight.ScreenshotToolAsset
// 0x0020 (0x0058 - 0x0038)
class UScreenshotToolAsset final : public UDataAsset
{
public:
	class UScreenshotToolConfigurationAsset*      Configuration;                                     // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScreenshotToolAnimationAsset*          Animations;                                        // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScreenshotToolViewAsset*               Views;                                             // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScreenshotToolSceneAsset*              Scenes;                                            // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenshotToolAsset">();
	}
	static class UScreenshotToolAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenshotToolAsset>();
	}
};
static_assert(alignof(UScreenshotToolAsset) == 0x000008, "Wrong alignment on UScreenshotToolAsset");
static_assert(sizeof(UScreenshotToolAsset) == 0x000058, "Wrong size on UScreenshotToolAsset");
static_assert(offsetof(UScreenshotToolAsset, Configuration) == 0x000038, "Member 'UScreenshotToolAsset::Configuration' has a wrong offset!");
static_assert(offsetof(UScreenshotToolAsset, Animations) == 0x000040, "Member 'UScreenshotToolAsset::Animations' has a wrong offset!");
static_assert(offsetof(UScreenshotToolAsset, Views) == 0x000048, "Member 'UScreenshotToolAsset::Views' has a wrong offset!");
static_assert(offsetof(UScreenshotToolAsset, Scenes) == 0x000050, "Member 'UScreenshotToolAsset::Scenes' has a wrong offset!");

// Class DeadByDaylight.NatAudioCustomMesh
// 0x0010 (0x06A0 - 0x0690)
class UNatAudioCustomMesh final : public UAudioCustomMeshComponent
{
public:
	class UAkAudioEvent*                          _onBeginOverlapAudioEvent;                         // 0x0688(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          _onEndOverlapAudioEvent;                           // 0x0690(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_698[0x8];                                      // 0x0698(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginOverlapAudioMesh(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlapAudioMesh(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NatAudioCustomMesh">();
	}
	static class UNatAudioCustomMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNatAudioCustomMesh>();
	}
};
static_assert(alignof(UNatAudioCustomMesh) == 0x000010, "Wrong alignment on UNatAudioCustomMesh");
static_assert(sizeof(UNatAudioCustomMesh) == 0x0006A0, "Wrong size on UNatAudioCustomMesh");
static_assert(offsetof(UNatAudioCustomMesh, _onBeginOverlapAudioEvent) == 0x000688, "Member 'UNatAudioCustomMesh::_onBeginOverlapAudioEvent' has a wrong offset!");
static_assert(offsetof(UNatAudioCustomMesh, _onEndOverlapAudioEvent) == 0x000690, "Member 'UNatAudioCustomMesh::_onEndOverlapAudioEvent' has a wrong offset!");

// Class DeadByDaylight.NavArea_BearTrap
// 0x0000 (0x0050 - 0x0050)
class UNavArea_BearTrap final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_BearTrap">();
	}
	static class UNavArea_BearTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_BearTrap>();
	}
};
static_assert(alignof(UNavArea_BearTrap) == 0x000008, "Wrong alignment on UNavArea_BearTrap");
static_assert(sizeof(UNavArea_BearTrap) == 0x000050, "Wrong size on UNavArea_BearTrap");

// Class DeadByDaylight.NavArea_Slasher
// 0x0000 (0x0050 - 0x0050)
class UNavArea_Slasher final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_Slasher">();
	}
	static class UNavArea_Slasher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_Slasher>();
	}
};
static_assert(alignof(UNavArea_Slasher) == 0x000008, "Wrong alignment on UNavArea_Slasher");
static_assert(sizeof(UNavArea_Slasher) == 0x000050, "Wrong size on UNavArea_Slasher");

// Class DeadByDaylight.NavArea_Turret
// 0x0000 (0x0050 - 0x0050)
class UNavArea_Turret final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_Turret">();
	}
	static class UNavArea_Turret* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_Turret>();
	}
};
static_assert(alignof(UNavArea_Turret) == 0x000008, "Wrong alignment on UNavArea_Turret");
static_assert(sizeof(UNavArea_Turret) == 0x000050, "Wrong size on UNavArea_Turret");

// Class DeadByDaylight.NavmeshGeneratorComponent
// 0x0038 (0x00F0 - 0x00B8)
class UNavmeshGeneratorComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x28];                                      // 0x00B8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ANavMeshBoundsVolume*>           _availableNavmeshBoundsVolumes;                    // 0x00E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavmeshGeneratorComponent">();
	}
	static class UNavmeshGeneratorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavmeshGeneratorComponent>();
	}
};
static_assert(alignof(UNavmeshGeneratorComponent) == 0x000008, "Wrong alignment on UNavmeshGeneratorComponent");
static_assert(sizeof(UNavmeshGeneratorComponent) == 0x0000F0, "Wrong size on UNavmeshGeneratorComponent");
static_assert(offsetof(UNavmeshGeneratorComponent, _availableNavmeshBoundsVolumes) == 0x0000E0, "Member 'UNavmeshGeneratorComponent::_availableNavmeshBoundsVolumes' has a wrong offset!");

// Class DeadByDaylight.NoAccumulationSpawnerStrategy
// 0x0000 (0x0030 - 0x0030)
class UNoAccumulationSpawnerStrategy final : public USpawnerStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NoAccumulationSpawnerStrategy">();
	}
	static class UNoAccumulationSpawnerStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNoAccumulationSpawnerStrategy>();
	}
};
static_assert(alignof(UNoAccumulationSpawnerStrategy) == 0x000008, "Wrong alignment on UNoAccumulationSpawnerStrategy");
static_assert(sizeof(UNoAccumulationSpawnerStrategy) == 0x000030, "Wrong size on UNoAccumulationSpawnerStrategy");

// Class DeadByDaylight.ObjectiveScreenIndicatorWorldMarkerComponent
// 0x0000 (0x02F0 - 0x02F0)
class UObjectiveScreenIndicatorWorldMarkerComponent final : public UScreenIndicatorWorldMarkerComponent
{
public:
	class UTexture2D*                             IndicatorHudScreenIcon;                            // 0x02E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveScreenIndicatorWorldMarkerComponent">();
	}
	static class UObjectiveScreenIndicatorWorldMarkerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveScreenIndicatorWorldMarkerComponent>();
	}
};
static_assert(alignof(UObjectiveScreenIndicatorWorldMarkerComponent) == 0x000010, "Wrong alignment on UObjectiveScreenIndicatorWorldMarkerComponent");
static_assert(sizeof(UObjectiveScreenIndicatorWorldMarkerComponent) == 0x0002F0, "Wrong size on UObjectiveScreenIndicatorWorldMarkerComponent");
static_assert(offsetof(UObjectiveScreenIndicatorWorldMarkerComponent, IndicatorHudScreenIcon) == 0x0002E8, "Member 'UObjectiveScreenIndicatorWorldMarkerComponent::IndicatorHudScreenIcon' has a wrong offset!");

// Class DeadByDaylight.AlwaysUseCurrentLocationPlacementStrategy
// 0x0000 (0x0068 - 0x0068)
class UAlwaysUseCurrentLocationPlacementStrategy final : public UObjectPlacementUpdateStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AlwaysUseCurrentLocationPlacementStrategy">();
	}
	static class UAlwaysUseCurrentLocationPlacementStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAlwaysUseCurrentLocationPlacementStrategy>();
	}
};
static_assert(alignof(UAlwaysUseCurrentLocationPlacementStrategy) == 0x000008, "Wrong alignment on UAlwaysUseCurrentLocationPlacementStrategy");
static_assert(sizeof(UAlwaysUseCurrentLocationPlacementStrategy) == 0x000068, "Wrong size on UAlwaysUseCurrentLocationPlacementStrategy");

// Class DeadByDaylight.BufferLastValidLocationObjectPlacementStrategy
// 0x0008 (0x0070 - 0x0068)
class UBufferLastValidLocationObjectPlacementStrategy final : public UObjectPlacementUpdateStrategy
{
public:
	float                                         _maxDistanceToOwner;                               // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BufferLastValidLocationObjectPlacementStrategy">();
	}
	static class UBufferLastValidLocationObjectPlacementStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBufferLastValidLocationObjectPlacementStrategy>();
	}
};
static_assert(alignof(UBufferLastValidLocationObjectPlacementStrategy) == 0x000008, "Wrong alignment on UBufferLastValidLocationObjectPlacementStrategy");
static_assert(sizeof(UBufferLastValidLocationObjectPlacementStrategy) == 0x000070, "Wrong size on UBufferLastValidLocationObjectPlacementStrategy");
static_assert(offsetof(UBufferLastValidLocationObjectPlacementStrategy, _maxDistanceToOwner) == 0x000068, "Member 'UBufferLastValidLocationObjectPlacementStrategy::_maxDistanceToOwner' has a wrong offset!");

// Class DeadByDaylight.SurvivorEndGameComponent
// 0x0070 (0x0128 - 0x00B8)
class USurvivorEndGameComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x58];                                      // 0x00B8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AEndGameEntity>             _endGameEntityClass;                               // 0x0110(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x4];                                      // 0x0118(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _delayBeforeSacrifice;                             // 0x011C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _readyToBeSacrificed;                              // 0x0120(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDelayBeforeSacrificeEnd();
	void OnEndGameSacrificeEnd();

	bool GetSacrificedByEndGame() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorEndGameComponent">();
	}
	static class USurvivorEndGameComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorEndGameComponent>();
	}
};
static_assert(alignof(USurvivorEndGameComponent) == 0x000008, "Wrong alignment on USurvivorEndGameComponent");
static_assert(sizeof(USurvivorEndGameComponent) == 0x000128, "Wrong size on USurvivorEndGameComponent");
static_assert(offsetof(USurvivorEndGameComponent, _endGameEntityClass) == 0x000110, "Member 'USurvivorEndGameComponent::_endGameEntityClass' has a wrong offset!");
static_assert(offsetof(USurvivorEndGameComponent, _delayBeforeSacrifice) == 0x00011C, "Member 'USurvivorEndGameComponent::_delayBeforeSacrifice' has a wrong offset!");
static_assert(offsetof(USurvivorEndGameComponent, _readyToBeSacrificed) == 0x000120, "Member 'USurvivorEndGameComponent::_readyToBeSacrificed' has a wrong offset!");

// Class DeadByDaylight.NavMeshObjectPlacementValidationStrategy
// 0x0008 (0x0118 - 0x0110)
class UNavMeshObjectPlacementValidationStrategy final : public UDefaultObjectPlacementValidationStrategy
{
public:
	float                                         _navPathMaxLength;                                 // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavMeshObjectPlacementValidationStrategy">();
	}
	static class UNavMeshObjectPlacementValidationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavMeshObjectPlacementValidationStrategy>();
	}
};
static_assert(alignof(UNavMeshObjectPlacementValidationStrategy) == 0x000008, "Wrong alignment on UNavMeshObjectPlacementValidationStrategy");
static_assert(sizeof(UNavMeshObjectPlacementValidationStrategy) == 0x000118, "Wrong size on UNavMeshObjectPlacementValidationStrategy");
static_assert(offsetof(UNavMeshObjectPlacementValidationStrategy, _navPathMaxLength) == 0x000110, "Member 'UNavMeshObjectPlacementValidationStrategy::_navPathMaxLength' has a wrong offset!");

// Class DeadByDaylight.OfferingHandler
// 0x0018 (0x0048 - 0x0030)
class UOfferingHandler final : public UObject
{
public:
	class UDBDGameInstance*                       _gameInstance;                                     // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _levelPerkIDs;                                     // 0x0038(0x0010)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OfferingHandler">();
	}
	static class UOfferingHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOfferingHandler>();
	}
};
static_assert(alignof(UOfferingHandler) == 0x000008, "Wrong alignment on UOfferingHandler");
static_assert(sizeof(UOfferingHandler) == 0x000048, "Wrong size on UOfferingHandler");
static_assert(offsetof(UOfferingHandler, _gameInstance) == 0x000030, "Member 'UOfferingHandler::_gameInstance' has a wrong offset!");
static_assert(offsetof(UOfferingHandler, _levelPerkIDs) == 0x000038, "Member 'UOfferingHandler::_levelPerkIDs' has a wrong offset!");

// Class DeadByDaylight.OfflineLobbyLevel
// 0x0210 (0x0568 - 0x0358)
class AOfflineLobbyLevel final : public ALobbyLevel
{
public:
	struct FVector                                _partyLobbyInviteButtonOffset;                     // 0x0358(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class APlayerStart>>    _roleSelectionCamperSpawns;                        // 0x0370(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class APlayerStart>>    _roleSelectionSlasherSpawns;                       // 0x0380(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ADisplayStand>           _offlineLobbyLocalSlasherSpawn;                    // 0x0390(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _partyLobbyEmptySlotFxOffset;                      // 0x0398(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ADisplayStand>           _offlineLobbyLocalCamperSpawn;                     // 0x03B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        _partyLobbySlasherPOVTrackerOffsets;               // 0x03B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   _partyLobbyEmptySlotSilhouette;                    // 0x03C8(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ADisplayStand>>   _partyLobbySlasherDisplayStands;                   // 0x0400(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ADisplayStand>>   _partyLobbyCamperDisplayStands;                    // 0x0410(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_420[0x10];                                     // 0x0420(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   _meatHookForCustomization;                         // 0x0430(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ATargetPoint>            _meatHookSpawn;                                    // 0x0468(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   _charmForCustomizationZoom;                        // 0x0470(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ATargetPoint>            _camperCharmSpawn;                                 // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ATargetPoint>            _slasherCharmSpawn;                                // 0x04B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<TWeakObjectPtr<class ADisplayStand>, TWeakObjectPtr<class ADBDMenuSilhouette>> _partyLobbyEmptySlotPawns; // 0x04B8(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_508[0x48];                                     // 0x0508(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         _destroyingPawns;                                  // 0x0550(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_560[0x8];                                      // 0x0560(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckDestroyingPawns(class AActor* DestroyedActor);
	void OnCharacterSpawned(class ADBDMenuPlayer* Player);
	void OnStateChanged(EOfflineLobbyState LobbyState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OfflineLobbyLevel">();
	}
	static class AOfflineLobbyLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOfflineLobbyLevel>();
	}
};
static_assert(alignof(AOfflineLobbyLevel) == 0x000008, "Wrong alignment on AOfflineLobbyLevel");
static_assert(sizeof(AOfflineLobbyLevel) == 0x000568, "Wrong size on AOfflineLobbyLevel");
static_assert(offsetof(AOfflineLobbyLevel, _partyLobbyInviteButtonOffset) == 0x000358, "Member 'AOfflineLobbyLevel::_partyLobbyInviteButtonOffset' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _roleSelectionCamperSpawns) == 0x000370, "Member 'AOfflineLobbyLevel::_roleSelectionCamperSpawns' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _roleSelectionSlasherSpawns) == 0x000380, "Member 'AOfflineLobbyLevel::_roleSelectionSlasherSpawns' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _offlineLobbyLocalSlasherSpawn) == 0x000390, "Member 'AOfflineLobbyLevel::_offlineLobbyLocalSlasherSpawn' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _partyLobbyEmptySlotFxOffset) == 0x000398, "Member 'AOfflineLobbyLevel::_partyLobbyEmptySlotFxOffset' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _offlineLobbyLocalCamperSpawn) == 0x0003B0, "Member 'AOfflineLobbyLevel::_offlineLobbyLocalCamperSpawn' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _partyLobbySlasherPOVTrackerOffsets) == 0x0003B8, "Member 'AOfflineLobbyLevel::_partyLobbySlasherPOVTrackerOffsets' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _partyLobbyEmptySlotSilhouette) == 0x0003C8, "Member 'AOfflineLobbyLevel::_partyLobbyEmptySlotSilhouette' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _partyLobbySlasherDisplayStands) == 0x000400, "Member 'AOfflineLobbyLevel::_partyLobbySlasherDisplayStands' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _partyLobbyCamperDisplayStands) == 0x000410, "Member 'AOfflineLobbyLevel::_partyLobbyCamperDisplayStands' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _meatHookForCustomization) == 0x000430, "Member 'AOfflineLobbyLevel::_meatHookForCustomization' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _meatHookSpawn) == 0x000468, "Member 'AOfflineLobbyLevel::_meatHookSpawn' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _charmForCustomizationZoom) == 0x000470, "Member 'AOfflineLobbyLevel::_charmForCustomizationZoom' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _camperCharmSpawn) == 0x0004A8, "Member 'AOfflineLobbyLevel::_camperCharmSpawn' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _slasherCharmSpawn) == 0x0004B0, "Member 'AOfflineLobbyLevel::_slasherCharmSpawn' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _partyLobbyEmptySlotPawns) == 0x0004B8, "Member 'AOfflineLobbyLevel::_partyLobbyEmptySlotPawns' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _destroyingPawns) == 0x000550, "Member 'AOfflineLobbyLevel::_destroyingPawns' has a wrong offset!");

// Class DeadByDaylight.OnboardingUtilities
// 0x0000 (0x0030 - 0x0030)
class UOnboardingUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnboardingUtilities">();
	}
	static class UOnboardingUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnboardingUtilities>();
	}
};
static_assert(alignof(UOnboardingUtilities) == 0x000008, "Wrong alignment on UOnboardingUtilities");
static_assert(sizeof(UOnboardingUtilities) == 0x000030, "Wrong size on UOnboardingUtilities");

// Class DeadByDaylight.OniBasicAttackComponent
// 0x0010 (0x00C8 - 0x00B8)
class UOniBasicAttackComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniBasicAttackComponent">();
	}
	static class UOniBasicAttackComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniBasicAttackComponent>();
	}
};
static_assert(alignof(UOniBasicAttackComponent) == 0x000008, "Wrong alignment on UOniBasicAttackComponent");
static_assert(sizeof(UOniBasicAttackComponent) == 0x0000C8, "Wrong size on UOniBasicAttackComponent");

// Class DeadByDaylight.OniDemonModeAttackStateComponent
// 0x0018 (0x00D8 - 0x00C0)
class UOniDemonModeAttackStateComponent final : public UChargedAttackStateComponent
{
public:
	TMulticastInlineDelegate<void(bool bIsReady)> OnChargedAttackReadyChanged;                       // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_ClearChargingState();
	void Server_ClearChargingState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniDemonModeAttackStateComponent">();
	}
	static class UOniDemonModeAttackStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniDemonModeAttackStateComponent>();
	}
};
static_assert(alignof(UOniDemonModeAttackStateComponent) == 0x000008, "Wrong alignment on UOniDemonModeAttackStateComponent");
static_assert(sizeof(UOniDemonModeAttackStateComponent) == 0x0000D8, "Wrong size on UOniDemonModeAttackStateComponent");
static_assert(offsetof(UOniDemonModeAttackStateComponent, OnChargedAttackReadyChanged) == 0x0000C0, "Member 'UOniDemonModeAttackStateComponent::OnChargedAttackReadyChanged' has a wrong offset!");

// Class DeadByDaylight.SpawnedActorReplicationComponent
// 0x0010 (0x00C8 - 0x00B8)
class USpawnedActorReplicationComponent final : public UActorComponent
{
public:
	TArray<class FName>                           _replicatedTags;                                   // 0x00B8(0x0010)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnedActorReplicationComponent">();
	}
	static class USpawnedActorReplicationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnedActorReplicationComponent>();
	}
};
static_assert(alignof(USpawnedActorReplicationComponent) == 0x000008, "Wrong alignment on USpawnedActorReplicationComponent");
static_assert(sizeof(USpawnedActorReplicationComponent) == 0x0000C8, "Wrong size on USpawnedActorReplicationComponent");
static_assert(offsetof(USpawnedActorReplicationComponent, _replicatedTags) == 0x0000B8, "Member 'USpawnedActorReplicationComponent::_replicatedTags' has a wrong offset!");

// Class DeadByDaylight.OnlineLobbyLevel
// 0x0038 (0x0390 - 0x0358)
class AOnlineLobbyLevel final : public ALobbyLevel
{
public:
	class UProceduralGenerationData*              ProceduralGenerationData;                          // 0x0358(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        _onlineLobbySlasherPOVTrackerOffsets;              // 0x0360(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ADisplayStand>>   _onlineLobbyCamperDisplayStands;                   // 0x0370(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ADisplayStand>>   _onlineLobbySlasherDisplayStands;                  // 0x0380(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineLobbyLevel">();
	}
	static class AOnlineLobbyLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOnlineLobbyLevel>();
	}
};
static_assert(alignof(AOnlineLobbyLevel) == 0x000008, "Wrong alignment on AOnlineLobbyLevel");
static_assert(sizeof(AOnlineLobbyLevel) == 0x000390, "Wrong size on AOnlineLobbyLevel");
static_assert(offsetof(AOnlineLobbyLevel, ProceduralGenerationData) == 0x000358, "Member 'AOnlineLobbyLevel::ProceduralGenerationData' has a wrong offset!");
static_assert(offsetof(AOnlineLobbyLevel, _onlineLobbySlasherPOVTrackerOffsets) == 0x000360, "Member 'AOnlineLobbyLevel::_onlineLobbySlasherPOVTrackerOffsets' has a wrong offset!");
static_assert(offsetof(AOnlineLobbyLevel, _onlineLobbyCamperDisplayStands) == 0x000370, "Member 'AOnlineLobbyLevel::_onlineLobbyCamperDisplayStands' has a wrong offset!");
static_assert(offsetof(AOnlineLobbyLevel, _onlineLobbySlasherDisplayStands) == 0x000380, "Member 'AOnlineLobbyLevel::_onlineLobbySlasherDisplayStands' has a wrong offset!");

// Class DeadByDaylight.OnlinePrivilegeManager
// 0x0008 (0x0040 - 0x0038)
class UOnlinePrivilegeManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlinePrivilegeManager">();
	}
	static class UOnlinePrivilegeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlinePrivilegeManager>();
	}
};
static_assert(alignof(UOnlinePrivilegeManager) == 0x000008, "Wrong alignment on UOnlinePrivilegeManager");
static_assert(sizeof(UOnlinePrivilegeManager) == 0x000040, "Wrong size on UOnlinePrivilegeManager");

// Class DeadByDaylight.OnlineSystemHandler
// 0x04E8 (0x0518 - 0x0030)
class UOnlineSystemHandler final : public UObject
{
public:
	uint8                                         Pad_30[0x1D0];                                     // 0x0030(0x01D0)(Fixing Size After Last Property [ Dumper-7 ])
	class ULocalPlayer*                           _cachedLocalPlayer;                                // 0x0200(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDGameInstance*                       _gameInstance;                                     // 0x0208(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameSessionDS*                         _gameSessionDS;                                    // 0x0210(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_218[0x270];                                    // 0x0218(0x0270)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDServerInstance*                     _serverInstance;                                   // 0x0488(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_490[0x30];                                     // 0x0490(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrossPlatformManager*                  _crossPlatformManager;                             // 0x04C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C8[0x50];                                     // 0x04C8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineSystemHandler">();
	}
	static class UOnlineSystemHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineSystemHandler>();
	}
};
static_assert(alignof(UOnlineSystemHandler) == 0x000008, "Wrong alignment on UOnlineSystemHandler");
static_assert(sizeof(UOnlineSystemHandler) == 0x000518, "Wrong size on UOnlineSystemHandler");
static_assert(offsetof(UOnlineSystemHandler, _cachedLocalPlayer) == 0x000200, "Member 'UOnlineSystemHandler::_cachedLocalPlayer' has a wrong offset!");
static_assert(offsetof(UOnlineSystemHandler, _gameInstance) == 0x000208, "Member 'UOnlineSystemHandler::_gameInstance' has a wrong offset!");
static_assert(offsetof(UOnlineSystemHandler, _gameSessionDS) == 0x000210, "Member 'UOnlineSystemHandler::_gameSessionDS' has a wrong offset!");
static_assert(offsetof(UOnlineSystemHandler, _serverInstance) == 0x000488, "Member 'UOnlineSystemHandler::_serverInstance' has a wrong offset!");
static_assert(offsetof(UOnlineSystemHandler, _crossPlatformManager) == 0x0004C0, "Member 'UOnlineSystemHandler::_crossPlatformManager' has a wrong offset!");

// Class DeadByDaylight.OnScreenDebugComponent
// 0x0010 (0x00C8 - 0x00B8)
class UOnScreenDebugComponent final : public UActorComponent
{
public:
	TArray<struct FOnScreenDebugInfo>             _messages;                                         // 0x00B8(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnScreenDebugComponent">();
	}
	static class UOnScreenDebugComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnScreenDebugComponent>();
	}
};
static_assert(alignof(UOnScreenDebugComponent) == 0x000008, "Wrong alignment on UOnScreenDebugComponent");
static_assert(sizeof(UOnScreenDebugComponent) == 0x0000C8, "Wrong size on UOnScreenDebugComponent");
static_assert(offsetof(UOnScreenDebugComponent, _messages) == 0x0000B8, "Member 'UOnScreenDebugComponent::_messages' has a wrong offset!");

// Class DeadByDaylight.SpecialEventCustomizationsComponent
// 0x0110 (0x0140 - 0x0030)
class USpecialEventCustomizationsComponent final : public UObject
{
public:
	uint8                                         Pad_30[0x110];                                     // 0x0030(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecialEventCustomizationsComponent">();
	}
	static class USpecialEventCustomizationsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpecialEventCustomizationsComponent>();
	}
};
static_assert(alignof(USpecialEventCustomizationsComponent) == 0x000008, "Wrong alignment on USpecialEventCustomizationsComponent");
static_assert(sizeof(USpecialEventCustomizationsComponent) == 0x000140, "Wrong size on USpecialEventCustomizationsComponent");

// Class DeadByDaylight.OpenHatch
// 0x0000 (0x0770 - 0x0770)
class UOpenHatch final : public UBaseEscapeThroughHatch
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OpenHatch">();
	}
	static class UOpenHatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOpenHatch>();
	}
};
static_assert(alignof(UOpenHatch) == 0x000010, "Wrong alignment on UOpenHatch");
static_assert(sizeof(UOpenHatch) == 0x000770, "Wrong size on UOpenHatch");

// Class DeadByDaylight.OpenSupplyCrateInteraction
// 0x0010 (0x08D0 - 0x08C0)
class UOpenSupplyCrateInteraction final : public UChargeableInteractionDefinition
{
public:
	class ASupplyCrateInteractable*               _owningSupplyCrate;                                // 0x08C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          _successExitTimeAnimSequenceReference;             // 0x08C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OpenSupplyCrateInteraction">();
	}
	static class UOpenSupplyCrateInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOpenSupplyCrateInteraction>();
	}
};
static_assert(alignof(UOpenSupplyCrateInteraction) == 0x000010, "Wrong alignment on UOpenSupplyCrateInteraction");
static_assert(sizeof(UOpenSupplyCrateInteraction) == 0x0008D0, "Wrong size on UOpenSupplyCrateInteraction");
static_assert(offsetof(UOpenSupplyCrateInteraction, _owningSupplyCrate) == 0x0008C0, "Member 'UOpenSupplyCrateInteraction::_owningSupplyCrate' has a wrong offset!");
static_assert(offsetof(UOpenSupplyCrateInteraction, _successExitTimeAnimSequenceReference) == 0x0008C8, "Member 'UOpenSupplyCrateInteraction::_successExitTimeAnimSequenceReference' has a wrong offset!");

// Class DeadByDaylight.OtherCharactersVerticalCollisionsHandler
// 0x0028 (0x00E0 - 0x00B8)
class UOtherCharactersVerticalCollisionsHandler final : public UActorComponent
{
public:
	TArray<class AActor*>                         _ignoreBelowActors;                                // 0x00B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         _overlappingActors;                                // 0x00C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UCapsuleComponent*                      _pawnDetector;                                     // 0x00D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void InitializeOverlapDetection();
	void OnPawnDetectorOverlapEnter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnPawnDetectorOverlapExit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void SetPawnDetector(class UCapsuleComponent* pawnDetector);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OtherCharactersVerticalCollisionsHandler">();
	}
	static class UOtherCharactersVerticalCollisionsHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOtherCharactersVerticalCollisionsHandler>();
	}
};
static_assert(alignof(UOtherCharactersVerticalCollisionsHandler) == 0x000008, "Wrong alignment on UOtherCharactersVerticalCollisionsHandler");
static_assert(sizeof(UOtherCharactersVerticalCollisionsHandler) == 0x0000E0, "Wrong size on UOtherCharactersVerticalCollisionsHandler");
static_assert(offsetof(UOtherCharactersVerticalCollisionsHandler, _ignoreBelowActors) == 0x0000B8, "Member 'UOtherCharactersVerticalCollisionsHandler::_ignoreBelowActors' has a wrong offset!");
static_assert(offsetof(UOtherCharactersVerticalCollisionsHandler, _overlappingActors) == 0x0000C8, "Member 'UOtherCharactersVerticalCollisionsHandler::_overlappingActors' has a wrong offset!");
static_assert(offsetof(UOtherCharactersVerticalCollisionsHandler, _pawnDetector) == 0x0000D8, "Member 'UOtherCharactersVerticalCollisionsHandler::_pawnDetector' has a wrong offset!");

// Class DeadByDaylight.OutfitHelper
// 0x0000 (0x0030 - 0x0030)
class UOutfitHelper final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutfitHelper">();
	}
	static class UOutfitHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOutfitHelper>();
	}
};
static_assert(alignof(UOutfitHelper) == 0x000008, "Wrong alignment on UOutfitHelper");
static_assert(sizeof(UOutfitHelper) == 0x000030, "Wrong size on UOutfitHelper");

// Class DeadByDaylight.SpecialEventUtilities
// 0x0000 (0x0030 - 0x0030)
class USpecialEventUtilities final : public UBlueprintFunctionLibrary
{
public:
	static bool BP_Find(const class UObject* contextObject, const class FName eventID, struct FCombinedSpecialEventData* outEvent);
	static bool BP_FindBestActive(const class UObject* contextObject, struct FCombinedSpecialEventData* outEvent);
	static int32 BP_GetEventTrackerObjectiveLevel(const class UObject* WorldContextObject, const class FName eventID);
	static struct FDateTime BP_GetMainEndDate(const struct FCombinedSpecialEventData& Event);
	static struct FDateTime BP_GetPostEndDate(const struct FCombinedSpecialEventData& Event);
	static struct FDateTime BP_GetStartDate(const struct FCombinedSpecialEventData& Event);
	static ESpecialEventStatus BP_GetStatus(const struct FCombinedSpecialEventData& Event);
	static struct FTimespan BP_GetTimeSinceStartDate(const struct FCombinedSpecialEventData& Event);
	static struct FTimespan BP_GetTimeTillMainEndDate(const struct FCombinedSpecialEventData& Event);
	static struct FTimespan BP_GetTimeTillPostEndDate(const struct FCombinedSpecialEventData& Event);
	static bool BP_IsActive(const struct FCombinedSpecialEventData& Event);
	static bool BP_IsValid(const struct FCombinedSpecialEventData& Event);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecialEventUtilities">();
	}
	static class USpecialEventUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpecialEventUtilities>();
	}
};
static_assert(alignof(USpecialEventUtilities) == 0x000008, "Wrong alignment on USpecialEventUtilities");
static_assert(sizeof(USpecialEventUtilities) == 0x000030, "Wrong size on USpecialEventUtilities");

// Class DeadByDaylight.OutlineReveal
// 0x00A8 (0x00D8 - 0x0030)
class UOutlineReveal final : public UObject
{
public:
	uint8                                         Pad_30[0x70];                                      // 0x0030(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADBDPlayer*>                     _affectedCharacters;                               // 0x00A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x28];                                      // 0x00B0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutlineReveal">();
	}
	static class UOutlineReveal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOutlineReveal>();
	}
};
static_assert(alignof(UOutlineReveal) == 0x000008, "Wrong alignment on UOutlineReveal");
static_assert(sizeof(UOutlineReveal) == 0x0000D8, "Wrong size on UOutlineReveal");
static_assert(offsetof(UOutlineReveal, _affectedCharacters) == 0x0000A0, "Member 'UOutlineReveal::_affectedCharacters' has a wrong offset!");

// Class DeadByDaylight.OutOfSightMeshRotator
// 0x0028 (0x00E0 - 0x00B8)
class UOutOfSightMeshRotator final : public UActorComponent
{
public:
	float                                         _maxDistance;                                      // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _dotProductThreshold;                              // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADBDPlayer*                             _locallyObservedPlayer;                            // 0x00C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMeshComponent*>                 _meshesToRotate;                                   // 0x00C8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	float                                         _rotationOffset;                                   // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMeshesToRotate(const TArray<class UMeshComponent*>& meshesToRotate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutOfSightMeshRotator">();
	}
	static class UOutOfSightMeshRotator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOutOfSightMeshRotator>();
	}
};
static_assert(alignof(UOutOfSightMeshRotator) == 0x000008, "Wrong alignment on UOutOfSightMeshRotator");
static_assert(sizeof(UOutOfSightMeshRotator) == 0x0000E0, "Wrong size on UOutOfSightMeshRotator");
static_assert(offsetof(UOutOfSightMeshRotator, _maxDistance) == 0x0000B8, "Member 'UOutOfSightMeshRotator::_maxDistance' has a wrong offset!");
static_assert(offsetof(UOutOfSightMeshRotator, _dotProductThreshold) == 0x0000BC, "Member 'UOutOfSightMeshRotator::_dotProductThreshold' has a wrong offset!");
static_assert(offsetof(UOutOfSightMeshRotator, _locallyObservedPlayer) == 0x0000C0, "Member 'UOutOfSightMeshRotator::_locallyObservedPlayer' has a wrong offset!");
static_assert(offsetof(UOutOfSightMeshRotator, _meshesToRotate) == 0x0000C8, "Member 'UOutOfSightMeshRotator::_meshesToRotate' has a wrong offset!");
static_assert(offsetof(UOutOfSightMeshRotator, _rotationOffset) == 0x0000D8, "Member 'UOutOfSightMeshRotator::_rotationOffset' has a wrong offset!");

// Class DeadByDaylight.PalletDropInteractionDefinition
// 0x0090 (0x0800 - 0x0770)
class UPalletDropInteractionDefinition final : public UInteractionDefinition
{
public:
	EPalletStunZoneSideStrategy                   _stunZoneSideStrategy;                             // 0x0768(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_769[0x7];                                      // 0x0769(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _palletVacuumSpeedBoost;                           // 0x0770(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _loudNoiseRange;                                   // 0x0798(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          _isStationary;                                     // 0x07C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C1[0x3F];                                     // 0x07C1(0x003F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPalletDropped();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalletDropInteractionDefinition">();
	}
	static class UPalletDropInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalletDropInteractionDefinition>();
	}
};
static_assert(alignof(UPalletDropInteractionDefinition) == 0x000010, "Wrong alignment on UPalletDropInteractionDefinition");
static_assert(sizeof(UPalletDropInteractionDefinition) == 0x000800, "Wrong size on UPalletDropInteractionDefinition");
static_assert(offsetof(UPalletDropInteractionDefinition, _stunZoneSideStrategy) == 0x000768, "Member 'UPalletDropInteractionDefinition::_stunZoneSideStrategy' has a wrong offset!");
static_assert(offsetof(UPalletDropInteractionDefinition, _palletVacuumSpeedBoost) == 0x000770, "Member 'UPalletDropInteractionDefinition::_palletVacuumSpeedBoost' has a wrong offset!");
static_assert(offsetof(UPalletDropInteractionDefinition, _loudNoiseRange) == 0x000798, "Member 'UPalletDropInteractionDefinition::_loudNoiseRange' has a wrong offset!");
static_assert(offsetof(UPalletDropInteractionDefinition, _isStationary) == 0x0007C0, "Member 'UPalletDropInteractionDefinition::_isStationary' has a wrong offset!");

// Class DeadByDaylight.PalletPulldownBlockerComponent
// 0x0078 (0x0130 - 0x00B8)
class UPalletPulldownBlockerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x60];                                      // 0x00B8(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isPalletPulldownBlockedByEntity;                  // 0x0118(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                _palletToBlock;                                    // 0x0120(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _blockedDisappearFxTime;                           // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_PalletPulldownBlockedHideCosmetic(class UObject* palletToUnblock);
	void Multicast_PalletPulldownBlockedShowCosmetic(class UObject* palletToBlock);
	void OnRep_PalletToBlock(class UObject* oldPalletToBlock);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalletPulldownBlockerComponent">();
	}
	static class UPalletPulldownBlockerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalletPulldownBlockerComponent>();
	}
};
static_assert(alignof(UPalletPulldownBlockerComponent) == 0x000008, "Wrong alignment on UPalletPulldownBlockerComponent");
static_assert(sizeof(UPalletPulldownBlockerComponent) == 0x000130, "Wrong size on UPalletPulldownBlockerComponent");
static_assert(offsetof(UPalletPulldownBlockerComponent, _isPalletPulldownBlockedByEntity) == 0x000118, "Member 'UPalletPulldownBlockerComponent::_isPalletPulldownBlockedByEntity' has a wrong offset!");
static_assert(offsetof(UPalletPulldownBlockerComponent, _palletToBlock) == 0x000120, "Member 'UPalletPulldownBlockerComponent::_palletToBlock' has a wrong offset!");
static_assert(offsetof(UPalletPulldownBlockerComponent, _blockedDisappearFxTime) == 0x000128, "Member 'UPalletPulldownBlockerComponent::_blockedDisappearFxTime' has a wrong offset!");

// Class DeadByDaylight.PalletTracker
// 0x0078 (0x0318 - 0x02A0)
class APalletTracker final : public AActor
{
public:
	uint8                                         Pad_2A0[0x28];                                     // 0x02A0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        _indicatorLocation;                                // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDNavEvadeLoopComponent*              _navEvadeLoopComponent;                            // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APallet*                                _trackedPallet;                                    // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APallet*                                _procedurallySpawnedPallet;                        // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPalletState                                  _trackedPalletState;                               // 0x02E8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E9[0x2F];                                     // 0x02E9(0x002F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanSpawnPalletAtLocation(const class AActor* spawningActor) const;
	void OnRep_TrackedPallet() const;
	void OnRep_TrackedPalletState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalletTracker">();
	}
	static class APalletTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalletTracker>();
	}
};
static_assert(alignof(APalletTracker) == 0x000008, "Wrong alignment on APalletTracker");
static_assert(sizeof(APalletTracker) == 0x000318, "Wrong size on APalletTracker");
static_assert(offsetof(APalletTracker, _indicatorLocation) == 0x0002C8, "Member 'APalletTracker::_indicatorLocation' has a wrong offset!");
static_assert(offsetof(APalletTracker, _navEvadeLoopComponent) == 0x0002D0, "Member 'APalletTracker::_navEvadeLoopComponent' has a wrong offset!");
static_assert(offsetof(APalletTracker, _trackedPallet) == 0x0002D8, "Member 'APalletTracker::_trackedPallet' has a wrong offset!");
static_assert(offsetof(APalletTracker, _procedurallySpawnedPallet) == 0x0002E0, "Member 'APalletTracker::_procedurallySpawnedPallet' has a wrong offset!");
static_assert(offsetof(APalletTracker, _trackedPalletState) == 0x0002E8, "Member 'APalletTracker::_trackedPalletState' has a wrong offset!");

// Class DeadByDaylight.PalletUtilities
// 0x0000 (0x0030 - 0x0030)
class UPalletUtilities final : public UObject
{
public:
	static TSoftClassPtr<class UClass> GetDreamPalletBP(const class UObject* WorldContextObject);
	static TSoftObjectPtr<class UStaticMesh> GetIllusionaryPalletStaticMesh(const class UObject* worldContextObjec);
	static TSoftClassPtr<class UClass> GetPalletTrackerBP(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalletUtilities">();
	}
	static class UPalletUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalletUtilities>();
	}
};
static_assert(alignof(UPalletUtilities) == 0x000008, "Wrong alignment on UPalletUtilities");
static_assert(sizeof(UPalletUtilities) == 0x000030, "Wrong size on UPalletUtilities");

// Class DeadByDaylight.RootMovie
// 0x0070 (0x00A0 - 0x0030)
class URootMovie final : public UObject
{
public:
	class FString                                 SwfAssetName;                                      // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGFxMoviePlayer*                        SwfMoviePlayer;                                    // 0x0040(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UScreenController*                      m_ScreenController;                                // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIController*                          m_UIController;                                    // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameInstance*                          m_GameInstance;                                    // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x30];                                      // 0x0070(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddCursorBlockingWidget(const class FString& ID, float X, float Y, float Width, float Height);
	void OnAssert(int32 Type, const class FString& Message);
	void OnFlashReady();
	void OnMovieClosed();
	void OnScreenEnter(const class FString& screenId);
	void OnScreenLeave(const class FString& screenId);
	void OnScreenReady(const class FString& screenId);
	void OpenLinkInBrowser(const class FString& linkAddress);
	void PlaySound(const class FString& soundId);
	void RegisterScreenControl(class UGFxObject* flashObj);
	void RegisterUIControl(class UGFxObject* flashObj);
	void RegisterView(const class FString& screenId, class UGFxObject* ScreenObject);
	void RemoveCursorBlockingWidget(const class FString& ID);
	void SetCursorAsSticky(bool IsSticky, bool lockVertical, bool lockHorizontal, float stickinessOverride);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RootMovie">();
	}
	static class URootMovie* GetDefaultObj()
	{
		return GetDefaultObjImpl<URootMovie>();
	}
};
static_assert(alignof(URootMovie) == 0x000008, "Wrong alignment on URootMovie");
static_assert(sizeof(URootMovie) == 0x0000A0, "Wrong size on URootMovie");
static_assert(offsetof(URootMovie, SwfAssetName) == 0x000030, "Member 'URootMovie::SwfAssetName' has a wrong offset!");
static_assert(offsetof(URootMovie, SwfMoviePlayer) == 0x000040, "Member 'URootMovie::SwfMoviePlayer' has a wrong offset!");
static_assert(offsetof(URootMovie, m_ScreenController) == 0x000058, "Member 'URootMovie::m_ScreenController' has a wrong offset!");
static_assert(offsetof(URootMovie, m_UIController) == 0x000060, "Member 'URootMovie::m_UIController' has a wrong offset!");
static_assert(offsetof(URootMovie, m_GameInstance) == 0x000068, "Member 'URootMovie::m_GameInstance' has a wrong offset!");

// Class DeadByDaylight.PanelScreen
// 0x0210 (0x0338 - 0x0128)
class UPanelScreen final : public UScreenBase
{
public:
	uint8                                         Pad_128[0x210];                                    // 0x0128(0x0210)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAvailableItemClicked(int32 clickedItemIndex);
	void OnAvailableItemsSortingChange(int32 newSorting);
	void OnBloodwebCenterButtonHovered();
	void OnBloodwebCenterButtonSelected();
	void OnCharacterSlotButtonClick(int32 characterIndex);
	void OnCharInfoClick();
	void OnConfirmCollectSelectedNode(int32 CharacterId);
	void OnCustomizationPresetClick(int32 Index_0);
	void OnEquipableSlotClicked(int32 clickedSlotCategory, int32 clickedSlotIndex);
	void OnLevelUpDone();
	void OnLevelUpShown();
	void OnNodeCollectionAnimDone();
	void OnNodeConsumptionAnimDone();
	void OnPanelsHidden();
	void OnPrestigeUp(int32 CharacterId);
	void OnRegenerateButtonClick(int32 CharacterId);
	void OnReservedBloodPoints(int32 CharacterId, int32 BloodPoints, bool fullCost);
	void OnSelectedEquipableSlotZoomChange(bool zoomIn);
	void OnSequenceStepCompleted(int32 CharacterId, int32 ID);
	void OnWebBuilt(int32 CharacterId, bool IsEmpty);
	void OnWebNodeHovered(int32 ID);
	void OnWebNodeSelected(int32 CharacterId, int32 ID, int32 nodeDepth);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PanelScreen">();
	}
	static class UPanelScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPanelScreen>();
	}
};
static_assert(alignof(UPanelScreen) == 0x000008, "Wrong alignment on UPanelScreen");
static_assert(sizeof(UPanelScreen) == 0x000338, "Wrong size on UPanelScreen");

// Class DeadByDaylight.ParticleSystemDistanceFaderComponent
// 0x0020 (0x00D8 - 0x00B8)
class UParticleSystemDistanceFaderComponent final : public UActorComponent
{
public:
	class UParticleSystemComponent*               ParticleSystemComponent;                           // 0x00B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   OpacityParameterName;                              // 0x00C0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartFadeDistance;                                 // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndFadeDistance;                                   // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleSystemDistanceFaderComponent">();
	}
	static class UParticleSystemDistanceFaderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleSystemDistanceFaderComponent>();
	}
};
static_assert(alignof(UParticleSystemDistanceFaderComponent) == 0x000008, "Wrong alignment on UParticleSystemDistanceFaderComponent");
static_assert(sizeof(UParticleSystemDistanceFaderComponent) == 0x0000D8, "Wrong size on UParticleSystemDistanceFaderComponent");
static_assert(offsetof(UParticleSystemDistanceFaderComponent, ParticleSystemComponent) == 0x0000B8, "Member 'UParticleSystemDistanceFaderComponent::ParticleSystemComponent' has a wrong offset!");
static_assert(offsetof(UParticleSystemDistanceFaderComponent, OpacityParameterName) == 0x0000C0, "Member 'UParticleSystemDistanceFaderComponent::OpacityParameterName' has a wrong offset!");
static_assert(offsetof(UParticleSystemDistanceFaderComponent, StartFadeDistance) == 0x0000CC, "Member 'UParticleSystemDistanceFaderComponent::StartFadeDistance' has a wrong offset!");
static_assert(offsetof(UParticleSystemDistanceFaderComponent, EndFadeDistance) == 0x0000D0, "Member 'UParticleSystemDistanceFaderComponent::EndFadeDistance' has a wrong offset!");

// Class DeadByDaylight.PawnAudioManager
// 0x0020 (0x0058 - 0x0038)
class UPawnAudioManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ForcePawnAudioPriority(class ADBDBasePlayer* Pawn);
	bool IsPawnCurrentlyActive(class ADBDBasePlayer* Pawn);
	bool PostAudioEventIfPawnCurrent(class ADBDBasePlayer* Pawn, class UAkAudioEvent* AudioEvent);
	void RegisterSlasherPawnAudio(class ADBDBasePlayer* SlasherPawn, TDelegate<void()> onAudioEnabled, TDelegate<void()> onAudioDisabled);
	void UnregisterSlasherPawnAudio(class ADBDBasePlayer* SlasherPawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PawnAudioManager">();
	}
	static class UPawnAudioManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPawnAudioManager>();
	}
};
static_assert(alignof(UPawnAudioManager) == 0x000008, "Wrong alignment on UPawnAudioManager");
static_assert(sizeof(UPawnAudioManager) == 0x000058, "Wrong size on UPawnAudioManager");

// Class DeadByDaylight.PerkCollectionComponent
// 0x0028 (0x00E0 - 0x00B8)
class UPerkCollectionComponent final : public UActorComponent
{
public:
	TArray<class UPerk*>                          _array;                                            // 0x00B8(0x0010)(ExportObject, Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x18];                                      // 0x00C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Array(const TArray<class UPerk*>& oldArray);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkCollectionComponent">();
	}
	static class UPerkCollectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerkCollectionComponent>();
	}
};
static_assert(alignof(UPerkCollectionComponent) == 0x000008, "Wrong alignment on UPerkCollectionComponent");
static_assert(sizeof(UPerkCollectionComponent) == 0x0000E0, "Wrong size on UPerkCollectionComponent");
static_assert(offsetof(UPerkCollectionComponent, _array) == 0x0000B8, "Member 'UPerkCollectionComponent::_array' has a wrong offset!");

// Class DeadByDaylight.PerkDataAsset
// 0x0000 (0x0090 - 0x0090)
class UPerkDataAsset final : public UGameplayModifierContainerDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkDataAsset">();
	}
	static class UPerkDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerkDataAsset>();
	}
};
static_assert(alignof(UPerkDataAsset) == 0x000008, "Wrong alignment on UPerkDataAsset");
static_assert(sizeof(UPerkDataAsset) == 0x000090, "Wrong size on UPerkDataAsset");

// Class DeadByDaylight.PerkManager
// 0x02C0 (0x0378 - 0x00B8)
class UPerkManager final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x28];                                      // 0x00B8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UPerkCollectionComponent*               _perks;                                            // 0x00E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStatusEffectCollectionComponent*       _statusEffects;                                    // 0x00E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkillCollectionComponent*              _skills;                                           // 0x00F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x280];                                     // 0x00F8(0x0280)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UStatusEffect* Authority_ImposeNewStatusEffectOfClassOrChangeLifeTime(TSubclassOf<class UStatusEffect> EffectClass, class ADBDPlayer* OriginatingPlayer, float Lifetime, float CustomParam, class UGameplayModifierContainer* OriginatingEffect, bool ShouldDisplay, bool replaceInfiniteLifetime);
	class UStatusEffect* Authority_ImposeStatusEffectFromTemplate(class UStatusEffect* effectTemplate, class ADBDPlayer* OriginatingPlayer, float CustomParam, class UGameplayModifierContainer* OriginatingEffect, bool ShouldDisplay, float Lifetime);
	class UStatusEffect* Authority_ImposeStatusEffectOfClass(TSubclassOf<class UStatusEffect> EffectClass, class ADBDPlayer* OriginatingPlayer, float CustomParam, class UGameplayModifierContainer* OriginatingEffect, bool ShouldDisplay, float Lifetime);
	void Authority_RemovePerks();
	void Authority_RemoveStatusEffect(class UStatusEffect* StatusEffect);
	void Authority_RemoveStatusEffectByClass(const class UClass* EffectClass, bool bRemoveAllOfSameClass);
	void Authority_SpawnPerk(class FName PerkId, int32 PerkLevel);

	TArray<class UGameplayModifierContainer*> GetAllSourcesWithFlag(const struct FGameplayTag& Flag) const;
	TArray<class UGameplayModifierContainer*> GetAllSourcesWithModifier(const struct FGameplayTag& Type) const;
	TArray<class UStatusEffect*> GetAllStatusEffects() const;
	TArray<class UStatusEffect*> GetAllStatusEffectsByClass(const class UClass* Type) const;
	TArray<class UStatusEffect*> GetAllStatusEffectsByID(const class FName& ID) const;
	float GetAveragePerkModifierValue(const struct FGameplayTag& Type) const;
	float GetCompoundedModifierValue(const struct FGameplayTag& Type) const;
	float GetMultiplicativeModifierValue(const struct FGameplayTag& Type) const;
	float GetMultiplicativeModifierValueOfContainerWithCompoundNegative(const struct FGameplayTagContainer& container) const;
	float GetMultiplicativeModifierValueWithCompoundNegative(const struct FGameplayTag& Type) const;
	class UPerk* GetPerk(class FName ID) const;
	float GetPerkModifier(const struct FGameplayTag& Type) const;
	float GetPerkModifierAdditiveValue(const struct FGameplayTag& Type, const float BaseValue) const;
	float GetPerkModifierMaxValue(const struct FGameplayTag& Type) const;
	float GetPerkModifierMaxValueAndSource(const struct FGameplayTag& Type, class UGameplayModifierContainer** outSource) const;
	float GetPerkModifierMinValue(const struct FGameplayTag& Type, float StartValue) const;
	float GetPerkModifierMinValueAndSource(const struct FGameplayTag& Type, float StartValue, class UGameplayModifierContainer** outSource) const;
	const TArray<class UPerk*> GetPerks() const;
	class UGameplayModifierContainer* GetSourceWithFlag(const struct FGameplayTag& Flag) const;
	class UGameplayModifierContainer* GetSourceWithModifier(const struct FGameplayTag& Type) const;
	class UStatusEffect* GetStatusEffectByClass(const class UClass* Type) const;
	bool HasAllCharacterPerksEquipped() const;
	bool HasAnyAddonWithTag(class FName Tag) const;
	bool HasPerkFlag(const struct FGameplayTag& Flag) const;
	bool HasPerkFlagFromSource(const struct FGameplayTag& Flag, EGameplayModifierSource modifierSource) const;
	bool HasPerkFlags(const TArray<struct FGameplayTag>& Flags_0) const;
	bool HasPerkModifierOfType(const struct FGameplayTag& Type) const;
	bool HasPerkSubFlag(const struct FGameplayTag& subFlag) const;
	bool HasStatusEffect(const class FName statusEffectId) const;
	bool HasStatusEffectOfClass(const class UClass* Type, bool includeChildrenOf) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkManager">();
	}
	static class UPerkManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerkManager>();
	}
};
static_assert(alignof(UPerkManager) == 0x000008, "Wrong alignment on UPerkManager");
static_assert(sizeof(UPerkManager) == 0x000378, "Wrong size on UPerkManager");
static_assert(offsetof(UPerkManager, _perks) == 0x0000E0, "Member 'UPerkManager::_perks' has a wrong offset!");
static_assert(offsetof(UPerkManager, _statusEffects) == 0x0000E8, "Member 'UPerkManager::_statusEffects' has a wrong offset!");
static_assert(offsetof(UPerkManager, _skills) == 0x0000F0, "Member 'UPerkManager::_skills' has a wrong offset!");

// Class DeadByDaylight.PerkManagerOwnerInterface
// 0x0000 (0x0000 - 0x0000)
class IPerkManagerOwnerInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkManagerOwnerInterface">();
	}
	static class IPerkManagerOwnerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPerkManagerOwnerInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPerkManagerOwnerInterface) == 0x000001, "Wrong alignment on IPerkManagerOwnerInterface");
static_assert(sizeof(IPerkManagerOwnerInterface) == 0x000001, "Wrong size on IPerkManagerOwnerInterface");

// Class DeadByDaylight.PerkOwnerInterface
// 0x0000 (0x0000 - 0x0000)
class IPerkOwnerInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkOwnerInterface">();
	}
	static class IPerkOwnerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPerkOwnerInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPerkOwnerInterface) == 0x000001, "Wrong alignment on IPerkOwnerInterface");
static_assert(sizeof(IPerkOwnerInterface) == 0x000001, "Wrong size on IPerkOwnerInterface");

// Class DeadByDaylight.ScreenController
// 0x02B0 (0x02E0 - 0x0030)
class UScreenController final : public UObject
{
public:
	class UDBDGameInstance*                       _gameInstance;                                     // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGFxObject*                             _screenControllerObj;                              // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGFxMoviePlayer*                        _moviePlayer;                                      // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FString, class UScreenBase*>       _screenDictionary;                                 // 0x0048(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FString, EScreenType>              _screenTypeDictionary;                             // 0x0098(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class UClass*, TWeakObjectPtr<class UUserWidget>> _cachedUMGScreens;                        // 0x00E8(0x0050)(ExportObject, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_138[0x1A8];                                    // 0x0138(0x01A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenController">();
	}
	static class UScreenController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenController>();
	}
};
static_assert(alignof(UScreenController) == 0x000008, "Wrong alignment on UScreenController");
static_assert(sizeof(UScreenController) == 0x0002E0, "Wrong size on UScreenController");
static_assert(offsetof(UScreenController, _gameInstance) == 0x000030, "Member 'UScreenController::_gameInstance' has a wrong offset!");
static_assert(offsetof(UScreenController, _screenControllerObj) == 0x000038, "Member 'UScreenController::_screenControllerObj' has a wrong offset!");
static_assert(offsetof(UScreenController, _moviePlayer) == 0x000040, "Member 'UScreenController::_moviePlayer' has a wrong offset!");
static_assert(offsetof(UScreenController, _screenDictionary) == 0x000048, "Member 'UScreenController::_screenDictionary' has a wrong offset!");
static_assert(offsetof(UScreenController, _screenTypeDictionary) == 0x000098, "Member 'UScreenController::_screenTypeDictionary' has a wrong offset!");
static_assert(offsetof(UScreenController, _cachedUMGScreens) == 0x0000E8, "Member 'UScreenController::_cachedUMGScreens' has a wrong offset!");

// Class DeadByDaylight.PerkTrappableComponent
// 0x0048 (0x0100 - 0x00B8)
class UPerkTrappableComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(const ETrapType trapType)> OnAddTrap;                              // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const ETrapType trapType)> OnRemoveTrap;                           // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class AInteractable>              _interactableType;                                 // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<ETrapType>                             _trapsOnInteractable;                              // 0x00E0(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0[0x10];                                      // 0x00F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_TrapsOnInteractable();

	bool HasAnyTrap() const;
	bool HasTrap(const ETrapType trapType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkTrappableComponent">();
	}
	static class UPerkTrappableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerkTrappableComponent>();
	}
};
static_assert(alignof(UPerkTrappableComponent) == 0x000008, "Wrong alignment on UPerkTrappableComponent");
static_assert(sizeof(UPerkTrappableComponent) == 0x000100, "Wrong size on UPerkTrappableComponent");
static_assert(offsetof(UPerkTrappableComponent, OnAddTrap) == 0x0000B8, "Member 'UPerkTrappableComponent::OnAddTrap' has a wrong offset!");
static_assert(offsetof(UPerkTrappableComponent, OnRemoveTrap) == 0x0000C8, "Member 'UPerkTrappableComponent::OnRemoveTrap' has a wrong offset!");
static_assert(offsetof(UPerkTrappableComponent, _interactableType) == 0x0000D8, "Member 'UPerkTrappableComponent::_interactableType' has a wrong offset!");
static_assert(offsetof(UPerkTrappableComponent, _trapsOnInteractable) == 0x0000E0, "Member 'UPerkTrappableComponent::_trapsOnInteractable' has a wrong offset!");

// Class DeadByDaylight.PerkUtilitiesInterface
// 0x0000 (0x0000 - 0x0000)
class IPerkUtilitiesInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkUtilitiesInterface">();
	}
	static class IPerkUtilitiesInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPerkUtilitiesInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPerkUtilitiesInterface) == 0x000001, "Wrong alignment on IPerkUtilitiesInterface");
static_assert(sizeof(IPerkUtilitiesInterface) == 0x000001, "Wrong size on IPerkUtilitiesInterface");

// Class DeadByDaylight.PlayerCardSubsystem
// 0x0000 (0x0038 - 0x0038)
class UPlayerCardSubsystem final : public UGameInstanceSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCardSubsystem">();
	}
	static class UPlayerCardSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerCardSubsystem>();
	}
};
static_assert(alignof(UPlayerCardSubsystem) == 0x000008, "Wrong alignment on UPlayerCardSubsystem");
static_assert(sizeof(UPlayerCardSubsystem) == 0x000038, "Wrong size on UPlayerCardSubsystem");

// Class DeadByDaylight.PlayerInGameAssetPreloadState
// 0x0018 (0x00D0 - 0x00B8)
class UPlayerInGameAssetPreloadState final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Server_SetPreloadCompleted(const class FString& preloadInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerInGameAssetPreloadState">();
	}
	static class UPlayerInGameAssetPreloadState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerInGameAssetPreloadState>();
	}
};
static_assert(alignof(UPlayerInGameAssetPreloadState) == 0x000008, "Wrong alignment on UPlayerInGameAssetPreloadState");
static_assert(sizeof(UPlayerInGameAssetPreloadState) == 0x0000D0, "Wrong size on UPlayerInGameAssetPreloadState");

// Class DeadByDaylight.PlayerMoveBackAndForthComponent
// 0x0050 (0x0108 - 0x00B8)
class UPlayerMoveBackAndForthComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x50];                                      // 0x00B8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMoveTimerDone();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerMoveBackAndForthComponent">();
	}
	static class UPlayerMoveBackAndForthComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerMoveBackAndForthComponent>();
	}
};
static_assert(alignof(UPlayerMoveBackAndForthComponent) == 0x000008, "Wrong alignment on UPlayerMoveBackAndForthComponent");
static_assert(sizeof(UPlayerMoveBackAndForthComponent) == 0x000108, "Wrong size on UPlayerMoveBackAndForthComponent");

// Class DeadByDaylight.PlayerReportManager
// 0x00A0 (0x00D8 - 0x0038)
class UPlayerReportManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDGameInstance*                       _gameInstance;                                     // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x90];                                      // 0x0048(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerReportManager">();
	}
	static class UPlayerReportManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerReportManager>();
	}
};
static_assert(alignof(UPlayerReportManager) == 0x000008, "Wrong alignment on UPlayerReportManager");
static_assert(sizeof(UPlayerReportManager) == 0x0000D8, "Wrong size on UPlayerReportManager");
static_assert(offsetof(UPlayerReportManager, _gameInstance) == 0x000040, "Member 'UPlayerReportManager::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.PlayerStateScoreEmitter
// 0x00B8 (0x00F0 - 0x0038)
class UPlayerStateScoreEmitter final : public UPlayerScoreEmitter
{
public:
	struct FGameplayTag                           _scoreTag;                                         // 0x0038(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _scoreUpdateInterval;                              // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTagQuery                      _tagQuery;                                         // 0x0048(0x0048)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x60];                                      // 0x0090(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStateScoreEmitter">();
	}
	static class UPlayerStateScoreEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerStateScoreEmitter>();
	}
};
static_assert(alignof(UPlayerStateScoreEmitter) == 0x000008, "Wrong alignment on UPlayerStateScoreEmitter");
static_assert(sizeof(UPlayerStateScoreEmitter) == 0x0000F0, "Wrong size on UPlayerStateScoreEmitter");
static_assert(offsetof(UPlayerStateScoreEmitter, _scoreTag) == 0x000038, "Member 'UPlayerStateScoreEmitter::_scoreTag' has a wrong offset!");
static_assert(offsetof(UPlayerStateScoreEmitter, _scoreUpdateInterval) == 0x000044, "Member 'UPlayerStateScoreEmitter::_scoreUpdateInterval' has a wrong offset!");
static_assert(offsetof(UPlayerStateScoreEmitter, _tagQuery) == 0x000048, "Member 'UPlayerStateScoreEmitter::_tagQuery' has a wrong offset!");

// Class DeadByDaylight.PoolableProjectileComponent
// 0x0000 (0x00F0 - 0x00F0)
class UPoolableProjectileComponent final : public UAuthoritativePoolableActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoolableProjectileComponent">();
	}
	static class UPoolableProjectileComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPoolableProjectileComponent>();
	}
};
static_assert(alignof(UPoolableProjectileComponent) == 0x000008, "Wrong alignment on UPoolableProjectileComponent");
static_assert(sizeof(UPoolableProjectileComponent) == 0x0000F0, "Wrong size on UPoolableProjectileComponent");

// Class DeadByDaylight.PowerWidgetData
// 0x0070 (0x00A8 - 0x0038)
class UPowerWidgetData final : public UDataAsset
{
public:
	TMap<struct FGameplayTag, TSoftObjectPtr<class UTexture2D>> _icons;                              // 0x0038(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	class FName                                   _widgetId;                                         // 0x0088(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EInputInteractionType                         _interactionInputType;                             // 0x0094(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EInteractionPromptType                        _interactionPromptType;                            // 0x0095(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_96[0x2];                                       // 0x0096(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _presentationId;                                   // 0x0098(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PowerWidgetData">();
	}
	static class UPowerWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPowerWidgetData>();
	}
};
static_assert(alignof(UPowerWidgetData) == 0x000008, "Wrong alignment on UPowerWidgetData");
static_assert(sizeof(UPowerWidgetData) == 0x0000A8, "Wrong size on UPowerWidgetData");
static_assert(offsetof(UPowerWidgetData, _icons) == 0x000038, "Member 'UPowerWidgetData::_icons' has a wrong offset!");
static_assert(offsetof(UPowerWidgetData, _widgetId) == 0x000088, "Member 'UPowerWidgetData::_widgetId' has a wrong offset!");
static_assert(offsetof(UPowerWidgetData, _interactionInputType) == 0x000094, "Member 'UPowerWidgetData::_interactionInputType' has a wrong offset!");
static_assert(offsetof(UPowerWidgetData, _interactionPromptType) == 0x000095, "Member 'UPowerWidgetData::_interactionPromptType' has a wrong offset!");
static_assert(offsetof(UPowerWidgetData, _presentationId) == 0x000098, "Member 'UPowerWidgetData::_presentationId' has a wrong offset!");

// Class DeadByDaylight.ProceduralGenerationData
// 0x0140 (0x0178 - 0x0038)
class UProceduralGenerationData final : public UDataAsset
{
public:
	TArray<struct FQuadrantSpawnTypeProperties>   QuadrantSpawnTypeProperties;                       // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FQuadrantSpawnCategories>       QuadrantSpawnCategories;                           // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FThemeProperties>               ThemeProperties;                                   // 0x0058(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	TArray<struct FKillerItemDependencies>        KillersItemDependencies;                           // 0x0068(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SurvivorItemPopulationProbability;                 // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSurvivorItemProperties>        SurvivorItemProperty;                              // 0x0080(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FEscapeTypeObjects>             EscapeTypeActors;                                  // 0x0090(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           Basements;                                         // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FGameplayElementsPopulation>    ElementsPopulation;                                // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FManagedGameplayElementsPopulation> ManagedElementsPopulation;                     // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSurvivorGroupingProbability>   SurvivorGroupingProbabilities;                     // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVector                                ProceduralMapOffset;                               // 0x00E0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProceduralTileWidth;                               // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProceduralTileHeight;                              // 0x00FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ProceduralQuadTileMapOffset;                       // 0x0100(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProceduralQuadTileCubeWidth;                       // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DifficultyModifier;                                // 0x011C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterCameraHeight;                             // 0x0120(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterCollisionRadius;                          // 0x0124(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnerCollisionRadius;                            // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotemVisualHeight;                                 // 0x012C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClosestSurvivorDistanceWeight;                     // 0x0130(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KillerDistanceWeight;                              // 0x0134(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxMapTilesForDistantKillerSpawn;                  // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpecialBehaviourPopulation>    SpecialBehaviourPopulation;                        // 0x0140(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPrivate)
	TArray<struct FEventSubstitutionData>         _eventProperties;                                  // 0x0150(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPrivate)
	uint8                                         Pad_160[0x18];                                     // 0x0160(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralGenerationData">();
	}
	static class UProceduralGenerationData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralGenerationData>();
	}
};
static_assert(alignof(UProceduralGenerationData) == 0x000008, "Wrong alignment on UProceduralGenerationData");
static_assert(sizeof(UProceduralGenerationData) == 0x000178, "Wrong size on UProceduralGenerationData");
static_assert(offsetof(UProceduralGenerationData, QuadrantSpawnTypeProperties) == 0x000038, "Member 'UProceduralGenerationData::QuadrantSpawnTypeProperties' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, QuadrantSpawnCategories) == 0x000048, "Member 'UProceduralGenerationData::QuadrantSpawnCategories' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, ThemeProperties) == 0x000058, "Member 'UProceduralGenerationData::ThemeProperties' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, KillersItemDependencies) == 0x000068, "Member 'UProceduralGenerationData::KillersItemDependencies' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, SurvivorItemPopulationProbability) == 0x000078, "Member 'UProceduralGenerationData::SurvivorItemPopulationProbability' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, SurvivorItemProperty) == 0x000080, "Member 'UProceduralGenerationData::SurvivorItemProperty' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, EscapeTypeActors) == 0x000090, "Member 'UProceduralGenerationData::EscapeTypeActors' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, Basements) == 0x0000A0, "Member 'UProceduralGenerationData::Basements' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, ElementsPopulation) == 0x0000B0, "Member 'UProceduralGenerationData::ElementsPopulation' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, ManagedElementsPopulation) == 0x0000C0, "Member 'UProceduralGenerationData::ManagedElementsPopulation' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, SurvivorGroupingProbabilities) == 0x0000D0, "Member 'UProceduralGenerationData::SurvivorGroupingProbabilities' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, ProceduralMapOffset) == 0x0000E0, "Member 'UProceduralGenerationData::ProceduralMapOffset' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, ProceduralTileWidth) == 0x0000F8, "Member 'UProceduralGenerationData::ProceduralTileWidth' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, ProceduralTileHeight) == 0x0000FC, "Member 'UProceduralGenerationData::ProceduralTileHeight' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, ProceduralQuadTileMapOffset) == 0x000100, "Member 'UProceduralGenerationData::ProceduralQuadTileMapOffset' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, ProceduralQuadTileCubeWidth) == 0x000118, "Member 'UProceduralGenerationData::ProceduralQuadTileCubeWidth' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, DifficultyModifier) == 0x00011C, "Member 'UProceduralGenerationData::DifficultyModifier' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, CharacterCameraHeight) == 0x000120, "Member 'UProceduralGenerationData::CharacterCameraHeight' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, CharacterCollisionRadius) == 0x000124, "Member 'UProceduralGenerationData::CharacterCollisionRadius' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, SpawnerCollisionRadius) == 0x000128, "Member 'UProceduralGenerationData::SpawnerCollisionRadius' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, TotemVisualHeight) == 0x00012C, "Member 'UProceduralGenerationData::TotemVisualHeight' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, ClosestSurvivorDistanceWeight) == 0x000130, "Member 'UProceduralGenerationData::ClosestSurvivorDistanceWeight' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, KillerDistanceWeight) == 0x000134, "Member 'UProceduralGenerationData::KillerDistanceWeight' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, MaxMapTilesForDistantKillerSpawn) == 0x000138, "Member 'UProceduralGenerationData::MaxMapTilesForDistantKillerSpawn' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, SpecialBehaviourPopulation) == 0x000140, "Member 'UProceduralGenerationData::SpecialBehaviourPopulation' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, _eventProperties) == 0x000150, "Member 'UProceduralGenerationData::_eventProperties' has a wrong offset!");

// Class DeadByDaylight.PromoCodeManager
// 0x0018 (0x0050 - 0x0038)
class UPromoCodeManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PromoCodeManager">();
	}
	static class UPromoCodeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPromoCodeManager>();
	}
};
static_assert(alignof(UPromoCodeManager) == 0x000008, "Wrong alignment on UPromoCodeManager");
static_assert(sizeof(UPromoCodeManager) == 0x000050, "Wrong size on UPromoCodeManager");

// Class DeadByDaylight.ProximityToSpawnPointTypeIterativeWeightAdjustmentStrategy
// 0x0008 (0x00A8 - 0x00A0)
class UProximityToSpawnPointTypeIterativeWeightAdjustmentStrategy final : public UProximityToActorsIterativeWeightAdjustmentStrategy
{
public:
	ETileSpawnPointType                           _spawnPointType;                                   // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProximityToSpawnPointTypeIterativeWeightAdjustmentStrategy">();
	}
	static class UProximityToSpawnPointTypeIterativeWeightAdjustmentStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProximityToSpawnPointTypeIterativeWeightAdjustmentStrategy>();
	}
};
static_assert(alignof(UProximityToSpawnPointTypeIterativeWeightAdjustmentStrategy) == 0x000008, "Wrong alignment on UProximityToSpawnPointTypeIterativeWeightAdjustmentStrategy");
static_assert(sizeof(UProximityToSpawnPointTypeIterativeWeightAdjustmentStrategy) == 0x0000A8, "Wrong size on UProximityToSpawnPointTypeIterativeWeightAdjustmentStrategy");
static_assert(offsetof(UProximityToSpawnPointTypeIterativeWeightAdjustmentStrategy, _spawnPointType) == 0x0000A0, "Member 'UProximityToSpawnPointTypeIterativeWeightAdjustmentStrategy::_spawnPointType' has a wrong offset!");

// Class DeadByDaylight.PushableInterface
// 0x0000 (0x0000 - 0x0000)
class IPushableInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PushableInterface">();
	}
	static class IPushableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPushableInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPushableInterface) == 0x000001, "Wrong alignment on IPushableInterface");
static_assert(sizeof(IPushableInterface) == 0x000001, "Wrong size on IPushableInterface");

// Class DeadByDaylight.RecentGameEventTracker
// 0x00A0 (0x00D8 - 0x0038)
class URecentGameEventTracker final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0xA0];                                      // 0x0038(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RecentGameEventTracker">();
	}
	static class URecentGameEventTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<URecentGameEventTracker>();
	}
};
static_assert(alignof(URecentGameEventTracker) == 0x000008, "Wrong alignment on URecentGameEventTracker");
static_assert(sizeof(URecentGameEventTracker) == 0x0000D8, "Wrong size on URecentGameEventTracker");

// Class DeadByDaylight.RegionFinder
// 0x0078 (0x00A8 - 0x0030)
class URegionFinder : public UObject
{
public:
	TArray<struct FRegion>                        Regions;                                           // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         TIMEOUT;                                           // 0x0040(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x64];                                      // 0x0044(0x0064)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RegionFinder">();
	}
	static class URegionFinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<URegionFinder>();
	}
};
static_assert(alignof(URegionFinder) == 0x000008, "Wrong alignment on URegionFinder");
static_assert(sizeof(URegionFinder) == 0x0000A8, "Wrong size on URegionFinder");
static_assert(offsetof(URegionFinder, Regions) == 0x000030, "Member 'URegionFinder::Regions' has a wrong offset!");
static_assert(offsetof(URegionFinder, TIMEOUT) == 0x000040, "Member 'URegionFinder::TIMEOUT' has a wrong offset!");

// Class DeadByDaylight.RestrictedPlacementAreaDefaultStrategy
// 0x0008 (0x00B0 - 0x00A8)
class URestrictedPlacementAreaDefaultStrategy final : public URestrictedPlacementAreaStrategy
{
public:
	TSubclassOf<class AActor>                     RestrictedActor;                                   // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RestrictedPlacementAreaDefaultStrategy">();
	}
	static class URestrictedPlacementAreaDefaultStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<URestrictedPlacementAreaDefaultStrategy>();
	}
};
static_assert(alignof(URestrictedPlacementAreaDefaultStrategy) == 0x000008, "Wrong alignment on URestrictedPlacementAreaDefaultStrategy");
static_assert(sizeof(URestrictedPlacementAreaDefaultStrategy) == 0x0000B0, "Wrong size on URestrictedPlacementAreaDefaultStrategy");
static_assert(offsetof(URestrictedPlacementAreaDefaultStrategy, RestrictedActor) == 0x0000A8, "Member 'URestrictedPlacementAreaDefaultStrategy::RestrictedActor' has a wrong offset!");

// Class DeadByDaylight.ReverseBearTrap
// 0x00B8 (0x0460 - 0x03A8)
class AReverseBearTrap final : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 _rbtMesh;                                          // 0x03B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationMontageSlave*                 _animMontageSlave;                                 // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C0[0x4];                                      // 0x03C0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _keyID;                                            // 0x03C4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _attemptsNeededToDetach;                           // 0x03C8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3CC[0x8C];                                     // 0x03CC(0x008C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _exitGatesPoweredAfterAttachment;                  // 0x0458(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _generatorFixedAfterAttachment;                    // 0x0459(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_45A[0x6];                                      // 0x045A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttachSurvivor(class ASurvivor* Survivor);
	void Authority_GenerateAttemptsNeeded(const int32 remainingAttemptsTotal, const int32 remainingRBTs, const int32 numRemovers);
	void Authority_OnGeneratorRepaired(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData);
	void Authority_SetKeyID(int32 KeyId);
	void DetachSurvivor(class ASurvivor* Survivor);
	void FastForwardExecutionTimer(float DeltaTime);
	void IncrementAttemptsMade();
	void NotifyDetachStarted(class ASurvivor* Survivor);
	void NotifyOnAttachSurvivorBegin(class ASurvivor* Survivor);
	void OnAttachSurvivor(class ASurvivor* Survivor);
	void OnAttachSurvivorBegin(class ASurvivor* Survivor);
	void OnDetachSurvivor(class ASurvivor* Survivor);
	void OnEnterWarningZone();
	void OnExitWarningZone();
	void OnWarningLevelChanged(int32 previousWarningLevel, int32 currentWarningLevel);
	void ResetExecutionTimer(float Time);
	void SetGateClosedAtAttachment(bool CLOSED);
	void SetVisible(bool Visible);
	void StopExecutionTimer();
	void StopMontage();

	bool CanExecute() const;
	class ASurvivor* GetAttachedSurvivor() const;
	int32 GetAttemptsMade() const;
	int32 GetAttemptsNeeded() const;
	float GetExecutionTimerPercentTimeElapsed() const;
	float GetExecutionTimerTimeLeft() const;
	bool GetExitGatesPoweredAfterAttachment() const;
	bool GetGeneratorFixedAfterAttachment() const;
	int32 GetKeyID() const;
	class AKiller* GetOwningKiller() const;
	int32 GetWarningLevel() const;
	bool GetWasGateClosedAtAttachment() const;
	bool HasDetachStarted() const;
	bool IsExecutionTimerActive() const;
	bool IsExecutionTimerDone() const;
	bool IsInWarningZone() const;
	bool IsRBTActivated() const;
	bool ShouldUpdateExecutionTimer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReverseBearTrap">();
	}
	static class AReverseBearTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReverseBearTrap>();
	}
};
static_assert(alignof(AReverseBearTrap) == 0x000008, "Wrong alignment on AReverseBearTrap");
static_assert(sizeof(AReverseBearTrap) == 0x000460, "Wrong size on AReverseBearTrap");
static_assert(offsetof(AReverseBearTrap, _rbtMesh) == 0x0003B0, "Member 'AReverseBearTrap::_rbtMesh' has a wrong offset!");
static_assert(offsetof(AReverseBearTrap, _animMontageSlave) == 0x0003B8, "Member 'AReverseBearTrap::_animMontageSlave' has a wrong offset!");
static_assert(offsetof(AReverseBearTrap, _keyID) == 0x0003C4, "Member 'AReverseBearTrap::_keyID' has a wrong offset!");
static_assert(offsetof(AReverseBearTrap, _attemptsNeededToDetach) == 0x0003C8, "Member 'AReverseBearTrap::_attemptsNeededToDetach' has a wrong offset!");
static_assert(offsetof(AReverseBearTrap, _exitGatesPoweredAfterAttachment) == 0x000458, "Member 'AReverseBearTrap::_exitGatesPoweredAfterAttachment' has a wrong offset!");
static_assert(offsetof(AReverseBearTrap, _generatorFixedAfterAttachment) == 0x000459, "Member 'AReverseBearTrap::_generatorFixedAfterAttachment' has a wrong offset!");

// Class DeadByDaylight.RewardTrackContainer
// 0x01C0 (0x01F0 - 0x0030)
class URewardTrackContainer final : public UObject
{
public:
	uint8                                         Pad_30[0x1C0];                                     // 0x0030(0x01C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RewardTrackContainer">();
	}
	static class URewardTrackContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<URewardTrackContainer>();
	}
};
static_assert(alignof(URewardTrackContainer) == 0x000008, "Wrong alignment on URewardTrackContainer");
static_assert(sizeof(URewardTrackContainer) == 0x0001F0, "Wrong size on URewardTrackContainer");

// Class DeadByDaylight.S3GameConfigs
// 0x06A0 (0x06D8 - 0x0038)
class US3GameConfigs final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x6A0];                                     // 0x0038(0x06A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S3GameConfigs">();
	}
	static class US3GameConfigs* GetDefaultObj()
	{
		return GetDefaultObjImpl<US3GameConfigs>();
	}
};
static_assert(alignof(US3GameConfigs) == 0x000008, "Wrong alignment on US3GameConfigs");
static_assert(sizeof(US3GameConfigs) == 0x0006D8, "Wrong size on US3GameConfigs");

// Class DeadByDaylight.SacrificeEnd
// 0x0000 (0x02F0 - 0x02F0)
class ASacrificeEnd final : public AEmitter
{
public:
	void FX_SacrificeEnd();
	void FX_SacrificeEnd_Basement();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SacrificeEnd">();
	}
	static class ASacrificeEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASacrificeEnd>();
	}
};
static_assert(alignof(ASacrificeEnd) == 0x000008, "Wrong alignment on ASacrificeEnd");
static_assert(sizeof(ASacrificeEnd) == 0x0002F0, "Wrong size on ASacrificeEnd");

// Class DeadByDaylight.ScourgeHookManagerComponent
// 0x0098 (0x0150 - 0x00B8)
class UScourgeHookManagerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x88];                                      // 0x00B8(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AMeatHook>>       _scourgeHooks;                                     // 0x0140(0x0010)(Net, ZeroConstructor, Transient, RepNotify, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void OnLocallyObservedChanged();
	void OnRep_ScourgeHooks();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScourgeHookManagerComponent">();
	}
	static class UScourgeHookManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScourgeHookManagerComponent>();
	}
};
static_assert(alignof(UScourgeHookManagerComponent) == 0x000008, "Wrong alignment on UScourgeHookManagerComponent");
static_assert(sizeof(UScourgeHookManagerComponent) == 0x000150, "Wrong size on UScourgeHookManagerComponent");
static_assert(offsetof(UScourgeHookManagerComponent, _scourgeHooks) == 0x000140, "Member 'UScourgeHookManagerComponent::_scourgeHooks' has a wrong offset!");

// Class DeadByDaylight.ScreamComponent
// 0x0040 (0x00F8 - 0x00B8)
class UScreamComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(const float screamRevealDuration, const bool SpawnBubbleIndicator)> _onScreamRevealOwner; // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UPerkManager*                           _perkManager;                                      // 0x00C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMontagePlayer*                         _montagePlayer;                                    // 0x00D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AActor>                     _bubbleIndicator;                                  // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMesh*                            _silhouetteStaticMesh;                             // 0x00E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                   _tagsPreventingScream;                             // 0x00E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void OnDamageStateChanged(EHealthState oldDamageState, EHealthState newDamageState);

	bool CanScream() const;
	bool GetCanScreamAndPreventNextScreamIfNeeded() const;
	void ScreamRevealOwner(const bool SpawnBubbleIndicator, const float screamRevealDuration) const;
	bool TriggerScreamEventsAndAndAnimationIfPossible(bool fireLoudNoiseEvent, const struct FMontagePlaybackDefinition& montageDefinition, float audibleRange) const;
	bool TriggerScreamEventsIfPossible(bool fireLoudNoiseEvent, float audibleRange) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreamComponent">();
	}
	static class UScreamComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreamComponent>();
	}
};
static_assert(alignof(UScreamComponent) == 0x000008, "Wrong alignment on UScreamComponent");
static_assert(sizeof(UScreamComponent) == 0x0000F8, "Wrong size on UScreamComponent");
static_assert(offsetof(UScreamComponent, _onScreamRevealOwner) == 0x0000B8, "Member 'UScreamComponent::_onScreamRevealOwner' has a wrong offset!");
static_assert(offsetof(UScreamComponent, _perkManager) == 0x0000C8, "Member 'UScreamComponent::_perkManager' has a wrong offset!");
static_assert(offsetof(UScreamComponent, _montagePlayer) == 0x0000D0, "Member 'UScreamComponent::_montagePlayer' has a wrong offset!");
static_assert(offsetof(UScreamComponent, _bubbleIndicator) == 0x0000D8, "Member 'UScreamComponent::_bubbleIndicator' has a wrong offset!");
static_assert(offsetof(UScreamComponent, _silhouetteStaticMesh) == 0x0000E0, "Member 'UScreamComponent::_silhouetteStaticMesh' has a wrong offset!");
static_assert(offsetof(UScreamComponent, _tagsPreventingScream) == 0x0000E8, "Member 'UScreamComponent::_tagsPreventingScream' has a wrong offset!");

// Class DeadByDaylight.ScreenshotTool
// 0x0000 (0x03F8 - 0x03F8)
class AScreenshotTool final : public ACharacterTool
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenshotTool">();
	}
	static class AScreenshotTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScreenshotTool>();
	}
};
static_assert(alignof(AScreenshotTool) == 0x000008, "Wrong alignment on AScreenshotTool");
static_assert(sizeof(AScreenshotTool) == 0x0003F8, "Wrong size on AScreenshotTool");

// Class DeadByDaylight.ScreenshotToolViewAsset
// 0x0050 (0x0090 - 0x0040)
class UScreenshotToolViewAsset final : public UScreenshotToolSettingAsset
{
public:
	TMap<ECustomizationCategory, struct FScreenshotViewSetting> Defaults;                            // 0x0040(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenshotToolViewAsset">();
	}
	static class UScreenshotToolViewAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenshotToolViewAsset>();
	}
};
static_assert(alignof(UScreenshotToolViewAsset) == 0x000008, "Wrong alignment on UScreenshotToolViewAsset");
static_assert(sizeof(UScreenshotToolViewAsset) == 0x000090, "Wrong size on UScreenshotToolViewAsset");
static_assert(offsetof(UScreenshotToolViewAsset, Defaults) == 0x000040, "Member 'UScreenshotToolViewAsset::Defaults' has a wrong offset!");

// Class DeadByDaylight.ScreenshotToolSceneAsset
// 0x0050 (0x0090 - 0x0040)
class UScreenshotToolSceneAsset final : public UScreenshotToolSettingAsset
{
public:
	TMap<ECustomizationCategory, struct FScreenshotSceneSetting> Defaults;                           // 0x0040(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenshotToolSceneAsset">();
	}
	static class UScreenshotToolSceneAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenshotToolSceneAsset>();
	}
};
static_assert(alignof(UScreenshotToolSceneAsset) == 0x000008, "Wrong alignment on UScreenshotToolSceneAsset");
static_assert(sizeof(UScreenshotToolSceneAsset) == 0x000090, "Wrong size on UScreenshotToolSceneAsset");
static_assert(offsetof(UScreenshotToolSceneAsset, Defaults) == 0x000040, "Member 'UScreenshotToolSceneAsset::Defaults' has a wrong offset!");

// Class DeadByDaylight.ScreenshotToolHook
// 0x0000 (0x0000 - 0x0000)
class IScreenshotToolHook final
{
public:
	void PostBatchItems(const TArray<struct FCharacterToolItemData>& Items);
	void PostHookConstruction();
	void PostSpawnCharacter(class ADBDMenuPlayer* Character);
	void PostSpawnCharm(class ACharm* Charm);
	void PostStateChanged(EScreenshotToolState previousState, EScreenshotToolState CurrentState);
	void PostTakeItemScreenshot(const struct FCharacterToolItemData& Item, bool Success);
	void PostUpdateCharacter(class ADBDMenuPlayer* Character);
	void PreBatchItems();
	void PreDestroyCharacter(class ADBDMenuPlayer* Character);
	void PreDestroyCharm(class ACharm* Charm);
	void PreHookDestruction();
	void PreSpawnCharacter(class ADBDMenuPlayer* Character, struct FCharacterToolSpawnParameters* SpawnParams);
	void PreSpawnCharm(const struct FCustomizationItemData& Item);
	void PreTakeItemScreenshot(const struct FCharacterToolItemData& Item);
	void ScreenshotBeginPlay(bool isPIE);

	bool IsPIEOnly() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenshotToolHook">();
	}
	static class IScreenshotToolHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<IScreenshotToolHook>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IScreenshotToolHook) == 0x000001, "Wrong alignment on IScreenshotToolHook");
static_assert(sizeof(IScreenshotToolHook) == 0x000001, "Wrong size on IScreenshotToolHook");

// Class DeadByDaylight.SeanceRitualSpot
// 0x00B0 (0x0458 - 0x03A8)
class ASeanceRitualSpot final : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x10];                                     // 0x03A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAttachInteractionComponent*            _attachInteractionComponent;                       // 0x03B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChargeableComponent*                   _ritualChargeable;                                 // 0x03C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _secondsToCharge;                                  // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _dechargeRate;                                     // 0x03CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASurvivor*                              _ritualOriginator;                                 // 0x03D0(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USeancePerk>                _ritualPerformed;                                  // 0x03D8(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ASurvivor*>                      _survivorsPerformingRitual;                        // 0x03E0(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _revealAuraEffectClass;                            // 0x03F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UInteractionDefinition>     _ritualInteractionDefinitionParentClass;           // 0x03F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isSpotUsable;                                     // 0x0400(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_401[0x7];                                      // 0x0401(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ADBDPlayer*, float>                _authority_progressAmountsCumulative;              // 0x0408(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	void Authority_OnChargeApplied(float IndividualChargeAmount, float TotalChargeAmount, class AActor* ChargeInstigator, bool WasCoop, float DeltaTime);
	void Authority_OnPerformRitualChargePercentChanged(class UChargeableComponent* ChargeableComponent, float PercentCompletionChange, float TotalPercentComplete);
	void Cosmetic_OnInteractionCompleted();
	void Cosmetic_OnInteractionUpdate(const class ADBDPlayer* interactingPlayer, const float ChargePercent);
	void Cosmetic_OnStartedInteracting(class ADBDPlayer* interactingPlayer, bool isOriginator);
	void Cosmetic_OnStoppedInteracting(bool interrupted);
	void Cosmetic_SurvivorsPerformingRitualUpdated();
	void Multicast_OnSeanceCompleted(class ASurvivor* originator);
	bool OnFinishedRitual();
	void OnRep_SurvivorsPerformingRitual();

	TArray<class ASurvivor*> GetRitualPerformers() const;
	bool IsSpotUsable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeanceRitualSpot">();
	}
	static class ASeanceRitualSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASeanceRitualSpot>();
	}
};
static_assert(alignof(ASeanceRitualSpot) == 0x000008, "Wrong alignment on ASeanceRitualSpot");
static_assert(sizeof(ASeanceRitualSpot) == 0x000458, "Wrong size on ASeanceRitualSpot");
static_assert(offsetof(ASeanceRitualSpot, _attachInteractionComponent) == 0x0003B8, "Member 'ASeanceRitualSpot::_attachInteractionComponent' has a wrong offset!");
static_assert(offsetof(ASeanceRitualSpot, _ritualChargeable) == 0x0003C0, "Member 'ASeanceRitualSpot::_ritualChargeable' has a wrong offset!");
static_assert(offsetof(ASeanceRitualSpot, _secondsToCharge) == 0x0003C8, "Member 'ASeanceRitualSpot::_secondsToCharge' has a wrong offset!");
static_assert(offsetof(ASeanceRitualSpot, _dechargeRate) == 0x0003CC, "Member 'ASeanceRitualSpot::_dechargeRate' has a wrong offset!");
static_assert(offsetof(ASeanceRitualSpot, _ritualOriginator) == 0x0003D0, "Member 'ASeanceRitualSpot::_ritualOriginator' has a wrong offset!");
static_assert(offsetof(ASeanceRitualSpot, _ritualPerformed) == 0x0003D8, "Member 'ASeanceRitualSpot::_ritualPerformed' has a wrong offset!");
static_assert(offsetof(ASeanceRitualSpot, _survivorsPerformingRitual) == 0x0003E0, "Member 'ASeanceRitualSpot::_survivorsPerformingRitual' has a wrong offset!");
static_assert(offsetof(ASeanceRitualSpot, _revealAuraEffectClass) == 0x0003F0, "Member 'ASeanceRitualSpot::_revealAuraEffectClass' has a wrong offset!");
static_assert(offsetof(ASeanceRitualSpot, _ritualInteractionDefinitionParentClass) == 0x0003F8, "Member 'ASeanceRitualSpot::_ritualInteractionDefinitionParentClass' has a wrong offset!");
static_assert(offsetof(ASeanceRitualSpot, _isSpotUsable) == 0x000400, "Member 'ASeanceRitualSpot::_isSpotUsable' has a wrong offset!");
static_assert(offsetof(ASeanceRitualSpot, _authority_progressAmountsCumulative) == 0x000408, "Member 'ASeanceRitualSpot::_authority_progressAmountsCumulative' has a wrong offset!");

// Class DeadByDaylight.SecurityCameraHUDComponent
// 0x0070 (0x0128 - 0x00B8)
class USecurityCameraHUDComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x70];                                      // 0x00B8(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SecurityCameraHUDComponent">();
	}
	static class USecurityCameraHUDComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USecurityCameraHUDComponent>();
	}
};
static_assert(alignof(USecurityCameraHUDComponent) == 0x000008, "Wrong alignment on USecurityCameraHUDComponent");
static_assert(sizeof(USecurityCameraHUDComponent) == 0x000128, "Wrong size on USecurityCameraHUDComponent");

// Class DeadByDaylight.shopmanager
// 0x0750 (0x0780 - 0x0030)
class Ushopmanager : public UObject
{
public:
	uint8                                         Pad_30[0x80];                                      // 0x0030(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UDBDGameInstance>        _gameInstance;                                     // 0x00B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x6C8];                                     // 0x00B8(0x06C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"shopmanager">();
	}
	static class Ushopmanager* GetDefaultObj()
	{
		return GetDefaultObjImpl<Ushopmanager>();
	}
};
static_assert(alignof(Ushopmanager) == 0x000008, "Wrong alignment on Ushopmanager");
static_assert(sizeof(Ushopmanager) == 0x000780, "Wrong size on Ushopmanager");
static_assert(offsetof(Ushopmanager, _gameInstance) == 0x0000B0, "Member 'Ushopmanager::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.ShopNewSeenItemSubsystem
// 0x0038 (0x0070 - 0x0038)
class UShopNewSeenItemSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x38];                                      // 0x0038(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShopNewSeenItemSubsystem">();
	}
	static class UShopNewSeenItemSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShopNewSeenItemSubsystem>();
	}
};
static_assert(alignof(UShopNewSeenItemSubsystem) == 0x000008, "Wrong alignment on UShopNewSeenItemSubsystem");
static_assert(sizeof(UShopNewSeenItemSubsystem) == 0x000070, "Wrong size on UShopNewSeenItemSubsystem");

// Class DeadByDaylight.SlashableInterface
// 0x0000 (0x0000 - 0x0000)
class ISlashableInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlashableInterface">();
	}
	static class ISlashableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISlashableInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ISlashableInterface) == 0x000001, "Wrong alignment on ISlashableInterface");
static_assert(sizeof(ISlashableInterface) == 0x000001, "Wrong size on ISlashableInterface");

// Class DeadByDaylight.SlasherOutlineUpdateStrategy
// 0x0080 (0x01E0 - 0x0160)
class USlasherOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	TMulticastInlineDelegate<void()>              OnRevealed;                                        // 0x0160(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FLinearColor                           _revealedColor;                                    // 0x0170(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _revealedColorForKiller;                           // 0x0180(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_190[0x50];                                     // 0x0190(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlasherOutlineUpdateStrategy">();
	}
	static class USlasherOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlasherOutlineUpdateStrategy>();
	}
};
static_assert(alignof(USlasherOutlineUpdateStrategy) == 0x000008, "Wrong alignment on USlasherOutlineUpdateStrategy");
static_assert(sizeof(USlasherOutlineUpdateStrategy) == 0x0001E0, "Wrong size on USlasherOutlineUpdateStrategy");
static_assert(offsetof(USlasherOutlineUpdateStrategy, OnRevealed) == 0x000160, "Member 'USlasherOutlineUpdateStrategy::OnRevealed' has a wrong offset!");
static_assert(offsetof(USlasherOutlineUpdateStrategy, _revealedColor) == 0x000170, "Member 'USlasherOutlineUpdateStrategy::_revealedColor' has a wrong offset!");
static_assert(offsetof(USlasherOutlineUpdateStrategy, _revealedColorForKiller) == 0x000180, "Member 'USlasherOutlineUpdateStrategy::_revealedColorForKiller' has a wrong offset!");

// Class DeadByDaylight.SlasherStateMachine
// 0x0000 (0x0140 - 0x0140)
class USlasherStateMachine final : public UPlayerStateMachine
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlasherStateMachine">();
	}
	static class USlasherStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlasherStateMachine>();
	}
};
static_assert(alignof(USlasherStateMachine) == 0x000010, "Wrong alignment on USlasherStateMachine");
static_assert(sizeof(USlasherStateMachine) == 0x000140, "Wrong size on USlasherStateMachine");

// Class DeadByDaylight.SpecialEventGameplaySpawnerComponent
// 0x0000 (0x00F0 - 0x00F0)
class USpecialEventGameplaySpawnerComponent final : public UGameplaySpawnerComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecialEventGameplaySpawnerComponent">();
	}
	static class USpecialEventGameplaySpawnerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpecialEventGameplaySpawnerComponent>();
	}
};
static_assert(alignof(USpecialEventGameplaySpawnerComponent) == 0x000008, "Wrong alignment on USpecialEventGameplaySpawnerComponent");
static_assert(sizeof(USpecialEventGameplaySpawnerComponent) == 0x0000F0, "Wrong size on USpecialEventGameplaySpawnerComponent");

// Class DeadByDaylight.specialeventmanager
// 0x0168 (0x0198 - 0x0030)
class Uspecialeventmanager final : public UObject
{
public:
	uint8                                         Pad_30[0x30];                                      // 0x0030(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class USpecialEventsContainer*                _eventsContainer;                                  // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpecialEventCustomizationsComponent*   _customizationsComponent;                          // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x128];                                     // 0x0070(0x0128)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"specialeventmanager">();
	}
	static class Uspecialeventmanager* GetDefaultObj()
	{
		return GetDefaultObjImpl<Uspecialeventmanager>();
	}
};
static_assert(alignof(Uspecialeventmanager) == 0x000008, "Wrong alignment on Uspecialeventmanager");
static_assert(sizeof(Uspecialeventmanager) == 0x000198, "Wrong size on Uspecialeventmanager");
static_assert(offsetof(Uspecialeventmanager, _eventsContainer) == 0x000060, "Member 'Uspecialeventmanager::_eventsContainer' has a wrong offset!");
static_assert(offsetof(Uspecialeventmanager, _customizationsComponent) == 0x000068, "Member 'Uspecialeventmanager::_customizationsComponent' has a wrong offset!");

// Class DeadByDaylight.StalkerComponent
// 0x0078 (0x0130 - 0x00B8)
class UStalkerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x28];                                      // 0x00B8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _distributeStalkRate;                              // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _canStalkWhileInChase;                             // 0x00E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E2[0x6];                                       // 0x00E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UStalkedComponent*>              _playerStalkedComponents;                          // 0x00E8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x10];                                      // 0x00F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargeableComponent*                   _stalkPointsChargeable;                            // 0x0108(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x20];                                     // 0x0110(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayerBeingStalkedChanged(bool isBeingStalked);

	bool CanStalk() const;
	float GetMaxStalkingPoints() const;
	float GetPercentStalkingPoints() const;
	float GetScoreMultiplier() const;
	float GetTotalStalkingPoints() const;
	bool HasMaxStalkPoints() const;
	bool IsStalkingSomeone() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StalkerComponent">();
	}
	static class UStalkerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStalkerComponent>();
	}
};
static_assert(alignof(UStalkerComponent) == 0x000008, "Wrong alignment on UStalkerComponent");
static_assert(sizeof(UStalkerComponent) == 0x000130, "Wrong size on UStalkerComponent");
static_assert(offsetof(UStalkerComponent, _distributeStalkRate) == 0x0000E0, "Member 'UStalkerComponent::_distributeStalkRate' has a wrong offset!");
static_assert(offsetof(UStalkerComponent, _canStalkWhileInChase) == 0x0000E1, "Member 'UStalkerComponent::_canStalkWhileInChase' has a wrong offset!");
static_assert(offsetof(UStalkerComponent, _playerStalkedComponents) == 0x0000E8, "Member 'UStalkerComponent::_playerStalkedComponents' has a wrong offset!");
static_assert(offsetof(UStalkerComponent, _stalkPointsChargeable) == 0x000108, "Member 'UStalkerComponent::_stalkPointsChargeable' has a wrong offset!");

// Class DeadByDaylight.DBDLogo
// 0x0000 (0x02A0 - 0x02A0)
class ADBDLogo : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDLogo">();
	}
	static class ADBDLogo* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDLogo>();
	}
};
static_assert(alignof(ADBDLogo) == 0x000008, "Wrong alignment on ADBDLogo");
static_assert(sizeof(ADBDLogo) == 0x0002A0, "Wrong size on ADBDLogo");

// Class DeadByDaylight.StartScreenBase
// 0x0000 (0x02A8 - 0x02A8)
class AStartScreenBase : public ALevelScriptActor
{
public:
	void BeginDestroyTravelSequence();
	void TravelToMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StartScreenBase">();
	}
	static class AStartScreenBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStartScreenBase>();
	}
};
static_assert(alignof(AStartScreenBase) == 0x000008, "Wrong alignment on AStartScreenBase");
static_assert(sizeof(AStartScreenBase) == 0x0002A8, "Wrong size on AStartScreenBase");

// Class DeadByDaylight.StateTagUtilities
// 0x0000 (0x0030 - 0x0030)
class UStateTagUtilities final : public UBlueprintFunctionLibrary
{
public:
	static void AddStateTag(const TScriptInterface<class IObjectStateProvider> ObjectStateProvider, const struct FGameplayTag& Tag);
	static void AddStateTagToPlayer(const class ADBDPlayer* Player, const struct FGameplayTag& Tag);
	static void AddTagWithSource(const TScriptInterface<class IObjectStateProvider> ObjectStateProvider, const struct FGameplayTag& Tag, const class UObject* Source);
	static bool CurrentInteractionHasAnyStateTag(const class ADBDPlayer* Player, const struct FGameplayTagContainer& Tags);
	static bool CurrentInteractionHasStateTag(const class ADBDPlayer* Player, const struct FGameplayTag& Tag);
	static bool HasAnyStateTags(const TScriptInterface<class IObjectStateProvider> ObjectStateProvider, const struct FGameplayTagContainer& Tags);
	static bool HasStateTag(const TScriptInterface<class IObjectStateProvider> ObjectStateProvider, const struct FGameplayTag& Tag);
	static bool InteractionHasStateTag(const class UInteractionDefinition* Interaction, const struct FGameplayTag& Tag);
	static void RemoveStateTag(const TScriptInterface<class IObjectStateProvider> ObjectStateProvider, const struct FGameplayTag& Tag);
	static void RemoveStateTagToPlayer(const class ADBDPlayer* Player, const struct FGameplayTag& Tag);
	static void RemoveTagWithSource(const TScriptInterface<class IObjectStateProvider> ObjectStateProvider, const struct FGameplayTag& Tag, const class UObject* Source);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateTagUtilities">();
	}
	static class UStateTagUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateTagUtilities>();
	}
};
static_assert(alignof(UStateTagUtilities) == 0x000008, "Wrong alignment on UStateTagUtilities");
static_assert(sizeof(UStateTagUtilities) == 0x000030, "Wrong size on UStateTagUtilities");

// Class DeadByDaylight.StoreDisplayStandController
// 0x0020 (0x01E0 - 0x01C0)
class UStoreDisplayStandController final : public UDisplayStandController
{
public:
	uint8                                         Pad_1C0[0x20];                                     // 0x01C0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreDisplayStandController">();
	}
	static class UStoreDisplayStandController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreDisplayStandController>();
	}
};
static_assert(alignof(UStoreDisplayStandController) == 0x000008, "Wrong alignment on UStoreDisplayStandController");
static_assert(sizeof(UStoreDisplayStandController) == 0x0001E0, "Wrong size on UStoreDisplayStandController");

// Class DeadByDaylight.StorefrontConfiguration
// 0x0050 (0x0088 - 0x0038)
class UStorefrontConfiguration final : public UDataAsset
{
public:
	TMap<EStorefrontState, struct FStorefrontStateData> States;                                      // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StorefrontConfiguration">();
	}
	static class UStorefrontConfiguration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStorefrontConfiguration>();
	}
};
static_assert(alignof(UStorefrontConfiguration) == 0x000008, "Wrong alignment on UStorefrontConfiguration");
static_assert(sizeof(UStorefrontConfiguration) == 0x000088, "Wrong size on UStorefrontConfiguration");
static_assert(offsetof(UStorefrontConfiguration, States) == 0x000038, "Member 'UStorefrontConfiguration::States' has a wrong offset!");

// Class DeadByDaylight.StorePurchasingPopupHandler
// 0x0008 (0x0040 - 0x0038)
class UStorePurchasingPopupHandler final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StorePurchasingPopupHandler">();
	}
	static class UStorePurchasingPopupHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStorePurchasingPopupHandler>();
	}
};
static_assert(alignof(UStorePurchasingPopupHandler) == 0x000008, "Wrong alignment on UStorePurchasingPopupHandler");
static_assert(sizeof(UStorePurchasingPopupHandler) == 0x000040, "Wrong size on UStorePurchasingPopupHandler");

// Class DeadByDaylight.StoreRecommendationSubsystem
// 0x0080 (0x00B8 - 0x0038)
class UStoreRecommendationSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x78];                                      // 0x0038(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class URemoteContentCacheSubsystem*           _remoteContentCacheSubsystem;                      // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreRecommendationSubsystem">();
	}
	static class UStoreRecommendationSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreRecommendationSubsystem>();
	}
};
static_assert(alignof(UStoreRecommendationSubsystem) == 0x000008, "Wrong alignment on UStoreRecommendationSubsystem");
static_assert(sizeof(UStoreRecommendationSubsystem) == 0x0000B8, "Wrong size on UStoreRecommendationSubsystem");
static_assert(offsetof(UStoreRecommendationSubsystem, _remoteContentCacheSubsystem) == 0x0000B0, "Member 'UStoreRecommendationSubsystem::_remoteContentCacheSubsystem' has a wrong offset!");

// Class DeadByDaylight.SubtitlesManager
// 0x00C0 (0x00F8 - 0x0038)
class USubtitlesManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x24];                                      // 0x0038(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UAkGameObject>           _currentSubtitleEventTarget;                       // 0x005C(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_64[0x94];                                      // 0x0064(0x0094)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class FString GetAudioEventNameFromLocalizedTextId(const class FString& TextId);
	static class FString GetForcedAudioOrDialogLine();
	static bool HasAnimNotifyPlayedForThisMatch(const class FString& AnimNotify);
	static bool IsDebuggingSubtitles();
	static int32 Post2DAkEventWithSubtitles(const TArray<struct FAkEventWithSubtitle>& akEventRandomizer, class UAkAudioEvent** akEventPlayed);
	static int32 PostAkEventWithSubtitles(class UAkGameObject* Target, const TArray<struct FAkEventWithSubtitle>& akEventRandomizer, float maxSubtitleDistance, int32 callbackMask, const TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)>& postEventCallback, class UAkAudioEvent** akEventPlayed);
	static void RecordAnimNotifyPlayedForThisMatch(const class FString& AnimNotify);

	void On3DEventCallback(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubtitlesManager">();
	}
	static class USubtitlesManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubtitlesManager>();
	}
};
static_assert(alignof(USubtitlesManager) == 0x000008, "Wrong alignment on USubtitlesManager");
static_assert(sizeof(USubtitlesManager) == 0x0000F8, "Wrong size on USubtitlesManager");
static_assert(offsetof(USubtitlesManager, _currentSubtitleEventTarget) == 0x00005C, "Member 'USubtitlesManager::_currentSubtitleEventTarget' has a wrong offset!");

// Class DeadByDaylight.SurviveTimerScoreEventComponent
// 0x0028 (0x00E0 - 0x00B8)
class USurviveTimerScoreEventComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x28];                                      // 0x00B8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnGameStarted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurviveTimerScoreEventComponent">();
	}
	static class USurviveTimerScoreEventComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurviveTimerScoreEventComponent>();
	}
};
static_assert(alignof(USurviveTimerScoreEventComponent) == 0x000008, "Wrong alignment on USurviveTimerScoreEventComponent");
static_assert(sizeof(USurviveTimerScoreEventComponent) == 0x0000E0, "Wrong size on USurviveTimerScoreEventComponent");

// Class DeadByDaylight.SurvivorAudioHandlerComponent
// 0x01E0 (0x0338 - 0x0158)
class USurvivorAudioHandlerComponent final : public UDBDPlayerAudioHandlerComponent
{
public:
	uint8                                         Pad_158[0x1E0];                                    // 0x0158(0x01E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorAudioHandlerComponent">();
	}
	static class USurvivorAudioHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorAudioHandlerComponent>();
	}
};
static_assert(alignof(USurvivorAudioHandlerComponent) == 0x000008, "Wrong alignment on USurvivorAudioHandlerComponent");
static_assert(sizeof(USurvivorAudioHandlerComponent) == 0x000338, "Wrong size on USurvivorAudioHandlerComponent");

// Class DeadByDaylight.SurvivorBloodTrailComponent
// 0x0030 (0x02B0 - 0x0280)
class USurvivorBloodTrailComponent final : public UBloodTrailComponent
{
public:
	class UPerkManager*                           _survivorPerkManager;                              // 0x0280(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_288[0x28];                                     // 0x0288(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDamageStateChanged(EHealthState oldDamageState, EHealthState currentDamageState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorBloodTrailComponent">();
	}
	static class USurvivorBloodTrailComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorBloodTrailComponent>();
	}
};
static_assert(alignof(USurvivorBloodTrailComponent) == 0x000010, "Wrong alignment on USurvivorBloodTrailComponent");
static_assert(sizeof(USurvivorBloodTrailComponent) == 0x0002B0, "Wrong size on USurvivorBloodTrailComponent");
static_assert(offsetof(USurvivorBloodTrailComponent, _survivorPerkManager) == 0x000280, "Member 'USurvivorBloodTrailComponent::_survivorPerkManager' has a wrong offset!");

// Class DeadByDaylight.SurvivorCameraLagStrategy
// 0x0070 (0x0128 - 0x00B8)
class USurvivorCameraLagStrategy final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x70];                                      // 0x00B8(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorCameraLagStrategy">();
	}
	static class USurvivorCameraLagStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorCameraLagStrategy>();
	}
};
static_assert(alignof(USurvivorCameraLagStrategy) == 0x000008, "Wrong alignment on USurvivorCameraLagStrategy");
static_assert(sizeof(USurvivorCameraLagStrategy) == 0x000128, "Wrong size on USurvivorCameraLagStrategy");

// Class DeadByDaylight.SurvivorExposerInstance
// 0x0030 (0x02D0 - 0x02A0)
class ASurvivorExposerInstance : public AActor
{
public:
	EExposerInstanceAreaLocation                  _areaLocation;                                     // 0x02A0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _audioAggravationLevelRtpc;                        // 0x02A8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x14];                                     // 0x02B8(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _aggravationLevel;                                 // 0x02CC(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ExitSequenceComplete();
	void OnRep_AggravationLevel();
	void OnRep_OnAreaLocationChanged(EExposerInstanceAreaLocation OldValue);
	void SetIsInteriorBP(bool interior);
	void StartExitSequence(bool withRandomDelay);
	void StartSpawnSequence(bool withRandomDelay);

	EExposerInstanceAreaLocation GetAreaLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorExposerInstance">();
	}
	static class ASurvivorExposerInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASurvivorExposerInstance>();
	}
};
static_assert(alignof(ASurvivorExposerInstance) == 0x000008, "Wrong alignment on ASurvivorExposerInstance");
static_assert(sizeof(ASurvivorExposerInstance) == 0x0002D0, "Wrong size on ASurvivorExposerInstance");
static_assert(offsetof(ASurvivorExposerInstance, _areaLocation) == 0x0002A0, "Member 'ASurvivorExposerInstance::_areaLocation' has a wrong offset!");
static_assert(offsetof(ASurvivorExposerInstance, _audioAggravationLevelRtpc) == 0x0002A8, "Member 'ASurvivorExposerInstance::_audioAggravationLevelRtpc' has a wrong offset!");
static_assert(offsetof(ASurvivorExposerInstance, _aggravationLevel) == 0x0002CC, "Member 'ASurvivorExposerInstance::_aggravationLevel' has a wrong offset!");

// Class DeadByDaylight.SurvivorSlashableComponent
// 0x00F0 (0x01A8 - 0x00B8)
class USurvivorSlashableComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      _slashableZone;                                    // 0x00C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      _hookSlashableZone;                                // 0x00C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _standingCapsuleHalfHeight;                        // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _crouchCapsuleHalfHeight;                          // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  _slashableDisablingStateTags;                      // 0x00D8(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         _sourceActivationLingerDuration;                   // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FC[0x34];                                      // 0x00FC(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	class USlashableActivationSourceCollection*   _slashableActivationSources;                       // 0x0130(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_138[0x70];                                     // 0x0138(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCrouchCapsuleHalfHeight(float Height);
	void SetHookSlashableZone(class UCapsuleComponent* zone);
	void SetSlashableZone(class UCapsuleComponent* zone);
	void SetStandingCapsuleHalfHeight(float Height);
	void SetUseCrouchSlashableCapsule(bool useCrouchCapsule);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorSlashableComponent">();
	}
	static class USurvivorSlashableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorSlashableComponent>();
	}
};
static_assert(alignof(USurvivorSlashableComponent) == 0x000008, "Wrong alignment on USurvivorSlashableComponent");
static_assert(sizeof(USurvivorSlashableComponent) == 0x0001A8, "Wrong size on USurvivorSlashableComponent");
static_assert(offsetof(USurvivorSlashableComponent, _slashableZone) == 0x0000C0, "Member 'USurvivorSlashableComponent::_slashableZone' has a wrong offset!");
static_assert(offsetof(USurvivorSlashableComponent, _hookSlashableZone) == 0x0000C8, "Member 'USurvivorSlashableComponent::_hookSlashableZone' has a wrong offset!");
static_assert(offsetof(USurvivorSlashableComponent, _standingCapsuleHalfHeight) == 0x0000D0, "Member 'USurvivorSlashableComponent::_standingCapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(USurvivorSlashableComponent, _crouchCapsuleHalfHeight) == 0x0000D4, "Member 'USurvivorSlashableComponent::_crouchCapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(USurvivorSlashableComponent, _slashableDisablingStateTags) == 0x0000D8, "Member 'USurvivorSlashableComponent::_slashableDisablingStateTags' has a wrong offset!");
static_assert(offsetof(USurvivorSlashableComponent, _sourceActivationLingerDuration) == 0x0000F8, "Member 'USurvivorSlashableComponent::_sourceActivationLingerDuration' has a wrong offset!");
static_assert(offsetof(USurvivorSlashableComponent, _slashableActivationSources) == 0x000130, "Member 'USurvivorSlashableComponent::_slashableActivationSources' has a wrong offset!");

// Class DeadByDaylight.SurvivorSpecialEventStatusIndicatorComponent
// 0x0058 (0x0110 - 0x00B8)
class USurvivorSpecialEventStatusIndicatorComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ULocalPlayerTrackerComponent*           _localPlayerTracker;                               // 0x00D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _specialEventStatusStateTag;                       // 0x00D8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E4[0x2C];                                      // 0x00E4(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnStatusIndicatorShown();
	void OnStatusChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorSpecialEventStatusIndicatorComponent">();
	}
	static class USurvivorSpecialEventStatusIndicatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorSpecialEventStatusIndicatorComponent>();
	}
};
static_assert(alignof(USurvivorSpecialEventStatusIndicatorComponent) == 0x000008, "Wrong alignment on USurvivorSpecialEventStatusIndicatorComponent");
static_assert(sizeof(USurvivorSpecialEventStatusIndicatorComponent) == 0x000110, "Wrong size on USurvivorSpecialEventStatusIndicatorComponent");
static_assert(offsetof(USurvivorSpecialEventStatusIndicatorComponent, _localPlayerTracker) == 0x0000D0, "Member 'USurvivorSpecialEventStatusIndicatorComponent::_localPlayerTracker' has a wrong offset!");
static_assert(offsetof(USurvivorSpecialEventStatusIndicatorComponent, _specialEventStatusStateTag) == 0x0000D8, "Member 'USurvivorSpecialEventStatusIndicatorComponent::_specialEventStatusStateTag' has a wrong offset!");

// Class DeadByDaylight.SurvivorStatusInterface
// 0x0000 (0x0000 - 0x0000)
class ISurvivorStatusInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorStatusInterface">();
	}
	static class ISurvivorStatusInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISurvivorStatusInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ISurvivorStatusInterface) == 0x000001, "Wrong alignment on ISurvivorStatusInterface");
static_assert(sizeof(ISurvivorStatusInterface) == 0x000001, "Wrong size on ISurvivorStatusInterface");

// Class DeadByDaylight.SwitchProfileDAL
// 0x0000 (0x0088 - 0x0088)
class USwitchProfileDAL final : public UPlayerProfileDAL
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwitchProfileDAL">();
	}
	static class USwitchProfileDAL* GetDefaultObj()
	{
		return GetDefaultObjImpl<USwitchProfileDAL>();
	}
};
static_assert(alignof(USwitchProfileDAL) == 0x000008, "Wrong alignment on USwitchProfileDAL");
static_assert(sizeof(USwitchProfileDAL) == 0x000088, "Wrong size on USwitchProfileDAL");

// Class DeadByDaylight.TallyScreen
// 0x0068 (0x0190 - 0x0128)
class UTallyScreen final : public UScreenBase
{
public:
	uint8                                         Pad_128[0x68];                                     // 0x0128(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLeaveButtonClick();
	void OnLevelingSequenceComplete();
	void OnSpectateButtonClick();
	void OnUpdateUMGTallyScoreboardVisibility(bool IsVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TallyScreen">();
	}
	static class UTallyScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTallyScreen>();
	}
};
static_assert(alignof(UTallyScreen) == 0x000008, "Wrong alignment on UTallyScreen");
static_assert(sizeof(UTallyScreen) == 0x000190, "Wrong size on UTallyScreen");

// Class DeadByDaylight.TickInEditorSkeletalMesh
// 0x0000 (0x0320 - 0x0320)
class ATickInEditorSkeletalMesh final : public ASkeletalMeshActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TickInEditorSkeletalMesh">();
	}
	static class ATickInEditorSkeletalMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATickInEditorSkeletalMesh>();
	}
};
static_assert(alignof(ATickInEditorSkeletalMesh) == 0x000008, "Wrong alignment on ATickInEditorSkeletalMesh");
static_assert(sizeof(ATickInEditorSkeletalMesh) == 0x000320, "Wrong size on ATickInEditorSkeletalMesh");

// Class DeadByDaylight.TileSpawnPointSelector
// 0x0020 (0x02F0 - 0x02D0)
class UTileSpawnPointSelector final : public USceneComponent
{
public:
	TArray<struct FSelectableTileSpawnPoint>      _tileSpawnPoints;                                  // 0x02D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E0[0x10];                                     // 0x02E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TileSpawnPointSelector">();
	}
	static class UTileSpawnPointSelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTileSpawnPointSelector>();
	}
};
static_assert(alignof(UTileSpawnPointSelector) == 0x000010, "Wrong alignment on UTileSpawnPointSelector");
static_assert(sizeof(UTileSpawnPointSelector) == 0x0002F0, "Wrong size on UTileSpawnPointSelector");
static_assert(offsetof(UTileSpawnPointSelector, _tileSpawnPoints) == 0x0002D0, "Member 'UTileSpawnPointSelector::_tileSpawnPoints' has a wrong offset!");

// Class DeadByDaylight.TimedEffectWidgetInterface
// 0x0000 (0x0000 - 0x0000)
class ITimedEffectWidgetInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimedEffectWidgetInterface">();
	}
	static class ITimedEffectWidgetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITimedEffectWidgetInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITimedEffectWidgetInterface) == 0x000001, "Wrong alignment on ITimedEffectWidgetInterface");
static_assert(sizeof(ITimedEffectWidgetInterface) == 0x000001, "Wrong size on ITimedEffectWidgetInterface");

// Class DeadByDaylight.TimerGate
// 0x0010 (0x02C8 - 0x02B8)
class ATimerGate final : public AGate
{
public:
	float                                         _currentTime;                                      // 0x02B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC[0xC];                                      // 0x02BC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddTime(float Time);
	void RemoveTime(float Time);
	void Reset();
	void Rushed(bool Success);
	void SetValues(float TimerDuration, float RushGain, float RushBlockDuration);
	void Update(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimerGate">();
	}
	static class ATimerGate* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATimerGate>();
	}
};
static_assert(alignof(ATimerGate) == 0x000008, "Wrong alignment on ATimerGate");
static_assert(sizeof(ATimerGate) == 0x0002C8, "Wrong size on ATimerGate");
static_assert(offsetof(ATimerGate, _currentTime) == 0x0002B8, "Member 'ATimerGate::_currentTime' has a wrong offset!");

// Class DeadByDaylight.TokenProvider
// 0x0000 (0x0000 - 0x0000)
class ITokenProvider final
{
public:
	class UTokenCounter* GetTokenProvider() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TokenProvider">();
	}
	static class ITokenProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITokenProvider>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITokenProvider) == 0x000001, "Wrong alignment on ITokenProvider");
static_assert(sizeof(ITokenProvider) == 0x000001, "Wrong size on ITokenProvider");

// Class DeadByDaylight.ToolBoxInterface
// 0x0000 (0x0000 - 0x0000)
class IToolBoxInterface final
{
public:
	class UChargerComponent* GetChargerComponent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ToolBoxInterface">();
	}
	static class IToolBoxInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IToolBoxInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IToolBoxInterface) == 0x000001, "Wrong alignment on IToolBoxInterface");
static_assert(sizeof(IToolBoxInterface) == 0x000001, "Wrong size on IToolBoxInterface");

// Class DeadByDaylight.Totem
// 0x0140 (0x04E8 - 0x03A8)
class ATotem final : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnTotemBound;                                      // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C0[0x18];                                     // 0x03C0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           _boonAuraRevealColor;                              // 0x03D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTotemBoundPerk*>                _boundPerks;                                       // 0x03E8(0x0010)(ExportObject, Net, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	ETotemState                                   _totemState;                                       // 0x03F8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F9[0x7];                                      // 0x03F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _baseBoonTotemBlessingRange;                       // 0x0400(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _baseBoonTotemAuraRevealRange;                     // 0x0428(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_450[0x18];                                     // 0x0450(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIPerceptionStimuliSourceComponent*    _perceptionStimuliComponent;                       // 0x0468(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlockableComponent*                    _totemBlockableComponent;                          // 0x0470(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_478[0x10];                                     // 0x0478(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ULocalPlayerTrackerComponent*           _localPlayerTracker;                               // 0x0488(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UActivatorComponent*                    _activatorComponent;                               // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameplayTagContainerComponent*         _objectState;                                      // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        _interactionsAttachPoint;                          // 0x04A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTotemOutlineUpdateStrategy*            _totemOutlineUpdateStrategy;                       // 0x04A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B0[0x30];                                     // 0x04B0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _canBeBoundToBoonPerk;                             // 0x04E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4E1[0x7];                                      // 0x04E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_BindToPerk(class UTotemBoundPerk* Perk);
	void Authority_Cleanse();
	void Authority_UnbindFromAllPerks();
	void Authority_UnbindFromPerk(class UTotemBoundPerk* Perk);
	void OnBlockTotemCosmetic(class ADBDPlayer* Player);
	void OnCleanseTotem(class ATotem* Totem, const ETotemState oldTotemState);
	void OnLocallyObservedChanged();
	void OnRep_TotemState(const ETotemState oldTotemState);
	void OnTotemBlockChanged();
	void OnTotemStateChanged(const ETotemState oldTotemState, const ETotemState newTotemState);
	void OnUnblockTotemCosmetic(class ADBDPlayer* Player);

	class UAkComponent* GetAkAudioComponent() const;
	class UChargeableInteractionDefinition* GetBlessTotemInteraction() const;
	struct FLinearColor GetBoonAuraRevealColor() const;
	float GetBoonTotemAuraRevealRange() const;
	float GetBoonTotemBlessingRange() const;
	class UChargeableInteractionDefinition* GetCleanseTotemInteraction() const;
	class UInteractor* GetMainInteractor() const;
	ETotemState GetTotemState() const;
	bool IsBoundToPerk() const;
	bool IsTotemBlockedForPlayer(const class ADBDPlayer* Player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Totem">();
	}
	static class ATotem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATotem>();
	}
};
static_assert(alignof(ATotem) == 0x000008, "Wrong alignment on ATotem");
static_assert(sizeof(ATotem) == 0x0004E8, "Wrong size on ATotem");
static_assert(offsetof(ATotem, OnTotemBound) == 0x0003B0, "Member 'ATotem::OnTotemBound' has a wrong offset!");
static_assert(offsetof(ATotem, _boonAuraRevealColor) == 0x0003D8, "Member 'ATotem::_boonAuraRevealColor' has a wrong offset!");
static_assert(offsetof(ATotem, _boundPerks) == 0x0003E8, "Member 'ATotem::_boundPerks' has a wrong offset!");
static_assert(offsetof(ATotem, _totemState) == 0x0003F8, "Member 'ATotem::_totemState' has a wrong offset!");
static_assert(offsetof(ATotem, _baseBoonTotemBlessingRange) == 0x000400, "Member 'ATotem::_baseBoonTotemBlessingRange' has a wrong offset!");
static_assert(offsetof(ATotem, _baseBoonTotemAuraRevealRange) == 0x000428, "Member 'ATotem::_baseBoonTotemAuraRevealRange' has a wrong offset!");
static_assert(offsetof(ATotem, _perceptionStimuliComponent) == 0x000468, "Member 'ATotem::_perceptionStimuliComponent' has a wrong offset!");
static_assert(offsetof(ATotem, _totemBlockableComponent) == 0x000470, "Member 'ATotem::_totemBlockableComponent' has a wrong offset!");
static_assert(offsetof(ATotem, _localPlayerTracker) == 0x000488, "Member 'ATotem::_localPlayerTracker' has a wrong offset!");
static_assert(offsetof(ATotem, _activatorComponent) == 0x000490, "Member 'ATotem::_activatorComponent' has a wrong offset!");
static_assert(offsetof(ATotem, _objectState) == 0x000498, "Member 'ATotem::_objectState' has a wrong offset!");
static_assert(offsetof(ATotem, _interactionsAttachPoint) == 0x0004A0, "Member 'ATotem::_interactionsAttachPoint' has a wrong offset!");
static_assert(offsetof(ATotem, _totemOutlineUpdateStrategy) == 0x0004A8, "Member 'ATotem::_totemOutlineUpdateStrategy' has a wrong offset!");
static_assert(offsetof(ATotem, _canBeBoundToBoonPerk) == 0x0004E0, "Member 'ATotem::_canBeBoundToBoonPerk' has a wrong offset!");

// Class DeadByDaylight.TotemActiveIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UTotemActiveIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TotemActiveIconStrategy">();
	}
	static class UTotemActiveIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTotemActiveIconStrategy>();
	}
};
static_assert(alignof(UTotemActiveIconStrategy) == 0x000008, "Wrong alignment on UTotemActiveIconStrategy");
static_assert(sizeof(UTotemActiveIconStrategy) == 0x000038, "Wrong size on UTotemActiveIconStrategy");

// Class DeadByDaylight.TrapInstallerComponent
// 0x0010 (0x00C8 - 0x00B8)
class UTrapInstallerComponent final : public UActorComponent
{
public:
	TArray<class USurvivorTrapPerk*>              _ownedTrapPerks;                                   // 0x00B8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrapInstallerComponent">();
	}
	static class UTrapInstallerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTrapInstallerComponent>();
	}
};
static_assert(alignof(UTrapInstallerComponent) == 0x000008, "Wrong alignment on UTrapInstallerComponent");
static_assert(sizeof(UTrapInstallerComponent) == 0x0000C8, "Wrong size on UTrapInstallerComponent");
static_assert(offsetof(UTrapInstallerComponent, _ownedTrapPerks) == 0x0000B8, "Member 'UTrapInstallerComponent::_ownedTrapPerks' has a wrong offset!");

// Class DeadByDaylight.TriggerableActivatorComponent
// 0x0048 (0x0100 - 0x00B8)
class UTriggerableActivatorComponent final : public UActorComponent
{
public:
	TSoftClassPtr<class UClass>                   _triggerableClass;                                 // 0x00B8(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UTriggerableWorldObjectComponent*> _triggerables;                                   // 0x00F0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void Authority_OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TriggerableActivatorComponent">();
	}
	static class UTriggerableActivatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTriggerableActivatorComponent>();
	}
};
static_assert(alignof(UTriggerableActivatorComponent) == 0x000008, "Wrong alignment on UTriggerableActivatorComponent");
static_assert(sizeof(UTriggerableActivatorComponent) == 0x000100, "Wrong size on UTriggerableActivatorComponent");
static_assert(offsetof(UTriggerableActivatorComponent, _triggerableClass) == 0x0000B8, "Member 'UTriggerableActivatorComponent::_triggerableClass' has a wrong offset!");
static_assert(offsetof(UTriggerableActivatorComponent, _triggerables) == 0x0000F0, "Member 'UTriggerableActivatorComponent::_triggerables' has a wrong offset!");

// Class DeadByDaylight.TunableStatFloatValueStrategy
// 0x0080 (0x0110 - 0x0090)
class UTunableStatFloatValueStrategy final : public UFloatValueStrategy
{
public:
	struct FTunableStat                           _value;                                            // 0x0090(0x0080)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TunableStatFloatValueStrategy">();
	}
	static class UTunableStatFloatValueStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTunableStatFloatValueStrategy>();
	}
};
static_assert(alignof(UTunableStatFloatValueStrategy) == 0x000008, "Wrong alignment on UTunableStatFloatValueStrategy");
static_assert(sizeof(UTunableStatFloatValueStrategy) == 0x000110, "Wrong size on UTunableStatFloatValueStrategy");
static_assert(offsetof(UTunableStatFloatValueStrategy, _value) == 0x000090, "Member 'UTunableStatFloatValueStrategy::_value' has a wrong offset!");

// Class DeadByDaylight.TutorialAssetLibrary
// 0x0010 (0x00C0 - 0x00B0)
class UTutorialAssetLibrary final : public UAssetLibrary
{
public:
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialAssetLibrary">();
	}
	static class UTutorialAssetLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialAssetLibrary>();
	}
};
static_assert(alignof(UTutorialAssetLibrary) == 0x000008, "Wrong alignment on UTutorialAssetLibrary");
static_assert(sizeof(UTutorialAssetLibrary) == 0x0000C0, "Wrong size on UTutorialAssetLibrary");

// Class DeadByDaylight.TutorialGameState
// 0x00A0 (0x0B30 - 0x0A90)
class ATutorialGameState final : public ADBDGameState
{
public:
	TMulticastInlineDelegate<void(ETutorialStep step)> OnCurrentTutorialStepChanged;                 // 0x0A90(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA0[0x38];                                     // 0x0AA0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _forceHatchVisible;                                // 0x0AD8(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AD9[0x57];                                     // 0x0AD9(0x0057)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCurrentTutorialStep(ETutorialStep step);
	void SetForcedHatchVisibility(bool IsHatchVisible_0);
	void TutorialEndReached();

	void CompleteLocallyControlledCharacterIntros() const;
	ETutorialStep GetCurrentTutorialStep() const;
	bool IsTutorialStarted() const;
	void SetEscapeRequirementsVisibility(bool IsVisible) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialGameState">();
	}
	static class ATutorialGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATutorialGameState>();
	}
};
static_assert(alignof(ATutorialGameState) == 0x000008, "Wrong alignment on ATutorialGameState");
static_assert(sizeof(ATutorialGameState) == 0x000B30, "Wrong size on ATutorialGameState");
static_assert(offsetof(ATutorialGameState, OnCurrentTutorialStepChanged) == 0x000A90, "Member 'ATutorialGameState::OnCurrentTutorialStepChanged' has a wrong offset!");
static_assert(offsetof(ATutorialGameState, _forceHatchVisible) == 0x000AD8, "Member 'ATutorialGameState::_forceHatchVisible' has a wrong offset!");

// Class DeadByDaylight.TutorialHighlightController
// 0x0018 (0x0048 - 0x0030)
class UTutorialHighlightController final : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHudComponentHighlight(EHudComponent hudComponent, bool Show);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialHighlightController">();
	}
	static class UTutorialHighlightController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialHighlightController>();
	}
};
static_assert(alignof(UTutorialHighlightController) == 0x000008, "Wrong alignment on UTutorialHighlightController");
static_assert(sizeof(UTutorialHighlightController) == 0x000048, "Wrong size on UTutorialHighlightController");

// Class DeadByDaylight.TutorialNotificationController
// 0x0080 (0x00B0 - 0x0030)
class UTutorialNotificationController final : public UObject
{
public:
	TMulticastInlineDelegate<void(class FName tutorialNotificationId)> OnBlockingNotificationDismissedEvent; // 0x0030(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x70];                                      // 0x0040(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HideNotification(bool removeAllCachedNotifs);
	void OnBlockingNotificationDismissed();
	void ShowBlockingNotification(class FName tutorialNotificationId);
	void ShowNotification(class FName tutorialNotificationId, float Duration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialNotificationController">();
	}
	static class UTutorialNotificationController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialNotificationController>();
	}
};
static_assert(alignof(UTutorialNotificationController) == 0x000008, "Wrong alignment on UTutorialNotificationController");
static_assert(sizeof(UTutorialNotificationController) == 0x0000B0, "Wrong size on UTutorialNotificationController");
static_assert(offsetof(UTutorialNotificationController, OnBlockingNotificationDismissedEvent) == 0x000030, "Member 'UTutorialNotificationController::OnBlockingNotificationDismissedEvent' has a wrong offset!");

// Class DeadByDaylight.TutorialObjectiveController
// 0x00B0 (0x00E0 - 0x0030)
class UTutorialObjectiveController final : public UObject
{
public:
	uint8                                         Pad_30[0xB0];                                      // 0x0030(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddObjective(class FName tutorialObjectiveId);
	void CompleteObjective(class FName tutorialObjectiveId, bool removeAfterCompletion);
	void RemoveAllObjectives();
	void RemoveObjective(class FName tutorialObjectiveId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialObjectiveController">();
	}
	static class UTutorialObjectiveController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialObjectiveController>();
	}
};
static_assert(alignof(UTutorialObjectiveController) == 0x000008, "Wrong alignment on UTutorialObjectiveController");
static_assert(sizeof(UTutorialObjectiveController) == 0x0000E0, "Wrong size on UTutorialObjectiveController");

// Class DeadByDaylight.UIController
// 0x0028 (0x0058 - 0x0030)
class UUIController final : public UObject
{
public:
	class UGFxObject*                             m_UIControllerObj;                                 // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DrawBlockingArea(const class FString& ID, const struct FGeometry& Geometry);
	void RemoveBlockingArea(const class FString& ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIController">();
	}
	static class UUIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIController>();
	}
};
static_assert(alignof(UUIController) == 0x000008, "Wrong alignment on UUIController");
static_assert(sizeof(UUIController) == 0x000058, "Wrong size on UUIController");
static_assert(offsetof(UUIController, m_UIControllerObj) == 0x000030, "Member 'UUIController::m_UIControllerObj' has a wrong offset!");

// Class DeadByDaylight.UMGAlertsWidget
// 0x00D0 (0x0418 - 0x0348)
class UUMGAlertsWidget final : public UMobileBaseUserWidget
{
public:
	TSoftClassPtr<class UClass>                   AtlantaScoreAlertComponentClass;                   // 0x0348(0x0038)(Edit, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   AtlantaStatusEffectAlertComponentClass;            // 0x0380(0x0038)(Edit, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CanvasPanelAlerts;                                 // 0x03B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IdleTime;                                          // 0x03C0(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C4[0x44];                                     // 0x03C4(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 _scoreAlertClass;                                  // 0x0408(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClass*                                 _statusEffectAlertClass;                           // 0x0410(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAlertsWidget">();
	}
	static class UUMGAlertsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAlertsWidget>();
	}
};
static_assert(alignof(UUMGAlertsWidget) == 0x000008, "Wrong alignment on UUMGAlertsWidget");
static_assert(sizeof(UUMGAlertsWidget) == 0x000418, "Wrong size on UUMGAlertsWidget");
static_assert(offsetof(UUMGAlertsWidget, AtlantaScoreAlertComponentClass) == 0x000348, "Member 'UUMGAlertsWidget::AtlantaScoreAlertComponentClass' has a wrong offset!");
static_assert(offsetof(UUMGAlertsWidget, AtlantaStatusEffectAlertComponentClass) == 0x000380, "Member 'UUMGAlertsWidget::AtlantaStatusEffectAlertComponentClass' has a wrong offset!");
static_assert(offsetof(UUMGAlertsWidget, CanvasPanelAlerts) == 0x0003B8, "Member 'UUMGAlertsWidget::CanvasPanelAlerts' has a wrong offset!");
static_assert(offsetof(UUMGAlertsWidget, IdleTime) == 0x0003C0, "Member 'UUMGAlertsWidget::IdleTime' has a wrong offset!");
static_assert(offsetof(UUMGAlertsWidget, _scoreAlertClass) == 0x000408, "Member 'UUMGAlertsWidget::_scoreAlertClass' has a wrong offset!");
static_assert(offsetof(UUMGAlertsWidget, _statusEffectAlertClass) == 0x000410, "Member 'UUMGAlertsWidget::_statusEffectAlertClass' has a wrong offset!");

// Class DeadByDaylight.UMGDragWidget
// 0x0028 (0x02D0 - 0x02A8)
class UUMGDragWidget : public UUserWidget
{
public:
	uint8                                         Pad_2A8[0x18];                                     // 0x02A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCustomWidgetWrapper_HudEditor*> _allEditableWidgets;                               // 0x02C0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void SetClampToViewportDirty();

	const TArray<class UCustomWidgetWrapper_HudEditor*> GetAllEditableWidgets() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGDragWidget">();
	}
	static class UUMGDragWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGDragWidget>();
	}
};
static_assert(alignof(UUMGDragWidget) == 0x000008, "Wrong alignment on UUMGDragWidget");
static_assert(sizeof(UUMGDragWidget) == 0x0002D0, "Wrong size on UUMGDragWidget");
static_assert(offsetof(UUMGDragWidget, _allEditableWidgets) == 0x0002C0, "Member 'UUMGDragWidget::_allEditableWidgets' has a wrong offset!");

// Class DeadByDaylight.UMGDragWidget_HudEditor
// 0x0060 (0x0330 - 0x02D0)
class UUMGDragWidget_HudEditor final : public UUMGDragWidget
{
public:
	uint8                                         Pad_2D0[0x20];                                     // 0x02D0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidget>                OnSelectionWidgetClass;                            // 0x02F0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUMGHudEditorDragConstraintWidget> DragLinkWidgetClass;                        // 0x02F8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomWidgetWrapper_HudEditor*         _customWrapper;                                    // 0x0300(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserWidget*                            _selectionWidget;                                  // 0x0308(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUMGHudEditorDragConstraintWidget*      _dragLinkWidget;                                   // 0x0310(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUMGDragWidget_HudEditor*               _parentLinkWidget;                                 // 0x0318(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUMGDragWidget_HudEditor*               _childLinkWidget;                                  // 0x0320(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetOnSelection(bool IsSelected);

	class UCustomWidgetWrapper_HudEditor* GetCustomWrapper() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGDragWidget_HudEditor">();
	}
	static class UUMGDragWidget_HudEditor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGDragWidget_HudEditor>();
	}
};
static_assert(alignof(UUMGDragWidget_HudEditor) == 0x000008, "Wrong alignment on UUMGDragWidget_HudEditor");
static_assert(sizeof(UUMGDragWidget_HudEditor) == 0x000330, "Wrong size on UUMGDragWidget_HudEditor");
static_assert(offsetof(UUMGDragWidget_HudEditor, OnSelectionWidgetClass) == 0x0002F0, "Member 'UUMGDragWidget_HudEditor::OnSelectionWidgetClass' has a wrong offset!");
static_assert(offsetof(UUMGDragWidget_HudEditor, DragLinkWidgetClass) == 0x0002F8, "Member 'UUMGDragWidget_HudEditor::DragLinkWidgetClass' has a wrong offset!");
static_assert(offsetof(UUMGDragWidget_HudEditor, _customWrapper) == 0x000300, "Member 'UUMGDragWidget_HudEditor::_customWrapper' has a wrong offset!");
static_assert(offsetof(UUMGDragWidget_HudEditor, _selectionWidget) == 0x000308, "Member 'UUMGDragWidget_HudEditor::_selectionWidget' has a wrong offset!");
static_assert(offsetof(UUMGDragWidget_HudEditor, _dragLinkWidget) == 0x000310, "Member 'UUMGDragWidget_HudEditor::_dragLinkWidget' has a wrong offset!");
static_assert(offsetof(UUMGDragWidget_HudEditor, _parentLinkWidget) == 0x000318, "Member 'UUMGDragWidget_HudEditor::_parentLinkWidget' has a wrong offset!");
static_assert(offsetof(UUMGDragWidget_HudEditor, _childLinkWidget) == 0x000320, "Member 'UUMGDragWidget_HudEditor::_childLinkWidget' has a wrong offset!");

// Class DeadByDaylight.UMGHtmlRichText
// 0x0000 (0x0890 - 0x0890)
class UUMGHtmlRichText final : public URichTextBlock
{
public:
	void SetHTMLText(const class FString& InText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGHtmlRichText">();
	}
	static class UUMGHtmlRichText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGHtmlRichText>();
	}
};
static_assert(alignof(UUMGHtmlRichText) == 0x000010, "Wrong alignment on UUMGHtmlRichText");
static_assert(sizeof(UUMGHtmlRichText) == 0x000890, "Wrong size on UUMGHtmlRichText");

// Class DeadByDaylight.UMGHtmlTextDecorator
// 0x0000 (0x0030 - 0x0030)
class UUMGHtmlTextDecorator final : public URichTextBlockDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGHtmlTextDecorator">();
	}
	static class UUMGHtmlTextDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGHtmlTextDecorator>();
	}
};
static_assert(alignof(UUMGHtmlTextDecorator) == 0x000008, "Wrong alignment on UUMGHtmlTextDecorator");
static_assert(sizeof(UUMGHtmlTextDecorator) == 0x000030, "Wrong size on UUMGHtmlTextDecorator");

// Class DeadByDaylight.UMGHudEditorDragConstraintWidget
// 0x0060 (0x0308 - 0x02A8)
class UUMGHudEditorDragConstraintWidget final : public UUserWidget
{
public:
	class USizeBox*                               LinkSizeBox;                                       // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            _childWidget;                                      // 0x02B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserWidget*                            _parentWidget;                                     // 0x02B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0[0x48];                                     // 0x02C0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGHudEditorDragConstraintWidget">();
	}
	static class UUMGHudEditorDragConstraintWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGHudEditorDragConstraintWidget>();
	}
};
static_assert(alignof(UUMGHudEditorDragConstraintWidget) == 0x000008, "Wrong alignment on UUMGHudEditorDragConstraintWidget");
static_assert(sizeof(UUMGHudEditorDragConstraintWidget) == 0x000308, "Wrong size on UUMGHudEditorDragConstraintWidget");
static_assert(offsetof(UUMGHudEditorDragConstraintWidget, LinkSizeBox) == 0x0002A8, "Member 'UUMGHudEditorDragConstraintWidget::LinkSizeBox' has a wrong offset!");
static_assert(offsetof(UUMGHudEditorDragConstraintWidget, _childWidget) == 0x0002B0, "Member 'UUMGHudEditorDragConstraintWidget::_childWidget' has a wrong offset!");
static_assert(offsetof(UUMGHudEditorDragConstraintWidget, _parentWidget) == 0x0002B8, "Member 'UUMGHudEditorDragConstraintWidget::_parentWidget' has a wrong offset!");

// Class DeadByDaylight.UMGHudEditorLayoutWidget
// 0x0078 (0x0348 - 0x02D0)
class UUMGHudEditorLayoutWidget final : public UUMGDragWidget
{
public:
	uint8                                         Pad_2D0[0x10];                                     // 0x02D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUMGHudEditorScreen*                    hudEditorScreen;                                   // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          _onSaveOverlapSound;                               // 0x02E8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUMGDragWidget_HudEditor*               _currentWidgetToEdit;                              // 0x02F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class UUMGHudEditorLayoutScreen*, bool>  _isSaveDirtyMap;                                   // 0x02F8(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void FlagSaveAsDirty();
	void FlipLayout();
	void OnSaveDirty(bool IsDirty);
	void ResetLayout();
	void SaveLayout();
	void SetHudEditorScreen(class UUMGHudEditorScreen* hudEditorScreen_0);
	void SetSaveOverlapSound(class UAkAudioEvent* onSaveOverlapSound);
	void SetWidgetToEdit(class UUMGDragWidget_HudEditor* Widget);
	void ShowKillerLayout();
	void ShowSurvivorLayout();

	class UUMGDragWidget_HudEditor* GetCurrentDragWidget() const;
	class UCustomWidgetWrapper_HudEditor* GetHudEditorWrapperToEdit() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGHudEditorLayoutWidget">();
	}
	static class UUMGHudEditorLayoutWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGHudEditorLayoutWidget>();
	}
};
static_assert(alignof(UUMGHudEditorLayoutWidget) == 0x000008, "Wrong alignment on UUMGHudEditorLayoutWidget");
static_assert(sizeof(UUMGHudEditorLayoutWidget) == 0x000348, "Wrong size on UUMGHudEditorLayoutWidget");
static_assert(offsetof(UUMGHudEditorLayoutWidget, hudEditorScreen) == 0x0002E0, "Member 'UUMGHudEditorLayoutWidget::hudEditorScreen' has a wrong offset!");
static_assert(offsetof(UUMGHudEditorLayoutWidget, _onSaveOverlapSound) == 0x0002E8, "Member 'UUMGHudEditorLayoutWidget::_onSaveOverlapSound' has a wrong offset!");
static_assert(offsetof(UUMGHudEditorLayoutWidget, _currentWidgetToEdit) == 0x0002F0, "Member 'UUMGHudEditorLayoutWidget::_currentWidgetToEdit' has a wrong offset!");
static_assert(offsetof(UUMGHudEditorLayoutWidget, _isSaveDirtyMap) == 0x0002F8, "Member 'UUMGHudEditorLayoutWidget::_isSaveDirtyMap' has a wrong offset!");

// Class DeadByDaylight.UMGHudEditorScreen
// 0x0070 (0x0318 - 0x02A8)
class UUMGHudEditorScreen final : public UUserWidget
{
public:
	class UUMGHudEditorLayoutWidget*              _hudEditorLayoutWidget;                            // 0x02A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUMGHudEditorVersionWidget*             _versionSwapWidget;                                // 0x02B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EPlayerRole, class UUMGHudEditorLayoutScreen*> _storedLayoutScreens;                        // 0x02B8(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UUMGHudEditorLayoutScreen*              _currentLayoutScreen;                              // 0x0308(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          _onDropOverlapSound;                               // 0x0310(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Quit();
	void RegisterEditorLayoutScreen(EPlayerRole Role, class UUMGHudEditorLayoutScreen* screen);
	void SetEditorDropErrorOverlapSound(class UAkAudioEvent* onDropOverlapSound);
	void SetWidgets(class UUMGHudEditorLayoutWidget* hudEditorLayoutWidget, class UUMGHudEditorVersionWidget* versionSwapWidget);
	void ShowHudLayout(EPlayerRole Role);

	class UUMGHudEditorVersionWidget* GetVersionSwapWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGHudEditorScreen">();
	}
	static class UUMGHudEditorScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGHudEditorScreen>();
	}
};
static_assert(alignof(UUMGHudEditorScreen) == 0x000008, "Wrong alignment on UUMGHudEditorScreen");
static_assert(sizeof(UUMGHudEditorScreen) == 0x000318, "Wrong size on UUMGHudEditorScreen");
static_assert(offsetof(UUMGHudEditorScreen, _hudEditorLayoutWidget) == 0x0002A8, "Member 'UUMGHudEditorScreen::_hudEditorLayoutWidget' has a wrong offset!");
static_assert(offsetof(UUMGHudEditorScreen, _versionSwapWidget) == 0x0002B0, "Member 'UUMGHudEditorScreen::_versionSwapWidget' has a wrong offset!");
static_assert(offsetof(UUMGHudEditorScreen, _storedLayoutScreens) == 0x0002B8, "Member 'UUMGHudEditorScreen::_storedLayoutScreens' has a wrong offset!");
static_assert(offsetof(UUMGHudEditorScreen, _currentLayoutScreen) == 0x000308, "Member 'UUMGHudEditorScreen::_currentLayoutScreen' has a wrong offset!");
static_assert(offsetof(UUMGHudEditorScreen, _onDropOverlapSound) == 0x000310, "Member 'UUMGHudEditorScreen::_onDropOverlapSound' has a wrong offset!");

// Class DeadByDaylight.UMGUtilities
// 0x0000 (0x0030 - 0x0030)
class UUMGUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGUtilities">();
	}
	static class UUMGUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGUtilities>();
	}
};
static_assert(alignof(UUMGUtilities) == 0x000008, "Wrong alignment on UUMGUtilities");
static_assert(sizeof(UUMGUtilities) == 0x000030, "Wrong size on UUMGUtilities");

// Class DeadByDaylight.UnbrokenPalletsRestrictedPlacementAreaStrategy
// 0x0020 (0x00C8 - 0x00A8)
class UUnbrokenPalletsRestrictedPlacementAreaStrategy final : public URestrictedPlacementAreaStrategy
{
public:
	TArray<class APallet*>                        _unbrokenPallets;                                  // 0x00A8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class FName                                   _palletCollisionBoxWhenDroppedTagName;             // 0x00B8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnbrokenPalletsRestrictedPlacementAreaStrategy">();
	}
	static class UUnbrokenPalletsRestrictedPlacementAreaStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnbrokenPalletsRestrictedPlacementAreaStrategy>();
	}
};
static_assert(alignof(UUnbrokenPalletsRestrictedPlacementAreaStrategy) == 0x000008, "Wrong alignment on UUnbrokenPalletsRestrictedPlacementAreaStrategy");
static_assert(sizeof(UUnbrokenPalletsRestrictedPlacementAreaStrategy) == 0x0000C8, "Wrong size on UUnbrokenPalletsRestrictedPlacementAreaStrategy");
static_assert(offsetof(UUnbrokenPalletsRestrictedPlacementAreaStrategy, _unbrokenPallets) == 0x0000A8, "Member 'UUnbrokenPalletsRestrictedPlacementAreaStrategy::_unbrokenPallets' has a wrong offset!");
static_assert(offsetof(UUnbrokenPalletsRestrictedPlacementAreaStrategy, _palletCollisionBoxWhenDroppedTagName) == 0x0000B8, "Member 'UUnbrokenPalletsRestrictedPlacementAreaStrategy::_palletCollisionBoxWhenDroppedTagName' has a wrong offset!");

// Class DeadByDaylight.UsableWithTimerIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UUsableWithTimerIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UsableWithTimerIconStrategy">();
	}
	static class UUsableWithTimerIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUsableWithTimerIconStrategy>();
	}
};
static_assert(alignof(UUsableWithTimerIconStrategy) == 0x000008, "Wrong alignment on UUsableWithTimerIconStrategy");
static_assert(sizeof(UUsableWithTimerIconStrategy) == 0x000038, "Wrong size on UUsableWithTimerIconStrategy");

// Class DeadByDaylight.VaultableComponent
// 0x0020 (0x00D8 - 0x00B8)
class UVaultableComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(class ADBDPlayer* vaulter)> OnVault;                               // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x10];                                      // 0x00C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChaseEnded(class ADBDPlayer* survivorPlayer, float ChaseTimer);
	void SignalVault(class ADBDPlayer* Survivor, float InteractionTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VaultableComponent">();
	}
	static class UVaultableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVaultableComponent>();
	}
};
static_assert(alignof(UVaultableComponent) == 0x000008, "Wrong alignment on UVaultableComponent");
static_assert(sizeof(UVaultableComponent) == 0x0000D8, "Wrong size on UVaultableComponent");
static_assert(offsetof(UVaultableComponent, OnVault) == 0x0000B8, "Member 'UVaultableComponent::OnVault' has a wrong offset!");

// Class DeadByDaylight.VomitStateComponent
// 0x00E0 (0x0198 - 0x00B8)
class UVomitStateComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTagStateBool                          _isIdle;                                           // 0x00C0(0x0048)(NativeAccessSpecifierPrivate)
	struct FTagStateBool                          _isCharging;                                       // 0x0108(0x0048)(NativeAccessSpecifierPrivate)
	struct FTagStateBool                          _isVomiting;                                       // 0x0150(0x0048)(NativeAccessSpecifierPrivate)

public:
	void SetObjectState(class UGameplayTagContainerComponent* objectState);
	void SetVomitState(ELinkedVomitState newVomitState);

	ELinkedVomitState GetVomitState() const;
	bool IsVomiting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VomitStateComponent">();
	}
	static class UVomitStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVomitStateComponent>();
	}
};
static_assert(alignof(UVomitStateComponent) == 0x000008, "Wrong alignment on UVomitStateComponent");
static_assert(sizeof(UVomitStateComponent) == 0x000198, "Wrong size on UVomitStateComponent");
static_assert(offsetof(UVomitStateComponent, _isIdle) == 0x0000C0, "Member 'UVomitStateComponent::_isIdle' has a wrong offset!");
static_assert(offsetof(UVomitStateComponent, _isCharging) == 0x000108, "Member 'UVomitStateComponent::_isCharging' has a wrong offset!");
static_assert(offsetof(UVomitStateComponent, _isVomiting) == 0x000150, "Member 'UVomitStateComponent::_isVomiting' has a wrong offset!");

// Class DeadByDaylight.WalesCypherHandler
// 0x0010 (0x0048 - 0x0038)
class UWalesCypherHandler final : public ULocalPlayerSubsystem
{
public:
	class UWalesCypherParameters*                 _walesCypherParams;                                // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WalesCypherHandler">();
	}
	static class UWalesCypherHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWalesCypherHandler>();
	}
};
static_assert(alignof(UWalesCypherHandler) == 0x000008, "Wrong alignment on UWalesCypherHandler");
static_assert(sizeof(UWalesCypherHandler) == 0x000048, "Wrong size on UWalesCypherHandler");
static_assert(offsetof(UWalesCypherHandler, _walesCypherParams) == 0x000038, "Member 'UWalesCypherHandler::_walesCypherParams' has a wrong offset!");

// Class DeadByDaylight.WalletHandler
// 0x0140 (0x0170 - 0x0030)
class UWalletHandler final : public UObject
{
public:
	uint8                                         Pad_30[0x140];                                     // 0x0030(0x0140)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WalletHandler">();
	}
	static class UWalletHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWalletHandler>();
	}
};
static_assert(alignof(UWalletHandler) == 0x000008, "Wrong alignment on UWalletHandler");
static_assert(sizeof(UWalletHandler) == 0x000170, "Wrong size on UWalletHandler");

// Class DeadByDaylight.WCSRComponent
// 0x0018 (0x0150 - 0x0138)
class UWCSRComponent : public UDBDSRComponent
{
public:
	class UAkAudioEvent*                          _breakSoundEvent;                                  // 0x0138(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FCharacterDropdown>             _eligibleCharacters;                               // 0x0140(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void Client_PlayBreakSound();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WCSRComponent">();
	}
	static class UWCSRComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWCSRComponent>();
	}
};
static_assert(alignof(UWCSRComponent) == 0x000008, "Wrong alignment on UWCSRComponent");
static_assert(sizeof(UWCSRComponent) == 0x000150, "Wrong size on UWCSRComponent");
static_assert(offsetof(UWCSRComponent, _breakSoundEvent) == 0x000138, "Member 'UWCSRComponent::_breakSoundEvent' has a wrong offset!");
static_assert(offsetof(UWCSRComponent, _eligibleCharacters) == 0x000140, "Member 'UWCSRComponent::_eligibleCharacters' has a wrong offset!");

// Class DeadByDaylight.WorldObjectTriggeringActorInterface
// 0x0000 (0x0000 - 0x0000)
class IWorldObjectTriggeringActorInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldObjectTriggeringActorInterface">();
	}
	static class IWorldObjectTriggeringActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IWorldObjectTriggeringActorInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IWorldObjectTriggeringActorInterface) == 0x000001, "Wrong alignment on IWorldObjectTriggeringActorInterface");
static_assert(sizeof(IWorldObjectTriggeringActorInterface) == 0x000001, "Wrong size on IWorldObjectTriggeringActorInterface");

// Class DeadByDaylight.WorldObjectTriggeringKillerComponent
// 0x0000 (0x00C0 - 0x00C0)
class UWorldObjectTriggeringKillerComponent final : public UWorldObjectTriggeringPlayerComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldObjectTriggeringKillerComponent">();
	}
	static class UWorldObjectTriggeringKillerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldObjectTriggeringKillerComponent>();
	}
};
static_assert(alignof(UWorldObjectTriggeringKillerComponent) == 0x000008, "Wrong alignment on UWorldObjectTriggeringKillerComponent");
static_assert(sizeof(UWorldObjectTriggeringKillerComponent) == 0x0000C0, "Wrong size on UWorldObjectTriggeringKillerComponent");

// Class DeadByDaylight.XboxProfileDAL
// 0x0000 (0x0088 - 0x0088)
class UXboxProfileDAL final : public UPlayerProfileDAL
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"XboxProfileDAL">();
	}
	static class UXboxProfileDAL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UXboxProfileDAL>();
	}
};
static_assert(alignof(UXboxProfileDAL) == 0x000008, "Wrong alignment on UXboxProfileDAL");
static_assert(sizeof(UXboxProfileDAL) == 0x000088, "Wrong size on UXboxProfileDAL");

// Class DeadByDaylight.ZoneDetectorComponent
// 0x0038 (0x00F0 - 0x00B8)
class UZoneDetectorComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPrimitiveComponent*>            _zones;                                            // 0x00D0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _tags;                                             // 0x00E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void OnOverlapEnter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnOverlapExit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZoneDetectorComponent">();
	}
	static class UZoneDetectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZoneDetectorComponent>();
	}
};
static_assert(alignof(UZoneDetectorComponent) == 0x000008, "Wrong alignment on UZoneDetectorComponent");
static_assert(sizeof(UZoneDetectorComponent) == 0x0000F0, "Wrong size on UZoneDetectorComponent");
static_assert(offsetof(UZoneDetectorComponent, _zones) == 0x0000D0, "Member 'UZoneDetectorComponent::_zones' has a wrong offset!");
static_assert(offsetof(UZoneDetectorComponent, _tags) == 0x0000E0, "Member 'UZoneDetectorComponent::_tags' has a wrong offset!");

}

