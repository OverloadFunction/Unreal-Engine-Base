#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheK29

#include "Basic.hpp"

#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "DBDCompetence_classes.hpp"
#include "DBDBots_classes.hpp"
#include "DBDAnimation_classes.hpp"
#include "AnimationUtilities_structs.hpp"
#include "DBDGameplay_classes.hpp"
#include "Engine_classes.hpp"
#include "DataTableUtilities_structs.hpp"
#include "StatSystem_structs.hpp"
#include "TheK29_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "DBDCosmetic_classes.hpp"


namespace SDK
{

// Class TheK29.K29InfectionRemovalCollectable
// 0x0010 (0x05B8 - 0x05A8)
class AK29InfectionRemovalCollectable final : public AContaminationAntidoteCollectable
{
public:
	uint8                                         Pad_5A8[0x10];                                     // 0x05A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29InfectionRemovalCollectable">();
	}
	static class AK29InfectionRemovalCollectable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK29InfectionRemovalCollectable>();
	}
};
static_assert(alignof(AK29InfectionRemovalCollectable) == 0x000008, "Wrong alignment on AK29InfectionRemovalCollectable");
static_assert(sizeof(AK29InfectionRemovalCollectable) == 0x0005B8, "Wrong size on AK29InfectionRemovalCollectable");

// Class TheK29.AISkill_FindCollectable_K29SupplyCrate
// 0x00C0 (0x0460 - 0x03A0)
class UAISkill_FindCollectable_K29SupplyCrate final : public UAISkill_FindCollectable_Searchable
{
public:
	struct FAITunableParameter                    UrgencyGoalWeight;                                 // 0x03A0(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    OpenedWeightMultiplier;                            // 0x0400(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindCollectable_K29SupplyCrate">();
	}
	static class UAISkill_FindCollectable_K29SupplyCrate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindCollectable_K29SupplyCrate>();
	}
};
static_assert(alignof(UAISkill_FindCollectable_K29SupplyCrate) == 0x000008, "Wrong alignment on UAISkill_FindCollectable_K29SupplyCrate");
static_assert(sizeof(UAISkill_FindCollectable_K29SupplyCrate) == 0x000460, "Wrong size on UAISkill_FindCollectable_K29SupplyCrate");
static_assert(offsetof(UAISkill_FindCollectable_K29SupplyCrate, UrgencyGoalWeight) == 0x0003A0, "Member 'UAISkill_FindCollectable_K29SupplyCrate::UrgencyGoalWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindCollectable_K29SupplyCrate, OpenedWeightMultiplier) == 0x000400, "Member 'UAISkill_FindCollectable_K29SupplyCrate::OpenedWeightMultiplier' has a wrong offset!");

// Class TheK29.AISkill_InteractionUseItem_K29StabilizingSpray
// 0x0000 (0x0290 - 0x0290)
class UAISkill_InteractionUseItem_K29StabilizingSpray final : public UAISkill_InteractionUseItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionUseItem_K29StabilizingSpray">();
	}
	static class UAISkill_InteractionUseItem_K29StabilizingSpray* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionUseItem_K29StabilizingSpray>();
	}
};
static_assert(alignof(UAISkill_InteractionUseItem_K29StabilizingSpray) == 0x000008, "Wrong alignment on UAISkill_InteractionUseItem_K29StabilizingSpray");
static_assert(sizeof(UAISkill_InteractionUseItem_K29StabilizingSpray) == 0x000290, "Wrong size on UAISkill_InteractionUseItem_K29StabilizingSpray");

// Class TheK29.AISkill_InteractionUseItem_K29StabilizingSprayOther
// 0x0000 (0x0290 - 0x0290)
class UAISkill_InteractionUseItem_K29StabilizingSprayOther final : public UAISkill_InteractionUseItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionUseItem_K29StabilizingSprayOther">();
	}
	static class UAISkill_InteractionUseItem_K29StabilizingSprayOther* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionUseItem_K29StabilizingSprayOther>();
	}
};
static_assert(alignof(UAISkill_InteractionUseItem_K29StabilizingSprayOther) == 0x000008, "Wrong alignment on UAISkill_InteractionUseItem_K29StabilizingSprayOther");
static_assert(sizeof(UAISkill_InteractionUseItem_K29StabilizingSprayOther) == 0x000290, "Wrong size on UAISkill_InteractionUseItem_K29StabilizingSprayOther");

// Class TheK29.K29KillerVaultInteractionDefinition
// 0x0050 (0x08B0 - 0x0860)
class UK29KillerVaultInteractionDefinition final : public UKillerVaultDefinition
{
public:
	struct FAnimationMontageDescriptor            _rushPallet;                                       // 0x0860(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _rushWindow;                                       // 0x0880(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8A0[0x10];                                     // 0x08A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnTentacleSlashDamage(class ASurvivor* hitSurvivor, const bool isDowned);
	void Multicast_DamageWithTentacleSlash(class ADBDPlayer* Player, class ASurvivor* hitSurvivor, const bool isDowned);
	void Multicast_WillHitSurvivor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29KillerVaultInteractionDefinition">();
	}
	static class UK29KillerVaultInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29KillerVaultInteractionDefinition>();
	}
};
static_assert(alignof(UK29KillerVaultInteractionDefinition) == 0x000010, "Wrong alignment on UK29KillerVaultInteractionDefinition");
static_assert(sizeof(UK29KillerVaultInteractionDefinition) == 0x0008B0, "Wrong size on UK29KillerVaultInteractionDefinition");
static_assert(offsetof(UK29KillerVaultInteractionDefinition, _rushPallet) == 0x000860, "Member 'UK29KillerVaultInteractionDefinition::_rushPallet' has a wrong offset!");
static_assert(offsetof(UK29KillerVaultInteractionDefinition, _rushWindow) == 0x000880, "Member 'UK29KillerVaultInteractionDefinition::_rushWindow' has a wrong offset!");

// Class TheK29.AISkill_Interaction_K29Rush
// 0x0358 (0x05F8 - 0x02A0)
class UAISkill_Interaction_K29Rush final : public UAISkill_Interaction_KillerPower
{
public:
	struct FAITunableParameter                    MinimumChargeDistance;                             // 0x02A0(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MaximumChargeDistance;                             // 0x0300(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MaxRushHoldTime;                                   // 0x0360(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         ChargeDistance;                                    // 0x03C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartAimAtChargePercent;                           // 0x03C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    FacingDirectionAngleAtMaxDistance;                 // 0x03C8(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    FacingDirectionAngleAtZeroDistance;                // 0x0428(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    AimVelocityPercentagePerMeter;                     // 0x0488(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    AimAtPredictedLocationChance;                      // 0x04E8(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         PathRushAngleAdjust;                               // 0x0548(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54C[0x4];                                      // 0x054C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    CameraLerpOverride;                                // 0x0550(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         RushStartAdjustDistance;                           // 0x05B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavRaycastHitTargetDistanceMargin;                 // 0x05B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstRushDistance;                                 // 0x05B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondRushDistance;                                // 0x05BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavLinkAdjustWithinDistance;                       // 0x05C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavLinkOffsetPosition;                             // 0x05C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C8[0x30];                                     // 0x05C8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_K29Rush">();
	}
	static class UAISkill_Interaction_K29Rush* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_K29Rush>();
	}
};
static_assert(alignof(UAISkill_Interaction_K29Rush) == 0x000008, "Wrong alignment on UAISkill_Interaction_K29Rush");
static_assert(sizeof(UAISkill_Interaction_K29Rush) == 0x0005F8, "Wrong size on UAISkill_Interaction_K29Rush");
static_assert(offsetof(UAISkill_Interaction_K29Rush, MinimumChargeDistance) == 0x0002A0, "Member 'UAISkill_Interaction_K29Rush::MinimumChargeDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_K29Rush, MaximumChargeDistance) == 0x000300, "Member 'UAISkill_Interaction_K29Rush::MaximumChargeDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_K29Rush, MaxRushHoldTime) == 0x000360, "Member 'UAISkill_Interaction_K29Rush::MaxRushHoldTime' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_K29Rush, ChargeDistance) == 0x0003C0, "Member 'UAISkill_Interaction_K29Rush::ChargeDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_K29Rush, StartAimAtChargePercent) == 0x0003C4, "Member 'UAISkill_Interaction_K29Rush::StartAimAtChargePercent' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_K29Rush, FacingDirectionAngleAtMaxDistance) == 0x0003C8, "Member 'UAISkill_Interaction_K29Rush::FacingDirectionAngleAtMaxDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_K29Rush, FacingDirectionAngleAtZeroDistance) == 0x000428, "Member 'UAISkill_Interaction_K29Rush::FacingDirectionAngleAtZeroDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_K29Rush, AimVelocityPercentagePerMeter) == 0x000488, "Member 'UAISkill_Interaction_K29Rush::AimVelocityPercentagePerMeter' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_K29Rush, AimAtPredictedLocationChance) == 0x0004E8, "Member 'UAISkill_Interaction_K29Rush::AimAtPredictedLocationChance' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_K29Rush, PathRushAngleAdjust) == 0x000548, "Member 'UAISkill_Interaction_K29Rush::PathRushAngleAdjust' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_K29Rush, CameraLerpOverride) == 0x000550, "Member 'UAISkill_Interaction_K29Rush::CameraLerpOverride' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_K29Rush, RushStartAdjustDistance) == 0x0005B0, "Member 'UAISkill_Interaction_K29Rush::RushStartAdjustDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_K29Rush, NavRaycastHitTargetDistanceMargin) == 0x0005B4, "Member 'UAISkill_Interaction_K29Rush::NavRaycastHitTargetDistanceMargin' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_K29Rush, FirstRushDistance) == 0x0005B8, "Member 'UAISkill_Interaction_K29Rush::FirstRushDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_K29Rush, SecondRushDistance) == 0x0005BC, "Member 'UAISkill_Interaction_K29Rush::SecondRushDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_K29Rush, NavLinkAdjustWithinDistance) == 0x0005C0, "Member 'UAISkill_Interaction_K29Rush::NavLinkAdjustWithinDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_K29Rush, NavLinkOffsetPosition) == 0x0005C4, "Member 'UAISkill_Interaction_K29Rush::NavLinkOffsetPosition' has a wrong offset!");

// Class TheK29.K29AnimInstance
// 0x0030 (0x0750 - 0x0720)
class UK29AnimInstance final : public UKillerAnimInstance
{
public:
	bool                                          _isRushing;                                        // 0x0720(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHoldingSurvivor;                                // 0x0721(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isChargingRushing;                                // 0x0722(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBetweenRushes;                                  // 0x0723(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isThrowing;                                       // 0x0724(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBouncingBack;                                   // 0x0725(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasStartedFinalRush;                              // 0x0726(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasRushEndedInSurvivorImpact;                     // 0x0727(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasRushEndedInLedgeDrop;                          // 0x0728(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasInstantlyPickedUpSurvivor;                     // 0x0729(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isReadyToRushButHasNoPath;                        // 0x072A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_72B[0x25];                                     // 0x072B(0x0025)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameEventReceived(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData);
	void OnHasInstantlyPickedUpSurvivor();
	void OnHasRushEndedInLedgeDrop();
	void OnHasRushEndedInSurvivorImpact();
	void OnStartThrowingSurvivor();
	void ResetHasInstantlyPickedUpSurvivor();
	void ResetHasRushEndedInLedgeDrop();
	void ResetHasRushEndedInSurvivorImpact();
	void ResetStartThrowingSurvivor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29AnimInstance">();
	}
	static class UK29AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29AnimInstance>();
	}
};
static_assert(alignof(UK29AnimInstance) == 0x000010, "Wrong alignment on UK29AnimInstance");
static_assert(sizeof(UK29AnimInstance) == 0x000750, "Wrong size on UK29AnimInstance");
static_assert(offsetof(UK29AnimInstance, _isRushing) == 0x000720, "Member 'UK29AnimInstance::_isRushing' has a wrong offset!");
static_assert(offsetof(UK29AnimInstance, _isHoldingSurvivor) == 0x000721, "Member 'UK29AnimInstance::_isHoldingSurvivor' has a wrong offset!");
static_assert(offsetof(UK29AnimInstance, _isChargingRushing) == 0x000722, "Member 'UK29AnimInstance::_isChargingRushing' has a wrong offset!");
static_assert(offsetof(UK29AnimInstance, _isBetweenRushes) == 0x000723, "Member 'UK29AnimInstance::_isBetweenRushes' has a wrong offset!");
static_assert(offsetof(UK29AnimInstance, _isThrowing) == 0x000724, "Member 'UK29AnimInstance::_isThrowing' has a wrong offset!");
static_assert(offsetof(UK29AnimInstance, _isBouncingBack) == 0x000725, "Member 'UK29AnimInstance::_isBouncingBack' has a wrong offset!");
static_assert(offsetof(UK29AnimInstance, _hasStartedFinalRush) == 0x000726, "Member 'UK29AnimInstance::_hasStartedFinalRush' has a wrong offset!");
static_assert(offsetof(UK29AnimInstance, _hasRushEndedInSurvivorImpact) == 0x000727, "Member 'UK29AnimInstance::_hasRushEndedInSurvivorImpact' has a wrong offset!");
static_assert(offsetof(UK29AnimInstance, _hasRushEndedInLedgeDrop) == 0x000728, "Member 'UK29AnimInstance::_hasRushEndedInLedgeDrop' has a wrong offset!");
static_assert(offsetof(UK29AnimInstance, _hasInstantlyPickedUpSurvivor) == 0x000729, "Member 'UK29AnimInstance::_hasInstantlyPickedUpSurvivor' has a wrong offset!");
static_assert(offsetof(UK29AnimInstance, _isReadyToRushButHasNoPath) == 0x00072A, "Member 'UK29AnimInstance::_isReadyToRushButHasNoPath' has a wrong offset!");

// Class TheK29.K29GateBlockerStatusEffect
// 0x0020 (0x04A0 - 0x0480)
class UK29GateBlockerStatusEffect final : public ULingeringMultiStateTagStatusEffect
{
public:
	class FName                                   _escapeZoneBoxComponentTagName;                    // 0x0480(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48C[0x14];                                     // 0x048C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29GateBlockerStatusEffect">();
	}
	static class UK29GateBlockerStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29GateBlockerStatusEffect>();
	}
};
static_assert(alignof(UK29GateBlockerStatusEffect) == 0x000008, "Wrong alignment on UK29GateBlockerStatusEffect");
static_assert(sizeof(UK29GateBlockerStatusEffect) == 0x0004A0, "Wrong size on UK29GateBlockerStatusEffect");
static_assert(offsetof(UK29GateBlockerStatusEffect, _escapeZoneBoxComponentTagName) == 0x000480, "Member 'UK29GateBlockerStatusEffect::_escapeZoneBoxComponentTagName' has a wrong offset!");

// Class TheK29.K29P01
// 0x0010 (0x0470 - 0x0460)
class UK29P01 final : public UPerk
{
public:
	float                                         _survivorVaultRushedEventRange;                    // 0x0460(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _cooldownTime;                                     // 0x0464(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_468[0x8];                                      // 0x0468(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetSurvivorVaultRushedEventRange() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29P01">();
	}
	static class UK29P01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29P01>();
	}
};
static_assert(alignof(UK29P01) == 0x000008, "Wrong alignment on UK29P01");
static_assert(sizeof(UK29P01) == 0x000470, "Wrong size on UK29P01");
static_assert(offsetof(UK29P01, _survivorVaultRushedEventRange) == 0x000460, "Member 'UK29P01::_survivorVaultRushedEventRange' has a wrong offset!");
static_assert(offsetof(UK29P01, _cooldownTime) == 0x000464, "Member 'UK29P01::_cooldownTime' has a wrong offset!");

// Class TheK29.K29P02
// 0x00C8 (0x0528 - 0x0460)
class UK29P02 final : public UPerk
{
public:
	float                                         _revealRange[0x3];                                 // 0x0460(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_46C[0x4];                                      // 0x046C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _effectClass;                                      // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<TWeakObjectPtr<class ASurvivor>, TWeakObjectPtr<class UStatusEffect>> _survivorRevealedEffects; // 0x0478(0x0050)(ExportObject, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C8[0x60];                                     // 0x04C8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnInRangeChanged(const bool inRange, class ASurvivor* Survivor);
	const float GetRevealRange();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29P02">();
	}
	static class UK29P02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29P02>();
	}
};
static_assert(alignof(UK29P02) == 0x000008, "Wrong alignment on UK29P02");
static_assert(sizeof(UK29P02) == 0x000528, "Wrong size on UK29P02");
static_assert(offsetof(UK29P02, _revealRange) == 0x000460, "Member 'UK29P02::_revealRange' has a wrong offset!");
static_assert(offsetof(UK29P02, _effectClass) == 0x000470, "Member 'UK29P02::_effectClass' has a wrong offset!");
static_assert(offsetof(UK29P02, _survivorRevealedEffects) == 0x000478, "Member 'UK29P02::_survivorRevealedEffects' has a wrong offset!");

// Class TheK29.K29P03
// 0x0018 (0x0478 - 0x0460)
class UK29P03 final : public UPerk
{
public:
	float                                         _brokenEffectDuration[0x3];                        // 0x0460(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_46C[0x4];                                      // 0x046C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _effectClass;                                      // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29P03">();
	}
	static class UK29P03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29P03>();
	}
};
static_assert(alignof(UK29P03) == 0x000008, "Wrong alignment on UK29P03");
static_assert(sizeof(UK29P03) == 0x000478, "Wrong size on UK29P03");
static_assert(offsetof(UK29P03, _brokenEffectDuration) == 0x000460, "Member 'UK29P03::_brokenEffectDuration' has a wrong offset!");
static_assert(offsetof(UK29P03, _effectClass) == 0x000470, "Member 'UK29P03::_effectClass' has a wrong offset!");

// Class TheK29.K29P03StatusEffect
// 0x0000 (0x03A8 - 0x03A8)
class UK29P03StatusEffect final : public UAdjustableCooldownStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29P03StatusEffect">();
	}
	static class UK29P03StatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29P03StatusEffect>();
	}
};
static_assert(alignof(UK29P03StatusEffect) == 0x000008, "Wrong alignment on UK29P03StatusEffect");
static_assert(sizeof(UK29P03StatusEffect) == 0x0003A8, "Wrong size on UK29P03StatusEffect");

// Class TheK29.K29PathingCalculatorComponent
// 0x0208 (0x02C0 - 0x00B8)
class UK29PathingCalculatorComponent final : public UActorComponent
{
public:
	struct FDBDTunableRowHandle                   _maxStepHeight;                                    // 0x00B8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _maxStepHeightDownwards;                           // 0x00E0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _horizontalAngle;                                  // 0x0108(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _verticalAngle;                                    // 0x0130(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _gridLength;                                       // 0x0158(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _detectionHeightOffset;                            // 0x0180(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _floorSearchLengthFromActorLocation;               // 0x01A8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _minimumWallDashDistanceCarryingSurvivor;          // 0x01D0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         _floorCheckDistance;                               // 0x01F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FC[0x4];                                      // 0x01FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _lineOfSightCapsuleRadius;                         // 0x0200(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _lineOfSightCapsuleHeight;                         // 0x0228(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _lineOfSightCapsuleHeightOffset;                   // 0x0250(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _maximumWalkableAngle;                             // 0x0278(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         _groundCollisionDetectionRadius;                   // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _allowedGroundBlockerHeight;                       // 0x02A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minimalLedgeDistance;                             // 0x02A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _collisionProfileName;                             // 0x02AC(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29PathingCalculatorComponent">();
	}
	static class UK29PathingCalculatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29PathingCalculatorComponent>();
	}
};
static_assert(alignof(UK29PathingCalculatorComponent) == 0x000008, "Wrong alignment on UK29PathingCalculatorComponent");
static_assert(sizeof(UK29PathingCalculatorComponent) == 0x0002C0, "Wrong size on UK29PathingCalculatorComponent");
static_assert(offsetof(UK29PathingCalculatorComponent, _maxStepHeight) == 0x0000B8, "Member 'UK29PathingCalculatorComponent::_maxStepHeight' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _maxStepHeightDownwards) == 0x0000E0, "Member 'UK29PathingCalculatorComponent::_maxStepHeightDownwards' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _horizontalAngle) == 0x000108, "Member 'UK29PathingCalculatorComponent::_horizontalAngle' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _verticalAngle) == 0x000130, "Member 'UK29PathingCalculatorComponent::_verticalAngle' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _gridLength) == 0x000158, "Member 'UK29PathingCalculatorComponent::_gridLength' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _detectionHeightOffset) == 0x000180, "Member 'UK29PathingCalculatorComponent::_detectionHeightOffset' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _floorSearchLengthFromActorLocation) == 0x0001A8, "Member 'UK29PathingCalculatorComponent::_floorSearchLengthFromActorLocation' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _minimumWallDashDistanceCarryingSurvivor) == 0x0001D0, "Member 'UK29PathingCalculatorComponent::_minimumWallDashDistanceCarryingSurvivor' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _floorCheckDistance) == 0x0001F8, "Member 'UK29PathingCalculatorComponent::_floorCheckDistance' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _lineOfSightCapsuleRadius) == 0x000200, "Member 'UK29PathingCalculatorComponent::_lineOfSightCapsuleRadius' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _lineOfSightCapsuleHeight) == 0x000228, "Member 'UK29PathingCalculatorComponent::_lineOfSightCapsuleHeight' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _lineOfSightCapsuleHeightOffset) == 0x000250, "Member 'UK29PathingCalculatorComponent::_lineOfSightCapsuleHeightOffset' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _maximumWalkableAngle) == 0x000278, "Member 'UK29PathingCalculatorComponent::_maximumWalkableAngle' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _groundCollisionDetectionRadius) == 0x0002A0, "Member 'UK29PathingCalculatorComponent::_groundCollisionDetectionRadius' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _allowedGroundBlockerHeight) == 0x0002A4, "Member 'UK29PathingCalculatorComponent::_allowedGroundBlockerHeight' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _minimalLedgeDistance) == 0x0002A8, "Member 'UK29PathingCalculatorComponent::_minimalLedgeDistance' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _collisionProfileName) == 0x0002AC, "Member 'UK29PathingCalculatorComponent::_collisionProfileName' has a wrong offset!");

// Class TheK29.K29Power
// 0x01A0 (0x06F8 - 0x0558)
class AK29Power final : public ACollectable
{
public:
	class UChargeableComponent*                   _rushChargeableComponent;                          // 0x0558(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractor*                            _interactor;                                       // 0x0560(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxPlayerOverlapComponent*             _interactionVolume;                                // 0x0568(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK29PowerChargePresentationItemProgressComponent* _powerChargePresentationItemProgressComponent; // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK29PowerChargePresentationPowerFadeComponent* _powerChargePresentationPowerFadeComponent; // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UK29PowerStatusHandlerComponent> _powerStatusHandlerComponentClass;            // 0x0580(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UK29RushChargesHandlerComponent> _rushChargesHandlerComponentClass;            // 0x0588(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UK29PathingCalculatorComponent> _pathingCalculatorComponentClass;              // 0x0590(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _blindnessProtectionStatusEffectClass;             // 0x0598(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _rushChargeTime;                                   // 0x05A0(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FStatProperty                          _scorePercent;                                     // 0x0620(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AAnimationFollowerActor>    _moriTentaclesAnimationFollowerActorClass;         // 0x06A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6B0[0x8];                                      // 0x06B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UK29PowerStatusHandlerComponent*        _powerStatusHandlerComponent;                      // 0x06B8(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK29RushChargesHandlerComponent*        _rushChargesHandlerComponent;                      // 0x06C0(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK29PathingCalculatorComponent*         _pathingCalculatorComponent;                       // 0x06C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6D0[0x28];                                     // 0x06D0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnStun(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData);
	class UK29RushCooldownInteraction* GetDropSurvivorCooldownInteraction();
	class UK29PowerStatusHandlerComponent* GetPowerStatusHandlerComponent();
	class UInteractionDefinition* GetPushSurvivorOverLedgeInteraction();
	class UK29RushCooldownInteraction* GetRushBreakableCooldownInteraction();
	class UK29RushChargeableInteraction* GetRushChargeableInteraction();
	class UK29RushCooldownInteraction* GetRushChargeCancelCooldownInteraction();
	class UK29RushChargesHandlerComponent* GetRushChargesHandlerComponent();
	class UK29RushCooldownInteraction* GetRushCompleteNoSurvivorCooldownInteraction();
	class UK29RushCooldownInteraction* GetRushCompleteSurvivorHitCooldownInteraction();
	class UK29RushCooldownInteraction* GetRushCompleteSurvivorThrowCooldownInteraction();
	class UStaticMeshComponent* GetRushSurvivorDetectionBox();
	class UK29RushCooldownInteraction* GetRushVaultCooldownInteraction();
	class UInteractionDefinition* GetSlashBreakableInteraction();
	class UInteractionDefinition* GetSlashSurvivorInteraction();
	void OnRep_PowerStatusHandlerComponent();
	void OnRep_RushChargesHandlerComponent();

	float GetScorePercent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29Power">();
	}
	static class AK29Power* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK29Power>();
	}
};
static_assert(alignof(AK29Power) == 0x000008, "Wrong alignment on AK29Power");
static_assert(sizeof(AK29Power) == 0x0006F8, "Wrong size on AK29Power");
static_assert(offsetof(AK29Power, _rushChargeableComponent) == 0x000558, "Member 'AK29Power::_rushChargeableComponent' has a wrong offset!");
static_assert(offsetof(AK29Power, _interactor) == 0x000560, "Member 'AK29Power::_interactor' has a wrong offset!");
static_assert(offsetof(AK29Power, _interactionVolume) == 0x000568, "Member 'AK29Power::_interactionVolume' has a wrong offset!");
static_assert(offsetof(AK29Power, _powerChargePresentationItemProgressComponent) == 0x000570, "Member 'AK29Power::_powerChargePresentationItemProgressComponent' has a wrong offset!");
static_assert(offsetof(AK29Power, _powerChargePresentationPowerFadeComponent) == 0x000578, "Member 'AK29Power::_powerChargePresentationPowerFadeComponent' has a wrong offset!");
static_assert(offsetof(AK29Power, _powerStatusHandlerComponentClass) == 0x000580, "Member 'AK29Power::_powerStatusHandlerComponentClass' has a wrong offset!");
static_assert(offsetof(AK29Power, _rushChargesHandlerComponentClass) == 0x000588, "Member 'AK29Power::_rushChargesHandlerComponentClass' has a wrong offset!");
static_assert(offsetof(AK29Power, _pathingCalculatorComponentClass) == 0x000590, "Member 'AK29Power::_pathingCalculatorComponentClass' has a wrong offset!");
static_assert(offsetof(AK29Power, _blindnessProtectionStatusEffectClass) == 0x000598, "Member 'AK29Power::_blindnessProtectionStatusEffectClass' has a wrong offset!");
static_assert(offsetof(AK29Power, _rushChargeTime) == 0x0005A0, "Member 'AK29Power::_rushChargeTime' has a wrong offset!");
static_assert(offsetof(AK29Power, _scorePercent) == 0x000620, "Member 'AK29Power::_scorePercent' has a wrong offset!");
static_assert(offsetof(AK29Power, _moriTentaclesAnimationFollowerActorClass) == 0x0006A8, "Member 'AK29Power::_moriTentaclesAnimationFollowerActorClass' has a wrong offset!");
static_assert(offsetof(AK29Power, _powerStatusHandlerComponent) == 0x0006B8, "Member 'AK29Power::_powerStatusHandlerComponent' has a wrong offset!");
static_assert(offsetof(AK29Power, _rushChargesHandlerComponent) == 0x0006C0, "Member 'AK29Power::_rushChargesHandlerComponent' has a wrong offset!");
static_assert(offsetof(AK29Power, _pathingCalculatorComponent) == 0x0006C8, "Member 'AK29Power::_pathingCalculatorComponent' has a wrong offset!");

// Class TheK29.K29PowerChargePresentationItemProgressComponent
// 0x0018 (0x00D8 - 0x00C0)
class UK29PowerChargePresentationItemProgressComponent final : public UPresentationItemProgressComponent
{
public:
	class UK29PowerStatusHandlerComponent*        _statusHandlerComponent;                           // 0x00C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK29RushChargesHandlerComponent*        _rushChargesHandlerComponent;                      // 0x00C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK29RushChargeableInteraction*          _rushInteraction;                                  // 0x00D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29PowerChargePresentationItemProgressComponent">();
	}
	static class UK29PowerChargePresentationItemProgressComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29PowerChargePresentationItemProgressComponent>();
	}
};
static_assert(alignof(UK29PowerChargePresentationItemProgressComponent) == 0x000008, "Wrong alignment on UK29PowerChargePresentationItemProgressComponent");
static_assert(sizeof(UK29PowerChargePresentationItemProgressComponent) == 0x0000D8, "Wrong size on UK29PowerChargePresentationItemProgressComponent");
static_assert(offsetof(UK29PowerChargePresentationItemProgressComponent, _statusHandlerComponent) == 0x0000C0, "Member 'UK29PowerChargePresentationItemProgressComponent::_statusHandlerComponent' has a wrong offset!");
static_assert(offsetof(UK29PowerChargePresentationItemProgressComponent, _rushChargesHandlerComponent) == 0x0000C8, "Member 'UK29PowerChargePresentationItemProgressComponent::_rushChargesHandlerComponent' has a wrong offset!");
static_assert(offsetof(UK29PowerChargePresentationItemProgressComponent, _rushInteraction) == 0x0000D0, "Member 'UK29PowerChargePresentationItemProgressComponent::_rushInteraction' has a wrong offset!");

// Class TheK29.K29PowerChargePresentationPowerFadeComponent
// 0x0010 (0x00C8 - 0x00B8)
class UK29PowerChargePresentationPowerFadeComponent final : public UPresentationPowerFadeComponent
{
public:
	class UK29RushChargesHandlerComponent*        _rushChargesHandlerComponent;                      // 0x00B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29PowerChargePresentationPowerFadeComponent">();
	}
	static class UK29PowerChargePresentationPowerFadeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29PowerChargePresentationPowerFadeComponent>();
	}
};
static_assert(alignof(UK29PowerChargePresentationPowerFadeComponent) == 0x000008, "Wrong alignment on UK29PowerChargePresentationPowerFadeComponent");
static_assert(sizeof(UK29PowerChargePresentationPowerFadeComponent) == 0x0000C8, "Wrong size on UK29PowerChargePresentationPowerFadeComponent");
static_assert(offsetof(UK29PowerChargePresentationPowerFadeComponent, _rushChargesHandlerComponent) == 0x0000B8, "Member 'UK29PowerChargePresentationPowerFadeComponent::_rushChargesHandlerComponent' has a wrong offset!");

// Class TheK29.K29PowerStatusHandlerComponent
// 0x0368 (0x0420 - 0x00B8)
class UK29PowerStatusHandlerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x30];                                      // 0x00B8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _maxInfectionLevel;                                // 0x00E8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _infectionAddedPerTickWhileActive;                 // 0x0110(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _stabilizingHealAmountByUsage;                     // 0x0190(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _initialInfectionLevel;                            // 0x0198(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _addedInfectionLevelsOnGrab;                       // 0x0218(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _infectionHealingMultiplier;                       // 0x0298(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _infectionIncubationThreshold;                     // 0x0318(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _useInfectionRemoverChargeTime;                    // 0x0340(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _hinderedStatusEffectClass;                        // 0x03C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _gateBlockerStatusEffectClass;                     // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UK29SurvivorThrowableComponent> _survivorThrowableClass;                       // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UChargeableInteractionDefinition> _useInfectionRemoverInteractionSelfClass;    // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UChargeableInteractionDefinition> _useInfectionRemoverInteractionOtherClass;   // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _maxInfectionLevelWhenHooked;                      // 0x03E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _recentlyGrabbedThresholdSeconds;                  // 0x03EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FK29SurvivorStatus>             _survivorStatusList;                               // 0x03F0(0x0010)(Net, ZeroConstructor, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_400[0x20];                                     // 0x0400(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddToTimesCuredByHeal(const class ASurvivor* Survivor);
	void Authority_AddInfectionLevels(const class ASurvivor* Survivor, const int32 infectionToAdd);
	void Authority_HealAllSurvivorsInfectionWithStabilizingSpray();
	void Authority_HealInfectionLevels(const class ASurvivor* Survivor, const int32 infectionLevelsToHeal, const bool shouldSetInfectionActiveToFalse);
	void Authority_OnSlash(class ASurvivor* TargetSurvivor);
	void Authority_OnSurvivorAdded(class ASurvivor* Survivor);
	void Authority_OnSurvivorImmoblizedChanged();
	void Authority_SetAllSurvivorsToInitialInfection();
	void Authority_SetAllSurvivorsToMaxInfection();
	void Authority_UseStabilizingSpray(class ASurvivor* instigatingSurvivor, class ASurvivor* TargetSurvivor);
	void Cosmetic_OnGrabbingInfectedSurvivor();
	void Cosmetic_OnGrabbingNonInfectedSurvivor();
	int32 GetInfectionLevel(const class ASurvivor* Survivor);
	int32 GetMaxInfectionLevel();
	bool IsInfectionIncreasingForSurvivor(const class ASurvivor* Survivor);
	void Multicast_DropSurvivor(class ASurvivor* leftSurvivor);
	void Multicast_GrabSurvivor(class ASurvivor* Survivor, const bool isProcessingInitialInfection);
	void Multicast_ReleaseSurvivor(class ASurvivor* Survivor, bool isForced);
	void Multicast_RemoveSurvivorFromLocker(class ASurvivor* Survivor);
	void Multicast_UseStabilizingSpray(class ASurvivor* TargetSurvivor);
	void OnIntroCompleted();
	void OnRep_SurvivorStatusList(const TArray<struct FK29SurvivorStatus>& oldSurvivorStatus);
	void Server_GrabSurvivor(class ASurvivor* Survivor, const bool isProcessingInitialInfection);
	void Server_ReleaseSurvivor(class ASurvivor* Survivor, bool isForced);

	int32 GetMaxInfectionLevelWhenHooked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29PowerStatusHandlerComponent">();
	}
	static class UK29PowerStatusHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29PowerStatusHandlerComponent>();
	}
};
static_assert(alignof(UK29PowerStatusHandlerComponent) == 0x000008, "Wrong alignment on UK29PowerStatusHandlerComponent");
static_assert(sizeof(UK29PowerStatusHandlerComponent) == 0x000420, "Wrong size on UK29PowerStatusHandlerComponent");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _maxInfectionLevel) == 0x0000E8, "Member 'UK29PowerStatusHandlerComponent::_maxInfectionLevel' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _infectionAddedPerTickWhileActive) == 0x000110, "Member 'UK29PowerStatusHandlerComponent::_infectionAddedPerTickWhileActive' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _stabilizingHealAmountByUsage) == 0x000190, "Member 'UK29PowerStatusHandlerComponent::_stabilizingHealAmountByUsage' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _initialInfectionLevel) == 0x000198, "Member 'UK29PowerStatusHandlerComponent::_initialInfectionLevel' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _addedInfectionLevelsOnGrab) == 0x000218, "Member 'UK29PowerStatusHandlerComponent::_addedInfectionLevelsOnGrab' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _infectionHealingMultiplier) == 0x000298, "Member 'UK29PowerStatusHandlerComponent::_infectionHealingMultiplier' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _infectionIncubationThreshold) == 0x000318, "Member 'UK29PowerStatusHandlerComponent::_infectionIncubationThreshold' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _useInfectionRemoverChargeTime) == 0x000340, "Member 'UK29PowerStatusHandlerComponent::_useInfectionRemoverChargeTime' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _hinderedStatusEffectClass) == 0x0003C0, "Member 'UK29PowerStatusHandlerComponent::_hinderedStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _gateBlockerStatusEffectClass) == 0x0003C8, "Member 'UK29PowerStatusHandlerComponent::_gateBlockerStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _survivorThrowableClass) == 0x0003D0, "Member 'UK29PowerStatusHandlerComponent::_survivorThrowableClass' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _useInfectionRemoverInteractionSelfClass) == 0x0003D8, "Member 'UK29PowerStatusHandlerComponent::_useInfectionRemoverInteractionSelfClass' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _useInfectionRemoverInteractionOtherClass) == 0x0003E0, "Member 'UK29PowerStatusHandlerComponent::_useInfectionRemoverInteractionOtherClass' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _maxInfectionLevelWhenHooked) == 0x0003E8, "Member 'UK29PowerStatusHandlerComponent::_maxInfectionLevelWhenHooked' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _recentlyGrabbedThresholdSeconds) == 0x0003EC, "Member 'UK29PowerStatusHandlerComponent::_recentlyGrabbedThresholdSeconds' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _survivorStatusList) == 0x0003F0, "Member 'UK29PowerStatusHandlerComponent::_survivorStatusList' has a wrong offset!");

// Class TheK29.K29RushChargeableInteraction
// 0x0880 (0x1140 - 0x08C0)
class UK29RushChargeableInteraction final : public UChargeableInteractionDefinition
{
public:
	uint8                                         Pad_8C0[0x10];                                     // 0x08C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UK29RushChargesHandlerComponent*        _rushChargesHandlerComponent;                      // 0x08D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK29PowerStatusHandlerComponent*        _powerStatusHandlerComponent;                      // 0x08D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK29PathingCalculatorComponent*         _pathingCalculatorComponent;                       // 0x08E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AK29Power*                              _powerCollectable;                                 // 0x08E8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EK29RushPhase, struct FK29RushMovementSpeedSetting> _movementSpeedSettingsByState;          // 0x08F0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _subsequentRushTimerTimeoutMovementSpeedMultiplierCurve; // 0x0940(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _subsequentRushTimerTimeoutMovementSpeedReductionDuration; // 0x0948(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _subsequentRushOpportunityTimerDuration;           // 0x09C8(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   _collisionProfileName;                             // 0x0A48(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A54[0x4];                                      // 0x0A54(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTunableStat                           _rushDuration;                                     // 0x0A58(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _rushDurationAfterFirst;                           // 0x0AD8(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _capsuleRadius;                                    // 0x0B58(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _survivorRevealTimeOnInstantPickup;                // 0x0B80(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _capsuleHeight;                                    // 0x0BA8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _capsuleHeightOffset;                              // 0x0BD0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _bounceDuration;                                   // 0x0BF8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _rushAccelerationMultiplier;                       // 0x0C20(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _instantCarryAnimationDuration;                    // 0x0C48(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         _percentageForRushChargeEndAvailability;           // 0x0C70(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _distanceInCmForNearMiss;                          // 0x0C74(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _rushDetectionBackwardsOffset;                     // 0x0C78(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C7C[0x4];                                      // 0x0C7C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _revealToSurvivorsStatusEffect;                    // 0x0C80(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _rushMovementSpeedInCmPerSecond;                   // 0x0C88(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _rushGrabMovementSpeedInCmPerSecond;               // 0x0CB0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _grabRushDuration;                                 // 0x0CD8(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         _rotationStrengthTransitionTime;                   // 0x0D58(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D5C[0x4];                                      // 0x0D5C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _minimumRushDistance;                              // 0x0D60(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _intoGrabbingTime;                                 // 0x0D88(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _smashOutTimerDuration;                            // 0x0DB0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _isStoppingMomentumAtIntoGrabbing;                 // 0x0DD8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _movementSpeedCurveBetweenRushesIncreased;         // 0x0E00(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _movementSpeedCurveChargingIncreased;              // 0x0E08(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _rushMovementSpeedCurve;                           // 0x0E10(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _rushMovementSpeedCurveWithSurvivor;               // 0x0E18(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _killerRushSmashAnimationName;                     // 0x0E20(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _survivorRushSmashAnimationName;                   // 0x0E2C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _killerRushToCarryAnimationName;                   // 0x0E38(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _survivorRushToCarryAnimationName;                 // 0x0E44(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _survivorRushDropAnimationName;                    // 0x0E50(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _killerRushCooldownAnimationName;                  // 0x0E5C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _animTagFPV;                                       // 0x0E68(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _lagInSecondsUntilRushIsInvalid;                   // 0x0E74(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _rushDropForwardDistance;                          // 0x0E78(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _decisiveStrikeSkillCheckDelay;                    // 0x0E7C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isLagChecked;                                     // 0x0E80(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E81[0x7];                                      // 0x0E81(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UInteractionDefinition>> _survivorInteractionPreventingGrab;            // 0x0E88(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_E98[0x2A8];                                    // 0x0E98(0x02A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BounceComplete();
	void Cosmetic_DamageSurvivorAsCollision(class ASurvivor* Survivor, const EHealthState survivorTargetDamageState);
	void Cosmetic_HideEndIndicator();
	void Cosmetic_OnChargeEnd();
	void Cosmetic_OnChargeStart();
	void Cosmetic_OnRushEnd();
	void Cosmetic_OnRushPhaseChanged(EK29RushPhase previousPhase, EK29RushPhase newPhase);
	void Cosmetic_OnRushStart();
	void Cosmetic_OnSlashAtSurvivor(class ASurvivor* Survivor, const EHealthState survivorTargetDamageState);
	void Cosmetic_ShowEndIndicator(const struct FVector& endIndicatorLocation, const struct FRotator& forwardRotation);
	void Multicast_CancelInteraction();
	void Multicast_CarrySurvivor(class ASurvivor* survivorToCarry);
	void Multicast_ChangeRushPhase(const EK29RushPhase newRushPhase, const bool forceLocallyControlled);
	void Multicast_DamageSurvivorAsCollision(const struct FVector& currentKillerPosition, class ASurvivor* collidedSurvivor, const EHealthState survivorTargetDamageState);
	void Multicast_DestroyPalletOrBreakable(class AActor* destroyable);
	void Multicast_RushInvalid();
	void Multicast_RushValid();
	void Multicast_SetCurrentRush(const struct FK29GuidedMovementInstance& newRushInstance);
	void Multicast_SetCurrentRushAsEndingAtLedge();
	void Multicast_SetCurrentRushAsEndingInCollision();
	void Multicast_SlashAtSurvivor(class ASurvivor* Survivor, const struct FVector& currentKillerPosition, const EHealthState survivorTargetDamageState);
	void Multicast_SmashSurvivor(class ASurvivor* survivorToCarry);
	void OnCollisionEnableTimerComplete();
	void OnGrabbingTransitionComplete();
	void OnInstantCarryTimerComplete(class ASurvivor* survivorToCarry);
	void OnSmashOutTimerCompleted();
	void OnSubsequentRushOpportunityTimeout();
	void OnWindowOfOpportunityTimeoutCooldownEnd();
	void RushComplete(const bool rushEndedNaturally);
	void Server_CancelInteraction();
	void Server_ChangeRushPhase(const EK29RushPhase newRushPhase, const float clientTimeStamp, const bool forceLocallyControlled);
	void Server_DamageSurvivorAsCollision(class ASurvivor* Survivor, const struct FVector& currentKillerPosition);
	void Server_DestroyPalletOrBreakable(class AActor* destroyable);
	void Server_SetCurrentRush(const struct FK29GuidedMovementInstance& newRushInstance, const EK29RushPhase targetPhase);
	void Server_SetCurrentRushAsEndingAtLedge();
	void Server_SetCurrentRushAsEndingInCollision(bool hitOtherSurvivor);
	void Server_SlashAtSurvivor(class ASurvivor* Survivor, const struct FVector& currentKillerPosition);

	float GetRushTimeLeft() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29RushChargeableInteraction">();
	}
	static class UK29RushChargeableInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29RushChargeableInteraction>();
	}
};
static_assert(alignof(UK29RushChargeableInteraction) == 0x000010, "Wrong alignment on UK29RushChargeableInteraction");
static_assert(sizeof(UK29RushChargeableInteraction) == 0x001140, "Wrong size on UK29RushChargeableInteraction");
static_assert(offsetof(UK29RushChargeableInteraction, _rushChargesHandlerComponent) == 0x0008D0, "Member 'UK29RushChargeableInteraction::_rushChargesHandlerComponent' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _powerStatusHandlerComponent) == 0x0008D8, "Member 'UK29RushChargeableInteraction::_powerStatusHandlerComponent' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _pathingCalculatorComponent) == 0x0008E0, "Member 'UK29RushChargeableInteraction::_pathingCalculatorComponent' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _powerCollectable) == 0x0008E8, "Member 'UK29RushChargeableInteraction::_powerCollectable' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _movementSpeedSettingsByState) == 0x0008F0, "Member 'UK29RushChargeableInteraction::_movementSpeedSettingsByState' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _subsequentRushTimerTimeoutMovementSpeedMultiplierCurve) == 0x000940, "Member 'UK29RushChargeableInteraction::_subsequentRushTimerTimeoutMovementSpeedMultiplierCurve' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _subsequentRushTimerTimeoutMovementSpeedReductionDuration) == 0x000948, "Member 'UK29RushChargeableInteraction::_subsequentRushTimerTimeoutMovementSpeedReductionDuration' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _subsequentRushOpportunityTimerDuration) == 0x0009C8, "Member 'UK29RushChargeableInteraction::_subsequentRushOpportunityTimerDuration' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _collisionProfileName) == 0x000A48, "Member 'UK29RushChargeableInteraction::_collisionProfileName' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _rushDuration) == 0x000A58, "Member 'UK29RushChargeableInteraction::_rushDuration' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _rushDurationAfterFirst) == 0x000AD8, "Member 'UK29RushChargeableInteraction::_rushDurationAfterFirst' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _capsuleRadius) == 0x000B58, "Member 'UK29RushChargeableInteraction::_capsuleRadius' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _survivorRevealTimeOnInstantPickup) == 0x000B80, "Member 'UK29RushChargeableInteraction::_survivorRevealTimeOnInstantPickup' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _capsuleHeight) == 0x000BA8, "Member 'UK29RushChargeableInteraction::_capsuleHeight' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _capsuleHeightOffset) == 0x000BD0, "Member 'UK29RushChargeableInteraction::_capsuleHeightOffset' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _bounceDuration) == 0x000BF8, "Member 'UK29RushChargeableInteraction::_bounceDuration' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _rushAccelerationMultiplier) == 0x000C20, "Member 'UK29RushChargeableInteraction::_rushAccelerationMultiplier' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _instantCarryAnimationDuration) == 0x000C48, "Member 'UK29RushChargeableInteraction::_instantCarryAnimationDuration' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _percentageForRushChargeEndAvailability) == 0x000C70, "Member 'UK29RushChargeableInteraction::_percentageForRushChargeEndAvailability' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _distanceInCmForNearMiss) == 0x000C74, "Member 'UK29RushChargeableInteraction::_distanceInCmForNearMiss' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _rushDetectionBackwardsOffset) == 0x000C78, "Member 'UK29RushChargeableInteraction::_rushDetectionBackwardsOffset' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _revealToSurvivorsStatusEffect) == 0x000C80, "Member 'UK29RushChargeableInteraction::_revealToSurvivorsStatusEffect' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _rushMovementSpeedInCmPerSecond) == 0x000C88, "Member 'UK29RushChargeableInteraction::_rushMovementSpeedInCmPerSecond' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _rushGrabMovementSpeedInCmPerSecond) == 0x000CB0, "Member 'UK29RushChargeableInteraction::_rushGrabMovementSpeedInCmPerSecond' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _grabRushDuration) == 0x000CD8, "Member 'UK29RushChargeableInteraction::_grabRushDuration' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _rotationStrengthTransitionTime) == 0x000D58, "Member 'UK29RushChargeableInteraction::_rotationStrengthTransitionTime' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _minimumRushDistance) == 0x000D60, "Member 'UK29RushChargeableInteraction::_minimumRushDistance' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _intoGrabbingTime) == 0x000D88, "Member 'UK29RushChargeableInteraction::_intoGrabbingTime' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _smashOutTimerDuration) == 0x000DB0, "Member 'UK29RushChargeableInteraction::_smashOutTimerDuration' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _isStoppingMomentumAtIntoGrabbing) == 0x000DD8, "Member 'UK29RushChargeableInteraction::_isStoppingMomentumAtIntoGrabbing' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _movementSpeedCurveBetweenRushesIncreased) == 0x000E00, "Member 'UK29RushChargeableInteraction::_movementSpeedCurveBetweenRushesIncreased' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _movementSpeedCurveChargingIncreased) == 0x000E08, "Member 'UK29RushChargeableInteraction::_movementSpeedCurveChargingIncreased' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _rushMovementSpeedCurve) == 0x000E10, "Member 'UK29RushChargeableInteraction::_rushMovementSpeedCurve' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _rushMovementSpeedCurveWithSurvivor) == 0x000E18, "Member 'UK29RushChargeableInteraction::_rushMovementSpeedCurveWithSurvivor' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _killerRushSmashAnimationName) == 0x000E20, "Member 'UK29RushChargeableInteraction::_killerRushSmashAnimationName' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _survivorRushSmashAnimationName) == 0x000E2C, "Member 'UK29RushChargeableInteraction::_survivorRushSmashAnimationName' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _killerRushToCarryAnimationName) == 0x000E38, "Member 'UK29RushChargeableInteraction::_killerRushToCarryAnimationName' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _survivorRushToCarryAnimationName) == 0x000E44, "Member 'UK29RushChargeableInteraction::_survivorRushToCarryAnimationName' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _survivorRushDropAnimationName) == 0x000E50, "Member 'UK29RushChargeableInteraction::_survivorRushDropAnimationName' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _killerRushCooldownAnimationName) == 0x000E5C, "Member 'UK29RushChargeableInteraction::_killerRushCooldownAnimationName' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _animTagFPV) == 0x000E68, "Member 'UK29RushChargeableInteraction::_animTagFPV' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _lagInSecondsUntilRushIsInvalid) == 0x000E74, "Member 'UK29RushChargeableInteraction::_lagInSecondsUntilRushIsInvalid' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _rushDropForwardDistance) == 0x000E78, "Member 'UK29RushChargeableInteraction::_rushDropForwardDistance' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _decisiveStrikeSkillCheckDelay) == 0x000E7C, "Member 'UK29RushChargeableInteraction::_decisiveStrikeSkillCheckDelay' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _isLagChecked) == 0x000E80, "Member 'UK29RushChargeableInteraction::_isLagChecked' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _survivorInteractionPreventingGrab) == 0x000E88, "Member 'UK29RushChargeableInteraction::_survivorInteractionPreventingGrab' has a wrong offset!");

// Class TheK29.K29RushChargesHandlerComponent
// 0x0178 (0x0230 - 0x00B8)
class UK29RushChargesHandlerComponent final : public UActorComponent
{
public:
	struct FTunableStat                           _maximumRushCharges;                               // 0x00B8(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _rechargeTimeByChargesLeft;                        // 0x0138(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _rechargeDurationMultiplier;                       // 0x0140(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _reducedChargeTimePerInfectionPlayers;             // 0x01C0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E8[0x48];                                     // 0x01E8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddSingleCharge();
	void Cosmetic_OnOutOfRushCharges();
	void Cosmetic_OnRushChargeAdded();
	void OnMaximumChargesChanged(const float NewValue);
	void SetToFullCharge();

	int32 GetAvailableCharges() const;
	class AKiller* GetKiller() const;
	int32 GetMaximumCharges() const;
	float GetPercentageRemainingUntilNextCharge() const;
	float GetRechargeDuration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29RushChargesHandlerComponent">();
	}
	static class UK29RushChargesHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29RushChargesHandlerComponent>();
	}
};
static_assert(alignof(UK29RushChargesHandlerComponent) == 0x000008, "Wrong alignment on UK29RushChargesHandlerComponent");
static_assert(sizeof(UK29RushChargesHandlerComponent) == 0x000230, "Wrong size on UK29RushChargesHandlerComponent");
static_assert(offsetof(UK29RushChargesHandlerComponent, _maximumRushCharges) == 0x0000B8, "Member 'UK29RushChargesHandlerComponent::_maximumRushCharges' has a wrong offset!");
static_assert(offsetof(UK29RushChargesHandlerComponent, _rechargeTimeByChargesLeft) == 0x000138, "Member 'UK29RushChargesHandlerComponent::_rechargeTimeByChargesLeft' has a wrong offset!");
static_assert(offsetof(UK29RushChargesHandlerComponent, _rechargeDurationMultiplier) == 0x000140, "Member 'UK29RushChargesHandlerComponent::_rechargeDurationMultiplier' has a wrong offset!");
static_assert(offsetof(UK29RushChargesHandlerComponent, _reducedChargeTimePerInfectionPlayers) == 0x0001C0, "Member 'UK29RushChargesHandlerComponent::_reducedChargeTimePerInfectionPlayers' has a wrong offset!");

// Class TheK29.K29RushCooldownInteraction
// 0x00E0 (0x0850 - 0x0770)
class UK29RushCooldownInteraction final : public UInteractionDefinition
{
public:
	struct FTunableStat                           _cooldownTime;                                     // 0x0768(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          _isCameraRestrictedForDuration;                    // 0x07E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7E9[0x7];                                      // 0x07E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _cameraRestrictionTime;                            // 0x07F0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_818[0x38];                                     // 0x0818(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ResetCameraInputLimit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29RushCooldownInteraction">();
	}
	static class UK29RushCooldownInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29RushCooldownInteraction>();
	}
};
static_assert(alignof(UK29RushCooldownInteraction) == 0x000010, "Wrong alignment on UK29RushCooldownInteraction");
static_assert(sizeof(UK29RushCooldownInteraction) == 0x000850, "Wrong size on UK29RushCooldownInteraction");
static_assert(offsetof(UK29RushCooldownInteraction, _cooldownTime) == 0x000768, "Member 'UK29RushCooldownInteraction::_cooldownTime' has a wrong offset!");
static_assert(offsetof(UK29RushCooldownInteraction, _isCameraRestrictedForDuration) == 0x0007E8, "Member 'UK29RushCooldownInteraction::_isCameraRestrictedForDuration' has a wrong offset!");
static_assert(offsetof(UK29RushCooldownInteraction, _cameraRestrictionTime) == 0x0007F0, "Member 'UK29RushCooldownInteraction::_cameraRestrictionTime' has a wrong offset!");

// Class TheK29.K29SicknessSurvivorAnimInstance
// 0x0030 (0x0610 - 0x05E0)
class UK29SicknessSurvivorAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	uint8                                         Pad_5E0[0x8];                                      // 0x05E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isInfectionActive;                                // 0x05E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCoughing;                                       // 0x05E9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5EA[0x2];                                      // 0x05EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _timeBetweenRandomCoughingTry;                     // 0x05EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _randomCoughMinProbabilityRange;                   // 0x05F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _randomCoughMaxProbabilityRange;                   // 0x05F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _randomCoughProbabilityThreshold;                  // 0x05F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrawling;                                       // 0x05FC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInsideLocker;                                   // 0x05FD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDead;                                           // 0x05FE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInteracting;                                    // 0x05FF(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInjured;                                        // 0x0600(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHoldingObject;                                  // 0x0601(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrouched;                                       // 0x0602(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHooked;                                         // 0x0603(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIdle;                                           // 0x0604(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isUsingAimItem;                                   // 0x0605(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInAir;                                          // 0x0606(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingHealed;                                    // 0x0607(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_608[0x8];                                      // 0x0608(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29SicknessSurvivorAnimInstance">();
	}
	static class UK29SicknessSurvivorAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29SicknessSurvivorAnimInstance>();
	}
};
static_assert(alignof(UK29SicknessSurvivorAnimInstance) == 0x000010, "Wrong alignment on UK29SicknessSurvivorAnimInstance");
static_assert(sizeof(UK29SicknessSurvivorAnimInstance) == 0x000610, "Wrong size on UK29SicknessSurvivorAnimInstance");
static_assert(offsetof(UK29SicknessSurvivorAnimInstance, _isInfectionActive) == 0x0005E8, "Member 'UK29SicknessSurvivorAnimInstance::_isInfectionActive' has a wrong offset!");
static_assert(offsetof(UK29SicknessSurvivorAnimInstance, _isCoughing) == 0x0005E9, "Member 'UK29SicknessSurvivorAnimInstance::_isCoughing' has a wrong offset!");
static_assert(offsetof(UK29SicknessSurvivorAnimInstance, _timeBetweenRandomCoughingTry) == 0x0005EC, "Member 'UK29SicknessSurvivorAnimInstance::_timeBetweenRandomCoughingTry' has a wrong offset!");
static_assert(offsetof(UK29SicknessSurvivorAnimInstance, _randomCoughMinProbabilityRange) == 0x0005F0, "Member 'UK29SicknessSurvivorAnimInstance::_randomCoughMinProbabilityRange' has a wrong offset!");
static_assert(offsetof(UK29SicknessSurvivorAnimInstance, _randomCoughMaxProbabilityRange) == 0x0005F4, "Member 'UK29SicknessSurvivorAnimInstance::_randomCoughMaxProbabilityRange' has a wrong offset!");
static_assert(offsetof(UK29SicknessSurvivorAnimInstance, _randomCoughProbabilityThreshold) == 0x0005F8, "Member 'UK29SicknessSurvivorAnimInstance::_randomCoughProbabilityThreshold' has a wrong offset!");
static_assert(offsetof(UK29SicknessSurvivorAnimInstance, _isCrawling) == 0x0005FC, "Member 'UK29SicknessSurvivorAnimInstance::_isCrawling' has a wrong offset!");
static_assert(offsetof(UK29SicknessSurvivorAnimInstance, _isInsideLocker) == 0x0005FD, "Member 'UK29SicknessSurvivorAnimInstance::_isInsideLocker' has a wrong offset!");
static_assert(offsetof(UK29SicknessSurvivorAnimInstance, _isDead) == 0x0005FE, "Member 'UK29SicknessSurvivorAnimInstance::_isDead' has a wrong offset!");
static_assert(offsetof(UK29SicknessSurvivorAnimInstance, _isInteracting) == 0x0005FF, "Member 'UK29SicknessSurvivorAnimInstance::_isInteracting' has a wrong offset!");
static_assert(offsetof(UK29SicknessSurvivorAnimInstance, _isInjured) == 0x000600, "Member 'UK29SicknessSurvivorAnimInstance::_isInjured' has a wrong offset!");
static_assert(offsetof(UK29SicknessSurvivorAnimInstance, _isHoldingObject) == 0x000601, "Member 'UK29SicknessSurvivorAnimInstance::_isHoldingObject' has a wrong offset!");
static_assert(offsetof(UK29SicknessSurvivorAnimInstance, _isCrouched) == 0x000602, "Member 'UK29SicknessSurvivorAnimInstance::_isCrouched' has a wrong offset!");
static_assert(offsetof(UK29SicknessSurvivorAnimInstance, _isHooked) == 0x000603, "Member 'UK29SicknessSurvivorAnimInstance::_isHooked' has a wrong offset!");
static_assert(offsetof(UK29SicknessSurvivorAnimInstance, _isIdle) == 0x000604, "Member 'UK29SicknessSurvivorAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(UK29SicknessSurvivorAnimInstance, _isUsingAimItem) == 0x000605, "Member 'UK29SicknessSurvivorAnimInstance::_isUsingAimItem' has a wrong offset!");
static_assert(offsetof(UK29SicknessSurvivorAnimInstance, _isInAir) == 0x000606, "Member 'UK29SicknessSurvivorAnimInstance::_isInAir' has a wrong offset!");
static_assert(offsetof(UK29SicknessSurvivorAnimInstance, _isBeingHealed) == 0x000607, "Member 'UK29SicknessSurvivorAnimInstance::_isBeingHealed' has a wrong offset!");

// Class TheK29.K29SupplyCrateOutlineUpdateStrategy
// 0x0000 (0x0100 - 0x0100)
class UK29SupplyCrateOutlineUpdateStrategy final : public UDefaultOutlineUpdateStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29SupplyCrateOutlineUpdateStrategy">();
	}
	static class UK29SupplyCrateOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29SupplyCrateOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UK29SupplyCrateOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UK29SupplyCrateOutlineUpdateStrategy");
static_assert(sizeof(UK29SupplyCrateOutlineUpdateStrategy) == 0x000100, "Wrong size on UK29SupplyCrateOutlineUpdateStrategy");

// Class TheK29.K29SurvivorAnimInstance
// 0x0040 (0x0620 - 0x05E0)
class UK29SurvivorAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	uint8                                         Pad_5E0[0x8];                                      // 0x05E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isBeingGrabbed;                                   // 0x05E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingThrown;                                    // 0x05E9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isKillerLocallyControlled;                        // 0x05EA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isUsingInfectionRemoverOnSelf;                    // 0x05EB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isUsingInfectionRemoverOnOther;                   // 0x05EC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInfectionRemoverUsedOnSelf;                     // 0x05ED(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasLastThrowResultedInDamage;                     // 0x05EE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasBeenThrown;                                    // 0x05EF(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrawling;                                       // 0x05F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInsideLocker;                                   // 0x05F1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDead;                                           // 0x05F2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInteracting;                                    // 0x05F3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInjured;                                        // 0x05F4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHoldingObject;                                  // 0x05F5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrouched;                                       // 0x05F6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHooked;                                         // 0x05F7(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIdle;                                           // 0x05F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isUsingAimItem;                                   // 0x05F9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInAir;                                          // 0x05FA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingHealed;                                    // 0x05FB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5FC[0x24];                                     // 0x05FC(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameEventReceived(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData);
	void OnHasBeenThrown();
	void ResetHasBeenThrown();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29SurvivorAnimInstance">();
	}
	static class UK29SurvivorAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29SurvivorAnimInstance>();
	}
};
static_assert(alignof(UK29SurvivorAnimInstance) == 0x000010, "Wrong alignment on UK29SurvivorAnimInstance");
static_assert(sizeof(UK29SurvivorAnimInstance) == 0x000620, "Wrong size on UK29SurvivorAnimInstance");
static_assert(offsetof(UK29SurvivorAnimInstance, _isBeingGrabbed) == 0x0005E8, "Member 'UK29SurvivorAnimInstance::_isBeingGrabbed' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isBeingThrown) == 0x0005E9, "Member 'UK29SurvivorAnimInstance::_isBeingThrown' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isKillerLocallyControlled) == 0x0005EA, "Member 'UK29SurvivorAnimInstance::_isKillerLocallyControlled' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isUsingInfectionRemoverOnSelf) == 0x0005EB, "Member 'UK29SurvivorAnimInstance::_isUsingInfectionRemoverOnSelf' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isUsingInfectionRemoverOnOther) == 0x0005EC, "Member 'UK29SurvivorAnimInstance::_isUsingInfectionRemoverOnOther' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isInfectionRemoverUsedOnSelf) == 0x0005ED, "Member 'UK29SurvivorAnimInstance::_isInfectionRemoverUsedOnSelf' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _hasLastThrowResultedInDamage) == 0x0005EE, "Member 'UK29SurvivorAnimInstance::_hasLastThrowResultedInDamage' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _hasBeenThrown) == 0x0005EF, "Member 'UK29SurvivorAnimInstance::_hasBeenThrown' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isCrawling) == 0x0005F0, "Member 'UK29SurvivorAnimInstance::_isCrawling' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isInsideLocker) == 0x0005F1, "Member 'UK29SurvivorAnimInstance::_isInsideLocker' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isDead) == 0x0005F2, "Member 'UK29SurvivorAnimInstance::_isDead' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isInteracting) == 0x0005F3, "Member 'UK29SurvivorAnimInstance::_isInteracting' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isInjured) == 0x0005F4, "Member 'UK29SurvivorAnimInstance::_isInjured' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isHoldingObject) == 0x0005F5, "Member 'UK29SurvivorAnimInstance::_isHoldingObject' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isCrouched) == 0x0005F6, "Member 'UK29SurvivorAnimInstance::_isCrouched' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isHooked) == 0x0005F7, "Member 'UK29SurvivorAnimInstance::_isHooked' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isIdle) == 0x0005F8, "Member 'UK29SurvivorAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isUsingAimItem) == 0x0005F9, "Member 'UK29SurvivorAnimInstance::_isUsingAimItem' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isInAir) == 0x0005FA, "Member 'UK29SurvivorAnimInstance::_isInAir' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isBeingHealed) == 0x0005FB, "Member 'UK29SurvivorAnimInstance::_isBeingHealed' has a wrong offset!");

// Class TheK29.K29SurvivorCarriableComponent
// 0x0090 (0x0148 - 0x00B8)
class UK29SurvivorCarriableComponent final : public UActorComponent
{
public:
	class FName                                   _rootJointName;                                    // 0x00B8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               _startingRotation;                                 // 0x00C8(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                _startingPosition;                                 // 0x00E0(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isCarriedByK29Rush;                               // 0x00F8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _killerIngoreTime;                                 // 0x00FC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ASurvivor>               _owningSurvivor;                                   // 0x0100(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AKiller>                 _killer;                                           // 0x0108(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x38];                                     // 0x0110(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsBeingCarriedByK29RushOrMarkedForThrow();
	void OnRep_OwningSurvivor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29SurvivorCarriableComponent">();
	}
	static class UK29SurvivorCarriableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29SurvivorCarriableComponent>();
	}
};
static_assert(alignof(UK29SurvivorCarriableComponent) == 0x000008, "Wrong alignment on UK29SurvivorCarriableComponent");
static_assert(sizeof(UK29SurvivorCarriableComponent) == 0x000148, "Wrong size on UK29SurvivorCarriableComponent");
static_assert(offsetof(UK29SurvivorCarriableComponent, _rootJointName) == 0x0000B8, "Member 'UK29SurvivorCarriableComponent::_rootJointName' has a wrong offset!");
static_assert(offsetof(UK29SurvivorCarriableComponent, _startingRotation) == 0x0000C8, "Member 'UK29SurvivorCarriableComponent::_startingRotation' has a wrong offset!");
static_assert(offsetof(UK29SurvivorCarriableComponent, _startingPosition) == 0x0000E0, "Member 'UK29SurvivorCarriableComponent::_startingPosition' has a wrong offset!");
static_assert(offsetof(UK29SurvivorCarriableComponent, _isCarriedByK29Rush) == 0x0000F8, "Member 'UK29SurvivorCarriableComponent::_isCarriedByK29Rush' has a wrong offset!");
static_assert(offsetof(UK29SurvivorCarriableComponent, _killerIngoreTime) == 0x0000FC, "Member 'UK29SurvivorCarriableComponent::_killerIngoreTime' has a wrong offset!");
static_assert(offsetof(UK29SurvivorCarriableComponent, _owningSurvivor) == 0x000100, "Member 'UK29SurvivorCarriableComponent::_owningSurvivor' has a wrong offset!");
static_assert(offsetof(UK29SurvivorCarriableComponent, _killer) == 0x000108, "Member 'UK29SurvivorCarriableComponent::_killer' has a wrong offset!");

// Class TheK29.K29SurvivorCosmeticHelperActor
// 0x00C0 (0x0418 - 0x0358)
class AK29SurvivorCosmeticHelperActor final : public ASurvivorCosmeticHelperActor
{
public:
	uint8                                         Pad_358[0xC0];                                     // 0x0358(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_GrabbedByKiller();
	void Cosmetic_IsInfectedActiveChanged(const bool IsInfectionActive_0);
	void Cosmetic_IsInfectedChanged(const bool IsInfected_0);
	void Cosmetic_IsInfectionCriticalChanged(const bool IsInfectionCritical_0);
	void Cosmetic_IsInfectionIncubatedChanged(const bool IsInfectionIncubated_0);
	void Cosmetic_OnInfectionLevelsChanged(const bool IsActive);
	void Cosmetic_OnInfectionRemovalCollectableUsed();
	void Cosmetic_OnLocallyObservedChanged();
	void Cosmetic_OnOwningSurvivorDied();
	void Cosmetic_OnOwningSurvivorHitCollisionWithRush();
	void OnInfectionLevelsChanged(class ASurvivor* TargetSurvivor, bool IsActive);
	void OnInfectionRemovalCollectableUsed(class ASurvivor* Survivor);
	void OnLevelReadyToPlay();
	void OnOwnerLocallyObserved(bool locallyObserved);
	void OnSurvivorDisguisedOrUndisguised(bool isDisguised);
	void OnSurvivorGrabbed(class ASurvivor* Survivor);

	int32 GetCurrentInfectionLevels() const;
	float GetCurrentInfectionPercentage() const;
	int32 GetMaximumInfectionLevels() const;
	bool IsInfected() const;
	bool IsInfectionActive() const;
	bool IsInfectionCritical() const;
	bool IsInfectionIncubated() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29SurvivorCosmeticHelperActor">();
	}
	static class AK29SurvivorCosmeticHelperActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK29SurvivorCosmeticHelperActor>();
	}
};
static_assert(alignof(AK29SurvivorCosmeticHelperActor) == 0x000008, "Wrong alignment on AK29SurvivorCosmeticHelperActor");
static_assert(sizeof(AK29SurvivorCosmeticHelperActor) == 0x000418, "Wrong size on AK29SurvivorCosmeticHelperActor");

// Class TheK29.K29SurvivorStatusComponent
// 0x0018 (0x00D0 - 0x00B8)
class UK29SurvivorStatusComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UK29PowerStatusHandlerComponent> _powerStatusHandlerComponent;              // 0x00C0(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ASurvivor>               _owningSurvivor;                                   // 0x00C8(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29SurvivorStatusComponent">();
	}
	static class UK29SurvivorStatusComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29SurvivorStatusComponent>();
	}
};
static_assert(alignof(UK29SurvivorStatusComponent) == 0x000008, "Wrong alignment on UK29SurvivorStatusComponent");
static_assert(sizeof(UK29SurvivorStatusComponent) == 0x0000D0, "Wrong size on UK29SurvivorStatusComponent");
static_assert(offsetof(UK29SurvivorStatusComponent, _powerStatusHandlerComponent) == 0x0000C0, "Member 'UK29SurvivorStatusComponent::_powerStatusHandlerComponent' has a wrong offset!");
static_assert(offsetof(UK29SurvivorStatusComponent, _owningSurvivor) == 0x0000C8, "Member 'UK29SurvivorStatusComponent::_owningSurvivor' has a wrong offset!");

// Class TheK29.K29SurvivorThrowableComponent
// 0x0390 (0x0448 - 0x00B8)
class UK29SurvivorThrowableComponent final : public UActorComponent
{
public:
	struct FTunableStat                           _throwDuration;                                    // 0x00B8(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _capsuleRadius;                                    // 0x0138(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _capsuleHeight;                                    // 0x0160(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _capsuleHeightOffset;                              // 0x0188(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _minimumThrowDistance;                             // 0x01B0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _throwMovementSpeedInCmPerSecond;                  // 0x01D8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _movingDelay;                                      // 0x0200(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _throwDelay;                                       // 0x0228(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _throwLedgeDropDistance;                           // 0x0250(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _throwLedgeDropTime;                               // 0x0278(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _throwMovementSpeedMultiplierCurve;                // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _throwAccelerationMultiplier;                      // 0x02A8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D0[0x178];                                    // 0x02D0(0x0178)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnSurvivorUsedAsCollision(class ASurvivor* Survivor);
	void EndThrow();
	void Multicast_CancelThrowOnOtherSurvivorCollision(const struct FVector& collisionPosition, class ASurvivor* survivorUsedAsCollision);
	void Multicast_EndThrow();
	void Multicast_InstantlyLetGoSurvivor(const bool hasDealtDamage);
	void Multicast_SetCurrentThrow(const struct FK29GuidedMovementInstance& throwInstance, class ASurvivor* thrownSurvivor);
	void OnThrowTimeout();
	void OnWalkingAllowedAfterFall();
	void Server_CancelThrowOnOtherSurvivorCollision(const struct FVector& collisionPosition, class ASurvivor* survivorUsedAsCollision);
	void Server_EndThrow();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29SurvivorThrowableComponent">();
	}
	static class UK29SurvivorThrowableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29SurvivorThrowableComponent>();
	}
};
static_assert(alignof(UK29SurvivorThrowableComponent) == 0x000008, "Wrong alignment on UK29SurvivorThrowableComponent");
static_assert(sizeof(UK29SurvivorThrowableComponent) == 0x000448, "Wrong size on UK29SurvivorThrowableComponent");
static_assert(offsetof(UK29SurvivorThrowableComponent, _throwDuration) == 0x0000B8, "Member 'UK29SurvivorThrowableComponent::_throwDuration' has a wrong offset!");
static_assert(offsetof(UK29SurvivorThrowableComponent, _capsuleRadius) == 0x000138, "Member 'UK29SurvivorThrowableComponent::_capsuleRadius' has a wrong offset!");
static_assert(offsetof(UK29SurvivorThrowableComponent, _capsuleHeight) == 0x000160, "Member 'UK29SurvivorThrowableComponent::_capsuleHeight' has a wrong offset!");
static_assert(offsetof(UK29SurvivorThrowableComponent, _capsuleHeightOffset) == 0x000188, "Member 'UK29SurvivorThrowableComponent::_capsuleHeightOffset' has a wrong offset!");
static_assert(offsetof(UK29SurvivorThrowableComponent, _minimumThrowDistance) == 0x0001B0, "Member 'UK29SurvivorThrowableComponent::_minimumThrowDistance' has a wrong offset!");
static_assert(offsetof(UK29SurvivorThrowableComponent, _throwMovementSpeedInCmPerSecond) == 0x0001D8, "Member 'UK29SurvivorThrowableComponent::_throwMovementSpeedInCmPerSecond' has a wrong offset!");
static_assert(offsetof(UK29SurvivorThrowableComponent, _movingDelay) == 0x000200, "Member 'UK29SurvivorThrowableComponent::_movingDelay' has a wrong offset!");
static_assert(offsetof(UK29SurvivorThrowableComponent, _throwDelay) == 0x000228, "Member 'UK29SurvivorThrowableComponent::_throwDelay' has a wrong offset!");
static_assert(offsetof(UK29SurvivorThrowableComponent, _throwLedgeDropDistance) == 0x000250, "Member 'UK29SurvivorThrowableComponent::_throwLedgeDropDistance' has a wrong offset!");
static_assert(offsetof(UK29SurvivorThrowableComponent, _throwLedgeDropTime) == 0x000278, "Member 'UK29SurvivorThrowableComponent::_throwLedgeDropTime' has a wrong offset!");
static_assert(offsetof(UK29SurvivorThrowableComponent, _throwMovementSpeedMultiplierCurve) == 0x0002A0, "Member 'UK29SurvivorThrowableComponent::_throwMovementSpeedMultiplierCurve' has a wrong offset!");
static_assert(offsetof(UK29SurvivorThrowableComponent, _throwAccelerationMultiplier) == 0x0002A8, "Member 'UK29SurvivorThrowableComponent::_throwAccelerationMultiplier' has a wrong offset!");

// Class TheK29.K29UseInfectionRemoverInteraction
// 0x0000 (0x08E0 - 0x08E0)
class UK29UseInfectionRemoverInteraction : public UUseContaminationAntidoteInteraction
{
public:
	void OnSurvivorCured_Cosmetic();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29UseInfectionRemoverInteraction">();
	}
	static class UK29UseInfectionRemoverInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29UseInfectionRemoverInteraction>();
	}
};
static_assert(alignof(UK29UseInfectionRemoverInteraction) == 0x000010, "Wrong alignment on UK29UseInfectionRemoverInteraction");
static_assert(sizeof(UK29UseInfectionRemoverInteraction) == 0x0008E0, "Wrong size on UK29UseInfectionRemoverInteraction");

// Class TheK29.K29UseInfectionRemoverInteractionOther
// 0x0000 (0x08E0 - 0x08E0)
class UK29UseInfectionRemoverInteractionOther final : public UK29UseInfectionRemoverInteraction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29UseInfectionRemoverInteractionOther">();
	}
	static class UK29UseInfectionRemoverInteractionOther* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29UseInfectionRemoverInteractionOther>();
	}
};
static_assert(alignof(UK29UseInfectionRemoverInteractionOther) == 0x000010, "Wrong alignment on UK29UseInfectionRemoverInteractionOther");
static_assert(sizeof(UK29UseInfectionRemoverInteractionOther) == 0x0008E0, "Wrong size on UK29UseInfectionRemoverInteractionOther");

// Class TheK29.K29UseInfectionRemoverInteractionSelf
// 0x0000 (0x08E0 - 0x08E0)
class UK29UseInfectionRemoverInteractionSelf final : public UK29UseInfectionRemoverInteraction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29UseInfectionRemoverInteractionSelf">();
	}
	static class UK29UseInfectionRemoverInteractionSelf* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29UseInfectionRemoverInteractionSelf>();
	}
};
static_assert(alignof(UK29UseInfectionRemoverInteractionSelf) == 0x000010, "Wrong alignment on UK29UseInfectionRemoverInteractionSelf");
static_assert(sizeof(UK29UseInfectionRemoverInteractionSelf) == 0x0008E0, "Wrong size on UK29UseInfectionRemoverInteractionSelf");

// Class TheK29.K29Utilities
// 0x0000 (0x0030 - 0x0030)
class UK29Utilities final : public UBlueprintFunctionLibrary
{
public:
	static class AK29Power* GetK29Power(const class UObject* WorldContextObject);
	static bool IsSurvivorAbleToBeAffectedByPower(const class AActor* survivorAsActor, const class AKiller* Killer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29Utilities">();
	}
	static class UK29Utilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29Utilities>();
	}
};
static_assert(alignof(UK29Utilities) == 0x000008, "Wrong alignment on UK29Utilities");
static_assert(sizeof(UK29Utilities) == 0x000030, "Wrong size on UK29Utilities");

}

