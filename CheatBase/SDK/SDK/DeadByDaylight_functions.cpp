#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DeadByDaylight

#include "Basic.hpp"

#include "DeadByDaylight_classes.hpp"
#include "DeadByDaylight_parameters.hpp"


namespace SDK
{

// Function DeadByDaylight.SeanceRitualOutlineUpdateStrategy.GetRevealColorToSurvivor
// (Final, Native, Public, HasDefaults, Const)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor USeanceRitualOutlineUpdateStrategy::GetRevealColorToSurvivor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeanceRitualOutlineUpdateStrategy", "GetRevealColorToSurvivor");

	Params::SeanceRitualOutlineUpdateStrategy_GetRevealColorToSurvivor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AICharacterBehaviour.Pause
// (Native, Public)

void UAICharacterBehaviour::Pause()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterBehaviour", "Pause");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AICharacterBehaviour.Resume
// (Native, Public)

void UAICharacterBehaviour::Resume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterBehaviour", "Resume");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AICharacterBehaviour.SetEnable
// (Final, Native, Public)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAICharacterBehaviour::SetEnable(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterBehaviour", "SetEnable");

	Params::AICharacterBehaviour_SetEnable Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AICharacterBehaviour.Start
// (Native, Public)

void UAICharacterBehaviour::Start()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterBehaviour", "Start");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AICharacterBehaviour.Stop
// (Native, Public)

void UAICharacterBehaviour::Stop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterBehaviour", "Stop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AICharacterBehaviour.Update
// (Native, Public)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAICharacterBehaviour::Update(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterBehaviour", "Update");

	Params::AICharacterBehaviour_Update Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AICharacterBehaviour.IsEnabled
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAICharacterBehaviour::IsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterBehaviour", "IsEnabled");

	Params::AICharacterBehaviour_IsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AIMoveToPosition.Init
// (Native, Public)
// Parameters:
// class ADBDPlayer*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAICharacterBehaviourData*        behaviourData                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIMoveToPosition::Init(class ADBDPlayer* Character, class UAICharacterBehaviourData* behaviourData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIMoveToPosition", "Init");

	Params::AIMoveToPosition_Init Parms{};

	Parms.Character = Character;
	Parms.behaviourData = behaviourData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AIMoveToPosition.TargetPositionReached
// (Final, Native, Private)
// Parameters:
// const struct FAIRequestID&              RequestID                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// EPathFollowingResult                    Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIMoveToPosition::TargetPositionReached(const struct FAIRequestID& RequestID, EPathFollowingResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIMoveToPosition", "TargetPositionReached");

	Params::AIMoveToPosition_TargetPositionReached Parms{};

	Parms.RequestID = std::move(RequestID);
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.Apply
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayModifierContainer::Apply(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "Apply");

	Params::GameplayModifierContainer_Apply Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.GameplayModifierContainer.Authority_ClearActivationTimer
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UGameplayModifierContainer::Authority_ClearActivationTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "Authority_ClearActivationTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.Authority_InstantiateGameplayModifierConditions
// (Final, Native, Public, BlueprintCallable)

void UGameplayModifierContainer::Authority_InstantiateGameplayModifierConditions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "Authority_InstantiateGameplayModifierConditions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.Authority_SetActivationTimerPaused
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              paused                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayModifierContainer::Authority_SetActivationTimerPaused(const bool paused)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "Authority_SetActivationTimerPaused");

	Params::GameplayModifierContainer_Authority_SetActivationTimerPaused Parms{};

	Parms.paused = paused;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.Authority_TriggerActivationTimer
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   activationTime                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayModifierContainer::Authority_TriggerActivationTimer(float activationTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "Authority_TriggerActivationTimer");

	Params::GameplayModifierContainer_Authority_TriggerActivationTimer Parms{};

	Parms.activationTime = activationTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.ListenToDispatcherGameEvent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              EventType                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayModifierContainer::ListenToDispatcherGameEvent(const struct FGameplayTag& EventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "ListenToDispatcherGameEvent");

	Params::GameplayModifierContainer_ListenToDispatcherGameEvent Parms{};

	Parms.EventType = std::move(EventType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.OnApplyBegin
// (Event, Public, BlueprintEvent)

void UGameplayModifierContainer::OnApplyBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "OnApplyBegin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.GameplayModifierContainer.OnApplyEnd
// (Event, Public, BlueprintEvent)

void UGameplayModifierContainer::OnApplyEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "OnApplyEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.GameplayModifierContainer.OnGameEventDispatched
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UGameplayModifierContainer::OnGameEventDispatched(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "OnGameEventDispatched");

	Params::GameplayModifierContainer_OnGameEventDispatched Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.OnInitialized
// (Native, Event, Public, BlueprintEvent)

void UGameplayModifierContainer::OnInitialized()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "OnInitialized");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.OnInitialized_Internal
// (Native, Public)

void UGameplayModifierContainer::OnInitialized_Internal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "OnInitialized_Internal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.OnLevelReadyToPlay
// (Native, Event, Protected, BlueprintEvent)

void UGameplayModifierContainer::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.OnRep_ActivationTimer
// (Final, Native, Private)

void UGameplayModifierContainer::OnRep_ActivationTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "OnRep_ActivationTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.OnRep_ModifierData
// (Native, Protected)

void UGameplayModifierContainer::OnRep_ModifierData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "OnRep_ModifierData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.OnRep_OperationConditionsData
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FOperationConditionsReplicatedData&oldOperationConditionsData                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UGameplayModifierContainer::OnRep_OperationConditionsData(const struct FOperationConditionsReplicatedData& oldOperationConditionsData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "OnRep_OperationConditionsData");

	Params::GameplayModifierContainer_OnRep_OperationConditionsData Parms{};

	Parms.oldOperationConditionsData = std::move(oldOperationConditionsData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.OnRep_TickableConditionsData
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FModifierTickableConditionReplicatedData&oldTickableConditionsData                              (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UGameplayModifierContainer::OnRep_TickableConditionsData(const struct FModifierTickableConditionReplicatedData& oldTickableConditionsData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "OnRep_TickableConditionsData");

	Params::GameplayModifierContainer_OnRep_TickableConditionsData Parms{};

	Parms.oldTickableConditionsData = std::move(oldTickableConditionsData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.RemoveAllFlags
// (Final, Native, Public, BlueprintCallable)

void UGameplayModifierContainer::RemoveAllFlags()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "RemoveAllFlags");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.RemoveAllModifiers
// (Final, Native, Public, BlueprintCallable)

void UGameplayModifierContainer::RemoveAllModifiers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "RemoveAllModifiers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.RemoveModifier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              Type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayModifierContainer::RemoveModifier(const struct FGameplayTag& Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "RemoveModifier");

	Params::GameplayModifierContainer_RemoveModifier Parms{};

	Parms.Type = std::move(Type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.SetFlag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              Flag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    flagValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayModifierContainer::SetFlag(const struct FGameplayTag& Flag, bool flagValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "SetFlag");

	Params::GameplayModifierContainer_SetFlag Parms{};

	Parms.Flag = std::move(Flag);
	Parms.flagValue = flagValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.SetModifierValue
// (Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              Type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   GameplayModifierValue                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayModifierContainer::SetModifierValue(const struct FGameplayTag& Type, float GameplayModifierValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "SetModifierValue");

	Params::GameplayModifierContainer_SetModifierValue Parms{};

	Parms.Type = std::move(Type);
	Parms.GameplayModifierValue = GameplayModifierValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.UnlistenToAllDispatcherGameEvents
// (Final, Native, Protected, BlueprintCallable)

void UGameplayModifierContainer::UnlistenToAllDispatcherGameEvents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "UnlistenToAllDispatcherGameEvents");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.UnlistenToDispatcherGameEvent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              EventType                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayModifierContainer::UnlistenToDispatcherGameEvent(const struct FGameplayTag& EventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "UnlistenToDispatcherGameEvent");

	Params::GameplayModifierContainer_UnlistenToDispatcherGameEvent Parms{};

	Parms.EventType = std::move(EventType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.UpdateIsApplicable
// (Final, Native, Public, BlueprintCallable)

void UGameplayModifierContainer::UpdateIsApplicable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "UpdateIsApplicable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.GetActivationTimerDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameplayModifierContainer::GetActivationTimerDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "GetActivationTimerDuration");

	Params::GameplayModifierContainer_GetActivationTimerDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierContainer.GetActivationTimerElapsedTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameplayModifierContainer::GetActivationTimerElapsedTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "GetActivationTimerElapsedTime");

	Params::GameplayModifierContainer_GetActivationTimerElapsedTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierContainer.GetActivationTimerElapsedTimePercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameplayModifierContainer::GetActivationTimerElapsedTimePercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "GetActivationTimerElapsedTimePercent");

	Params::GameplayModifierContainer_GetActivationTimerElapsedTimePercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierContainer.GetActivationTimerPercentRemaining
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameplayModifierContainer::GetActivationTimerPercentRemaining() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "GetActivationTimerPercentRemaining");

	Params::GameplayModifierContainer_GetActivationTimerPercentRemaining Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierContainer.GetActivationTimerRemainingTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameplayModifierContainer::GetActivationTimerRemainingTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "GetActivationTimerRemainingTime");

	Params::GameplayModifierContainer_GetActivationTimerRemainingTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierContainer.GetModifierValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              Type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameplayModifierContainer::GetModifierValue(const struct FGameplayTag& Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "GetModifierValue");

	Params::GameplayModifierContainer_GetModifierValue Parms{};

	Parms.Type = std::move(Type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierContainer.GetOriginatingEffect
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UGameplayModifierContainer*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayModifierContainer* UGameplayModifierContainer::GetOriginatingEffect() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "GetOriginatingEffect");

	Params::GameplayModifierContainer_GetOriginatingEffect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierContainer.GetOwningPlayer
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UGameplayModifierContainer::GetOwningPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "GetOwningPlayer");

	Params::GameplayModifierContainer_GetOwningPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierContainer.GetPercentageFill
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameplayModifierContainer::GetPercentageFill() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "GetPercentageFill");

	Params::GameplayModifierContainer_GetPercentageFill Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierContainer.GetRemainingLifetime
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameplayModifierContainer::GetRemainingLifetime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "GetRemainingLifetime");

	Params::GameplayModifierContainer_GetRemainingLifetime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierContainer.HasFlag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              Flag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayModifierContainer::HasFlag(const struct FGameplayTag& Flag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "HasFlag");

	Params::GameplayModifierContainer_HasFlag Parms{};

	Parms.Flag = std::move(Flag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierContainer.HasModifierOfType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              Type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayModifierContainer::HasModifierOfType(const struct FGameplayTag& Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "HasModifierOfType");

	Params::GameplayModifierContainer_HasModifierOfType Parms{};

	Parms.Type = std::move(Type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierContainer.IsActivationTimerActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayModifierContainer::IsActivationTimerActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "IsActivationTimerActive");

	Params::GameplayModifierContainer_IsActivationTimerActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierContainer.IsActivationTimerDone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayModifierContainer::IsActivationTimerDone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "IsActivationTimerDone");

	Params::GameplayModifierContainer_IsActivationTimerDone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StatusEffect.Authority_End
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UStatusEffect::Authority_End()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "Authority_End");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.Authority_EndSelf
// (BlueprintAuthorityOnly, Native, Event, Public, BlueprintEvent)

void UStatusEffect::Authority_EndSelf()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "Authority_EndSelf");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.Authority_OnOriginatingPlayerEndPlay
// (Final, Native, Private)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEndPlayReason                          EndPlayReason                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffect::Authority_OnOriginatingPlayerEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "Authority_OnOriginatingPlayerEndPlay");

	Params::StatusEffect_Authority_OnOriginatingPlayerEndPlay Parms{};

	Parms.Actor = Actor;
	Parms.EndPlayReason = EndPlayReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.Authority_RemoveSelf
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UStatusEffect::Authority_RemoveSelf()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "Authority_RemoveSelf");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.Authority_SetRemainingLifetime
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Lifetime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffect::Authority_SetRemainingLifetime(float Lifetime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "Authority_SetRemainingLifetime");

	Params::StatusEffect_Authority_SetRemainingLifetime Parms{};

	Parms.Lifetime = Lifetime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.Authority_Start
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Duration                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffect::Authority_Start(const float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "Authority_Start");

	Params::StatusEffect_Authority_Start Parms{};

	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.BroadcastGameEventNotification
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const struct FGameplayNotificationData& notificationData                                       (Parm, NativeAccessSpecifierPublic)
// bool                                    addToHistory                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffect::BroadcastGameEventNotification(const struct FGameplayNotificationData& notificationData, bool addToHistory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "BroadcastGameEventNotification");

	Params::StatusEffect_BroadcastGameEventNotification Parms{};

	Parms.notificationData = std::move(notificationData);
	Parms.addToHistory = addToHistory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.BroadcastOriginatorGameEventNotification
// (Final, Native, Protected, BlueprintCallable)

void UStatusEffect::BroadcastOriginatorGameEventNotification()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "BroadcastOriginatorGameEventNotification");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.InitializeLifetime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Lifetime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffect::InitializeLifetime(float Lifetime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "InitializeLifetime");

	Params::StatusEffect_InitializeLifetime Parms{};

	Parms.Lifetime = Lifetime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.Multicast_SetRemainingLifetime
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// float                                   Lifetime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffect::Multicast_SetRemainingLifetime(float Lifetime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "Multicast_SetRemainingLifetime");

	Params::StatusEffect_Multicast_SetRemainingLifetime Parms{};

	Parms.Lifetime = Lifetime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.Multicast_SetRemainingLifetimeInitialized
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    remainingLifetimeInitialized                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffect::Multicast_SetRemainingLifetimeInitialized(bool remainingLifetimeInitialized)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "Multicast_SetRemainingLifetimeInitialized");

	Params::StatusEffect_Multicast_SetRemainingLifetimeInitialized Parms{};

	Parms.remainingLifetimeInitialized = remainingLifetimeInitialized;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.OnLifetimeEnded
// (Native, Event, Public, BlueprintEvent)

void UStatusEffect::OnLifetimeEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "OnLifetimeEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.OnLifetimeStarted
// (Native, Event, Public, BlueprintEvent)

void UStatusEffect::OnLifetimeStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "OnLifetimeStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.OnRep_ShouldDisplay
// (Final, Native, Protected)

void UStatusEffect::OnRep_ShouldDisplay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "OnRep_ShouldDisplay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.OnRep_ShouldOriginatingPlayerChange
// (Final, Native, Protected)

void UStatusEffect::OnRep_ShouldOriginatingPlayerChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "OnRep_ShouldOriginatingPlayerChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.OnRep_StatusInitializationData
// (Final, Native, Private)

void UStatusEffect::OnRep_StatusInitializationData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "OnRep_StatusInitializationData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.OnShouldDisplayChanged
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    CurrentValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffect::OnShouldDisplayChanged(bool CurrentValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "OnShouldDisplayChanged");

	Params::StatusEffect_OnShouldDisplayChanged Parms{};

	Parms.CurrentValue = CurrentValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.OnShouldOriginatingPlayerChange
// (Native, Event, Protected, BlueprintEvent)

void UStatusEffect::OnShouldOriginatingPlayerChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "OnShouldOriginatingPlayerChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.SetShouldDisplay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    On                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffect::SetShouldDisplay(bool On)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "SetShouldDisplay");

	Params::StatusEffect_SetShouldDisplay Parms{};

	Parms.On = On;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.SetStatusEffectIconPercentage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffect::SetStatusEffectIconPercentage(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "SetStatusEffectIconPercentage");

	Params::StatusEffect_SetStatusEffectIconPercentage Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.FireActiveStatusEffectEvent
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// float                                   Percentage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   levelToDisplay                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffect::FireActiveStatusEffectEvent(float Percentage, int32 levelToDisplay) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "FireActiveStatusEffectEvent");

	Params::StatusEffect_FireActiveStatusEffectEvent Parms{};

	Parms.Percentage = Percentage;
	Parms.levelToDisplay = levelToDisplay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.GetCustomParam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UStatusEffect::GetCustomParam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "GetCustomParam");

	Params::StatusEffect_GetCustomParam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StatusEffect.GetLifetimeDuration
// (Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UStatusEffect::GetLifetimeDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "GetLifetimeDuration");

	Params::StatusEffect_GetLifetimeDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StatusEffect.GetOriginatingPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UStatusEffect::GetOriginatingPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "GetOriginatingPlayer");

	Params::StatusEffect_GetOriginatingPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StatusEffect.GetShouldDisplay
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStatusEffect::GetShouldDisplay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "GetShouldDisplay");

	Params::StatusEffect_GetShouldDisplay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StatusEffect.GetStatusEffectCooldownRate
// (Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UStatusEffect::GetStatusEffectCooldownRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "GetStatusEffectCooldownRate");

	Params::StatusEffect_GetStatusEffectCooldownRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StatusEffect.GetStatusEffectType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EStatusEffectType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EStatusEffectType UStatusEffect::GetStatusEffectType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "GetStatusEffectType");

	Params::StatusEffect_GetStatusEffectType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StatusEffect.IsInOriginatorRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStatusEffect::IsInOriginatorRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "IsInOriginatorRange");

	Params::StatusEffect_IsInOriginatorRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StatusEffect.IsKillerInOriginatorRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   AdditiveRangeModifier                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStatusEffect::IsKillerInOriginatorRange(float AdditiveRangeModifier) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "IsKillerInOriginatorRange");

	Params::StatusEffect_IsKillerInOriginatorRange Parms{};

	Parms.AdditiveRangeModifier = AdditiveRangeModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StatusEffect.IsOriginatorAlive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStatusEffect::IsOriginatorAlive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "IsOriginatorAlive");

	Params::StatusEffect_IsOriginatorAlive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StatusEffect.IsOriginatorHooked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStatusEffect::IsOriginatorHooked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "IsOriginatorHooked");

	Params::StatusEffect_IsOriginatorHooked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StatusEffect.ShouldDisplayStatusEffectIcon
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStatusEffect::ShouldDisplayStatusEffectIcon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "ShouldDisplayStatusEffectIcon");

	Params::StatusEffect_ShouldDisplayStatusEffectIcon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StatusEffect.ShouldHideStatusEffectIcon
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStatusEffect::ShouldHideStatusEffectIcon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "ShouldHideStatusEffectIcon");

	Params::StatusEffect_ShouldHideStatusEffectIcon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactable.AttachEveryInteractionToZone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              zone                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractable::AttachEveryInteractionToZone(class UPrimitiveComponent* zone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "AttachEveryInteractionToZone");

	Params::Interactable_AttachEveryInteractionToZone Parms{};

	Parms.zone = zone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Interactable.AuthorityRequestCancelOngoingInteractions
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    onlyOnHitCancelableInteractions                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractable::AuthorityRequestCancelOngoingInteractions(bool onlyOnHitCancelableInteractions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "AuthorityRequestCancelOngoingInteractions");

	Params::Interactable_AuthorityRequestCancelOngoingInteractions Parms{};

	Parms.onlyOnHitCancelableInteractions = onlyOnHitCancelableInteractions;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Interactable.OnInteractorLockChanged
// (Final, Native, Private)
// Parameters:
// bool                                    Locked                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       interactingPlayer                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractable::OnInteractorLockChanged(bool Locked, class ADBDPlayer* interactingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "OnInteractorLockChanged");

	Params::Interactable_OnInteractorLockChanged Parms{};

	Parms.Locked = Locked;
	Parms.interactingPlayer = interactingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Interactable.OnLevelReadyToPlay
// (Event, Public, BlueprintEvent)

void AInteractable::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "OnLevelReadyToPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Interactable.OnLevelReadyToPlay_Native
// (Native, Protected)

void AInteractable::OnLevelReadyToPlay_Native()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "OnLevelReadyToPlay_Native");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Interactable.PreInterruptionEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       interruptor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       interruptee                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInterruptionDefinition*          interruption                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractable::PreInterruptionEvent(class ADBDPlayer* interruptor, class ADBDPlayer* interruptee, class UInterruptionDefinition* interruption)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "PreInterruptionEvent");

	Params::Interactable_PreInterruptionEvent Parms{};

	Parms.interruptor = interruptor;
	Parms.interruptee = interruptee;
	Parms.interruption = interruption;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Interactable.SetInteractorsUsable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    usable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractor*                      exception                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractable::SetInteractorsUsable(bool usable, class UInteractor* exception)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "SetInteractorsUsable");

	Params::Interactable_SetInteractorsUsable Parms{};

	Parms.usable = usable;
	Parms.exception = exception;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Interactable.SetSingleZone
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              zone                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractable::SetSingleZone(class UPrimitiveComponent* zone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "SetSingleZone");

	Params::Interactable_SetSingleZone Parms{};

	Parms.zone = zone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Interactable.Authority_GetInteractingPlayers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ADBDPlayer*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ADBDPlayer*> AInteractable::Authority_GetInteractingPlayers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "Authority_GetInteractingPlayers");

	Params::Interactable_Authority_GetInteractingPlayers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactable.GetFocalPointPosition
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UInteractionDefinition*     definition                                             (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AInteractable::GetFocalPointPosition(const class ADBDPlayer* Player, const class UInteractionDefinition* definition) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "GetFocalPointPosition");

	Params::Interactable_GetFocalPointPosition Parms{};

	Parms.Player = Player;
	Parms.definition = definition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactable.GetInteractingPlayersRaw
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ADBDPlayer*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ADBDPlayer*> AInteractable::GetInteractingPlayersRaw() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "GetInteractingPlayersRaw");

	Params::Interactable_GetInteractingPlayersRaw Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactable.GetInteractors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UInteractor*>              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UInteractor*> AInteractable::GetInteractors() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "GetInteractors");

	Params::Interactable_GetInteractors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactable.GetObjectState
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UGameplayTagContainerComponent*   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayTagContainerComponent* AInteractable::GetObjectState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "GetObjectState");

	Params::Interactable_GetObjectState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactable.GetPlayerOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* AInteractable::GetPlayerOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "GetPlayerOwner");

	Params::Interactable_GetPlayerOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactable.HasAnOngoingInteraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AInteractable::HasAnOngoingInteraction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "HasAnOngoingInteraction");

	Params::Interactable_HasAnOngoingInteraction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactable.IsInteractingWith
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AInteractable::IsInteractingWith(const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "IsInteractingWith");

	Params::Interactable_IsInteractingWith Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactable.IsInteractionDone
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UInteractor*                Interactor                                             (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UInteractionDefinition*     definition                                             (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputInteractionType                   interactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AInteractable::IsInteractionDone(class ADBDPlayer* Player, const class UInteractor* Interactor, const class UInteractionDefinition* definition, EInputInteractionType interactionType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "IsInteractionDone");

	Params::Interactable_IsInteractionDone Parms{};

	Parms.Player = Player;
	Parms.Interactor = Interactor;
	Parms.definition = definition;
	Parms.interactionType = interactionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactable.IsInterruptionPossible
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// const class ADBDPlayer*                 interruptor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ADBDPlayer*                 interruptee                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UInteractor*                Interactor                                             (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UInteractionDefinition*     definition                                             (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UInterruptionDefinition*    interruption                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AInteractable::IsInterruptionPossible(const class ADBDPlayer* interruptor, const class ADBDPlayer* interruptee, const class UInteractor* Interactor, const class UInteractionDefinition* definition, const class UInterruptionDefinition* interruption) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "IsInterruptionPossible");

	Params::Interactable_IsInterruptionPossible Parms{};

	Parms.interruptor = interruptor;
	Parms.interruptee = interruptee;
	Parms.Interactor = Interactor;
	Parms.definition = definition;
	Parms.interruption = interruption;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.Authority_AddItemAddon
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UItemAddon*                       addon                                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACollectable::Authority_AddItemAddon(class UItemAddon* addon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "Authority_AddItemAddon");

	Params::Collectable_Authority_AddItemAddon Parms{};

	Parms.addon = addon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.Authority_Discard
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ACollectable::Authority_Discard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "Authority_Discard");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.Authority_OnCollectorEndPlay
// (Final, Native, Private)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEndPlayReason                          EndPlayReason                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::Authority_OnCollectorEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "Authority_OnCollectorEndPlay");

	Params::Collectable_Authority_OnCollectorEndPlay Parms{};

	Parms.Actor = Actor;
	Parms.EndPlayReason = EndPlayReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.Authority_OnConsumed
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    forceDiscard                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::Authority_OnConsumed(bool forceDiscard)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "Authority_OnConsumed");

	Params::Collectable_Authority_OnConsumed Parms{};

	Parms.forceDiscard = forceDiscard;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.Authority_RemoveItemAddon
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UItemAddon*                       addon                                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::Authority_RemoveItemAddon(class UItemAddon* addon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "Authority_RemoveItemAddon");

	Params::Collectable_Authority_RemoveItemAddon Parms{};

	Parms.addon = addon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.Authority_Use
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ACollectable::Authority_Use()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "Authority_Use");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.Authority_UseReleased
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ACollectable::Authority_UseReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "Authority_UseReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.BP_OnSurvivorAdded
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::BP_OnSurvivorAdded(class ASurvivor* Survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "BP_OnSurvivorAdded");

	Params::Collectable_BP_OnSurvivorAdded Parms{};

	Parms.Survivor = Survivor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Collectable.CallOnCollectorSetBP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(class ADBDPlayer* Player)>Callback                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::CallOnCollectorSetBP(TDelegate<void(class ADBDPlayer* Player)> Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "CallOnCollectorSetBP");

	Params::Collectable_CallOnCollectorSetBP Parms{};

	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.DebugPrintStats
// (Native, Event, Public, BlueprintEvent)

void ACollectable::DebugPrintStats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "DebugPrintStats");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.GetItemAddons
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UItemAddon*>               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UItemAddon*> ACollectable::GetItemAddons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "GetItemAddons");

	Params::Collectable_GetItemAddons Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.Local_Dropped_Location
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       droppedBy                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ACollectable::Local_Dropped_Location(class ADBDPlayer* droppedBy, const struct FVector& Location, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "Local_Dropped_Location");

	Params::Collectable_Local_Dropped_Location Parms{};

	Parms.droppedBy = droppedBy;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.Multicast_Collected
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class ADBDPlayer*                       collector                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInventoryType                          inventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::Multicast_Collected(class ADBDPlayer* collector, EInventoryType inventoryType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "Multicast_Collected");

	Params::Collectable_Multicast_Collected Parms{};

	Parms.collector = collector;
	Parms.inventoryType = inventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.Multicast_Dropped
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// class ADBDPlayer*                       droppedBy                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Rotation                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EItemDropType                           itemDropType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::Multicast_Dropped(class ADBDPlayer* droppedBy, const struct FVector& Location, const struct FRotator& Rotation, EItemDropType itemDropType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "Multicast_Dropped");

	Params::Collectable_Multicast_Dropped Parms{};

	Parms.droppedBy = droppedBy;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.itemDropType = itemDropType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.Multicast_RemoveAllAddons
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ACollectable::Multicast_RemoveAllAddons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "Multicast_RemoveAllAddons");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.Multicast_RemoveItemAddon
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class UItemAddon*                       addon                                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::Multicast_RemoveItemAddon(class UItemAddon* addon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "Multicast_RemoveItemAddon");

	Params::Collectable_Multicast_RemoveItemAddon Parms{};

	Parms.addon = addon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.Multicast_Use
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void ACollectable::Multicast_Use()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "Multicast_Use");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.Multicast_UseReleased
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class ADBDPlayer*                       collector                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::Multicast_UseReleased(class ADBDPlayer* collector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "Multicast_UseReleased");

	Params::Collectable_Multicast_UseReleased Parms{};

	Parms.collector = collector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.OnActivateDissolveItem
// (BlueprintCosmetic, Event, Public, BlueprintCallable, BlueprintEvent)

void ACollectable::OnActivateDissolveItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "OnActivateDissolveItem");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Collectable.OnAddonsAdded
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const TArray<class UItemAddon*>&        addons                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACollectable::OnAddonsAdded(const TArray<class UItemAddon*>& addons)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "OnAddonsAdded");

	Params::Collectable_OnAddonsAdded Parms{};

	Parms.addons = std::move(addons);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Collectable.OnAddonsRemoved
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const TArray<class UItemAddon*>&        addons                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACollectable::OnAddonsRemoved(const TArray<class UItemAddon*>& addons)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "OnAddonsRemoved");

	Params::Collectable_OnAddonsRemoved Parms{};

	Parms.addons = std::move(addons);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Collectable.OnCollectorSet
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       collector                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::OnCollectorSet(class ADBDPlayer* collector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "OnCollectorSet");

	Params::Collectable_OnCollectorSet Parms{};

	Parms.collector = collector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.OnCustomizationChanged
// (Event, Public, BlueprintEvent)

void ACollectable::OnCustomizationChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "OnCustomizationChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Collectable.OnDropped
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       droppingPlayer                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::OnDropped(class ADBDPlayer* droppingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "OnDropped");

	Params::Collectable_OnDropped Parms{};

	Parms.droppingPlayer = droppingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.OnPostItemAddonsCreation
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::OnPostItemAddonsCreation(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "OnPostItemAddonsCreation");

	Params::Collectable_OnPostItemAddonsCreation Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Collectable.OnRep_Collector
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       oldCollector                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::OnRep_Collector(class ADBDPlayer* oldCollector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "OnRep_Collector");

	Params::Collectable_OnRep_Collector Parms{};

	Parms.oldCollector = oldCollector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.OnRep_State
// (Final, Native, Private)

void ACollectable::OnRep_State()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "OnRep_State");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.OnUse
// (Native, Event, Protected, BlueprintEvent)

void ACollectable::OnUse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "OnUse");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.OnUseReleased
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       collector                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::OnUseReleased(class ADBDPlayer* collector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "OnUseReleased");

	Params::Collectable_OnUseReleased Parms{};

	Parms.collector = collector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.SetCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::SetCount(int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "SetCount");

	Params::Collectable_SetCount Parms{};

	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.SetDisplayedInputType
// (Final, Native, Public)
// Parameters:
// const EInputInteractionType             displayedInputType                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::SetDisplayedInputType(const EInputInteractionType displayedInputType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "SetDisplayedInputType");

	Params::Collectable_SetDisplayedInputType Parms{};

	Parms.displayedInputType = displayedInputType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.SetIsKeyPromptForceDisabled
// (Final, Native, Public)
// Parameters:
// const bool                              IsKeyPromptForceDisabled                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::SetIsKeyPromptForceDisabled(const bool IsKeyPromptForceDisabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "SetIsKeyPromptForceDisabled");

	Params::Collectable_SetIsKeyPromptForceDisabled Parms{};

	Parms.IsKeyPromptForceDisabled = IsKeyPromptForceDisabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.SetItemInteractor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInteractor*                      Interactor                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::SetItemInteractor(class UInteractor* Interactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "SetItemInteractor");

	Params::Collectable_SetItemInteractor Parms{};

	Parms.Interactor = Interactor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.SetVisibilityEvent
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    Visibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::SetVisibilityEvent(bool Visibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "SetVisibilityEvent");

	Params::Collectable_SetVisibilityEvent Parms{};

	Parms.Visibility = Visibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.CanBeCollected
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 collector                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACollectable::CanBeCollected(const class ADBDPlayer* collector) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "CanBeCollected");

	Params::Collectable_CanBeCollected Parms{};

	Parms.collector = collector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.CanBeDropped
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 dropper                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACollectable::CanBeDropped(const class ADBDPlayer* dropper) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "CanBeDropped");

	Params::Collectable_CanBeDropped Parms{};

	Parms.dropper = dropper;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.CanUse
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACollectable::CanUse(const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "CanUse");

	Params::Collectable_CanUse Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.GetCollector
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* ACollectable::GetCollector() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "GetCollector");

	Params::Collectable_GetCollector Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.GetCount
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACollectable::GetCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "GetCount");

	Params::Collectable_GetCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.GetDisplayedInputType
// (Native, Public, Const)
// Parameters:
// EInputInteractionType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInputInteractionType ACollectable::GetDisplayedInputType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "GetDisplayedInputType");

	Params::Collectable_GetDisplayedInputType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.GetIconFilePath
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FString                     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FString ACollectable::GetIconFilePath() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "GetIconFilePath");

	Params::Collectable_GetIconFilePath Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.GetItemIconIndex
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 ACollectable::GetItemIconIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "GetItemIconIndex");

	Params::Collectable_GetItemIconIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.GetItemInteractor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractor*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractor* ACollectable::GetItemInteractor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "GetItemInteractor");

	Params::Collectable_GetItemInteractor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.GetModifierMax
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              modifierType                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   defaultValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACollectable::GetModifierMax(const struct FGameplayTag& modifierType, float defaultValue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "GetModifierMax");

	Params::Collectable_GetModifierMax Parms{};

	Parms.modifierType = std::move(modifierType);
	Parms.defaultValue = defaultValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.GetModifierSum
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              modifierType                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   defaultValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACollectable::GetModifierSum(const struct FGameplayTag& modifierType, float defaultValue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "GetModifierSum");

	Params::Collectable_GetModifierSum Parms{};

	Parms.modifierType = std::move(modifierType);
	Parms.defaultValue = defaultValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.GetUsePercentLeft
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACollectable::GetUsePercentLeft() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "GetUsePercentLeft");

	Params::Collectable_GetUsePercentLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.HasGameplayModifierFlag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              modifierFlag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACollectable::HasGameplayModifierFlag(const struct FGameplayTag& modifierFlag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "HasGameplayModifierFlag");

	Params::Collectable_HasGameplayModifierFlag Parms{};

	Parms.modifierFlag = std::move(modifierFlag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.IsCollected
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACollectable::IsCollected() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "IsCollected");

	Params::Collectable_IsCollected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.IsCountDisplayForced
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACollectable::IsCountDisplayForced() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "IsCountDisplayForced");

	Params::Collectable_IsCountDisplayForced Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.IsCursedItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACollectable::IsCursedItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "IsCursedItem");

	Params::Collectable_IsCursedItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.IsEquipped
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACollectable::IsEquipped() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "IsEquipped");

	Params::Collectable_IsEquipped Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.IsInSearchable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACollectable::IsInSearchable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "IsInSearchable");

	Params::Collectable_IsInSearchable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.IsKeyPromptForceDisabled
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACollectable::IsKeyPromptForceDisabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "IsKeyPromptForceDisabled");

	Params::Collectable_IsKeyPromptForceDisabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.IsLocallyControlled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACollectable::IsLocallyControlled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "IsLocallyControlled");

	Params::Collectable_IsLocallyControlled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.IsOnGround
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACollectable::IsOnGround() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "IsOnGround");

	Params::Collectable_IsOnGround Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.IsPickable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACollectable::IsPickable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "IsPickable");

	Params::Collectable_IsPickable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.IsRechargeable
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACollectable::IsRechargeable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "IsRechargeable");

	Params::Collectable_IsRechargeable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.IsSpecialItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACollectable::IsSpecialItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "IsSpecialItem");

	Params::Collectable_IsSpecialItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.IsStored
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACollectable::IsStored() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "IsStored");

	Params::Collectable_IsStored Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.BaseTrap.SetIsTrapSet
// (Native, Public, BlueprintCallable)
// Parameters:
// const bool                              Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseTrap::SetIsTrapSet(const bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseTrap", "SetIsTrapSet");

	Params::BaseTrap_SetIsTrapSet Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BaseTrap.IsTrapSet
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseTrap::IsTrapSet() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseTrap", "IsTrapSet");

	Params::BaseTrap_IsTrapSet Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.AddMutuallyExclusiveInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInteractionDefinition*           Interaction                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::AddMutuallyExclusiveInteraction(class UInteractionDefinition* Interaction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "AddMutuallyExclusiveInteraction");

	Params::InteractionDefinition_AddMutuallyExclusiveInteraction Parms{};

	Parms.Interaction = Interaction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InteractionDefinition.AttachToInteractor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInteractor*                      Interactor                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::AttachToInteractor(class UInteractor* Interactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "AttachToInteractor");

	Params::InteractionDefinition_AttachToInteractor Parms{};

	Parms.Interactor = Interactor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InteractionDefinition.AttachToZone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              zone                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::AttachToZone(class UPrimitiveComponent* zone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "AttachToZone");

	Params::InteractionDefinition_AttachToZone Parms{};

	Parms.zone = zone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InteractionDefinition.Authority_OnInteractionAuthorized
// (BlueprintAuthorityOnly, Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::Authority_OnInteractionAuthorized(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "Authority_OnInteractionAuthorized");

	Params::InteractionDefinition_Authority_OnInteractionAuthorized Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.GetPlayerDependency
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// const class ADBDPlayer*                 interactingPlayer                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UInteractionDefinition::GetPlayerDependency(const class ADBDPlayer* interactingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetPlayerDependency");

	Params::InteractionDefinition_GetPlayerDependency Parms{};

	Parms.interactingPlayer = interactingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.OnInteractionAnimNotifyEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             NotifyId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInteractionAnimNotifyEvent(class FName NotifyId, class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInteractionAnimNotifyEvent");

	Params::InteractionDefinition_OnInteractionAnimNotifyEvent Parms{};

	Parms.NotifyId = NotifyId;
	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnInteractionCancelled
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInteractionCancelled(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInteractionCancelled");

	Params::InteractionDefinition_OnInteractionCancelled Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnInteractionEnterEnd
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInteractionEnterEnd(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInteractionEnterEnd");

	Params::InteractionDefinition_OnInteractionEnterEnd Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnInteractionEnterStart
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   actualSnapTime                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInteractionEnterStart(class ADBDPlayer* Player, float actualSnapTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInteractionEnterStart");

	Params::InteractionDefinition_OnInteractionEnterStart Parms{};

	Parms.Player = Player;
	Parms.actualSnapTime = actualSnapTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnInteractionEnterTick
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInteractionEnterTick(class ADBDPlayer* Player, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInteractionEnterTick");

	Params::InteractionDefinition_OnInteractionEnterTick Parms{};

	Parms.Player = Player;
	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnInteractionExitEnd
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInteractionExitEnd(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInteractionExitEnd");

	Params::InteractionDefinition_OnInteractionExitEnd Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnInteractionExitStart
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInteractionExitStart(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInteractionExitStart");

	Params::InteractionDefinition_OnInteractionExitStart Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnInteractionExitTick
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInteractionExitTick(class ADBDPlayer* Player, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInteractionExitTick");

	Params::InteractionDefinition_OnInteractionExitTick Parms{};

	Parms.Player = Player;
	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnInteractionFinished
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    hasInteractionStarted                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInteractionFinished(class ADBDPlayer* Player, bool hasInteractionStarted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInteractionFinished");

	Params::InteractionDefinition_OnInteractionFinished Parms{};

	Parms.Player = Player;
	Parms.hasInteractionStarted = hasInteractionStarted;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnInteractionInit
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInteractionInit(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInteractionInit");

	Params::InteractionDefinition_OnInteractionInit Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnInteractionInterruptEnd
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInterruptionDefinition*          currentInterruption                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       interruptingPlayer                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInteractionInterruptEnd(class ADBDPlayer* Player, class UInterruptionDefinition* currentInterruption, class ADBDPlayer* interruptingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInteractionInterruptEnd");

	Params::InteractionDefinition_OnInteractionInterruptEnd Parms{};

	Parms.Player = Player;
	Parms.currentInterruption = currentInterruption;
	Parms.interruptingPlayer = interruptingPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnInteractionInterruptStart
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInterruptionDefinition*          currentInterruption                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       interruptingPlayer                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInteractionInterruptStart(class ADBDPlayer* Player, class UInterruptionDefinition* currentInterruption, class ADBDPlayer* interruptingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInteractionInterruptStart");

	Params::InteractionDefinition_OnInteractionInterruptStart Parms{};

	Parms.Player = Player;
	Parms.currentInterruption = currentInterruption;
	Parms.interruptingPlayer = interruptingPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnInteractionInterruptStarted
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInterruptionDefinition*          currentInterruption                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       interruptingPlayer                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInteractionInterruptStarted(class ADBDPlayer* Player, class UInterruptionDefinition* currentInterruption, class ADBDPlayer* interruptingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInteractionInterruptStarted");

	Params::InteractionDefinition_OnInteractionInterruptStarted Parms{};

	Parms.Player = Player;
	Parms.currentInterruption = currentInterruption;
	Parms.interruptingPlayer = interruptingPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnInteractionUpdateEnd
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInteractionUpdateEnd(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInteractionUpdateEnd");

	Params::InteractionDefinition_OnInteractionUpdateEnd Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnInteractionUpdateMontageReachedMiddle
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInteractionUpdateMontageReachedMiddle(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInteractionUpdateMontageReachedMiddle");

	Params::InteractionDefinition_OnInteractionUpdateMontageReachedMiddle Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnInteractionUpdateStart
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInteractionUpdateStart(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInteractionUpdateStart");

	Params::InteractionDefinition_OnInteractionUpdateStart Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnInteractionUpdateTick
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInteractionUpdateTick(class ADBDPlayer* Player, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInteractionUpdateTick");

	Params::InteractionDefinition_OnInteractionUpdateTick Parms{};

	Parms.Player = Player;
	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnInterruptorUpdateStart
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UInterruptionDefinition*          currentInterruption                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       interruptor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       interruptee                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInterruptorUpdateStart(class UInterruptionDefinition* currentInterruption, class ADBDPlayer* interruptor, class ADBDPlayer* interruptee)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInterruptorUpdateStart");

	Params::InteractionDefinition_OnInterruptorUpdateStart Parms{};

	Parms.currentInterruption = currentInterruption;
	Parms.interruptor = interruptor;
	Parms.interruptee = interruptee;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnUpdateMontageStart
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnUpdateMontageStart(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnUpdateMontageStart");

	Params::InteractionDefinition_OnUpdateMontageStart Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.CalculateSnapTimeForConstantMaxNormalMovementSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   speedBoost                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionDefinition::CalculateSnapTimeForConstantMaxNormalMovementSpeed(const class ADBDPlayer* Player, float speedBoost) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "CalculateSnapTimeForConstantMaxNormalMovementSpeed");

	Params::InteractionDefinition_CalculateSnapTimeForConstantMaxNormalMovementSpeed Parms{};

	Parms.Player = Player;
	Parms.speedBoost = speedBoost;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.CanOverrideInteraction
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class UInteractionDefinition*     Interaction                                            (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionDefinition::CanOverrideInteraction(const class UInteractionDefinition* Interaction) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "CanOverrideInteraction");

	Params::InteractionDefinition_CanOverrideInteraction Parms{};

	Parms.Interaction = Interaction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.ComparePriorityToInteraction
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// const class UInteractionDefinition*     Interaction                                            (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInteractionComparisonPriority          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInteractionComparisonPriority UInteractionDefinition::ComparePriorityToInteraction(const class UInteractionDefinition* Interaction) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "ComparePriorityToInteraction");

	Params::InteractionDefinition_ComparePriorityToInteraction Parms{};

	Parms.Interaction = Interaction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.DoesPlayerHaveClearPath
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionDefinition::DoesPlayerHaveClearPath(const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "DoesPlayerHaveClearPath");

	Params::InteractionDefinition_DoesPlayerHaveClearPath Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetActionSpeedMultiplier
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Character                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionDefinition::GetActionSpeedMultiplier(const class ADBDPlayer* Character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetActionSpeedMultiplier");

	Params::InteractionDefinition_GetActionSpeedMultiplier Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetActorHeightDelta
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionDefinition::GetActorHeightDelta(const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetActorHeightDelta");

	Params::InteractionDefinition_GetActorHeightDelta Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetActorsToIgnoreOverlap
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UInteractionDefinition::GetActorsToIgnoreOverlap() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetActorsToIgnoreOverlap");

	Params::InteractionDefinition_GetActorsToIgnoreOverlap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetAllowNavigation
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionDefinition::GetAllowNavigation(const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetAllowNavigation");

	Params::InteractionDefinition_GetAllowNavigation Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetChargePercent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionDefinition::GetChargePercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetChargePercent");

	Params::InteractionDefinition_GetChargePercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetEnterMontage
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAnimationMontageDescriptor      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAnimationMontageDescriptor UInteractionDefinition::GetEnterMontage(const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetEnterMontage");

	Params::InteractionDefinition_GetEnterMontage Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetExitMontage
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAnimationMontageDescriptor      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAnimationMontageDescriptor UInteractionDefinition::GetExitMontage(const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetExitMontage");

	Params::InteractionDefinition_GetExitMontage Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetFocalPointPosition
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UInteractionDefinition::GetFocalPointPosition(const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetFocalPointPosition");

	Params::InteractionDefinition_GetFocalPointPosition Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetInteractable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AInteractable*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AInteractable* UInteractionDefinition::GetInteractable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetInteractable");

	Params::InteractionDefinition_GetInteractable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetInteractionDescriptionText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FText                       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const class FText UInteractionDefinition::GetInteractionDescriptionText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetInteractionDescriptionText");

	Params::InteractionDefinition_GetInteractionDescriptionText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetInteractionExitTime
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Character                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionDefinition::GetInteractionExitTime(const class ADBDPlayer* Character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetInteractionExitTime");

	Params::InteractionDefinition_GetInteractionExitTime Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetInteractionText
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UInteractionDefinition::GetInteractionText(const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetInteractionText");

	Params::InteractionDefinition_GetInteractionText Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetInteractionTime
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Character                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionDefinition::GetInteractionTime(const class ADBDPlayer* Character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetInteractionTime");

	Params::InteractionDefinition_GetInteractionTime Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetInteractionTimeMultiplier
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// const class ADBDPlayer*                 Character                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionDefinition::GetInteractionTimeMultiplier(const class ADBDPlayer* Character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetInteractionTimeMultiplier");

	Params::InteractionDefinition_GetInteractionTimeMultiplier Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetInteractor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractor*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractor* UInteractionDefinition::GetInteractor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetInteractor");

	Params::InteractionDefinition_GetInteractor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetPlayerOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UInteractionDefinition::GetPlayerOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetPlayerOwner");

	Params::InteractionDefinition_GetPlayerOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetRotationToSnapPoint
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UInteractionDefinition::GetRotationToSnapPoint(const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetRotationToSnapPoint");

	Params::InteractionDefinition_GetRotationToSnapPoint Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetSecondaryActionInputType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputInteractionType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInputInteractionType UInteractionDefinition::GetSecondaryActionInputType(const class UObject* WorldContextObject) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetSecondaryActionInputType");

	Params::InteractionDefinition_GetSecondaryActionInputType Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetSlashableRelativeLocation
// (Native, Event, Public, HasDefaults, BlueprintEvent, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UInteractionDefinition::GetSlashableRelativeLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetSlashableRelativeLocation");

	Params::InteractionDefinition_GetSlashableRelativeLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetSnapDistance
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionDefinition::GetSnapDistance(const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetSnapDistance");

	Params::InteractionDefinition_GetSnapDistance Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetSnapPointPosition
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UInteractionDefinition::GetSnapPointPosition(const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetSnapPointPosition");

	Params::InteractionDefinition_GetSnapPointPosition Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetSnapSocketName
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UInteractionDefinition::GetSnapSocketName(const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetSnapSocketName");

	Params::InteractionDefinition_GetSnapSocketName Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetSnapTime
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionDefinition::GetSnapTime(const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetSnapTime");

	Params::InteractionDefinition_GetSnapTime Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetUpdateMontage
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAnimationMontageDescriptor      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAnimationMontageDescriptor UInteractionDefinition::GetUpdateMontage(const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetUpdateMontage");

	Params::InteractionDefinition_GetUpdateMontage Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.IsCancelable
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionDefinition::IsCancelable(const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "IsCancelable");

	Params::InteractionDefinition_IsCancelable Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.IsInteractionDone
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputInteractionType                   interactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionDefinition::IsInteractionDone(const class ADBDPlayer* Player, EInputInteractionType interactionType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "IsInteractionDone");

	Params::InteractionDefinition_IsInteractionDone Parms{};

	Parms.Player = Player;
	Parms.interactionType = interactionType;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.IsInteractionPossible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputInteractionType                   interactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    performClientCheck                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    performHeightCheck                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isBotPredictionCheck                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionDefinition::IsInteractionPossible(const class ADBDPlayer* Player, EInputInteractionType interactionType, bool performClientCheck, bool performHeightCheck, bool isBotPredictionCheck) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "IsInteractionPossible");

	Params::InteractionDefinition_IsInteractionPossible Parms{};

	Parms.Player = Player;
	Parms.interactionType = interactionType;
	Parms.performClientCheck = performClientCheck;
	Parms.performHeightCheck = performHeightCheck;
	Parms.isBotPredictionCheck = isBotPredictionCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.IsInteractionPossibleBP
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputInteractionType                   interactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionDefinition::IsInteractionPossibleBP(const class ADBDPlayer* Player, EInputInteractionType interactionType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "IsInteractionPossibleBP");

	Params::InteractionDefinition_IsInteractionPossibleBP Parms{};

	Parms.Player = Player;
	Parms.interactionType = interactionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.IsInteractionPossibleClient
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputInteractionType                   interactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionDefinition::IsInteractionPossibleClient(const class ADBDPlayer* Player, EInputInteractionType interactionType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "IsInteractionPossibleClient");

	Params::InteractionDefinition_IsInteractionPossibleClient Parms{};

	Parms.Player = Player;
	Parms.interactionType = interactionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.IsInteractionUsingOffering
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionDefinition::IsInteractionUsingOffering(const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "IsInteractionUsingOffering");

	Params::InteractionDefinition_IsInteractionUsingOffering Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.IsInterruptionPossible
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// const class ADBDPlayer*                 interruptor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ADBDPlayer*                 interruptee                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UInterruptionDefinition*    interruption                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionDefinition::IsInterruptionPossible(const class ADBDPlayer* interruptor, const class ADBDPlayer* interruptee, const class UInterruptionDefinition* interruption) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "IsInterruptionPossible");

	Params::InteractionDefinition_IsInterruptionPossible Parms{};

	Parms.interruptor = interruptor;
	Parms.interruptee = interruptee;
	Parms.interruption = interruption;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.ShouldStartUpdateMontageDuringEnter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Character                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionDefinition::ShouldStartUpdateMontageDuringEnter(const class ADBDPlayer* Character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "ShouldStartUpdateMontageDuringEnter");

	Params::InteractionDefinition_ShouldStartUpdateMontageDuringEnter Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.LanternLightCollectable.SetParentLantern
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ALanternInteractable*             parentLantern                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALanternLightCollectable::SetParentLantern(class ALanternInteractable* parentLantern)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LanternLightCollectable", "SetParentLantern");

	Params::LanternLightCollectable_SetParentLantern Parms{};

	Parms.parentLantern = parentLantern;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Competence.Authority_DecrementToken
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UCompetence::Authority_DecrementToken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Competence", "Authority_DecrementToken");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Competence.Authority_IncrementToken
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UCompetence::Authority_IncrementToken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Competence", "Authority_IncrementToken");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Competence.Authority_SetMaxTokenCount
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompetence::Authority_SetMaxTokenCount(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Competence", "Authority_SetMaxTokenCount");

	Params::Competence_Authority_SetMaxTokenCount Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Competence.Authority_SetPermanentlyDisabled
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Disabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompetence::Authority_SetPermanentlyDisabled(bool Disabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Competence", "Authority_SetPermanentlyDisabled");

	Params::Competence_Authority_SetPermanentlyDisabled Parms{};

	Parms.Disabled = Disabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Competence.Authority_SetTokenCount
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompetence::Authority_SetTokenCount(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Competence", "Authority_SetTokenCount");

	Params::Competence_Authority_SetTokenCount Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Competence.Authority_TriggerCooldownTimer
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Duration                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompetence::Authority_TriggerCooldownTimer(const float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Competence", "Authority_TriggerCooldownTimer");

	Params::Competence_Authority_TriggerCooldownTimer Parms{};

	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Competence.Authority_TriggerHudIconTimer
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompetence::Authority_TriggerHudIconTimer(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Competence", "Authority_TriggerHudIconTimer");

	Params::Competence_Authority_TriggerHudIconTimer Parms{};

	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Competence.OnRep_IsDisabled
// (Final, Native, Private)
// Parameters:
// bool                                    Disabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompetence::OnRep_IsDisabled(bool Disabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Competence", "OnRep_IsDisabled");

	Params::Competence_OnRep_IsDisabled Parms{};

	Parms.Disabled = Disabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Competence.OnRep_TokenCount
// (Final, Native, Private)
// Parameters:
// int32                                   oldCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompetence::OnRep_TokenCount(int32 oldCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Competence", "OnRep_TokenCount");

	Params::Competence_OnRep_TokenCount Parms{};

	Parms.oldCount = oldCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Competence.GetCooldownTimer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTimerObject*                     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTimerObject* UCompetence::GetCooldownTimer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Competence", "GetCooldownTimer");

	Params::Competence_GetCooldownTimer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Competence.GetHudIconTimerElapsedTimePercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCompetence::GetHudIconTimerElapsedTimePercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Competence", "GetHudIconTimerElapsedTimePercent");

	Params::Competence_GetHudIconTimerElapsedTimePercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Competence.GetHudIconTimerRemainingTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCompetence::GetHudIconTimerRemainingTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Competence", "GetHudIconTimerRemainingTime");

	Params::Competence_GetHudIconTimerRemainingTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Competence.GetMaxTokenCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCompetence::GetMaxTokenCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Competence", "GetMaxTokenCount");

	Params::Competence_GetMaxTokenCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Competence.GetPerkIconStrategy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBasePerkIconStrategy*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBasePerkIconStrategy* UCompetence::GetPerkIconStrategy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Competence", "GetPerkIconStrategy");

	Params::Competence_GetPerkIconStrategy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Competence.GetTokenCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCompetence::GetTokenCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Competence", "GetTokenCount");

	Params::Competence_GetTokenCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Competence.IsCooldownTimerDone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCompetence::IsCooldownTimerDone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Competence", "IsCooldownTimerDone");

	Params::Competence_IsCooldownTimerDone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Competence.IsHudIconTimerActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCompetence::IsHudIconTimerActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Competence", "IsHudIconTimerActive");

	Params::Competence_IsHudIconTimerActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Competence.IsHudIconTimerDone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCompetence::IsHudIconTimerDone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Competence", "IsHudIconTimerDone");

	Params::Competence_IsHudIconTimerDone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Competence.IsPermanentlyDisabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCompetence::IsPermanentlyDisabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Competence", "IsPermanentlyDisabled");

	Params::Competence_IsPermanentlyDisabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Competence.OnRep_CooldownTimer
// (Final, Native, Private, Const)

void UCompetence::OnRep_CooldownTimer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Competence", "OnRep_CooldownTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Perk.Authority_SetIsUsable
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerk::Authority_SetIsUsable(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Perk", "Authority_SetIsUsable");

	Params::Perk_Authority_SetIsUsable Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Perk.FireActivePerkEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Percentage                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             chargeCount                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerk::FireActivePerkEvent(const float Percentage, const int32 chargeCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Perk", "FireActivePerkEvent");

	Params::Perk_FireActivePerkEvent Parms{};

	Parms.Percentage = Percentage;
	Parms.chargeCount = chargeCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Perk.GetGameplayModifierData
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayModifierData            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayModifierData UPerk::GetGameplayModifierData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Perk", "GetGameplayModifierData");

	Params::Perk_GetGameplayModifierData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Perk.OnRep_PerkInitializationData
// (Final, Native, Private)

void UPerk::OnRep_PerkInitializationData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Perk", "OnRep_PerkInitializationData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Perk.SetIsUsable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerk::SetIsUsable(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Perk", "SetIsUsable");

	Params::Perk_SetIsUsable Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Perk.GetIsUsable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPerk::GetIsUsable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Perk", "GetIsUsable");

	Params::Perk_GetIsUsable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Perk.GetPerkLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPerk::GetPerkLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Perk", "GetPerkLevel");

	Params::Perk_GetPerkLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Perk.OnRep_IsUsable
// (Final, Native, Private, Const)

void UPerk::OnRep_IsUsable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Perk", "OnRep_IsUsable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CompetenceAction.OnApplyBegin
// (Event, Public, BlueprintEvent)

void UCompetenceAction::OnApplyBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompetenceAction", "OnApplyBegin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.CompetenceAction.OnApplyEnd
// (Event, Public, BlueprintEvent)

void UCompetenceAction::OnApplyEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompetenceAction", "OnApplyEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.CompetenceAction.GetOwningPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UCompetenceAction::GetOwningPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompetenceAction", "GetOwningPlayer");

	Params::CompetenceAction_GetOwningPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Skill.OnRep_SkillInitializationData
// (Final, Native, Private)

void USkill::OnRep_SkillInitializationData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Skill", "OnRep_SkillInitializationData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AnimationPreview.OnAnimationStartFadeOutComplete
// (Final, Native, Private)

void UAnimationPreview::OnAnimationStartFadeOutComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationPreview", "OnAnimationStartFadeOutComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AnimationPreview.OnFadeInComplete
// (Final, Native, Private)

void UAnimationPreview::OnFadeInComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationPreview", "OnFadeInComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AnimationPreview.OnFadeOutForCompletionComplete
// (Final, Native, Private)
// Parameters:
// bool                                    Succeeded                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationPreview::OnFadeOutForCompletionComplete(bool Succeeded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationPreview", "OnFadeOutForCompletionComplete");

	Params::AnimationPreview_OnFadeOutForCompletionComplete Parms{};

	Parms.Succeeded = Succeeded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AnimationPreview.OnRequiredClassesLoaded
// (Final, Native, Private)

void UAnimationPreview::OnRequiredClassesLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationPreview", "OnRequiredClassesLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InteractionAnimationPreview.OnInteractionFinished
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    didInteractionStart                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionAnimationPreview::OnInteractionFinished(class ADBDPlayer* Player, bool didInteractionStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionAnimationPreview", "OnInteractionFinished");

	Params::InteractionAnimationPreview_OnInteractionFinished Parms{};

	Parms.Player = Player;
	Parms.didInteractionStart = didInteractionStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MoriAnimationPreview.OnAudioEventFinished
// (Final, Native, Private)
// Parameters:
// EAkCallbackType                         CallbackType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkCallbackInfo*                  CallbackInfo                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMoriAnimationPreview::OnAudioEventFinished(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoriAnimationPreview", "OnAudioEventFinished");

	Params::MoriAnimationPreview_OnAudioEventFinished Parms{};

	Parms.CallbackType = CallbackType;
	Parms.CallbackInfo = CallbackInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LightFollower.AddFollower
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULightComponent*                  Follower                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightFollower::AddFollower(class ULightComponent* Follower)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightFollower", "AddFollower");

	Params::LightFollower_AddFollower Parms{};

	Parms.Follower = Follower;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LightFollower.SetLeader
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULightComponent*                  Leader                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   maxIntensity                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightFollower::SetLeader(class ULightComponent* Leader, float maxIntensity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightFollower", "SetLeader");

	Params::LightFollower_SetLeader Parms{};

	Parms.Leader = Leader;
	Parms.maxIntensity = maxIntensity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OfferingSequenceAssets.PlayFadeIn
// (Event, Public, BlueprintEvent)

void AOfferingSequenceAssets::PlayFadeIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingSequenceAssets", "PlayFadeIn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.OfferingSequenceAssets.PlayFadeOut
// (Event, Public, BlueprintEvent)

void AOfferingSequenceAssets::PlayFadeOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingSequenceAssets", "PlayFadeOut");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.OfferingSequenceAssets.PlaySmoke
// (Event, Public, BlueprintEvent)

void AOfferingSequenceAssets::PlaySmoke()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingSequenceAssets", "PlaySmoke");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.OfferingSequenceManager.FadeInScreen
// (Final, Native, Private)

void AOfferingSequenceManager::FadeInScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingSequenceManager", "FadeInScreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OfferingSequenceManager.HandleSequenceEnded
// (Event, Protected, BlueprintEvent)

void AOfferingSequenceManager::HandleSequenceEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingSequenceManager", "HandleSequenceEnded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.OfferingSequenceManager.HandleSequenceStarted
// (Event, Protected, BlueprintEvent)

void AOfferingSequenceManager::HandleSequenceStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingSequenceManager", "HandleSequenceStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.OfferingSequenceManager.HandleSequenceStateChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// EOfferingSequenceState                  State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOfferingSequenceManager::HandleSequenceStateChanged(EOfferingSequenceState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingSequenceManager", "HandleSequenceStateChanged");

	Params::OfferingSequenceManager_HandleSequenceStateChanged Parms{};

	Parms.State = State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.OfferingSequenceManager.ContainsDefaultCard
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOfferingSequenceManager::ContainsDefaultCard() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingSequenceManager", "ContainsDefaultCard");

	Params::OfferingSequenceManager_ContainsDefaultCard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.OfferingSequenceManager.ContainsEventCard
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOfferingSequenceManager::ContainsEventCard() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingSequenceManager", "ContainsEventCard");

	Params::OfferingSequenceManager_ContainsEventCard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.OfferingSequenceManager.GetCurrentState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOfferingSequenceState                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOfferingSequenceState AOfferingSequenceManager::GetCurrentState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingSequenceManager", "GetCurrentState");

	Params::OfferingSequenceManager_GetCurrentState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ScreenBase.BroadcastOnHighlightedElementClickedEvent
// (Final, Native, Public)
// Parameters:
// const class FName                       onBoardingID                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScreenBase::BroadcastOnHighlightedElementClickedEvent(const class FName onBoardingID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenBase", "BroadcastOnHighlightedElementClickedEvent");

	Params::ScreenBase_BroadcastOnHighlightedElementClickedEvent Parms{};

	Parms.onBoardingID = onBoardingID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenBase.OnAnimationUpdate
// (Final, Native, Public)
// Parameters:
// int32                                   isAnimationDone_0                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScreenBase::OnAnimationUpdate(int32 isAnimationDone_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenBase", "OnAnimationUpdate");

	Params::ScreenBase_OnAnimationUpdate Parms{};

	Parms.isAnimationDone_0 = isAnimationDone_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenBase.OnAnyKey
// (Final, Native, Public)
// Parameters:
// float                                   Code                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScreenBase::OnAnyKey(float Code)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenBase", "OnAnyKey");

	Params::ScreenBase_OnAnyKey Parms{};

	Parms.Code = Code;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenBase.OnBack
// (Final, Native, Public)

void UScreenBase::OnBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenBase", "OnBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenBase.OnEscape
// (Final, Native, Public)

void UScreenBase::OnEscape()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenBase", "OnEscape");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenBase.OnHideVirtualKeyboardRequested
// (Final, Native, Public)

void UScreenBase::OnHideVirtualKeyboardRequested()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenBase", "OnHideVirtualKeyboardRequested");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenBase.OnNavKey
// (Final, Native, Public)
// Parameters:
// const class FString&                    navKey                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScreenBase::OnNavKey(const class FString& navKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenBase", "OnNavKey");

	Params::ScreenBase_OnNavKey Parms{};

	Parms.navKey = std::move(navKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenBase.OnStart
// (Final, Native, Public)

void UScreenBase::OnStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenBase", "OnStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenBase.OnTextInputMouseClicked
// (Final, Native, Public)
// Parameters:
// bool                                    IsPassword                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScreenBase::OnTextInputMouseClicked(bool IsPassword)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenBase", "OnTextInputMouseClicked");

	Params::ScreenBase_OnTextInputMouseClicked Parms{};

	Parms.IsPassword = IsPassword;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenBase.SetFadesOut
// (Final, Native, Public, Const)
// Parameters:
// bool                                    fadesOut                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScreenBase::SetFadesOut(bool fadesOut) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenBase", "SetFadesOut");

	Params::ScreenBase_SetFadesOut Parms{};

	Parms.fadesOut = fadesOut;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaUtilities.GetAlantaInteractionDescriptionText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UInteractionDefinition*           Interaction                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UAtlantaUtilities::GetAlantaInteractionDescriptionText(class UInteractionDefinition* Interaction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetAlantaInteractionDescriptionText");

	Params::AtlantaUtilities_GetAlantaInteractionDescriptionText Parms{};

	Parms.Interaction = Interaction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetAvailableInteractionOfType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputInteractionType                   interactionInputType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractionDefinition*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionDefinition* UAtlantaUtilities::GetAvailableInteractionOfType(class ADBDPlayer* Player, EInputInteractionType interactionInputType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetAvailableInteractionOfType");

	Params::AtlantaUtilities_GetAvailableInteractionOfType Parms{};

	Parms.Player = Player;
	Parms.interactionInputType = interactionInputType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetCurrencyColor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ECurrencyType                           currencyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSlateColor                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSlateColor UAtlantaUtilities::GetCurrencyColor(ECurrencyType currencyType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetCurrencyColor");

	Params::AtlantaUtilities_GetCurrencyColor Parms{};

	Parms.currencyType = currencyType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetCurrencyUITexturePath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ECurrencyType                           currencyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAtlantaUtilities::GetCurrencyUITexturePath(ECurrencyType currencyType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetCurrencyUITexturePath");

	Params::AtlantaUtilities_GetCurrencyUITexturePath Parms{};

	Parms.currencyType = currencyType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetCurrentInteraction
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractionDefinition*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionDefinition* UAtlantaUtilities::GetCurrentInteraction(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetCurrentInteraction");

	Params::AtlantaUtilities_GetCurrentInteraction Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetCurrentInteractionOfType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputInteractionType                   interactionInputType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractionDefinition*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionDefinition* UAtlantaUtilities::GetCurrentInteractionOfType(class ADBDPlayer* Player, EInputInteractionType interactionInputType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetCurrentInteractionOfType");

	Params::AtlantaUtilities_GetCurrentInteractionOfType Parms{};

	Parms.Player = Player;
	Parms.interactionInputType = interactionInputType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetCurrentOrAvailableInteractionOfType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputInteractionType                   interactionInputType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractionDefinition*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionDefinition* UAtlantaUtilities::GetCurrentOrAvailableInteractionOfType(class ADBDPlayer* Player, EInputInteractionType interactionInputType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetCurrentOrAvailableInteractionOfType");

	Params::AtlantaUtilities_GetCurrentOrAvailableInteractionOfType Parms{};

	Parms.Player = Player;
	Parms.interactionInputType = interactionInputType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetDifficultyLevelText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EAIDifficultyLevel                difficultyLevel                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UAtlantaUtilities::GetDifficultyLevelText(const EAIDifficultyLevel difficultyLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetDifficultyLevelText");

	Params::AtlantaUtilities_GetDifficultyLevelText Parms{};

	Parms.difficultyLevel = difficultyLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetEmblemQualityText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EEmblemQuality                    EmblemQuality                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UAtlantaUtilities::GetEmblemQualityText(const EEmblemQuality EmblemQuality)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetEmblemQualityText");

	Params::AtlantaUtilities_GetEmblemQualityText Parms{};

	Parms.EmblemQuality = EmblemQuality;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetIconImageByPath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    IconPath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UAtlantaUtilities::GetIconImageByPath(const class FString& IconPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetIconImageByPath");

	Params::AtlantaUtilities_GetIconImageByPath Parms{};

	Parms.IconPath = std::move(IconPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetItemAvailabilityText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EItemAvailability                 Availability                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UAtlantaUtilities::GetItemAvailabilityText(const EItemAvailability Availability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetItemAvailabilityText");

	Params::AtlantaUtilities_GetItemAvailabilityText Parms{};

	Parms.Availability = Availability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetItemRarityText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EItemRarity                       Rarity                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UAtlantaUtilities::GetItemRarityText(const EItemRarity Rarity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetItemRarityText");

	Params::AtlantaUtilities_GetItemRarityText Parms{};

	Parms.Rarity = Rarity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetMapSpriteFromPath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    mapSpritePath                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPaperSprite*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPaperSprite* UAtlantaUtilities::GetMapSpriteFromPath(const class FString& mapSpritePath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetMapSpriteFromPath");

	Params::AtlantaUtilities_GetMapSpriteFromPath Parms{};

	Parms.mapSpritePath = std::move(mapSpritePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetOfferingCategoryText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EOfferingCategory                 OfferingCategory                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UAtlantaUtilities::GetOfferingCategoryText(const EOfferingCategory OfferingCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetOfferingCategoryText");

	Params::AtlantaUtilities_GetOfferingCategoryText Parms{};

	Parms.OfferingCategory = OfferingCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetPlayerRoleText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EPlayerRole                       PlayerRole                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UAtlantaUtilities::GetPlayerRoleText(const EPlayerRole PlayerRole)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetPlayerRoleText");

	Params::AtlantaUtilities_GetPlayerRoleText Parms{};

	Parms.PlayerRole = PlayerRole;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetPlayerRoleTextUppercase
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EPlayerRole                       PlayerRole                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UAtlantaUtilities::GetPlayerRoleTextUppercase(const EPlayerRole PlayerRole)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetPlayerRoleTextUppercase");

	Params::AtlantaUtilities_GetPlayerRoleTextUppercase Parms{};

	Parms.PlayerRole = PlayerRole;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetSpriteFromFullPath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    fullSpritePath                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPaperSprite*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPaperSprite* UAtlantaUtilities::GetSpriteFromFullPath(const class FString& fullSpritePath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetSpriteFromFullPath");

	Params::AtlantaUtilities_GetSpriteFromFullPath Parms{};

	Parms.fullSpritePath = std::move(fullSpritePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetSpriteFromPath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    fullDbPathToImage                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    constantDbPathToImageFolder                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    constantPathToSpriteFolder                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPaperSprite*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPaperSprite* UAtlantaUtilities::GetSpriteFromPath(const class FString& fullDbPathToImage, const class FString& constantDbPathToImageFolder, const class FString& constantPathToSpriteFolder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetSpriteFromPath");

	Params::AtlantaUtilities_GetSpriteFromPath Parms{};

	Parms.fullDbPathToImage = std::move(fullDbPathToImage);
	Parms.constantDbPathToImageFolder = std::move(constantDbPathToImageFolder);
	Parms.constantPathToSpriteFolder = std::move(constantPathToSpriteFolder);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.IsPlayerInteractingWithActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::IsPlayerInteractingWithActor(class ADBDPlayer* Player, const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "IsPlayerInteractingWithActor");

	Params::AtlantaUtilities_IsPlayerInteractingWithActor Parms{};

	Parms.Player = Player;
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.LoadTextureByAsset
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UAtlantaUtilities::LoadTextureByAsset(const class FString& Path)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "LoadTextureByAsset");

	Params::AtlantaUtilities_LoadTextureByAsset Parms{};

	Parms.Path = std::move(Path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.MakeBrushFromSprite
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPaperSprite*                     Sprite                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSlateBrush                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSlateBrush UAtlantaUtilities::MakeBrushFromSprite(class UPaperSprite* Sprite)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "MakeBrushFromSprite");

	Params::AtlantaUtilities_MakeBrushFromSprite Parms{};

	Parms.Sprite = Sprite;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.MakeBrushFromTexture
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UTexture2D*                       Texture                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSlateBrush                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSlateBrush UAtlantaUtilities::MakeBrushFromTexture(class UTexture2D* Texture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "MakeBrushFromTexture");

	Params::AtlantaUtilities_MakeBrushFromTexture Parms{};

	Parms.Texture = Texture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.SecondsToStringWithoutDecimals
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             Seconds                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAtlantaUtilities::SecondsToStringWithoutDecimals(const int32 Seconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "SecondsToStringWithoutDecimals");

	Params::AtlantaUtilities_SecondsToStringWithoutDecimals Parms{};

	Parms.Seconds = Seconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.SetButtonStyle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UButton*                          Button                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSlateBrush&               Brush                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAtlantaUtilities::SetButtonStyle(class UButton* Button, const struct FSlateBrush& Brush)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "SetButtonStyle");

	Params::AtlantaUtilities_SetButtonStyle Parms{};

	Parms.Button = Button;
	Parms.Brush = std::move(Brush);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaUtilities.SetImageBrush
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UImage*                           Image                                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       Asset                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMatchSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtlantaUtilities::SetImageBrush(class UImage* Image, class UTexture2D* Asset, bool bMatchSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "SetImageBrush");

	Params::AtlantaUtilities_SetImageBrush Parms{};

	Parms.Image = Image;
	Parms.Asset = Asset;
	Parms.bMatchSize = bMatchSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaUtilities.SetImageBrushFromPath
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UImage*                           Image                                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMatchSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtlantaUtilities::SetImageBrushFromPath(class UImage* Image, const class FString& Path, bool bMatchSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "SetImageBrushFromPath");

	Params::AtlantaUtilities_SetImageBrushFromPath Parms{};

	Parms.Image = Image;
	Parms.Path = std::move(Path);
	Parms.bMatchSize = bMatchSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaUtilities.SetImageBrushFromSpritePath
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UImage*                           Image                                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtlantaUtilities::SetImageBrushFromSpritePath(class UImage* Image, const class FString& Path)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "SetImageBrushFromSpritePath");

	Params::AtlantaUtilities_SetImageBrushFromSpritePath Parms{};

	Parms.Image = Image;
	Parms.Path = std::move(Path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaUtilities.SetImageSlateBrush
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UImage*                           Image                                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSlateBrush&               Brush                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bMatchSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::SetImageSlateBrush(class UImage* Image, const struct FSlateBrush& Brush, bool bMatchSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "SetImageSlateBrush");

	Params::AtlantaUtilities_SetImageSlateBrush Parms{};

	Parms.Image = Image;
	Parms.Brush = std::move(Brush);
	Parms.bMatchSize = bMatchSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDBaseMatchGameMode.GetEndGameComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEndGameComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEndGameComponent* ADBDBaseMatchGameMode::GetEndGameComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBaseMatchGameMode", "GetEndGameComponent");

	Params::DBDBaseMatchGameMode_GetEndGameComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayNotificationManager.FireGameplayNotification
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayNotificationData& notificationData                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    addToHistory                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayNotificationManager::FireGameplayNotification(const struct FGameplayNotificationData& notificationData, bool addToHistory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayNotificationManager", "FireGameplayNotification");

	Params::GameplayNotificationManager_FireGameplayNotification Parms{};

	Parms.notificationData = std::move(notificationData);
	Parms.addToHistory = addToHistory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayNotificationManager.Multicast_FireGameplayNotification
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const class UGameplayModifierContainer* modifierContainer                                      (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    addToHistory                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayNotificationManager::Multicast_FireGameplayNotification(const class UGameplayModifierContainer* modifierContainer, bool addToHistory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayNotificationManager", "Multicast_FireGameplayNotification");

	Params::GameplayNotificationManager_Multicast_FireGameplayNotification Parms{};

	Parms.modifierContainer = modifierContainer;
	Parms.addToHistory = addToHistory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.Authority_AddCharge
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isChargeFromItem                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableInteractionDefinition::Authority_AddCharge(float DeltaSeconds, class ADBDPlayer* Character, bool isChargeFromItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "Authority_AddCharge");

	Params::ChargeableInteractionDefinition_Authority_AddCharge Parms{};

	Parms.DeltaSeconds = DeltaSeconds;
	Parms.Character = Character;
	Parms.isChargeFromItem = isChargeFromItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.Authority_ChargeWithItem
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACollectable*                     Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableInteractionDefinition::Authority_ChargeWithItem(float DeltaSeconds, class ACollectable* Item, class ADBDPlayer* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "Authority_ChargeWithItem");

	Params::ChargeableInteractionDefinition_Authority_ChargeWithItem Parms{};

	Parms.DeltaSeconds = DeltaSeconds;
	Parms.Item = Item;
	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.Authority_ResetCharge
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableInteractionDefinition::Authority_ResetCharge(class ADBDPlayer* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "Authority_ResetCharge");

	Params::ChargeableInteractionDefinition_Authority_ResetCharge Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.OnInteractionCompletionStateChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    complete                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableInteractionDefinition::OnInteractionCompletionStateChanged(class ADBDPlayer* Player, bool complete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "OnInteractionCompletionStateChanged");

	Params::ChargeableInteractionDefinition_OnInteractionCompletionStateChanged Parms{};

	Parms.Player = Player;
	Parms.complete = complete;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.ChargeableInteractionDefinition.OnSkillCheckResponseAesthetic
// (Native, Protected)
// Parameters:
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Bonus                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TriggerLoudNoise                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    hadInput                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableInteractionDefinition::OnSkillCheckResponseAesthetic(bool Success, bool Bonus, class ADBDPlayer* Player, bool TriggerLoudNoise, bool hadInput, ESkillCheckCustomType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "OnSkillCheckResponseAesthetic");

	Params::ChargeableInteractionDefinition_OnSkillCheckResponseAesthetic Parms{};

	Parms.Success = Success;
	Parms.Bonus = Bonus;
	Parms.Player = Player;
	Parms.TriggerLoudNoise = TriggerLoudNoise;
	Parms.hadInput = hadInput;
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.OnSkillCheckResponseAestheticBP
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Bonus                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    hadInput                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableInteractionDefinition::OnSkillCheckResponseAestheticBP(class ADBDPlayer* Player, bool Success, bool Bonus, bool hadInput, ESkillCheckCustomType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "OnSkillCheckResponseAestheticBP");

	Params::ChargeableInteractionDefinition_OnSkillCheckResponseAestheticBP Parms{};

	Parms.Player = Player;
	Parms.Success = Success;
	Parms.Bonus = Bonus;
	Parms.hadInput = hadInput;
	Parms.Type = Type;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.ChargeableInteractionDefinition.OnSkillCheckResponseAuthority
// (Native, Protected)
// Parameters:
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Bonus                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TriggerLoudNoise                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    hadInput                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableInteractionDefinition::OnSkillCheckResponseAuthority(bool Success, bool Bonus, class ADBDPlayer* Player, bool TriggerLoudNoise, bool hadInput, ESkillCheckCustomType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "OnSkillCheckResponseAuthority");

	Params::ChargeableInteractionDefinition_OnSkillCheckResponseAuthority Parms{};

	Parms.Success = Success;
	Parms.Bonus = Bonus;
	Parms.Player = Player;
	Parms.TriggerLoudNoise = TriggerLoudNoise;
	Parms.hadInput = hadInput;
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.OnSkillCheckResponseAuthorityBP
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Bonus                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    hadInput                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableInteractionDefinition::OnSkillCheckResponseAuthorityBP(class ADBDPlayer* Player, bool Success, bool Bonus, bool hadInput, ESkillCheckCustomType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "OnSkillCheckResponseAuthorityBP");

	Params::ChargeableInteractionDefinition_OnSkillCheckResponseAuthorityBP Parms{};

	Parms.Player = Player;
	Parms.Success = Success;
	Parms.Bonus = Bonus;
	Parms.hadInput = hadInput;
	Parms.Type = Type;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.ChargeableInteractionDefinition.SetChargeableComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UChargeableComponent*             ChargeableComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isNullAllowed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableInteractionDefinition::SetChargeableComponent(class UChargeableComponent* ChargeableComponent, bool isNullAllowed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "SetChargeableComponent");

	Params::ChargeableInteractionDefinition_SetChargeableComponent Parms{};

	Parms.ChargeableComponent = ChargeableComponent;
	Parms.isNullAllowed = isNullAllowed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.SetSecondsToCharge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   SecondsToCharge                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableInteractionDefinition::SetSecondsToCharge(float SecondsToCharge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "SetSecondsToCharge");

	Params::ChargeableInteractionDefinition_SetSecondsToCharge Parms{};

	Parms.SecondsToCharge = SecondsToCharge;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.SetSpeedBase
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   speedBase                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableInteractionDefinition::SetSpeedBase(float speedBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "SetSpeedBase");

	Params::ChargeableInteractionDefinition_SetSpeedBase Parms{};

	Parms.speedBase = speedBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.SetTutorialChargeableMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   multiplierValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableInteractionDefinition::SetTutorialChargeableMultiplier(float multiplierValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "SetTutorialChargeableMultiplier");

	Params::ChargeableInteractionDefinition_SetTutorialChargeableMultiplier Parms{};

	Parms.multiplierValue = multiplierValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetAdditiveChargeTimeReductionAsMultiplier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Character                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetAdditiveChargeTimeReductionAsMultiplier(const class ADBDPlayer* Character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetAdditiveChargeTimeReductionAsMultiplier");

	Params::ChargeableInteractionDefinition_GetAdditiveChargeTimeReductionAsMultiplier Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetAdditiveLuckBonus
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Character                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetAdditiveLuckBonus(const class ADBDPlayer* Character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetAdditiveLuckBonus");

	Params::ChargeableInteractionDefinition_GetAdditiveLuckBonus Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetBonusSkillCheckSuccessPercentReward
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetBonusSkillCheckSuccessPercentReward(const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetBonusSkillCheckSuccessPercentReward");

	Params::ChargeableInteractionDefinition_GetBonusSkillCheckSuccessPercentReward Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetBonusSkillCheckZoneSizeModifier
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Character                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetBonusSkillCheckZoneSizeModifier(const class ADBDPlayer* Character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetBonusSkillCheckZoneSizeModifier");

	Params::ChargeableInteractionDefinition_GetBonusSkillCheckZoneSizeModifier Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetChargeableComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UChargeableComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChargeableComponent* UChargeableInteractionDefinition::GetChargeableComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetChargeableComponent");

	Params::ChargeableInteractionDefinition_GetChargeableComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetChargeAmountForTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetChargeAmountForTime(float DeltaSeconds, class ADBDPlayer* Character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetChargeAmountForTime");

	Params::ChargeableInteractionDefinition_GetChargeAmountForTime Parms{};

	Parms.DeltaSeconds = DeltaSeconds;
	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetChargeSpeedModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Character                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetChargeSpeedModifier(const class ADBDPlayer* Character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetChargeSpeedModifier");

	Params::ChargeableInteractionDefinition_GetChargeSpeedModifier Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetGoodSkillCheckSuccessPercentReward
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetGoodSkillCheckSuccessPercentReward(const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetGoodSkillCheckSuccessPercentReward");

	Params::ChargeableInteractionDefinition_GetGoodSkillCheckSuccessPercentReward Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetInteractionChargeSpeedMultiplier
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// const class ADBDPlayer*                 Character                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetInteractionChargeSpeedMultiplier(const class ADBDPlayer* Character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetInteractionChargeSpeedMultiplier");

	Params::ChargeableInteractionDefinition_GetInteractionChargeSpeedMultiplier Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetItemEfficiencyModifier
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Character                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetItemEfficiencyModifier(const class ADBDPlayer* Character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetItemEfficiencyModifier");

	Params::ChargeableInteractionDefinition_GetItemEfficiencyModifier Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetMaxCharge
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetMaxCharge() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetMaxCharge");

	Params::ChargeableInteractionDefinition_GetMaxCharge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetMultiplicativeLuckBonus
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Character                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetMultiplicativeLuckBonus(const class ADBDPlayer* Character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetMultiplicativeLuckBonus");

	Params::ChargeableInteractionDefinition_GetMultiplicativeLuckBonus Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetPerkMultiplier
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Character                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetPerkMultiplier(const class ADBDPlayer* Character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetPerkMultiplier");

	Params::ChargeableInteractionDefinition_GetPerkMultiplier Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetPipsPassed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UChargeableInteractionDefinition::GetPipsPassed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetPipsPassed");

	Params::ChargeableInteractionDefinition_GetPipsPassed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetSkillCheckCharge
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Bonus                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetSkillCheckCharge(class ADBDPlayer* Player, bool Success, bool Bonus, ESkillCheckCustomType Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetSkillCheckCharge");

	Params::ChargeableInteractionDefinition_GetSkillCheckCharge Parms{};

	Parms.Player = Player;
	Parms.Success = Success;
	Parms.Bonus = Bonus;
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetSkillCheckDifficulityModifier
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Character                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetSkillCheckDifficulityModifier(const class ADBDPlayer* Character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetSkillCheckDifficulityModifier");

	Params::ChargeableInteractionDefinition_GetSkillCheckDifficulityModifier Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetSkillCheckFailurePercentPenalty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetSkillCheckFailurePercentPenalty(const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetSkillCheckFailurePercentPenalty");

	Params::ChargeableInteractionDefinition_GetSkillCheckFailurePercentPenalty Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetSkillCheckFailureTimePenalty
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetSkillCheckFailureTimePenalty() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetSkillCheckFailureTimePenalty");

	Params::ChargeableInteractionDefinition_GetSkillCheckFailureTimePenalty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetSkillCheckProbability
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 interactingPlayer                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetSkillCheckProbability(const class ADBDPlayer* interactingPlayer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetSkillCheckProbability");

	Params::ChargeableInteractionDefinition_GetSkillCheckProbability Parms{};

	Parms.interactingPlayer = interactingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetSuccessProbability
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetSuccessProbability() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetSuccessProbability");

	Params::ChargeableInteractionDefinition_GetSuccessProbability Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetTunableValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             tunableValueID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   defaultValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetTunableValue(class FName tunableValueID, float defaultValue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetTunableValue");

	Params::ChargeableInteractionDefinition_GetTunableValue Parms{};

	Parms.tunableValueID = tunableValueID;
	Parms.defaultValue = defaultValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.HasSkillCheckHappened
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Character                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UChargeableInteractionDefinition::HasSkillCheckHappened(const class ADBDPlayer* Character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "HasSkillCheckHappened");

	Params::ChargeableInteractionDefinition_HasSkillCheckHappened Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.IsChargeComplete
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UChargeableInteractionDefinition::IsChargeComplete() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "IsChargeComplete");

	Params::ChargeableInteractionDefinition_IsChargeComplete Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.ShouldShowSpeedProficiencyForMultipleInteractors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UChargeableInteractionDefinition::ShouldShowSpeedProficiencyForMultipleInteractors() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "ShouldShowSpeedProficiencyForMultipleInteractors");

	Params::ChargeableInteractionDefinition_ShouldShowSpeedProficiencyForMultipleInteractors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.BasePerkIconStrategy.GetDisplayPercent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UCompetence*                Competence                                             (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBasePerkIconStrategy::GetDisplayPercent(const class UCompetence* Competence) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePerkIconStrategy", "GetDisplayPercent");

	Params::BasePerkIconStrategy_GetDisplayPercent Parms{};

	Parms.Competence = Competence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.BasePerkIconStrategy.GetIsRechargeable
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UCompetence*                Competence                                             (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBasePerkIconStrategy::GetIsRechargeable(const class UCompetence* Competence) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePerkIconStrategy", "GetIsRechargeable");

	Params::BasePerkIconStrategy_GetIsRechargeable Parms{};

	Parms.Competence = Competence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.BasePerkIconStrategy.GetIsRechargeableActive
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UCompetence*                Competence                                             (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBasePerkIconStrategy::GetIsRechargeableActive(const class UCompetence* Competence) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePerkIconStrategy", "GetIsRechargeableActive");

	Params::BasePerkIconStrategy_GetIsRechargeableActive Parms{};

	Parms.Competence = Competence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.KillerProjectileDodgeComponent.OnKillerProjectileFinished
// (Final, Native, Private)
// Parameters:
// class AActor*                           survivorHit                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerProjectileDodgeComponent::OnKillerProjectileFinished(class AActor* survivorHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerProjectileDodgeComponent", "OnKillerProjectileFinished");

	Params::KillerProjectileDodgeComponent_OnKillerProjectileFinished Parms{};

	Parms.survivorHit = survivorHit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerProjectileDodgeComponent.OnKillerProjectileFinishedWithoutCollision
// (Final, Native, Private)

void UKillerProjectileDodgeComponent::OnKillerProjectileFinishedWithoutCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerProjectileDodgeComponent", "OnKillerProjectileFinishedWithoutCollision");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerProjectileDodgeComponent.OnKillerProjectileLaunched
// (Final, Native, Private)

void UKillerProjectileDodgeComponent::OnKillerProjectileLaunched()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerProjectileDodgeComponent", "OnKillerProjectileLaunched");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SupplyCrateInteractable.OnIsClosing
// (Event, Public, BlueprintEvent)

void ASupplyCrateInteractable::OnIsClosing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SupplyCrateInteractable", "OnIsClosing");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.SupplyCrateInteractable.OnIsOpened
// (Event, Public, BlueprintEvent)

void ASupplyCrateInteractable::OnIsOpened()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SupplyCrateInteractable", "OnIsOpened");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.SupplyCrateInteractable.OnRep_IsAutoClosing
// (Final, Native, Private)

void ASupplyCrateInteractable::OnRep_IsAutoClosing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SupplyCrateInteractable", "OnRep_IsAutoClosing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SupplyCrateInteractable.OnRep_IsOpen
// (Final, Native, Private)

void ASupplyCrateInteractable::OnRep_IsOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SupplyCrateInteractable", "OnRep_IsOpen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerSoundCuesComponent.StartTrackingActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           actorToStartTracking                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             distanceDataID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerSoundCuesComponent::StartTrackingActor(class AActor* actorToStartTracking, class FName distanceDataID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerSoundCuesComponent", "StartTrackingActor");

	Params::KillerSoundCuesComponent_StartTrackingActor Parms{};

	Parms.actorToStartTracking = actorToStartTracking;
	Parms.distanceDataID = distanceDataID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerSoundCuesComponent.StartTrackingActorWithLifetime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           actorToStartTracking                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             distanceDataID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   trackerLifetime                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerSoundCuesComponent::StartTrackingActorWithLifetime(class AActor* actorToStartTracking, class FName distanceDataID, float trackerLifetime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerSoundCuesComponent", "StartTrackingActorWithLifetime");

	Params::KillerSoundCuesComponent_StartTrackingActorWithLifetime Parms{};

	Parms.actorToStartTracking = actorToStartTracking;
	Parms.distanceDataID = distanceDataID;
	Parms.trackerLifetime = trackerLifetime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerSoundCuesComponent.StopTrackingActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           actorToStopTracking                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerSoundCuesComponent::StopTrackingActor(class AActor* actorToStopTracking)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerSoundCuesComponent", "StopTrackingActor");

	Params::KillerSoundCuesComponent_StopTrackingActor Parms{};

	Parms.actorToStopTracking = actorToStopTracking;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DecalSpawnerCollection.CreateDecalSpawner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             decalSpawnerName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               decalMaterial                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PoolSize                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESpawnerStrategyType                    spawnerStrateryType                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDecalSpawner*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDecalSpawner* UDecalSpawnerCollection::CreateDecalSpawner(const class UObject* WorldContextObject, class FName decalSpawnerName, class UMaterialInterface* decalMaterial, int32 PoolSize, ESpawnerStrategyType spawnerStrateryType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecalSpawnerCollection", "CreateDecalSpawner");

	Params::DecalSpawnerCollection_CreateDecalSpawner Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.decalSpawnerName = decalSpawnerName;
	Parms.decalMaterial = decalMaterial;
	Parms.PoolSize = PoolSize;
	Parms.spawnerStrateryType = spawnerStrateryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DecalSpawnerCollection.ReleaseDecalSpawner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             decalSpawnerName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDecalSpawnerCollection::ReleaseDecalSpawner(class FName decalSpawnerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecalSpawnerCollection", "ReleaseDecalSpawner");

	Params::DecalSpawnerCollection_ReleaseDecalSpawner Parms{};

	Parms.decalSpawnerName = decalSpawnerName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DecalSpawnerCollection.SpawnDecalAtLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             decalSpawnerName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   DecalSize                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   LifeSpan                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             decalType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             SortOrder                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDBDDecalComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDBDDecalComponent* UDecalSpawnerCollection::SpawnDecalAtLocation(class FName decalSpawnerName, const struct FVector& DecalSize, const struct FVector& Location, const struct FRotator& Rotation, float LifeSpan, class FName decalType, const int32 SortOrder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecalSpawnerCollection", "SpawnDecalAtLocation");

	Params::DecalSpawnerCollection_SpawnDecalAtLocation Parms{};

	Parms.decalSpawnerName = decalSpawnerName;
	Parms.DecalSize = std::move(DecalSize);
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.LifeSpan = LifeSpan;
	Parms.decalType = decalType;
	Parms.SortOrder = SortOrder;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AISense_UnclearHearing.ReportUnclearNoiseEvent
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NoiseLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Loudness                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAISense_UnclearHearing::ReportUnclearNoiseEvent(class UObject* WorldContextObject, const struct FVector& NoiseLocation, float Loudness, class AActor* Instigator, float MaxRange, class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AISense_UnclearHearing", "ReportUnclearNoiseEvent");

	Params::AISense_UnclearHearing_ReportUnclearNoiseEvent Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.NoiseLocation = std::move(NoiseLocation);
	Parms.Loudness = Loudness;
	Parms.Instigator = Instigator;
	Parms.MaxRange = MaxRange;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemModifier.AuthoritySetItemCount
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   itemCount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemModifier::AuthoritySetItemCount(int32 itemCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemModifier", "AuthoritySetItemCount");

	Params::ItemModifier_AuthoritySetItemCount Parms{};

	Parms.itemCount = itemCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemModifier.AuthoritySetItemEnergy
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   energy                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemModifier::AuthoritySetItemEnergy(float energy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemModifier", "AuthoritySetItemEnergy");

	Params::ItemModifier_AuthoritySetItemEnergy Parms{};

	Parms.energy = energy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemModifier.AuthoritySetItemMaxEnergy
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   energy                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemModifier::AuthoritySetItemMaxEnergy(float energy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemModifier", "AuthoritySetItemMaxEnergy");

	Params::ItemModifier_AuthoritySetItemMaxEnergy Parms{};

	Parms.energy = energy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemModifier.HandleIncreaseCharge
// (Final, Native, Public, BlueprintCallable)

void UItemModifier::HandleIncreaseCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemModifier", "HandleIncreaseCharge");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemModifier.HandleIncreaseItemCount
// (Final, Native, Public, BlueprintCallable)

void UItemModifier::HandleIncreaseItemCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemModifier", "HandleIncreaseItemCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemModifier.HandleIncreaseMaxCharge
// (Final, Native, Public, BlueprintCallable)

void UItemModifier::HandleIncreaseMaxCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemModifier", "HandleIncreaseMaxCharge");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemModifier.GetBaseItem
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACollectable*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACollectable* UItemModifier::GetBaseItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemModifier", "GetBaseItem");

	Params::ItemModifier_GetBaseItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ItemModifier.GetItemCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UItemModifier::GetItemCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemModifier", "GetItemCount");

	Params::ItemModifier_GetItemCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ItemModifier.GetItemEnergy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UItemModifier::GetItemEnergy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemModifier", "GetItemEnergy");

	Params::ItemModifier_GetItemEnergy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ItemModifier.GetItemMaxEnergy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UItemModifier::GetItemMaxEnergy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemModifier", "GetItemMaxEnergy");

	Params::ItemModifier_GetItemMaxEnergy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SurvivorHitCosmeticHandler.OnMontageStarted
// (Final, Native, Private)
// Parameters:
// const struct FAnimationMontageDescriptor&animMontageID                                          (ConstParm, Parm, NativeAccessSpecifierPublic)
// const float                             PlayRate                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorHitCosmeticHandler::OnMontageStarted(const struct FAnimationMontageDescriptor& animMontageID, const float PlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorHitCosmeticHandler", "OnMontageStarted");

	Params::SurvivorHitCosmeticHandler_OnMontageStarted Parms{};

	Parms.animMontageID = std::move(animMontageID);
	Parms.PlayRate = PlayRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemAddon.Authority_ApplyMetaModifiers
// (Final, Native, Private)

void UItemAddon::Authority_ApplyMetaModifiers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "Authority_ApplyMetaModifiers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemAddon.Authority_DecrementToken
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UItemAddon::Authority_DecrementToken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "Authority_DecrementToken");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemAddon.Authority_IncrementToken
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UItemAddon::Authority_IncrementToken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "Authority_IncrementToken");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemAddon.Authority_OnCollectableDropped
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemAddon::Authority_OnCollectableDropped(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "Authority_OnCollectableDropped");

	Params::ItemAddon_Authority_OnCollectableDropped Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemAddon.Authority_OnCollectablePickedUp
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemAddon::Authority_OnCollectablePickedUp(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "Authority_OnCollectablePickedUp");

	Params::ItemAddon_Authority_OnCollectablePickedUp Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemAddon.Authority_SetMaxTokenCount
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemAddon::Authority_SetMaxTokenCount(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "Authority_SetMaxTokenCount");

	Params::ItemAddon_Authority_SetMaxTokenCount Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemAddon.Authority_SetTokenCount
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemAddon::Authority_SetTokenCount(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "Authority_SetTokenCount");

	Params::ItemAddon_Authority_SetTokenCount Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemAddon.DebugPrintStats
// (Event, Public, BlueprintEvent)

void UItemAddon::DebugPrintStats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "DebugPrintStats");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.ItemAddon.OnPostItemAddonsCreation
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACollectable*                     Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemAddon::OnPostItemAddonsCreation(class ADBDPlayer* Player, class ACollectable* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "OnPostItemAddonsCreation");

	Params::ItemAddon_OnPostItemAddonsCreation Parms{};

	Parms.Player = Player;
	Parms.Item = Item;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.ItemAddon.OnRep_AddonInitializationData
// (Final, Native, Private)

void UItemAddon::OnRep_AddonInitializationData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "OnRep_AddonInitializationData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemAddon.OnRep_BaseItem
// (Final, Native, Private)

void UItemAddon::OnRep_BaseItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "OnRep_BaseItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemAddon.OnRep_TokenCount
// (Native, Protected)
// Parameters:
// int32                                   oldCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemAddon::OnRep_TokenCount(int32 oldCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "OnRep_TokenCount");

	Params::ItemAddon_OnRep_TokenCount Parms{};

	Parms.oldCount = oldCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemAddon.SetUpAddon
// (Event, Protected, BlueprintEvent)

void UItemAddon::SetUpAddon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "SetUpAddon");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.ItemAddon.GetMaxTokenCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UItemAddon::GetMaxTokenCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "GetMaxTokenCount");

	Params::ItemAddon_GetMaxTokenCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ItemAddon.GetTokenCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UItemAddon::GetTokenCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "GetTokenCount");

	Params::ItemAddon_GetTokenCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ItemAddon.IsReadyForSetUp
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemAddon::IsReadyForSetUp() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "IsReadyForSetUp");

	Params::ItemAddon_IsReadyForSetUp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ItemAddon.IsSecondaryAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemAddon::IsSecondaryAction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "IsSecondaryAction");

	Params::ItemAddon_IsSecondaryAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StateMachine.Multicast_SetStateStack
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const TArray<uint16>&                   netStateIDStack                                        (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UStateMachine::Multicast_SetStateStack(const TArray<uint16>& netStateIDStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateMachine", "Multicast_SetStateStack");

	Params::StateMachine_Multicast_SetStateStack Parms{};

	Parms.netStateIDStack = std::move(netStateIDStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StateMachine.NetIDStackChanged
// (Final, Native, Private)

void UStateMachine::NetIDStackChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateMachine", "NetIDStackChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StateMachine.Server_SetStateStack
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// const TArray<uint16>&                   netStateIDStack                                        (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UStateMachine::Server_SetStateStack(const TArray<uint16>& netStateIDStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateMachine", "Server_SetStateStack");

	Params::StateMachine_Server_SetStateStack Parms{};

	Parms.netStateIDStack = std::move(netStateIDStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerStateMachine.Multicast_DeniedStateChange
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// const struct FPlayerStateMachineTransitionData&rejectedStateStack                                     (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<uint16>&                   serverCurrentStateStack                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UPlayerStateMachine::Multicast_DeniedStateChange(const struct FPlayerStateMachineTransitionData& rejectedStateStack, const TArray<uint16>& serverCurrentStateStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateMachine", "Multicast_DeniedStateChange");

	Params::PlayerStateMachine_Multicast_DeniedStateChange Parms{};

	Parms.rejectedStateStack = std::move(rejectedStateStack);
	Parms.serverCurrentStateStack = std::move(serverCurrentStateStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerStateMachine.Multicast_SetStateStackImmediate
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// const TArray<uint16>&                   netStateIDStack                                        (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UPlayerStateMachine::Multicast_SetStateStackImmediate(const TArray<uint16>& netStateIDStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateMachine", "Multicast_SetStateStackImmediate");

	Params::PlayerStateMachine_Multicast_SetStateStackImmediate Parms{};

	Parms.netStateIDStack = std::move(netStateIDStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAttack.Client_ReceiveAttackSubstateRequestResult
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// const struct FAttackSubstateRequestResult&Result                                                 (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)

void UDBDAttack::Client_ReceiveAttackSubstateRequestResult(const struct FAttackSubstateRequestResult& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttack", "Client_ReceiveAttackSubstateRequestResult");

	Params::DBDAttack_Client_ReceiveAttackSubstateRequestResult Parms{};

	Parms.Result = std::move(Result);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAttack.Client_ReceiveHitResult
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// class ACharacter*                       Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsValid                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FActionPredictionKey&      PredictionKey                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDAttack::Client_ReceiveHitResult(class ACharacter* Target, bool IsValid, const struct FActionPredictionKey& PredictionKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttack", "Client_ReceiveHitResult");

	Params::DBDAttack_Client_ReceiveHitResult Parms{};

	Parms.Target = Target;
	Parms.IsValid = IsValid;
	Parms.PredictionKey = std::move(PredictionKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAttack.Local_OnMovementChanged
// (Final, Native, Protected)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           PrevMovementMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PreviousCustomMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDAttack::Local_OnMovementChanged(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttack", "Local_OnMovementChanged");

	Params::DBDAttack_Local_OnMovementChanged Parms{};

	Parms.Character = Character;
	Parms.PrevMovementMode = PrevMovementMode;
	Parms.PreviousCustomMode = PreviousCustomMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAttack.Multicast_ClearTargets
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void UDBDAttack::Multicast_ClearTargets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttack", "Multicast_ClearTargets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAttack.Multicast_HitAttackableComponent
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class UAttackableComponent*             AttackableComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDAttack::Multicast_HitAttackableComponent(class UAttackableComponent* AttackableComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttack", "Multicast_HitAttackableComponent");

	Params::DBDAttack_Multicast_HitAttackableComponent Parms{};

	Parms.AttackableComponent = AttackableComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAttack.Multicast_HitTarget
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ACharacter*                       Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    hitCosmeticOnly                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDAttack::Multicast_HitTarget(class ACharacter* Target, bool hitCosmeticOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttack", "Multicast_HitTarget");

	Params::DBDAttack_Multicast_HitTarget Parms{};

	Parms.Target = Target;
	Parms.hitCosmeticOnly = hitCosmeticOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAttack.Multicast_RequestStateChange
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const EAttackSubstate                   State                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDAttack::Multicast_RequestStateChange(const EAttackSubstate State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttack", "Multicast_RequestStateChange");

	Params::DBDAttack_Multicast_RequestStateChange Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAttack.Multicast_SendPostHitTargetData
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ADBDPlayer*                       owningKiller                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPreAttackData&            PreAttackData                                          (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FPostAttackData&           PostAttackData                                         (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDBDAttack::Multicast_SendPostHitTargetData(class ADBDPlayer* owningKiller, class ADBDPlayer* Target, const struct FPreAttackData& PreAttackData, const struct FPostAttackData& PostAttackData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttack", "Multicast_SendPostHitTargetData");

	Params::DBDAttack_Multicast_SendPostHitTargetData Parms{};

	Parms.owningKiller = owningKiller;
	Parms.Target = Target;
	Parms.PreAttackData = std::move(PreAttackData);
	Parms.PostAttackData = std::move(PostAttackData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAttack.Server_ClearTargets
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void UDBDAttack::Server_ClearTargets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttack", "Server_ClearTargets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAttack.Server_HitDestroyableActorAttackableComponent
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class UAttackableComponent*             AttackableComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDAttack::Server_HitDestroyableActorAttackableComponent(class UAttackableComponent* AttackableComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttack", "Server_HitDestroyableActorAttackableComponent");

	Params::DBDAttack_Server_HitDestroyableActorAttackableComponent Parms{};

	Parms.AttackableComponent = AttackableComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAttack.Server_HitTarget
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// class ACharacter*                       Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             TargetLocationTimestamp                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FActionPredictionKey&      PredictionKey                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDAttack::Server_HitTarget(class ACharacter* Target, const float TargetLocationTimestamp, const struct FActionPredictionKey& PredictionKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttack", "Server_HitTarget");

	Params::DBDAttack_Server_HitTarget Parms{};

	Parms.Target = Target;
	Parms.TargetLocationTimestamp = TargetLocationTimestamp;
	Parms.PredictionKey = std::move(PredictionKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAttack.Server_RequestStateChange
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// const EAttackSubstate                   State                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDAttack::Server_RequestStateChange(const EAttackSubstate State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttack", "Server_RequestStateChange");

	Params::DBDAttack_Server_RequestStateChange Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAttack.GetAttackSubstate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const EAttackSubstate                   State                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDBDAttackSubstate*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDBDAttackSubstate* UDBDAttack::GetAttackSubstate(const EAttackSubstate State) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttack", "GetAttackSubstate");

	Params::DBDAttack_GetAttackSubstate Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SurvivorBloodFXComponent.SpawnBloodSpurts
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UNiagaraComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraComponent* USurvivorBloodFXComponent::SpawnBloodSpurts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorBloodFXComponent", "SpawnBloodSpurts");

	Params::SurvivorBloodFXComponent_SpawnBloodSpurts Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SpecialBehaviourInteractable.OnRep_SpecialBehaviourOwner
// (Final, Native, Private)

void ASpecialBehaviourInteractable::OnRep_SpecialBehaviourOwner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpecialBehaviourInteractable", "OnRep_SpecialBehaviourOwner");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SpecialBehaviourInteractable.GetOwnerPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* ASpecialBehaviourInteractable::GetOwnerPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpecialBehaviourInteractable", "GetOwnerPlayer");

	Params::SpecialBehaviourInteractable_GetOwnerPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDTunableUtilities.GetEndGameTunableValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             valueName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDTunableUtilities::GetEndGameTunableValue(const class UObject* WorldContextObject, class FName valueName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDTunableUtilities", "GetEndGameTunableValue");

	Params::DBDTunableUtilities_GetEndGameTunableValue Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.valueName = valueName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDTunableUtilities.GetSlasherTunableValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             valueName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDTunableUtilities::GetSlasherTunableValue(const class UObject* WorldContextObject, class FName valueName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDTunableUtilities", "GetSlasherTunableValue");

	Params::DBDTunableUtilities_GetSlasherTunableValue Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.valueName = valueName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDTunableUtilities.GetTunableRowHandleValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDBDTunableRowHandle&      rowHandle                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDTunableUtilities::GetTunableRowHandleValue(const struct FDBDTunableRowHandle& rowHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDTunableUtilities", "GetTunableRowHandleValue");

	Params::DBDTunableUtilities_GetTunableRowHandleValue Parms{};

	Parms.rowHandle = std::move(rowHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDTunableUtilities.GetTunableValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             valueName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDTunableUtilities::GetTunableValue(const class UObject* WorldContextObject, class FName valueName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDTunableUtilities", "GetTunableValue");

	Params::DBDTunableUtilities_GetTunableValue Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.valueName = valueName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameObjectiveBase.OnRep_IsCompleted
// (Final, Native, Protected)
// Parameters:
// bool                                    wasCompleted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameObjectiveBase::OnRep_IsCompleted(bool wasCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameObjectiveBase", "OnRep_IsCompleted");

	Params::GameObjectiveBase_OnRep_IsCompleted Parms{};

	Parms.wasCompleted = wasCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillInteractionDefinition.OnMoriCancelled
// (Event, Protected, BlueprintEvent)

void UKillInteractionDefinition::OnMoriCancelled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillInteractionDefinition", "OnMoriCancelled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.KillInteractionDefinition.GetChargeCompleted
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKillInteractionDefinition::GetChargeCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillInteractionDefinition", "GetChargeCompleted");

	Params::KillInteractionDefinition_GetChargeCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.KillInteractionDefinition.GetExitAnimationMontage
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// struct FAnimationMontageDescriptor      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAnimationMontageDescriptor UKillInteractionDefinition::GetExitAnimationMontage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillInteractionDefinition", "GetExitAnimationMontage");

	Params::KillInteractionDefinition_GetExitAnimationMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.KillInteractionDefinition.GetOriginatingKiller
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AKiller*                    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class AKiller* UKillInteractionDefinition::GetOriginatingKiller() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillInteractionDefinition", "GetOriginatingKiller");

	Params::KillInteractionDefinition_GetOriginatingKiller Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.KillInteractionDefinition.GetOwningSurvivor
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ASurvivor*                  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class ASurvivor* UKillInteractionDefinition::GetOwningSurvivor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillInteractionDefinition", "GetOwningSurvivor");

	Params::KillInteractionDefinition_GetOwningSurvivor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.KillInteractionDefinition.IsKillerAllowedToKillSurvivor
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// const class AKiller*                    Killer                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ASurvivor*                  Survivor                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKillInteractionDefinition::IsKillerAllowedToKillSurvivor(const class AKiller* Killer, const class ASurvivor* Survivor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillInteractionDefinition", "IsKillerAllowedToKillSurvivor");

	Params::KillInteractionDefinition_IsKillerAllowedToKillSurvivor Parms{};

	Parms.Killer = Killer;
	Parms.Survivor = Survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AICharacterRepairGeneratorBehaviour.OnGeneratorRepairedEventHandler
// (Final, Native, Private)
// Parameters:
// bool                                    isAutoCompleted                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAICharacterRepairGeneratorBehaviour::OnGeneratorRepairedEventHandler(bool isAutoCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterRepairGeneratorBehaviour", "OnGeneratorRepairedEventHandler");

	Params::AICharacterRepairGeneratorBehaviour_OnGeneratorRepairedEventHandler Parms{};

	Parms.isAutoCompleted = isAutoCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AICharacterRepairGeneratorBehaviour.OnMovementFinished
// (Final, Native, Private)
// Parameters:
// const struct FAIRequestID&              RequestID                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// EPathFollowingResult                    Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAICharacterRepairGeneratorBehaviour::OnMovementFinished(const struct FAIRequestID& RequestID, EPathFollowingResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterRepairGeneratorBehaviour", "OnMovementFinished");

	Params::AICharacterRepairGeneratorBehaviour_OnMovementFinished Parms{};

	Parms.RequestID = std::move(RequestID);
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplaySpawnerComponent.OnRep_SpawnedComponents
// (Final, Native, Private)

void UGameplaySpawnerComponent::OnRep_SpawnedComponents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplaySpawnerComponent", "OnRep_SpawnedComponents");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorTrapPerk.Authority_OnKillerInteracted
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayTag&              GameEventTag                                           (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void USurvivorTrapPerk::Authority_OnKillerInteracted(const struct FGameplayTag& GameEventTag, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorTrapPerk", "Authority_OnKillerInteracted");

	Params::SurvivorTrapPerk_Authority_OnKillerInteracted Parms{};

	Parms.GameEventTag = std::move(GameEventTag);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorTrapPerk.Authority_OnRepairProgress
// (Final, Native, Private)
// Parameters:
// float                                   IndividualChargeAmount                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TotalChargeAmount                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ChargeInstigator                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    WasCoop                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorTrapPerk::Authority_OnRepairProgress(float IndividualChargeAmount, float TotalChargeAmount, class AActor* ChargeInstigator, bool WasCoop, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorTrapPerk", "Authority_OnRepairProgress");

	Params::SurvivorTrapPerk_Authority_OnRepairProgress Parms{};

	Parms.IndividualChargeAmount = IndividualChargeAmount;
	Parms.TotalChargeAmount = TotalChargeAmount;
	Parms.ChargeInstigator = ChargeInstigator;
	Parms.WasCoop = WasCoop;
	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorTrapPerk.Authority_OnSurvivorRemoved
// (Final, Native, Private)
// Parameters:
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorTrapPerk::Authority_OnSurvivorRemoved(class ASurvivor* Survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorTrapPerk", "Authority_OnSurvivorRemoved");

	Params::SurvivorTrapPerk_Authority_OnSurvivorRemoved Parms{};

	Parms.Survivor = Survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorTrapPerk.Authority_OnTrapInteractionEvent
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              GameEvent                                              (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void USurvivorTrapPerk::Authority_OnTrapInteractionEvent(const struct FGameplayTag& GameEvent, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorTrapPerk", "Authority_OnTrapInteractionEvent");

	Params::SurvivorTrapPerk_Authority_OnTrapInteractionEvent Parms{};

	Parms.GameEvent = std::move(GameEvent);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorTrapPerk.Authority_OnTrapTimerDone
// (Final, Native, Private)

void USurvivorTrapPerk::Authority_OnTrapTimerDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorTrapPerk", "Authority_OnTrapTimerDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorTrapPerk.OnRep_TrappedInteractable
// (Final, Native, Private)
// Parameters:
// class AInteractable*                    oldInteractable                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorTrapPerk::OnRep_TrappedInteractable(class AInteractable* oldInteractable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorTrapPerk", "OnRep_TrappedInteractable");

	Params::SurvivorTrapPerk_OnRep_TrappedInteractable Parms{};

	Parms.oldInteractable = oldInteractable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorTrapPerk.GetPerkTrappableComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AInteractable*                    Interactable                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPerkTrappableComponent*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPerkTrappableComponent* USurvivorTrapPerk::GetPerkTrappableComponent(class AInteractable* Interactable) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorTrapPerk", "GetPerkTrappableComponent");

	Params::SurvivorTrapPerk_GetPerkTrappableComponent Parms{};

	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SurvivorTrapPerk.GetRepairProgressPercent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USurvivorTrapPerk::GetRepairProgressPercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorTrapPerk", "GetRepairProgressPercent");

	Params::SurvivorTrapPerk_GetRepairProgressPercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SurvivorTrapPerk.GetRequiredRepairProgressForActivation
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USurvivorTrapPerk::GetRequiredRepairProgressForActivation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorTrapPerk", "GetRequiredRepairProgressForActivation");

	Params::SurvivorTrapPerk_GetRequiredRepairProgressForActivation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SurvivorTrapPerk.GetTrapDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USurvivorTrapPerk::GetTrapDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorTrapPerk", "GetTrapDuration");

	Params::SurvivorTrapPerk_GetTrapDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.BloodwebManager.Init
// (Final, Native, Public)
// Parameters:
// class UDBDGameInstance*                 GameInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBloodwebManager::Init(class UDBDGameInstance* GameInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodwebManager", "Init");

	Params::BloodwebManager_Init Parms{};

	Parms.GameInstance = GameInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BlindableBaseComponent.Authority_AddBlindingEffector
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IBlindingEffectorInterface>effector                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlindableBaseComponent::Authority_AddBlindingEffector(TScriptInterface<class IBlindingEffectorInterface> effector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlindableBaseComponent", "Authority_AddBlindingEffector");

	Params::BlindableBaseComponent_Authority_AddBlindingEffector Parms{};

	Parms.effector = effector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BlindableBaseComponent.Authority_Blinded
// (Native, Public, BlueprintCallable)
// Parameters:
// EBlindType                              blindType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlindnessDuration                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           effectorActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlindableBaseComponent::Authority_Blinded(EBlindType blindType, float BlindnessDuration, class AActor* effectorActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlindableBaseComponent", "Authority_Blinded");

	Params::BlindableBaseComponent_Authority_Blinded Parms{};

	Parms.blindType = blindType;
	Parms.BlindnessDuration = BlindnessDuration;
	Parms.effectorActor = effectorActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BlindableBaseComponent.Authority_RemoveBlindingEffector
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IBlindingEffectorInterface>effector                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlindableBaseComponent::Authority_RemoveBlindingEffector(TScriptInterface<class IBlindingEffectorInterface> effector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlindableBaseComponent", "Authority_RemoveBlindingEffector");

	Params::BlindableBaseComponent_Authority_RemoveBlindingEffector Parms{};

	Parms.effector = effector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BlindableBaseComponent.OnChargeableCompletionPercentChanged
// (Final, Native, Private)
// Parameters:
// class UChargeableComponent*             ChargeableComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TotalPercentComplete                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlindableBaseComponent::OnChargeableCompletionPercentChanged(class UChargeableComponent* ChargeableComponent, float TotalPercentComplete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlindableBaseComponent", "OnChargeableCompletionPercentChanged");

	Params::BlindableBaseComponent_OnChargeableCompletionPercentChanged Parms{};

	Parms.ChargeableComponent = ChargeableComponent;
	Parms.TotalPercentComplete = TotalPercentComplete;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BlindableBaseComponent.OnRep_IsBlinded
// (Final, Native, Private)

void UBlindableBaseComponent::OnRep_IsBlinded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlindableBaseComponent", "OnRep_IsBlinded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BlindableBaseComponent.SetChargeable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UChargeableComponent*             Value                                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlindableBaseComponent::SetChargeable(class UChargeableComponent* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlindableBaseComponent", "SetChargeable");

	Params::BlindableBaseComponent_SetChargeable Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BlindableBaseComponent.IsBlinded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlindableBaseComponent::IsBlinded() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlindableBaseComponent", "IsBlinded");

	Params::BlindableBaseComponent_IsBlinded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.RBTOutlineUpdateStrategy.IsRevealedToLocalPlayer_BP
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBTOutlineUpdateStrategy::IsRevealedToLocalPlayer_BP(const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTOutlineUpdateStrategy", "IsRevealedToLocalPlayer_BP");

	Params::RBTOutlineUpdateStrategy_IsRevealedToLocalPlayer_BP Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.BlindingFXComponent.SetPostProcess
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPostProcessComponent*            Value                                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlindingFXComponent::SetPostProcess(class UPostProcessComponent* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlindingFXComponent", "SetPostProcess");

	Params::BlindingFXComponent_SetPostProcess Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BlindingFXComponent.SetPostProcessMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         Value                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlindingFXComponent::SetPostProcessMaterial(class UMaterialInstanceDynamic* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlindingFXComponent", "SetPostProcessMaterial");

	Params::BlindingFXComponent_SetPostProcessMaterial Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerRedStainUpdateStrategy.OnHeadHiddenChanged
// (Final, Native, Private)
// Parameters:
// bool                                    IsHidden                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerRedStainUpdateStrategy::OnHeadHiddenChanged(bool IsHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerRedStainUpdateStrategy", "OnHeadHiddenChanged");

	Params::KillerRedStainUpdateStrategy_OnHeadHiddenChanged Parms{};

	Parms.IsHidden = IsHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerBlindingFXComponent.Multicast_OnBlindedByPlayersCosmetic
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const TArray<class ADBDPlayer*>&        Players                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKillerBlindingFXComponent::Multicast_OnBlindedByPlayersCosmetic(const TArray<class ADBDPlayer*>& Players)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerBlindingFXComponent", "Multicast_OnBlindedByPlayersCosmetic");

	Params::KillerBlindingFXComponent_Multicast_OnBlindedByPlayersCosmetic Parms{};

	Parms.Players = std::move(Players);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MapSpecificLocalPlayerEffects.Local_SpawnOnLocalCamera
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UCameraComponent*                 localCamera                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapSpecificLocalPlayerEffects::Local_SpawnOnLocalCamera(class UCameraComponent* localCamera)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSpecificLocalPlayerEffects", "Local_SpawnOnLocalCamera");

	Params::MapSpecificLocalPlayerEffects_Local_SpawnOnLocalCamera Parms{};

	Parms.localCamera = localCamera;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.MapSpecificLocalPlayerEffects.OnObservedActorChanged
// (Final, Native, Protected)

void UMapSpecificLocalPlayerEffects::OnObservedActorChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSpecificLocalPlayerEffects", "OnObservedActorChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.VaultDefinition.IsWindowVaultable
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVaultDefinition::IsWindowVaultable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VaultDefinition", "IsWindowVaultable");

	Params::VaultDefinition_IsWindowVaultable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.VaultDefinition.IsWithinHeightDelta
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVaultDefinition::IsWithinHeightDelta(const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VaultDefinition", "IsWithinHeightDelta");

	Params::VaultDefinition_IsWithinHeightDelta Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.VaultDefinition.ShouldLaunchCharacter
// (Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVaultDefinition::ShouldLaunchCharacter(const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VaultDefinition", "ShouldLaunchCharacter");

	Params::VaultDefinition_ShouldLaunchCharacter Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AutomaticLeanComponent.Local_Lean
// (Final, Native, Public, BlueprintCallable)

void UAutomaticLeanComponent::Local_Lean()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomaticLeanComponent", "Local_Lean");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AutomaticLeanComponent.Local_Unlean
// (Final, Native, Public, BlueprintCallable)

void UAutomaticLeanComponent::Local_Unlean()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomaticLeanComponent", "Local_Unlean");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AutomaticLeanComponent.OnRep_LeanState
// (Final, Native, Private)

void UAutomaticLeanComponent::OnRep_LeanState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomaticLeanComponent", "OnRep_LeanState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AutomaticLeanComponent.Server_SetLeanState
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// ELeanState                              leanState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAutomaticLeanComponent::Server_SetLeanState(ELeanState leanState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomaticLeanComponent", "Server_SetLeanState");

	Params::AutomaticLeanComponent_Server_SetLeanState Parms{};

	Parms.leanState = leanState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AutomaticLeanComponent.CanInitiateLean
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAutomaticLeanComponent::CanInitiateLean() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomaticLeanComponent", "CanInitiateLean");

	Params::AutomaticLeanComponent_CanInitiateLean Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AutomaticLeanComponent.GetAvailableDistanceInFrontOfCamera
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAutomaticLeanComponent::GetAvailableDistanceInFrontOfCamera() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomaticLeanComponent", "GetAvailableDistanceInFrontOfCamera");

	Params::AutomaticLeanComponent_GetAvailableDistanceInFrontOfCamera Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AutomaticLeanComponent.GetLeanState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELeanState                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELeanState UAutomaticLeanComponent::GetLeanState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomaticLeanComponent", "GetLeanState");

	Params::AutomaticLeanComponent_GetLeanState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AutomaticLeanComponent.GetPotentialLeanState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELeanState                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELeanState UAutomaticLeanComponent::GetPotentialLeanState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomaticLeanComponent", "GetPotentialLeanState");

	Params::AutomaticLeanComponent_GetPotentialLeanState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AutomaticLeanComponent.IsLeaning
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAutomaticLeanComponent::IsLeaning() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomaticLeanComponent", "IsLeaning");

	Params::AutomaticLeanComponent_IsLeaning Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DecalSpawner.GetSpawnerStrategy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USpawnerStrategy*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USpawnerStrategy* UDecalSpawner::GetSpawnerStrategy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecalSpawner", "GetSpawnerStrategy");

	Params::DecalSpawner_GetSpawnerStrategy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDAIController.AbilityTwoRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECharacterMovementTypes                 MovementMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::AbilityTwoRequest(const class UObject* requester, ECharacterMovementTypes MovementMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "AbilityTwoRequest");

	Params::DBDAIController_AbilityTwoRequest Parms{};

	Parms.requester = requester;
	Parms.MovementMode = MovementMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.ActionRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::ActionRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "ActionRequest");

	Params::DBDAIController_ActionRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.AttackRequest
// (Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::AttackRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "AttackRequest");

	Params::DBDAIController_AttackRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.CancelMinigameRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::CancelMinigameRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "CancelMinigameRequest");

	Params::DBDAIController_CancelMinigameRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.CrouchRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::CrouchRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "CrouchRequest");

	Params::DBDAIController_CrouchRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.DropItemRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::DropItemRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "DropItemRequest");

	Params::DBDAIController_DropItemRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.EndAbilityTwoRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::EndAbilityTwoRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "EndAbilityTwoRequest");

	Params::DBDAIController_EndAbilityTwoRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.EndActionRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::EndActionRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "EndActionRequest");

	Params::DBDAIController_EndActionRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.EndCrouchRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::EndCrouchRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "EndCrouchRequest");

	Params::DBDAIController_EndCrouchRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.EndDropItemRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::EndDropItemRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "EndDropItemRequest");

	Params::DBDAIController_EndDropItemRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.EndEventAbilityRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::EndEventAbilityRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "EndEventAbilityRequest");

	Params::DBDAIController_EndEventAbilityRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.EndFastInteractRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::EndFastInteractRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "EndFastInteractRequest");

	Params::DBDAIController_EndFastInteractRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.EndInteractRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::EndInteractRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "EndInteractRequest");

	Params::DBDAIController_EndInteractRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.EndRunRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::EndRunRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "EndRunRequest");

	Params::DBDAIController_EndRunRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.EndSecondAttackRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::EndSecondAttackRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "EndSecondAttackRequest");

	Params::DBDAIController_EndSecondAttackRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.EndUseItemRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::EndUseItemRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "EndUseItemRequest");

	Params::DBDAIController_EndUseItemRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.EventAbilityRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::EventAbilityRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "EventAbilityRequest");

	Params::DBDAIController_EventAbilityRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.FastInteractRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::FastInteractRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "FastInteractRequest");

	Params::DBDAIController_FastInteractRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.Gesture01Request
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::Gesture01Request(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "Gesture01Request");

	Params::DBDAIController_Gesture01Request Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.Gesture02Request
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::Gesture02Request(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "Gesture02Request");

	Params::DBDAIController_Gesture02Request Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.Gesture03Request
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::Gesture03Request(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "Gesture03Request");

	Params::DBDAIController_Gesture03Request Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.Gesture04Request
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::Gesture04Request(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "Gesture04Request");

	Params::DBDAIController_Gesture04Request Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.InteractRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::InteractRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "InteractRequest");

	Params::DBDAIController_InteractRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.InteractRequestRelease
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::InteractRequestRelease(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "InteractRequestRelease");

	Params::DBDAIController_InteractRequestRelease Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.RunRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::RunRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "RunRequest");

	Params::DBDAIController_RunRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.SecondaryActionRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::SecondaryActionRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "SecondaryActionRequest");

	Params::DBDAIController_SecondaryActionRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.SecondAttackRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::SecondAttackRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "SecondAttackRequest");

	Params::DBDAIController_SecondAttackRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.Server_SetAIPlayerRank
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// int32                                   playerRank                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::Server_SetAIPlayerRank(int32 playerRank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "Server_SetAIPlayerRank");

	Params::DBDAIController_Server_SetAIPlayerRank Parms{};

	Parms.playerRank = playerRank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.SetCharacterMovement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECharacterMovementTypes                 movementTypes                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAIMovementPriority                     applyOrder                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDAIController::SetCharacterMovement(ECharacterMovementTypes movementTypes, const class UObject* requester, EAIMovementPriority applyOrder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "SetCharacterMovement");

	Params::DBDAIController_SetCharacterMovement Parms{};

	Parms.movementTypes = movementTypes;
	Parms.requester = requester;
	Parms.applyOrder = applyOrder;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDAIController.StruggleRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Input                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::StruggleRequest(const class UObject* requester, float Input)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "StruggleRequest");

	Params::DBDAIController_StruggleRequest Parms{};

	Parms.requester = requester;
	Parms.Input = Input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.UseItemRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::UseItemRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "UseItemRequest");

	Params::DBDAIController_UseItemRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDNetworkUtilities.IsOnDedicatedServerNetwork
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDNetworkUtilities::IsOnDedicatedServerNetwork(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDNetworkUtilities", "IsOnDedicatedServerNetwork");

	Params::DBDNetworkUtilities_IsOnDedicatedServerNetwork Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDNetworkUtilities.IsRunningDedicatedServerFlow
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDNetworkUtilities::IsRunningDedicatedServerFlow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDNetworkUtilities", "IsRunningDedicatedServerFlow");

	Params::DBDNetworkUtilities_IsRunningDedicatedServerFlow Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterMovementComponent.Client_Cheat_SetMaxSpeedMultiplier
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// const float                             maxSpeedMultiplier                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDCharacterMovementComponent::Client_Cheat_SetMaxSpeedMultiplier(const float maxSpeedMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDCharacterMovementComponent", "Client_Cheat_SetMaxSpeedMultiplier");

	Params::DBDCharacterMovementComponent_Client_Cheat_SetMaxSpeedMultiplier Parms{};

	Parms.maxSpeedMultiplier = maxSpeedMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDCharacterMovementComponent.Client_PreventMovement
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// const bool                              Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDCharacterMovementComponent::Client_PreventMovement(const bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDCharacterMovementComponent", "Client_PreventMovement");

	Params::DBDCharacterMovementComponent_Client_PreventMovement Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDCharacterMovementComponent.Client_Stop
// (Net, NetReliable, Native, Event, Protected, NetClient)

void UDBDCharacterMovementComponent::Client_Stop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDCharacterMovementComponent", "Client_Stop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDCharacterMovementComponent.Client_TeleportTo
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// const struct FVector_NetQuantize100&    Location                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FYawAndPitchRotator_NetQuantize32&Rotation                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UDBDCharacterMovementComponent::Client_TeleportTo(const struct FVector_NetQuantize100& Location, const struct FYawAndPitchRotator_NetQuantize32& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDCharacterMovementComponent", "Client_TeleportTo");

	Params::DBDCharacterMovementComponent_Client_TeleportTo Parms{};

	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDCharacterMovementComponent.Server_Launch
// (Final, Net, NetReliable, Native, Event, Private, NetServer, HasDefaults)
// Parameters:
// float                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   LaunchVelocity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   launchCallCount                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDCharacterMovementComponent::Server_Launch(float Timestamp, const struct FVector& LaunchVelocity, int32 launchCallCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDCharacterMovementComponent", "Server_Launch");

	Params::DBDCharacterMovementComponent_Server_Launch Parms{};

	Parms.Timestamp = Timestamp;
	Parms.LaunchVelocity = std::move(LaunchVelocity);
	Parms.launchCallCount = launchCallCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDCharacterMovementComponent.Server_MovementSetStateStack
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// float                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FPlayerStateMachineTransitionData>&stateStackContainers                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   stateStackCallCount                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDCharacterMovementComponent::Server_MovementSetStateStack(float Timestamp, const TArray<struct FPlayerStateMachineTransitionData>& stateStackContainers, int32 stateStackCallCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDCharacterMovementComponent", "Server_MovementSetStateStack");

	Params::DBDCharacterMovementComponent_Server_MovementSetStateStack Parms{};

	Parms.Timestamp = Timestamp;
	Parms.stateStackContainers = std::move(stateStackContainers);
	Parms.stateStackCallCount = stateStackCallCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDCharacterMovementComponent.Server_MovementTimeSync
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// uint64                                  clientTimeSync                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  minStackDepth                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isInGameThreadOnly                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDCharacterMovementComponent::Server_MovementTimeSync(uint64 clientTimeSync, uint32 minStackDepth, bool isInGameThreadOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDCharacterMovementComponent", "Server_MovementTimeSync");

	Params::DBDCharacterMovementComponent_Server_MovementTimeSync Parms{};

	Parms.clientTimeSync = clientTimeSync;
	Parms.minStackDepth = minStackDepth;
	Parms.isInGameThreadOnly = isInGameThreadOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDCharacterMovementComponent.Server_ReplicateControlRotation
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// uint8                                   ClientRoll                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  View                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDCharacterMovementComponent::Server_ReplicateControlRotation(uint8 ClientRoll, uint32 View)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDCharacterMovementComponent", "Server_ReplicateControlRotation");

	Params::DBDCharacterMovementComponent_Server_ReplicateControlRotation Parms{};

	Parms.ClientRoll = ClientRoll;
	Parms.View = View;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDCharacterMovementComponent.Server_SetMaxAcceleration
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// float                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDCharacterMovementComponent::Server_SetMaxAcceleration(float Timestamp, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDCharacterMovementComponent", "Server_SetMaxAcceleration");

	Params::DBDCharacterMovementComponent_Server_SetMaxAcceleration Parms{};

	Parms.Timestamp = Timestamp;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDCharacterMovementComponent.Server_UpdateCameraRotation
// (Final, Net, NetReliable, Native, Event, Private, NetServer, HasDefaults)
// Parameters:
// float                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  cameraRotation                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   updateCameraRotationCallCount                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDCharacterMovementComponent::Server_UpdateCameraRotation(float Timestamp, const struct FRotator& cameraRotation, int32 updateCameraRotationCallCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDCharacterMovementComponent", "Server_UpdateCameraRotation");

	Params::DBDCharacterMovementComponent_Server_UpdateCameraRotation Parms{};

	Parms.Timestamp = Timestamp;
	Parms.cameraRotation = std::move(cameraRotation);
	Parms.updateCameraRotationCallCount = updateCameraRotationCallCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDCharacterMovementComponent.Multicast_SetIsIgnoringPawnCollision
// (Net, NetReliable, Native, Event, NetMulticast, Public, Const)
// Parameters:
// const bool                              isIgnoringPawnCollision                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDCharacterMovementComponent::Multicast_SetIsIgnoringPawnCollision(const bool isIgnoringPawnCollision) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDCharacterMovementComponent", "Multicast_SetIsIgnoringPawnCollision");

	Params::DBDCharacterMovementComponent_Multicast_SetIsIgnoringPawnCollision Parms{};

	Parms.isIgnoringPawnCollision = isIgnoringPawnCollision;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BaseLockerItem.AdjustPositionOnLocker
// (Final, Native, Private)

void ABaseLockerItem::AdjustPositionOnLocker()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseLockerItem", "AdjustPositionOnLocker");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BaseLockerItem.OnRep_OwningLocker
// (Final, Native, Protected)

void ABaseLockerItem::OnRep_OwningLocker()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseLockerItem", "OnRep_OwningLocker");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InteractionDetectorComponent.AddIgnoredActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ignored                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDetectorComponent::AddIgnoredActor(class AActor* ignored)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDetectorComponent", "AddIgnoredActor");

	Params::InteractionDetectorComponent_AddIgnoredActor Parms{};

	Parms.ignored = ignored;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InteractionDetectorComponent.BeginOverlapCallback
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    fromSweep                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UInteractionDetectorComponent::BeginOverlapCallback(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool fromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDetectorComponent", "BeginOverlapCallback");

	Params::InteractionDetectorComponent_BeginOverlapCallback Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.fromSweep = fromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InteractionDetectorComponent.EndOverlapCallback
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDetectorComponent::EndOverlapCallback(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDetectorComponent", "EndOverlapCallback");

	Params::InteractionDetectorComponent_EndOverlapCallback Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InteractionDetectorComponent.OnLocallyObservedChanged
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDetectorComponent::OnLocallyObservedChanged(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDetectorComponent", "OnLocallyObservedChanged");

	Params::InteractionDetectorComponent_OnLocallyObservedChanged Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InteractionDetectorComponent.SetDetectionPrimitive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              detectionPrimitive                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDetectorComponent::SetDetectionPrimitive(class UPrimitiveComponent* detectionPrimitive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDetectorComponent", "SetDetectionPrimitive");

	Params::InteractionDetectorComponent_SetDetectionPrimitive Parms{};

	Parms.detectionPrimitive = detectionPrimitive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InteractionDetectorComponent.GetDetectionPrimitive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* UInteractionDetectorComponent::GetDetectionPrimitive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDetectorComponent", "GetDetectionPrimitive");

	Params::InteractionDetectorComponent_GetDetectionPrimitive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AimingCrosshairComponent.Cosmetic_OnCrosshairStateChanged
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// EAimingCrosshairState                   newState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAimingCrosshairState                   lastState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAimingCrosshairComponent::Cosmetic_OnCrosshairStateChanged(EAimingCrosshairState newState, EAimingCrosshairState lastState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimingCrosshairComponent", "Cosmetic_OnCrosshairStateChanged");

	Params::AimingCrosshairComponent_Cosmetic_OnCrosshairStateChanged Parms{};

	Parms.newState = newState;
	Parms.lastState = lastState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.KillerProjectileLauncher.Server_UpdateCameraRotation
// (Final, Net, NetReliable, Native, Event, Private, NetServer, HasDefaults)
// Parameters:
// const struct FRotator&                  Rotation                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UKillerProjectileLauncher::Server_UpdateCameraRotation(const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerProjectileLauncher", "Server_UpdateCameraRotation");

	Params::KillerProjectileLauncher_Server_UpdateCameraRotation Parms{};

	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerProjectileLauncher.GetOwningKiller
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AKiller*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AKiller* UKillerProjectileLauncher::GetOwningKiller() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerProjectileLauncher", "GetOwningKiller");

	Params::KillerProjectileLauncher_GetOwningKiller Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MenuForcedLODHandler.OnCustomizationChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// ECustomizationCategory                  category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDMenuPlayer*                   menuPlayer                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMenuForcedLODHandler::OnCustomizationChanged(ECustomizationCategory category, const class FName& ItemId, class ADBDMenuPlayer* menuPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuForcedLODHandler", "OnCustomizationChanged");

	Params::MenuForcedLODHandler_OnCustomizationChanged Parms{};

	Parms.category = category;
	Parms.ItemId = ItemId;
	Parms.menuPlayer = menuPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MenuForcedLODHandler.OnMenuPlayerEndPlay
// (Final, Native, Private)
// Parameters:
// class AActor*                           menuPlayerActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEndPlayReason                          EndPlayReason                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMenuForcedLODHandler::OnMenuPlayerEndPlay(class AActor* menuPlayerActor, EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuForcedLODHandler", "OnMenuPlayerEndPlay");

	Params::MenuForcedLODHandler_OnMenuPlayerEndPlay Parms{};

	Parms.menuPlayerActor = menuPlayerActor;
	Parms.EndPlayReason = EndPlayReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDBasePlayer.DBD_SwapCosmetics
// (Final, Exec, Native, Protected)
// Parameters:
// class FName                             cosmeticId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDBasePlayer::DBD_SwapCosmetics(class FName cosmeticId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "DBD_SwapCosmetics");

	Params::DBDBasePlayer_DBD_SwapCosmetics Parms{};

	Parms.cosmeticId = cosmeticId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDBasePlayer.Multicast_SwapCosmetics
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class FName                             cosmeticId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDBasePlayer::Multicast_SwapCosmetics(class FName cosmeticId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "Multicast_SwapCosmetics");

	Params::DBDBasePlayer_Multicast_SwapCosmetics Parms{};

	Parms.cosmeticId = cosmeticId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDBasePlayer.OnAnimInstanceChanged
// (Final, Native, Private)

void ADBDBasePlayer::OnAnimInstanceChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "OnAnimInstanceChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDBasePlayer.OnCurrentMontageBlendingOut
// (Final, Native, Private)
// Parameters:
// class UAnimMontage*                     MontageAsset                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    interrupted                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDBasePlayer::OnCurrentMontageBlendingOut(class UAnimMontage* MontageAsset, bool interrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "OnCurrentMontageBlendingOut");

	Params::DBDBasePlayer_OnCurrentMontageBlendingOut Parms{};

	Parms.MontageAsset = MontageAsset;
	Parms.interrupted = interrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDBasePlayer.OnCurrentMontageComplete
// (Native, Protected)
// Parameters:
// class UAnimMontage*                     MontageAsset                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    interrupted                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDBasePlayer::OnCurrentMontageComplete(class UAnimMontage* MontageAsset, bool interrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "OnCurrentMontageComplete");

	Params::DBDBasePlayer_OnCurrentMontageComplete Parms{};

	Parms.MontageAsset = MontageAsset;
	Parms.interrupted = interrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDBasePlayer.PlayMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FAnimationMontageDescriptor&animMontageID                                          (Parm, NativeAccessSpecifierPublic)
// float                                   PlayRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isFollower                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ADBDBasePlayer::PlayMontage(const struct FAnimationMontageDescriptor& animMontageID, float PlayRate, bool isFollower)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "PlayMontage");

	Params::DBDBasePlayer_PlayMontage Parms{};

	Parms.animMontageID = std::move(animMontageID);
	Parms.PlayRate = PlayRate;
	Parms.isFollower = isFollower;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDBasePlayer.StopMontage
// (Final, Native, Public, BlueprintCallable)

void ADBDBasePlayer::StopMontage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "StopMontage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDBasePlayer.TeleportWithClothHandling
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    checkCollisions                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDBasePlayer::TeleportWithClothHandling(const struct FVector& Location, const struct FRotator& Rotation, bool checkCollisions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "TeleportWithClothHandling");

	Params::DBDBasePlayer_TeleportWithClothHandling Parms{};

	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.checkCollisions = checkCollisions;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDBasePlayer.GetAnimInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimInstance*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimInstance* ADBDBasePlayer::GetAnimInstance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "GetAnimInstance");

	Params::DBDBasePlayer_GetAnimInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDBasePlayer.GetAnimTags
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>*                    outTags                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ADBDBasePlayer::GetAnimTags(TArray<class FName>* outTags) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "GetAnimTags");

	Params::DBDBasePlayer_GetAnimTags Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outTags != nullptr)
		*outTags = std::move(Parms.outTags);
}


// Function DeadByDaylight.DBDBasePlayer.GetAudioComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAkComponent*                     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAkComponent* ADBDBasePlayer::GetAudioComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "GetAudioComponent");

	Params::DBDBasePlayer_GetAudioComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDBasePlayer.GetCharacterIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADBDBasePlayer::GetCharacterIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "GetCharacterIndex");

	Params::DBDBasePlayer_GetCharacterIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDBasePlayer.GetCharacterName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ADBDBasePlayer::GetCharacterName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "GetCharacterName");

	Params::DBDBasePlayer_GetCharacterName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDBasePlayer.GetCharacterOverrideId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ADBDBasePlayer::GetCharacterOverrideId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "GetCharacterOverrideId");

	Params::DBDBasePlayer_GetCharacterOverrideId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDBasePlayer.GetCustomizedAudio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCustomizedAudioComponent*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCustomizedAudioComponent* ADBDBasePlayer::GetCustomizedAudio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "GetCustomizedAudio");

	Params::DBDBasePlayer_GetCustomizedAudio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDBasePlayer.GetCustomizedSkeletalMesh
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UCustomizedSkeletalMesh*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCustomizedSkeletalMesh* ADBDBasePlayer::GetCustomizedSkeletalMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "GetCustomizedSkeletalMesh");

	Params::DBDBasePlayer_GetCustomizedSkeletalMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDBasePlayer.GetLeftFootGroundDetector
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBaseGroundDetectorComponent*     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBaseGroundDetectorComponent* ADBDBasePlayer::GetLeftFootGroundDetector() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "GetLeftFootGroundDetector");

	Params::DBDBasePlayer_GetLeftFootGroundDetector Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDBasePlayer.GetLeftFrontFootGroundDetector
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBaseGroundDetectorComponent*     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBaseGroundDetectorComponent* ADBDBasePlayer::GetLeftFrontFootGroundDetector() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "GetLeftFrontFootGroundDetector");

	Params::DBDBasePlayer_GetLeftFrontFootGroundDetector Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDBasePlayer.GetMontage
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FAnimationMontageDescriptor&animMontageID                                          (Parm, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ADBDBasePlayer::GetMontage(const struct FAnimationMontageDescriptor& animMontageID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "GetMontage");

	Params::DBDBasePlayer_GetMontage Parms{};

	Parms.animMontageID = std::move(animMontageID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDBasePlayer.GetMontageLength
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FAnimationMontageDescriptor&animMontageID                                          (Parm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADBDBasePlayer::GetMontageLength(const struct FAnimationMontageDescriptor& animMontageID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "GetMontageLength");

	Params::DBDBasePlayer_GetMontageLength Parms{};

	Parms.animMontageID = std::move(animMontageID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDBasePlayer.GetMontagePlaybackDefinition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FAnimationMontageDescriptor&animMontageID                                          (Parm, NativeAccessSpecifierPublic)
// float                                   PlayRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isFollower                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMontagePlaybackDefinition       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMontagePlaybackDefinition ADBDBasePlayer::GetMontagePlaybackDefinition(const struct FAnimationMontageDescriptor& animMontageID, float PlayRate, bool isFollower) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "GetMontagePlaybackDefinition");

	Params::DBDBasePlayer_GetMontagePlaybackDefinition Parms{};

	Parms.animMontageID = std::move(animMontageID);
	Parms.PlayRate = PlayRate;
	Parms.isFollower = isFollower;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDBasePlayer.GetMontagePlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMontagePlayer*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMontagePlayer* ADBDBasePlayer::GetMontagePlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "GetMontagePlayer");

	Params::DBDBasePlayer_GetMontagePlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDBasePlayer.GetRightFootGroundDetector
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBaseGroundDetectorComponent*     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBaseGroundDetectorComponent* ADBDBasePlayer::GetRightFootGroundDetector() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "GetRightFootGroundDetector");

	Params::DBDBasePlayer_GetRightFootGroundDetector Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDBasePlayer.GetRightFrontFootGroundDetector
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBaseGroundDetectorComponent*     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBaseGroundDetectorComponent* ADBDBasePlayer::GetRightFrontFootGroundDetector() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "GetRightFrontFootGroundDetector");

	Params::DBDBasePlayer_GetRightFrontFootGroundDetector Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDBasePlayer.GetSemanticTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTagContainer      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FGameplayTagContainer ADBDBasePlayer::GetSemanticTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "GetSemanticTag");

	Params::DBDBasePlayer_GetSemanticTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDBasePlayer.GetShowBlindDebugInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDBasePlayer::GetShowBlindDebugInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "GetShowBlindDebugInfo");

	Params::DBDBasePlayer_GetShowBlindDebugInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDBasePlayer.IsPlayingAnyMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDBasePlayer::IsPlayingAnyMontage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "IsPlayingAnyMontage");

	Params::DBDBasePlayer_IsPlayingAnyMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDBasePlayer.IsPlayingMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FAnimationMontageDescriptor&animMontageID                                          (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDBasePlayer::IsPlayingMontage(const struct FAnimationMontageDescriptor& animMontageID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "IsPlayingMontage");

	Params::DBDBasePlayer_IsPlayingMontage Parms{};

	Parms.animMontageID = std::move(animMontageID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.AddDetectionZone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDetectionZone                          detectionZoneID                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              zone                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::AddDetectionZone(EDetectionZone detectionZoneID, class UPrimitiveComponent* zone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "AddDetectionZone");

	Params::DBDPlayer_AddDetectionZone Parms{};

	Parms.detectionZoneID = detectionZoneID;
	Parms.zone = zone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.AttachInteractor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInteractor*                      Interactor                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::AttachInteractor(class UInteractor* Interactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "AttachInteractor");

	Params::DBDPlayer_AttachInteractor Parms{};

	Parms.Interactor = Interactor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Authority_HandleScoreEvent
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              scoreTypeTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FScoreEventData&           ScoreEventData                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ADBDPlayer::Authority_HandleScoreEvent(const struct FGameplayTag& scoreTypeTag, const struct FScoreEventData& ScoreEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Authority_HandleScoreEvent");

	Params::DBDPlayer_Authority_HandleScoreEvent Parms{};

	Parms.scoreTypeTag = std::move(scoreTypeTag);
	Parms.ScoreEventData = std::move(ScoreEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.CameraUpdated
// (Native, Public, BlueprintCallable)

void ADBDPlayer::CameraUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "CameraUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.CancelCarry
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    alsoCancelForOtherPlayer                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::CancelCarry(bool alsoCancelForOtherPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "CancelCarry");

	Params::DBDPlayer_CancelCarry Parms{};

	Parms.alsoCancelForOtherPlayer = alsoCancelForOtherPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Client_SendCancelInteraction
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// const class UInteractionDefinition*     InteractionDefinition                                  (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Client_SendCancelInteraction(const class UInteractionDefinition* InteractionDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Client_SendCancelInteraction");

	Params::DBDPlayer_Client_SendCancelInteraction Parms{};

	Parms.InteractionDefinition = InteractionDefinition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Client_TryInteraction
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class UInteractionDefinition*           Interaction                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       requester                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    usingInputPersistence                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Client_TryInteraction(class UInteractionDefinition* Interaction, class ADBDPlayer* requester, bool force, bool usingInputPersistence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Client_TryInteraction");

	Params::DBDPlayer_Client_TryInteraction Parms{};

	Parms.Interaction = Interaction;
	Parms.requester = requester;
	Parms.force = force;
	Parms.usingInputPersistence = usingInputPersistence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Client_TryInteractionType
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// EInputInteractionType                   interactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       requester                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Client_TryInteractionType(EInputInteractionType interactionType, class ADBDPlayer* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Client_TryInteractionType");

	Params::DBDPlayer_Client_TryInteractionType Parms{};

	Parms.interactionType = interactionType;
	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.DBD_SetMouseLookUpSpeedMultiplier
// (Final, Exec, Native, Protected)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::DBD_SetMouseLookUpSpeedMultiplier(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "DBD_SetMouseLookUpSpeedMultiplier");

	Params::DBDPlayer_DBD_SetMouseLookUpSpeedMultiplier Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.DBD_SetMouseTurnSpeedMultiplier
// (Final, Exec, Native, Protected)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::DBD_SetMouseTurnSpeedMultiplier(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "DBD_SetMouseTurnSpeedMultiplier");

	Params::DBDPlayer_DBD_SetMouseTurnSpeedMultiplier Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.DBD_ToggleForceAuthoritativeMovement
// (Final, Exec, Native, Private)

void ADBDPlayer::DBD_ToggleForceAuthoritativeMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "DBD_ToggleForceAuthoritativeMovement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.DBDCrouch
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ADBDPlayer::DBDCrouch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "DBDCrouch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.DBDUnCrouch
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ADBDPlayer::DBDUnCrouch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "DBDUnCrouch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.DetachInteractor
// (Final, Native, Public, BlueprintCallable)

void ADBDPlayer::DetachInteractor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "DetachInteractor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Dissolve
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Dissolve_0                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Dissolve(bool Dissolve_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Dissolve");

	Params::DBDPlayer_Dissolve Parms{};

	Parms.Dissolve_0 = Dissolve_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBDPlayer.GetInteractionPlayerProperties
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FInteractionPlayerPropertiesReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FInteractionPlayerProperties ADBDPlayer::GetInteractionPlayerProperties()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetInteractionPlayerProperties");

	Params::DBDPlayer_GetInteractionPlayerProperties Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.K2_SetActorLocationByBottomCapsule
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   NewLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::K2_SetActorLocationByBottomCapsule(const struct FVector& NewLocation, bool bSweep, struct FHitResult* SweepHitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "K2_SetActorLocationByBottomCapsule");

	Params::DBDPlayer_K2_SetActorLocationByBottomCapsule Parms{};

	Parms.NewLocation = std::move(NewLocation);
	Parms.bSweep = bSweep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.Local_NotifyMatchEnded
// (Native, Event, Public, BlueprintEvent)

void ADBDPlayer::Local_NotifyMatchEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Local_NotifyMatchEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Multicast_Broadcast_DebugPlayMontage
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// const struct FAnimationMontageDescriptor&animMontageID                                          (Parm, NativeAccessSpecifierPublic)
// float                                   PlayRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Multicast_Broadcast_DebugPlayMontage(const struct FAnimationMontageDescriptor& animMontageID, float PlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Multicast_Broadcast_DebugPlayMontage");

	Params::DBDPlayer_Multicast_Broadcast_DebugPlayMontage Parms{};

	Parms.animMontageID = std::move(animMontageID);
	Parms.PlayRate = PlayRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Multicast_ConfirmItemDrop
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// bool                                    Pressed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Multicast_ConfirmItemDrop(bool Pressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Multicast_ConfirmItemDrop");

	Params::DBDPlayer_Multicast_ConfirmItemDrop Parms{};

	Parms.Pressed = Pressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Multicast_Debug_SetMaxWalkSpeed
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// float                                   MaxWalkSpeed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Multicast_Debug_SetMaxWalkSpeed(float MaxWalkSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Multicast_Debug_SetMaxWalkSpeed");

	Params::DBDPlayer_Multicast_Debug_SetMaxWalkSpeed Parms{};

	Parms.MaxWalkSpeed = MaxWalkSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Multicast_LeaveGame
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// const struct FGuid&                     uniqueLeavingPlayerId                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Multicast_LeaveGame(const struct FGuid& uniqueLeavingPlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Multicast_LeaveGame");

	Params::DBDPlayer_Multicast_LeaveGame Parms{};

	Parms.uniqueLeavingPlayerId = std::move(uniqueLeavingPlayerId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Multicast_ReplicateController
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class AController*                      NewController                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Multicast_ReplicateController(class AController* NewController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Multicast_ReplicateController");

	Params::DBDPlayer_Multicast_ReplicateController Parms{};

	Parms.NewController = NewController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Multicast_ServerResetMeshRelativeOffSet
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ADBDPlayer::Multicast_ServerResetMeshRelativeOffSet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Multicast_ServerResetMeshRelativeOffSet");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Multicast_SetAuthoritativeMovement
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Multicast_SetAuthoritativeMovement(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Multicast_SetAuthoritativeMovement");

	Params::DBDPlayer_Multicast_SetAuthoritativeMovement Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Multicast_SetContinuousPrintDebug
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Multicast_SetContinuousPrintDebug(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Multicast_SetContinuousPrintDebug");

	Params::DBDPlayer_Multicast_SetContinuousPrintDebug Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Multicast_SetCustomization
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// const struct FEquippedPlayerCustomization&Customization                                          (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ADBDPlayer::Multicast_SetCustomization(const struct FEquippedPlayerCustomization& Customization)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Multicast_SetCustomization");

	Params::DBDPlayer_Multicast_SetCustomization Parms{};

	Parms.Customization = std::move(Customization);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Multicast_SetDebugCarry
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Multicast_SetDebugCarry(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Multicast_SetDebugCarry");

	Params::DBDPlayer_Multicast_SetDebugCarry Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Multicast_SetDebugPrintAvailableInteractions
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Multicast_SetDebugPrintAvailableInteractions(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Multicast_SetDebugPrintAvailableInteractions");

	Params::DBDPlayer_Multicast_SetDebugPrintAvailableInteractions Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Multicast_SetDebugSnapPoint
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Multicast_SetDebugSnapPoint(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Multicast_SetDebugSnapPoint");

	Params::DBDPlayer_Multicast_SetDebugSnapPoint Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Multicast_SetEnableCapsuleDynamicResize
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Multicast_SetEnableCapsuleDynamicResize(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Multicast_SetEnableCapsuleDynamicResize");

	Params::DBDPlayer_Multicast_SetEnableCapsuleDynamicResize Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Multicast_SetForceAuthoritativeMovement
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Multicast_SetForceAuthoritativeMovement(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Multicast_SetForceAuthoritativeMovement");

	Params::DBDPlayer_Multicast_SetForceAuthoritativeMovement Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Multicast_SetInteractingPlayer
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ADBDPlayer*                       interactingPlayer                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Multicast_SetInteractingPlayer(class ADBDPlayer* interactingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Multicast_SetInteractingPlayer");

	Params::DBDPlayer_Multicast_SetInteractingPlayer Parms{};

	Parms.interactingPlayer = interactingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Multicast_SetReverseTraverseEnabled
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Multicast_SetReverseTraverseEnabled(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Multicast_SetReverseTraverseEnabled");

	Params::DBDPlayer_Multicast_SetReverseTraverseEnabled Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Multicast_SetRunVaultEnabled
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Multicast_SetRunVaultEnabled(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Multicast_SetRunVaultEnabled");

	Params::DBDPlayer_Multicast_SetRunVaultEnabled Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.OnAllPlayerLoaded
// (Final, Native, Public)

void ADBDPlayer::OnAllPlayerLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnAllPlayerLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.OnBlindChargeEmptied
// (Native, Protected)

void ADBDPlayer::OnBlindChargeEmptied()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnBlindChargeEmptied");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.OnClientRestart
// (Event, Public, BlueprintEvent)

void ADBDPlayer::OnClientRestart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnClientRestart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.DBDPlayer.OnControllerChanged
// (Final, Native, Private)
// Parameters:
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      OldController                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      NewController                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::OnControllerChanged(class APawn* Pawn, class AController* OldController, class AController* NewController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnControllerChanged");

	Params::DBDPlayer_OnControllerChanged Parms{};

	Parms.Pawn = Pawn;
	Parms.OldController = OldController;
	Parms.NewController = NewController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.OnEscapeDoorActivated
// (Event, Protected, BlueprintEvent)

void ADBDPlayer::OnEscapeDoorActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnEscapeDoorActivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.DBDPlayer.OnHudVisibilityChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// const bool                              IsVisible                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::OnHudVisibilityChanged(const bool IsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnHudVisibilityChanged");

	Params::DBDPlayer_OnHudVisibilityChanged Parms{};

	Parms.IsVisible = IsVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBDPlayer.OnHudVisibilityChangedNative
// (Native, Protected)
// Parameters:
// const bool                              IsVisible                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::OnHudVisibilityChangedNative(const bool IsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnHudVisibilityChangedNative");

	Params::DBDPlayer_OnHudVisibilityChangedNative Parms{};

	Parms.IsVisible = IsVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.OnInterruptedStart
// (Event, Protected, BlueprintEvent)

void ADBDPlayer::OnInterruptedStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnInterruptedStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.DBDPlayer.OnIntroCompleted
// (Event, Public, BlueprintEvent)

void ADBDPlayer::OnIntroCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnIntroCompleted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.DBDPlayer.OnIntroCompletedNative
// (Native, Protected)

void ADBDPlayer::OnIntroCompletedNative()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnIntroCompletedNative");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.OnLevelReadyToPlay
// (Native, Event, Public, BlueprintEvent)

void ADBDPlayer::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.OnLocallyObservedChanged
// (Event, Protected, BlueprintEvent)

void ADBDPlayer::OnLocallyObservedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnLocallyObservedChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.DBDPlayer.OnPickupEnd
// (Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::OnPickupEnd(class ADBDPlayer* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnPickupEnd");

	Params::DBDPlayer_OnPickupEnd Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.OnPickupStart
// (Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   pickupDuration                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::OnPickupStart(class ADBDPlayer* Target, float pickupDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnPickupStart");

	Params::DBDPlayer_OnPickupStart Parms{};

	Parms.Target = Target;
	Parms.pickupDuration = pickupDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.OnPostProcessInput
// (Final, Native, Private)

void ADBDPlayer::OnPostProcessInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnPostProcessInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.OnRep_Interactable
// (Final, Native, Protected)

void ADBDPlayer::OnRep_Interactable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnRep_Interactable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.RemoveStatusEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UStatusEffect*                    StatusEffect                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::RemoveStatusEffect(class UStatusEffect* StatusEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "RemoveStatusEffect");

	Params::DBDPlayer_RemoveStatusEffect Parms{};

	Parms.StatusEffect = StatusEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.ResetCamera
// (Native, Public, BlueprintCallable)

void ADBDPlayer::ResetCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "ResetCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.ResetPitchScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   adjustTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::ResetPitchScale(float adjustTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "ResetPitchScale");

	Params::DBDPlayer_ResetPitchScale Parms{};

	Parms.adjustTime = adjustTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Server_Broadcast_DebugPlayMontage
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// const struct FAnimationMontageDescriptor&animMontageID                                          (Parm, NativeAccessSpecifierPublic)
// float                                   PlayRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Server_Broadcast_DebugPlayMontage(const struct FAnimationMontageDescriptor& animMontageID, float PlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Server_Broadcast_DebugPlayMontage");

	Params::DBDPlayer_Server_Broadcast_DebugPlayMontage Parms{};

	Parms.animMontageID = std::move(animMontageID);
	Parms.PlayRate = PlayRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Server_DebugSetCustomization
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FEquippedPlayerCustomization&Customization                                          (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ADBDPlayer::Server_DebugSetCustomization(const struct FEquippedPlayerCustomization& Customization)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Server_DebugSetCustomization");

	Params::DBDPlayer_Server_DebugSetCustomization Parms{};

	Parms.Customization = std::move(Customization);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Server_SendAbilityInput
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    Pressed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Server_SendAbilityInput(bool Pressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Server_SendAbilityInput");

	Params::DBDPlayer_Server_SendAbilityInput Parms{};

	Parms.Pressed = Pressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Server_SendAbilityTwoInput
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    Pressed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Server_SendAbilityTwoInput(bool Pressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Server_SendAbilityTwoInput");

	Params::DBDPlayer_Server_SendAbilityTwoInput Parms{};

	Parms.Pressed = Pressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Server_SendEventAbilityInput
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    Pressed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Server_SendEventAbilityInput(bool Pressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Server_SendEventAbilityInput");

	Params::DBDPlayer_Server_SendEventAbilityInput Parms{};

	Parms.Pressed = Pressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Server_SendFastInteractionInput
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    Pressed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Server_SendFastInteractionInput(bool Pressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Server_SendFastInteractionInput");

	Params::DBDPlayer_Server_SendFastInteractionInput Parms{};

	Parms.Pressed = Pressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Server_SendInteractionInput
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    Pressed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Server_SendInteractionInput(bool Pressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Server_SendInteractionInput");

	Params::DBDPlayer_Server_SendInteractionInput Parms{};

	Parms.Pressed = Pressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Server_SendItemDropInput
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// bool                                    Pressed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Server_SendItemDropInput(bool Pressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Server_SendItemDropInput");

	Params::DBDPlayer_Server_SendItemDropInput Parms{};

	Parms.Pressed = Pressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Server_SendItemUseInput
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// bool                                    Pressed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    requestItemUse                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Server_SendItemUseInput(bool Pressed, bool requestItemUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Server_SendItemUseInput");

	Params::DBDPlayer_Server_SendItemUseInput Parms{};

	Parms.Pressed = Pressed;
	Parms.requestItemUse = requestItemUse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Server_SendSecondaryActionPressed
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// bool                                    fromCancelRequest                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Server_SendSecondaryActionPressed(bool fromCancelRequest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Server_SendSecondaryActionPressed");

	Params::DBDPlayer_Server_SendSecondaryActionPressed Parms{};

	Parms.fromCancelRequest = fromCancelRequest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Server_UpdateScreenAspectRatio
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Server_UpdateScreenAspectRatio(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Server_UpdateScreenAspectRatio");

	Params::DBDPlayer_Server_UpdateScreenAspectRatio Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.SetAllDetectionZonesEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::SetAllDetectionZonesEnabled(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "SetAllDetectionZonesEnabled");

	Params::DBDPlayer_SetAllDetectionZonesEnabled Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.SetAnimationCrouchState
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    crouched                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::SetAnimationCrouchState(bool crouched)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "SetAnimationCrouchState");

	Params::DBDPlayer_SetAnimationCrouchState Parms{};

	Parms.crouched = crouched;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBDPlayer.SetDetectionZoneEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDetectionZone                          detectionZoneID                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::SetDetectionZoneEnabled(EDetectionZone detectionZoneID, bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "SetDetectionZoneEnabled");

	Params::DBDPlayer_SetDetectionZoneEnabled Parms{};

	Parms.detectionZoneID = detectionZoneID;
	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.SetFirstPersonModelEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::SetFirstPersonModelEnabled(bool Enabled, bool force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "SetFirstPersonModelEnabled");

	Params::DBDPlayer_SetFirstPersonModelEnabled Parms{};

	Parms.Enabled = Enabled;
	Parms.force = force;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.SetFirstPersonVfxsVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isFirstPerson                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::SetFirstPersonVfxsVisibility(bool isFirstPerson)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "SetFirstPersonVfxsVisibility");

	Params::DBDPlayer_SetFirstPersonVfxsVisibility Parms{};

	Parms.isFirstPerson = isFirstPerson;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.SetForceDisableSkillChecks
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsEnabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::SetForceDisableSkillChecks(bool IsEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "SetForceDisableSkillChecks");

	Params::DBDPlayer_SetForceDisableSkillChecks Parms{};

	Parms.IsEnabled = IsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.SetItemUseAsToggle
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::SetItemUseAsToggle(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "SetItemUseAsToggle");

	Params::DBDPlayer_SetItemUseAsToggle Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.SetQuestEventHandlerComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UActorComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::SetQuestEventHandlerComponent(class UActorComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "SetQuestEventHandlerComponent");

	Params::DBDPlayer_SetQuestEventHandlerComponent Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.SetReverseMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Reverse                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::SetReverseMontage(bool Reverse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "SetReverseMontage");

	Params::DBDPlayer_SetReverseMontage Parms{};

	Parms.Reverse = Reverse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.SetShouldPlayCarryAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ShouldPlayCarryAnim_0                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::SetShouldPlayCarryAnim(bool ShouldPlayCarryAnim_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "SetShouldPlayCarryAnim");

	Params::DBDPlayer_SetShouldPlayCarryAnim Parms{};

	Parms.ShouldPlayCarryAnim_0 = ShouldPlayCarryAnim_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.TriggerAnimNotify
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAnimNotifyType                         animNotifyType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::TriggerAnimNotify(EAnimNotifyType animNotifyType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "TriggerAnimNotify");

	Params::DBDPlayer_TriggerAnimNotify Parms{};

	Parms.animNotifyType = animNotifyType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.TryInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInteractionDefinition*           Interaction                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       requester                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    usingInputPersistence                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::TryInteraction(class UInteractionDefinition* Interaction, class ADBDPlayer* requester, bool force, bool usingInputPersistence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "TryInteraction");

	Params::DBDPlayer_TryInteraction Parms{};

	Parms.Interaction = Interaction;
	Parms.requester = requester;
	Parms.force = force;
	Parms.usingInputPersistence = usingInputPersistence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.TryInteractionType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EInputInteractionType                   interactionInputType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       requester                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    usingInputPersistence                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::TryInteractionType(EInputInteractionType interactionInputType, class ADBDPlayer* requester, bool usingInputPersistence, bool force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "TryInteractionType");

	Params::DBDPlayer_TryInteractionType Parms{};

	Parms.interactionInputType = interactionInputType;
	Parms.requester = requester;
	Parms.usingInputPersistence = usingInputPersistence;
	Parms.force = force;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.Authority_EvaluateIfPlayerCanSee
// (Final, Native, Private, Const)

void ADBDPlayer::Authority_EvaluateIfPlayerCanSee() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Authority_EvaluateIfPlayerCanSee");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.CanInterrupt_BP
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::CanInterrupt_BP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "CanInterrupt_BP");

	Params::DBDPlayer_CanInterrupt_BP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.FindClosestSlashablePlayerInDetectionZone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDetectionZone                          detectionZoneID                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* ADBDPlayer::FindClosestSlashablePlayerInDetectionZone(EDetectionZone detectionZoneID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "FindClosestSlashablePlayerInDetectionZone");

	Params::DBDPlayer_FindClosestSlashablePlayerInDetectionZone Parms{};

	Parms.detectionZoneID = detectionZoneID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetActorLocationFromFeetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   feetLocation                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ADBDPlayer::GetActorLocationFromFeetLocation(const struct FVector& feetLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetActorLocationFromFeetLocation");

	Params::DBDPlayer_GetActorLocationFromFeetLocation Parms{};

	Parms.feetLocation = std::move(feetLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetAssociatedPlayer
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* ADBDPlayer::GetAssociatedPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetAssociatedPlayer");

	Params::DBDPlayer_GetAssociatedPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetAssociatedPlayerState
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class APlayerState*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerState* ADBDPlayer::GetAssociatedPlayerState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetAssociatedPlayerState");

	Params::DBDPlayer_GetAssociatedPlayerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetAttachPoint
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class FName                             attachPointName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* ADBDPlayer::GetAttachPoint(class FName attachPointName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetAttachPoint");

	Params::DBDPlayer_GetAttachPoint Parms{};

	Parms.attachPointName = attachPointName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetAuthoritativeMovementComponent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAuthoritativeMovementComponent*  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAuthoritativeMovementComponent* ADBDPlayer::GetAuthoritativeMovementComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetAuthoritativeMovementComponent");

	Params::DBDPlayer_GetAuthoritativeMovementComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetAverageVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ADBDPlayer::GetAverageVelocity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetAverageVelocity");

	Params::DBDPlayer_GetAverageVelocity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetBlindableComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBlindableComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBlindableComponent* ADBDPlayer::GetBlindableComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetBlindableComponent");

	Params::DBDPlayer_GetBlindableComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetBoneLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBoneSpaces                             space                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ADBDPlayer::GetBoneLocation(class FName Name_0, EBoneSpaces space) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetBoneLocation");

	Params::DBDPlayer_GetBoneLocation Parms{};

	Parms.Name_0 = Name_0;
	Parms.space = space;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetCameraManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayerCameraManager*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayerCameraManager* ADBDPlayer::GetCameraManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetCameraManager");

	Params::DBDPlayer_GetCameraManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetCharacterInventoryComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCharacterInventoryComponent*     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCharacterInventoryComponent* ADBDPlayer::GetCharacterInventoryComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetCharacterInventoryComponent");

	Params::DBDPlayer_GetCharacterInventoryComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetChaseComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UChaseComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChaseComponent* ADBDPlayer::GetChaseComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetChaseComponent");

	Params::DBDPlayer_GetChaseComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetCurrentInteraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractionDefinition*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionDefinition* ADBDPlayer::GetCurrentInteraction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetCurrentInteraction");

	Params::DBDPlayer_GetCurrentInteraction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetCurrentInteractionAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInteractionAnimation                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInteractionAnimation ADBDPlayer::GetCurrentInteractionAnimation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetCurrentInteractionAnimation");

	Params::DBDPlayer_GetCurrentInteractionAnimation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetCurrentVsBaseMaxSpeedDifferenceAsPercentage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADBDPlayer::GetCurrentVsBaseMaxSpeedDifferenceAsPercentage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetCurrentVsBaseMaxSpeedDifferenceAsPercentage");

	Params::DBDPlayer_GetCurrentVsBaseMaxSpeedDifferenceAsPercentage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetDBDPlayerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayerState*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayerState* ADBDPlayer::GetDBDPlayerState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetDBDPlayerState");

	Params::DBDPlayer_GetDBDPlayerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetDetectionZone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDetectionZone                          detectionZoneID                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* ADBDPlayer::GetDetectionZone(EDetectionZone detectionZoneID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetDetectionZone");

	Params::DBDPlayer_GetDetectionZone Parms{};

	Parms.detectionZoneID = detectionZoneID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetFeetPosition
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ADBDPlayer::GetFeetPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetFeetPosition");

	Params::DBDPlayer_GetFeetPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetFirstComponentByClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UActorComponent>      ComponentClass                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorComponent* ADBDPlayer::GetFirstComponentByClass(TSubclassOf<class UActorComponent> ComponentClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetFirstComponentByClass");

	Params::DBDPlayer_GetFirstComponentByClass Parms{};

	Parms.ComponentClass = ComponentClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetGrassEffectRadiusMultiplier
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADBDPlayer::GetGrassEffectRadiusMultiplier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetGrassEffectRadiusMultiplier");

	Params::DBDPlayer_GetGrassEffectRadiusMultiplier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetInteractable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AInteractable*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AInteractable* ADBDPlayer::GetInteractable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetInteractable");

	Params::DBDPlayer_GetInteractable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetInteractionDetectorComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractionDetectorComponent*    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionDetectorComponent* ADBDPlayer::GetInteractionDetectorComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetInteractionDetectorComponent");

	Params::DBDPlayer_GetInteractionDetectorComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetIsInFirstPerson
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::GetIsInFirstPerson() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetIsInFirstPerson");

	Params::DBDPlayer_GetIsInFirstPerson Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetIsInteracting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::GetIsInteracting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetIsInteracting");

	Params::DBDPlayer_GetIsInteracting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetIsInterrupting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::GetIsInterrupting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetIsInterrupting");

	Params::DBDPlayer_GetIsInterrupting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetItemAddons
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class UItemAddon*>         ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TArray<class UItemAddon*> ADBDPlayer::GetItemAddons() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetItemAddons");

	Params::DBDPlayer_GetItemAddons Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetItemModifiers
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class UItemModifier*>      ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TArray<class UItemModifier*> ADBDPlayer::GetItemModifiers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetItemModifiers");

	Params::DBDPlayer_GetItemModifiers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetLuck
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADBDPlayer::GetLuck() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetLuck");

	Params::DBDPlayer_GetLuck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetMaxSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADBDPlayer::GetMaxSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetMaxSpeed");

	Params::DBDPlayer_GetMaxSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetNameDebugString
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ADBDPlayer::GetNameDebugString() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetNameDebugString");

	Params::DBDPlayer_GetNameDebugString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetObjectState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UGameplayTagContainerComponent*   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayTagContainerComponent* ADBDPlayer::GetObjectState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetObjectState");

	Params::DBDPlayer_GetObjectState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetOtherCharactersVerticalCollisionsHandler
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UOtherCharactersVerticalCollisionsHandler*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOtherCharactersVerticalCollisionsHandler* ADBDPlayer::GetOtherCharactersVerticalCollisionsHandler() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetOtherCharactersVerticalCollisionsHandler");

	Params::DBDPlayer_GetOtherCharactersVerticalCollisionsHandler Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetPawnType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPawnType                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPawnType ADBDPlayer::GetPawnType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetPawnType");

	Params::DBDPlayer_GetPawnType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetPercentMovementSpeed
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADBDPlayer::GetPercentMovementSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetPercentMovementSpeed");

	Params::DBDPlayer_GetPercentMovementSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetPerkManager
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPerkManager*                     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPerkManager* ADBDPlayer::GetPerkManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetPerkManager");

	Params::DBDPlayer_GetPerkManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetPlayerCamera
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCameraComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCameraComponent* ADBDPlayer::GetPlayerCamera() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetPlayerCamera");

	Params::DBDPlayer_GetPlayerCamera Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetPlayerController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayerController*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayerController* ADBDPlayer::GetPlayerController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetPlayerController");

	Params::DBDPlayer_GetPlayerController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetPlayerDirection
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ADBDPlayer::GetPlayerDirection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetPlayerDirection");

	Params::DBDPlayer_GetPlayerDirection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetPlayerInteractionHandler
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPlayerInteractionHandler*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlayerInteractionHandler* ADBDPlayer::GetPlayerInteractionHandler() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetPlayerInteractionHandler");

	Params::DBDPlayer_GetPlayerInteractionHandler Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetPlayerRole
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerRole                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerRole ADBDPlayer::GetPlayerRole() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetPlayerRole");

	Params::DBDPlayer_GetPlayerRole Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetPlayerTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerTeam                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerTeam ADBDPlayer::GetPlayerTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetPlayerTeam");

	Params::DBDPlayer_GetPlayerTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetRepControlRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ADBDPlayer::GetRepControlRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetRepControlRotation");

	Params::DBDPlayer_GetRepControlRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetReverseTraverseEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::GetReverseTraverseEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetReverseTraverseEnabled");

	Params::DBDPlayer_GetReverseTraverseEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetRunVaultEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::GetRunVaultEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetRunVaultEnabled");

	Params::DBDPlayer_GetRunVaultEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetSharedPlayerController
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class ADBDPlayerController*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayerController* ADBDPlayer::GetSharedPlayerController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetSharedPlayerController");

	Params::DBDPlayer_GetSharedPlayerController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetStillnessStartTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime ADBDPlayer::GetStillnessStartTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetStillnessStartTime");

	Params::DBDPlayer_GetStillnessStartTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetTunableValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   defaultValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    warnIfRowMissing                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADBDPlayer::GetTunableValue(class FName Key, float defaultValue, bool warnIfRowMissing) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetTunableValue");

	Params::DBDPlayer_GetTunableValue Parms{};

	Parms.Key = Key;
	Parms.defaultValue = defaultValue;
	Parms.warnIfRowMissing = warnIfRowMissing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.HasClearPathToTarget
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   TargetPosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::HasClearPathToTarget(const struct FVector& TargetPosition) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "HasClearPathToTarget");

	Params::DBDPlayer_HasClearPathToTarget Parms{};

	Parms.TargetPosition = std::move(TargetPosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.HasClearPathToTargetWithFilter
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   TargetPosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ClassFilter                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           IgnoreActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::HasClearPathToTargetWithFilter(const struct FVector& TargetPosition, TSubclassOf<class AActor> ClassFilter, class AActor* IgnoreActor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "HasClearPathToTargetWithFilter");

	Params::DBDPlayer_HasClearPathToTargetWithFilter Parms{};

	Parms.TargetPosition = std::move(TargetPosition);
	Parms.ClassFilter = ClassFilter;
	Parms.IgnoreActor = IgnoreActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.HasClearPathToTargetWithIgnore
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   TargetPosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            ignoreActors                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::HasClearPathToTargetWithIgnore(const struct FVector& TargetPosition, const TArray<class AActor*>& ignoreActors) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "HasClearPathToTargetWithIgnore");

	Params::DBDPlayer_HasClearPathToTargetWithIgnore Parms{};

	Parms.TargetPosition = std::move(TargetPosition);
	Parms.ignoreActors = std::move(ignoreActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.HasMoveInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::HasMoveInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "HasMoveInput");

	Params::DBDPlayer_HasMoveInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsBeingInterrupted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsBeingInterrupted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsBeingInterrupted");

	Params::DBDPlayer_IsBeingInterrupted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsCloaked
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsCloaked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsCloaked");

	Params::DBDPlayer_IsCloaked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsCrouching
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsCrouching() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsCrouching");

	Params::DBDPlayer_IsCrouching Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsCrouchPressed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsCrouchPressed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsCrouchPressed");

	Params::DBDPlayer_IsCrouchPressed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsExhausted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsExhausted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsExhausted");

	Params::DBDPlayer_IsExhausted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsForPreview
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsForPreview() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsForPreview");

	Params::DBDPlayer_IsForPreview Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsHeadHidden
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsHeadHidden() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsHeadHidden");

	Params::DBDPlayer_IsHeadHidden Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsIncapacitated
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsIncapacitated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsIncapacitated");

	Params::DBDPlayer_IsIncapacitated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsInMeathookZone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsInMeathookZone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsInMeathookZone");

	Params::DBDPlayer_IsInMeathookZone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsInParadise
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsInParadise() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsInParadise");

	Params::DBDPlayer_IsInParadise Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsInsideLocker
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsInsideLocker() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsInsideLocker");

	Params::DBDPlayer_IsInsideLocker Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsInStalkMode
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsInStalkMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsInStalkMode");

	Params::DBDPlayer_IsInStalkMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsInteractionInputPressed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInputInteractionType                   interactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsInteractionInputPressed(EInputInteractionType interactionType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsInteractionInputPressed");

	Params::DBDPlayer_IsInteractionInputPressed Parms{};

	Parms.interactionType = interactionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsInTerrorRadius
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsInTerrorRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsInTerrorRadius");

	Params::DBDPlayer_IsInTerrorRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsLocallyObserved
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsLocallyObserved() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsLocallyObserved");

	Params::DBDPlayer_IsLocallyObserved Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsMoving
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsMoving() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsMoving");

	Params::DBDPlayer_IsMoving Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsRunning
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsRunning() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsRunning");

	Params::DBDPlayer_IsRunning Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.Local_IsInteractionInputPressed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInputInteractionType                   interactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::Local_IsInteractionInputPressed(EInputInteractionType interactionType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Local_IsInteractionInputPressed");

	Params::DBDPlayer_Local_IsInteractionInputPressed Parms{};

	Parms.interactionType = interactionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.OnGetCharacterName
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ADBDPlayer::OnGetCharacterName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnGetCharacterName");

	Params::DBDPlayer_OnGetCharacterName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.ShouldFall
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::ShouldFall() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "ShouldFall");

	Params::DBDPlayer_ShouldFall Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.ShouldPlayCarryAnim
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::ShouldPlayCarryAnim() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "ShouldPlayCarryAnim");

	Params::DBDPlayer_ShouldPlayCarryAnim Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.UpdateLoadoutFromInventory
// (Final, Native, Public, Const)

void ADBDPlayer::UpdateLoadoutFromInventory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "UpdateLoadoutFromInventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChaseComponent.OnRep_IsInChase
// (Native, Protected)

void UChaseComponent::OnRep_IsInChase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaseComponent", "OnRep_IsInChase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChaseComponent.IsInChase
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UChaseComponent::IsInChase() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaseComponent", "IsInChase");

	Params::ChaseComponent_IsInChase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChaserCharacterComponent.Authority_OnChaseTargetFound
// (Final, Native, Private)
// Parameters:
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChaserCharacterComponent::Authority_OnChaseTargetFound(class APawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaserCharacterComponent", "Authority_OnChaseTargetFound");

	Params::ChaserCharacterComponent_Authority_OnChaseTargetFound Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChaserCharacterComponent.Multicast_OnAllChaseEnd
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void UChaserCharacterComponent::Multicast_OnAllChaseEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaserCharacterComponent", "Multicast_OnAllChaseEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChaserCharacterComponent.Multicast_OnChaseEnd
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FChaseUpdateInfo&          ChaseUpdateInfo                                        (ConstParm, Parm, NativeAccessSpecifierPublic)

void UChaserCharacterComponent::Multicast_OnChaseEnd(class ASurvivor* Survivor, const struct FChaseUpdateInfo& ChaseUpdateInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaserCharacterComponent", "Multicast_OnChaseEnd");

	Params::ChaserCharacterComponent_Multicast_OnChaseEnd Parms{};

	Parms.Survivor = Survivor;
	Parms.ChaseUpdateInfo = std::move(ChaseUpdateInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChaserCharacterComponent.Multicast_OnChaseStart
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChaserCharacterComponent::Multicast_OnChaseStart(class ASurvivor* Survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaserCharacterComponent", "Multicast_OnChaseStart");

	Params::ChaserCharacterComponent_Multicast_OnChaseStart Parms{};

	Parms.Survivor = Survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChaserCharacterComponent.OnKillerLocallyObservedChanged
// (Final, Native, Private)
// Parameters:
// bool                                    locallyObserved                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChaserCharacterComponent::OnKillerLocallyObservedChanged(bool locallyObserved)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaserCharacterComponent", "OnKillerLocallyObservedChanged");

	Params::ChaserCharacterComponent_OnKillerLocallyObservedChanged Parms{};

	Parms.locallyObserved = locallyObserved;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChaserCharacterComponent.OnRep_ChasedPlayers
// (Final, Native, Private, Const)

void UChaserCharacterComponent::OnRep_ChasedPlayers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaserCharacterComponent", "OnRep_ChasedPlayers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerProjectile.SetActiveSlashable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Active                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKillerProjectile::SetActiveSlashable(bool Active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerProjectile", "SetActiveSlashable");

	Params::KillerProjectile_SetActiveSlashable Parms{};

	Parms.Active = Active;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerProjectile.GetLaunchingKiller
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AKiller*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AKiller* AKillerProjectile::GetLaunchingKiller() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerProjectile", "GetLaunchingKiller");

	Params::KillerProjectile_GetLaunchingKiller Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.KillerProjectile.GetPlayerPrimitiveComponent
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// class UPrimitiveComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* AKillerProjectile::GetPlayerPrimitiveComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerProjectile", "GetPlayerPrimitiveComponent");

	Params::KillerProjectile_GetPlayerPrimitiveComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ColorBlindSettingsListenerInterface.OnColorBlindSettingsChange
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// EColorVisionDeficiency                  ColorBlindMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ColorblindIntensity                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IColorBlindSettingsListenerInterface::OnColorBlindSettingsChange(EColorVisionDeficiency ColorBlindMode, int32 ColorblindIntensity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ColorBlindSettingsListenerInterface", "OnColorBlindSettingsChange");

	Params::ColorBlindSettingsListenerInterface_OnColorBlindSettingsChange Parms{};

	Parms.ColorBlindMode = ColorBlindMode;
	Parms.ColorblindIntensity = ColorblindIntensity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LoudNoiseNotifier.CanSeeLoudNoise
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULoudNoiseNotifier::CanSeeLoudNoise(const class UObject* WorldContextObject, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LoudNoiseNotifier", "CanSeeLoudNoise");

	Params::LoudNoiseNotifier_CanSeeLoudNoise Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.LoudNoiseNotifier.Fire
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    shouldTrack                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   audibleRange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       instigatingPlayer                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isQuickAction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isDeceivingNoise                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULoudNoiseNotifier::Fire(const class UObject* WorldContextObject, class AActor* Instigator, const struct FVector& Location, bool shouldTrack, float audibleRange, class ADBDPlayer* instigatingPlayer, bool isQuickAction, bool isDeceivingNoise)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LoudNoiseNotifier", "Fire");

	Params::LoudNoiseNotifier_Fire Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Instigator = Instigator;
	Parms.Location = std::move(Location);
	Parms.shouldTrack = shouldTrack;
	Parms.audibleRange = audibleRange;
	Parms.instigatingPlayer = instigatingPlayer;
	Parms.isQuickAction = isQuickAction;
	Parms.isDeceivingNoise = isDeceivingNoise;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LoudNoiseNotifier.FireWithTimeBudgeter
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    shouldTrack                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   audibleRange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       instigatingPlayer                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isQuickAction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULoudNoiseNotifier::FireWithTimeBudgeter(const class UObject* WorldContextObject, class AActor* Instigator, const struct FVector& Location, bool shouldTrack, float audibleRange, class ADBDPlayer* instigatingPlayer, bool isQuickAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LoudNoiseNotifier", "FireWithTimeBudgeter");

	Params::LoudNoiseNotifier_FireWithTimeBudgeter Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Instigator = Instigator;
	Parms.Location = std::move(Location);
	Parms.shouldTrack = shouldTrack;
	Parms.audibleRange = audibleRange;
	Parms.instigatingPlayer = instigatingPlayer;
	Parms.isQuickAction = isQuickAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TotemBoundPerk.Authority_BindToDullTotems
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    allowAdditionalBoundTotems                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTotemBoundPerk::Authority_BindToDullTotems(bool allowAdditionalBoundTotems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TotemBoundPerk", "Authority_BindToDullTotems");

	Params::TotemBoundPerk_Authority_BindToDullTotems Parms{};

	Parms.allowAdditionalBoundTotems = allowAdditionalBoundTotems;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TotemBoundPerk.Authority_UnbindFromTotem
// (Native, Public)
// Parameters:
// class ATotem*                           aTotemActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTotemBoundPerk::Authority_UnbindFromTotem(class ATotem* aTotemActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TotemBoundPerk", "Authority_UnbindFromTotem");

	Params::TotemBoundPerk_Authority_UnbindFromTotem Parms{};

	Parms.aTotemActor = aTotemActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TotemBoundPerk.OnRep_BoundTotems
// (Final, Native, Private)

void UTotemBoundPerk::OnRep_BoundTotems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TotemBoundPerk", "OnRep_BoundTotems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TotemBoundPerk.GetBoundTotems
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ATotem*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ATotem*> UTotemBoundPerk::GetBoundTotems() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TotemBoundPerk", "GetBoundTotems");

	Params::TotemBoundPerk_GetBoundTotems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TotemBoundPerk.GetSquaredDistanceToOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AActor*                     Survivor                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTotemBoundPerk::GetSquaredDistanceToOwner(const class AActor* Survivor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TotemBoundPerk", "GetSquaredDistanceToOwner");

	Params::TotemBoundPerk_GetSquaredDistanceToOwner Parms{};

	Parms.Survivor = Survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TotemBoundPerk.GetTotems
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class ATotem*>             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ATotem*> UTotemBoundPerk::GetTotems() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TotemBoundPerk", "GetTotems");

	Params::TotemBoundPerk_GetTotems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDSpringArmComponent.IgnoreActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldIgnore                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDSpringArmComponent::IgnoreActor(class AActor* Actor, bool bShouldIgnore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDSpringArmComponent", "IgnoreActor");

	Params::DBDSpringArmComponent_IgnoreActor Parms{};

	Parms.Actor = Actor;
	Parms.bShouldIgnore = bShouldIgnore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDSpringArmComponent.ZoomCamera
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   zoomCount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   zoomDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDSpringArmComponent::ZoomCamera(float zoomCount, float zoomDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDSpringArmComponent", "ZoomCamera");

	Params::DBDSpringArmComponent_ZoomCamera Parms{};

	Parms.zoomCount = zoomCount;
	Parms.zoomDuration = zoomDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDSpringArmComponent.ZoomCameraToDefault
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   zoomDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDSpringArmComponent::ZoomCameraToDefault(float zoomDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDSpringArmComponent", "ZoomCameraToDefault");

	Params::DBDSpringArmComponent_ZoomCameraToDefault Parms{};

	Parms.zoomDuration = zoomDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDSpringArmComponent.ZoomCameraTowardsNewTargetArmLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   newTargetArmLength                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   zoomDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDSpringArmComponent::ZoomCameraTowardsNewTargetArmLength(float newTargetArmLength, float zoomDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDSpringArmComponent", "ZoomCameraTowardsNewTargetArmLength");

	Params::DBDSpringArmComponent_ZoomCameraTowardsNewTargetArmLength Parms{};

	Parms.newTargetArmLength = newTargetArmLength;
	Parms.zoomDuration = zoomDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierFunctionLibrary.Authority_ClearAllPlayerGameplayFlags
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       TargetPlayer                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayModifierFunctionLibrary::Authority_ClearAllPlayerGameplayFlags(class ADBDPlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayModifierFunctionLibrary", "Authority_ClearAllPlayerGameplayFlags");

	Params::GameplayModifierFunctionLibrary_Authority_ClearAllPlayerGameplayFlags Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierFunctionLibrary.Authority_ClearAllPlayerGameplayModifiers
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       TargetPlayer                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayModifierFunctionLibrary::Authority_ClearAllPlayerGameplayModifiers(class ADBDPlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayModifierFunctionLibrary", "Authority_ClearAllPlayerGameplayModifiers");

	Params::GameplayModifierFunctionLibrary_Authority_ClearAllPlayerGameplayModifiers Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierFunctionLibrary.Authority_ClearPlayerGameplayFlag
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       TargetPlayer                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              FlagType                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayModifierFunctionLibrary::Authority_ClearPlayerGameplayFlag(class ADBDPlayer* TargetPlayer, const struct FGameplayTag& FlagType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayModifierFunctionLibrary", "Authority_ClearPlayerGameplayFlag");

	Params::GameplayModifierFunctionLibrary_Authority_ClearPlayerGameplayFlag Parms{};

	Parms.TargetPlayer = TargetPlayer;
	Parms.FlagType = std::move(FlagType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierFunctionLibrary.Authority_ClearPlayerGameplayModifier
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       TargetPlayer                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              modifierType                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayModifierFunctionLibrary::Authority_ClearPlayerGameplayModifier(class ADBDPlayer* TargetPlayer, const struct FGameplayTag& modifierType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayModifierFunctionLibrary", "Authority_ClearPlayerGameplayModifier");

	Params::GameplayModifierFunctionLibrary_Authority_ClearPlayerGameplayModifier Parms{};

	Parms.TargetPlayer = TargetPlayer;
	Parms.modifierType = std::move(modifierType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierFunctionLibrary.Authority_SetPlayerGameplayFlag
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       TargetPlayer                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              FlagType                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayModifierFunctionLibrary::Authority_SetPlayerGameplayFlag(class ADBDPlayer* TargetPlayer, const struct FGameplayTag& FlagType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayModifierFunctionLibrary", "Authority_SetPlayerGameplayFlag");

	Params::GameplayModifierFunctionLibrary_Authority_SetPlayerGameplayFlag Parms{};

	Parms.TargetPlayer = TargetPlayer;
	Parms.FlagType = std::move(FlagType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierFunctionLibrary.Authority_SetPlayerGameplayModifier
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       TargetPlayer                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              modifierType                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ModifierValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayModifierFunctionLibrary::Authority_SetPlayerGameplayModifier(class ADBDPlayer* TargetPlayer, const struct FGameplayTag& modifierType, float ModifierValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayModifierFunctionLibrary", "Authority_SetPlayerGameplayModifier");

	Params::GameplayModifierFunctionLibrary_Authority_SetPlayerGameplayModifier Parms{};

	Parms.TargetPlayer = TargetPlayer;
	Parms.modifierType = std::move(modifierType);
	Parms.ModifierValue = ModifierValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AnimationFollowerActor.Cosmetic_OnMontageStarted
// (BlueprintCosmetic, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FAnimationMontageDescriptor&montagePlayed                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AAnimationFollowerActor::Cosmetic_OnMontageStarted(const struct FAnimationMontageDescriptor& montagePlayed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationFollowerActor", "Cosmetic_OnMontageStarted");

	Params::AnimationFollowerActor_Cosmetic_OnMontageStarted Parms{};

	Parms.montagePlayed = std::move(montagePlayed);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.AnimationFollowerActor.Cosmetic_OnMontageStopped
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void AAnimationFollowerActor::Cosmetic_OnMontageStopped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationFollowerActor", "Cosmetic_OnMontageStopped");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.AnimationFollowerActor.Cosmetic_OnVisibilityChanged
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    IsVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAnimationFollowerActor::Cosmetic_OnVisibilityChanged(bool IsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationFollowerActor", "Cosmetic_OnVisibilityChanged");

	Params::AnimationFollowerActor_Cosmetic_OnVisibilityChanged Parms{};

	Parms.IsVisible = IsVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.AnimationFollowerActor.NativeOnMontageEnded
// (Native, Protected)
// Parameters:
// const struct FAnimationMontageDescriptor&Montage                                                (ConstParm, Parm, NativeAccessSpecifierPublic)
// bool                                    interrupted                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAnimationFollowerActor::NativeOnMontageEnded(const struct FAnimationMontageDescriptor& Montage, bool interrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationFollowerActor", "NativeOnMontageEnded");

	Params::AnimationFollowerActor_NativeOnMontageEnded Parms{};

	Parms.Montage = std::move(Montage);
	Parms.interrupted = interrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AnimationFollowerActor.NativeOnMontageStarted
// (Native, Protected)
// Parameters:
// const struct FAnimationMontageDescriptor&ID                                                     (ConstParm, Parm, NativeAccessSpecifierPublic)
// const float                             Rate                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAnimationFollowerActor::NativeOnMontageStarted(const struct FAnimationMontageDescriptor& ID, const float Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationFollowerActor", "NativeOnMontageStarted");

	Params::AnimationFollowerActor_NativeOnMontageStarted Parms{};

	Parms.ID = std::move(ID);
	Parms.Rate = Rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AnimationFollowerActor.NativeOnMontageStopped
// (Native, Protected)
// Parameters:
// const struct FAnimationMontageDescriptor&ID                                                     (ConstParm, Parm, NativeAccessSpecifierPublic)

void AAnimationFollowerActor::NativeOnMontageStopped(const struct FAnimationMontageDescriptor& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationFollowerActor", "NativeOnMontageStopped");

	Params::AnimationFollowerActor_NativeOnMontageStopped Parms{};

	Parms.ID = std::move(ID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AnimationFollowerActor.OnMontageEnd
// (Final, Native, Private)
// Parameters:
// const struct FAnimationMontageDescriptor&MontageID                                              (ConstParm, Parm, NativeAccessSpecifierPublic)
// bool                                    interrupted                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAnimationFollowerActor::OnMontageEnd(const struct FAnimationMontageDescriptor& MontageID, bool interrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationFollowerActor", "OnMontageEnd");

	Params::AnimationFollowerActor_OnMontageEnd Parms{};

	Parms.MontageID = std::move(MontageID);
	Parms.interrupted = interrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AnimationFollowerActor.OnMontageStarted
// (Final, Native, Private)
// Parameters:
// const struct FAnimationMontageDescriptor&MontageID                                              (ConstParm, Parm, NativeAccessSpecifierPublic)
// const float                             Rate                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAnimationFollowerActor::OnMontageStarted(const struct FAnimationMontageDescriptor& MontageID, const float Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationFollowerActor", "OnMontageStarted");

	Params::AnimationFollowerActor_OnMontageStarted Parms{};

	Parms.MontageID = std::move(MontageID);
	Parms.Rate = Rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AnimationFollowerActor.OnMontageStopped
// (Final, Native, Private)
// Parameters:
// const struct FAnimationMontageDescriptor&MontageID                                              (ConstParm, Parm, NativeAccessSpecifierPublic)

void AAnimationFollowerActor::OnMontageStopped(const struct FAnimationMontageDescriptor& MontageID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationFollowerActor", "OnMontageStopped");

	Params::AnimationFollowerActor_OnMontageStopped Parms{};

	Parms.MontageID = std::move(MontageID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ObjectPlacerComponent.ActivateObjectPlacement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Active                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectPlacerComponent::ActivateObjectPlacement(bool Active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectPlacerComponent", "ActivateObjectPlacement");

	Params::ObjectPlacerComponent_ActivateObjectPlacement Parms{};

	Parms.Active = Active;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ObjectPlacerComponent.SetHideIndicatorDuringAttack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectPlacerComponent::SetHideIndicatorDuringAttack(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectPlacerComponent", "SetHideIndicatorDuringAttack");

	Params::ObjectPlacerComponent_SetHideIndicatorDuringAttack Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ObjectPlacerComponent.SetIndicatorOffsetX
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectPlacerComponent::SetIndicatorOffsetX(float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectPlacerComponent", "SetIndicatorOffsetX");

	Params::ObjectPlacerComponent_SetIndicatorOffsetX Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ObjectPlacerComponent.SetIndicatorOffsetY
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectPlacerComponent::SetIndicatorOffsetY(float Y)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectPlacerComponent", "SetIndicatorOffsetY");

	Params::ObjectPlacerComponent_SetIndicatorOffsetY Parms{};

	Parms.Y = Y;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ObjectPlacerComponent.SetMeshOffsetZ
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectPlacerComponent::SetMeshOffsetZ(float Z)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectPlacerComponent", "SetMeshOffsetZ");

	Params::ObjectPlacerComponent_SetMeshOffsetZ Parms{};

	Parms.Z = Z;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ObjectPlacerComponent.SetObjectMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             objectMesh                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectPlacerComponent::SetObjectMesh(class UStaticMeshComponent* objectMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectPlacerComponent", "SetObjectMesh");

	Params::ObjectPlacerComponent_SetObjectMesh Parms{};

	Parms.objectMesh = objectMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ObjectPlacerComponent.SetShowIndicator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectPlacerComponent::SetShowIndicator(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectPlacerComponent", "SetShowIndicator");

	Params::ObjectPlacerComponent_SetShowIndicator Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ObjectPlacerComponent.GetObjectPlacementLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UObjectPlacerComponent::GetObjectPlacementLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectPlacerComponent", "GetObjectPlacementLocation");

	Params::ObjectPlacerComponent_GetObjectPlacementLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ObjectPlacerComponent.GetObjectPlacementRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UObjectPlacerComponent::GetObjectPlacementRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectPlacerComponent", "GetObjectPlacementRotation");

	Params::ObjectPlacerComponent_GetObjectPlacementRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ObjectPlacerComponent.IsPlacementValid
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UObjectPlacerComponent::IsPlacementValid() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectPlacerComponent", "IsPlacementValid");

	Params::ObjectPlacerComponent_IsPlacementValid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargerComponent.OnRep_EnergyLevel
// (Final, Native, Private)
// Parameters:
// float                                   previousEnergyLevel                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargerComponent::OnRep_EnergyLevel(float previousEnergyLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargerComponent", "OnRep_EnergyLevel");

	Params::ChargerComponent_OnRep_EnergyLevel Parms{};

	Parms.previousEnergyLevel = previousEnergyLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargerComponent.Reset
// (Final, Native, Public, BlueprintCallable)

void UChargerComponent::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargerComponent", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargerComponent.SetEnergyLevel
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   EnergyLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargerComponent::SetEnergyLevel(float EnergyLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargerComponent", "SetEnergyLevel");

	Params::ChargerComponent_SetEnergyLevel Parms{};

	Parms.EnergyLevel = EnergyLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargerComponent.SetEnergyLevelAndGetDiff
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   EnergyLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargerComponent::SetEnergyLevelAndGetDiff(float EnergyLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargerComponent", "SetEnergyLevelAndGetDiff");

	Params::ChargerComponent_SetEnergyLevelAndGetDiff Parms{};

	Parms.EnergyLevel = EnergyLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargerComponent.SetMaxEnergyLevel
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   EnergyLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargerComponent::SetMaxEnergyLevel(float EnergyLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargerComponent", "SetMaxEnergyLevel");

	Params::ChargerComponent_SetMaxEnergyLevel Parms{};

	Parms.EnergyLevel = EnergyLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargerComponent.SetNormalizedEnergyLevel
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   EnergyLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargerComponent::SetNormalizedEnergyLevel(float EnergyLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargerComponent", "SetNormalizedEnergyLevel");

	Params::ChargerComponent_SetNormalizedEnergyLevel Parms{};

	Parms.EnergyLevel = EnergyLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargerComponent.UseEnergy
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   energyUseModifier                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargerComponent::UseEnergy(float Seconds, float energyUseModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargerComponent", "UseEnergy");

	Params::ChargerComponent_UseEnergy Parms{};

	Parms.Seconds = Seconds;
	Parms.energyUseModifier = energyUseModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargerComponent.GetEnergyLevel
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargerComponent::GetEnergyLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargerComponent", "GetEnergyLevel");

	Params::ChargerComponent_GetEnergyLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargerComponent.GetMaxEnergyLevel
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargerComponent::GetMaxEnergyLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargerComponent", "GetMaxEnergyLevel");

	Params::ChargerComponent_GetMaxEnergyLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargerComponent.GetNormalizedEnergyLevel
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargerComponent::GetNormalizedEnergyLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargerComponent", "GetNormalizedEnergyLevel");

	Params::ChargerComponent_GetNormalizedEnergyLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargerComponent.HasCharge
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UChargerComponent::HasCharge() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargerComponent", "HasCharge");

	Params::ChargerComponent_HasCharge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.QuickTimeEventPlayerComponent.Multicast_CompleteQuickTimeEvent
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const struct FQuickTimeEventResponse&   Response                                               (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UQuickTimeEventPlayerComponent::Multicast_CompleteQuickTimeEvent(const struct FQuickTimeEventResponse& Response)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuickTimeEventPlayerComponent", "Multicast_CompleteQuickTimeEvent");

	Params::QuickTimeEventPlayerComponent_Multicast_CompleteQuickTimeEvent Parms{};

	Parms.Response = std::move(Response);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DetectionZoneUtilities.DetectObstruction
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDetectionZone                          detectionZoneID                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPhysicalMaterial**               physicalMaterialOut                                    (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         positionOut                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         normalOut                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDetectionZoneUtilities::DetectObstruction(const class ADBDPlayer* Player, EDetectionZone detectionZoneID, class UPhysicalMaterial** physicalMaterialOut, struct FVector* positionOut, struct FVector* normalOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DetectionZoneUtilities", "DetectObstruction");

	Params::DetectionZoneUtilities_DetectObstruction Parms{};

	Parms.Player = Player;
	Parms.detectionZoneID = detectionZoneID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (physicalMaterialOut != nullptr)
		*physicalMaterialOut = Parms.physicalMaterialOut;

	if (positionOut != nullptr)
		*positionOut = std::move(Parms.positionOut);

	if (normalOut != nullptr)
		*normalOut = std::move(Parms.normalOut);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlayerInteractable.InitInteractable
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerInteractable::InitInteractable(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractable", "InitInteractable");

	Params::PlayerInteractable_InitInteractable Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BloodTrailComponent.ConditionalStartBleeding
// (Native, Public, BlueprintCallable)

void UBloodTrailComponent::ConditionalStartBleeding()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodTrailComponent", "ConditionalStartBleeding");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AICharacterBehaviourInteractWithActor.OnMovementFinished
// (Final, Native, Private)
// Parameters:
// const struct FAIRequestID&              RequestID                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// EPathFollowingResult                    Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAICharacterBehaviourInteractWithActor::OnMovementFinished(const struct FAIRequestID& RequestID, EPathFollowingResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterBehaviourInteractWithActor", "OnMovementFinished");

	Params::AICharacterBehaviourInteractWithActor_OnMovementFinished Parms{};

	Parms.RequestID = std::move(RequestID);
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FirstPersonViewComponent.OnIntroCompleted
// (Final, Native, Private)

void UFirstPersonViewComponent::OnIntroCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FirstPersonViewComponent", "OnIntroCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationStateComponent.OnControllerChanged
// (Final, Native, Private)
// Parameters:
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      OldController                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      NewController                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNavigationStateComponent::OnControllerChanged(class APawn* Pawn, class AController* OldController, class AController* NewController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationStateComponent", "OnControllerChanged");

	Params::NavigationStateComponent_OnControllerChanged Parms{};

	Parms.Pawn = Pawn;
	Parms.OldController = OldController;
	Parms.NewController = NewController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationStateComponent.OnRep_GuidedState
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGuidingInfo&              previousState                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UNavigationStateComponent::OnRep_GuidedState(const struct FGuidingInfo& previousState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationStateComponent", "OnRep_GuidedState");

	Params::NavigationStateComponent_OnRep_GuidedState Parms{};

	Parms.previousState = std::move(previousState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationStateComponent.OnRep_ImmobilizedState
// (Final, Native, Private)
// Parameters:
// EImmobilizedState                       previousState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNavigationStateComponent::OnRep_ImmobilizedState(EImmobilizedState previousState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationStateComponent", "OnRep_ImmobilizedState");

	Params::NavigationStateComponent_OnRep_ImmobilizedState Parms{};

	Parms.previousState = previousState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ObjectPlacementValidationWithRestrictionStrategy.OnIntroComplete
// (Native, Protected)

void UObjectPlacementValidationWithRestrictionStrategy::OnIntroComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectPlacementValidationWithRestrictionStrategy", "OnIntroComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ObjectPlacementValidationWithRestrictionStrategy.OnLevelReadyToPlay
// (Native, Protected)

void UObjectPlacementValidationWithRestrictionStrategy::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectPlacementValidationWithRestrictionStrategy", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerPerspectiveChangeComponent.FinalizeTargetPerspective
// (Native, Protected)

void UPlayerPerspectiveChangeComponent::FinalizeTargetPerspective()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerPerspectiveChangeComponent", "FinalizeTargetPerspective");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerPerspectiveChangeComponent.TransitionToTargetPerspective
// (BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// const struct FPlayerPerspectiveChangeTargetData&TargetData                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   TransitionDuration                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerPerspectiveChangeComponent::TransitionToTargetPerspective(const struct FPlayerPerspectiveChangeTargetData& TargetData, float TransitionDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerPerspectiveChangeComponent", "TransitionToTargetPerspective");

	Params::PlayerPerspectiveChangeComponent_TransitionToTargetPerspective Parms{};

	Parms.TargetData = std::move(TargetData);
	Parms.TransitionDuration = TransitionDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ConfigurableCollisionComponent.OnBeginOverlap
// (Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    fromSweep                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UConfigurableCollisionComponent::OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool fromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurableCollisionComponent", "OnBeginOverlap");

	Params::ConfigurableCollisionComponent_OnBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.fromSweep = fromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ConfigurableCollisionComponent.OnEndOverlap
// (Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConfigurableCollisionComponent::OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurableCollisionComponent", "OnEndOverlap");

	Params::ConfigurableCollisionComponent_OnEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ConfigurableCollisionComponent.OnLevelReadyToPlay
// (Native, Protected)

void UConfigurableCollisionComponent::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConfigurableCollisionComponent", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GroundDetectorUtilities.GetAudioSurfaceName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UBaseGroundDetectorComponent*     groundDetectorComponent                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UGroundDetectorUtilities::GetAudioSurfaceName(class UBaseGroundDetectorComponent* groundDetectorComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GroundDetectorUtilities", "GetAudioSurfaceName");

	Params::GroundDetectorUtilities_GetAudioSurfaceName Parms{};

	Parms.groundDetectorComponent = groundDetectorComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GroundDetectorUtilities.GetSurfaceType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UBaseGroundDetectorComponent*     groundDetectorComponent                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhysicalSurface                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPhysicalSurface UGroundDetectorUtilities::GetSurfaceType(class UBaseGroundDetectorComponent* groundDetectorComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GroundDetectorUtilities", "GetSurfaceType");

	Params::GroundDetectorUtilities_GetSurfaceType Parms{};

	Parms.groundDetectorComponent = groundDetectorComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GeneratorTrapPerk.Authority_OnExitGatesPowered
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              GameEventTag                                           (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UGeneratorTrapPerk::Authority_OnExitGatesPowered(const struct FGameplayTag& GameEventTag, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTrapPerk", "Authority_OnExitGatesPowered");

	Params::GeneratorTrapPerk_Authority_OnExitGatesPowered Parms{};

	Parms.GameEventTag = std::move(GameEventTag);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorTrapPerk.Authority_OnGeneratorCompleted
// (Final, Native, Private)
// Parameters:
// bool                                    isAutoCompleted                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorTrapPerk::Authority_OnGeneratorCompleted(bool isAutoCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTrapPerk", "Authority_OnGeneratorCompleted");

	Params::GeneratorTrapPerk_Authority_OnGeneratorCompleted Parms{};

	Parms.isAutoCompleted = isAutoCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorTrapPerk.Client_OnTrapActivated
// (Final, Net, Native, Event, Private, NetClient)
// Parameters:
// const class AGenerator*                 Generator                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorTrapPerk::Client_OnTrapActivated(const class AGenerator* Generator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTrapPerk", "Client_OnTrapActivated");

	Params::GeneratorTrapPerk_Client_OnTrapActivated Parms{};

	Parms.Generator = Generator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorTrapPerk.Client_OnTrapDestroyed
// (Final, Net, Native, Event, Private, NetClient)
// Parameters:
// const class AGenerator*                 Generator                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ETrapRemovedReason                Reason                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorTrapPerk::Client_OnTrapDestroyed(const class AGenerator* Generator, const ETrapRemovedReason Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTrapPerk", "Client_OnTrapDestroyed");

	Params::GeneratorTrapPerk_Client_OnTrapDestroyed Parms{};

	Parms.Generator = Generator;
	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorTrapPerk.Cosmetic_TrapActivated
// (Event, Protected, BlueprintEvent)
// Parameters:
// const class AGenerator*                 Generator                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorTrapPerk::Cosmetic_TrapActivated(const class AGenerator* Generator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTrapPerk", "Cosmetic_TrapActivated");

	Params::GeneratorTrapPerk_Cosmetic_TrapActivated Parms{};

	Parms.Generator = Generator;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.GeneratorTrapPerk.Cosmetic_TrapDestroyed
// (Event, Protected, BlueprintEvent)
// Parameters:
// const class AGenerator*                 Generator                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ETrapRemovedReason                Reason                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorTrapPerk::Cosmetic_TrapDestroyed(const class AGenerator* Generator, const ETrapRemovedReason Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTrapPerk", "Cosmetic_TrapDestroyed");

	Params::GeneratorTrapPerk_Cosmetic_TrapDestroyed Parms{};

	Parms.Generator = Generator;
	Parms.Reason = Reason;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.GeneratorTrapPerk.GetGeneratorTrapDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGeneratorTrapPerk::GetGeneratorTrapDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTrapPerk", "GetGeneratorTrapDuration");

	Params::GeneratorTrapPerk_GetGeneratorTrapDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.LevelReadyToPlayPlayerComponent.OnRep_LevelReadyToPlayRequirementsTarget
// (Final, Native, Private)

void ULevelReadyToPlayPlayerComponent::OnRep_LevelReadyToPlayRequirementsTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelReadyToPlayPlayerComponent", "OnRep_LevelReadyToPlayRequirementsTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LevelReadyToPlayPlayerComponent.Server_SetIsReadyToPlay
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const struct FFilesInformation&         hackInfo                                               (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ULevelReadyToPlayPlayerComponent::Server_SetIsReadyToPlay(const struct FFilesInformation& hackInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelReadyToPlayPlayerComponent", "Server_SetIsReadyToPlay");

	Params::LevelReadyToPlayPlayerComponent_Server_SetIsReadyToPlay Parms{};

	Parms.hackInfo = std::move(hackInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDBaseHud.DBD_ShowAnimHud
// (Final, Exec, Native, Protected)
// Parameters:
// bool                                    Show                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDBaseHud::DBD_ShowAnimHud(bool Show)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBaseHud", "DBD_ShowAnimHud");

	Params::DBDBaseHud_DBD_ShowAnimHud Parms{};

	Parms.Show = Show;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDBaseHud.ShowAnimHudBP
// (Event, Protected, BlueprintEvent)

void ADBDBaseHud::ShowAnimHudBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBaseHud", "ShowAnimHudBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.DBDBaseHud.ShouldDrawAnimHud
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDBaseHud::ShouldDrawAnimHud() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBaseHud", "ShouldDrawAnimHud");

	Params::DBDBaseHud_ShouldDrawAnimHud Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlashableActivationSourceCollection.AddSource
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlashableActivationSourceCollection::AddSource(class UObject* Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SlashableActivationSourceCollection", "AddSource");

	Params::SlashableActivationSourceCollection_AddSource Parms{};

	Parms.Source = Source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlashableActivationSourceCollection.ForceActivate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlashableActivationSourceCollection::ForceActivate(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SlashableActivationSourceCollection", "ForceActivate");

	Params::SlashableActivationSourceCollection_ForceActivate Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlashableActivationSourceCollection.RemoveSource
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlashableActivationSourceCollection::RemoveSource(class UObject* Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SlashableActivationSourceCollection", "RemoveSource");

	Params::SlashableActivationSourceCollection_RemoveSource Parms{};

	Parms.Source = Source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.QuestEventEvaluatorBase.OnGameEvent
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UQuestEventEvaluatorBase::OnGameEvent(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestEventEvaluatorBase", "OnGameEvent");

	Params::QuestEventEvaluatorBase_OnGameEvent Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LobbyDialogueSubsystem.CountGuestLobbyMembersWithAudioSwitch
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// EAudioCustomizationCategory             switchCategory                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FString>&            audioSwitches                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32*                                  numMatching                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  numNotMatching                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyDialogueSubsystem::CountGuestLobbyMembersWithAudioSwitch(EAudioCustomizationCategory switchCategory, const TArray<class FString>& audioSwitches, int32* numMatching, int32* numNotMatching)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LobbyDialogueSubsystem", "CountGuestLobbyMembersWithAudioSwitch");

	Params::LobbyDialogueSubsystem_CountGuestLobbyMembersWithAudioSwitch Parms{};

	Parms.switchCategory = switchCategory;
	Parms.audioSwitches = std::move(audioSwitches);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (numMatching != nullptr)
		*numMatching = Parms.numMatching;

	if (numNotMatching != nullptr)
		*numNotMatching = Parms.numNotMatching;
}


// Function DeadByDaylight.LobbyDialogueSubsystem.GetGuestLobbyMembers
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class ADBDMenuPlayer*>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ADBDMenuPlayer*> ULobbyDialogueSubsystem::GetGuestLobbyMembers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LobbyDialogueSubsystem", "GetGuestLobbyMembers");

	Params::LobbyDialogueSubsystem_GetGuestLobbyMembers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.LobbyDialogueSubsystem.HasCharacterPlayedDialogueForThisLobby
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    CharacterName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   dialogueId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULobbyDialogueSubsystem::HasCharacterPlayedDialogueForThisLobby(const class FString& CharacterName, int32 dialogueId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LobbyDialogueSubsystem", "HasCharacterPlayedDialogueForThisLobby");

	Params::LobbyDialogueSubsystem_HasCharacterPlayedDialogueForThisLobby Parms{};

	Parms.CharacterName = std::move(CharacterName);
	Parms.dialogueId = dialogueId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.LobbyDialogueSubsystem.IsLobbyFullForRole
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EPlayerRole                             Role                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULobbyDialogueSubsystem::IsLobbyFullForRole(EPlayerRole Role)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LobbyDialogueSubsystem", "IsLobbyFullForRole");

	Params::LobbyDialogueSubsystem_IsLobbyFullForRole Parms{};

	Parms.Role = Role;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.LobbyDialogueSubsystem.NotifyCharacterPlayedDialogueForThisLobby
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    CharacterName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   dialogueId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyDialogueSubsystem::NotifyCharacterPlayedDialogueForThisLobby(const class FString& CharacterName, int32 dialogueId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LobbyDialogueSubsystem", "NotifyCharacterPlayedDialogueForThisLobby");

	Params::LobbyDialogueSubsystem_NotifyCharacterPlayedDialogueForThisLobby Parms{};

	Parms.CharacterName = std::move(CharacterName);
	Parms.dialogueId = dialogueId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LobbyDialogueSubsystem.NotifyDialogueInterrupted
// (Final, Native, Static, Public, BlueprintCallable)

void ULobbyDialogueSubsystem::NotifyDialogueInterrupted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LobbyDialogueSubsystem", "NotifyDialogueInterrupted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDMenuPlayer.BeginCreateSequence
// (Event, Protected, BlueprintEvent)

void ADBDMenuPlayer::BeginCreateSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "BeginCreateSequence");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.DBDMenuPlayer.BeginDestroySequence_Internal
// (Native, Event, Protected, BlueprintEvent)

void ADBDMenuPlayer::BeginDestroySequence_Internal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "BeginDestroySequence_Internal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDMenuPlayer.BlockCharacterRotation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    shouldBlock                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDMenuPlayer::BlockCharacterRotation(bool shouldBlock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "BlockCharacterRotation");

	Params::DBDMenuPlayer_BlockCharacterRotation Parms{};

	Parms.shouldBlock = shouldBlock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDMenuPlayer.GetCharmSpawnerComponent
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class UCharmSpawnerComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCharmSpawnerComponent* ADBDMenuPlayer::GetCharmSpawnerComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "GetCharmSpawnerComponent");

	Params::DBDMenuPlayer_GetCharmSpawnerComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDMenuPlayer.HasSameCharacterInLobby
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDMenuPlayer::HasSameCharacterInLobby()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "HasSameCharacterInLobby");

	Params::DBDMenuPlayer_HasSameCharacterInLobby Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDMenuPlayer.IsInMenuPlayer
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDMenuPlayer::IsInMenuPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "IsInMenuPlayer");

	Params::DBDMenuPlayer_IsInMenuPlayer Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDMenuPlayer.OnAllPlayersReadyInOnlineLobby
// (Event, Public, BlueprintEvent)

void ADBDMenuPlayer::OnAllPlayersReadyInOnlineLobby()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "OnAllPlayersReadyInOnlineLobby");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.DBDMenuPlayer.OnCustomizationTransactionCompleted
// (Event, Public, BlueprintEvent)
// Parameters:
// ECustomizationCategory                  category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDMenuPlayer::OnCustomizationTransactionCompleted(ECustomizationCategory category)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "OnCustomizationTransactionCompleted");

	Params::DBDMenuPlayer_OnCustomizationTransactionCompleted Parms{};

	Parms.category = category;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBDMenuPlayer.OnFinishSpawnOnStand
// (Event, Public, BlueprintEvent)

void ADBDMenuPlayer::OnFinishSpawnOnStand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "OnFinishSpawnOnStand");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.DBDMenuPlayer.OnGameplayTagAnimNotify
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              InformationTag                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDMenuPlayer::OnGameplayTagAnimNotify(const struct FGameplayTag& InformationTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "OnGameplayTagAnimNotify");

	Params::DBDMenuPlayer_OnGameplayTagAnimNotify Parms{};

	Parms.InformationTag = std::move(InformationTag);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBDMenuPlayer.OnGuestPlayerDespawned
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADBDMenuPlayer*                   Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDMenuPlayer::OnGuestPlayerDespawned(class ADBDMenuPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "OnGuestPlayerDespawned");

	Params::DBDMenuPlayer_OnGuestPlayerDespawned Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBDMenuPlayer.OnGuestPlayerReadyChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADBDMenuPlayer*                   Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsReady                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDMenuPlayer::OnGuestPlayerReadyChanged(class ADBDMenuPlayer* Player, bool IsReady)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "OnGuestPlayerReadyChanged");

	Params::DBDMenuPlayer_OnGuestPlayerReadyChanged Parms{};

	Parms.Player = Player;
	Parms.IsReady = IsReady;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBDMenuPlayer.OnGuestPlayerSpawned
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADBDMenuPlayer*                   Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDMenuPlayer::OnGuestPlayerSpawned(class ADBDMenuPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "OnGuestPlayerSpawned");

	Params::DBDMenuPlayer_OnGuestPlayerSpawned Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBDMenuPlayer.OnIsReadyChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    IsReady                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDMenuPlayer::OnIsReadyChanged(bool IsReady)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "OnIsReadyChanged");

	Params::DBDMenuPlayer_OnIsReadyChanged Parms{};

	Parms.IsReady = IsReady;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBDMenuPlayer.OnLocalPlayerReadyChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    IsReady                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDMenuPlayer::OnLocalPlayerReadyChanged(bool IsReady)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "OnLocalPlayerReadyChanged");

	Params::DBDMenuPlayer_OnLocalPlayerReadyChanged Parms{};

	Parms.IsReady = IsReady;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBDMenuPlayer.OnLocalPlayerSpawned
// (Event, Public, BlueprintEvent)

void ADBDMenuPlayer::OnLocalPlayerSpawned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "OnLocalPlayerSpawned");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.DBDMenuPlayer.OnPlayerMaxPrestige
// (Event, Public, BlueprintEvent)

void ADBDMenuPlayer::OnPlayerMaxPrestige()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "OnPlayerMaxPrestige");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.DBDMenuPlayer.RestartInSequence_Internal
// (Event, Protected, BlueprintEvent)

void ADBDMenuPlayer::RestartInSequence_Internal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "RestartInSequence_Internal");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.DBDMenuPlayer.SetIsMuted
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    isMuted                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDMenuPlayer::SetIsMuted(bool isMuted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "SetIsMuted");

	Params::DBDMenuPlayer_SetIsMuted Parms{};

	Parms.isMuted = isMuted;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBDMenuPlayer.WrappedOnDestroyed
// (Final, Native, Private)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDMenuPlayer::WrappedOnDestroyed(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "WrappedOnDestroyed");

	Params::DBDMenuPlayer_WrappedOnDestroyed Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDMenuPlayer.GetBlockRotationAfterSpawningTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADBDMenuPlayer::GetBlockRotationAfterSpawningTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "GetBlockRotationAfterSpawningTime");

	Params::DBDMenuPlayer_GetBlockRotationAfterSpawningTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDMenuPlayer.GetCurrentMenu
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGameFlowStep                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGameFlowStep ADBDMenuPlayer::GetCurrentMenu() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "GetCurrentMenu");

	Params::DBDMenuPlayer_GetCurrentMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDMenuPlayer.GetHandPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EItemHandPosition                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EItemHandPosition ADBDMenuPlayer::GetHandPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "GetHandPosition");

	Params::DBDMenuPlayer_GetHandPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDMenuPlayer.GetIsLocalPlayerCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDMenuPlayer::GetIsLocalPlayerCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "GetIsLocalPlayerCharacter");

	Params::DBDMenuPlayer_GetIsLocalPlayerCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDMenuPlayer.GetIsReady
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDMenuPlayer::GetIsReady() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "GetIsReady");

	Params::DBDMenuPlayer_GetIsReady Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDMenuPlayer.ShouldApplyPositionOffset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDMenuPlayer::ShouldApplyPositionOffset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "ShouldApplyPositionOffset");

	Params::DBDMenuPlayer_ShouldApplyPositionOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDMenuPlayer.ShouldShowSpawnAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDMenuPlayer::ShouldShowSpawnAnimation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "ShouldShowSpawnAnimation");

	Params::DBDMenuPlayer_ShouldShowSpawnAnimation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDAIUtilities.DrawDebugAINavigation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDAIUtilities::DrawDebugAINavigation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDAIUtilities", "DrawDebugAINavigation");

	Params::DBDAIUtilities_DrawDebugAINavigation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDAIUtilities.DrawDebugAINavigationFilter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDAIUtilities::DrawDebugAINavigationFilter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDAIUtilities", "DrawDebugAINavigationFilter");

	Params::DBDAIUtilities_DrawDebugAINavigationFilter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDAIUtilities.DrawDebugAIPerception
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDAIUtilities::DrawDebugAIPerception()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDAIUtilities", "DrawDebugAIPerception");

	Params::DBDAIUtilities_DrawDebugAIPerception Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDAIUtilities.FindPathWithAgentRadiusToActorSynchronously
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   pathStart                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           GoalActor                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AgentRadius                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   tetherDistance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           pathfindingContext                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UNavigationQueryFilter>FilterClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNavigationPath*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNavigationPath* UDBDAIUtilities::FindPathWithAgentRadiusToActorSynchronously(class UObject* WorldContextObject, const struct FVector& pathStart, class AActor* GoalActor, float AgentRadius, float tetherDistance, class AActor* pathfindingContext, TSubclassOf<class UNavigationQueryFilter> FilterClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDAIUtilities", "FindPathWithAgentRadiusToActorSynchronously");

	Params::DBDAIUtilities_FindPathWithAgentRadiusToActorSynchronously Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.pathStart = std::move(pathStart);
	Parms.GoalActor = GoalActor;
	Parms.AgentRadius = AgentRadius;
	Parms.tetherDistance = tetherDistance;
	Parms.pathfindingContext = pathfindingContext;
	Parms.FilterClass = FilterClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDAIUtilities.SetCanEverAffectNavigation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UActorComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    affectNavigation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDAIUtilities::SetCanEverAffectNavigation(class UActorComponent* Component, bool affectNavigation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDAIUtilities", "SetCanEverAffectNavigation");

	Params::DBDAIUtilities_SetCanEverAffectNavigation Parms{};

	Parms.Component = Component;
	Parms.affectNavigation = affectNavigation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierCondition.OnOwningGameplayModifierSet
// (Event, Public, BlueprintEvent)

void UGameplayModifierCondition::OnOwningGameplayModifierSet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierCondition", "OnOwningGameplayModifierSet");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.GameplayModifierCondition.SetOwningGameplayModifier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameplayModifierContainer*       OwningGameplayModifier                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayModifierCondition::SetOwningGameplayModifier(class UGameplayModifierContainer* OwningGameplayModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierCondition", "SetOwningGameplayModifier");

	Params::GameplayModifierCondition_SetOwningGameplayModifier Parms{};

	Parms.OwningGameplayModifier = OwningGameplayModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierCondition.GetOwningGameplayModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UGameplayModifierContainer*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayModifierContainer* UGameplayModifierCondition::GetOwningGameplayModifier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierCondition", "GetOwningGameplayModifier");

	Params::GameplayModifierCondition_GetOwningGameplayModifier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierCondition.GetOwningPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UGameplayModifierCondition::GetOwningPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierCondition", "GetOwningPlayer");

	Params::GameplayModifierCondition_GetOwningPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierCondition.IsApplicable
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayModifierCondition::IsApplicable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierCondition", "IsApplicable");

	Params::GameplayModifierCondition_IsApplicable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SeancePerformerComponent.Cosmetic_OnInteractionCompleted
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void USeancePerformerComponent::Cosmetic_OnInteractionCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeancePerformerComponent", "Cosmetic_OnInteractionCompleted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.SeancePerformerComponent.Cosmetic_OnStartedInteracting
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void USeancePerformerComponent::Cosmetic_OnStartedInteracting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeancePerformerComponent", "Cosmetic_OnStartedInteracting");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.SeancePerformerComponent.Cosmetic_OnStoppedInteracting
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    interrupted                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USeancePerformerComponent::Cosmetic_OnStoppedInteracting(bool interrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeancePerformerComponent", "Cosmetic_OnStoppedInteracting");

	Params::SeancePerformerComponent_Cosmetic_OnStoppedInteracting Parms{};

	Parms.interrupted = interrupted;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBDGameState.AddDangerPredictionObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDBDDangerPredictionComponent*    toAdd                                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::AddDangerPredictionObject(class UDBDDangerPredictionComponent* toAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "AddDangerPredictionObject");

	Params::DBDGameState_AddDangerPredictionObject Parms{};

	Parms.toAdd = toAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.AddTrap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AInteractable*                    toAdd                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::AddTrap(class AInteractable* toAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "AddTrap");

	Params::DBDGameState_AddTrap Parms{};

	Parms.toAdd = toAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_DeactivateAI
// (Final, Native, Public)

void ADBDGameState::Authority_DeactivateAI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_DeactivateAI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_EnableObsession
// (Final, Native, Public, BlueprintCallable)

void ADBDGameState::Authority_EnableObsession()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_EnableObsession");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_EscapeThroughHatch
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ADBDGameState::Authority_EscapeThroughHatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_EscapeThroughHatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_EvaluateObsessionTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       potentialTarget                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::Authority_EvaluateObsessionTarget(class ADBDPlayer* potentialTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_EvaluateObsessionTarget");

	Params::DBDGameState_Authority_EvaluateObsessionTarget Parms{};

	Parms.potentialTarget = potentialTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_OnPlayerGameStateChangedAddIfKilled
// (Final, Native, Private)
// Parameters:
// class ADBDPlayerState*                  PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameState                              GameState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::Authority_OnPlayerGameStateChangedAddIfKilled(class ADBDPlayerState* PlayerState, EGameState GameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_OnPlayerGameStateChangedAddIfKilled");

	Params::DBDGameState_Authority_OnPlayerGameStateChangedAddIfKilled Parms{};

	Parms.PlayerState = PlayerState;
	Parms.GameState = GameState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_SetAllPlayerLoaded
// (Final, Native, Public)

void ADBDGameState::Authority_SetAllPlayerLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_SetAllPlayerLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_SetBuiltLevelData
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FBuiltLevelData&           BuiltLevelData                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ADBDGameState::Authority_SetBuiltLevelData(const struct FBuiltLevelData& BuiltLevelData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_SetBuiltLevelData");

	Params::DBDGameState_Authority_SetBuiltLevelData Parms{};

	Parms.BuiltLevelData = std::move(BuiltLevelData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_SetEscapeDoorOpened
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    OPENED                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::Authority_SetEscapeDoorOpened(bool OPENED)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_SetEscapeDoorOpened");

	Params::DBDGameState_Authority_SetEscapeDoorOpened Parms{};

	Parms.OPENED = OPENED;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_SetGameLevelCreated
// (Final, Native, Public)

void ADBDGameState::Authority_SetGameLevelCreated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_SetGameLevelCreated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_SetGameLevelEnded
// (Final, Native, Public)
// Parameters:
// EEndGameReason                          endGameReason                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::Authority_SetGameLevelEnded(EEndGameReason endGameReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_SetGameLevelEnded");

	Params::DBDGameState_Authority_SetGameLevelEnded Parms{};

	Parms.endGameReason = endGameReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_SetGameLevelLoaded
// (Final, Native, Public)

void ADBDGameState::Authority_SetGameLevelLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_SetGameLevelLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_SetGameSelectedOffering
// (Final, Native, Public, HasOutParams)
// Parameters:
// const TArray<struct FSelectedOffering>& offerings                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ADBDGameState::Authority_SetGameSelectedOffering(const TArray<struct FSelectedOffering>& offerings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_SetGameSelectedOffering");

	Params::DBDGameState_Authority_SetGameSelectedOffering Parms{};

	Parms.offerings = std::move(offerings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_SetGameStarted
// (Final, Native, Public)

void ADBDGameState::Authority_SetGameStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_SetGameStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_SetLevelReadyToPlay
// (Final, Native, Public, BlueprintCallable)

void ADBDGameState::Authority_SetLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_SetLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_SetObsessionTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASurvivor*                        obsessionTarget                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::Authority_SetObsessionTarget(class ASurvivor* obsessionTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_SetObsessionTarget");

	Params::DBDGameState_Authority_SetObsessionTarget Parms{};

	Parms.obsessionTarget = obsessionTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_SetSurvivorLeft
// (Final, Native, Public)
// Parameters:
// int32                                   survivorRemaining                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::Authority_SetSurvivorLeft(int32 survivorRemaining)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_SetSurvivorLeft");

	Params::DBDGameState_Authority_SetSurvivorLeft Parms{};

	Parms.survivorRemaining = survivorRemaining;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_SignalEscapeDoorActivated
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    newEscapeDoorActivated                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::Authority_SignalEscapeDoorActivated(bool newEscapeDoorActivated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_SignalEscapeDoorActivated");

	Params::DBDGameState_Authority_SignalEscapeDoorActivated Parms{};

	Parms.newEscapeDoorActivated = newEscapeDoorActivated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_UnsetLevelReadyToPlay
// (Final, Native, Public, BlueprintCallable)

void ADBDGameState::Authority_UnsetLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_UnsetLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_UpdateHatchState
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ADBDGameState::Authority_UpdateHatchState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_UpdateHatchState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.BroadcastOnSetBuildLevelData
// (Final, Native, Public)

void ADBDGameState::BroadcastOnSetBuildLevelData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "BroadcastOnSetBuildLevelData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.CallOnIntroComplete
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void()>                       Callback                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::CallOnIntroComplete(TDelegate<void()> Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "CallOnIntroComplete");

	Params::DBDGameState_CallOnIntroComplete Parms{};

	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.CallOnLevelReadyToPlay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void()>                       Callback                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::CallOnLevelReadyToPlay(TDelegate<void()> Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "CallOnLevelReadyToPlay");

	Params::DBDGameState_CallOnLevelReadyToPlay Parms{};

	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.CallOnSlasherSet
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(class AKiller* Slasher)> Callback                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::CallOnSlasherSet(TDelegate<void(class AKiller* Slasher)> Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "CallOnSlasherSet");

	Params::DBDGameState_CallOnSlasherSet Parms{};

	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.GetDangerPredictionObjects
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              isObjectDynamic                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class UDBDDangerPredictionComponent*>ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TArray<class UDBDDangerPredictionComponent*> ADBDGameState::GetDangerPredictionObjects(const bool isObjectDynamic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetDangerPredictionObjects");

	Params::DBDGameState_GetDangerPredictionObjects Parms{};

	Parms.isObjectDynamic = isObjectDynamic;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.IntroCompleted
// (Final, Native, Public, BlueprintCallable)

void ADBDGameState::IntroCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "IntroCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.IsObsessionTargetAlive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::IsObsessionTargetAlive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "IsObsessionTargetAlive");

	Params::DBDGameState_IsObsessionTargetAlive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.IsObsessionTargetAliveInLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::IsObsessionTargetAliveInLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "IsObsessionTargetAliveInLevel");

	Params::DBDGameState_IsObsessionTargetAliveInLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.Multicast_BroadcastOnLevelLoadingTimeOutClientEvent
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ADBDGameState::Multicast_BroadcastOnLevelLoadingTimeOutClientEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Multicast_BroadcastOnLevelLoadingTimeOutClientEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Multicast_FireLoudNoiseNotification
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// class AActor*                           loudNoiseInstigator                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    shouldTrack                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   audibleRange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       instigatingPlayer                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isQuickAction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isDeceivingNoise                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::Multicast_FireLoudNoiseNotification(class AActor* loudNoiseInstigator, const struct FVector& Location, bool shouldTrack, float audibleRange, class ADBDPlayer* instigatingPlayer, bool isQuickAction, bool isDeceivingNoise)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Multicast_FireLoudNoiseNotification");

	Params::DBDGameState_Multicast_FireLoudNoiseNotification Parms{};

	Parms.loudNoiseInstigator = loudNoiseInstigator;
	Parms.Location = std::move(Location);
	Parms.shouldTrack = shouldTrack;
	Parms.audibleRange = audibleRange;
	Parms.instigatingPlayer = instigatingPlayer;
	Parms.isQuickAction = isQuickAction;
	Parms.isDeceivingNoise = isDeceivingNoise;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Multicast_OnGameStarted
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ADBDGameState::Multicast_OnGameStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Multicast_OnGameStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Multicast_SendEnsureToClients
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// const class FString&                    Ensure                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::Multicast_SendEnsureToClients(const class FString& Ensure)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Multicast_SendEnsureToClients");

	Params::DBDGameState_Multicast_SendEnsureToClients Parms{};

	Parms.Ensure = std::move(Ensure);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Multicast_SendHVSPlusState
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::Multicast_SendHVSPlusState(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Multicast_SendHVSPlusState");

	Params::DBDGameState_Multicast_SendHVSPlusState Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Multicast_SetBuiltLevelData
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// const struct FBuiltLevelData&           BuiltLevelData                                         (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ADBDGameState::Multicast_SetBuiltLevelData(const struct FBuiltLevelData& BuiltLevelData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Multicast_SetBuiltLevelData");

	Params::DBDGameState_Multicast_SetBuiltLevelData Parms{};

	Parms.BuiltLevelData = std::move(BuiltLevelData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Multicast_SetGameEnded
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    hasServerLeftGame                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::Multicast_SetGameEnded(bool hasServerLeftGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Multicast_SetGameEnded");

	Params::DBDGameState_Multicast_SetGameEnded Parms{};

	Parms.hasServerLeftGame = hasServerLeftGame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Multicast_SetGameLevelEnded
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// EEndGameReason                          endGameReason                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::Multicast_SetGameLevelEnded(EEndGameReason endGameReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Multicast_SetGameLevelEnded");

	Params::DBDGameState_Multicast_SetGameLevelEnded Parms{};

	Parms.endGameReason = endGameReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Multicast_SetGameLevelLoaded
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    gameLevelLoaded                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::Multicast_SetGameLevelLoaded(bool gameLevelLoaded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Multicast_SetGameLevelLoaded");

	Params::DBDGameState_Multicast_SetGameLevelLoaded Parms{};

	Parms.gameLevelLoaded = gameLevelLoaded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Multicast_SetLostServerConnection
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    hasLostServerConnection                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::Multicast_SetLostServerConnection(bool hasLostServerConnection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Multicast_SetLostServerConnection");

	Params::DBDGameState_Multicast_SetLostServerConnection Parms{};

	Parms.hasLostServerConnection = hasLostServerConnection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Multicast_SetServerLeftGame
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    hasServerLeftGame                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::Multicast_SetServerLeftGame(bool hasServerLeftGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Multicast_SetServerLeftGame");

	Params::DBDGameState_Multicast_SetServerLeftGame Parms{};

	Parms.hasServerLeftGame = hasServerLeftGame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Multicast_UpdateCharacterFromGamePreset
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ADBDPlayerState_Menu*             playerState_Menu                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGamePresetData&           GamePresetData                                         (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ADBDGameState::Multicast_UpdateCharacterFromGamePreset(class ADBDPlayerState_Menu* playerState_Menu, const struct FGamePresetData& GamePresetData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Multicast_UpdateCharacterFromGamePreset");

	Params::DBDGameState_Multicast_UpdateCharacterFromGamePreset Parms{};

	Parms.playerState_Menu = playerState_Menu;
	Parms.GamePresetData = std::move(GamePresetData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.OnRep_BuildLevelData
// (Final, Native, Private)

void ADBDGameState::OnRep_BuildLevelData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "OnRep_BuildLevelData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.OnRep_EscapeDoorActivated
// (Final, Native, Private)
// Parameters:
// bool                                    OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::OnRep_EscapeDoorActivated(bool OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "OnRep_EscapeDoorActivated");

	Params::DBDGameState_OnRep_EscapeDoorActivated Parms{};

	Parms.OldValue = OldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.OnRep_GameLevelLoadingStarted
// (Final, Native, Private)
// Parameters:
// bool                                    OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::OnRep_GameLevelLoadingStarted(bool OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "OnRep_GameLevelLoadingStarted");

	Params::DBDGameState_OnRep_GameLevelLoadingStarted Parms{};

	Parms.OldValue = OldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.OnRep_GamePresetData
// (Final, Native, Private)

void ADBDGameState::OnRep_GamePresetData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "OnRep_GamePresetData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.OnRep_LobbyId
// (Final, Native, Private)

void ADBDGameState::OnRep_LobbyId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "OnRep_LobbyId");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.OnRep_NumberOfSurvivorsKilledOrSacrificed
// (Final, Native, Private)

void ADBDGameState::OnRep_NumberOfSurvivorsKilledOrSacrificed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "OnRep_NumberOfSurvivorsKilledOrSacrificed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.OnRep_ObsessionTarget
// (Final, Native, Private)
// Parameters:
// class ASurvivor*                        previousObsessionTarget                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::OnRep_ObsessionTarget(class ASurvivor* previousObsessionTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "OnRep_ObsessionTarget");

	Params::DBDGameState_OnRep_ObsessionTarget Parms{};

	Parms.previousObsessionTarget = previousObsessionTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.OnRep_OnGameLevelCreated
// (Final, Native, Private)

void ADBDGameState::OnRep_OnGameLevelCreated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "OnRep_OnGameLevelCreated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.OnRep_OnLevelReadyToPlay
// (Final, Native, Private)

void ADBDGameState::OnRep_OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "OnRep_OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.OnRep_SecondsLeftInLobby
// (Final, Native, Private)
// Parameters:
// const int32                             OldValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::OnRep_SecondsLeftInLobby(const int32 OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "OnRep_SecondsLeftInLobby");

	Params::DBDGameState_OnRep_SecondsLeftInLobby Parms{};

	Parms.OldValue = OldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.OnRep_SessionId
// (Final, Native, Private)

void ADBDGameState::OnRep_SessionId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "OnRep_SessionId");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.OnRep_SurvivorLeft
// (Final, Native, Private)
// Parameters:
// int32                                   OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::OnRep_SurvivorLeft(int32 OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "OnRep_SurvivorLeft");

	Params::DBDGameState_OnRep_SurvivorLeft Parms{};

	Parms.OldValue = OldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.OnRep_UseNetAsyncLoading
// (Final, Native, Private)

void ADBDGameState::OnRep_UseNetAsyncLoading()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "OnRep_UseNetAsyncLoading");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.RemoveDangerPredictionObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDBDDangerPredictionComponent*    toRemove                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::RemoveDangerPredictionObject(class UDBDDangerPredictionComponent* toRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "RemoveDangerPredictionObject");

	Params::DBDGameState_RemoveDangerPredictionObject Parms{};

	Parms.toRemove = toRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.RemoveTrap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AInteractable*                    toRemove                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::RemoveTrap(class AInteractable* toRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "RemoveTrap");

	Params::DBDGameState_RemoveTrap Parms{};

	Parms.toRemove = toRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.ResetGameLevelStatus
// (Final, Native, Public)

void ADBDGameState::ResetGameLevelStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "ResetGameLevelStatus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Server_UpdateGameRole
// (Final, Native, Public)

void ADBDGameState::Server_UpdateGameRole()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Server_UpdateGameRole");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.SetDisplayMapName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Display                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::SetDisplayMapName(bool Display)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "SetDisplayMapName");

	Params::DBDGameState_SetDisplayMapName Parms{};

	Parms.Display = Display;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.SetGameLevelEnded
// (Final, Native, Public)
// Parameters:
// EEndGameReason                          endGameReason                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::SetGameLevelEnded(EEndGameReason endGameReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "SetGameLevelEnded");

	Params::DBDGameState_SetGameLevelEnded Parms{};

	Parms.endGameReason = endGameReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.SetKillerIntroCompletedNormalized
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   completedAmount                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::SetKillerIntroCompletedNormalized(float completedAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "SetKillerIntroCompletedNormalized");

	Params::DBDGameState_SetKillerIntroCompletedNormalized Parms{};

	Parms.completedAmount = completedAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.SetPlayersReadyToStart
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    playersReadyToStart                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::SetPlayersReadyToStart(bool playersReadyToStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "SetPlayersReadyToStart");

	Params::DBDGameState_SetPlayersReadyToStart Parms{};

	Parms.playersReadyToStart = playersReadyToStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.SortOfferings
// (Final, Native, Public)

void ADBDGameState::SortOfferings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "SortOfferings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.UnregisterFromIntroCompleteAndLevelReadyToPlay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    inObject                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::UnregisterFromIntroCompleteAndLevelReadyToPlay(const class UObject* inObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "UnregisterFromIntroCompleteAndLevelReadyToPlay");

	Params::DBDGameState_UnregisterFromIntroCompleteAndLevelReadyToPlay Parms{};

	Parms.inObject = inObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.GetAllDangerPredictionObjects
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class UDBDDangerPredictionComponent*>ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TArray<class UDBDDangerPredictionComponent*> ADBDGameState::GetAllDangerPredictionObjects() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetAllDangerPredictionObjects");

	Params::DBDGameState_GetAllDangerPredictionObjects Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetCharacterCollection
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCharacterCollection*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCharacterCollection* ADBDGameState::GetCharacterCollection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetCharacterCollection");

	Params::DBDGameState_GetCharacterCollection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetCollectableCollection
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCollectableCollection*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCollectableCollection* ADBDGameState::GetCollectableCollection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetCollectableCollection");

	Params::DBDGameState_GetCollectableCollection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetEndGameStateComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEndGameStateComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEndGameStateComponent* ADBDGameState::GetEndGameStateComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetEndGameStateComponent");

	Params::DBDGameState_GetEndGameStateComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetGameLevelLoaded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::GetGameLevelLoaded() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetGameLevelLoaded");

	Params::DBDGameState_GetGameLevelLoaded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetGameLevelLoadingStarted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::GetGameLevelLoadingStarted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetGameLevelLoadingStarted");

	Params::DBDGameState_GetGameLevelLoadingStarted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetInGameBaseTraps
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class ABaseTrap*>          ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ABaseTrap*> ADBDGameState::GetInGameBaseTraps() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetInGameBaseTraps");

	Params::DBDGameState_GetInGameBaseTraps Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetInGameEscapeDoors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class AEscapeDoor*>        ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class AEscapeDoor*> ADBDGameState::GetInGameEscapeDoors() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetInGameEscapeDoors");

	Params::DBDGameState_GetInGameEscapeDoors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetInGameGenerators
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class AGenerator*>         ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class AGenerator*> ADBDGameState::GetInGameGenerators() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetInGameGenerators");

	Params::DBDGameState_GetInGameGenerators Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetInGameHatches
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class AHatch*>             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class AHatch*> ADBDGameState::GetInGameHatches() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetInGameHatches");

	Params::DBDGameState_GetInGameHatches Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetInGameMeatHooks
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class AMeatHook*>          ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class AMeatHook*> ADBDGameState::GetInGameMeatHooks() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetInGameMeatHooks");

	Params::DBDGameState_GetInGameMeatHooks Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetInGamePallets
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class APallet*>            ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class APallet*> ADBDGameState::GetInGamePallets() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetInGamePallets");

	Params::DBDGameState_GetInGamePallets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetInGameReverseBearTrapRemovers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class AReverseBearTrapRemover*>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class AReverseBearTrapRemover*> ADBDGameState::GetInGameReverseBearTrapRemovers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetInGameReverseBearTrapRemovers");

	Params::DBDGameState_GetInGameReverseBearTrapRemovers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetInGameSearchables
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class ASearchable*>        ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ASearchable*> ADBDGameState::GetInGameSearchables() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetInGameSearchables");

	Params::DBDGameState_GetInGameSearchables Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetInGameSpecialGenerators
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class AInteractable*>      ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class AInteractable*> ADBDGameState::GetInGameSpecialGenerators() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetInGameSpecialGenerators");

	Params::DBDGameState_GetInGameSpecialGenerators Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetInGameWindows
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class AWindow*>            ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class AWindow*> ADBDGameState::GetInGameWindows() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetInGameWindows");

	Params::DBDGameState_GetInGameWindows Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetIsGameEnded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::GetIsGameEnded() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetIsGameEnded");

	Params::DBDGameState_GetIsGameEnded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetKiller
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AKiller*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AKiller* ADBDGameState::GetKiller() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetKiller");

	Params::DBDGameState_GetKiller Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetKillerIntroCompletedNormalized
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADBDGameState::GetKillerIntroCompletedNormalized() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetKillerIntroCompletedNormalized");

	Params::DBDGameState_GetKillerIntroCompletedNormalized Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetLevelData
// (Final, Native, Public, Const)
// Parameters:
// const struct FBuiltLevelData            ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FBuiltLevelData ADBDGameState::GetLevelData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetLevelData");

	Params::DBDGameState_GetLevelData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetLevelThemeAudioSoundBankAssetPtr
// (Final, Native, Public, Const)
// Parameters:
// TSoftObjectPtr<class UAkAudioBank>      ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UAkAudioBank> ADBDGameState::GetLevelThemeAudioSoundBankAssetPtr() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetLevelThemeAudioSoundBankAssetPtr");

	Params::DBDGameState_GetLevelThemeAudioSoundBankAssetPtr Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetLocalPlayerBasePawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* ADBDGameState::GetLocalPlayerBasePawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetLocalPlayerBasePawn");

	Params::DBDGameState_GetLocalPlayerBasePawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetLocalPlayerPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* ADBDGameState::GetLocalPlayerPawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetLocalPlayerPawn");

	Params::DBDGameState_GetLocalPlayerPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetMapThemeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ADBDGameState::GetMapThemeName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetMapThemeName");

	Params::DBDGameState_GetMapThemeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetNumberOfActiveSurvivors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADBDGameState::GetNumberOfActiveSurvivors() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetNumberOfActiveSurvivors");

	Params::DBDGameState_GetNumberOfActiveSurvivors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetNumberOfOtherActiveSurvivors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       exception                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADBDGameState::GetNumberOfOtherActiveSurvivors(class ADBDPlayer* exception) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetNumberOfOtherActiveSurvivors");

	Params::DBDGameState_GetNumberOfOtherActiveSurvivors Parms{};

	Parms.exception = exception;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetObsessionTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASurvivor*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASurvivor* ADBDGameState::GetObsessionTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetObsessionTarget");

	Params::DBDGameState_GetObsessionTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetPlayerRoleCounts
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32*                                  survivorCount                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  killerCount                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  spectatorCount                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::GetPlayerRoleCounts(int32* survivorCount, int32* killerCount, int32* spectatorCount) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetPlayerRoleCounts");

	Params::DBDGameState_GetPlayerRoleCounts Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (survivorCount != nullptr)
		*survivorCount = Parms.survivorCount;

	if (killerCount != nullptr)
		*killerCount = Parms.killerCount;

	if (spectatorCount != nullptr)
		*spectatorCount = Parms.spectatorCount;
}


// Function DeadByDaylight.DBDGameState.GetPlayersReadyToStart
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::GetPlayersReadyToStart() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetPlayersReadyToStart");

	Params::DBDGameState_GetPlayersReadyToStart Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetPlayerStateByIDString
// (Final, Native, Public, Const)
// Parameters:
// const class FString&                    ID                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsReplacementBot                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayerState*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayerState* ADBDGameState::GetPlayerStateByIDString(const class FString& ID, bool IsReplacementBot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetPlayerStateByIDString");

	Params::DBDGameState_GetPlayerStateByIDString Parms{};

	Parms.ID = std::move(ID);
	Parms.IsReplacementBot = IsReplacementBot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetPlayerStateByMirrorsID
// (Final, Native, Public, Const)
// Parameters:
// const class FString&                    ID                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayerState*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayerState* ADBDGameState::GetPlayerStateByMirrorsID(const class FString& ID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetPlayerStateByMirrorsID");

	Params::DBDGameState_GetPlayerStateByMirrorsID Parms{};

	Parms.ID = std::move(ID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetSelectedOffering
// (Final, Native, Public, HasOutParams, Const)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSelectedOffering*               SelectedOffering                                       (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::GetSelectedOffering(int32 Index_0, struct FSelectedOffering* SelectedOffering) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetSelectedOffering");

	Params::DBDGameState_GetSelectedOffering Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SelectedOffering != nullptr)
		*SelectedOffering = std::move(Parms.SelectedOffering);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetSelectedOfferings
// (Final, Native, Public, Const)
// Parameters:
// const TArray<struct FSelectedOffering>  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FSelectedOffering> ADBDGameState::GetSelectedOfferings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetSelectedOfferings");

	Params::DBDGameState_GetSelectedOfferings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetSpecialEventGameplaySpawnerComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USpecialEventGameplaySpawnerComponent*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USpecialEventGameplaySpawnerComponent* ADBDGameState::GetSpecialEventGameplaySpawnerComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetSpecialEventGameplaySpawnerComponent");

	Params::DBDGameState_GetSpecialEventGameplaySpawnerComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetSurvivorLeft
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADBDGameState::GetSurvivorLeft() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetSurvivorLeft");

	Params::DBDGameState_GetSurvivorLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetTotems
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class ATotem*>             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ATotem*> ADBDGameState::GetTotems() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetTotems");

	Params::DBDGameState_GetTotems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetTraps
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class AInteractable*>      ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class AInteractable*> ADBDGameState::GetTraps() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetTraps");

	Params::DBDGameState_GetTraps Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.IsEscapeDoorActivated
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::IsEscapeDoorActivated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "IsEscapeDoorActivated");

	Params::DBDGameState_IsEscapeDoorActivated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.IsEscapeDoorOpen
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::IsEscapeDoorOpen() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "IsEscapeDoorOpen");

	Params::DBDGameState_IsEscapeDoorOpen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.IsHatchVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::IsHatchVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "IsHatchVisible");

	Params::DBDGameState_IsHatchVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.IsIntroCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::IsIntroCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "IsIntroCompleted");

	Params::DBDGameState_IsIntroCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.IsLevelReadyToPlay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::IsLevelReadyToPlay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "IsLevelReadyToPlay");

	Params::DBDGameState_IsLevelReadyToPlay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.IsLevelSetupDone
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::IsLevelSetupDone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "IsLevelSetupDone");

	Params::DBDGameState_IsLevelSetupDone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.IsLightingGenerated
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::IsLightingGenerated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "IsLightingGenerated");

	Params::DBDGameState_IsLightingGenerated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.IsOfferingReceived
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::IsOfferingReceived() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "IsOfferingReceived");

	Params::DBDGameState_IsOfferingReceived Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.IsOnePlayerLeft
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::IsOnePlayerLeft() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "IsOnePlayerLeft");

	Params::DBDGameState_IsOnePlayerLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.IsPlayerDistributionReady
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::IsPlayerDistributionReady() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "IsPlayerDistributionReady");

	Params::DBDGameState_IsPlayerDistributionReady Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.OnRep_HatchOpened
// (Final, Native, Private, Const)

void ADBDGameState::OnRep_HatchOpened() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "OnRep_HatchOpened");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.UpdateInGamePallets
// (Final, Native, Public, BlueprintCallable, Const)

void ADBDGameState::UpdateInGamePallets() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "UpdateInGamePallets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TriggerableWorldObjectComponent.Authority_ConditionalVolumeBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UTriggerableWorldObjectComponent::Authority_ConditionalVolumeBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerableWorldObjectComponent", "Authority_ConditionalVolumeBeginOverlap");

	Params::TriggerableWorldObjectComponent_Authority_ConditionalVolumeBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TriggerableWorldObjectComponent.Authority_ConditionalVolumeEndOverlap
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTriggerableWorldObjectComponent::Authority_ConditionalVolumeEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerableWorldObjectComponent", "Authority_ConditionalVolumeEndOverlap");

	Params::TriggerableWorldObjectComponent_Authority_ConditionalVolumeEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TriggerableWorldObjectComponent.Authority_GuaranteedVolumeOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UTriggerableWorldObjectComponent::Authority_GuaranteedVolumeOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerableWorldObjectComponent", "Authority_GuaranteedVolumeOverlap");

	Params::TriggerableWorldObjectComponent_Authority_GuaranteedVolumeOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TriggerableWorldObjectComponent.Multicast_OnTriggered
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// class ACharacter*                       Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   triggerLocation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTriggerableWorldObjectComponent::Multicast_OnTriggered(class ACharacter* Instigator, const struct FVector& triggerLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerableWorldObjectComponent", "Multicast_OnTriggered");

	Params::TriggerableWorldObjectComponent_Multicast_OnTriggered Parms{};

	Parms.Instigator = Instigator;
	Parms.triggerLocation = std::move(triggerLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TriggerableWorldObjectComponent.Multicast_OnTriggerReset
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void UTriggerableWorldObjectComponent::Multicast_OnTriggerReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerableWorldObjectComponent", "Multicast_OnTriggerReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TriggerableWorldObjectComponent.OnLevelReadyToPlay
// (Final, Native, Protected)

void UTriggerableWorldObjectComponent::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerableWorldObjectComponent", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TriggerableWorldObjectComponent.SetConditionalTriggerVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Volume                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTriggerableWorldObjectComponent::SetConditionalTriggerVolume(class UPrimitiveComponent* Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerableWorldObjectComponent", "SetConditionalTriggerVolume");

	Params::TriggerableWorldObjectComponent_SetConditionalTriggerVolume Parms{};

	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TriggerableWorldObjectComponent.SetGuaranteedTriggerVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Volume                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTriggerableWorldObjectComponent::SetGuaranteedTriggerVolume(class UPrimitiveComponent* Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerableWorldObjectComponent", "SetGuaranteedTriggerVolume");

	Params::TriggerableWorldObjectComponent_SetGuaranteedTriggerVolume Parms{};

	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BlueprintPlatformUtilities.ToFloat
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDBDPerPlatformFloat&      PerPlatformFloat                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const class UObject*                    objectInWorld                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBlueprintPlatformUtilities::ToFloat(const struct FDBDPerPlatformFloat& PerPlatformFloat, const class UObject* objectInWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintPlatformUtilities", "ToFloat");

	Params::BlueprintPlatformUtilities_ToFloat Parms{};

	Parms.PerPlatformFloat = std::move(PerPlatformFloat);
	Parms.objectInWorld = objectInWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.BlueprintPlatformUtilities.ToInteger
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDBDPerPlatformInt&        PerPlatformInt                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const class UObject*                    objectInWorld                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBlueprintPlatformUtilities::ToInteger(const struct FDBDPerPlatformInt& PerPlatformInt, const class UObject* objectInWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintPlatformUtilities", "ToInteger");

	Params::BlueprintPlatformUtilities_ToInteger Parms{};

	Parms.PerPlatformInt = std::move(PerPlatformInt);
	Parms.objectInWorld = objectInWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AICharacterEscapeCarriedData.Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    preventWiggleSuccess                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAICharacterEscapeCarriedData::Init(bool preventWiggleSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterEscapeCarriedData", "Init");

	Params::AICharacterEscapeCarriedData_Init Parms{};

	Parms.preventWiggleSuccess = preventWiggleSuccess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDDesignTunables.GetArrayGameTypeTunable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EGameType                               gameType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameTypeModifierName                   TunableName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UDBDDesignTunables::GetArrayGameTypeTunable(EGameType gameType, EGameTypeModifierName TunableName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDDesignTunables", "GetArrayGameTypeTunable");

	Params::DBDDesignTunables_GetArrayGameTypeTunable Parms{};

	Parms.gameType = gameType;
	Parms.TunableName = TunableName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDDesignTunables.GetBoolGameTypeTunable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EGameType                               gameType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameTypeModifierName                   TunableName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDDesignTunables::GetBoolGameTypeTunable(EGameType gameType, EGameTypeModifierName TunableName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDDesignTunables", "GetBoolGameTypeTunable");

	Params::DBDDesignTunables_GetBoolGameTypeTunable Parms{};

	Parms.gameType = gameType;
	Parms.TunableName = TunableName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDDesignTunables.GetBoolManualTunableValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              defaultValue                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    warnIfRowMissing                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDDesignTunables::GetBoolManualTunableValue(class FName ID, const bool defaultValue, bool warnIfRowMissing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDDesignTunables", "GetBoolManualTunableValue");

	Params::DBDDesignTunables_GetBoolManualTunableValue Parms{};

	Parms.ID = ID;
	Parms.defaultValue = defaultValue;
	Parms.warnIfRowMissing = warnIfRowMissing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDDesignTunables.GetFloatGameTypeTunable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EGameType                               gameType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameTypeModifierName                   TunableName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDDesignTunables::GetFloatGameTypeTunable(EGameType gameType, EGameTypeModifierName TunableName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDDesignTunables", "GetFloatGameTypeTunable");

	Params::DBDDesignTunables_GetFloatGameTypeTunable Parms{};

	Parms.gameType = gameType;
	Parms.TunableName = TunableName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDDesignTunables.GetFloatManualTunableValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             defaultValue                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    warnIfRowMissing                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDDesignTunables::GetFloatManualTunableValue(class FName ID, const float defaultValue, bool warnIfRowMissing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDDesignTunables", "GetFloatManualTunableValue");

	Params::DBDDesignTunables_GetFloatManualTunableValue Parms{};

	Parms.ID = ID;
	Parms.defaultValue = defaultValue;
	Parms.warnIfRowMissing = warnIfRowMissing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDDesignTunables.GetInt32ManualTunableValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             defaultValue                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    warnIfRowMissing                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDBDDesignTunables::GetInt32ManualTunableValue(class FName ID, const int32 defaultValue, bool warnIfRowMissing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDDesignTunables", "GetInt32ManualTunableValue");

	Params::DBDDesignTunables_GetInt32ManualTunableValue Parms{};

	Parms.ID = ID;
	Parms.defaultValue = defaultValue;
	Parms.warnIfRowMissing = warnIfRowMissing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDDesignTunables.GetIntGameTypeTunable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EGameType                               gameType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameTypeModifierName                   TunableName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDBDDesignTunables::GetIntGameTypeTunable(EGameType gameType, EGameTypeModifierName TunableName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDDesignTunables", "GetIntGameTypeTunable");

	Params::DBDDesignTunables_GetIntGameTypeTunable Parms{};

	Parms.gameType = gameType;
	Parms.TunableName = TunableName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDDesignTunables.GetStringArrayManualTunableValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FString>&            defaultValue                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    warnIfRowMissing                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UDBDDesignTunables::GetStringArrayManualTunableValue(class FName ID, const TArray<class FString>& defaultValue, bool warnIfRowMissing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDDesignTunables", "GetStringArrayManualTunableValue");

	Params::DBDDesignTunables_GetStringArrayManualTunableValue Parms{};

	Parms.ID = ID;
	Parms.defaultValue = std::move(defaultValue);
	Parms.warnIfRowMissing = warnIfRowMissing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDDesignTunables.GetStringGameTypeTunable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EGameType                               gameType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameTypeModifierName                   TunableName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDBDDesignTunables::GetStringGameTypeTunable(EGameType gameType, EGameTypeModifierName TunableName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDDesignTunables", "GetStringGameTypeTunable");

	Params::DBDDesignTunables_GetStringGameTypeTunable Parms{};

	Parms.gameType = gameType;
	Parms.TunableName = TunableName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDDesignTunables.GetStringManualTunableValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    defaultValue                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    warnIfRowMissing                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDBDDesignTunables::GetStringManualTunableValue(class FName ID, const class FString& defaultValue, bool warnIfRowMissing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDDesignTunables", "GetStringManualTunableValue");

	Params::DBDDesignTunables_GetStringManualTunableValue Parms{};

	Parms.ID = ID;
	Parms.defaultValue = std::move(defaultValue);
	Parms.warnIfRowMissing = warnIfRowMissing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDDesignTunables.OnPluginDataPathAdded
// (Final, Native, Private)
// Parameters:
// const class FString&                    DataPath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDDesignTunables::OnPluginDataPathAdded(const class FString& DataPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDDesignTunables", "OnPluginDataPathAdded");

	Params::DBDDesignTunables_OnPluginDataPathAdded Parms{};

	Parms.DataPath = std::move(DataPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDDesignTunables.GetTunableValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    warnIfRowMissing                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDDesignTunables::GetTunableValue(class FName ID, bool warnIfRowMissing) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDDesignTunables", "GetTunableValue");

	Params::DBDDesignTunables_GetTunableValue Parms{};

	Parms.ID = ID;
	Parms.warnIfRowMissing = warnIfRowMissing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDEmblem.Client_FinalizeReplication
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// const float                             Points                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FProgressionPoints>&ProgressionPoints                                      (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UDBDEmblem::Client_FinalizeReplication(const float Points, const TArray<struct FProgressionPoints>& ProgressionPoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDEmblem", "Client_FinalizeReplication");

	Params::DBDEmblem_Client_FinalizeReplication Parms{};

	Parms.Points = Points;
	Parms.ProgressionPoints = std::move(ProgressionPoints);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDEmblem.Server_EnableEmblemDebugging
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDEmblem::Server_EnableEmblemDebugging(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDEmblem", "Server_EnableEmblemDebugging");

	Params::DBDEmblem_Server_EnableEmblemDebugging Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.AddDamagingInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInteractionDefinition*           Interaction                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::AddDamagingInteraction(class UInteractionDefinition* Interaction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "AddDamagingInteraction");

	Params::Generator_AddDamagingInteraction Parms{};

	Parms.Interaction = Interaction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.AddPlayerStartTime
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   starttime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::AddPlayerStartTime(class ADBDPlayer* Player, float starttime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "AddPlayerStartTime");

	Params::Generator_AddPlayerStartTime Parms{};

	Parms.Player = Player;
	Parms.starttime = starttime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.AT_SetActivated
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    activated                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::AT_SetActivated(bool activated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "AT_SetActivated");

	Params::Generator_AT_SetActivated Parms{};

	Parms.activated = activated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.Authority_AddBlockingSource
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    Source                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::Authority_AddBlockingSource(const class UObject* Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "Authority_AddBlockingSource");

	Params::Generator_Authority_AddBlockingSource Parms{};

	Parms.Source = Source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.Authority_AddTimedBlockingSource
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    Source                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             blockingTime                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::Authority_AddTimedBlockingSource(const class UObject* Source, const float blockingTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "Authority_AddTimedBlockingSource");

	Params::Generator_Authority_AddTimedBlockingSource Parms{};

	Parms.Source = Source;
	Parms.blockingTime = blockingTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.Authority_OnChargeApplied
// (Final, Native, Private)
// Parameters:
// float                                   IndividualChargeAmount                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TotalChargeAmount                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ChargeInstigator                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    WasCoop                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::Authority_OnChargeApplied(float IndividualChargeAmount, float TotalChargeAmount, class AActor* ChargeInstigator, bool WasCoop, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "Authority_OnChargeApplied");

	Params::Generator_Authority_OnChargeApplied Parms{};

	Parms.IndividualChargeAmount = IndividualChargeAmount;
	Parms.TotalChargeAmount = TotalChargeAmount;
	Parms.ChargeInstigator = ChargeInstigator;
	Parms.WasCoop = WasCoop;
	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.Authority_OnChargeChanged
// (Final, Native, Private)
// Parameters:
// class UChargeableComponent*             ChargeableComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PercentCompletionChange                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TotalPercentComplete                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::Authority_OnChargeChanged(class UChargeableComponent* ChargeableComponent, float PercentCompletionChange, float TotalPercentComplete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "Authority_OnChargeChanged");

	Params::Generator_Authority_OnChargeChanged Parms{};

	Parms.ChargeableComponent = ChargeableComponent;
	Parms.PercentCompletionChange = PercentCompletionChange;
	Parms.TotalPercentComplete = TotalPercentComplete;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.Authority_RemoveBlockingSource
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    Source                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::Authority_RemoveBlockingSource(const class UObject* Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "Authority_RemoveBlockingSource");

	Params::Generator_Authority_RemoveBlockingSource Parms{};

	Parms.Source = Source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.Authority_RepairDamage
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       repairedBy                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::Authority_RepairDamage(class ADBDPlayer* repairedBy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "Authority_RepairDamage");

	Params::Generator_Authority_RepairDamage Parms{};

	Parms.repairedBy = repairedBy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.Authority_SetRepaired
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              showGeneratorCloneLoudNoise                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              isAutoCompleted                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::Authority_SetRepaired(const bool showGeneratorCloneLoudNoise, const bool isAutoCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "Authority_SetRepaired");

	Params::Generator_Authority_SetRepaired Parms{};

	Parms.showGeneratorCloneLoudNoise = showGeneratorCloneLoudNoise;
	Parms.isAutoCompleted = isAutoCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.BroadcastIsDamagedChangedEvent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::BroadcastIsDamagedChangedEvent(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "BroadcastIsDamagedChangedEvent");

	Params::Generator_BroadcastIsDamagedChangedEvent Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.DisableInaccessibleInteractors
// (Final, Native, Private)

void AGenerator::DisableInaccessibleInteractors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "DisableInaccessibleInteractors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.GetIsBlockedFromCharging
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGenerator::GetIsBlockedFromCharging()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "GetIsBlockedFromCharging");

	Params::Generator_GetIsBlockedFromCharging Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Generator.Multicast_OnRepaired
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const bool                              showGeneratorCloneLoudNoise                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              isAutoCompleted                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             updatedRemainingGeneratorCount                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::Multicast_OnRepaired(const bool showGeneratorCloneLoudNoise, const bool isAutoCompleted, const int32 updatedRemainingGeneratorCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "Multicast_OnRepaired");

	Params::Generator_Multicast_OnRepaired Parms{};

	Parms.showGeneratorCloneLoudNoise = showGeneratorCloneLoudNoise;
	Parms.isAutoCompleted = isAutoCompleted;
	Parms.updatedRemainingGeneratorCount = updatedRemainingGeneratorCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.Multicast_PlayFailSparksFX
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Explode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::Multicast_PlayFailSparksFX(class ADBDPlayer* Player, bool Explode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "Multicast_PlayFailSparksFX");

	Params::Generator_Multicast_PlayFailSparksFX Parms{};

	Parms.Player = Player;
	Parms.Explode = Explode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.NotifyRepairFinish
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractor*                      Interactor                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::NotifyRepairFinish(const class ADBDPlayer* Player, class UInteractor* Interactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "NotifyRepairFinish");

	Params::Generator_NotifyRepairFinish Parms{};

	Parms.Player = Player;
	Parms.Interactor = Interactor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Generator.NotifyRepairStart
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::NotifyRepairStart(const class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "NotifyRepairStart");

	Params::Generator_NotifyRepairStart Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Generator.OnBlockingStatusChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// const bool                              IsBlocked                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::OnBlockingStatusChanged(const bool IsBlocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "OnBlockingStatusChanged");

	Params::Generator_OnBlockingStatusChanged Parms{};

	Parms.IsBlocked = IsBlocked;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Generator.OnCaptureProbeSecondState
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AGenerator::OnCaptureProbeSecondState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "OnCaptureProbeSecondState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Generator.OnChargeChanged
// (Final, Native, Private)
// Parameters:
// class UChargeableComponent*             ChargeableComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Percent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::OnChargeChanged(class UChargeableComponent* ChargeableComponent, float Percent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "OnChargeChanged");

	Params::Generator_OnChargeChanged Parms{};

	Parms.ChargeableComponent = ChargeableComponent;
	Parms.Percent = Percent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.OnEscapeDoorActivated
// (Event, Protected, BlueprintEvent)

void AGenerator::OnEscapeDoorActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "OnEscapeDoorActivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Generator.OnPreWarmASMCache
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AGenerator::OnPreWarmASMCache()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "OnPreWarmASMCache");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Generator.OnRegressionStateChanged
// (Final, Native, Private)
// Parameters:
// const bool                              regressing                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       lastDamageChangeSource                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::OnRegressionStateChanged(const bool regressing, class ADBDPlayer* lastDamageChangeSource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "OnRegressionStateChanged");

	Params::Generator_OnRegressionStateChanged Parms{};

	Parms.regressing = regressing;
	Parms.lastDamageChangeSource = lastDamageChangeSource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.OnRep_IsBlocked
// (Final, Native, Private)

void AGenerator::OnRep_IsBlocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "OnRep_IsBlocked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.OnRepairedBP
// (Event, Public, BlueprintEvent)
// Parameters:
// const bool                              showGeneratorCloneLoudNoise                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              isAutoCompleted                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::OnRepairedBP(const bool showGeneratorCloneLoudNoise, const bool isAutoCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "OnRepairedBP");

	Params::Generator_OnRepairedBP Parms{};

	Parms.showGeneratorCloneLoudNoise = showGeneratorCloneLoudNoise;
	Parms.isAutoCompleted = isAutoCompleted;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Generator.OnResetGenerator
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void AGenerator::OnResetGenerator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "OnResetGenerator");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Generator.OnUpdateChargeProgress
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   newPercentComplete                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::OnUpdateChargeProgress(float newPercentComplete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "OnUpdateChargeProgress");

	Params::Generator_OnUpdateChargeProgress Parms{};

	Parms.newPercentComplete = newPercentComplete;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.PlayFailSparksFX
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       interactingPlayer                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Explode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::PlayFailSparksFX(class ADBDPlayer* interactingPlayer, bool Explode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "PlayFailSparksFX");

	Params::Generator_PlayFailSparksFX Parms{};

	Parms.interactingPlayer = interactingPlayer;
	Parms.Explode = Explode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Generator.PostAkEvent
// (Final, BlueprintCosmetic, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAkAudioEvent*                    akEvent                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   callbackMask                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)>&postEventCallback                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AGenerator::PostAkEvent(class UAkAudioEvent* akEvent, int32 callbackMask, const TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)>& postEventCallback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "PostAkEvent");

	Params::Generator_PostAkEvent Parms{};

	Parms.akEvent = akEvent;
	Parms.callbackMask = callbackMask;
	Parms.postEventCallback = postEventCallback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Generator.RemovePlayerStartTime
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::RemovePlayerStartTime(const class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "RemovePlayerStartTime");

	Params::Generator_RemovePlayerStartTime Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.ResetGenerator
// (Final, Native, Public, BlueprintCallable)

void AGenerator::ResetGenerator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "ResetGenerator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.SetComplete
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    complete                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::SetComplete(bool complete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "SetComplete");

	Params::Generator_SetComplete Parms{};

	Parms.complete = complete;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Generator.SetIsAutoCompleted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              isAutoCompleted                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::SetIsAutoCompleted(const bool isAutoCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "SetIsAutoCompleted");

	Params::Generator_SetIsAutoCompleted Parms{};

	Parms.isAutoCompleted = isAutoCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.SetIsBlockedFromCharging
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isBlockedFromCharging                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::SetIsBlockedFromCharging(bool isBlockedFromCharging)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "SetIsBlockedFromCharging");

	Params::Generator_SetIsBlockedFromCharging Parms{};

	Parms.isBlockedFromCharging = isBlockedFromCharging;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.SetIsOvercharged
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              overcharged                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::SetIsOvercharged(const bool overcharged)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "SetIsOvercharged");

	Params::Generator_SetIsOvercharged Parms{};

	Parms.overcharged = overcharged;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.StopDischarge
// (Final, Native, Private)

void AGenerator::StopDischarge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "StopDischarge");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.TriggerSkillCheck
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       instigatingPlayer                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::TriggerSkillCheck(class ADBDPlayer* instigatingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "TriggerSkillCheck");

	Params::Generator_TriggerSkillCheck Parms{};

	Parms.instigatingPlayer = instigatingPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Generator.TriggerSkillCheckFailureLoudNoise
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       instigatingPlayer                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::TriggerSkillCheckFailureLoudNoise(class ADBDPlayer* instigatingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "TriggerSkillCheckFailureLoudNoise");

	Params::Generator_TriggerSkillCheckFailureLoudNoise Parms{};

	Parms.instigatingPlayer = instigatingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.VFXClampTopActivationSingleLight
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::VFXClampTopActivationSingleLight(float Distance, class FName ParameterName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "VFXClampTopActivationSingleLight");

	Params::Generator_VFXClampTopActivationSingleLight Parms{};

	Parms.Distance = Distance;
	Parms.ParameterName = ParameterName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Generator.ActivateTeleportGeneratorIndicator
// (Event, Public, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// bool                                    Activate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::ActivateTeleportGeneratorIndicator(bool Activate) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "ActivateTeleportGeneratorIndicator");

	Params::Generator_ActivateTeleportGeneratorIndicator Parms{};

	Parms.Activate = Activate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Generator.BroadcastGeneratorRepairedBySurvivor
// (Final, Native, Protected, BlueprintCallable, Const)
// Parameters:
// class ADBDPlayer*                       repairingSurvivor                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::BroadcastGeneratorRepairedBySurvivor(class ADBDPlayer* repairingSurvivor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "BroadcastGeneratorRepairedBySurvivor");

	Params::Generator_BroadcastGeneratorRepairedBySurvivor Parms{};

	Parms.repairingSurvivor = repairingSurvivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.CanSurvivorReactToBlockingEntity
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ASurvivor*                  Survivor                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGenerator::CanSurvivorReactToBlockingEntity(const class ASurvivor* Survivor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "CanSurvivorReactToBlockingEntity");

	Params::Generator_CanSurvivorReactToBlockingEntity Parms{};

	Parms.Survivor = Survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Generator.GetChargePercentComplete
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AGenerator::GetChargePercentComplete() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "GetChargePercentComplete");

	Params::Generator_GetChargePercentComplete Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Generator.GetGeneratorAudioComponent
// (Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UAkComponent*                     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAkComponent* AGenerator::GetGeneratorAudioComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "GetGeneratorAudioComponent");

	Params::Generator_GetGeneratorAudioComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Generator.GetGeneratorChargeComponent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UChargeableComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChargeableComponent* AGenerator::GetGeneratorChargeComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "GetGeneratorChargeComponent");

	Params::Generator_GetGeneratorChargeComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Generator.GetIsAutoCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGenerator::GetIsAutoCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "GetIsAutoCompleted");

	Params::Generator_GetIsAutoCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Generator.GetPlayerStartTime
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AGenerator::GetPlayerStartTime(const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "GetPlayerStartTime");

	Params::Generator_GetPlayerStartTime Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Generator.GetPlayerStartTimes
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FPlayerFloatTuple>  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FPlayerFloatTuple> AGenerator::GetPlayerStartTimes() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "GetPlayerStartTimes");

	Params::Generator_GetPlayerStartTimes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Generator.GetRepairPercentComplete
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AGenerator::GetRepairPercentComplete() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "GetRepairPercentComplete");

	Params::Generator_GetRepairPercentComplete Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Generator.GetSkeletalMesh
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* AGenerator::GetSkeletalMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "GetSkeletalMesh");

	Params::Generator_GetSkeletalMesh Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Generator.IsBeingDamagedByKiller
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGenerator::IsBeingDamagedByKiller() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "IsBeingDamagedByKiller");

	Params::Generator_IsBeingDamagedByKiller Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Generator.ShouldDoOverchargeSkillcheck
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGenerator::ShouldDoOverchargeSkillcheck() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "ShouldDoOverchargeSkillcheck");

	Params::Generator_ShouldDoOverchargeSkillcheck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SurvivorMovementComponent.OnCamperHealthStateChanged
// (Final, Native, Public)
// Parameters:
// EHealthState                            oldDamageState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHealthState                            currentDamageState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorMovementComponent::OnCamperHealthStateChanged(EHealthState oldDamageState, EHealthState currentDamageState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorMovementComponent", "OnCamperHealthStateChanged");

	Params::SurvivorMovementComponent_OnCamperHealthStateChanged Parms{};

	Parms.oldDamageState = oldDamageState;
	Parms.currentDamageState = currentDamageState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorMovementComponent.GetDefaultRotationRate
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator USurvivorMovementComponent::GetDefaultRotationRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorMovementComponent", "GetDefaultRotationRate");

	Params::SurvivorMovementComponent_GetDefaultRotationRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SurvivorMovementComponent.GetDropStaggerTimeLeft
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USurvivorMovementComponent::GetDropStaggerTimeLeft() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorMovementComponent", "GetDropStaggerTimeLeft");

	Params::SurvivorMovementComponent_GetDropStaggerTimeLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SurvivorMovementComponent.GetRotationRateWhileCrawling
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator USurvivorMovementComponent::GetRotationRateWhileCrawling() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorMovementComponent", "GetRotationRateWhileCrawling");

	Params::SurvivorMovementComponent_GetRotationRateWhileCrawling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActionButton.PlayBecameAvailableAnimation
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UActionButton::PlayBecameAvailableAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionButton", "PlayBecameAvailableAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.ActionButton.SetIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FSlateBrush&               SlateBrush                                             (Parm, NativeAccessSpecifierPublic)

void UActionButton::SetIcon(const struct FSlateBrush& SlateBrush)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionButton", "SetIcon");

	Params::ActionButton_SetIcon Parms{};

	Parms.SlateBrush = std::move(SlateBrush);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActionButton.SetPreviousState
// (Final, Native, Protected, BlueprintCallable)

void UActionButton::SetPreviousState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionButton", "SetPreviousState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActionButton.SetSlateBrush
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FSlateBrush&               InBrush                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UActionButton::SetSlateBrush(const struct FSlateBrush& InBrush)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionButton", "SetSlateBrush");

	Params::ActionButton_SetSlateBrush Parms{};

	Parms.InBrush = std::move(InBrush);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActionButton.SetState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EActionButtonState                      State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActionButton::SetState(EActionButtonState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionButton", "SetState");

	Params::ActionButton_SetState Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationScreen.OnAddPlayerClick
// (Final, Native, Protected)
// Parameters:
// int32                                   buttonId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNavigationScreen::OnAddPlayerClick(int32 buttonId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationScreen", "OnAddPlayerClick");

	Params::NavigationScreen_OnAddPlayerClick Parms{};

	Parms.buttonId = buttonId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationScreen.OnBankClick
// (Final, Native, Protected)
// Parameters:
// int32                                   currencyTypeInt                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNavigationScreen::OnBankClick(int32 currencyTypeInt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationScreen", "OnBankClick");

	Params::NavigationScreen_OnBankClick Parms{};

	Parms.currencyTypeInt = currencyTypeInt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationScreen.OnBloodpointIncentiveHovered
// (Final, Native, Protected)
// Parameters:
// int32                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Width                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNavigationScreen::OnBloodpointIncentiveHovered(int32 X, int32 Y, int32 Width, int32 Height)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationScreen", "OnBloodpointIncentiveHovered");

	Params::NavigationScreen_OnBloodpointIncentiveHovered Parms{};

	Parms.X = X;
	Parms.Y = Y;
	Parms.Width = Width;
	Parms.Height = Height;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationScreen.OnBloodpointIncentiveUnhovered
// (Final, Native, Protected)

void UNavigationScreen::OnBloodpointIncentiveUnhovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationScreen", "OnBloodpointIncentiveUnhovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationScreen.OnCancelButtonClick
// (Final, Native, Protected)

void UNavigationScreen::OnCancelButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationScreen", "OnCancelButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationScreen.OnCharacterSwapArrowClick
// (Final, Native, Protected)
// Parameters:
// bool                                    isNext                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNavigationScreen::OnCharacterSwapArrowClick(bool isNext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationScreen", "OnCharacterSwapArrowClick");

	Params::NavigationScreen_OnCharacterSwapArrowClick Parms{};

	Parms.isNext = isNext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationScreen.OnFadeOutEnded
// (Final, Native, Protected)

void UNavigationScreen::OnFadeOutEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationScreen", "OnFadeOutEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationScreen.OnInviteFriendClick
// (Final, Native, Protected)

void UNavigationScreen::OnInviteFriendClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationScreen", "OnInviteFriendClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationScreen.OnMatchMakingBanTimeout
// (Final, Native, Protected)

void UNavigationScreen::OnMatchMakingBanTimeout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationScreen", "OnMatchMakingBanTimeout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationScreen.OnMatchManagementButtonClick
// (Final, Native, Protected)

void UNavigationScreen::OnMatchManagementButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationScreen", "OnMatchManagementButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationScreen.OnPlayerInfoClick
// (Final, Native, Protected)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNavigationScreen::OnPlayerInfoClick(int32 PlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationScreen", "OnPlayerInfoClick");

	Params::NavigationScreen_OnPlayerInfoClick Parms{};

	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationScreen.OnPlayerOptionSelected
// (Final, Native, Protected)
// Parameters:
// const class FString&                    KrakenId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    PlayerId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Option                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNavigationScreen::OnPlayerOptionSelected(const class FString& KrakenId, const class FString& PlayerId, uint8 Option)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationScreen", "OnPlayerOptionSelected");

	Params::NavigationScreen_OnPlayerOptionSelected Parms{};

	Parms.KrakenId = std::move(KrakenId);
	Parms.PlayerId = std::move(PlayerId);
	Parms.Option = Option;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationScreen.OnReadyButtonClick
// (Final, Native, Protected)

void UNavigationScreen::OnReadyButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationScreen", "OnReadyButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationScreen.OnSettingsClick
// (Final, Native, Protected)

void UNavigationScreen::OnSettingsClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationScreen", "OnSettingsClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationScreen.ShowcaseMapButtonHovered
// (Final, Native, Protected)
// Parameters:
// int32                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Width                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNavigationScreen::ShowcaseMapButtonHovered(int32 X, int32 Y, int32 Width, int32 Height)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationScreen", "ShowcaseMapButtonHovered");

	Params::NavigationScreen_ShowcaseMapButtonHovered Parms{};

	Parms.X = X;
	Parms.Y = Y;
	Parms.Width = Width;
	Parms.Height = Height;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationScreen.ShowcaseMapButtonUnhovered
// (Final, Native, Protected)

void UNavigationScreen::ShowcaseMapButtonUnhovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationScreen", "ShowcaseMapButtonUnhovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorActivityIndicatorComponent.Authority_OnCamperEscape
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              GameplayTag                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void USurvivorActivityIndicatorComponent::Authority_OnCamperEscape(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorActivityIndicatorComponent", "Authority_OnCamperEscape");

	Params::SurvivorActivityIndicatorComponent_Authority_OnCamperEscape Parms{};

	Parms.GameplayTag = std::move(GameplayTag);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorActivityIndicatorComponent.HandleStartActivityIfStillInEffect
// (Final, Native, Private)
// Parameters:
// const struct FSurvivorActivity&         activityViewInfo                                       (ConstParm, Parm, NativeAccessSpecifierPublic)

void USurvivorActivityIndicatorComponent::HandleStartActivityIfStillInEffect(const struct FSurvivorActivity& activityViewInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorActivityIndicatorComponent", "HandleStartActivityIfStillInEffect");

	Params::SurvivorActivityIndicatorComponent_HandleStartActivityIfStillInEffect Parms{};

	Parms.activityViewInfo = std::move(activityViewInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorActivityIndicatorComponent.Multicast_OnCamperEscape
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void USurvivorActivityIndicatorComponent::Multicast_OnCamperEscape()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorActivityIndicatorComponent", "Multicast_OnCamperEscape");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorActivityIndicatorComponent.OnChargeableProgressChanged
// (Final, Native, Private)
// Parameters:
// class UChargeableComponent*             ChargeableComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TotalPercentComplete                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorActivityIndicatorComponent::OnChargeableProgressChanged(class UChargeableComponent* ChargeableComponent, float TotalPercentComplete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorActivityIndicatorComponent", "OnChargeableProgressChanged");

	Params::SurvivorActivityIndicatorComponent_OnChargeableProgressChanged Parms{};

	Parms.ChargeableComponent = ChargeableComponent;
	Parms.TotalPercentComplete = TotalPercentComplete;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorActivityIndicatorComponent.OnDamageStateChanged
// (Final, Native, Private)
// Parameters:
// EHealthState                            oldDamageState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHealthState                            currentDamageState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorActivityIndicatorComponent::OnDamageStateChanged(EHealthState oldDamageState, EHealthState currentDamageState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorActivityIndicatorComponent", "OnDamageStateChanged");

	Params::SurvivorActivityIndicatorComponent_OnDamageStateChanged Parms{};

	Parms.oldDamageState = oldDamageState;
	Parms.currentDamageState = currentDamageState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorActivityIndicatorComponent.OnPlayerDropped
// (Final, Native, Private)

void USurvivorActivityIndicatorComponent::OnPlayerDropped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorActivityIndicatorComponent", "OnPlayerDropped");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorActivityIndicatorComponent.OnPlayerPickedUp
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       picker                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorActivityIndicatorComponent::OnPlayerPickedUp(class ADBDPlayer* picker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorActivityIndicatorComponent", "OnPlayerPickedUp");

	Params::SurvivorActivityIndicatorComponent_OnPlayerPickedUp Parms{};

	Parms.picker = picker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AISlasherChaseAndAttackBehaviourData.Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASurvivor*                        TargetSurvivor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   attackRangeDistance                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   locationDistance                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAISlasherChaseAndAttackBehaviourData::Init(class ASurvivor* TargetSurvivor, float attackRangeDistance, float locationDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AISlasherChaseAndAttackBehaviourData", "Init");

	Params::AISlasherChaseAndAttackBehaviourData_Init Parms{};

	Parms.TargetSurvivor = TargetSurvivor;
	Parms.attackRangeDistance = attackRangeDistance;
	Parms.locationDistance = locationDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LevelParadise.OnInterpolationDone
// (Final, Native, Private)

void ALevelParadise::OnInterpolationDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelParadise", "OnInterpolationDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LevelParadise.ParadiseEntered
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FParadiseData&             PlayerData                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ALevelParadise::ParadiseEntered(const struct FParadiseData& PlayerData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelParadise", "ParadiseEntered");

	Params::LevelParadise_ParadiseEntered Parms{};

	Parms.PlayerData = std::move(PlayerData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BaseSky.CopyComponentsSettingsFromSource
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             moonMesh                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDirectionalLightComponent*       shadowLight                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDirectionalLightComponent*       godRayLight                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkyLightComponent*               SkyLight                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UExponentialHeightFogComponent*   HeightFog                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPostProcessComponent*            postProcess                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           sourceBaseSkyClass                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSky::CopyComponentsSettingsFromSource(class UStaticMeshComponent* moonMesh, class UDirectionalLightComponent* shadowLight, class UDirectionalLightComponent* godRayLight, class USkyLightComponent* SkyLight, class UExponentialHeightFogComponent* HeightFog, class UPostProcessComponent* postProcess, class UClass* sourceBaseSkyClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSky", "CopyComponentsSettingsFromSource");

	Params::BaseSky_CopyComponentsSettingsFromSource Parms{};

	Parms.moonMesh = moonMesh;
	Parms.shadowLight = shadowLight;
	Parms.godRayLight = godRayLight;
	Parms.SkyLight = SkyLight;
	Parms.HeightFog = HeightFog;
	Parms.postProcess = postProcess;
	Parms.sourceBaseSkyClass = sourceBaseSkyClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BaseSky.GetPostprocessComponent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPostProcessComponent*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPostProcessComponent* ABaseSky::GetPostprocessComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSky", "GetPostprocessComponent");

	Params::BaseSky_GetPostprocessComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.BaseSky.GetVistasAndEnvironmentElements
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* ABaseSky::GetVistasAndEnvironmentElements()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSky", "GetVistasAndEnvironmentElements");

	Params::BaseSky_GetVistasAndEnvironmentElements Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.BaseSky.OnAlphaChanged
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   newAlpha                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSky::OnAlphaChanged(float newAlpha, class AActor* Other)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSky", "OnAlphaChanged");

	Params::BaseSky_OnAlphaChanged Parms{};

	Parms.newAlpha = newAlpha;
	Parms.Other = Other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BaseSky.OnFadeBegin
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSky::OnFadeBegin(class AActor* Other)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSky", "OnFadeBegin");

	Params::BaseSky_OnFadeBegin Parms{};

	Parms.Other = Other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BaseSky.OnFadeEnd
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSky::OnFadeEnd(class AActor* Other)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSky", "OnFadeEnd");

	Params::BaseSky_OnFadeEnd Parms{};

	Parms.Other = Other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BaseSky.SetCullDistance
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   NewCullDistance                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSky::SetCullDistance(float NewCullDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSky", "SetCullDistance");

	Params::BaseSky_SetCullDistance Parms{};

	Parms.NewCullDistance = NewCullDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BaseSky.SetProbesTint
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FLinearColor&              InColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   inSaturation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSky::SetProbesTint(const struct FLinearColor& InColor, float inSaturation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSky", "SetProbesTint");

	Params::BaseSky_SetProbesTint Parms{};

	Parms.InColor = std::move(InColor);
	Parms.inSaturation = inSaturation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BaseSky.ToggleLightingChange
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    toggleOn                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ThemeName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSky::ToggleLightingChange(bool toggleOn, class FName ThemeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSky", "ToggleLightingChange");

	Params::BaseSky_ToggleLightingChange Parms{};

	Parms.toggleOn = toggleOn;
	Parms.ThemeName = ThemeName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Tile.InitOnSpawned
// (Event, Protected, BlueprintEvent)

void ATile::InitOnSpawned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Tile", "InitOnSpawned");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Tile.OnAllTileSpawned
// (Event, Public, BlueprintEvent)

void ATile::OnAllTileSpawned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Tile", "OnAllTileSpawned");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Tile.OnRep_Initialized
// (Final, Native, Protected)
// Parameters:
// bool                                    OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATile::OnRep_Initialized(bool OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Tile", "OnRep_Initialized");

	Params::Tile_OnRep_Initialized Parms{};

	Parms.OldValue = OldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Tile.OnSetSpawnObject
// (Event, Public, BlueprintEvent)
// Parameters:
// class UTileSpawnPoint*                  TileSpawnPoint                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           spawnedObject                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATile::OnSetSpawnObject(class UTileSpawnPoint* TileSpawnPoint, class AActor* spawnedObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Tile", "OnSetSpawnObject");

	Params::Tile_OnSetSpawnObject Parms{};

	Parms.TileSpawnPoint = TileSpawnPoint;
	Parms.spawnedObject = spawnedObject;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.ActorClipperComponent.OnCameraChanged
// (Final, Native, Private)
// Parameters:
// EDBDCameraSocketID                      socketId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorClipperComponent::OnCameraChanged(EDBDCameraSocketID socketId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorClipperComponent", "OnCameraChanged");

	Params::ActorClipperComponent_OnCameraChanged Parms{};

	Parms.socketId = socketId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActorClipperComponent.OnOwnerLocallyObservedChanged
// (Final, Native, Private)
// Parameters:
// bool                                    locallyObserved                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorClipperComponent::OnOwnerLocallyObservedChanged(bool locallyObserved)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorClipperComponent", "OnOwnerLocallyObservedChanged");

	Params::ActorClipperComponent_OnOwnerLocallyObservedChanged Parms{};

	Parms.locallyObserved = locallyObserved;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActorClipperComponent.SetPrimitiveCollection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UPrimitiveCollection*       clippables                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorClipperComponent::SetPrimitiveCollection(const class UPrimitiveCollection* clippables)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorClipperComponent", "SetPrimitiveCollection");

	Params::ActorClipperComponent_SetPrimitiveCollection Parms{};

	Parms.clippables = clippables;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActorComponentExt.GetOwningCharacter
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UActorComponent*            ActorComponent                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    recursiveSearch                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacter*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacter* UActorComponentExt::GetOwningCharacter(const class UActorComponent* ActorComponent, bool recursiveSearch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorComponentExt", "GetOwningCharacter");

	Params::ActorComponentExt_GetOwningCharacter Parms{};

	Parms.ActorComponent = ActorComponent;
	Parms.recursiveSearch = recursiveSearch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorComponentExt.GetOwningCharacterChecked
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UActorComponent*            ActorComponent                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    recursiveSearch                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacter*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacter* UActorComponentExt::GetOwningCharacterChecked(const class UActorComponent* ActorComponent, bool recursiveSearch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorComponentExt", "GetOwningCharacterChecked");

	Params::ActorComponentExt_GetOwningCharacterChecked Parms{};

	Parms.ActorComponent = ActorComponent;
	Parms.recursiveSearch = recursiveSearch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorComponentExt.GetOwningKiller
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UActorComponent*            ActorComponent                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    recursiveSearch                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AKiller*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AKiller* UActorComponentExt::GetOwningKiller(const class UActorComponent* ActorComponent, bool recursiveSearch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorComponentExt", "GetOwningKiller");

	Params::ActorComponentExt_GetOwningKiller Parms{};

	Parms.ActorComponent = ActorComponent;
	Parms.recursiveSearch = recursiveSearch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorComponentExt.GetOwningPawn
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UActorComponent*            ActorComponent                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    recursiveSearch                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* UActorComponentExt::GetOwningPawn(const class UActorComponent* ActorComponent, bool recursiveSearch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorComponentExt", "GetOwningPawn");

	Params::ActorComponentExt_GetOwningPawn Parms{};

	Parms.ActorComponent = ActorComponent;
	Parms.recursiveSearch = recursiveSearch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorComponentExt.GetOwningPawnChecked
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UActorComponent*            ActorComponent                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    recursiveSearch                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* UActorComponentExt::GetOwningPawnChecked(const class UActorComponent* ActorComponent, bool recursiveSearch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorComponentExt", "GetOwningPawnChecked");

	Params::ActorComponentExt_GetOwningPawnChecked Parms{};

	Parms.ActorComponent = ActorComponent;
	Parms.recursiveSearch = recursiveSearch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorComponentExt.GetOwningPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UActorComponent*            ActorComponent                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    recursiveSearch                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UActorComponentExt::GetOwningPlayer(const class UActorComponent* ActorComponent, bool recursiveSearch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorComponentExt", "GetOwningPlayer");

	Params::ActorComponentExt_GetOwningPlayer Parms{};

	Parms.ActorComponent = ActorComponent;
	Parms.recursiveSearch = recursiveSearch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorComponentExt.GetOwningPlayerChecked
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UActorComponent*            ActorComponent                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    recursiveSearch                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UActorComponentExt::GetOwningPlayerChecked(const class UActorComponent* ActorComponent, bool recursiveSearch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorComponentExt", "GetOwningPlayerChecked");

	Params::ActorComponentExt_GetOwningPlayerChecked Parms{};

	Parms.ActorComponent = ActorComponent;
	Parms.recursiveSearch = recursiveSearch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorComponentExt.GetOwningPlayerInHierarchy
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UActorComponent*            ActorComponent                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UActorComponentExt::GetOwningPlayerInHierarchy(const class UActorComponent* ActorComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorComponentExt", "GetOwningPlayerInHierarchy");

	Params::ActorComponentExt_GetOwningPlayerInHierarchy Parms{};

	Parms.ActorComponent = ActorComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorComponentExt.GetOwningSurvivor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UActorComponent*            ActorComponent                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    recursiveSearch                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASurvivor*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASurvivor* UActorComponentExt::GetOwningSurvivor(const class UActorComponent* ActorComponent, bool recursiveSearch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorComponentExt", "GetOwningSurvivor");

	Params::ActorComponentExt_GetOwningSurvivor Parms{};

	Parms.ActorComponent = ActorComponent;
	Parms.recursiveSearch = recursiveSearch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorComponentExt.GetOwningSurvivorChecked
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UActorComponent*            ActorComponent                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    recursiveSearch                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASurvivor*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASurvivor* UActorComponentExt::GetOwningSurvivorChecked(const class UActorComponent* ActorComponent, bool recursiveSearch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorComponentExt", "GetOwningSurvivorChecked");

	Params::ActorComponentExt_GetOwningSurvivorChecked Parms{};

	Parms.ActorComponent = ActorComponent;
	Parms.recursiveSearch = recursiveSearch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorComponentExt.GetValidatedOwner
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UActorComponent*            ActorComponent                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UActorComponentExt::GetValidatedOwner(const class UActorComponent* ActorComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorComponentExt", "GetValidatedOwner");

	Params::ActorComponentExt_GetValidatedOwner Parms{};

	Parms.ActorComponent = ActorComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorComponentExt.HasAuthority
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UActorComponent*            ActorComponent                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActorComponentExt::HasAuthority(const class UActorComponent* ActorComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorComponentExt", "HasAuthority");

	Params::ActorComponentExt_HasAuthority Parms{};

	Parms.ActorComponent = ActorComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorComponentExt.IsLocallyControlled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UActorComponent*            ActorComponent                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    recursiveSearch                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActorComponentExt::IsLocallyControlled(const class UActorComponent* ActorComponent, bool recursiveSearch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorComponentExt", "IsLocallyControlled");

	Params::ActorComponentExt_IsLocallyControlled Parms{};

	Parms.ActorComponent = ActorComponent;
	Parms.recursiveSearch = recursiveSearch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorComponentExt.IsLocallyObserved
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UActorComponent*            ActorComponent                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    recursiveSearch                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActorComponentExt::IsLocallyObserved(const class UActorComponent* ActorComponent, bool recursiveSearch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorComponentExt", "IsLocallyObserved");

	Params::ActorComponentExt_IsLocallyObserved Parms{};

	Parms.ActorComponent = ActorComponent;
	Parms.recursiveSearch = recursiveSearch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SurvivorPlagueEffect.Authority_AddSickness
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   sicknessToAdd                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorPlagueEffect::Authority_AddSickness(float sicknessToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "Authority_AddSickness");

	Params::SurvivorPlagueEffect_Authority_AddSickness Parms{};

	Parms.sicknessToAdd = sicknessToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorPlagueEffect.Authority_InfectInteractable
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AInteractable*                    Interactable                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorPlagueEffect::Authority_InfectInteractable(class AInteractable* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "Authority_InfectInteractable");

	Params::SurvivorPlagueEffect_Authority_InfectInteractable Parms{};

	Parms.Interactable = Interactable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.SurvivorPlagueEffect.Authority_OnHitBySuperVomitProjectile
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void USurvivorPlagueEffect::Authority_OnHitBySuperVomitProjectile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "Authority_OnHitBySuperVomitProjectile");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorPlagueEffect.Authority_OnHitByVomitProjectile
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   sicknessToAdd                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorPlagueEffect::Authority_OnHitByVomitProjectile(float sicknessToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "Authority_OnHitByVomitProjectile");

	Params::SurvivorPlagueEffect_Authority_OnHitByVomitProjectile Parms{};

	Parms.sicknessToAdd = sicknessToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorPlagueEffect.Authority_OnHitByVomitProjectileAesthetic
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void USurvivorPlagueEffect::Authority_OnHitByVomitProjectileAesthetic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "Authority_OnHitByVomitProjectileAesthetic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorPlagueEffect.Authority_ResetSickness
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   newSickness                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorPlagueEffect::Authority_ResetSickness(float newSickness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "Authority_ResetSickness");

	Params::SurvivorPlagueEffect_Authority_ResetSickness Parms{};

	Parms.newSickness = newSickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorPlagueEffect.Multicast_AddOnScreenDebugMessage
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, HasDefaults)
// Parameters:
// uint64                                  Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FColor&                    DisplayColor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    debugMessage                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorPlagueEffect::Multicast_AddOnScreenDebugMessage(uint64 Key, float Duration, const struct FColor& DisplayColor, const class FString& debugMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "Multicast_AddOnScreenDebugMessage");

	Params::SurvivorPlagueEffect_Multicast_AddOnScreenDebugMessage Parms{};

	Parms.Key = Key;
	Parms.Duration = Duration;
	Parms.DisplayColor = std::move(DisplayColor);
	Parms.debugMessage = std::move(debugMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorPlagueEffect.Multicast_OnMaxSicknessReached
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void USurvivorPlagueEffect::Multicast_OnMaxSicknessReached()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "Multicast_OnMaxSicknessReached");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorPlagueEffect.Multicast_OnSicknessChanged
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// float                                   newSickness                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorPlagueEffect::Multicast_OnSicknessChanged(float newSickness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "Multicast_OnSicknessChanged");

	Params::SurvivorPlagueEffect_Multicast_OnSicknessChanged Parms{};

	Parms.newSickness = newSickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorPlagueEffect.Multicast_OnSicknessCured
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void USurvivorPlagueEffect::Multicast_OnSicknessCured()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "Multicast_OnSicknessCured");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorPlagueEffect.Multicast_OnSurvivorBecomesInfected
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void USurvivorPlagueEffect::Multicast_OnSurvivorBecomesInfected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "Multicast_OnSurvivorBecomesInfected");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorPlagueEffect.Multicast_OnSurvivorVomit
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void USurvivorPlagueEffect::Multicast_OnSurvivorVomit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "Multicast_OnSurvivorVomit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorPlagueEffect.OnHitByVomit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isSuperVomit                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorPlagueEffect::OnHitByVomit(bool isSuperVomit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "OnHitByVomit");

	Params::SurvivorPlagueEffect_OnHitByVomit Parms{};

	Parms.isSuperVomit = isSuperVomit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorPlagueEffect.OnMaxSicknessReached_Aesthetic
// (Event, Protected, BlueprintEvent)

void USurvivorPlagueEffect::OnMaxSicknessReached_Aesthetic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "OnMaxSicknessReached_Aesthetic");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.SurvivorPlagueEffect.OnRep_SicknessAmount
// (Final, Native, Public)

void USurvivorPlagueEffect::OnRep_SicknessAmount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "OnRep_SicknessAmount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorPlagueEffect.OnSicknessChanged_Aesthetic
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   newSickness                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorPlagueEffect::OnSicknessChanged_Aesthetic(float newSickness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "OnSicknessChanged_Aesthetic");

	Params::SurvivorPlagueEffect_OnSicknessChanged_Aesthetic Parms{};

	Parms.newSickness = newSickness;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.SurvivorPlagueEffect.OnSicknessCured_Aesthetic
// (Event, Protected, BlueprintEvent)

void USurvivorPlagueEffect::OnSicknessCured_Aesthetic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "OnSicknessCured_Aesthetic");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.SurvivorPlagueEffect.OnSurvivorBecomesInfected_Aesthetic
// (Event, Protected, BlueprintEvent)

void USurvivorPlagueEffect::OnSurvivorBecomesInfected_Aesthetic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "OnSurvivorBecomesInfected_Aesthetic");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.SurvivorPlagueEffect.OnSurvivorDisguisedOrUndisguised
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    isDisguised                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorPlagueEffect::OnSurvivorDisguisedOrUndisguised(bool isDisguised)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "OnSurvivorDisguisedOrUndisguised");

	Params::SurvivorPlagueEffect_OnSurvivorDisguisedOrUndisguised Parms{};

	Parms.isDisguised = isDisguised;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.SurvivorPlagueEffect.OnSurvivorVomit_Aesthetic
// (Event, Protected, BlueprintEvent)

void USurvivorPlagueEffect::OnSurvivorVomit_Aesthetic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "OnSurvivorVomit_Aesthetic");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.SurvivorPlagueEffect.RefreshSicknessGainValues
// (Final, Native, Public, BlueprintCallable)

void USurvivorPlagueEffect::RefreshSicknessGainValues()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "RefreshSicknessGainValues");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorPlagueEffect.GetMaxSicknessLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 USurvivorPlagueEffect::GetMaxSicknessLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "GetMaxSicknessLevel");

	Params::SurvivorPlagueEffect_GetMaxSicknessLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SurvivorPlagueEffect.GetSicknessAmount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USurvivorPlagueEffect::GetSicknessAmount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "GetSicknessAmount");

	Params::SurvivorPlagueEffect_GetSicknessAmount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SurvivorPlagueEffect.GetSicknessLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 USurvivorPlagueEffect::GetSicknessLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "GetSicknessLevel");

	Params::SurvivorPlagueEffect_GetSicknessLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SurvivorPlagueEffect.GetSicknessPercentage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USurvivorPlagueEffect::GetSicknessPercentage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "GetSicknessPercentage");

	Params::SurvivorPlagueEffect_GetSicknessPercentage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SurvivorPlagueEffect.GetSicknessThresholds
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<float>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<float> USurvivorPlagueEffect::GetSicknessThresholds() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "GetSicknessThresholds");

	Params::SurvivorPlagueEffect_GetSicknessThresholds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SurvivorPlagueEffect.HasMaxLevelSickness
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USurvivorPlagueEffect::HasMaxLevelSickness() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "HasMaxLevelSickness");

	Params::SurvivorPlagueEffect_HasMaxLevelSickness Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SurvivorPlagueEffect.IsDebugModeActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USurvivorPlagueEffect::IsDebugModeActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "IsDebugModeActive");

	Params::SurvivorPlagueEffect_IsDebugModeActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SurvivorPlagueEffect.IsInfected
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USurvivorPlagueEffect::IsInfected() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "IsInfected");

	Params::SurvivorPlagueEffect_IsInfected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.BehaviourPenalty_DisableCollisions.TimerDone
// (Final, Native, Protected, Const)

void UBehaviourPenalty_DisableCollisions::TimerDone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BehaviourPenalty_DisableCollisions", "TimerDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActorDetectorComponent.OnOverlapEnter
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UActorDetectorComponent::OnOverlapEnter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorDetectorComponent", "OnOverlapEnter");

	Params::ActorDetectorComponent_OnOverlapEnter Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActorDetectorComponent.SetDetectionPrimitive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Primitive                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorDetectorComponent::SetDetectionPrimitive(class UPrimitiveComponent* Primitive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorDetectorComponent", "SetDetectionPrimitive");

	Params::ActorDetectorComponent_SetDetectionPrimitive Parms{};

	Parms.Primitive = Primitive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BaseBehaviourDetectionComponent.StartMonitoring
// (Native, Protected)

void UBaseBehaviourDetectionComponent::StartMonitoring()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseBehaviourDetectionComponent", "StartMonitoring");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BaseBehaviourDetectionComponent.StopMonitoring
// (Native, Protected)

void UBaseBehaviourDetectionComponent::StopMonitoring()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseBehaviourDetectionComponent", "StopMonitoring");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SupplyCrateAnimInstance.OnBeingPriedOpenStarted
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USupplyCrateAnimInstance::OnBeingPriedOpenStarted(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SupplyCrateAnimInstance", "OnBeingPriedOpenStarted");

	Params::SupplyCrateAnimInstance_OnBeingPriedOpenStarted Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SupplyCrateAnimInstance.OnBeingPriedOpenStopped
// (Final, Native, Private)

void USupplyCrateAnimInstance::OnBeingPriedOpenStopped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SupplyCrateAnimInstance", "OnBeingPriedOpenStopped");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGScoreAlertWidget.UpdateWidget
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// EDBDScoreCategory                       ScoreType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Title                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ScoreValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      defaultScoreText                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUMGScoreAlertWidget::UpdateWidget(EDBDScoreCategory ScoreType, const class FString& Title, int32 ScoreValue, float Progress, const class FText& defaultScoreText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGScoreAlertWidget", "UpdateWidget");

	Params::UMGScoreAlertWidget_UpdateWidget Parms{};

	Parms.ScoreType = ScoreType;
	Parms.Title = std::move(Title);
	Parms.ScoreValue = ScoreValue;
	Parms.Progress = Progress;
	Parms.defaultScoreText = std::move(defaultScoreText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.BlessedVignetteController.OnActivateBlessedVignette
// (Event, Public, BlueprintEvent)

void UBlessedVignetteController::OnActivateBlessedVignette()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlessedVignetteController", "OnActivateBlessedVignette");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.BlessedVignetteController.OnDeactivateBlessedVignette
// (Event, Public, BlueprintEvent)

void UBlessedVignetteController::OnDeactivateBlessedVignette()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlessedVignetteController", "OnDeactivateBlessedVignette");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.ActorKnowledgeCollection.Authority_Add
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActorKnowledgeCollection::Authority_Add(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorKnowledgeCollection", "Authority_Add");

	Params::ActorKnowledgeCollection_Authority_Add Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorKnowledgeCollection.Authority_Append
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class AActor*>&            Actors                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UActorKnowledgeCollection::Authority_Append(const TArray<class AActor*>& Actors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorKnowledgeCollection", "Authority_Append");

	Params::ActorKnowledgeCollection_Authority_Append Parms{};

	Parms.Actors = std::move(Actors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActorKnowledgeCollection.Authority_Empty
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UActorKnowledgeCollection::Authority_Empty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorKnowledgeCollection", "Authority_Empty");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActorKnowledgeCollection.Authority_Remove
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorKnowledgeCollection::Authority_Remove(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorKnowledgeCollection", "Authority_Remove");

	Params::ActorKnowledgeCollection_Authority_Remove Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActorKnowledgeCollection.Authority_SetAvailable
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorKnowledgeCollection::Authority_SetAvailable(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorKnowledgeCollection", "Authority_SetAvailable");

	Params::ActorKnowledgeCollection_Authority_SetAvailable Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActorKnowledgeCollection.Authority_SetPossessor
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ACharacter*                       possessor                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorKnowledgeCollection::Authority_SetPossessor(class ACharacter* possessor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorKnowledgeCollection", "Authority_SetPossessor");

	Params::ActorKnowledgeCollection_Authority_SetPossessor Parms{};

	Parms.possessor = possessor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActorKnowledgeCollection.Authority_SetSharingType
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// EKnowledgeSharingType                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorKnowledgeCollection::Authority_SetSharingType(EKnowledgeSharingType Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorKnowledgeCollection", "Authority_SetSharingType");

	Params::ActorKnowledgeCollection_Authority_SetSharingType Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActorKnowledgeCollection.Local_SetAvailable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorKnowledgeCollection::Local_SetAvailable(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorKnowledgeCollection", "Local_SetAvailable");

	Params::ActorKnowledgeCollection_Local_SetAvailable Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActorKnowledgeCollection.OnRep_Actors
// (Final, Native, Private)

void UActorKnowledgeCollection::OnRep_Actors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorKnowledgeCollection", "OnRep_Actors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActorKnowledgeCollection.Contains
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActorKnowledgeCollection::Contains(class AActor* Actor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorKnowledgeCollection", "Contains");

	Params::ActorKnowledgeCollection_Contains Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorKnowledgeCollection.IsAvailable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ACharacter*                 Character                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActorKnowledgeCollection::IsAvailable(const class ACharacter* Character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorKnowledgeCollection", "IsAvailable");

	Params::ActorKnowledgeCollection_IsAvailable Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorSpawner.Authority_SpawnActorAsyncEvent
// (Final, Native, Public, BlueprintCallable)

void UActorSpawner::Authority_SpawnActorAsyncEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorSpawner", "Authority_SpawnActorAsyncEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActorSpawner.AuthoritySelect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Selected                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorSpawner::AuthoritySelect(bool Selected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorSpawner", "AuthoritySelect");

	Params::ActorSpawner_AuthoritySelect Parms{};

	Parms.Selected = Selected;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActorSpawner.EditorForceSpawnVisualization
// (Final, Native, Public, BlueprintCallable)

void UActorSpawner::EditorForceSpawnVisualization()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorSpawner", "EditorForceSpawnVisualization");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActorSpawner.AuthorityGetSpawnedActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UActorSpawner::AuthorityGetSpawnedActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorSpawner", "AuthorityGetSpawnedActor");

	Params::ActorSpawner_AuthorityGetSpawnedActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorSpawner.IsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActorSpawner::IsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorSpawner", "IsEnabled");

	Params::ActorSpawner_IsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorSpawner.UseActivatedElement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActorSpawner::UseActivatedElement() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorSpawner", "UseActivatedElement");

	Params::ActorSpawner_UseActivatedElement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.BlockableComponent.Authority_AddBlock
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    Source                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSet<class ADBDPlayer*>&          affectedPlayers                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBlockableComponent::Authority_AddBlock(const class UObject* Source, const TSet<class ADBDPlayer*>& affectedPlayers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlockableComponent", "Authority_AddBlock");

	Params::BlockableComponent_Authority_AddBlock Parms{};

	Parms.Source = Source;
	Parms.affectedPlayers = std::move(affectedPlayers);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BlockableComponent.Authority_AddTimedBlock
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    Source                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Duration                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSet<class ADBDPlayer*>&          affectedPlayers                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBlockableComponent::Authority_AddTimedBlock(const class UObject* Source, const float Duration, const TSet<class ADBDPlayer*>& affectedPlayers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlockableComponent", "Authority_AddTimedBlock");

	Params::BlockableComponent_Authority_AddTimedBlock Parms{};

	Parms.Source = Source;
	Parms.Duration = Duration;
	Parms.affectedPlayers = std::move(affectedPlayers);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BlockableComponent.Authority_RemoveBlock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    Source                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlockableComponent::Authority_RemoveBlock(const class UObject* Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlockableComponent", "Authority_RemoveBlock");

	Params::BlockableComponent_Authority_RemoveBlock Parms{};

	Parms.Source = Source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BlockableComponent.OnRep_ReplicatedDatum
// (Final, Native, Private, Const)

void UBlockableComponent::OnRep_ReplicatedDatum() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlockableComponent", "OnRep_ReplicatedDatum");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TimerGateDecrease.Update
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATimerGateDecrease::Update(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimerGateDecrease", "Update");

	Params::TimerGateDecrease_Update Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AICharacterBehaviourInteractWithActorData.Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECharacterMovementTypes                 characterMovementType_0                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    usePathfinding_0                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAICharacterBehaviourInteractWithActorData::Init(class AActor* Actor, ECharacterMovementTypes characterMovementType_0, bool usePathfinding_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterBehaviourInteractWithActorData", "Init");

	Params::AICharacterBehaviourInteractWithActorData_Init Parms{};

	Parms.Actor = Actor;
	Parms.characterMovementType_0 = characterMovementType_0;
	Parms.usePathfinding_0 = usePathfinding_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AICharacterBehaviourInteractWithActorData.WatchGameEventType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAICharacterBehaviourInteractWithActorData::WatchGameEventType(const struct FGameplayTag& gameEventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterBehaviourInteractWithActorData", "WatchGameEventType");

	Params::AICharacterBehaviourInteractWithActorData_WatchGameEventType Parms{};

	Parms.gameEventType = std::move(gameEventType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AICharacterBehaviourInteractWithActorData.WatchGameEventTypes
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<struct FGameplayTag>&      gameEventTypes                                         (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAICharacterBehaviourInteractWithActorData::WatchGameEventTypes(const TArray<struct FGameplayTag>& gameEventTypes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterBehaviourInteractWithActorData", "WatchGameEventTypes");

	Params::AICharacterBehaviourInteractWithActorData_WatchGameEventTypes Parms{};

	Parms.gameEventTypes = std::move(gameEventTypes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PerspectiveEffectActivator.IsEffectActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             effectName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPerspectiveEffectActivator::IsEffectActive(class FName effectName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerspectiveEffectActivator", "IsEffectActive");

	Params::PerspectiveEffectActivator_IsEffectActive Parms{};

	Parms.effectName = effectName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerspectiveEffectActivator.RegisterEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             effectName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPerspectiveEffectData&    effectData                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UPerspectiveEffectActivator::RegisterEffect(class FName effectName, const struct FPerspectiveEffectData& effectData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerspectiveEffectActivator", "RegisterEffect");

	Params::PerspectiveEffectActivator_RegisterEffect Parms{};

	Parms.effectName = effectName;
	Parms.effectData = std::move(effectData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PerspectiveEffectActivator.SetWantsActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             effectName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    WantsActive                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerspectiveEffectActivator::SetWantsActive(class FName effectName, bool WantsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerspectiveEffectActivator", "SetWantsActive");

	Params::PerspectiveEffectActivator_SetWantsActive Parms{};

	Parms.effectName = effectName;
	Parms.WantsActive = WantsActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PerspectiveEffectActivator.UnregisterEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             effectName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerspectiveEffectActivator::UnregisterEffect(class FName effectName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerspectiveEffectActivator", "UnregisterEffect");

	Params::PerspectiveEffectActivator_UnregisterEffect Parms{};

	Parms.effectName = effectName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterEvasionBehaviourData.Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Hunter                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            escapePoints                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   minEscapeDist                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterEvasionBehaviourData::Init(class AActor* Hunter, const TArray<class AActor*>& escapePoints, float minEscapeDist)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterEvasionBehaviourData", "Init");

	Params::CharacterEvasionBehaviourData_Init Parms{};

	Parms.Hunter = Hunter;
	Parms.escapePoints = std::move(escapePoints);
	Parms.minEscapeDist = minEscapeDist;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AICharacterEvasionBehaviour.EscapeDestinationReached
// (Final, Native, Private)
// Parameters:
// const struct FAIRequestID&              RequestID                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// EPathFollowingResult                    Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAICharacterEvasionBehaviour::EscapeDestinationReached(const struct FAIRequestID& RequestID, EPathFollowingResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterEvasionBehaviour", "EscapeDestinationReached");

	Params::AICharacterEvasionBehaviour_EscapeDestinationReached Parms{};

	Parms.RequestID = std::move(RequestID);
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialGameMode.SetEscapeActivated
// (Final, Native, Public, BlueprintCallable)

void ATutorialGameMode::SetEscapeActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialGameMode", "SetEscapeActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialGameMode.SetGameObjective
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AGameObjective_ActivatedGenerators>gameObjectiveClass                                     (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialGameMode::SetGameObjective(TSubclassOf<class AGameObjective_ActivatedGenerators> gameObjectiveClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialGameMode", "SetGameObjective");

	Params::TutorialGameMode_SetGameObjective Parms{};

	Parms.gameObjectiveClass = gameObjectiveClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialGameMode.GetAtlantaTutorialPlayerHudController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAtlantaTutorialPlayerHudController*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtlantaTutorialPlayerHudController* ATutorialGameMode::GetAtlantaTutorialPlayerHudController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialGameMode", "GetAtlantaTutorialPlayerHudController");

	Params::TutorialGameMode_GetAtlantaTutorialPlayerHudController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TutorialGameMode.GetTutorialHighlightController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTutorialHighlightController*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTutorialHighlightController* ATutorialGameMode::GetTutorialHighlightController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialGameMode", "GetTutorialHighlightController");

	Params::TutorialGameMode_GetTutorialHighlightController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TutorialGameMode.GetTutorialNotificationController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTutorialNotificationController*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTutorialNotificationController* ATutorialGameMode::GetTutorialNotificationController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialGameMode", "GetTutorialNotificationController");

	Params::TutorialGameMode_GetTutorialNotificationController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TutorialGameMode.GetTutorialObjectiveController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTutorialObjectiveController*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTutorialObjectiveController* ATutorialGameMode::GetTutorialObjectiveController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialGameMode", "GetTutorialObjectiveController");

	Params::TutorialGameMode_GetTutorialObjectiveController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AICharacterHideInLockerBehaviourData.Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ALocker*                          Locker                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECharacterMovementTypes                 characterMovementType_0                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAICharacterHideInLockerBehaviourData::Init(class ALocker* Locker, ECharacterMovementTypes characterMovementType_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterHideInLockerBehaviourData", "Init");

	Params::AICharacterHideInLockerBehaviourData_Init Parms{};

	Parms.Locker = Locker;
	Parms.characterMovementType_0 = characterMovementType_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FearMarketManager.ReceivedFearMarketData
// (Final, Native, Private)
// Parameters:
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFearMarketManager::ReceivedFearMarketData(bool Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FearMarketManager", "ReceivedFearMarketData");

	Params::FearMarketManager_ReceivedFearMarketData Parms{};

	Parms.Success = Success;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AICharacterHideInLockerBehaviour.OnMovementFinished
// (Final, Native, Private)
// Parameters:
// const struct FAIRequestID&              RequestID                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// EPathFollowingResult                    Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAICharacterHideInLockerBehaviour::OnMovementFinished(const struct FAIRequestID& RequestID, EPathFollowingResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterHideInLockerBehaviour", "OnMovementFinished");

	Params::AICharacterHideInLockerBehaviour_OnMovementFinished Parms{};

	Parms.RequestID = std::move(RequestID);
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AICharacterRepairGeneratorBehaviourData.Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AGenerator*                       Generator                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECharacterMovementTypes                 characterMovementType                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAICharacterRepairGeneratorBehaviourData::Init(class AGenerator* Generator, ECharacterMovementTypes characterMovementType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterRepairGeneratorBehaviourData", "Init");

	Params::AICharacterRepairGeneratorBehaviourData_Init Parms{};

	Parms.Generator = Generator;
	Parms.characterMovementType = characterMovementType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MoriableComponent.OnMoriFinished
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    hasBeenKilledByMori                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMoriableComponent::OnMoriFinished(bool hasBeenKilledByMori)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoriableComponent", "OnMoriFinished");

	Params::MoriableComponent_OnMoriFinished Parms{};

	Parms.hasBeenKilledByMori = hasBeenKilledByMori;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MoriableComponent.OnMoriUpdateStart
// (Final, Native, Public, BlueprintCallable)

void UMoriableComponent::OnMoriUpdateStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoriableComponent", "OnMoriUpdateStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MoriableComponent.OnRep_MoriInteractions
// (Final, Native, Protected)

void UMoriableComponent::OnRep_MoriInteractions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoriableComponent", "OnRep_MoriInteractions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AIHealAllyBehaviourData.Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASurvivor*                        allyToHealTarget                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIHealAllyBehaviourData::Init(class ASurvivor* allyToHealTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIHealAllyBehaviourData", "Init");

	Params::AIHealAllyBehaviourData_Init Parms{};

	Parms.allyToHealTarget = allyToHealTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AIHealAllyBehaviour.Init
// (Native, Public)
// Parameters:
// class ADBDPlayer*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAICharacterBehaviourData*        behaviourData                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIHealAllyBehaviour::Init(class ADBDPlayer* Character, class UAICharacterBehaviourData* behaviourData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIHealAllyBehaviour", "Init");

	Params::AIHealAllyBehaviour_Init Parms{};

	Parms.Character = Character;
	Parms.behaviourData = behaviourData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AIHealAllyBehaviour.TargetPositionReached
// (Final, Native, Private)
// Parameters:
// const struct FAIRequestID&              RequestID                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// EPathFollowingResult                    Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIHealAllyBehaviour::TargetPositionReached(const struct FAIRequestID& RequestID, EPathFollowingResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIHealAllyBehaviour", "TargetPositionReached");

	Params::AIHealAllyBehaviour_TargetPositionReached Parms{};

	Parms.RequestID = std::move(RequestID);
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EndGameComponent.DisableEndGameScenario
// (Final, Native, Public, BlueprintCallable)

void UEndGameComponent::DisableEndGameScenario()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameComponent", "DisableEndGameScenario");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EndGameComponent.FireEndGameSacrificeScoreEvent
// (Final, Native, Private)
// Parameters:
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)

void UEndGameComponent::FireEndGameSacrificeScoreEvent(const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameComponent", "FireEndGameSacrificeScoreEvent");

	Params::EndGameComponent_FireEndGameSacrificeScoreEvent Parms{};

	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EndGameComponent.PauseEndGameTimer
// (Final, Native, Public, BlueprintCallable)

void UEndGameComponent::PauseEndGameTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameComponent", "PauseEndGameTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EndGameComponent.StartEndGame_Cheat
// (Final, Native, Public, BlueprintCallable)

void UEndGameComponent::StartEndGame_Cheat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameComponent", "StartEndGame_Cheat");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EndGameComponent.UnpauseEndGameTimer
// (Final, Native, Public, BlueprintCallable)

void UEndGameComponent::UnpauseEndGameTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameComponent", "UnpauseEndGameTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EndGameComponent.GetHasEndGameBegun
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEndGameComponent::GetHasEndGameBegun() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameComponent", "GetHasEndGameBegun");

	Params::EndGameComponent_GetHasEndGameBegun Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TutorialEndGameComponent.SetTimerMaxCompletionPercentage
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const float&                            Percentage                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialEndGameComponent::SetTimerMaxCompletionPercentage(const float& Percentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialEndGameComponent", "SetTimerMaxCompletionPercentage");

	Params::TutorialEndGameComponent_SetTimerMaxCompletionPercentage Parms{};

	Parms.Percentage = Percentage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AIMoveToInteractData.Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           interactActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECharacterMovementTypes                 characterMovementTypes                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           targetPositionActor                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIMoveToInteractData::Init(class AActor* interactActor, ECharacterMovementTypes characterMovementTypes, class AActor* targetPositionActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIMoveToInteractData", "Init");

	Params::AIMoveToInteractData_Init Parms{};

	Parms.interactActor = interactActor;
	Parms.characterMovementTypes = characterMovementTypes;
	Parms.targetPositionActor = targetPositionActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AIMoveToInteract.Init
// (Native, Public)
// Parameters:
// class ADBDPlayer*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAICharacterBehaviourData*        behaviourData                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIMoveToInteract::Init(class ADBDPlayer* Character, class UAICharacterBehaviourData* behaviourData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIMoveToInteract", "Init");

	Params::AIMoveToInteract_Init Parms{};

	Parms.Character = Character;
	Parms.behaviourData = behaviourData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AIMoveToInteract.InteractionPointReached
// (Final, Native, Private)
// Parameters:
// const struct FAIRequestID&              RequestID                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// EPathFollowingResult                    Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIMoveToInteract::InteractionPointReached(const struct FAIRequestID& RequestID, EPathFollowingResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIMoveToInteract", "InteractionPointReached");

	Params::AIMoveToInteract_InteractionPointReached Parms{};

	Parms.RequestID = std::move(RequestID);
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffectCollectionComponent.OnRep_Array
// (Final, Native, Private)

void UStatusEffectCollectionComponent::OnRep_Array()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectCollectionComponent", "OnRep_Array");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AIMoveToPositionData.Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           positionActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECharacterMovementTypes                 movementType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    usePathfinding                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIMoveToPositionData::Init(class AActor* positionActor, ECharacterMovementTypes movementType, bool usePathfinding)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIMoveToPositionData", "Init");

	Params::AIMoveToPositionData_Init Parms{};

	Parms.positionActor = positionActor;
	Parms.movementType = movementType;
	Parms.usePathfinding = usePathfinding;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDHud.RemoveStatusViewOnDestroy
// (Final, Native, Private)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDHud::RemoveStatusViewOnDestroy(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDHud", "RemoveStatusViewOnDestroy");

	Params::DBDHud_RemoveStatusViewOnDestroy Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AISense_Trail.ReportTrailEvent
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          worldContextObj                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              IgnoreOnPerkTag                                        (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Lifetime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAISense_Trail::ReportTrailEvent(class UObject* worldContextObj, const struct FVector& Location, class AActor* Instigator, const struct FGameplayTag& IgnoreOnPerkTag, float Lifetime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AISense_Trail", "ReportTrailEvent");

	Params::AISense_Trail_ReportTrailEvent Parms{};

	Parms.worldContextObj = worldContextObj;
	Parms.Location = std::move(Location);
	Parms.Instigator = Instigator;
	Parms.IgnoreOnPerkTag = std::move(IgnoreOnPerkTag);
	Parms.Lifetime = Lifetime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GenericPopupScreen.OnChoiceSelected
// (Final, Native, Private)
// Parameters:
// int32                                   selectedButtonType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGenericPopupScreen::OnChoiceSelected(int32 selectedButtonType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GenericPopupScreen", "OnChoiceSelected");

	Params::GenericPopupScreen_OnChoiceSelected Parms{};

	Parms.selectedButtonType = selectedButtonType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FriendSearchPopupScreen.OnAcceptFriendInvite
// (Final, Native, Public)
// Parameters:
// const class FString&                    friendKrakenID                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFriendSearchPopupScreen::OnAcceptFriendInvite(const class FString& friendKrakenID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendSearchPopupScreen", "OnAcceptFriendInvite");

	Params::FriendSearchPopupScreen_OnAcceptFriendInvite Parms{};

	Parms.friendKrakenID = std::move(friendKrakenID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FriendSearchPopupScreen.OnFriendSearchStart
// (Final, Native, Public)
// Parameters:
// const class FString&                    SearchText                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFriendSearchPopupScreen::OnFriendSearchStart(const class FString& SearchText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendSearchPopupScreen", "OnFriendSearchStart");

	Params::FriendSearchPopupScreen_OnFriendSearchStart Parms{};

	Parms.SearchText = std::move(SearchText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FriendSearchPopupScreen.OnInviteFriend
// (Final, Native, Public)
// Parameters:
// const class FString&                    friendKrakenID                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsOffNetwork                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFriendSearchPopupScreen::OnInviteFriend(const class FString& friendKrakenID, bool IsOffNetwork)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendSearchPopupScreen", "OnInviteFriend");

	Params::FriendSearchPopupScreen_OnInviteFriend Parms{};

	Parms.friendKrakenID = std::move(friendKrakenID);
	Parms.IsOffNetwork = IsOffNetwork;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FriendSearchPopupScreen.OnUnblockPlayer
// (Final, Native, Public)
// Parameters:
// const class FString&                    friendKrakenID                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFriendSearchPopupScreen::OnUnblockPlayer(const class FString& friendKrakenID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendSearchPopupScreen", "OnUnblockPlayer");

	Params::FriendSearchPopupScreen_OnUnblockPlayer Parms{};

	Parms.friendKrakenID = std::move(friendKrakenID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ExposerInteriorZoneComponent.AddExposerSpawnPoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Point                                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExposerInteriorZoneComponent::AddExposerSpawnPoint(class USceneComponent* Point)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExposerInteriorZoneComponent", "AddExposerSpawnPoint");

	Params::ExposerInteriorZoneComponent_AddExposerSpawnPoint Parms{};

	Parms.Point = Point;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGGameplayAlertWidget.UpdateWidget
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FStatusEffectSlotData&     StatusEffectData                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FInventorySlotData&        originatorData                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUMGGameplayAlertWidget::UpdateWidget(const struct FStatusEffectSlotData& StatusEffectData, const struct FInventorySlotData& originatorData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGGameplayAlertWidget", "UpdateWidget");

	Params::UMGGameplayAlertWidget_UpdateWidget Parms{};

	Parms.StatusEffectData = std::move(StatusEffectData);
	Parms.originatorData = std::move(originatorData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.AISlasherMoveToGrabSurvivorBehaviourData.Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASurvivor*                        TargetSurvivor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAISlasherMoveToGrabSurvivorBehaviourData::Init(class ASurvivor* TargetSurvivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AISlasherMoveToGrabSurvivorBehaviourData", "Init");

	Params::AISlasherMoveToGrabSurvivorBehaviourData_Init Parms{};

	Parms.TargetSurvivor = TargetSurvivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBD_SoundEventSpawner.AssetsLoaded
// (Final, Native, Protected)

void ADBD_SoundEventSpawner::AssetsLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBD_SoundEventSpawner", "AssetsLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBD_SoundEventSpawner.OnLoudNoiseTriggered
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           originator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           instigatingActor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    shouldTrack                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  audibleRange                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isQuickAction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isDeceivingNoise                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBD_SoundEventSpawner::OnLoudNoiseTriggered(class AActor* originator, class AActor* instigatingActor, const struct FVector& Location, bool shouldTrack, float* audibleRange, bool isQuickAction, bool isDeceivingNoise)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBD_SoundEventSpawner", "OnLoudNoiseTriggered");

	Params::DBD_SoundEventSpawner_OnLoudNoiseTriggered Parms{};

	Parms.originator = originator;
	Parms.instigatingActor = instigatingActor;
	Parms.Location = std::move(Location);
	Parms.shouldTrack = shouldTrack;
	Parms.isQuickAction = isQuickAction;
	Parms.isDeceivingNoise = isDeceivingNoise;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (audibleRange != nullptr)
		*audibleRange = Parms.audibleRange;
}


// Function DeadByDaylight.DBDPlayerCameraManager.CancelCurrentFadeTimeline
// (Event, Public, BlueprintEvent)

void ADBDPlayerCameraManager::CancelCurrentFadeTimeline()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerCameraManager", "CancelCurrentFadeTimeline");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.DBDPlayerCameraManager.StartFadeInTimeline
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerCameraManager::StartFadeInTimeline(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerCameraManager", "StartFadeInTimeline");

	Params::DBDPlayerCameraManager_StartFadeInTimeline Parms{};

	Parms.Duration = Duration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBDPlayerCameraManager.StartFadeOutTimeline
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerCameraManager::StartFadeOutTimeline(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerCameraManager", "StartFadeOutTimeline");

	Params::DBDPlayerCameraManager_StartFadeOutTimeline Parms{};

	Parms.Duration = Duration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBDClipRegionComponent.ApplyArrayOfClipsToDynamicMaterial
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const TArray<class UDBDClipRegionComponent*>&InRegions                                              (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic*         dynamicInstanceToClip                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDClipRegionComponent::ApplyArrayOfClipsToDynamicMaterial(const TArray<class UDBDClipRegionComponent*>& InRegions, class UMaterialInstanceDynamic* dynamicInstanceToClip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDClipRegionComponent", "ApplyArrayOfClipsToDynamicMaterial");

	Params::DBDClipRegionComponent_ApplyArrayOfClipsToDynamicMaterial Parms{};

	Parms.InRegions = std::move(InRegions);
	Parms.dynamicInstanceToClip = dynamicInstanceToClip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDClipRegionComponent.ApplyClip
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UMaterialInstanceDynamic*         InMaterial2clip                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InRegionID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDClipRegionComponent::ApplyClip(class UMaterialInstanceDynamic* InMaterial2clip, int32 InRegionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDClipRegionComponent", "ApplyClip");

	Params::DBDClipRegionComponent_ApplyClip Parms{};

	Parms.InMaterial2clip = InMaterial2clip;
	Parms.InRegionID = InRegionID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBDClipRegionComponent.ApplyClipToDynamicMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         dynamicInstanceToClip                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InRegionID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDClipRegionComponent::ApplyClipToDynamicMaterial(class UMaterialInstanceDynamic* dynamicInstanceToClip, int32 InRegionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDClipRegionComponent", "ApplyClipToDynamicMaterial");

	Params::DBDClipRegionComponent_ApplyClipToDynamicMaterial Parms{};

	Parms.dynamicInstanceToClip = dynamicInstanceToClip;
	Parms.InRegionID = InRegionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDClipRegionComponent.ClipDistance
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UMeshComponent*                   InMeshComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDClipRegionComponent::ClipDistance(class UMeshComponent* InMeshComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDClipRegionComponent", "ClipDistance");

	Params::DBDClipRegionComponent_ClipDistance Parms{};

	Parms.InMeshComponent = InMeshComponent;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDClipRegionComponent.NotifyShouldClipComponent
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UMeshComponent*                   InMeshComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDClipRegionComponent::NotifyShouldClipComponent(class UMeshComponent* InMeshComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDClipRegionComponent", "NotifyShouldClipComponent");

	Params::DBDClipRegionComponent_NotifyShouldClipComponent Parms{};

	Parms.InMeshComponent = InMeshComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.AnimationMontageSlave.OnMontageStarted
// (Final, Native, Private)
// Parameters:
// const struct FAnimationMontageDescriptor&ID                                                     (ConstParm, Parm, NativeAccessSpecifierPublic)
// const float                             Rate                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationMontageSlave::OnMontageStarted(const struct FAnimationMontageDescriptor& ID, const float Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationMontageSlave", "OnMontageStarted");

	Params::AnimationMontageSlave_OnMontageStarted Parms{};

	Parms.ID = std::move(ID);
	Parms.Rate = Rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AnimationMontageSlave.OnMontageStopped
// (Final, Native, Private)
// Parameters:
// const struct FAnimationMontageDescriptor&ID                                                     (ConstParm, Parm, NativeAccessSpecifierPublic)

void UAnimationMontageSlave::OnMontageStopped(const struct FAnimationMontageDescriptor& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationMontageSlave", "OnMontageStopped");

	Params::AnimationMontageSlave_OnMontageStopped Parms{};

	Parms.ID = std::move(ID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AnimationMontageSlave.SetLeader
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMontagePlayer*                   Leader                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationMontageSlave::SetLeader(class UMontagePlayer* Leader)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationMontageSlave", "SetLeader");

	Params::AnimationMontageSlave_SetLeader Parms{};

	Parms.Leader = Leader;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AnimationMontageSlave.SetMontagePlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMontagePlayer*                   MontagePlayer                                          (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationMontageSlave::SetMontagePlayer(class UMontagePlayer* MontagePlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationMontageSlave", "SetMontagePlayer");

	Params::AnimationMontageSlave_SetMontagePlayer Parms{};

	Parms.MontagePlayer = MontagePlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AnimationPreviewPreloadRequest.OnClassesLoaded
// (Final, Native, Private)

void UAnimationPreviewPreloadRequest::OnClassesLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationPreviewPreloadRequest", "OnClassesLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AnimationPreviewSubsystem.OnAnimationPreviewEnd
// (Final, Native, Private)
// Parameters:
// class UAnimationPreview*                Preview                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    completedSuccessfully                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationPreviewSubsystem::OnAnimationPreviewEnd(class UAnimationPreview* Preview, bool completedSuccessfully)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationPreviewSubsystem", "OnAnimationPreviewEnd");

	Params::AnimationPreviewSubsystem_OnAnimationPreviewEnd Parms{};

	Parms.Preview = Preview;
	Parms.completedSuccessfully = completedSuccessfully;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AnimationPreviewSubsystem.OnAnimationPreviewStart
// (Final, Native, Private)
// Parameters:
// class UAnimationPreview*                Preview                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationPreviewSubsystem::OnAnimationPreviewStart(class UAnimationPreview* Preview)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationPreviewSubsystem", "OnAnimationPreviewStart");

	Params::AnimationPreviewSubsystem_OnAnimationPreviewStart Parms{};

	Parms.Preview = Preview;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AnimationPreviewSubsystem.CharacterHasSecondaryMori
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   killerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimationPreviewSubsystem::CharacterHasSecondaryMori(int32 killerId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationPreviewSubsystem", "CharacterHasSecondaryMori");

	Params::AnimationPreviewSubsystem_CharacterHasSecondaryMori Parms{};

	Parms.killerId = killerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AnimationPreviewSubsystem.IsPreviewingAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimationPreviewSubsystem::IsPreviewingAnimation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationPreviewSubsystem", "IsPreviewingAnimation");

	Params::AnimationPreviewSubsystem_IsPreviewingAnimation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDMathBlueprintLibrary.TransformToMatrix
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FTransform&                A                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FLinearColor>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FLinearColor> UDBDMathBlueprintLibrary::TransformToMatrix(const struct FTransform& A)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDMathBlueprintLibrary", "TransformToMatrix");

	Params::DBDMathBlueprintLibrary_TransformToMatrix Parms{};

	Parms.A = std::move(A);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDMathBlueprintLibrary.VectorAbsoluteValue
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDBDMathBlueprintLibrary::VectorAbsoluteValue(const struct FVector& A)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDMathBlueprintLibrary", "VectorAbsoluteValue");

	Params::DBDMathBlueprintLibrary_VectorAbsoluteValue Parms{};

	Parms.A = std::move(A);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDMathBlueprintLibrary.VectorIntersect
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   OriginA                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   ExtentA                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   OriginB                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   ExtentB                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDMathBlueprintLibrary::VectorIntersect(const struct FVector& OriginA, const struct FVector& ExtentA, const struct FVector& OriginB, const struct FVector& ExtentB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDMathBlueprintLibrary", "VectorIntersect");

	Params::DBDMathBlueprintLibrary_VectorIntersect Parms{};

	Parms.OriginA = std::move(OriginA);
	Parms.ExtentA = std::move(ExtentA);
	Parms.OriginB = std::move(OriginB);
	Parms.ExtentB = std::move(ExtentB);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DisplayStandItemRequesterComponent.LoadItemsOnCharacter
// (Final, Native, Private)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDisplayStandItemRequesterComponent::LoadItemsOnCharacter(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DisplayStandItemRequesterComponent", "LoadItemsOnCharacter");

	Params::DisplayStandItemRequesterComponent_LoadItemsOnCharacter Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AnimNotify_PlayNiagaraEffectBasedOnTag.GetSpawnedDefaultEffect
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class UFXSystemComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFXSystemComponent* UAnimNotify_PlayNiagaraEffectBasedOnTag::GetSpawnedDefaultEffect() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimNotify_PlayNiagaraEffectBasedOnTag", "GetSpawnedDefaultEffect");

	Params::AnimNotify_PlayNiagaraEffectBasedOnTag_GetSpawnedDefaultEffect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AnimNotify_PlayNiagaraEffectBasedOnTag.GetSpawnedTagBasedEffect
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class UFXSystemComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFXSystemComponent* UAnimNotify_PlayNiagaraEffectBasedOnTag::GetSpawnedTagBasedEffect() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimNotify_PlayNiagaraEffectBasedOnTag", "GetSpawnedTagBasedEffect");

	Params::AnimNotify_PlayNiagaraEffectBasedOnTag_GetSpawnedTagBasedEffect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.OfferingUtilities.HasItemLossProtection
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOfferingUtilities::HasItemLossProtection(const class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OfferingUtilities", "HasItemLossProtection");

	Params::OfferingUtilities_HasItemLossProtection Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.OfferingUtilities.HasOfferingOfType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOfferingEffectType                     offeringEffectType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOfferingUtilities::HasOfferingOfType(const class UObject* WorldContextObject, EOfferingEffectType offeringEffectType, int32 PlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OfferingUtilities", "HasOfferingOfType");

	Params::OfferingUtilities_HasOfferingOfType Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.offeringEffectType = offeringEffectType;
	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.OfferingUtilities.IsPlayerEquippedWithOfferingWithTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       offeringTag                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOfferingUtilities::IsPlayerEquippedWithOfferingWithTag(const class ADBDPlayer* Player, const class FName offeringTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OfferingUtilities", "IsPlayerEquippedWithOfferingWithTag");

	Params::OfferingUtilities_IsPlayerEquippedWithOfferingWithTag Parms{};

	Parms.Player = Player;
	Parms.offeringTag = offeringTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherAnimInstance.CallOnFootTrapped
// (Final, Native, Protected, BlueprintCallable)

void USlasherAnimInstance::CallOnFootTrapped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherAnimInstance", "CallOnFootTrapped");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherAnimInstance.SetIsCrouched
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlasherAnimInstance::SetIsCrouched(const bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherAnimInstance", "SetIsCrouched");

	Params::SlasherAnimInstance_SetIsCrouched Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FranklinsDemiseConsumedByEntityComponent.Authority_StartConsume
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       previousOwner                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       Slasher                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFranklinsDemiseConsumedByEntityComponent::Authority_StartConsume(float Duration, class ADBDPlayer* previousOwner, class ADBDPlayer* Slasher)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FranklinsDemiseConsumedByEntityComponent", "Authority_StartConsume");

	Params::FranklinsDemiseConsumedByEntityComponent_Authority_StartConsume Parms{};

	Parms.Duration = Duration;
	Parms.previousOwner = previousOwner;
	Parms.Slasher = Slasher;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FranklinsDemiseConsumedByEntityComponent.OnConsumedByEntity
// (Event, Public, BlueprintEvent)

void UFranklinsDemiseConsumedByEntityComponent::OnConsumedByEntity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FranklinsDemiseConsumedByEntityComponent", "OnConsumedByEntity");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.FranklinsDemiseConsumedByEntityComponent.OnRep_ConsumeTimer
// (Final, Native, Private)

void UFranklinsDemiseConsumedByEntityComponent::OnRep_ConsumeTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FranklinsDemiseConsumedByEntityComponent", "OnRep_ConsumeTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AntiCampSelfUnhookComponent.OnEscapeDoorActivated
// (Final, Native, Private)

void UAntiCampSelfUnhookComponent::OnEscapeDoorActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AntiCampSelfUnhookComponent", "OnEscapeDoorActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AntiCampSelfUnhookComponent.OnHookedSurvivorDrainStageChanged
// (Final, Native, Private)
// Parameters:
// const int32                             drainStage                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAntiCampSelfUnhookComponent::OnHookedSurvivorDrainStageChanged(const int32 drainStage, class ADBDPlayer* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AntiCampSelfUnhookComponent", "OnHookedSurvivorDrainStageChanged");

	Params::AntiCampSelfUnhookComponent_OnHookedSurvivorDrainStageChanged Parms{};

	Parms.drainStage = drainStage;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AntiCampSelfUnhookComponent.OnRep_Progress
// (Final, Native, Private)

void UAntiCampSelfUnhookComponent::OnRep_Progress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AntiCampSelfUnhookComponent", "OnRep_Progress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AntiCampSelfUnhookComponent.OnRep_State
// (Final, Native, Private)
// Parameters:
// ETimedEffectMeterState                  previousState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAntiCampSelfUnhookComponent::OnRep_State(ETimedEffectMeterState previousState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AntiCampSelfUnhookComponent", "OnRep_State");

	Params::AntiCampSelfUnhookComponent_OnRep_State Parms{};

	Parms.previousState = previousState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AntiCampSelfUnhookComponent.SetAntiCampUnhookChargeable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UChargeableComponent*             Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAntiCampSelfUnhookComponent::SetAntiCampUnhookChargeable(class UChargeableComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AntiCampSelfUnhookComponent", "SetAntiCampUnhookChargeable");

	Params::AntiCampSelfUnhookComponent_SetAntiCampUnhookChargeable Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AntiCampSelfUnhookComponent.GetAntiCampGracePeriod
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAntiCampSelfUnhookComponent::GetAntiCampGracePeriod() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AntiCampSelfUnhookComponent", "GetAntiCampGracePeriod");

	Params::AntiCampSelfUnhookComponent_GetAntiCampGracePeriod Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AntiCampSelfUnhookComponent.GetAntiCampMaxLowerZCurveDistanceTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAntiCampSelfUnhookComponent::GetAntiCampMaxLowerZCurveDistanceTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AntiCampSelfUnhookComponent", "GetAntiCampMaxLowerZCurveDistanceTime");

	Params::AntiCampSelfUnhookComponent_GetAntiCampMaxLowerZCurveDistanceTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AntiCampSelfUnhookComponent.GetAntiCampMaxUpperZCurveDistanceTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAntiCampSelfUnhookComponent::GetAntiCampMaxUpperZCurveDistanceTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AntiCampSelfUnhookComponent", "GetAntiCampMaxUpperZCurveDistanceTime");

	Params::AntiCampSelfUnhookComponent_GetAntiCampMaxUpperZCurveDistanceTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AntiCampSelfUnhookComponent.GetAntiCampMaxXYCurveDistanceTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAntiCampSelfUnhookComponent::GetAntiCampMaxXYCurveDistanceTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AntiCampSelfUnhookComponent", "GetAntiCampMaxXYCurveDistanceTime");

	Params::AntiCampSelfUnhookComponent_GetAntiCampMaxXYCurveDistanceTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AntiCampSelfUnhookComponent.GetProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAntiCampSelfUnhookComponent::GetProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AntiCampSelfUnhookComponent", "GetProgress");

	Params::AntiCampSelfUnhookComponent_GetProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.OfferingEffectCollection.HasOfferingOfType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOfferingEffectType                     Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOfferingEffectCollection::HasOfferingOfType(EOfferingEffectType Type, int32 PlayerId, class FName Tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingEffectCollection", "HasOfferingOfType");

	Params::OfferingEffectCollection_HasOfferingOfType Parms{};

	Parms.Type = Type;
	Parms.PlayerId = PlayerId;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.OfferingEffectCollection.HasOfferingWithTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOfferingEffectCollection::HasOfferingWithTag(int32 PlayerId, class FName Tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingEffectCollection", "HasOfferingWithTag");

	Params::OfferingEffectCollection_HasOfferingWithTag Parms{};

	Parms.PlayerId = PlayerId;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.OverlayMenuScreen.OnAimAssistClick
// (Final, Native, Public)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOverlayMenuScreen::OnAimAssistClick(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnAimAssistClick");

	Params::OverlayMenuScreen_OnAimAssistClick Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnAtlantaSettingButtonClick
// (Final, Native, Public)
// Parameters:
// int32                                   buttonId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOverlayMenuScreen::OnAtlantaSettingButtonClick(int32 buttonId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnAtlantaSettingButtonClick");

	Params::OverlayMenuScreen_OnAtlantaSettingButtonClick Parms{};

	Parms.buttonId = buttonId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnBackButtonClick
// (Final, Native, Public)

void UOverlayMenuScreen::OnBackButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnBackButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnCustomerSupportButtonClick
// (Final, Native, Public)

void UOverlayMenuScreen::OnCustomerSupportButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnCustomerSupportButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnEULAButtonClick
// (Final, Native, Public)

void UOverlayMenuScreen::OnEULAButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnEULAButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnForumsButtonClick
// (Final, Native, Public)

void UOverlayMenuScreen::OnForumsButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnForumsButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnKillerCameraSensitivityChanged
// (Final, Native, Public)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOverlayMenuScreen::OnKillerCameraSensitivityChanged(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnKillerCameraSensitivityChanged");

	Params::OverlayMenuScreen_OnKillerCameraSensitivityChanged Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnLanguageChange
// (Final, Native, Public)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOverlayMenuScreen::OnLanguageChange(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnLanguageChange");

	Params::OverlayMenuScreen_OnLanguageChange Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnPrivacyPolicyButtonClick
// (Final, Native, Public)

void UOverlayMenuScreen::OnPrivacyPolicyButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnPrivacyPolicyButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnQuitButtonClick
// (Final, Native, Public)

void UOverlayMenuScreen::OnQuitButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnQuitButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnRequestKeyBindingInput
// (Final, Native, Public)
// Parameters:
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOverlayMenuScreen::OnRequestKeyBindingInput(int32 ID, const class FString& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnRequestKeyBindingInput");

	Params::OverlayMenuScreen_OnRequestKeyBindingInput Parms{};

	Parms.ID = ID;
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnResetDefaultKeybindings
// (Final, Native, Public)

void UOverlayMenuScreen::OnResetDefaultKeybindings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnResetDefaultKeybindings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnResetDefaultSettings
// (Final, Native, Public)

void UOverlayMenuScreen::OnResetDefaultSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnResetDefaultSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnSelectTab
// (Final, Native, Public)
// Parameters:
// int32                                   TabIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOverlayMenuScreen::OnSelectTab(int32 TabIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnSelectTab");

	Params::OverlayMenuScreen_OnSelectTab Parms{};

	Parms.TabIndex = TabIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnSetScrollPromptVisibility
// (Final, Native, Public)
// Parameters:
// bool                                    IsVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOverlayMenuScreen::OnSetScrollPromptVisibility(bool IsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnSetScrollPromptVisibility");

	Params::OverlayMenuScreen_OnSetScrollPromptVisibility Parms{};

	Parms.IsVisible = IsVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnSettingsOptionButtonClicked
// (Final, Native, Public)
// Parameters:
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOverlayMenuScreen::OnSettingsOptionButtonClicked(int32 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnSettingsOptionButtonClicked");

	Params::OverlayMenuScreen_OnSettingsOptionButtonClicked Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnSettingsOptionCheckboxSelected
// (Final, Native, Public)
// Parameters:
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsSelected                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOverlayMenuScreen::OnSettingsOptionCheckboxSelected(int32 ID, bool IsSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnSettingsOptionCheckboxSelected");

	Params::OverlayMenuScreen_OnSettingsOptionCheckboxSelected Parms{};

	Parms.ID = ID;
	Parms.IsSelected = IsSelected;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnSettingsOptionIntValueChanged
// (Final, Native, Public)
// Parameters:
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOverlayMenuScreen::OnSettingsOptionIntValueChanged(int32 ID, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnSettingsOptionIntValueChanged");

	Params::OverlayMenuScreen_OnSettingsOptionIntValueChanged Parms{};

	Parms.ID = ID;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnSurvivorCameraSensitivityChanged
// (Final, Native, Public)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOverlayMenuScreen::OnSurvivorCameraSensitivityChanged(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnSurvivorCameraSensitivityChanged");

	Params::OverlayMenuScreen_OnSurvivorCameraSensitivityChanged Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDOutlineComponent.InitBatcher
// (Final, Native, Private)

void UDBDOutlineComponent::InitBatcher()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDOutlineComponent", "InitBatcher");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDOutlineComponent.OnLevelReadyToPlay
// (Final, Native, Private)

void UDBDOutlineComponent::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDOutlineComponent", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDOutlineComponent.RefreshOutlineComponent
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)

void UDBDOutlineComponent::RefreshOutlineComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDOutlineComponent", "RefreshOutlineComponent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDOutlineComponent.ResetToTransparent
// (Final, Native, Public, BlueprintCallable)

void UDBDOutlineComponent::ResetToTransparent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDOutlineComponent", "ResetToTransparent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDOutlineComponent.SetFadeIntensity
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// float                                   fadeIntensity                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDOutlineComponent::SetFadeIntensity(float fadeIntensity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDOutlineComponent", "SetFadeIntensity");

	Params::DBDOutlineComponent_SetFadeIntensity Parms{};

	Parms.fadeIntensity = fadeIntensity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDOutlineComponent.SetFadeTexture
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class UTexture*                         inFadeTexture                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDOutlineComponent::SetFadeTexture(class UTexture* inFadeTexture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDOutlineComponent", "SetFadeTexture");

	Params::DBDOutlineComponent_SetFadeTexture Parms{};

	Parms.inFadeTexture = inFadeTexture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDOutlineComponent.SetIsOccludingOutlines
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              isOccluding                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDOutlineComponent::SetIsOccludingOutlines(const bool isOccluding)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDOutlineComponent", "SetIsOccludingOutlines");

	Params::DBDOutlineComponent_SetIsOccludingOutlines Parms{};

	Parms.isOccluding = isOccluding;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDOutlineComponent.SetMaterialCopyTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               inMaterialToCopy                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDOutlineComponent::SetMaterialCopyTarget(class UMaterialInterface* inMaterialToCopy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDOutlineComponent", "SetMaterialCopyTarget");

	Params::DBDOutlineComponent_SetMaterialCopyTarget Parms{};

	Parms.inMaterialToCopy = inMaterialToCopy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDOutlineComponent.SetMinimumOutlineDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   distanceWhenIsAlwaysVisible                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDOutlineComponent::SetMinimumOutlineDistance(float distanceWhenIsAlwaysVisible, float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDOutlineComponent", "SetMinimumOutlineDistance");

	Params::DBDOutlineComponent_SetMinimumOutlineDistance Parms{};

	Parms.distanceWhenIsAlwaysVisible = distanceWhenIsAlwaysVisible;
	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDOutlineComponent.SetOutlineIntensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   outlineIntensity                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDOutlineComponent::SetOutlineIntensity(float outlineIntensity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDOutlineComponent", "SetOutlineIntensity");

	Params::DBDOutlineComponent_SetOutlineIntensity Parms{};

	Parms.outlineIntensity = outlineIntensity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDOutlineComponent.SetOutlineMaterialOverride
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              OverrideName                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDOutlineComponent::SetOutlineMaterialOverride(const struct FGameplayTag& OverrideName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDOutlineComponent", "SetOutlineMaterialOverride");

	Params::DBDOutlineComponent_SetOutlineMaterialOverride Parms{};

	Parms.OverrideName = std::move(OverrideName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDOutlineComponent.SetTargetColor
// (Final, BlueprintCosmetic, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FLinearColor&              Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDOutlineComponent::SetTargetColor(const struct FLinearColor& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDOutlineComponent", "SetTargetColor");

	Params::DBDOutlineComponent_SetTargetColor Parms{};

	Parms.Color = std::move(Color);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDOutlineComponent.GetTargetColor
// (Final, BlueprintCosmetic, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FLinearColor               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FLinearColor UDBDOutlineComponent::GetTargetColor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDOutlineComponent", "GetTargetColor");

	Params::DBDOutlineComponent_GetTargetColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.OfferingCard.ChangeAnimationClass
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TSubclassOf<class UOfferingCardAnim>&animationClass                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOfferingCard::ChangeAnimationClass(const TSubclassOf<class UOfferingCardAnim>& animationClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingCard", "ChangeAnimationClass");

	Params::OfferingCard_ChangeAnimationClass Parms{};

	Parms.animationClass = animationClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OfferingCard.ChangeState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOfferingAnimState                      State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOfferingCard::ChangeState(EOfferingAnimState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingCard", "ChangeState");

	Params::OfferingCard_ChangeState Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OfferingCard.HandleCardDissolved
// (Event, Protected, BlueprintEvent)

void AOfferingCard::HandleCardDissolved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingCard", "HandleCardDissolved");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.OfferingCard.HandleStateChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// EOfferingAnimState                      State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOfferingCard::HandleStateChanged(EOfferingAnimState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingCard", "HandleStateChanged");

	Params::OfferingCard_HandleStateChanged Parms{};

	Parms.State = State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.OfferingCard.GetCardAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UOfferingCardAnim*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOfferingCardAnim* AOfferingCard::GetCardAnimation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingCard", "GetCardAnimation");

	Params::OfferingCard_GetCardAnimation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.OfferingCard.GetState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOfferingAnimState                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOfferingAnimState AOfferingCard::GetState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingCard", "GetState");

	Params::OfferingCard_GetState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.OfferingCard.IsRevealed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOfferingCard::IsRevealed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingCard", "IsRevealed");

	Params::OfferingCard_IsRevealed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TokenCounter.Authority_DecrementToken
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UTokenCounter::Authority_DecrementToken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TokenCounter", "Authority_DecrementToken");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TokenCounter.Authority_IncrementToken
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UTokenCounter::Authority_IncrementToken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TokenCounter", "Authority_IncrementToken");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TokenCounter.Authority_SetMaxTokenCount
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTokenCounter::Authority_SetMaxTokenCount(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TokenCounter", "Authority_SetMaxTokenCount");

	Params::TokenCounter_Authority_SetMaxTokenCount Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TokenCounter.Authority_SetTokenCount
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTokenCounter::Authority_SetTokenCount(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TokenCounter", "Authority_SetTokenCount");

	Params::TokenCounter_Authority_SetTokenCount Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TokenCounter.OnRep_TokenCount
// (Final, Native, Private)
// Parameters:
// int32                                   oldCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTokenCounter::OnRep_TokenCount(int32 oldCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TokenCounter", "OnRep_TokenCount");

	Params::TokenCounter_OnRep_TokenCount Parms{};

	Parms.oldCount = oldCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TokenCounter.GetMaxTokenCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTokenCounter::GetMaxTokenCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TokenCounter", "GetMaxTokenCount");

	Params::TokenCounter_GetMaxTokenCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TokenCounter.GetTokenCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTokenCounter::GetTokenCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TokenCounter", "GetTokenCount");

	Params::TokenCounter_GetTokenCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBD_CrossDissolver.KillClone
// (Final, Native, Public, BlueprintCallable)

void UDBD_CrossDissolver::KillClone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBD_CrossDissolver", "KillClone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBD_CrossDissolver.MakeClone
// (Final, Native, Public, BlueprintCallable)

void UDBD_CrossDissolver::MakeClone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBD_CrossDissolver", "MakeClone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Pallet.Authority_OnOverlapPushBox
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void APallet::Authority_OnOverlapPushBox(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "Authority_OnOverlapPushBox");

	Params::Pallet_Authority_OnOverlapPushBox Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Pallet.BP_ExplodePallet
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APallet::BP_ExplodePallet(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "BP_ExplodePallet");

	Params::Pallet_BP_ExplodePallet Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Pallet.Cosmetic_OnPalletPulldownBlockedByEntityHide
// (BlueprintCosmetic, Event, Public, BlueprintCallable, BlueprintEvent)

void APallet::Cosmetic_OnPalletPulldownBlockedByEntityHide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "Cosmetic_OnPalletPulldownBlockedByEntityHide");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Pallet.Cosmetic_OnPalletPulldownBlockedByEntityShow
// (BlueprintCosmetic, Event, Public, BlueprintCallable, BlueprintEvent)

void APallet::Cosmetic_OnPalletPulldownBlockedByEntityShow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "Cosmetic_OnPalletPulldownBlockedByEntityShow");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Pallet.Cosmetic_PalletPullDownFXImmediateHide
// (BlueprintCosmetic, Event, Protected, BlueprintCallable, BlueprintEvent)

void APallet::Cosmetic_PalletPullDownFXImmediateHide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "Cosmetic_PalletPullDownFXImmediateHide");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Pallet.EntityExplodePallet
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APallet::EntityExplodePallet(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "EntityExplodePallet");

	Params::Pallet_EntityExplodePallet Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Pallet.ExplodePallet
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    kickPallet                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APallet::ExplodePallet(class ADBDPlayer* Player, bool kickPallet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "ExplodePallet");

	Params::Pallet_ExplodePallet Parms{};

	Parms.Player = Player;
	Parms.kickPallet = kickPallet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Pallet.ExplodeStunPallet
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APallet::ExplodeStunPallet(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "ExplodeStunPallet");

	Params::Pallet_ExplodeStunPallet Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Pallet.GetZoneForRestrictedPlacement
// (Event, Public, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* APallet::GetZoneForRestrictedPlacement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "GetZoneForRestrictedPlacement");

	Params::Pallet_GetZoneForRestrictedPlacement Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Pallet.Multicast_ExplodePallet
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    byEntity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APallet::Multicast_ExplodePallet(class ADBDPlayer* Player, bool byEntity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "Multicast_ExplodePallet");

	Params::Pallet_Multicast_ExplodePallet Parms{};

	Parms.Player = Player;
	Parms.byEntity = byEntity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Pallet.Multicast_PulldownPallet
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void APallet::Multicast_PulldownPallet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "Multicast_PulldownPallet");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Pallet.Multicast_ResetPallet
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void APallet::Multicast_ResetPallet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "Multicast_ResetPallet");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Pallet.Multicast_StunActor
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       playerPullingDown                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    stunBreakPallet                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APallet::Multicast_StunActor(class AActor* Actor, class ADBDPlayer* playerPullingDown, bool stunBreakPallet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "Multicast_StunActor");

	Params::Pallet_Multicast_StunActor Parms{};

	Parms.Actor = Actor;
	Parms.playerPullingDown = playerPullingDown;
	Parms.stunBreakPallet = stunBreakPallet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Pallet.OnFallen
// (Event, Public, BlueprintCallable, BlueprintEvent)

void APallet::OnFallen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "OnFallen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Pallet.OnPalletPulledUp_BP
// (Event, Protected, BlueprintEvent)

void APallet::OnPalletPulledUp_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "OnPalletPulledUp_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Pallet.OnPalletStunHit
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void APallet::OnPalletStunHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "OnPalletStunHit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Pallet.OnPulldownOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void APallet::OnPulldownOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "OnPulldownOverlap");

	Params::Pallet_OnPulldownOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Pallet.OnStunOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void APallet::OnStunOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "OnStunOverlap");

	Params::Pallet_OnStunOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Pallet.PullDown
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPalletPushSettings&       pushSettings                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const EPalletStunZoneSideStrategy       stunZoneSideStrategy                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APallet::PullDown(class ADBDPlayer* Player, const struct FPalletPushSettings& pushSettings, const EPalletStunZoneSideStrategy stunZoneSideStrategy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "PullDown");

	Params::Pallet_PullDown Parms{};

	Parms.Player = Player;
	Parms.pushSettings = std::move(pushSettings);
	Parms.stunZoneSideStrategy = stunZoneSideStrategy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Pallet.PulldownPallet
// (Event, Public, BlueprintCallable, BlueprintEvent)

void APallet::PulldownPallet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "PulldownPallet");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Pallet.ResetPallet
// (Event, Protected, BlueprintEvent)

void APallet::ResetPallet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "ResetPallet");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Pallet.SetPalletState
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EPalletState                            State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APallet::SetPalletState(EPalletState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "SetPalletState");

	Params::Pallet_SetPalletState Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Pallet.SetPendingDestruction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsPendingDestruction                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APallet::SetPendingDestruction(bool IsPendingDestruction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "SetPendingDestruction");

	Params::Pallet_SetPendingDestruction Parms{};

	Parms.IsPendingDestruction = IsPendingDestruction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Pallet.CanPulldown
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   interactionAxis                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              isStationary                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APallet::CanPulldown(const class ADBDPlayer* Player, const struct FVector& interactionAxis, const bool isStationary) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "CanPulldown");

	Params::Pallet_CanPulldown Parms{};

	Parms.Player = Player;
	Parms.interactionAxis = std::move(interactionAxis);
	Parms.isStationary = isStationary;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Pallet.GetDestructibleAreaPrimitiveComponents
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// TArray<class UPrimitiveComponent*>*     prims                                                  (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void APallet::GetDestructibleAreaPrimitiveComponents(TArray<class UPrimitiveComponent*>* prims) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "GetDestructibleAreaPrimitiveComponents");

	Params::Pallet_GetDestructibleAreaPrimitiveComponents Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (prims != nullptr)
		*prims = std::move(Parms.prims);
}


// Function DeadByDaylight.Pallet.GetFallDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float APallet::GetFallDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "GetFallDuration");

	Params::Pallet_GetFallDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Pallet.GetIsDreamPallet
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APallet::GetIsDreamPallet() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "GetIsDreamPallet");

	Params::Pallet_GetIsDreamPallet Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Pallet.GetIsFragile
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APallet::GetIsFragile() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "GetIsFragile");

	Params::Pallet_GetIsFragile Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Pallet.GetIsPulledDown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APallet::GetIsPulledDown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "GetIsPulledDown");

	Params::Pallet_GetIsPulledDown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Pallet.GetPalletSkeletalMeshComponent
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* APallet::GetPalletSkeletalMeshComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "GetPalletSkeletalMeshComponent");

	Params::Pallet_GetPalletSkeletalMeshComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Pallet.GetPlayerDoingPulldown
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* APallet::GetPlayerDoingPulldown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "GetPlayerDoingPulldown");

	Params::Pallet_GetPlayerDoingPulldown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Pallet.IsDestroyedByEntity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APallet::IsDestroyedByEntity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "IsDestroyedByEntity");

	Params::Pallet_IsDestroyedByEntity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Pallet.IsPendingDestruction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APallet::IsPendingDestruction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "IsPendingDestruction");

	Params::Pallet_IsPendingDestruction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Pallet.IsPulldownBlockedByEntity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APallet::IsPulldownBlockedByEntity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "IsPulldownBlockedByEntity");

	Params::Pallet_IsPulldownBlockedByEntity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrapRemover.AddKey
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   KeyId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReverseBearTrapRemover::AddKey(int32 KeyId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrapRemover", "AddKey");

	Params::ReverseBearTrapRemover_AddKey Parms{};

	Parms.KeyId = KeyId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrapRemover.AddSearchedKey
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   KeyId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReverseBearTrapRemover::AddSearchedKey(int32 KeyId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrapRemover", "AddSearchedKey");

	Params::ReverseBearTrapRemover_AddSearchedKey Parms{};

	Parms.KeyId = KeyId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrapRemover.PlayRemoveFailMontage
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AReverseBearTrapRemover::PlayRemoveFailMontage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrapRemover", "PlayRemoveFailMontage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.ReverseBearTrapRemover.GetAttachedRBT
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AReverseBearTrap*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AReverseBearTrap* AReverseBearTrapRemover::GetAttachedRBT(class AActor* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrapRemover", "GetAttachedRBT");

	Params::ReverseBearTrapRemover_GetAttachedRBT Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrapRemover.GetInteractorPrimitiveComponent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* AReverseBearTrapRemover::GetInteractorPrimitiveComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrapRemover", "GetInteractorPrimitiveComponent");

	Params::ReverseBearTrapRemover_GetInteractorPrimitiveComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrapRemover.GetMapActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMapActorComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMapActorComponent* AReverseBearTrapRemover::GetMapActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrapRemover", "GetMapActor");

	Params::ReverseBearTrapRemover_GetMapActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrapRemover.HasKey
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   KeyId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AReverseBearTrapRemover::HasKey(int32 KeyId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrapRemover", "HasKey");

	Params::ReverseBearTrapRemover_HasKey Parms{};

	Parms.KeyId = KeyId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrapRemover.HasSearchedForKey
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   KeyId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AReverseBearTrapRemover::HasSearchedForKey(int32 KeyId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrapRemover", "HasSearchedForKey");

	Params::ReverseBearTrapRemover_HasSearchedForKey Parms{};

	Parms.KeyId = KeyId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReportPlayerPopupScreen.OnConfirmReportPlayer
// (Final, Native, Private)
// Parameters:
// const class FString&                    category                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Comment                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UReportPlayerPopupScreen::OnConfirmReportPlayer(const class FString& category, const class FString& Comment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReportPlayerPopupScreen", "OnConfirmReportPlayer");

	Params::ReportPlayerPopupScreen_OnConfirmReportPlayer Parms{};

	Parms.category = std::move(category);
	Parms.Comment = std::move(Comment);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReportPlayerPopupScreen.OnTextInputMouseOver
// (Final, Native, Private)
// Parameters:
// bool                                    IsMouseOver                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UReportPlayerPopupScreen::OnTextInputMouseOver(bool IsMouseOver)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReportPlayerPopupScreen", "OnTextInputMouseOver");

	Params::ReportPlayerPopupScreen_OnTextInputMouseOver Parms{};

	Parms.IsMouseOver = IsMouseOver;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Window.Authority_OnVaultInternal
// (Final, BlueprintAuthorityOnly, Native, Protected, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    canBlockVault                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWindow::Authority_OnVaultInternal(class ADBDPlayer* Player, bool canBlockVault)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Window", "Authority_OnVaultInternal");

	Params::Window_Authority_OnVaultInternal Parms{};

	Parms.Player = Player;
	Parms.canBlockVault = canBlockVault;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Window.Authority_SetBlockedByLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isBlockedByLevel                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWindow::Authority_SetBlockedByLevel(bool isBlockedByLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Window", "Authority_SetBlockedByLevel");

	Params::Window_Authority_SetBlockedByLevel Parms{};

	Parms.isBlockedByLevel = isBlockedByLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Window.NotifyOnFastVault
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractionDefinition*           Interaction                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWindow::NotifyOnFastVault(class ADBDPlayer* Player, class UInteractionDefinition* Interaction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Window", "NotifyOnFastVault");

	Params::Window_NotifyOnFastVault Parms{};

	Parms.Player = Player;
	Parms.Interaction = Interaction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Window.OnFastVault
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractionDefinition*           Interaction                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWindow::OnFastVault(class ADBDPlayer* Player, class UInteractionDefinition* Interaction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Window", "OnFastVault");

	Params::Window_OnFastVault Parms{};

	Parms.Player = Player;
	Parms.Interaction = Interaction;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Window.OnRep_blockedByLevel
// (Final, Native, Private)

void AWindow::OnRep_blockedByLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Window", "OnRep_blockedByLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Window.IsWindowVaultBlockedFor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AWindow::IsWindowVaultBlockedFor(const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Window", "IsWindowVaultBlockedFor");

	Params::Window_IsWindowVaultBlockedFor Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDSRComponent.OnRep_State
// (Final, Native, Private)

void UDBDSRComponent::OnRep_State()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDSRComponent", "OnRep_State");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DisplayStand.BlockRotation
// (Final, Native, Public)
// Parameters:
// bool                                    shouldBlockRotation                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADisplayStand::BlockRotation(bool shouldBlockRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DisplayStand", "BlockRotation");

	Params::DisplayStand_BlockRotation Parms{};

	Parms.shouldBlockRotation = shouldBlockRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DisplayStand.OnCurrentActorDestroyed
// (Final, Native, Private)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADisplayStand::OnCurrentActorDestroyed(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DisplayStand", "OnCurrentActorDestroyed");

	Params::DisplayStand_OnCurrentActorDestroyed Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaTutorialPlayerHudController.HideHudComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHudComponent                           hudComponentToHide                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtlantaTutorialPlayerHudController::HideHudComponent(EHudComponent hudComponentToHide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaTutorialPlayerHudController", "HideHudComponent");

	Params::AtlantaTutorialPlayerHudController_HideHudComponent Parms{};

	Parms.hudComponentToHide = hudComponentToHide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaTutorialPlayerHudController.SetVirtualJoystickInputEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtlantaTutorialPlayerHudController::SetVirtualJoystickInputEnabled(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaTutorialPlayerHudController", "SetVirtualJoystickInputEnabled");

	Params::AtlantaTutorialPlayerHudController_SetVirtualJoystickInputEnabled Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaTutorialPlayerHudController.ShowHudComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHudComponent                           hudComponentToShow                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtlantaTutorialPlayerHudController::ShowHudComponent(EHudComponent hudComponentToShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaTutorialPlayerHudController", "ShowHudComponent");

	Params::AtlantaTutorialPlayerHudController_ShowHudComponent Parms{};

	Parms.hudComponentToShow = hudComponentToShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AttachInteractionComponent.Authority_SetInteractionAttachPoints
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class USceneComponent*>&   interactionsAttachPoints                               (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAttachInteractionComponent::Authority_SetInteractionAttachPoints(const TArray<class USceneComponent*>& interactionsAttachPoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttachInteractionComponent", "Authority_SetInteractionAttachPoints");

	Params::AttachInteractionComponent_Authority_SetInteractionAttachPoints Parms{};

	Parms.interactionsAttachPoints = std::move(interactionsAttachPoints);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AudioFXComponent.Authority_Deafen
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioFXComponent::Authority_Deafen(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioFXComponent", "Authority_Deafen");

	Params::AudioFXComponent_Authority_Deafen Parms{};

	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AudioFXComponent.Multicast_Deafen
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioFXComponent::Multicast_Deafen(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioFXComponent", "Multicast_Deafen");

	Params::AudioFXComponent_Multicast_Deafen Parms{};

	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AudioFXComponent.OnDeafenCompleted
// (Final, Native, Private)

void UAudioFXComponent::OnDeafenCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioFXComponent", "OnDeafenCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AudioFXComponent.OnLocallyObservedChanged
// (Final, Native, Private)
// Parameters:
// bool                                    locallyObserved                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioFXComponent::OnLocallyObservedChanged(bool locallyObserved)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioFXComponent", "OnLocallyObservedChanged");

	Params::AudioFXComponent_OnLocallyObservedChanged Parms{};

	Parms.locallyObserved = locallyObserved;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AudioFXComponent.SetAudioAmbientDetector
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              audioAmbientDetector                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioFXComponent::SetAudioAmbientDetector(class UPrimitiveComponent* audioAmbientDetector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioFXComponent", "SetAudioAmbientDetector");

	Params::AudioFXComponent_SetAudioAmbientDetector Parms{};

	Parms.audioAmbientDetector = audioAmbientDetector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AuthoritativeMovementComponent.OnPawnDetectorOverlapEnter
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAuthoritativeMovementComponent::OnPawnDetectorOverlapEnter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuthoritativeMovementComponent", "OnPawnDetectorOverlapEnter");

	Params::AuthoritativeMovementComponent_OnPawnDetectorOverlapEnter Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AuthoritativeMovementComponent.OnPawnDetectorOverlapExit
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuthoritativeMovementComponent::OnPawnDetectorOverlapExit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuthoritativeMovementComponent", "OnPawnDetectorOverlapExit");

	Params::AuthoritativeMovementComponent_OnPawnDetectorOverlapExit Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AuthoritativeMovementComponent.OnRep_AuthoritativeIgnoreOverlapCharacters
// (Final, Native, Private)

void UAuthoritativeMovementComponent::OnRep_AuthoritativeIgnoreOverlapCharacters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuthoritativeMovementComponent", "OnRep_AuthoritativeIgnoreOverlapCharacters");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AuthoritativeMovementComponent.SetPawnDetector
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCapsuleComponent*                pawnDetector                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuthoritativeMovementComponent::SetPawnDetector(class UCapsuleComponent* pawnDetector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuthoritativeMovementComponent", "SetPawnDetector");

	Params::AuthoritativeMovementComponent_SetPawnDetector Parms{};

	Parms.pawnDetector = pawnDetector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Survivor.ActivateLocalPlayerExposedVFX
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void ASurvivor::ActivateLocalPlayerExposedVFX()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "ActivateLocalPlayerExposedVFX");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Survivor.ActivatePlayerExposedVFX
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void ASurvivor::ActivatePlayerExposedVFX()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "ActivatePlayerExposedVFX");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Survivor.AddBloodDecalToGK_Mori
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ASurvivor::AddBloodDecalToGK_Mori()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "AddBloodDecalToGK_Mori");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Survivor.AddBloodDrippingToGK_Mori
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ASurvivor::AddBloodDrippingToGK_Mori()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "AddBloodDrippingToGK_Mori");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Survivor.AddBloodDropsToLeftHand
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ASurvivor::AddBloodDropsToLeftHand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "AddBloodDropsToLeftHand");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Survivor.AddBloodDropsToRightHand
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ASurvivor::AddBloodDropsToRightHand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "AddBloodDropsToRightHand");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Survivor.Authority_OnSlashed
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Attacker                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASurvivor::Authority_OnSlashed(class ADBDPlayer* Attacker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "Authority_OnSlashed");

	Params::Survivor_Authority_OnSlashed Parms{};

	Parms.Attacker = Attacker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Survivor.DBD_CheatEscaped
// (Final, Exec, Native, Public)

void ASurvivor::DBD_CheatEscaped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "DBD_CheatEscaped");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Survivor.DBD_ForceRun
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    Forced                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASurvivor::DBD_ForceRun(bool Forced)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "DBD_ForceRun");

	Params::Survivor_DBD_ForceRun Parms{};

	Parms.Forced = Forced;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Survivor.DBD_LeaveParadise
// (Final, Exec, Native, Public)

void ASurvivor::DBD_LeaveParadise()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "DBD_LeaveParadise");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Survivor.DBD_SetImmobilized
// (Final, Exec, Native, Public)
// Parameters:
// EImmobilizedState                       State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASurvivor::DBD_SetImmobilized(EImmobilizedState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "DBD_SetImmobilized");

	Params::Survivor_DBD_SetImmobilized Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Survivor.DBD_SetSurvivorCameraArmLength
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   cameraArmLength                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASurvivor::DBD_SetSurvivorCameraArmLength(float cameraArmLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "DBD_SetSurvivorCameraArmLength");

	Params::Survivor_DBD_SetSurvivorCameraArmLength Parms{};

	Parms.cameraArmLength = cameraArmLength;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Survivor.DBD_SetSurvivorCameraArmLengthCommand
// (Final, Exec, Native, Public)
// Parameters:
// float                                   cameraArmLength                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASurvivor::DBD_SetSurvivorCameraArmLengthCommand(float cameraArmLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "DBD_SetSurvivorCameraArmLengthCommand");

	Params::Survivor_DBD_SetSurvivorCameraArmLengthCommand Parms{};

	Parms.cameraArmLength = cameraArmLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Survivor.DecalBlood_Puddles
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ASurvivor::DecalBlood_Puddles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "DecalBlood_Puddles");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Survivor.DoSacrificialDissolve
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ASurvivor::DoSacrificialDissolve()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "DoSacrificialDissolve");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Survivor.EventOnDeath
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ASurvivor::EventOnDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "EventOnDeath");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Survivor.Input_ToggleRun
// (Final, Native, Public, BlueprintCallable)

void ASurvivor::Input_ToggleRun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "Input_ToggleRun");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Survivor.Kill
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHealthType                             healthType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASurvivor::Kill(EHealthType healthType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "Kill");

	Params::Survivor_Kill Parms{};

	Parms.healthType = healthType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Survivor.Local_SetImmobilized
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EImmobilizedState                       State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASurvivor::Local_SetImmobilized(EImmobilizedState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "Local_SetImmobilized");

	Params::Survivor_Local_SetImmobilized Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Survivor.MakeCamperDisappear
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ASurvivor::MakeCamperDisappear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "MakeCamperDisappear");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Survivor.MakeCamperDisappearBleedOut
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ASurvivor::MakeCamperDisappearBleedOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "MakeCamperDisappearBleedOut");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Survivor.Multicast_EscapeItemEvents
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    isItemFromSpawn                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASurvivor::Multicast_EscapeItemEvents(bool isItemFromSpawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "Multicast_EscapeItemEvents");

	Params::Survivor_Multicast_EscapeItemEvents Parms{};

	Parms.isItemFromSpawn = isItemFromSpawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Survivor.Multicast_RemoveReverseBearTrap
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ASurvivor::Multicast_RemoveReverseBearTrap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "Multicast_RemoveReverseBearTrap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Survivor.Multicast_SetAuthoritativeMovementFlag
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// EAuthoritativeMovementFlag              Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASurvivor::Multicast_SetAuthoritativeMovementFlag(EAuthoritativeMovementFlag Flag, bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "Multicast_SetAuthoritativeMovementFlag");

	Params::Survivor_Multicast_SetAuthoritativeMovementFlag Parms{};

	Parms.Flag = Flag;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Survivor.Multicast_SetHookEscapeAutoFail
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASurvivor::Multicast_SetHookEscapeAutoFail(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "Multicast_SetHookEscapeAutoFail");

	Params::Survivor_Multicast_SetHookEscapeAutoFail Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Survivor.Multicast_SetImmobilized
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// EImmobilizedState                       State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASurvivor::Multicast_SetImmobilized(EImmobilizedState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "Multicast_SetImmobilized");

	Params::Survivor_Multicast_SetImmobilized Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Survivor.Multicast_SetOverlappingEscape
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class AActor*                           Escape                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASurvivor::Multicast_SetOverlappingEscape(class AActor* Escape)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "Multicast_SetOverlappingEscape");

	Params::Survivor_Multicast_SetOverlappingEscape Parms{};

	Parms.Escape = Escape;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Survivor.OnDroppedEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    clearLeader                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASurvivor::OnDroppedEnd(bool clearLeader)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "OnDroppedEnd");

	Params::Survivor_OnDroppedEnd Parms{};

	Parms.clearLeader = clearLeader;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Survivor.OnDroppedStart
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       dropper                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASurvivor::OnDroppedStart(class ADBDPlayer* dropper)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "OnDroppedStart");

	Params::Survivor_OnDroppedStart Parms{};

	Parms.dropper = dropper;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Survivor.OnHooked
// (Final, Native, Public, BlueprintCallable)

void ASurvivor::OnHooked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "OnHooked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Survivor.OnHookedStateChangedCosmetic
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    hooked                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASurvivor::OnHookedStateChangedCosmetic(bool hooked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "OnHookedStateChangedCosmetic");

	Params::Survivor_OnHookedStateChangedCosmetic Parms{};

	Parms.hooked = hooked;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Survivor.OnHpSlotSkillCheckResponseAesthetic
// (Final, Native, Public)
// Parameters:
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Bonus                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TriggerLoudNoise                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    hadInput                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ChargeChange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASurvivor::OnHpSlotSkillCheckResponseAesthetic(bool Success, bool Bonus, class ADBDPlayer* Player, bool TriggerLoudNoise, bool hadInput, ESkillCheckCustomType Type, float ChargeChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "OnHpSlotSkillCheckResponseAesthetic");

	Params::Survivor_OnHpSlotSkillCheckResponseAesthetic Parms{};

	Parms.Success = Success;
	Parms.Bonus = Bonus;
	Parms.Player = Player;
	Parms.TriggerLoudNoise = TriggerLoudNoise;
	Parms.hadInput = hadInput;
	Parms.Type = Type;
	Parms.ChargeChange = ChargeChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Survivor.OnObsessionChanged
// (Final, Native, Public)
// Parameters:
// class ASurvivor*                        newObsession                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASurvivor*                        previousObsession                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASurvivor::OnObsessionChanged(class ASurvivor* newObsession, class ASurvivor* previousObsession)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "OnObsessionChanged");

	Params::Survivor_OnObsessionChanged Parms{};

	Parms.newObsession = newObsession;
	Parms.previousObsession = previousObsession;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Survivor.OnPawnSensed
// (Final, Native, Private)
// Parameters:
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASurvivor::OnPawnSensed(class APawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "OnPawnSensed");

	Params::Survivor_OnPawnSensed Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Survivor.OnProximityEntered
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ASurvivor::OnProximityEntered(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "OnProximityEntered");

	Params::Survivor_OnProximityEntered Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Survivor.OnRep_RunInputPressed
// (Final, Native, Private)

void ASurvivor::OnRep_RunInputPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "OnRep_RunInputPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Survivor.OnRep_SprintEffect
// (Final, Native, Private)

void ASurvivor::OnRep_SprintEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "OnRep_SprintEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Survivor.RemoveReverseBearTrap
// (Event, Public, BlueprintEvent)

void ASurvivor::RemoveReverseBearTrap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "RemoveReverseBearTrap");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Survivor.ResetCameraAttach
// (Final, Native, Public, BlueprintCallable)

void ASurvivor::ResetCameraAttach()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "ResetCameraAttach");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Survivor.Server_SetOverlappingEscape
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class AActor*                           Escape                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASurvivor::Server_SetOverlappingEscape(class AActor* Escape)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "Server_SetOverlappingEscape");

	Params::Survivor_Server_SetOverlappingEscape Parms{};

	Parms.Escape = Escape;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Survivor.Server_SetRunInput
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// bool                                    Pressed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASurvivor::Server_SetRunInput(bool Pressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "Server_SetRunInput");

	Params::Survivor_Server_SetRunInput Parms{};

	Parms.Pressed = Pressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Survivor.SetPlayerExposedVFX
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void ASurvivor::SetPlayerExposedVFX()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "SetPlayerExposedVFX");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Survivor.SetVignetteVisible
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    Visible                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASurvivor::SetVignetteVisible(bool Visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "SetVignetteVisible");

	Params::Survivor_SetVignetteVisible Parms{};

	Parms.Visible = Visible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Survivor.SurvivorDissolve
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    shouldDissolve                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   timeToDissolve                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASurvivor::SurvivorDissolve(bool shouldDissolve, float timeToDissolve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "SurvivorDissolve");

	Params::Survivor_SurvivorDissolve Parms{};

	Parms.shouldDissolve = shouldDissolve;
	Parms.timeToDissolve = timeToDissolve;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Survivor.TriggerAfflictionHUDFeedback
// (Final, Native, Public, BlueprintCallable)

void ASurvivor::TriggerAfflictionHUDFeedback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "TriggerAfflictionHUDFeedback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Survivor.AcceptsHealing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASurvivor::AcceptsHealing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "AcceptsHealing");

	Params::Survivor_AcceptsHealing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.CanBePickedUp
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASurvivor::CanBePickedUp() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "CanBePickedUp");

	Params::Survivor_CanBePickedUp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.CanRushQuietly
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASurvivor::CanRushQuietly() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "CanRushQuietly");

	Params::Survivor_CanRushQuietly Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.GetAllEntityRenderRegions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UDBDClipRegionComponent*>  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UDBDClipRegionComponent*> ASurvivor::GetAllEntityRenderRegions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "GetAllEntityRenderRegions");

	Params::Survivor_GetAllEntityRenderRegions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.GetAntiCampSelfUnhookComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAntiCampSelfUnhookComponent*     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAntiCampSelfUnhookComponent* ASurvivor::GetAntiCampSelfUnhookComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "GetAntiCampSelfUnhookComponent");

	Params::Survivor_GetAntiCampSelfUnhookComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.GetBloodTrailComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USurvivorBloodTrailComponent*     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USurvivorBloodTrailComponent* ASurvivor::GetBloodTrailComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "GetBloodTrailComponent");

	Params::Survivor_GetBloodTrailComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.GetChaseeCharacterComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UChaseeCharacterComponent*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChaseeCharacterComponent* ASurvivor::GetChaseeCharacterComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "GetChaseeCharacterComponent");

	Params::Survivor_GetChaseeCharacterComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.GetGuidedAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGuidedState                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGuidedState ASurvivor::GetGuidedAction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "GetGuidedAction");

	Params::Survivor_GetGuidedAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.GetHealthComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UHealthComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UHealthComponent* ASurvivor::GetHealthComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "GetHealthComponent");

	Params::Survivor_GetHealthComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.GetHookableComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UHookableComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UHookableComponent* ASurvivor::GetHookableComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "GetHookableComponent");

	Params::Survivor_GetHookableComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.GetImmobilizedState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EImmobilizedState                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EImmobilizedState ASurvivor::GetImmobilizedState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "GetImmobilizedState");

	Params::Survivor_GetImmobilizedState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.GetMontageFollower
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimationMontageSlave*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimationMontageSlave* ASurvivor::GetMontageFollower() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "GetMontageFollower");

	Params::Survivor_GetMontageFollower Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.GetNoOcclusionAudioComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAkComponent*                     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAkComponent* ASurvivor::GetNoOcclusionAudioComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "GetNoOcclusionAudioComponent");

	Params::Survivor_GetNoOcclusionAudioComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.GetReverseBearTrap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AReverseBearTrap*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AReverseBearTrap* ASurvivor::GetReverseBearTrap() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "GetReverseBearTrap");

	Params::Survivor_GetReverseBearTrap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.GetWiggleChargeable
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UChargeableComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChargeableComponent* ASurvivor::GetWiggleChargeable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "GetWiggleChargeable");

	Params::Survivor_GetWiggleChargeable Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.HasGuidedAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASurvivor::HasGuidedAction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "HasGuidedAction");

	Params::Survivor_HasGuidedAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.HasReverseBearTrap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASurvivor::HasReverseBearTrap() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "HasReverseBearTrap");

	Params::Survivor_HasReverseBearTrap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.IsBeingCarried
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASurvivor::IsBeingCarried() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "IsBeingCarried");

	Params::Survivor_IsBeingCarried Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.IsBeingHealed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASurvivor::IsBeingHealed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "IsBeingHealed");

	Params::Survivor_IsBeingHealed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.IsBeingInteractedWith
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASurvivor::IsBeingInteractedWith() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "IsBeingInteractedWith");

	Params::Survivor_IsBeingInteractedWith Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.IsBeingMended
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASurvivor::IsBeingMended() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "IsBeingMended");

	Params::Survivor_IsBeingMended Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.IsBeingPickedUp
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASurvivor::IsBeingPickedUp() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "IsBeingPickedUp");

	Params::Survivor_IsBeingPickedUp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.IsBeingPutDown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASurvivor::IsBeingPutDown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "IsBeingPutDown");

	Params::Survivor_IsBeingPutDown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.IsBeingPutOnHook
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASurvivor::IsBeingPutOnHook() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "IsBeingPutOnHook");

	Params::Survivor_IsBeingPutOnHook Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.IsBeingUnhooked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASurvivor::IsBeingUnhooked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "IsBeingUnhooked");

	Params::Survivor_IsBeingUnhooked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.IsCrawling
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASurvivor::IsCrawling() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "IsCrawling");

	Params::Survivor_IsCrawling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.IsDeadOrInParadise
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASurvivor::IsDeadOrInParadise() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "IsDeadOrInParadise");

	Params::Survivor_IsDeadOrInParadise Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.IsEscaped
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASurvivor::IsEscaped() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "IsEscaped");

	Params::Survivor_IsEscaped Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.IsGuidedBySlasher
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASurvivor::IsGuidedBySlasher() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "IsGuidedBySlasher");

	Params::Survivor_IsGuidedBySlasher Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.IsHooked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASurvivor::IsHooked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "IsHooked");

	Params::Survivor_IsHooked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.IsInDeathBed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASurvivor::IsInDeathBed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "IsInDeathBed");

	Params::Survivor_IsInDeathBed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.IsObsessionTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASurvivor::IsObsessionTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "IsObsessionTarget");

	Params::Survivor_IsObsessionTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.IsTrapped
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASurvivor::IsTrapped() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "IsTrapped");

	Params::Survivor_IsTrapped Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.IsVaulting
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASurvivor::IsVaulting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "IsVaulting");

	Params::Survivor_IsVaulting Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.IsWalking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASurvivor::IsWalking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "IsWalking");

	Params::Survivor_IsWalking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Survivor.NotifySurvivorDissolveFinished
// (Final, Native, Protected, BlueprintCallable, Const)
// Parameters:
// bool                                    isDissolved                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASurvivor::NotifySurvivorDissolveFinished(bool isDissolved) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Survivor", "NotifySurvivorDissolveFinished");

	Params::Survivor_NotifySurvivorDissolveFinished Parms{};

	Parms.isDissolved = isDissolved;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BaseEscapeThroughHatch.GetHatch
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AHatch*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AHatch* UBaseEscapeThroughHatch::GetHatch() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseEscapeThroughHatch", "GetHatch");

	Params::BaseEscapeThroughHatch_GetHatch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.BaseGenerator.Authority_CancelRepairInteractions
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class ADBDPlayer*>&        repairers                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void IBaseGenerator::Authority_CancelRepairInteractions(const TArray<class ADBDPlayer*>& repairers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BaseGenerator", "Authority_CancelRepairInteractions");

	Params::BaseGenerator_Authority_CancelRepairInteractions Parms{};

	Parms.repairers = std::move(repairers);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BaseGenerator.SetFireLevelScoreEventOnFix
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    FireLevelScoreEventOnFix                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IBaseGenerator::SetFireLevelScoreEventOnFix(bool FireLevelScoreEventOnFix)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BaseGenerator", "SetFireLevelScoreEventOnFix");

	Params::BaseGenerator_SetFireLevelScoreEventOnFix Parms{};

	Parms.FireLevelScoreEventOnFix = FireLevelScoreEventOnFix;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BaseGenerator.GetChargePercentOnLastUpdate
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IBaseGenerator::GetChargePercentOnLastUpdate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BaseGenerator", "GetChargePercentOnLastUpdate");

	Params::BaseGenerator_GetChargePercentOnLastUpdate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.BaseGenerator.GetGeneratorDamageComponent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UGeneratorDamageComponent*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGeneratorDamageComponent* IBaseGenerator::GetGeneratorDamageComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BaseGenerator", "GetGeneratorDamageComponent");

	Params::BaseGenerator_GetGeneratorDamageComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.BaseGenerator.GetRepairers
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ADBDPlayer*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ADBDPlayer*> IBaseGenerator::GetRepairers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BaseGenerator", "GetRepairers");

	Params::BaseGenerator_GetRepairers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.BaseGenerator.IsActivated
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IBaseGenerator::IsActivated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BaseGenerator", "IsActivated");

	Params::BaseGenerator_IsActivated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.BaseGenerator.IsBeingRepaired
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IBaseGenerator::IsBeingRepaired() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BaseGenerator", "IsBeingRepaired");

	Params::BaseGenerator_IsBeingRepaired Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.BaseGenerator.IsBlocked
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IBaseGenerator::IsBlocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BaseGenerator", "IsBlocked");

	Params::BaseGenerator_IsBlocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.BaseGenerator.IsRepaired
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IBaseGenerator::IsRepaired() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BaseGenerator", "IsRepaired");

	Params::BaseGenerator_IsRepaired Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.BaseLinkedVomitProjectile.NativeExplode
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FImpactInfo&               ImpactInfo                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ABaseLinkedVomitProjectile::NativeExplode(const struct FImpactInfo& ImpactInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseLinkedVomitProjectile", "NativeExplode");

	Params::BaseLinkedVomitProjectile_NativeExplode Parms{};

	Parms.ImpactInfo = std::move(ImpactInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BaseLinkedVomitProjectile.OnAffectInteractable
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class AInteractable*                    Interactable                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseLinkedVomitProjectile::OnAffectInteractable(class AInteractable* Interactable, class USceneComponent* HitComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseLinkedVomitProjectile", "OnAffectInteractable");

	Params::BaseLinkedVomitProjectile_OnAffectInteractable Parms{};

	Parms.Interactable = Interactable;
	Parms.HitComponent = HitComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BaseLinkedVomitProjectile.OnAffectSurvivor
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseLinkedVomitProjectile::OnAffectSurvivor(class ASurvivor* Survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseLinkedVomitProjectile", "OnAffectSurvivor");

	Params::BaseLinkedVomitProjectile_OnAffectSurvivor Parms{};

	Parms.Survivor = Survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BehaviourDetectionComponent_Inactivity.OnExitGatesActivated
// (Final, Native, Protected)

void UBehaviourDetectionComponent_Inactivity::OnExitGatesActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BehaviourDetectionComponent_Inactivity", "OnExitGatesActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EnduranceVFXComponent.ShowHighlight
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UGameplayModifierContainer*       preventKOSource                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnduranceVFXComponent::ShowHighlight(class UGameplayModifierContainer* preventKOSource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnduranceVFXComponent", "ShowHighlight");

	Params::EnduranceVFXComponent_ShowHighlight Parms{};

	Parms.preventKOSource = preventKOSource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PurpleGlyphBloodTrailComponent.DeactivateGlyphBloodTrail
// (Final, Native, Public, BlueprintCallable)

void UPurpleGlyphBloodTrailComponent::DeactivateGlyphBloodTrail()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PurpleGlyphBloodTrailComponent", "DeactivateGlyphBloodTrail");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Bloodlust.DBD_SetBloodlust
// (Final, Exec, Native, Public)
// Parameters:
// const int32                             Amount                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              enableDecay                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBloodlust::DBD_SetBloodlust(const int32 Amount, const bool enableDecay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Bloodlust", "DBD_SetBloodlust");

	Params::Bloodlust_DBD_SetBloodlust Parms{};

	Parms.Amount = Amount;
	Parms.enableDecay = enableDecay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Bloodlust.OnAllChaseEndedEvent
// (Final, Native, Private)

void UBloodlust::OnAllChaseEndedEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Bloodlust", "OnAllChaseEndedEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Bloodlust.OnChaseStartedEvent
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       chasedPlayer                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBloodlust::OnChaseStartedEvent(class ADBDPlayer* chasedPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Bloodlust", "OnChaseStartedEvent");

	Params::Bloodlust_OnChaseStartedEvent Parms{};

	Parms.chasedPlayer = chasedPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Bloodlust.OnRep_BloodlustTime
// (Final, Native, Private)
// Parameters:
// float                                   oldBloodlustTime                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBloodlust::OnRep_BloodlustTime(float oldBloodlustTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Bloodlust", "OnRep_BloodlustTime");

	Params::Bloodlust_OnRep_BloodlustTime Parms{};

	Parms.oldBloodlustTime = oldBloodlustTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Bloodlust.GetBloodlustTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBloodlust::GetBloodlustTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Bloodlust", "GetBloodlustTime");

	Params::Bloodlust_GetBloodlustTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.FeatureGateHelper.GetAll
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    contextObject                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FDBDFeatureLockProgress>* outData                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFeatureGateHelper::GetAll(const class UObject* contextObject, TArray<struct FDBDFeatureLockProgress>* outData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FeatureGateHelper", "GetAll");

	Params::FeatureGateHelper_GetAll Parms{};

	Parms.contextObject = contextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outData != nullptr)
		*outData = std::move(Parms.outData);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.FeatureGateHelper.GetAllByLockState
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    contextObject                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FDBDFeatureLockProgress>* outData                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    Locked                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFeatureGateHelper::GetAllByLockState(const class UObject* contextObject, TArray<struct FDBDFeatureLockProgress>* outData, bool Locked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FeatureGateHelper", "GetAllByLockState");

	Params::FeatureGateHelper_GetAllByLockState Parms{};

	Parms.contextObject = contextObject;
	Parms.Locked = Locked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outData != nullptr)
		*outData = std::move(Parms.outData);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.FeatureGateHelper.GetAllByRole
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    contextObject                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FDBDFeatureLockProgress>* outData                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// EPlayerRole                             Role                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFeatureGateHelper::GetAllByRole(const class UObject* contextObject, TArray<struct FDBDFeatureLockProgress>* outData, EPlayerRole Role)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FeatureGateHelper", "GetAllByRole");

	Params::FeatureGateHelper_GetAllByRole Parms{};

	Parms.contextObject = contextObject;
	Parms.Role = Role;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outData != nullptr)
		*outData = std::move(Parms.outData);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.FeatureGateHelper.GetAllBySeenState
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    contextObject                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FDBDFeatureLockProgress>* outData                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    WasSeen_0                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFeatureGateHelper::GetAllBySeenState(const class UObject* contextObject, TArray<struct FDBDFeatureLockProgress>* outData, bool WasSeen_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FeatureGateHelper", "GetAllBySeenState");

	Params::FeatureGateHelper_GetAllBySeenState Parms{};

	Parms.contextObject = contextObject;
	Parms.WasSeen_0 = WasSeen_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outData != nullptr)
		*outData = std::move(Parms.outData);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.FeatureGateHelper.GetSingle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    contextObject                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDBDFeatureLockProgress*         outData                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDBDFeatureType                         featureType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerRole                             Role                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFeatureGateHelper::GetSingle(const class UObject* contextObject, struct FDBDFeatureLockProgress* outData, EDBDFeatureType featureType, EPlayerRole Role)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FeatureGateHelper", "GetSingle");

	Params::FeatureGateHelper_GetSingle Parms{};

	Parms.contextObject = contextObject;
	Parms.featureType = featureType;
	Parms.Role = Role;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outData != nullptr)
		*outData = std::move(Parms.outData);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.FeatureGateHelper.IsEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    contextObject                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFeatureGateHelper::IsEnabled(const class UObject* contextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FeatureGateHelper", "IsEnabled");

	Params::FeatureGateHelper_IsEnabled Parms{};

	Parms.contextObject = contextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.FeatureGateHelper.IsLocked
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    contextObject                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDBDFeatureType                         featureType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerRole                             Role                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFeatureGateHelper::IsLocked(const class UObject* contextObject, EDBDFeatureType featureType, EPlayerRole Role)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FeatureGateHelper", "IsLocked");

	Params::FeatureGateHelper_IsLocked Parms{};

	Parms.contextObject = contextObject;
	Parms.featureType = featureType;
	Parms.Role = Role;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.FeatureGateHelper.WasSeen
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    contextObject                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDBDFeatureType                         featureType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerRole                             Role                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFeatureGateHelper::WasSeen(const class UObject* contextObject, EDBDFeatureType featureType, EPlayerRole Role)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FeatureGateHelper", "WasSeen");

	Params::FeatureGateHelper_WasSeen Parms{};

	Parms.contextObject = contextObject;
	Parms.featureType = featureType;
	Parms.Role = Role;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGHudEditorVersionWidget.Hide
// (Final, Native, Public, BlueprintCallable)

void UUMGHudEditorVersionWidget::Hide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorVersionWidget", "Hide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGHudEditorVersionWidget.OnButtonClick
// (Final, Native, Protected, BlueprintCallable)

void UUMGHudEditorVersionWidget::OnButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorVersionWidget", "OnButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGHudEditorVersionWidget.Show
// (Final, Native, Public, BlueprintCallable)

void UUMGHudEditorVersionWidget::Show()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorVersionWidget", "Show");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.ForceCloseGame
// (Final, Native, Static, Public)

void UDBDGameInstance::ForceCloseGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDGameInstance", "ForceCloseGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.AddActorKnowledgeCollection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UActorKnowledgeCollection*        Collection                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::AddActorKnowledgeCollection(class UActorKnowledgeCollection* Collection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "AddActorKnowledgeCollection");

	Params::DBDGameInstance_AddActorKnowledgeCollection Parms{};

	Parms.Collection = Collection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.Authority_SimulatePerks
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class FName>&              Perks                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::Authority_SimulatePerks(const TArray<class FName>& Perks, int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "Authority_SimulatePerks");

	Params::DBDGameInstance_Authority_SimulatePerks Parms{};

	Parms.Perks = std::move(Perks);
	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.BeginLoadingScreen
// (Final, Native, Public)
// Parameters:
// const class FString&                    MapName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::BeginLoadingScreen(const class FString& MapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "BeginLoadingScreen");

	Params::DBDGameInstance_BeginLoadingScreen Parms{};

	Parms.MapName = std::move(MapName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_ApplyMist
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// const float                             fogModifier                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::DBD_ApplyMist(const float fogModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_ApplyMist");

	Params::DBDGameInstance_DBD_ApplyMist Parms{};

	Parms.fogModifier = fogModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_ApplyNoMist
// (Final, Exec, Native, Public, BlueprintCallable)

void UDBDGameInstance::DBD_ApplyNoMist()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_ApplyNoMist");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_ChangeSteamOverlayPosition
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   VerticalOffset                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   HorizontalOffset                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::DBD_ChangeSteamOverlayPosition(int32 Position, int32 VerticalOffset, int32 HorizontalOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_ChangeSteamOverlayPosition");

	Params::DBDGameInstance_DBD_ChangeSteamOverlayPosition Parms{};

	Parms.Position = Position;
	Parms.VerticalOffset = VerticalOffset;
	Parms.HorizontalOffset = HorizontalOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_DeleteLocalSaveFile
// (Final, Exec, Native, Public, BlueprintCallable)

void UDBDGameInstance::DBD_DeleteLocalSaveFile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_DeleteLocalSaveFile");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_DestroySteamInventory
// (Final, Exec, Native, Public)

void UDBDGameInstance::DBD_DestroySteamInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_DestroySteamInventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_DisplayCurrentAchievementStat
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             StatName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::DBD_DisplayCurrentAchievementStat(class FName StatName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_DisplayCurrentAchievementStat");

	Params::DBDGameInstance_DBD_DisplayCurrentAchievementStat Parms{};

	Parms.StatName = StatName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_DumpSessions
// (Final, Exec, Native, Public, BlueprintCallable)

void UDBDGameInstance::DBD_DumpSessions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_DumpSessions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_ForceLoad
// (Final, Exec, Native, Public, BlueprintCallable)

void UDBDGameInstance::DBD_ForceLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_ForceLoad");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_ForceSave
// (Final, Exec, Native, Public, BlueprintCallable)

void UDBDGameInstance::DBD_ForceSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_ForceSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_GetRegion
// (Final, Exec, Native, Public)

void UDBDGameInstance::DBD_GetRegion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_GetRegion");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_PIXBeginCapture
// (Final, Exec, Native, Public)

void UDBDGameInstance::DBD_PIXBeginCapture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_PIXBeginCapture");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_PIXEndCapture
// (Final, Exec, Native, Public)

void UDBDGameInstance::DBD_PIXEndCapture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_PIXEndCapture");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_ResetCurrentAchievementStat
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             StatName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    andUpload                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::DBD_ResetCurrentAchievementStat(class FName StatName, bool andUpload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_ResetCurrentAchievementStat");

	Params::DBDGameInstance_DBD_ResetCurrentAchievementStat Parms{};

	Parms.StatName = StatName;
	Parms.andUpload = andUpload;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_ResetCurrentAchievementStats
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    andUpload                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    andUpdateData                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::DBD_ResetCurrentAchievementStats(bool andUpload, bool andUpdateData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_ResetCurrentAchievementStats");

	Params::DBDGameInstance_DBD_ResetCurrentAchievementStats Parms{};

	Parms.andUpload = andUpload;
	Parms.andUpdateData = andUpdateData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_ResetSaveData
// (Final, Exec, Native, Public, BlueprintCallable)

void UDBDGameInstance::DBD_ResetSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_ResetSaveData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_SetFearMarketDate
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    dateString                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::DBD_SetFearMarketDate(const class FString& dateString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_SetFearMarketDate");

	Params::DBDGameInstance_DBD_SetFearMarketDate Parms{};

	Parms.dateString = std::move(dateString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_SetStatsUploadEnabled
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::DBD_SetStatsUploadEnabled(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_SetStatsUploadEnabled");

	Params::DBDGameInstance_DBD_SetStatsUploadEnabled Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_TestDiceRoll
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   BaseProbability                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MultiplicativeModifier                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AdditiveModifier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::DBD_TestDiceRoll(float BaseProbability, float MultiplicativeModifier, float AdditiveModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_TestDiceRoll");

	Params::DBDGameInstance_DBD_TestDiceRoll Parms{};

	Parms.BaseProbability = BaseProbability;
	Parms.MultiplicativeModifier = MultiplicativeModifier;
	Parms.AdditiveModifier = AdditiveModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_TestRegion
// (Final, Exec, Native, Public)

void UDBDGameInstance::DBD_TestRegion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_TestRegion");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_TestSaveFile
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::DBD_TestSaveFile(const class FString& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_TestSaveFile");

	Params::DBDGameInstance_DBD_TestSaveFile Parms{};

	Parms.Name_0 = std::move(Name_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_TestTickedDiceRoll
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   BaseProbability                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ticks                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MultiplicativeModifier                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AdditiveModifier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::DBD_TestTickedDiceRoll(float BaseProbability, float ticks, float MultiplicativeModifier, float AdditiveModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_TestTickedDiceRoll");

	Params::DBDGameInstance_DBD_TestTickedDiceRoll Parms{};

	Parms.BaseProbability = BaseProbability;
	Parms.ticks = ticks;
	Parms.MultiplicativeModifier = MultiplicativeModifier;
	Parms.AdditiveModifier = AdditiveModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_ToggleLightingLoaded
// (Final, Exec, Native, Public, BlueprintCallable)

void UDBDGameInstance::DBD_ToggleLightingLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_ToggleLightingLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_UpdateSteamInventory
// (Final, Exec, Native, Public, BlueprintCallable)

void UDBDGameInstance::DBD_UpdateSteamInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_UpdateSteamInventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.EndLoadingScreen
// (Final, Native, Public)
// Parameters:
// class UWorld*                           loadedWorld                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::EndLoadingScreen(class UWorld* loadedWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "EndLoadingScreen");

	Params::DBDGameInstance_EndLoadingScreen Parms{};

	Parms.loadedWorld = loadedWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.GetLevelLighting
// (Final, Native, Public)
// Parameters:
// class ABaseSky*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABaseSky* UDBDGameInstance::GetLevelLighting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetLevelLighting");

	Params::DBDGameInstance_GetLevelLighting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetLightingHelper
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULightingHelper*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULightingHelper* UDBDGameInstance::GetLightingHelper()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetLightingHelper");

	Params::DBDGameInstance_GetLightingHelper Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetLightInterpolator
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULightingInterpolator*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULightingInterpolator* UDBDGameInstance::GetLightInterpolator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetLightInterpolator");

	Params::DBDGameInstance_GetLightInterpolator Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GotoSplashScreen
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    showDefaultDialogueOnSplashScreen                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::GotoSplashScreen(bool showDefaultDialogueOnSplashScreen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GotoSplashScreen");

	Params::DBDGameInstance_GotoSplashScreen Parms{};

	Parms.showDefaultDialogueOnSplashScreen = showDefaultDialogueOnSplashScreen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.RemoveActorKnowledgeCollection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UActorKnowledgeCollection*        Collection                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::RemoveActorKnowledgeCollection(class UActorKnowledgeCollection* Collection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "RemoveActorKnowledgeCollection");

	Params::DBDGameInstance_RemoveActorKnowledgeCollection Parms{};

	Parms.Collection = Collection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.SimulateOfferingSequence
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class FName>&              offerings                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    PlaySequence                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::SimulateOfferingSequence(const TArray<class FName>& offerings, bool PlaySequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "SimulateOfferingSequence");

	Params::DBDGameInstance_SimulateOfferingSequence Parms{};

	Parms.offerings = std::move(offerings);
	Parms.PlaySequence = PlaySequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.StartOfferingSequence
// (Final, Native, Public)

void UDBDGameInstance::StartOfferingSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "StartOfferingSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_PrintAudioConfig
// (Final, Exec, Native, Public, BlueprintCallable, Const)

void UDBDGameInstance::DBD_PrintAudioConfig() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_PrintAudioConfig");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.GetBonusPointEventsManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBonusPointEventsManager*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBonusPointEventsManager* UDBDGameInstance::GetBonusPointEventsManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetBonusPointEventsManager");

	Params::DBDGameInstance_GetBonusPointEventsManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetCharacterClippingPrimitiveCollection
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPrimitiveCollection*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveCollection* UDBDGameInstance::GetCharacterClippingPrimitiveCollection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetCharacterClippingPrimitiveCollection");

	Params::DBDGameInstance_GetCharacterClippingPrimitiveCollection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetCharacterDefaultItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   inCharacterIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UDBDGameInstance::GetCharacterDefaultItem(int32 inCharacterIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetCharacterDefaultItem");

	Params::DBDGameInstance_GetCharacterDefaultItem Parms{};

	Parms.inCharacterIndex = inCharacterIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetCinematicManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCinematicManager*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCinematicManager* UDBDGameInstance::GetCinematicManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetCinematicManager");

	Params::DBDGameInstance_GetCinematicManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetConsentManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UConsentManager*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UConsentManager* UDBDGameInstance::GetConsentManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetConsentManager");

	Params::DBDGameInstance_GetConsentManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetDeadOrDisconnectedCampersCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayerState*                  exception                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDBDGameInstance::GetDeadOrDisconnectedCampersCount(class ADBDPlayerState* exception) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetDeadOrDisconnectedCampersCount");

	Params::DBDGameInstance_GetDeadOrDisconnectedCampersCount Parms{};

	Parms.exception = exception;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetDecalSpawnerCollection
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDecalSpawnerCollection*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDecalSpawnerCollection* UDBDGameInstance::GetDecalSpawnerCollection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetDecalSpawnerCollection");

	Params::DBDGameInstance_GetDecalSpawnerCollection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetDedicatedServerManager
// (Final, Native, Public, Const)
// Parameters:
// class UDedicatedServerManager*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDedicatedServerManager* UDBDGameInstance::GetDedicatedServerManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetDedicatedServerManager");

	Params::DBDGameInstance_GetDedicatedServerManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetInventoryHandler
// (Final, Native, Public, Const)
// Parameters:
// class UInventoryHandler*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInventoryHandler* UDBDGameInstance::GetInventoryHandler() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetInventoryHandler");

	Params::DBDGameInstance_GetInventoryHandler Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetLocalEventManager
// (Final, Native, Public, Const)
// Parameters:
// class ULocalEventManager*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULocalEventManager* UDBDGameInstance::GetLocalEventManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetLocalEventManager");

	Params::DBDGameInstance_GetLocalEventManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetLocallyControlledCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UDBDGameInstance::GetLocallyControlledCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetLocallyControlledCharacter");

	Params::DBDGameInstance_GetLocallyControlledCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetLocalPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULocalPlayer*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULocalPlayer* UDBDGameInstance::GetLocalPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetLocalPlayer");

	Params::DBDGameInstance_GetLocalPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetLocalPlayerController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APlayerController*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerController* UDBDGameInstance::GetLocalPlayerController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetLocalPlayerController");

	Params::DBDGameInstance_GetLocalPlayerController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetMapActorDB
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMapActorDB*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMapActorDB* UDBDGameInstance::GetMapActorDB() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetMapActorDB");

	Params::DBDGameInstance_GetMapActorDB Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetMaxSurvivorCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDBDGameInstance::GetMaxSurvivorCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetMaxSurvivorCount");

	Params::DBDGameInstance_GetMaxSurvivorCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetPlayerLevelManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDBDPlayerLevelManager*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDBDPlayerLevelManager* UDBDGameInstance::GetPlayerLevelManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetPlayerLevelManager");

	Params::DBDGameInstance_GetPlayerLevelManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetPlayerNameRegistration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPlayerNameRegistration*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlayerNameRegistration* UDBDGameInstance::GetPlayerNameRegistration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetPlayerNameRegistration");

	Params::DBDGameInstance_GetPlayerNameRegistration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetRankManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URankManager*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URankManager* UDBDGameInstance::GetRankManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetRankManager");

	Params::DBDGameInstance_GetRankManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetSoftBanManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USoftBanManager*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USoftBanManager* UDBDGameInstance::GetSoftBanManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetSoftBanManager");

	Params::DBDGameInstance_GetSoftBanManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetSpecialEventManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class Uspecialeventmanager*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class Uspecialeventmanager* UDBDGameInstance::GetSpecialEventManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetSpecialEventManager");

	Params::DBDGameInstance_GetSpecialEventManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetTimeUtils
// (Final, Native, Public, Const)
// Parameters:
// class UDBDTimeUtilities*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDBDTimeUtilities* UDBDGameInstance::GetTimeUtils() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetTimeUtils");

	Params::DBDGameInstance_GetTimeUtils Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.HasOfferingByType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOfferingEffectType                     Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDGameInstance::HasOfferingByType(EOfferingEffectType Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "HasOfferingByType");

	Params::DBDGameInstance_HasOfferingByType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.HasOfferingOfType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOfferingEffectType                     Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDGameInstance::HasOfferingOfType(EOfferingEffectType Type, int32 PlayerId, class FName Tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "HasOfferingOfType");

	Params::DBDGameInstance_HasOfferingOfType Parms{};

	Parms.Type = Type;
	Parms.PlayerId = PlayerId;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.IsActorKnown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 knowledgePossessor                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           possiblyKnownActor                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDGameInstance::IsActorKnown(const class ADBDPlayer* knowledgePossessor, class AActor* possiblyKnownActor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "IsActorKnown");

	Params::DBDGameInstance_IsActorKnown Parms{};

	Parms.knowledgePossessor = knowledgePossessor;
	Parms.possiblyKnownActor = possiblyKnownActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.OnTimeTravelComplete
// (Final, Native, Public, Const)
// Parameters:
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Date                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::OnTimeTravelComplete(bool Success, const class FString& Date) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "OnTimeTravelComplete");

	Params::DBDGameInstance_OnTimeTravelComplete Parms{};

	Parms.Success = Success;
	Parms.Date = std::move(Date);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StalkedComponent.OnRep_IsBeingStalked
// (Final, Native, Private)

void UStalkedComponent::OnRep_IsBeingStalked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StalkedComponent", "OnRep_IsBeingStalked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StalkedComponent.OnRep_MaxStalkPoints
// (Final, Native, Private)

void UStalkedComponent::OnRep_MaxStalkPoints()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StalkedComponent", "OnRep_MaxStalkPoints");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StalkedComponent.HasStalkPoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStalkedComponent::HasStalkPoints() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StalkedComponent", "HasStalkPoints");

	Params::StalkedComponent_HasStalkPoints Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.RecoverInteractableDefinition.IsKillerInteracting
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URecoverInteractableDefinition::IsKillerInteracting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RecoverInteractableDefinition", "IsKillerInteracting");

	Params::RecoverInteractableDefinition_IsKillerInteracting Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EscapeDoor.Cosmetic_OnGateDechargeBegin
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void AEscapeDoor::Cosmetic_OnGateDechargeBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "Cosmetic_OnGateDechargeBegin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.EscapeDoor.Cosmetic_OnGateDechargeEnd
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void AEscapeDoor::Cosmetic_OnGateDechargeEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "Cosmetic_OnGateDechargeEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.EscapeDoor.Cosmetic_OnSpectatedPlayerChanged
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    isCurrentlyDecharging                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isSurvivor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEscapeDoor::Cosmetic_OnSpectatedPlayerChanged(bool isCurrentlyDecharging, bool isSurvivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "Cosmetic_OnSpectatedPlayerChanged");

	Params::EscapeDoor_Cosmetic_OnSpectatedPlayerChanged Parms{};

	Parms.isCurrentlyDecharging = isCurrentlyDecharging;
	Parms.isSurvivor = isSurvivor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.EscapeDoor.GetOpenEscapeInteraction
// (Event, Public, BlueprintEvent)
// Parameters:
// class UChargeableInteractionDefinition* ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChargeableInteractionDefinition* AEscapeDoor::GetOpenEscapeInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "GetOpenEscapeInteraction");

	Params::EscapeDoor_GetOpenEscapeInteraction Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EscapeDoor.LightAllLights
// (BlueprintCosmetic, Event, Public, BlueprintCallable, BlueprintEvent)

void AEscapeDoor::LightAllLights()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "LightAllLights");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.EscapeDoor.OnBlockDoorSwitchCosmetic
// (Event, Protected, BlueprintEvent)

void AEscapeDoor::OnBlockDoorSwitchCosmetic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "OnBlockDoorSwitchCosmetic");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.EscapeDoor.OnEscapeZoneBeginOverlap
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           overlappingActor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEscapeDoor::OnEscapeZoneBeginOverlap(class AActor* overlappingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "OnEscapeZoneBeginOverlap");

	Params::EscapeDoor_OnEscapeZoneBeginOverlap Parms{};

	Parms.overlappingActor = overlappingActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EscapeDoor.OnEscapeZoneEndOverlap
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           overlappingActor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEscapeDoor::OnEscapeZoneEndOverlap(class AActor* overlappingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "OnEscapeZoneEndOverlap");

	Params::EscapeDoor_OnEscapeZoneEndOverlap Parms{};

	Parms.overlappingActor = overlappingActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EscapeDoor.OnExitActivationChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    activated                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEscapeDoor::OnExitActivationChanged(bool activated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "OnExitActivationChanged");

	Params::EscapeDoor_OnExitActivationChanged Parms{};

	Parms.activated = activated;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.EscapeDoor.OnExitGateOpened
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEscapeDoor::OnExitGateOpened(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "OnExitGateOpened");

	Params::EscapeDoor_OnExitGateOpened Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EscapeDoor.OnExitOpenChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    OPENED                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEscapeDoor::OnExitOpenChanged(bool OPENED)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "OnExitOpenChanged");

	Params::EscapeDoor_OnExitOpenChanged Parms{};

	Parms.OPENED = OPENED;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.EscapeDoor.OnOpenChargeableDechargeBegin
// (Final, Native, Private)
// Parameters:
// class UChargeableComponent*             ChargeableComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEscapeDoor::OnOpenChargeableDechargeBegin(class UChargeableComponent* ChargeableComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "OnOpenChargeableDechargeBegin");

	Params::EscapeDoor_OnOpenChargeableDechargeBegin Parms{};

	Parms.ChargeableComponent = ChargeableComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EscapeDoor.OnOpenChargeableDechargeEnd
// (Final, Native, Private)
// Parameters:
// class UChargeableComponent*             ChargeableComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEscapeDoor::OnOpenChargeableDechargeEnd(class UChargeableComponent* ChargeableComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "OnOpenChargeableDechargeEnd");

	Params::EscapeDoor_OnOpenChargeableDechargeEnd Parms{};

	Parms.ChargeableComponent = ChargeableComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EscapeDoor.OnPlayerEnterExitArea
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEscapeDoor::OnPlayerEnterExitArea(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "OnPlayerEnterExitArea");

	Params::EscapeDoor_OnPlayerEnterExitArea Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EscapeDoor.OnPlayerExitExitArea
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEscapeDoor::OnPlayerExitExitArea(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "OnPlayerExitExitArea");

	Params::EscapeDoor_OnPlayerExitExitArea Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EscapeDoor.OnRep_Activated
// (Final, Native, Private)
// Parameters:
// bool                                    oldActivated                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEscapeDoor::OnRep_Activated(bool oldActivated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "OnRep_Activated");

	Params::EscapeDoor_OnRep_Activated Parms{};

	Parms.oldActivated = oldActivated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EscapeDoor.OnSpectatedPlayerChanged
// (Final, Native, Private)

void AEscapeDoor::OnSpectatedPlayerChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "OnSpectatedPlayerChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EscapeDoor.OnUnblockDoorSwitchCosmetic
// (Event, Protected, BlueprintEvent)

void AEscapeDoor::OnUnblockDoorSwitchCosmetic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "OnUnblockDoorSwitchCosmetic");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.EscapeDoor.SetIsActivated
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsActivated                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEscapeDoor::SetIsActivated(bool IsActivated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "SetIsActivated");

	Params::EscapeDoor_SetIsActivated Parms{};

	Parms.IsActivated = IsActivated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EscapeDoor.GetDoorSkeletalMeshComponent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* AEscapeDoor::GetDoorSkeletalMeshComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "GetDoorSkeletalMeshComponent");

	Params::EscapeDoor_GetDoorSkeletalMeshComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EscapeDoor.GetEscapeSwitchFloorLocation
// (Event, Public, HasDefaults, BlueprintEvent, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AEscapeDoor::GetEscapeSwitchFloorLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "GetEscapeSwitchFloorLocation");

	Params::EscapeDoor_GetEscapeSwitchFloorLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EscapeDoor.GetExitArea
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UBoxComponent*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBoxComponent* AEscapeDoor::GetExitArea() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "GetExitArea");

	Params::EscapeDoor_GetExitArea Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EscapeDoor.GetIsOpen
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEscapeDoor::GetIsOpen() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "GetIsOpen");

	Params::EscapeDoor_GetIsOpen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EscapeDoor.GetOpenTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AEscapeDoor::GetOpenTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "GetOpenTime");

	Params::EscapeDoor_GetOpenTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EscapeDoor.GetParadiseServerLocation
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AEscapeDoor::GetParadiseServerLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "GetParadiseServerLocation");

	Params::EscapeDoor_GetParadiseServerLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EscapeDoor.GetSwitchSceneComponent
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* AEscapeDoor::GetSwitchSceneComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "GetSwitchSceneComponent");

	Params::EscapeDoor_GetSwitchSceneComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EscapeDoor.IsActivated
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEscapeDoor::IsActivated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "IsActivated");

	Params::EscapeDoor_IsActivated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EscapeDoor.IsDoorSwitchBlocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEscapeDoor::IsDoorSwitchBlocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "IsDoorSwitchBlocked");

	Params::EscapeDoor_IsDoorSwitchBlocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.BlueprintDebugUtilities.EnsureFalseWithMessage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    ensureMessage                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintDebugUtilities::EnsureFalseWithMessage(const class FString& ensureMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintDebugUtilities", "EnsureFalseWithMessage");

	Params::BlueprintDebugUtilities_EnsureFalseWithMessage Parms{};

	Parms.ensureMessage = std::move(ensureMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BlueprintDebugUtilities.EnsureOnConditionWithMessage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const bool                              Condition                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    ensureMessage                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintDebugUtilities::EnsureOnConditionWithMessage(const bool Condition, const class FString& ensureMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintDebugUtilities", "EnsureOnConditionWithMessage");

	Params::BlueprintDebugUtilities_EnsureOnConditionWithMessage Parms{};

	Parms.Condition = Condition;
	Parms.ensureMessage = std::move(ensureMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BreakableBase.Explode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABreakableBase::Explode(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BreakableBase", "Explode");

	Params::BreakableBase_Explode Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BreakableBase.ExplodeVfxSfx
// (Event, Protected, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FVector&                   ImpulseDir                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABreakableBase::ExplodeVfxSfx(const struct FVector& ImpulseDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BreakableBase", "ExplodeVfxSfx");

	Params::BreakableBase_ExplodeVfxSfx Parms{};

	Parms.ImpulseDir = std::move(ImpulseDir);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.BreakableBase.PlayAudioBreakable
// (Final, Native, Public, BlueprintCallable)

void ABreakableBase::PlayAudioBreakable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BreakableBase", "PlayAudioBreakable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BreakableBase.IsUnbroken
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABreakableBase::IsUnbroken() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BreakableBase", "IsUnbroken");

	Params::BreakableBase_IsUnbroken Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlayerPerspectiveComponent.OnPawnControllerChanged
// (Final, Native, Private)
// Parameters:
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      OldController                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      NewController                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerPerspectiveComponent::OnPawnControllerChanged(class APawn* Pawn, class AController* OldController, class AController* NewController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerPerspectiveComponent", "OnPawnControllerChanged");

	Params::PlayerPerspectiveComponent_OnPawnControllerChanged Parms{};

	Parms.Pawn = Pawn;
	Parms.OldController = OldController;
	Parms.NewController = NewController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerPerspectiveComponent.UpdateLocallyObserved
// (Final, Native, Private)

void UPlayerPerspectiveComponent::UpdateLocallyObserved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerPerspectiveComponent", "UpdateLocallyObserved");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerPerspectiveComponent.IsLocallyObserved
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerPerspectiveComponent::IsLocallyObserved() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerPerspectiveComponent", "IsLocallyObserved");

	Params::PlayerPerspectiveComponent_IsLocallyObserved Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CameraAttachmentComponent.Detach
// (Final, Native, Public, BlueprintCallable)

void UCameraAttachmentComponent::Detach()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraAttachmentComponent", "Detach");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CameraAttachmentComponent.Reset
// (Final, Native, Public, BlueprintCallable)

void UCameraAttachmentComponent::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraAttachmentComponent", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CameraAttachmentComponent.IsAttached
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCameraAttachmentComponent::IsAttached() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraAttachmentComponent", "IsAttached");

	Params::CameraAttachmentComponent_IsAttached Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CameraFadeComponent.OnFadedIn
// (Final, Native, Public, BlueprintCallable)

void UCameraFadeComponent::OnFadedIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraFadeComponent", "OnFadedIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CameraFadeComponent.OnFadedOut
// (Final, Native, Public, BlueprintCallable)

void UCameraFadeComponent::OnFadedOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraFadeComponent", "OnFadedOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CameraFadeComponent.GetCameraFadeState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECameraFadeState                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECameraFadeState UCameraFadeComponent::GetCameraFadeState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraFadeComponent", "GetCameraFadeState");

	Params::CameraFadeComponent_GetCameraFadeState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DisplayStandCharmRequesterComponent.OnCharmDisplayed
// (Final, Native, Private)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDisplayStandCharmRequesterComponent::OnCharmDisplayed(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DisplayStandCharmRequesterComponent", "OnCharmDisplayed");

	Params::DisplayStandCharmRequesterComponent_OnCharmDisplayed Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CameraHandlerComponent.AddCameraToSocket
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDBDCameraSocketID                      Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Camera                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraHandlerComponent::AddCameraToSocket(EDBDCameraSocketID Mode, class AActor* Camera)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraHandlerComponent", "AddCameraToSocket");

	Params::CameraHandlerComponent_AddCameraToSocket Parms{};

	Parms.Mode = Mode;
	Parms.Camera = Camera;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CameraHandlerComponent.GetCurrentCamera
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UCameraHandlerComponent::GetCurrentCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraHandlerComponent", "GetCurrentCamera");

	Params::CameraHandlerComponent_GetCurrentCamera Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CameraHandlerComponent.GetSocketID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDBDCameraSocketID                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDBDCameraSocketID UCameraHandlerComponent::GetSocketID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraHandlerComponent", "GetSocketID");

	Params::CameraHandlerComponent_GetSocketID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CameraHandlerComponent.OnFirstPersonViewChanged
// (Final, Native, Private)
// Parameters:
// bool                                    isFirstPerson                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraHandlerComponent::OnFirstPersonViewChanged(bool isFirstPerson)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraHandlerComponent", "OnFirstPersonViewChanged");

	Params::CameraHandlerComponent_OnFirstPersonViewChanged Parms{};

	Parms.isFirstPerson = isFirstPerson;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CameraHandlerComponent.OnLevelReadyToPlay
// (Final, Native, Private)

void UCameraHandlerComponent::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraHandlerComponent", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CameraHandlerComponent.PlayVFXOnCurrentCamera
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UParticleSystemComponent*         Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraHandlerComponent::PlayVFXOnCurrentCamera(class UParticleSystemComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraHandlerComponent", "PlayVFXOnCurrentCamera");

	Params::CameraHandlerComponent_PlayVFXOnCurrentCamera Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CameraHandlerComponent.SetAttachmentComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  attachmentComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraHandlerComponent::SetAttachmentComponent(class USceneComponent* attachmentComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraHandlerComponent", "SetAttachmentComponent");

	Params::CameraHandlerComponent_SetAttachmentComponent Parms{};

	Parms.attachmentComponent = attachmentComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CameraHandlerComponent.SetSocketID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDBDCameraSocketID                      Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraHandlerComponent::SetSocketID(EDBDCameraSocketID Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraHandlerComponent", "SetSocketID");

	Params::CameraHandlerComponent_SetSocketID Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CameraHandlerComponent.GetCameraComponentBySocket
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDBDCameraSocketID                      socket                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCameraComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCameraComponent* UCameraHandlerComponent::GetCameraComponentBySocket(EDBDCameraSocketID socket) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraHandlerComponent", "GetCameraComponentBySocket");

	Params::CameraHandlerComponent_GetCameraComponentBySocket Parms{};

	Parms.socket = socket;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CameraHandlerComponent.GetDesiredFOV
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCameraHandlerComponent::GetDesiredFOV() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraHandlerComponent", "GetDesiredFOV");

	Params::CameraHandlerComponent_GetDesiredFOV Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperMaterialHelperController.AddManagedGroup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Group                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperMaterialHelperController::AddManagedGroup(class UObject* Source, const class FString& Group)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperMaterialHelperController", "AddManagedGroup");

	Params::CamperMaterialHelperController_AddManagedGroup Parms{};

	Parms.Source = Source;
	Parms.Group = std::move(Group);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperMaterialHelperController.AddManagedGroupWithColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Group                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ColorParameterName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperMaterialHelperController::AddManagedGroupWithColor(class UObject* Source, const class FString& Group, class FName ColorParameterName, const struct FLinearColor& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperMaterialHelperController", "AddManagedGroupWithColor");

	Params::CamperMaterialHelperController_AddManagedGroupWithColor Parms{};

	Parms.Source = Source;
	Parms.Group = std::move(Group);
	Parms.ColorParameterName = ColorParameterName;
	Parms.Color = std::move(Color);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperMaterialHelperController.AddManagedWithCondition
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Group                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TDelegate<void()>&                Condition                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperMaterialHelperController::AddManagedWithCondition(class UObject* Source, const class FString& Group, const TDelegate<void()>& Condition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperMaterialHelperController", "AddManagedWithCondition");

	Params::CamperMaterialHelperController_AddManagedWithCondition Parms{};

	Parms.Source = Source;
	Parms.Group = std::move(Group);
	Parms.Condition = Condition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperMaterialHelperController.RemoveGroupsBySource
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperMaterialHelperController::RemoveGroupsBySource(class UObject* Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperMaterialHelperController", "RemoveGroupsBySource");

	Params::CamperMaterialHelperController_RemoveGroupsBySource Parms{};

	Parms.Source = Source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGame_Lobby.DBD_AddBotToLobby
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   SelectedCharacter                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Item                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Addon1                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Addon2                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Offering                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    perk1                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    perk2                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    perk3                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    perk4                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Rank                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGame_Lobby::DBD_AddBotToLobby(int32 SelectedCharacter, const class FString& Item, const class FString& Addon1, const class FString& Addon2, const class FString& Offering, const class FString& perk1, const class FString& perk2, const class FString& perk3, const class FString& perk4, int32 Rank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGame_Lobby", "DBD_AddBotToLobby");

	Params::DBDGame_Lobby_DBD_AddBotToLobby Parms{};

	Parms.SelectedCharacter = SelectedCharacter;
	Parms.Item = std::move(Item);
	Parms.Addon1 = std::move(Addon1);
	Parms.Addon2 = std::move(Addon2);
	Parms.Offering = std::move(Offering);
	Parms.perk1 = std::move(perk1);
	Parms.perk2 = std::move(perk2);
	Parms.perk3 = std::move(perk3);
	Parms.perk4 = std::move(perk4);
	Parms.Rank = Rank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGame_Lobby.DBD_AddBotToLobbyByName
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    SelectedCharacter                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Item                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Addon1                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Addon2                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Offering                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    perk1                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    perk2                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    perk3                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    perk4                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Rank                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGame_Lobby::DBD_AddBotToLobbyByName(const class FString& SelectedCharacter, const class FString& Item, const class FString& Addon1, const class FString& Addon2, const class FString& Offering, const class FString& perk1, const class FString& perk2, const class FString& perk3, const class FString& perk4, int32 Rank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGame_Lobby", "DBD_AddBotToLobbyByName");

	Params::DBDGame_Lobby_DBD_AddBotToLobbyByName Parms{};

	Parms.SelectedCharacter = std::move(SelectedCharacter);
	Parms.Item = std::move(Item);
	Parms.Addon1 = std::move(Addon1);
	Parms.Addon2 = std::move(Addon2);
	Parms.Offering = std::move(Offering);
	Parms.perk1 = std::move(perk1);
	Parms.perk2 = std::move(perk2);
	Parms.perk3 = std::move(perk3);
	Parms.perk4 = std::move(perk4);
	Parms.Rank = Rank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGame_Lobby.DBD_AddBotToLobbyNoLoadout
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   SelectedCharacter                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGame_Lobby::DBD_AddBotToLobbyNoLoadout(int32 SelectedCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGame_Lobby", "DBD_AddBotToLobbyNoLoadout");

	Params::DBDGame_Lobby_DBD_AddBotToLobbyNoLoadout Parms{};

	Parms.SelectedCharacter = SelectedCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGame_Lobby.DBD_AddBotToLobbyNoLoadoutByName
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    SelectedCharacter                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGame_Lobby::DBD_AddBotToLobbyNoLoadoutByName(const class FString& SelectedCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGame_Lobby", "DBD_AddBotToLobbyNoLoadoutByName");

	Params::DBDGame_Lobby_DBD_AddBotToLobbyNoLoadoutByName Parms{};

	Parms.SelectedCharacter = std::move(SelectedCharacter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGame_Lobby.DBD_FillLobby
// (Final, Exec, Native, Public)

void ADBDGame_Lobby::DBD_FillLobby()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGame_Lobby", "DBD_FillLobby");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGame_Lobby.DBD_FillLobbyWithBotsByName
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    selectedKiller                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Rank                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGame_Lobby::DBD_FillLobbyWithBotsByName(const class FString& selectedKiller, int32 Rank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGame_Lobby", "DBD_FillLobbyWithBotsByName");

	Params::DBDGame_Lobby_DBD_FillLobbyWithBotsByName Parms{};

	Parms.selectedKiller = std::move(selectedKiller);
	Parms.Rank = Rank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGame_Lobby.DBD_RemoveBotByIndex
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   botIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGame_Lobby::DBD_RemoveBotByIndex(int32 botIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGame_Lobby", "DBD_RemoveBotByIndex");

	Params::DBDGame_Lobby_DBD_RemoveBotByIndex Parms{};

	Parms.botIndex = botIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CartersSparkComponent.Authority_AddTotallyInsaneSurvivor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       insaneSurvivor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCartersSparkComponent::Authority_AddTotallyInsaneSurvivor(class ADBDPlayer* insaneSurvivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CartersSparkComponent", "Authority_AddTotallyInsaneSurvivor");

	Params::CartersSparkComponent_Authority_AddTotallyInsaneSurvivor Parms{};

	Parms.insaneSurvivor = insaneSurvivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CartersSparkComponent.Authority_RegisterToGameEvents
// (Final, Native, Private)

void UCartersSparkComponent::Authority_RegisterToGameEvents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CartersSparkComponent", "Authority_RegisterToGameEvents");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CartersSparkComponent.Multicast_OnShockTherapyCooldownCheatEntered
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void UCartersSparkComponent::Multicast_OnShockTherapyCooldownCheatEntered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CartersSparkComponent", "Multicast_OnShockTherapyCooldownCheatEntered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CartersSparkComponent.OnRequestAndBeginInteraction
// (Final, Native, Private)
// Parameters:
// class UInteractionDefinition*           Interaction                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCartersSparkComponent::OnRequestAndBeginInteraction(class UInteractionDefinition* Interaction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CartersSparkComponent", "OnRequestAndBeginInteraction");

	Params::CartersSparkComponent_OnRequestAndBeginInteraction Parms{};

	Parms.Interaction = Interaction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CartersSparkComponent.TriggerShockTherapyCooldown
// (Final, Native, Public, BlueprintCallable)

void UCartersSparkComponent::TriggerShockTherapyCooldown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CartersSparkComponent", "TriggerShockTherapyCooldown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CartersSparkComponent.TriggerStaticBlastCooldown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    hasHitSurvivor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCartersSparkComponent::TriggerStaticBlastCooldown(bool hasHitSurvivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CartersSparkComponent", "TriggerStaticBlastCooldown");

	Params::CartersSparkComponent_TriggerStaticBlastCooldown Parms{};

	Parms.hasHitSurvivor = hasHitSurvivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CartersSparkComponent.GetShockTherapyCooldownDuration
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCartersSparkComponent::GetShockTherapyCooldownDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CartersSparkComponent", "GetShockTherapyCooldownDuration");

	Params::CartersSparkComponent_GetShockTherapyCooldownDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CartersSparkComponent.GetStaticBlastCooldownDuration
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    hasHitSurvivor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCartersSparkComponent::GetStaticBlastCooldownDuration(bool hasHitSurvivor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CartersSparkComponent", "GetStaticBlastCooldownDuration");

	Params::CartersSparkComponent_GetStaticBlastCooldownDuration Parms{};

	Parms.hasHitSurvivor = hasHitSurvivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CartersSparkComponent.GetStaticBlastCooldownPercentElapsed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCartersSparkComponent::GetStaticBlastCooldownPercentElapsed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CartersSparkComponent", "GetStaticBlastCooldownPercentElapsed");

	Params::CartersSparkComponent_GetStaticBlastCooldownPercentElapsed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CartersSparkComponent.IsShockTherapyOnCooldown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCartersSparkComponent::IsShockTherapyOnCooldown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CartersSparkComponent", "IsShockTherapyOnCooldown");

	Params::CartersSparkComponent_IsShockTherapyOnCooldown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CartersSparkComponent.IsStaticBlastOnCooldown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCartersSparkComponent::IsStaticBlastOnCooldown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CartersSparkComponent", "IsStaticBlastOnCooldown");

	Params::CartersSparkComponent_IsStaticBlastOnCooldown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterChaseVisualComponent.OnAllChaseEnd
// (Final, Native, Public)

void UCharacterChaseVisualComponent::OnAllChaseEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterChaseVisualComponent", "OnAllChaseEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameMode.HostGame
// (Final, Native, Protected, BlueprintCallable)

void ADBDGameMode::HostGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameMode", "HostGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameMode.InitializeEscapeRequirements
// (Final, Native, Protected, BlueprintCallable)

void ADBDGameMode::InitializeEscapeRequirements()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameMode", "InitializeEscapeRequirements");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameMode.LevelLoaded
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const class FString&                    LevelName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameMode::LevelLoaded(const class FString& LevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameMode", "LevelLoaded");

	Params::DBDGameMode_LevelLoaded Parms{};

	Parms.LevelName = std::move(LevelName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameMode.SetPlayerCount
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   playerAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameMode::SetPlayerCount(int32 playerAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameMode", "SetPlayerCount");

	Params::DBDGameMode_SetPlayerCount Parms{};

	Parms.playerAmount = playerAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameMode.AreLoadoutsCreated
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameMode::AreLoadoutsCreated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameMode", "AreLoadoutsCreated");

	Params::DBDGameMode_AreLoadoutsCreated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameMode.IsEscapeOpen
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameMode::IsEscapeOpen() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameMode", "IsEscapeOpen");

	Params::DBDGameMode_IsEscapeOpen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterClassUtilities.GetEquippedCharacterClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UCharacterClassUtilities::GetEquippedCharacterClass(const class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterClassUtilities", "GetEquippedCharacterClass");

	Params::CharacterClassUtilities_GetEquippedCharacterClass Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterCollection.GetAllDBDPlayers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class ADBDPlayer*>         ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class ADBDPlayer*> UCharacterCollection::GetAllDBDPlayers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCollection", "GetAllDBDPlayers");

	Params::CharacterCollection_GetAllDBDPlayers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterCollection.GetKiller
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AKiller*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AKiller* UCharacterCollection::GetKiller() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCollection", "GetKiller");

	Params::CharacterCollection_GetKiller Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterCollection.GetKillers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TSet<class AKiller*>              ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TSet<class AKiller*> UCharacterCollection::GetKillers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCollection", "GetKillers");

	Params::CharacterCollection_GetKillers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterCollection.GetMainDBDPlayers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TSet<class ADBDPlayer*>           ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TSet<class ADBDPlayer*> UCharacterCollection::GetMainDBDPlayers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCollection", "GetMainDBDPlayers");

	Params::CharacterCollection_GetMainDBDPlayers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterCollection.GetOtherCharacters
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TSet<class ADBDPlayer*>           ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TSet<class ADBDPlayer*> UCharacterCollection::GetOtherCharacters() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCollection", "GetOtherCharacters");

	Params::CharacterCollection_GetOtherCharacters Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterCollection.GetSurvivors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TSet<class ASurvivor*>            ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TSet<class ASurvivor*> UCharacterCollection::GetSurvivors() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCollection", "GetSurvivors");

	Params::CharacterCollection_GetSurvivors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterCollectionUtilities.GetAllCharacters
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSet<class ACharacter*>           ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TSet<class ACharacter*> UCharacterCollectionUtilities::GetAllCharacters(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCollectionUtilities", "GetAllCharacters");

	Params::CharacterCollectionUtilities_GetAllCharacters Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterCollectionUtilities.GetAllDBDPlayers
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADBDPlayer*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ADBDPlayer*> UCharacterCollectionUtilities::GetAllDBDPlayers(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCollectionUtilities", "GetAllDBDPlayers");

	Params::CharacterCollectionUtilities_GetAllDBDPlayers Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterCollectionUtilities.GetCharactersByPlayerTeam
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EPlayerTeam                             playerTeam                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADBDPlayer*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ADBDPlayer*> UCharacterCollectionUtilities::GetCharactersByPlayerTeam(EPlayerTeam playerTeam, const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCollectionUtilities", "GetCharactersByPlayerTeam");

	Params::CharacterCollectionUtilities_GetCharactersByPlayerTeam Parms{};

	Parms.playerTeam = playerTeam;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterCollectionUtilities.GetInGameKillers
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AKiller*>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AKiller*> UCharacterCollectionUtilities::GetInGameKillers(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCollectionUtilities", "GetInGameKillers");

	Params::CharacterCollectionUtilities_GetInGameKillers Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterCollectionUtilities.GetInGameKillersByRef
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSet<class AKiller*>              ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TSet<class AKiller*> UCharacterCollectionUtilities::GetInGameKillersByRef(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCollectionUtilities", "GetInGameKillersByRef");

	Params::CharacterCollectionUtilities_GetInGameKillersByRef Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterCollectionUtilities.GetInGameOtherCharacters
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADBDPlayer*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ADBDPlayer*> UCharacterCollectionUtilities::GetInGameOtherCharacters(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCollectionUtilities", "GetInGameOtherCharacters");

	Params::CharacterCollectionUtilities_GetInGameOtherCharacters Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterCollectionUtilities.GetInGamePlayers
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADBDPlayer*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ADBDPlayer*> UCharacterCollectionUtilities::GetInGamePlayers(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCollectionUtilities", "GetInGamePlayers");

	Params::CharacterCollectionUtilities_GetInGamePlayers Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterCollectionUtilities.GetInGameSurvivors
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ASurvivor*>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ASurvivor*> UCharacterCollectionUtilities::GetInGameSurvivors(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCollectionUtilities", "GetInGameSurvivors");

	Params::CharacterCollectionUtilities_GetInGameSurvivors Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterCollectionUtilities.GetInGameSurvivorsAsPlayers
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADBDPlayer*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ADBDPlayer*> UCharacterCollectionUtilities::GetInGameSurvivorsAsPlayers(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCollectionUtilities", "GetInGameSurvivorsAsPlayers");

	Params::CharacterCollectionUtilities_GetInGameSurvivorsAsPlayers Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterCollectionUtilities.GetInGameSurvivorsByRef
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSet<class ASurvivor*>            ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TSet<class ASurvivor*> UCharacterCollectionUtilities::GetInGameSurvivorsByRef(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCollectionUtilities", "GetInGameSurvivorsByRef");

	Params::CharacterCollectionUtilities_GetInGameSurvivorsByRef Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterCollectionUtilities.GetKiller
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AKiller*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AKiller* UCharacterCollectionUtilities::GetKiller(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCollectionUtilities", "GetKiller");

	Params::CharacterCollectionUtilities_GetKiller Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterCollectionUtilities.GetNumberOfInjuredHookedOrDyingSurvivors
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UCharacterCollectionUtilities::GetNumberOfInjuredHookedOrDyingSurvivors(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCollectionUtilities", "GetNumberOfInjuredHookedOrDyingSurvivors");

	Params::CharacterCollectionUtilities_GetNumberOfInjuredHookedOrDyingSurvivors Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SelectiveVisibilityComponent.Local_SetVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewVisibility                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPropagateToChildren                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USelectiveVisibilityComponent::Local_SetVisibility(bool bNewVisibility, bool bPropagateToChildren)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectiveVisibilityComponent", "Local_SetVisibility");

	Params::SelectiveVisibilityComponent_Local_SetVisibility Parms{};

	Parms.bNewVisibility = bNewVisibility;
	Parms.bPropagateToChildren = bPropagateToChildren;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterHelper.GetAllEnabledCharms
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    sortArray                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UCharacterHelper::GetAllEnabledCharms(bool sortArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterHelper", "GetAllEnabledCharms");

	Params::CharacterHelper_GetAllEnabledCharms Parms{};

	Parms.sortArray = sortArray;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterHelper.GetAllOutfitComponentsOfCharacter
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FCustomizationItemData>*  returnHeads                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FCustomizationItemData>*  returnTorsos                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FCustomizationItemData>*  returnLegsWeapons                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// const class FString&                    CharacterId                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              sortArrays                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterHelper::GetAllOutfitComponentsOfCharacter(TArray<struct FCustomizationItemData>* returnHeads, TArray<struct FCustomizationItemData>* returnTorsos, TArray<struct FCustomizationItemData>* returnLegsWeapons, const class FString& CharacterId, const bool sortArrays)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterHelper", "GetAllOutfitComponentsOfCharacter");

	Params::CharacterHelper_GetAllOutfitComponentsOfCharacter Parms{};

	Parms.CharacterId = std::move(CharacterId);
	Parms.sortArrays = sortArrays;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (returnHeads != nullptr)
		*returnHeads = std::move(Parms.returnHeads);

	if (returnTorsos != nullptr)
		*returnTorsos = std::move(Parms.returnTorsos);

	if (returnLegsWeapons != nullptr)
		*returnLegsWeapons = std::move(Parms.returnLegsWeapons);
}


// Function DeadByDaylight.CharacterHelper.GetCharactersByRole
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EPlayerRole                       Role                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              sortArray                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FCharacterDescription>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FCharacterDescription> UCharacterHelper::GetCharactersByRole(const class UObject* WorldContextObject, const EPlayerRole Role, const bool sortArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterHelper", "GetCharactersByRole");

	Params::CharacterHelper_GetCharactersByRole Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Role = Role;
	Parms.sortArray = sortArray;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterHelper.GetOutfitComposition
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FCustomizationItemData*          returnHead                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FCustomizationItemData*          returnTorso                                            (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FCustomizationItemData*          returnLegsWeapon                                       (Parm, OutParm, NativeAccessSpecifierPublic)
// const class FString&                    OutfitId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterHelper::GetOutfitComposition(struct FCustomizationItemData* returnHead, struct FCustomizationItemData* returnTorso, struct FCustomizationItemData* returnLegsWeapon, const class FString& OutfitId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterHelper", "GetOutfitComposition");

	Params::CharacterHelper_GetOutfitComposition Parms{};

	Parms.OutfitId = std::move(OutfitId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (returnHead != nullptr)
		*returnHead = std::move(Parms.returnHead);

	if (returnTorso != nullptr)
		*returnTorso = std::move(Parms.returnTorso);

	if (returnLegsWeapon != nullptr)
		*returnLegsWeapon = std::move(Parms.returnLegsWeapon);
}


// Function DeadByDaylight.CharacterHelper.GetOutfitsByCharacterIndex
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   characterIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              sortArray                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              includeCharacterDescriptionOverrides                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FOutfitData>              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FOutfitData> UCharacterHelper::GetOutfitsByCharacterIndex(int32 characterIndex, const bool sortArray, const bool includeCharacterDescriptionOverrides)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterHelper", "GetOutfitsByCharacterIndex");

	Params::CharacterHelper_GetOutfitsByCharacterIndex Parms{};

	Parms.characterIndex = characterIndex;
	Parms.sortArray = sortArray;
	Parms.includeCharacterDescriptionOverrides = includeCharacterDescriptionOverrides;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterHelper.SetCharmSlot
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADBDPlayerState*                  PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      CharmId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   slotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCharmIdSlot                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCharmIdSlot UCharacterHelper::SetCharmSlot(class ADBDPlayerState* PlayerState, const class FName& CharmId, int32 slotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterHelper", "SetCharmSlot");

	Params::CharacterHelper_SetCharmSlot Parms{};

	Parms.PlayerState = PlayerState;
	Parms.CharmId = CharmId;
	Parms.slotIndex = slotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterInventoryComponent.Authority_AddToInventory
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ACollectable*                     Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInventoryType                          inventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterInventoryComponent::Authority_AddToInventory(class ACollectable* Item, EInventoryType inventoryType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "Authority_AddToInventory");

	Params::CharacterInventoryComponent_Authority_AddToInventory Parms{};

	Parms.Item = Item;
	Parms.inventoryType = inventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterInventoryComponent.Authority_ClearAndDestroyInventory
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UCharacterInventoryComponent::Authority_ClearAndDestroyInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "Authority_ClearAndDestroyInventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterInventoryComponent.Authority_Collect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACollectable*                     Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInventoryType                          inventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    swapItemsAndHideOldAway                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterInventoryComponent::Authority_Collect(class ACollectable* Item, EInventoryType inventoryType, bool swapItemsAndHideOldAway)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "Authority_Collect");

	Params::CharacterInventoryComponent_Authority_Collect Parms{};

	Parms.Item = Item;
	Parms.inventoryType = inventoryType;
	Parms.swapItemsAndHideOldAway = swapItemsAndHideOldAway;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterInventoryComponent.Authority_RemoveFromInventory
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ACollectable*                     Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInventoryType                          inventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterInventoryComponent::Authority_RemoveFromInventory(class ACollectable* Item, EInventoryType inventoryType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "Authority_RemoveFromInventory");

	Params::CharacterInventoryComponent_Authority_RemoveFromInventory Parms{};

	Parms.Item = Item;
	Parms.inventoryType = inventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterInventoryComponent.Authority_UseInventoryItem
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UCharacterInventoryComponent::Authority_UseInventoryItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "Authority_UseInventoryItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterInventoryComponent.EquipItem
// (Final, Native, Public, BlueprintCallable)

void UCharacterInventoryComponent::EquipItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "EquipItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterInventoryComponent.GetAddon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             AddonID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAddon*                       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UItemAddon* UCharacterInventoryComponent::GetAddon(class FName AddonID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "GetAddon");

	Params::CharacterInventoryComponent_GetAddon Parms{};

	Parms.AddonID = AddonID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterInventoryComponent.GetAddons
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class UItemAddon*>         ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TArray<class UItemAddon*> UCharacterInventoryComponent::GetAddons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "GetAddons");

	Params::CharacterInventoryComponent_GetAddons Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterInventoryComponent.GetFirstItemFromInventory
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class ACollectable>         Item                                                   (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInventoryType                          inventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACollectable*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACollectable* UCharacterInventoryComponent::GetFirstItemFromInventory(TSubclassOf<class ACollectable> Item, EInventoryType inventoryType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "GetFirstItemFromInventory");

	Params::CharacterInventoryComponent_GetFirstItemFromInventory Parms{};

	Parms.Item = Item;
	Parms.inventoryType = inventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterInventoryComponent.HasInInventory
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class ACollectable>         Item                                                   (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInventoryType                          inventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterInventoryComponent::HasInInventory(TSubclassOf<class ACollectable> Item, EInventoryType inventoryType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "HasInInventory");

	Params::CharacterInventoryComponent_HasInInventory Parms{};

	Parms.Item = Item;
	Parms.inventoryType = inventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterInventoryComponent.Multicast_AddToInventory
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ACollectable*                     Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInventoryType                          inventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterInventoryComponent::Multicast_AddToInventory(class ACollectable* Item, EInventoryType inventoryType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "Multicast_AddToInventory");

	Params::CharacterInventoryComponent_Multicast_AddToInventory Parms{};

	Parms.Item = Item;
	Parms.inventoryType = inventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterInventoryComponent.Multicast_ClearAndDestroyInventory
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void UCharacterInventoryComponent::Multicast_ClearAndDestroyInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "Multicast_ClearAndDestroyInventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterInventoryComponent.Multicast_MoveItemToOtherSlot
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ACollectable*                     itemBeingMoved                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInventoryType                          targetInventoryType                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterInventoryComponent::Multicast_MoveItemToOtherSlot(class ACollectable* itemBeingMoved, EInventoryType targetInventoryType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "Multicast_MoveItemToOtherSlot");

	Params::CharacterInventoryComponent_Multicast_MoveItemToOtherSlot Parms{};

	Parms.itemBeingMoved = itemBeingMoved;
	Parms.targetInventoryType = targetInventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterInventoryComponent.Multicast_RemoveFromInventory
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ACollectable*                     Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInventoryType                          inventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterInventoryComponent::Multicast_RemoveFromInventory(class ACollectable* Item, EInventoryType inventoryType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "Multicast_RemoveFromInventory");

	Params::CharacterInventoryComponent_Multicast_RemoveFromInventory Parms{};

	Parms.Item = Item;
	Parms.inventoryType = inventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterInventoryComponent.OnRep_BackpackInventory
// (Final, Native, Private)

void UCharacterInventoryComponent::OnRep_BackpackInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "OnRep_BackpackInventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterInventoryComponent.OnRep_GeneralAddons
// (Final, Native, Private)

void UCharacterInventoryComponent::OnRep_GeneralAddons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "OnRep_GeneralAddons");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterInventoryComponent.OnRep_Inventory
// (Final, Native, Private)

void UCharacterInventoryComponent::OnRep_Inventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "OnRep_Inventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterInventoryComponent.SpawnAndCollectItem
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACollectable*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACollectable* UCharacterInventoryComponent::SpawnAndCollectItem(class FName ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "SpawnAndCollectItem");

	Params::CharacterInventoryComponent_SpawnAndCollectItem Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterInventoryComponent.StoreItem
// (Final, Native, Public, BlueprintCallable)

void UCharacterInventoryComponent::StoreItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "StoreItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterInventoryComponent.GetItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInventoryType                          inventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACollectable*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACollectable* UCharacterInventoryComponent::GetItem(EInventoryType inventoryType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "GetItem");

	Params::CharacterInventoryComponent_GetItem Parms{};

	Parms.inventoryType = inventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterInventoryComponent.GetItemCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCharacterInventoryComponent::GetItemCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "GetItemCount");

	Params::CharacterInventoryComponent_GetItemCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterInventoryComponent.GetItemCountByID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ItemId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCharacterInventoryComponent::GetItemCountByID(class FName ItemId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "GetItemCountByID");

	Params::CharacterInventoryComponent_GetItemCountByID Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterInventoryComponent.GetItemID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInventoryType                          inventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UCharacterInventoryComponent::GetItemID(EInventoryType inventoryType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "GetItemID");

	Params::CharacterInventoryComponent_GetItemID Parms{};

	Parms.inventoryType = inventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterInventoryComponent.HasEquippedItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterInventoryComponent::HasEquippedItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "HasEquippedItem");

	Params::CharacterInventoryComponent_HasEquippedItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterInventoryComponent.HasItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInventoryType                          inventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterInventoryComponent::HasItem(EInventoryType inventoryType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "HasItem");

	Params::CharacterInventoryComponent_HasItem Parms{};

	Parms.inventoryType = inventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterInventoryComponent.HasMaximumItemCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ACollectable*               Item                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterInventoryComponent::HasMaximumItemCount(const class ACollectable* Item) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "HasMaximumItemCount");

	Params::CharacterInventoryComponent_HasMaximumItemCount Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterInventoryComponent.HasStoredItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterInventoryComponent::HasStoredItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "HasStoredItem");

	Params::CharacterInventoryComponent_HasStoredItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterInventoryComponent.IsUsingAimItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterInventoryComponent::IsUsingAimItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "IsUsingAimItem");

	Params::CharacterInventoryComponent_IsUsingAimItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayerState.Authority_CancelOngoingScoreEvent
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              scoreTypeTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::Authority_CancelOngoingScoreEvent(const struct FGameplayTag& scoreTypeTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Authority_CancelOngoingScoreEvent");

	Params::DBDPlayerState_Authority_CancelOngoingScoreEvent Parms{};

	Parms.scoreTypeTag = std::move(scoreTypeTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Authority_EndOngoingScoreEvent
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              scoreTypeTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::Authority_EndOngoingScoreEvent(const struct FGameplayTag& scoreTypeTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Authority_EndOngoingScoreEvent");

	Params::DBDPlayerState_Authority_EndOngoingScoreEvent Parms{};

	Parms.scoreTypeTag = std::move(scoreTypeTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Authority_HandleScoreEvent
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              scoreTypeTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FScoreEventData&           ScoreEventData                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ADBDPlayerState::Authority_HandleScoreEvent(const struct FGameplayTag& scoreTypeTag, const struct FScoreEventData& ScoreEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Authority_HandleScoreEvent");

	Params::DBDPlayerState_Authority_HandleScoreEvent Parms{};

	Parms.scoreTypeTag = std::move(scoreTypeTag);
	Parms.ScoreEventData = std::move(ScoreEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Authority_SetBotStateInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDBDBotStateInfo&          Info                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ADBDPlayerState::Authority_SetBotStateInfo(const struct FDBDBotStateInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Authority_SetBotStateInfo");

	Params::DBDPlayerState_Authority_SetBotStateInfo Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Authority_SetPlayerGameState
// (Final, Native, Private)
// Parameters:
// EGameState                              newGameState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isEscapeHatch                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::Authority_SetPlayerGameState(EGameState newGameState, bool isEscapeHatch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Authority_SetPlayerGameState");

	Params::DBDPlayerState_Authority_SetPlayerGameState Parms{};

	Parms.newGameState = newGameState;
	Parms.isEscapeHatch = isEscapeHatch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.ChangeStartingGameRole
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPlayerRole                             GameRole_0                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::ChangeStartingGameRole(EPlayerRole GameRole_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "ChangeStartingGameRole");

	Params::DBDPlayerState_ChangeStartingGameRole Parms{};

	Parms.GameRole_0 = GameRole_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Client_FireQuestRepetitionValueChangeEvent
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// int32                                   Repetition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    QuestEventId                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    ChallengeId                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::Client_FireQuestRepetitionValueChangeEvent(int32 Repetition, const class FString& QuestEventId, const class FString& ChallengeId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Client_FireQuestRepetitionValueChangeEvent");

	Params::DBDPlayerState_Client_FireQuestRepetitionValueChangeEvent Parms{};

	Parms.Repetition = Repetition;
	Parms.QuestEventId = std::move(QuestEventId);
	Parms.ChallengeId = std::move(ChallengeId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Client_HandleEndOfMatch
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FEndOfMatchRPCData&        Response                                               (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ADBDPlayerState::Client_HandleEndOfMatch(bool Success, const struct FEndOfMatchRPCData& Response)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Client_HandleEndOfMatch");

	Params::DBDPlayerState_Client_HandleEndOfMatch Parms{};

	Parms.Success = Success;
	Parms.Response = std::move(Response);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Client_HandleEscapeScoreEvent
// (Net, NetReliable, Native, Event, Public, NetClient)

void ADBDPlayerState::Client_HandleEscapeScoreEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Client_HandleEscapeScoreEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Client_InvalidateIncentives
// (Net, NetReliable, Native, Event, Public, NetClient)

void ADBDPlayerState::Client_InvalidateIncentives()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Client_InvalidateIncentives");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Client_RemotelyDispatchGameEvent
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ADBDPlayerState::Client_RemotelyDispatchGameEvent(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Client_RemotelyDispatchGameEvent");

	Params::DBDPlayerState_Client_RemotelyDispatchGameEvent Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Client_RemotelyDispatchGameEventWithScore
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FAwardedScore&             AwardedScore                                           (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ADBDPlayerState::Client_RemotelyDispatchGameEventWithScore(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData, const struct FAwardedScore& AwardedScore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Client_RemotelyDispatchGameEventWithScore");

	Params::DBDPlayerState_Client_RemotelyDispatchGameEventWithScore Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.GameEventData = std::move(GameEventData);
	Parms.AwardedScore = std::move(AwardedScore);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Client_RemotelyDispatchGameEventWithTaggedScore
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              ScoreTypeId                                            (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BloodpointsAwarded                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::Client_RemotelyDispatchGameEventWithTaggedScore(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData, const struct FGameplayTag& ScoreTypeId, float BloodpointsAwarded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Client_RemotelyDispatchGameEventWithTaggedScore");

	Params::DBDPlayerState_Client_RemotelyDispatchGameEventWithTaggedScore Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.GameEventData = std::move(GameEventData);
	Parms.ScoreTypeId = std::move(ScoreTypeId);
	Parms.BloodpointsAwarded = BloodpointsAwarded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Client_RemoveElementFromInventory
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FName                             toRemove                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    updateLoadout                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::Client_RemoveElementFromInventory(class FName toRemove, bool updateLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Client_RemoveElementFromInventory");

	Params::DBDPlayerState_Client_RemoveElementFromInventory Parms{};

	Parms.toRemove = toRemove;
	Parms.updateLoadout = updateLoadout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Client_SetDSKickedOutReason
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// const uint32                            Reason                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::Client_SetDSKickedOutReason(const uint32 Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Client_SetDSKickedOutReason");

	Params::DBDPlayerState_Client_SetDSKickedOutReason Parms{};

	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Client_SetGameRole
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// EPlayerRole                             newRole                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::Client_SetGameRole(EPlayerRole newRole)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Client_SetGameRole");

	Params::DBDPlayerState_Client_SetGameRole Parms{};

	Parms.newRole = newRole;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Client_SetHasActiveArchiveDSQuestUpdate
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// bool                                    IsEnabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::Client_SetHasActiveArchiveDSQuestUpdate(bool IsEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Client_SetHasActiveArchiveDSQuestUpdate");

	Params::DBDPlayerState_Client_SetHasActiveArchiveDSQuestUpdate Parms{};

	Parms.IsEnabled = IsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Client_SetInParadise
// (Final, Net, NetReliable, Native, Event, Private, NetClient)

void ADBDPlayerState::Client_SetInParadise()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Client_SetInParadise");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Client_UpdateWallet
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// const class FString&                    currencyId                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::Client_UpdateWallet(const class FString& currencyId, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Client_UpdateWallet");

	Params::DBDPlayerState_Client_UpdateWallet Parms{};

	Parms.currencyId = std::move(currencyId);
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.FireActiveStatusEffectEvent
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             statusEffectId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Percentage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   iconFilePathIndex                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   levelToDisplay                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::FireActiveStatusEffectEvent(class FName statusEffectId, float Percentage, int32 iconFilePathIndex, int32 levelToDisplay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "FireActiveStatusEffectEvent");

	Params::DBDPlayerState_FireActiveStatusEffectEvent Parms{};

	Parms.statusEffectId = statusEffectId;
	Parms.Percentage = Percentage;
	Parms.iconFilePathIndex = iconFilePathIndex;
	Parms.levelToDisplay = levelToDisplay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.FireScoreEvent
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// EDBDScoreTypes                          ScoreType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PercentToAward                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::FireScoreEvent(EDBDScoreTypes ScoreType, float PercentToAward)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "FireScoreEvent");

	Params::DBDPlayerState_FireScoreEvent Parms{};

	Parms.ScoreType = ScoreType;
	Parms.PercentToAward = PercentToAward;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Multicast_FireGameplayEvent
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// EDBDScoreTypes                          playerGameplayEventType                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           effector                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::Multicast_FireGameplayEvent(EDBDScoreTypes playerGameplayEventType, float Amount, class AActor* effector, class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Multicast_FireGameplayEvent");

	Params::DBDPlayerState_Multicast_FireGameplayEvent Parms{};

	Parms.playerGameplayEventType = playerGameplayEventType;
	Parms.Amount = Amount;
	Parms.effector = effector;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Multicast_FireGameplayEventWithScore
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// EDBDScoreTypes                          playerGameplayEventType                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           effector                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAwardedScore&             AwardedScore                                           (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ADBDPlayerState::Multicast_FireGameplayEventWithScore(EDBDScoreTypes playerGameplayEventType, float Amount, class AActor* effector, class AActor* Target, const struct FAwardedScore& AwardedScore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Multicast_FireGameplayEventWithScore");

	Params::DBDPlayerState_Multicast_FireGameplayEventWithScore Parms{};

	Parms.playerGameplayEventType = playerGameplayEventType;
	Parms.Amount = Amount;
	Parms.effector = effector;
	Parms.Target = Target;
	Parms.AwardedScore = std::move(AwardedScore);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Multicast_FireGameplayEventWithTaggedScore
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// EDBDScoreTypes                          playerGameplayEventType                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           effector                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              ScoreTypeId                                            (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BloodpointsAwarded                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::Multicast_FireGameplayEventWithTaggedScore(EDBDScoreTypes playerGameplayEventType, float Amount, class AActor* effector, class AActor* Target, const struct FGameplayTag& ScoreTypeId, float BloodpointsAwarded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Multicast_FireGameplayEventWithTaggedScore");

	Params::DBDPlayerState_Multicast_FireGameplayEventWithTaggedScore Parms{};

	Parms.playerGameplayEventType = playerGameplayEventType;
	Parms.Amount = Amount;
	Parms.effector = effector;
	Parms.Target = Target;
	Parms.ScoreTypeId = std::move(ScoreTypeId);
	Parms.BloodpointsAwarded = BloodpointsAwarded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Multicast_SetAsDisconnected
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// EBotReplacementState                    botReplacementState                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::Multicast_SetAsDisconnected(EBotReplacementState botReplacementState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Multicast_SetAsDisconnected");

	Params::DBDPlayerState_Multicast_SetAsDisconnected Parms{};

	Parms.botReplacementState = botReplacementState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Multicast_SetAsLeftMatch
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// EBotReplacementState                    botReplacementState                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::Multicast_SetAsLeftMatch(EBotReplacementState botReplacementState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Multicast_SetAsLeftMatch");

	Params::DBDPlayerState_Multicast_SetAsLeftMatch Parms{};

	Parms.botReplacementState = botReplacementState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Multicast_SetInParadise
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void ADBDPlayerState::Multicast_SetInParadise()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Multicast_SetInParadise");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Multicast_SetPlayerGameState
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// EGameState                              newGameState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isEscapeHatch                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::Multicast_SetPlayerGameState(EGameState newGameState, bool isEscapeHatch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Multicast_SetPlayerGameState");

	Params::DBDPlayerState_Multicast_SetPlayerGameState Parms{};

	Parms.newGameState = newGameState;
	Parms.isEscapeHatch = isEscapeHatch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.OnRep_AvailableSurrenderType
// (Final, Native, Private)

void ADBDPlayerState::OnRep_AvailableSurrenderType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "OnRep_AvailableSurrenderType");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.OnRep_BotDifficultyLevel
// (Final, Native, Public)

void ADBDPlayerState::OnRep_BotDifficultyLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "OnRep_BotDifficultyLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.OnRep_BotInfo
// (Final, Native, Private)

void ADBDPlayerState::OnRep_BotInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "OnRep_BotInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.OnRep_CustomizationData
// (Native, Public)

void ADBDPlayerState::OnRep_CustomizationData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "OnRep_CustomizationData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.OnRep_DisplayData
// (Final, Native, Public)

void ADBDPlayerState::OnRep_DisplayData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "OnRep_DisplayData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Server_CheatSelectKiller
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   killerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::Server_CheatSelectKiller(int32 killerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Server_CheatSelectKiller");

	Params::DBDPlayerState_Server_CheatSelectKiller Parms{};

	Parms.killerIndex = killerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Server_CheatSelectSurvivor
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   survivorIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::Server_CheatSelectSurvivor(int32 survivorIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Server_CheatSelectSurvivor");

	Params::DBDPlayerState_Server_CheatSelectSurvivor Parms{};

	Parms.survivorIndex = survivorIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Server_SetQuestRepetitionByClientValue
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   Repetition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    QuestEventId                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    ChallengeId                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::Server_SetQuestRepetitionByClientValue(int32 Repetition, const class FString& QuestEventId, const class FString& ChallengeId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Server_SetQuestRepetitionByClientValue");

	Params::DBDPlayerState_Server_SetQuestRepetitionByClientValue Parms{};

	Parms.Repetition = Repetition;
	Parms.QuestEventId = std::move(QuestEventId);
	Parms.ChallengeId = std::move(ChallengeId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.UpdateOngoingScores
// (Final, Native, Protected)

void ADBDPlayerState::UpdateOngoingScores()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "UpdateOngoingScores");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.GetBotStateInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FDBDBotStateInfo           ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FDBDBotStateInfo ADBDPlayerState::GetBotStateInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "GetBotStateInfo");

	Params::DBDPlayerState_GetBotStateInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayerState.GetGameplayNotificationManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UGameplayNotificationManager*     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayNotificationManager* ADBDPlayerState::GetGameplayNotificationManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "GetGameplayNotificationManager");

	Params::DBDPlayerState_GetGameplayNotificationManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayerState.GetGameRole
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerRole                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerRole ADBDPlayerState::GetGameRole() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "GetGameRole");

	Params::DBDPlayerState_GetGameRole Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayerState.GetPlayerGameState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGameState                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGameState ADBDPlayerState::GetPlayerGameState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "GetPlayerGameState");

	Params::DBDPlayerState_GetPlayerGameState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayerState.HasEscaped
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayerState::HasEscaped() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "HasEscaped");

	Params::DBDPlayerState_HasEscaped Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayerState.IsInFinishedPlayingState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayerState::IsInFinishedPlayingState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "IsInFinishedPlayingState");

	Params::DBDPlayerState_IsInFinishedPlayingState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayerState.IsReplacementBot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayerState::IsReplacementBot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "IsReplacementBot");

	Params::DBDPlayerState_IsReplacementBot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PostProcessUpdate.PostProcessToggle
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    toggle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APostProcessUpdate::PostProcessToggle(bool toggle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PostProcessUpdate", "PostProcessToggle");

	Params::PostProcessUpdate_PostProcessToggle Parms{};

	Parms.toggle = toggle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.AnimationWidget.SetPlayRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationWidget::SetPlayRate(float Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationWidget", "SetPlayRate");

	Params::AnimationWidget_SetPlayRate Parms{};

	Parms.Rate = Rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AnimationWidget.GetPlayRate
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimationWidget::GetPlayRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationWidget", "GetPlayRate");

	Params::AnimationWidget_GetPlayRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterStatsHandlerComponent.InitializePreMatchStats
// (Final, Native, Private)

void UCharacterStatsHandlerComponent::InitializePreMatchStats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatsHandlerComponent", "InitializePreMatchStats");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterStatsHandlerComponent.OnGameEvent
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UCharacterStatsHandlerComponent::OnGameEvent(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatsHandlerComponent", "OnGameEvent");

	Params::CharacterStatsHandlerComponent_OnGameEvent Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterStatsHandlerComponent.ReceiveGameEvent
// (Final, Native, Public)
// Parameters:
// EDBDScoreTypes                          ScoreType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterStatsHandlerComponent::ReceiveGameEvent(EDBDScoreTypes ScoreType, float Amount, class AActor* Instigator, class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatsHandlerComponent", "ReceiveGameEvent");

	Params::CharacterStatsHandlerComponent_ReceiveGameEvent Parms{};

	Parms.ScoreType = ScoreType;
	Parms.Amount = Amount;
	Parms.Instigator = Instigator;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDUtilities.AddComponentToActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UClass*                           compClass                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             compName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorComponent* UDBDUtilities::AddComponentToActor(class UClass* compClass, class FName compName, class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "AddComponentToActor");

	Params::DBDUtilities_AddComponentToActor Parms{};

	Parms.compClass = compClass;
	Parms.compName = compName;
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.BoxTraceAgainstActor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UBoxComponent*              Box                                                    (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      outHitResult                                           (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::BoxTraceAgainstActor(const struct FVector& Start, const struct FVector& End, const class UBoxComponent* Box, const class AActor* Actor, struct FHitResult* outHitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "BoxTraceAgainstActor");

	Params::DBDUtilities_BoxTraceAgainstActor Parms{};

	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Box = Box;
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outHitResult != nullptr)
		*outHitResult = std::move(Parms.outHitResult);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.CancelSurvivorInteractionAndItemUse
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    requireInteractionBeCancelableOnHit                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::CancelSurvivorInteractionAndItemUse(class ASurvivor* Survivor, bool requireInteractionBeCancelableOnHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "CancelSurvivorInteractionAndItemUse");

	Params::DBDUtilities_CancelSurvivorInteractionAndItemUse Parms{};

	Parms.Survivor = Survivor;
	Parms.requireInteractionBeCancelableOnHit = requireInteractionBeCancelableOnHit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.CrashGameCausingInterrupt
// (Final, Native, Static, Public, BlueprintCallable)

void UDBDUtilities::CrashGameCausingInterrupt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "CrashGameCausingInterrupt");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDUtilities.DBDCapsuleTraceSingle
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::DBDCapsuleTraceSingle(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, ECollisionChannel TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "DBDCapsuleTraceSingle");

	Params::DBDUtilities_DBDCapsuleTraceSingle Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.DistanceFromPointToPane
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   Point                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPlane&                    Plane                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDUtilities::DistanceFromPointToPane(const struct FVector& Point, const struct FPlane& Plane)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "DistanceFromPointToPane");

	Params::DBDUtilities_DistanceFromPointToPane Parms{};

	Parms.Point = std::move(Point);
	Parms.Plane = std::move(Plane);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.FindFloorSingle
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   raycastLength                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::FindFloorSingle(const class UObject* WorldContextObject, const struct FVector& Location, float raycastLength, struct FHitResult* OutHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "FindFloorSingle");

	Params::DBDUtilities_FindFloorSingle Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Location = std::move(Location);
	Parms.raycastLength = raycastLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.FindParentOfClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InChild                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           InClass                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UDBDUtilities::FindParentOfClass(class AActor* InChild, class UClass* InClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "FindParentOfClass");

	Params::DBDUtilities_FindParentOfClass Parms{};

	Parms.InChild = InChild;
	Parms.InClass = InClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetActiveShadowSystem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EShadowSystem                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EShadowSystem UDBDUtilities::GetActiveShadowSystem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetActiveShadowSystem");

	Params::DBDUtilities_GetActiveShadowSystem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetActorOwnerName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDBDUtilities::GetActorOwnerName(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetActorOwnerName");

	Params::DBDUtilities_GetActorOwnerName Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetActorSpawners
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UActorSpawner*>*           actorSpawners                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDBDUtilities::GetActorSpawners(TArray<class UActorSpawner*>* actorSpawners)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetActorSpawners");

	Params::DBDUtilities_GetActorSpawners Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (actorSpawners != nullptr)
		*actorSpawners = std::move(Parms.actorSpawners);
}


// Function DeadByDaylight.DBDUtilities.GetAnimSequenceLength
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimSequence*              Sequence                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDUtilities::GetAnimSequenceLength(const class UAnimSequence* Sequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetAnimSequenceLength");

	Params::DBDUtilities_GetAnimSequenceLength Parms{};

	Parms.Sequence = Sequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetBuilder
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AProceduralLevelBuilder*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AProceduralLevelBuilder* UDBDUtilities::GetBuilder(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetBuilder");

	Params::DBDUtilities_GetBuilder Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetClosestGenerators
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class AGenerator*>&        unrevealedGenerators                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const int32                             closestGeneratorsCount                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AGenerator*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AGenerator*> UDBDUtilities::GetClosestGenerators(const TArray<class AGenerator*>& unrevealedGenerators, const int32 closestGeneratorsCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetClosestGenerators");

	Params::DBDUtilities_GetClosestGenerators Parms{};

	Parms.unrevealedGenerators = std::move(unrevealedGenerators);
	Parms.closestGeneratorsCount = closestGeneratorsCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetClosestPointOnOrbit
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   centerPoint                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   orbitterPosition                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Distance                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDBDUtilities::GetClosestPointOnOrbit(const struct FVector& centerPoint, const struct FVector& orbitterPosition, const float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetClosestPointOnOrbit");

	Params::DBDUtilities_GetClosestPointOnOrbit Parms{};

	Parms.centerPoint = std::move(centerPoint);
	Parms.orbitterPosition = std::move(orbitterPosition);
	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetClosestSnapTransformOnOrbit
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   centerPoint                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   orbitterPosition                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Distance                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UDBDUtilities::GetClosestSnapTransformOnOrbit(const struct FVector& centerPoint, const struct FVector& orbitterPosition, const float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetClosestSnapTransformOnOrbit");

	Params::DBDUtilities_GetClosestSnapTransformOnOrbit Parms{};

	Parms.centerPoint = std::move(centerPoint);
	Parms.orbitterPosition = std::move(orbitterPosition);
	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetClosestUnrepairedGenerator
// (Final, Native, Static, Public)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGenerator*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGenerator* UDBDUtilities::GetClosestUnrepairedGenerator(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetClosestUnrepairedGenerator");

	Params::DBDUtilities_GetClosestUnrepairedGenerator Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetComponentOwnerName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UActorComponent*                  ActorComponent                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDBDUtilities::GetComponentOwnerName(class UActorComponent* ActorComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetComponentOwnerName");

	Params::DBDUtilities_GetComponentOwnerName Parms{};

	Parms.ActorComponent = ActorComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetDBDAIPlayerController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDAIPlayerController*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDAIPlayerController* UDBDUtilities::GetDBDAIPlayerController(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetDBDAIPlayerController");

	Params::DBDUtilities_GetDBDAIPlayerController Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetDBDGameInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDBDGameInstance*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDBDGameInstance* UDBDUtilities::GetDBDGameInstance(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetDBDGameInstance");

	Params::DBDUtilities_GetDBDGameInstance Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetDBDGameMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDGameMode*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDGameMode* UDBDUtilities::GetDBDGameMode(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetDBDGameMode");

	Params::DBDUtilities_GetDBDGameMode Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetDBDGameState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDGameState*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDGameState* UDBDUtilities::GetDBDGameState(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetDBDGameState");

	Params::DBDUtilities_GetDBDGameState Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetDistanceToNearestHookedSurvivor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDUtilities::GetDistanceToNearestHookedSurvivor(const class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetDistanceToNearestHookedSurvivor");

	Params::DBDUtilities_GetDistanceToNearestHookedSurvivor Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetEndGameTunableValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             valueName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDUtilities::GetEndGameTunableValue(const class UObject* WorldContextObject, class FName valueName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetEndGameTunableValue");

	Params::DBDUtilities_GetEndGameTunableValue Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.valueName = valueName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetFirstActorWithTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            actorsArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UDBDUtilities::GetFirstActorWithTag(class FName Tag, const TArray<class AActor*>& actorsArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetFirstActorWithTag");

	Params::DBDUtilities_GetFirstActorWithTag Parms{};

	Parms.Tag = Tag;
	Parms.actorsArray = std::move(actorsArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetFloorLocationAt
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   raycastStartHeight                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   raycastEndHeight                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    useComplex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDBDUtilities::GetFloorLocationAt(class UObject* WorldContextObject, const struct FVector& Location, float raycastStartHeight, float raycastEndHeight, bool useComplex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetFloorLocationAt");

	Params::DBDUtilities_GetFloorLocationAt Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Location = std::move(Location);
	Parms.raycastStartHeight = raycastStartHeight;
	Parms.raycastEndHeight = raycastEndHeight;
	Parms.useComplex = useComplex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetFormattedNumberString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   maxDecimals                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   minDecimals                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    leadingZero                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDBDUtilities::GetFormattedNumberString(float Value, int32 maxDecimals, int32 minDecimals, bool leadingZero)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetFormattedNumberString");

	Params::DBDUtilities_GetFormattedNumberString Parms{};

	Parms.Value = Value;
	Parms.maxDecimals = maxDecimals;
	Parms.minDecimals = minDecimals;
	Parms.leadingZero = leadingZero;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetFormattedNumberText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   maxDecimals                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   minDecimals                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    leadingZero                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDBDUtilities::GetFormattedNumberText(float Value, int32 maxDecimals, int32 minDecimals, bool leadingZero)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetFormattedNumberText");

	Params::DBDUtilities_GetFormattedNumberText Parms{};

	Parms.Value = Value;
	Parms.maxDecimals = maxDecimals;
	Parms.minDecimals = minDecimals;
	Parms.leadingZero = leadingZero;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetImpactCollisionObjectType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UPrimitiveComponent*        Primitive                                              (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECollisionChannel UDBDUtilities::GetImpactCollisionObjectType(const class UPrimitiveComponent* Primitive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetImpactCollisionObjectType");

	Params::DBDUtilities_GetImpactCollisionObjectType Parms{};

	Parms.Primitive = Primitive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetImpactCollisionResponseContainer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UPrimitiveComponent*        Primitive                                              (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCollisionResponseContainer      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCollisionResponseContainer UDBDUtilities::GetImpactCollisionResponseContainer(const class UPrimitiveComponent* Primitive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetImpactCollisionResponseContainer");

	Params::DBDUtilities_GetImpactCollisionResponseContainer Parms{};

	Parms.Primitive = Primitive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetInventoryCount
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   characterIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ItemId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDBDUtilities::GetInventoryCount(const class UObject* WorldContextObject, int32 characterIndex, class FName ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetInventoryCount");

	Params::DBDUtilities_GetInventoryCount Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.characterIndex = characterIndex;
	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetInventoryCountForMultipleCharacters
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<int32>&                    characterIndexes                                       (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class FName                             ItemId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDBDUtilities::GetInventoryCountForMultipleCharacters(const class UObject* WorldContextObject, const TArray<int32>& characterIndexes, class FName ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetInventoryCountForMultipleCharacters");

	Params::DBDUtilities_GetInventoryCountForMultipleCharacters Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.characterIndexes = std::move(characterIndexes);
	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetLocalDBDCameraManager
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayerCameraManager*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayerCameraManager* UDBDUtilities::GetLocalDBDCameraManager(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetLocalDBDCameraManager");

	Params::DBDUtilities_GetLocalDBDCameraManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetLocalDBDPlayerController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayerControllerBase*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayerControllerBase* UDBDUtilities::GetLocalDBDPlayerController(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetLocalDBDPlayerController");

	Params::DBDUtilities_GetLocalDBDPlayerController Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetLocallyControlledCharacter
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UDBDUtilities::GetLocallyControlledCharacter(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetLocallyControlledCharacter");

	Params::DBDUtilities_GetLocallyControlledCharacter Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetLocallyControlledCharacterRole
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerRole                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerRole UDBDUtilities::GetLocallyControlledCharacterRole(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetLocallyControlledCharacterRole");

	Params::DBDUtilities_GetLocallyControlledCharacterRole Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetLocallyControlledKiller
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AKiller*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AKiller* UDBDUtilities::GetLocallyControlledKiller(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetLocallyControlledKiller");

	Params::DBDUtilities_GetLocallyControlledKiller Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetLocallyControlledSurvivor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASurvivor*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASurvivor* UDBDUtilities::GetLocallyControlledSurvivor(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetLocallyControlledSurvivor");

	Params::DBDUtilities_GetLocallyControlledSurvivor Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetLocallyObservedCharacter
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UDBDUtilities::GetLocallyObservedCharacter(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetLocallyObservedCharacter");

	Params::DBDUtilities_GetLocallyObservedCharacter Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetLocallyObservedCharacterRole
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerRole                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerRole UDBDUtilities::GetLocallyObservedCharacterRole(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetLocallyObservedCharacterRole");

	Params::DBDUtilities_GetLocallyObservedCharacterRole Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetLogStringMaterialInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    inStr                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UMaterialInterface*         Root                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDBDUtilities::GetLogStringMaterialInfo(const class FString& inStr, const class UMaterialInterface* Root)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetLogStringMaterialInfo");

	Params::DBDUtilities_GetLogStringMaterialInfo Parms{};

	Parms.inStr = std::move(inStr);
	Parms.Root = Root;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetMaterialHelpersAttachedToPlayerMesh
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UMaterialHelper*>          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UMaterialHelper*> UDBDUtilities::GetMaterialHelpersAttachedToPlayerMesh(const class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetMaterialHelpersAttachedToPlayerMesh");

	Params::DBDUtilities_GetMaterialHelpersAttachedToPlayerMesh Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetMontageLength
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDUtilities::GetMontageLength(class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetMontageLength");

	Params::DBDUtilities_GetMontageLength Parms{};

	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetNearbyActorsOfType
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Center                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>*                  outNearbyActors                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UClass*                           actorClassType                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       CollisionChannel                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           IgnoreActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::GetNearbyActorsOfType(class UWorld* World, const struct FVector& Center, float Radius, TArray<class AActor*>* outNearbyActors, class UClass* actorClassType, ECollisionChannel CollisionChannel, class AActor* IgnoreActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetNearbyActorsOfType");

	Params::DBDUtilities_GetNearbyActorsOfType Parms{};

	Parms.World = World;
	Parms.Center = std::move(Center);
	Parms.Radius = Radius;
	Parms.actorClassType = actorClassType;
	Parms.CollisionChannel = CollisionChannel;
	Parms.IgnoreActor = IgnoreActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outNearbyActors != nullptr)
		*outNearbyActors = std::move(Parms.outNearbyActors);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetNearbyCampers
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Center                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ASurvivor*>*               outNearbyCampers                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            ignoredCampers                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UDBDUtilities::GetNearbyCampers(class UWorld* World, const struct FVector& Center, float Radius, TArray<class ASurvivor*>* outNearbyCampers, const TArray<class AActor*>& ignoredCampers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetNearbyCampers");

	Params::DBDUtilities_GetNearbyCampers Parms{};

	Parms.World = World;
	Parms.Center = std::move(Center);
	Parms.Radius = Radius;
	Parms.ignoredCampers = std::move(ignoredCampers);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outNearbyCampers != nullptr)
		*outNearbyCampers = std::move(Parms.outNearbyCampers);
}


// Function DeadByDaylight.DBDUtilities.GetNextPowerOf2
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDBDUtilities::GetNextPowerOf2(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetNextPowerOf2");

	Params::DBDUtilities_GetNextPowerOf2 Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetOuterMostActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimInstance*              AnimInstance                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UDBDUtilities::GetOuterMostActor(const class UAnimInstance* AnimInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetOuterMostActor");

	Params::DBDUtilities_GetOuterMostActor Parms{};

	Parms.AnimInstance = AnimInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetOwningCamper
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimInstance*              AnimInstance                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASurvivor*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASurvivor* UDBDUtilities::GetOwningCamper(const class UAnimInstance* AnimInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetOwningCamper");

	Params::DBDUtilities_GetOwningCamper Parms{};

	Parms.AnimInstance = AnimInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetOwningDBDBasePlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimInstance*              AnimInstance                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDBasePlayer*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDBasePlayer* UDBDUtilities::GetOwningDBDBasePlayer(const class UAnimInstance* AnimInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetOwningDBDBasePlayer");

	Params::DBDUtilities_GetOwningDBDBasePlayer Parms{};

	Parms.AnimInstance = AnimInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetOwningDBDBasePlayerFromActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    recursiveSearch                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDBasePlayer*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDBasePlayer* UDBDUtilities::GetOwningDBDBasePlayerFromActor(const class AActor* Actor, bool recursiveSearch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetOwningDBDBasePlayerFromActor");

	Params::DBDUtilities_GetOwningDBDBasePlayerFromActor Parms{};

	Parms.Actor = Actor;
	Parms.recursiveSearch = recursiveSearch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetOwningKillerFromActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    recursiveSearch                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AKiller*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AKiller* UDBDUtilities::GetOwningKillerFromActor(const class AActor* Actor, bool recursiveSearch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetOwningKillerFromActor");

	Params::DBDUtilities_GetOwningKillerFromActor Parms{};

	Parms.Actor = Actor;
	Parms.recursiveSearch = recursiveSearch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetOwningSlasher
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimInstance*              AnimInstance                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AKiller*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AKiller* UDBDUtilities::GetOwningSlasher(const class UAnimInstance* AnimInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetOwningSlasher");

	Params::DBDUtilities_GetOwningSlasher Parms{};

	Parms.AnimInstance = AnimInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetOwningSurvivorFromActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    recursiveSearch                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASurvivor*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASurvivor* UDBDUtilities::GetOwningSurvivorFromActor(const class AActor* Actor, bool recursiveSearch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetOwningSurvivorFromActor");

	Params::DBDUtilities_GetOwningSurvivorFromActor Parms{};

	Parms.Actor = Actor;
	Parms.recursiveSearch = recursiveSearch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetPercentOfRange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const float                             Val                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Min                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Max                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDUtilities::GetPercentOfRange(const float Val, const float Min, const float Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetPercentOfRange");

	Params::DBDUtilities_GetPercentOfRange Parms{};

	Parms.Val = Val;
	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetPlayRateForMontage
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDUtilities::GetPlayRateForMontage(class UAnimMontage* Montage, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetPlayRateForMontage");

	Params::DBDUtilities_GetPlayRateForMontage Parms{};

	Parms.Montage = Montage;
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetSimilarVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   Vector                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   maximumDeviation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDBDUtilities::GetSimilarVector(const struct FVector& Vector, float maximumDeviation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetSimilarVector");

	Params::DBDUtilities_GetSimilarVector Parms{};

	Parms.Vector = std::move(Vector);
	Parms.maximumDeviation = maximumDeviation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetSlasherTunableValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             valueName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDUtilities::GetSlasherTunableValue(const class UObject* WorldContextObject, class FName valueName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetSlasherTunableValue");

	Params::DBDUtilities_GetSlasherTunableValue Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.valueName = valueName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetSquaredDistanceToKiller
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDUtilities::GetSquaredDistanceToKiller(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetSquaredDistanceToKiller");

	Params::DBDUtilities_GetSquaredDistanceToKiller Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetTileSpawnPoints
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UTileSpawnPoint*>*         tileSpawnPoints                                        (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDBDUtilities::GetTileSpawnPoints(TArray<class UTileSpawnPoint*>* tileSpawnPoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetTileSpawnPoints");

	Params::DBDUtilities_GetTileSpawnPoints Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (tileSpawnPoints != nullptr)
		*tileSpawnPoints = std::move(Parms.tileSpawnPoints);
}


// Function DeadByDaylight.DBDUtilities.GetTotalPlaytime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Update                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UDBDUtilities::GetTotalPlaytime(const class UObject* WorldContextObject, bool Update)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetTotalPlaytime");

	Params::DBDUtilities_GetTotalPlaytime Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Update = Update;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetVelocityXYAngleDegrees
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDUtilities::GetVelocityXYAngleDegrees(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetVelocityXYAngleDegrees");

	Params::DBDUtilities_GetVelocityXYAngleDegrees Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetXYVector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Vector                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDBDUtilities::GetXYVector(const struct FVector& Vector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetXYVector");

	Params::DBDUtilities_GetXYVector Parms{};

	Parms.Vector = std::move(Vector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetYawOnly
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FRotator&                  Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UDBDUtilities::GetYawOnly(const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetYawOnly");

	Params::DBDUtilities_GetYawOnly Parms{};

	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.HasFloorForward
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   fowardVector                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   raycastStartHeight                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   raycastEndHeight                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>*              OutHits                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector*                         raycastStart                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::HasFloorForward(class UObject* WorldContextObject, const struct FVector& Location, const struct FVector& fowardVector, float Distance, float raycastStartHeight, float raycastEndHeight, TArray<struct FHitResult>* OutHits, struct FVector* raycastStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "HasFloorForward");

	Params::DBDUtilities_HasFloorForward Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Location = std::move(Location);
	Parms.fowardVector = std::move(fowardVector);
	Parms.Distance = Distance;
	Parms.raycastStartHeight = raycastStartHeight;
	Parms.raycastEndHeight = raycastEndHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	if (raycastStart != nullptr)
		*raycastStart = std::move(Parms.raycastStart);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.HasLineOfSightToTarget
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   StartPosition                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   TargetPosition                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     ignoredActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              useComplex                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              useDebugLogs                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::HasLineOfSightToTarget(class UObject* WorldContextObject, const struct FVector& StartPosition, const struct FVector& TargetPosition, const class AActor* ignoredActor, const bool useComplex, const bool useDebugLogs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "HasLineOfSightToTarget");

	Params::DBDUtilities_HasLineOfSightToTarget Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.StartPosition = std::move(StartPosition);
	Parms.TargetPosition = std::move(TargetPosition);
	Parms.ignoredActor = ignoredActor;
	Parms.useComplex = useComplex;
	Parms.useDebugLogs = useDebugLogs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.HasWalkableSurfaceForward
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   fowardVector                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   raycastStartHeight                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   raycastEndHeight                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>*              OutHits                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector*                         raycastStart                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::HasWalkableSurfaceForward(class UObject* WorldContextObject, const struct FVector& Location, const struct FVector& fowardVector, float Distance, float raycastStartHeight, float raycastEndHeight, TArray<struct FHitResult>* OutHits, struct FVector* raycastStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "HasWalkableSurfaceForward");

	Params::DBDUtilities_HasWalkableSurfaceForward Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Location = std::move(Location);
	Parms.fowardVector = std::move(fowardVector);
	Parms.Distance = Distance;
	Parms.raycastStartHeight = raycastStartHeight;
	Parms.raycastEndHeight = raycastEndHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	if (raycastStart != nullptr)
		*raycastStart = std::move(Parms.raycastStart);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.IsClassChildOfOtherClasses
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UClass*                     classToCheck                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class UClass*>&            otherClasses                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::IsClassChildOfOtherClasses(const class UClass* classToCheck, const TArray<class UClass*>& otherClasses)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "IsClassChildOfOtherClasses");

	Params::DBDUtilities_IsClassChildOfOtherClasses Parms{};

	Parms.classToCheck = classToCheck;
	Parms.otherClasses = std::move(otherClasses);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.IsInKillerTeam
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::IsInKillerTeam(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "IsInKillerTeam");

	Params::DBDUtilities_IsInKillerTeam Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.IsInSurvivorTeam
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::IsInSurvivorTeam(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "IsInSurvivorTeam");

	Params::DBDUtilities_IsInSurvivorTeam Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.IsInTutorialLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::IsInTutorialLevel(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "IsInTutorialLevel");

	Params::DBDUtilities_IsInTutorialLevel Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.IsLocallyObservedCharacterInRange
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Target                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Range                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::IsLocallyObservedCharacterInRange(const class AActor* Target, const float Range)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "IsLocallyObservedCharacterInRange");

	Params::DBDUtilities_IsLocallyObservedCharacterInRange Parms{};

	Parms.Target = Target;
	Parms.Range = Range;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.IsLocallyObservingAKiller
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::IsLocallyObservingAKiller(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "IsLocallyObservingAKiller");

	Params::DBDUtilities_IsLocallyObservingAKiller Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.IsLocallyObservingASurvivor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::IsLocallyObservingASurvivor(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "IsLocallyObservingASurvivor");

	Params::DBDUtilities_IsLocallyObservingASurvivor Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.IsNonViolent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::IsNonViolent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "IsNonViolent");

	Params::DBDUtilities_IsNonViolent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.IsReplaceDisconnectedPlayersWithBotsActive
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::IsReplaceDisconnectedPlayersWithBotsActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "IsReplaceDisconnectedPlayersWithBotsActive");

	Params::DBDUtilities_IsReplaceDisconnectedPlayersWithBotsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.IsServer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::IsServer(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "IsServer");

	Params::DBDUtilities_IsServer Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.IsSteamPIEGame
// (Final, Native, Static, Public)
// Parameters:
// const class UObject*                    contextObject                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::IsSteamPIEGame(const class UObject* contextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "IsSteamPIEGame");

	Params::DBDUtilities_IsSteamPIEGame Parms{};

	Parms.contextObject = contextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.KillerInterruptSurvivorInteraction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AKiller*                          Killer                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    requireInteractionBeCancelableOnHit                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::KillerInterruptSurvivorInteraction(class AKiller* Killer, class ASurvivor* Survivor, bool requireInteractionBeCancelableOnHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "KillerInterruptSurvivorInteraction");

	Params::DBDUtilities_KillerInterruptSurvivorInteraction Parms{};

	Parms.Killer = Killer;
	Parms.Survivor = Survivor;
	Parms.requireInteractionBeCancelableOnHit = requireInteractionBeCancelableOnHit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.LogMeshMaterialInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    inStr                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UMeshComponent*             Root                                                   (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDUtilities::LogMeshMaterialInfo(const class FString& inStr, const class UMeshComponent* Root)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "LogMeshMaterialInfo");

	Params::DBDUtilities_LogMeshMaterialInfo Parms{};

	Parms.inStr = std::move(inStr);
	Parms.Root = Root;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDUtilities.LogString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    inStr                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDUtilities::LogString(const class FString& inStr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "LogString");

	Params::DBDUtilities_LogString Parms{};

	Parms.inStr = std::move(inStr);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDUtilities.NormalizeXY
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector*                         Vector                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::NormalizeXY(struct FVector* Vector, float Tolerance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "NormalizeXY");

	Params::DBDUtilities_NormalizeXY Parms{};

	Parms.Tolerance = Tolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Vector != nullptr)
		*Vector = std::move(Parms.Vector);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.PointerToInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Obj                                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UDBDUtilities::PointerToInt(class UObject* Obj)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "PointerToInt");

	Params::DBDUtilities_PointerToInt Parms{};

	Parms.Obj = Obj;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.PrintStringEmbiggened
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              TextColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDUtilities::PrintStringEmbiggened(const class UObject* WorldContextObject, const class FString& InString, const struct FLinearColor& TextColor, float Duration, int32 Key, float Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "PrintStringEmbiggened");

	Params::DBDUtilities_PrintStringEmbiggened Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InString = std::move(InString);
	Parms.TextColor = std::move(TextColor);
	Parms.Duration = Duration;
	Parms.Key = Key;
	Parms.Scale = Scale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDUtilities.ResolveCharacterIdFromPlayerState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class ADBDPlayerState*            PlayerState                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDBDUtilities::ResolveCharacterIdFromPlayerState(const class ADBDPlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "ResolveCharacterIdFromPlayerState");

	Params::DBDUtilities_ResolveCharacterIdFromPlayerState Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.Saturate
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDUtilities::Saturate(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "Saturate");

	Params::DBDUtilities_Saturate Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.SetComponentCastHiddenShadow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CastShadow                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDUtilities::SetComponentCastHiddenShadow(class UPrimitiveComponent* Component, bool CastShadow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "SetComponentCastHiddenShadow");

	Params::DBDUtilities_SetComponentCastHiddenShadow Parms{};

	Parms.Component = Component;
	Parms.CastShadow = CastShadow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDUtilities.SphereTraceAgainstActor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class USphereComponent*           Sphere                                                 (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      outHitResult                                           (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::SphereTraceAgainstActor(const struct FVector& Start, const struct FVector& End, const class USphereComponent* Sphere, const class AActor* Actor, struct FHitResult* outHitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "SphereTraceAgainstActor");

	Params::DBDUtilities_SphereTraceAgainstActor Parms{};

	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Sphere = Sphere;
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outHitResult != nullptr)
		*outHitResult = std::move(Parms.outHitResult);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.SphereTraceSingle
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class USphereComponent*           Sphere                                                 (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      outHitResult                                           (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            IgnoredActors                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::SphereTraceSingle(const struct FVector& Start, const struct FVector& End, const class USphereComponent* Sphere, struct FHitResult* outHitResult, const TArray<class AActor*>& IgnoredActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "SphereTraceSingle");

	Params::DBDUtilities_SphereTraceSingle Parms{};

	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Sphere = Sphere;
	Parms.IgnoredActors = std::move(IgnoredActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outHitResult != nullptr)
		*outHitResult = std::move(Parms.outHitResult);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.ToAngle_negative180to180
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Angle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDUtilities::ToAngle_negative180to180(float Angle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "ToAngle_negative180to180");

	Params::DBDUtilities_ToAngle_negative180to180 Parms{};

	Parms.Angle = Angle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.WithinRange
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::WithinRange(float Min, float Max, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "WithinRange");

	Params::DBDUtilities_WithinRange Parms{};

	Parms.Min = Min;
	Parms.Max = Max;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.WithinRangeExclusive
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::WithinRangeExclusive(float Min, float Max, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "WithinRangeExclusive");

	Params::DBDUtilities_WithinRangeExclusive Parms{};

	Parms.Min = Min;
	Parms.Max = Max;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameUserSettings.GetDBDGameUserSettings
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UDBDGameUserSettings*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDBDGameUserSettings* UDBDGameUserSettings::GetDBDGameUserSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDGameUserSettings", "GetDBDGameUserSettings");

	Params::DBDGameUserSettings_GetDBDGameUserSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameUserSettings.GetBloodwebInteractionBehaviour
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDGameUserSettings::GetBloodwebInteractionBehaviour() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameUserSettings", "GetBloodwebInteractionBehaviour");

	Params::DBDGameUserSettings_GetBloodwebInteractionBehaviour Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameUserSettings.GetColorBlindMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EColorVisionDeficiency                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EColorVisionDeficiency UDBDGameUserSettings::GetColorBlindMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameUserSettings", "GetColorBlindMode");

	Params::DBDGameUserSettings_GetColorBlindMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameUserSettings.GetColorBlindModeIntensity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDBDGameUserSettings::GetColorBlindModeIntensity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameUserSettings", "GetColorBlindModeIntensity");

	Params::DBDGameUserSettings_GetColorBlindModeIntensity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameUserSettings.GetDeepWoundBarVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDGameUserSettings::GetDeepWoundBarVisibility() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameUserSettings", "GetDeepWoundBarVisibility");

	Params::DBDGameUserSettings_GetDeepWoundBarVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameUserSettings.GetFieldOfView
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDBDGameUserSettings::GetFieldOfView() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameUserSettings", "GetFieldOfView");

	Params::DBDGameUserSettings_GetFieldOfView Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameUserSettings.GetHUDKillerHookCountVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDGameUserSettings::GetHUDKillerHookCountVisibility() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameUserSettings", "GetHUDKillerHookCountVisibility");

	Params::DBDGameUserSettings_GetHUDKillerHookCountVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameUserSettings.GetHUDPlayerNamesVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDGameUserSettings::GetHUDPlayerNamesVisibility() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameUserSettings", "GetHUDPlayerNamesVisibility");

	Params::DBDGameUserSettings_GetHUDPlayerNamesVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameUserSettings.GetHudScaleFactor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDBDGameUserSettings::GetHudScaleFactor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameUserSettings", "GetHudScaleFactor");

	Params::DBDGameUserSettings_GetHudScaleFactor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameUserSettings.GetHUDScoreEventsVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDGameUserSettings::GetHUDScoreEventsVisibility() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameUserSettings", "GetHUDScoreEventsVisibility");

	Params::DBDGameUserSettings_GetHUDScoreEventsVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameUserSettings.GetHUDUseItemPickupPopupAbridgedVersion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDGameUserSettings::GetHUDUseItemPickupPopupAbridgedVersion() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameUserSettings", "GetHUDUseItemPickupPopupAbridgedVersion");

	Params::DBDGameUserSettings_GetHUDUseItemPickupPopupAbridgedVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameUserSettings.GetLargeText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDGameUserSettings::GetLargeText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameUserSettings", "GetLargeText");

	Params::DBDGameUserSettings_GetLargeText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameUserSettings.GetLegacyPrestigePortraits
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDGameUserSettings::GetLegacyPrestigePortraits() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameUserSettings", "GetLegacyPrestigePortraits");

	Params::DBDGameUserSettings_GetLegacyPrestigePortraits Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameUserSettings.GetMenuScaleFactor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDBDGameUserSettings::GetMenuScaleFactor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameUserSettings", "GetMenuScaleFactor");

	Params::DBDGameUserSettings_GetMenuScaleFactor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameUserSettings.GetSkillCheckScaleFactor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDBDGameUserSettings::GetSkillCheckScaleFactor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameUserSettings", "GetSkillCheckScaleFactor");

	Params::DBDGameUserSettings_GetSkillCheckScaleFactor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameUserSettings.GetTerrorRadiusVisualFeedback
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDGameUserSettings::GetTerrorRadiusVisualFeedback() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameUserSettings", "GetTerrorRadiusVisualFeedback");

	Params::DBDGameUserSettings_GetTerrorRadiusVisualFeedback Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameUserSettings.GetTomesChallengeNotification
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EChallengeTrackerNotificationMode       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EChallengeTrackerNotificationMode UDBDGameUserSettings::GetTomesChallengeNotification() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameUserSettings", "GetTomesChallengeNotification");

	Params::DBDGameUserSettings_GetTomesChallengeNotification Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TutorialsUtilities.DestroyAI
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAIController*                    AIController                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialsUtilities::DestroyAI(class AAIController* AIController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TutorialsUtilities", "DestroyAI");

	Params::TutorialsUtilities_DestroyAI Parms{};

	Parms.AIController = AIController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialsUtilities.GetTutorialsUtilities
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATutorialsUtilities*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATutorialsUtilities* ATutorialsUtilities::GetTutorialsUtilities(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TutorialsUtilities", "GetTutorialsUtilities");

	Params::TutorialsUtilities_GetTutorialsUtilities Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TutorialsUtilities.TriggerTutorialHudFadeIn
// (Final, Native, Public, BlueprintCallable)

void ATutorialsUtilities::TriggerTutorialHudFadeIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialsUtilities", "TriggerTutorialHudFadeIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialsUtilities.TriggerTutorialHudFadeOut
// (Final, Native, Public, BlueprintCallable)

void ATutorialsUtilities::TriggerTutorialHudFadeOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialsUtilities", "TriggerTutorialHudFadeOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterUtilities.GetActorLocationFromFeetLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ACharacter*                 Character                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   feetLocation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCharacterUtilities::GetActorLocationFromFeetLocation(const class ACharacter* Character, const struct FVector& feetLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterUtilities", "GetActorLocationFromFeetLocation");

	Params::CharacterUtilities_GetActorLocationFromFeetLocation Parms{};

	Parms.Character = Character;
	Parms.feetLocation = std::move(feetLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterUtilities.GetFeetPosition
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ACharacter*                 Character                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCharacterUtilities::GetFeetPosition(const class ACharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterUtilities", "GetFeetPosition");

	Params::CharacterUtilities_GetFeetPosition Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterUtilities.GetFeetPositionAtTargetLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ACharacter*                 Character                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCharacterUtilities::GetFeetPositionAtTargetLocation(const class ACharacter* Character, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterUtilities", "GetFeetPositionAtTargetLocation");

	Params::CharacterUtilities_GetFeetPositionAtTargetLocation Parms{};

	Parms.Character = Character;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableComponent.Authority_AddCharge
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ChargeAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    BypassSkillCheckFail                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsOneTimeIncrease                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isChargeWithItem                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableComponent::Authority_AddCharge(float ChargeAmount, class AActor* Instigator, bool BypassSkillCheckFail, bool IsOneTimeIncrease, bool isChargeWithItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "Authority_AddCharge");

	Params::ChargeableComponent_Authority_AddCharge Parms{};

	Parms.ChargeAmount = ChargeAmount;
	Parms.Instigator = Instigator;
	Parms.BypassSkillCheckFail = BypassSkillCheckFail;
	Parms.IsOneTimeIncrease = IsOneTimeIncrease;
	Parms.isChargeWithItem = isChargeWithItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableComponent.Authority_AddChargePercent
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ChargePercent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    BypassSkillCheckFail                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsOneTimeIncrease                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isChargeWithItem                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableComponent::Authority_AddChargePercent(float ChargePercent, class AActor* Instigator, bool BypassSkillCheckFail, bool IsOneTimeIncrease, bool isChargeWithItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "Authority_AddChargePercent");

	Params::ChargeableComponent_Authority_AddChargePercent Parms{};

	Parms.ChargePercent = ChargePercent;
	Parms.Instigator = Instigator;
	Parms.BypassSkillCheckFail = BypassSkillCheckFail;
	Parms.IsOneTimeIncrease = IsOneTimeIncrease;
	Parms.isChargeWithItem = isChargeWithItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableComponent.Authority_ApplyStartingCharge
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UChargeableComponent::Authority_ApplyStartingCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "Authority_ApplyStartingCharge");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableComponent.Authority_Reset
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UChargeableComponent::Authority_Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "Authority_Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableComponent.Authority_SetEnableAddCharge
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              Enable                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableComponent::Authority_SetEnableAddCharge(const bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "Authority_SetEnableAddCharge");

	Params::ChargeableComponent_Authority_SetEnableAddCharge Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableComponent.Authority_SetEnableSkillCheckFailurePenalty
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              Enable                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableComponent::Authority_SetEnableSkillCheckFailurePenalty(const bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "Authority_SetEnableSkillCheckFailurePenalty");

	Params::ChargeableComponent_Authority_SetEnableSkillCheckFailurePenalty Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableComponent.IncreaseMaxCharge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Percent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableComponent::IncreaseMaxCharge(float Percent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "IncreaseMaxCharge");

	Params::ChargeableComponent_IncreaseMaxCharge Parms{};

	Parms.Percent = Percent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableComponent.Multicast_SetPermanentCharge
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// float                                   ChargePercent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableComponent::Multicast_SetPermanentCharge(float ChargePercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "Multicast_SetPermanentCharge");

	Params::ChargeableComponent_Multicast_SetPermanentCharge Parms{};

	Parms.ChargePercent = ChargePercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableComponent.OnCurrentChargeChanged
// (Final, Native, Private)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableComponent::OnCurrentChargeChanged(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "OnCurrentChargeChanged");

	Params::ChargeableComponent_OnCurrentChargeChanged Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableComponent.OnRep_CurrentCharge
// (Final, Native, Private)

void UChargeableComponent::OnRep_CurrentCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "OnRep_CurrentCharge");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableComponent.SetDechargeRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   dechargeRate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableComponent::SetDechargeRate(float dechargeRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "SetDechargeRate");

	Params::ChargeableComponent_SetDechargeRate Parms{};

	Parms.dechargeRate = dechargeRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableComponent.SetSecondsToCharge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   SecondsToCharge                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableComponent::SetSecondsToCharge(float SecondsToCharge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "SetSecondsToCharge");

	Params::ChargeableComponent_SetSecondsToCharge Parms{};

	Parms.SecondsToCharge = SecondsToCharge;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableComponent.GetChargeRemaining
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableComponent::GetChargeRemaining() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "GetChargeRemaining");

	Params::ChargeableComponent_GetChargeRemaining Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableComponent.GetChargingSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableComponent::GetChargingSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "GetChargingSpeed");

	Params::ChargeableComponent_GetChargingSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableComponent.GetCurrentCharge
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableComponent::GetCurrentCharge() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "GetCurrentCharge");

	Params::ChargeableComponent_GetCurrentCharge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableComponent.GetMaxCharge
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableComponent::GetMaxCharge() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "GetMaxCharge");

	Params::ChargeableComponent_GetMaxCharge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableComponent.GetPercentComplete
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableComponent::GetPercentComplete() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "GetPercentComplete");

	Params::ChargeableComponent_GetPercentComplete Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableComponent.GetPermanentChargePercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableComponent::GetPermanentChargePercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "GetPermanentChargePercent");

	Params::ChargeableComponent_GetPermanentChargePercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableComponent.GetPlayerCountPenaltyModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PlayerCount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableComponent::GetPlayerCountPenaltyModifier(int32 PlayerCount) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "GetPlayerCountPenaltyModifier");

	Params::ChargeableComponent_GetPlayerCountPenaltyModifier Parms{};

	Parms.PlayerCount = PlayerCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableComponent.GetTunableValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             tunableValueID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableComponent::GetTunableValue(class FName tunableValueID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "GetTunableValue");

	Params::ChargeableComponent_GetTunableValue Parms{};

	Parms.tunableValueID = tunableValueID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableComponent.HasPlayerDoneSkillCheck
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UChargeableComponent::HasPlayerDoneSkillCheck(int32 PlayerId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "HasPlayerDoneSkillCheck");

	Params::ChargeableComponent_HasPlayerDoneSkillCheck Parms{};

	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableComponent.IsChargeComplete
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UChargeableComponent::IsChargeComplete() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "IsChargeComplete");

	Params::ChargeableComponent_IsChargeComplete Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableComponent.IsSkillCheckTimePenaltyActive
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UChargeableComponent::IsSkillCheckTimePenaltyActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "IsSkillCheckTimePenaltyActive");

	Params::ChargeableComponent_IsSkillCheckTimePenaltyActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableComponent.Multicast_OnCompleteChanged
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, Const)
// Parameters:
// bool                                    COMPLETED                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableComponent::Multicast_OnCompleteChanged(bool COMPLETED) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "Multicast_OnCompleteChanged");

	Params::ChargeableComponent_Multicast_OnCompleteChanged Parms{};

	Parms.COMPLETED = COMPLETED;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableComponent.Multicast_OnEmptied
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, Const)

void UChargeableComponent::Multicast_OnEmptied() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "Multicast_OnEmptied");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargedAttackStateComponent.SetChargingPercent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ChargePercent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargedAttackStateComponent::SetChargingPercent(float ChargePercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargedAttackStateComponent", "SetChargingPercent");

	Params::ChargedAttackStateComponent_SetChargingPercent Parms{};

	Parms.ChargePercent = ChargePercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargedAttackStateComponent.SetIsCharging
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsCharging                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargedAttackStateComponent::SetIsCharging(bool IsCharging)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargedAttackStateComponent", "SetIsCharging");

	Params::ChargedAttackStateComponent_SetIsCharging Parms{};

	Parms.IsCharging = IsCharging;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargedAttackStateComponent.GetChargingPercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargedAttackStateComponent::GetChargingPercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargedAttackStateComponent", "GetChargingPercent");

	Params::ChargedAttackStateComponent_GetChargingPercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargedAttackStateComponent.GetIsCharging
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UChargedAttackStateComponent::GetIsCharging() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargedAttackStateComponent", "GetIsCharging");

	Params::ChargedAttackStateComponent_GetIsCharging Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Charm.BeginDestroySequence_Internal
// (Native, Event, Protected, BlueprintEvent)

void ACharm::BeginDestroySequence_Internal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Charm", "BeginDestroySequence_Internal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TileSpawnPoint.OnRep_SpawnObject
// (Native, Protected)

void UTileSpawnPoint::OnRep_SpawnObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TileSpawnPoint", "OnRep_SpawnObject");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TileSpawnPoint.SetActivated
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    activated                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTileSpawnPoint::SetActivated(bool activated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TileSpawnPoint", "SetActivated");

	Params::TileSpawnPoint_SetActivated Parms{};

	Parms.activated = activated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TileSpawnPoint.GetSpawnedObject
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UTileSpawnPoint::GetSpawnedObject() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TileSpawnPoint", "GetSpawnedObject");

	Params::TileSpawnPoint_GetSpawnedObject Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TileSpawnPoint.IsActivated
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTileSpawnPoint::IsActivated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TileSpawnPoint", "IsActivated");

	Params::TileSpawnPoint_IsActivated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharmAttacher.BindOnCharmAnimationTagsChanged
// (Final, Native, Private)

void ACharmAttacher::BindOnCharmAnimationTagsChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharmAttacher", "BindOnCharmAnimationTagsChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharmAttacher.DispatchOnCharmAnimationTagsChanged
// (Final, Native, Private)

void ACharmAttacher::DispatchOnCharmAnimationTagsChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharmAttacher", "DispatchOnCharmAnimationTagsChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharmAttacher.GetActorAttachedOn
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ACharmAttacher::GetActorAttachedOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharmAttacher", "GetActorAttachedOn");

	Params::CharmAttacher_GetActorAttachedOn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharmAttacher.GetAnimationTweak
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FCharmAttacherAnimationTweak     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCharmAttacherAnimationTweak ACharmAttacher::GetAnimationTweak()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharmAttacher", "GetAnimationTweak");

	Params::CharmAttacher_GetAnimationTweak Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharmAttacher.GetAttachedCharm
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ACharm*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharm* ACharmAttacher::GetAttachedCharm()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharmAttacher", "GetAttachedCharm");

	Params::CharmAttacher_GetAttachedCharm Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharmAttacher.GetSkeletalMeshComponentAttachedOn
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ACharmAttacher::GetSkeletalMeshComponentAttachedOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharmAttacher", "GetSkeletalMeshComponentAttachedOn");

	Params::CharmAttacher_GetSkeletalMeshComponentAttachedOn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharmSpawnerComponent.ReplaceCharmTextures
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FCharmIdSlot>&      Customization                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UCharmSpawnerComponent::ReplaceCharmTextures(const TArray<struct FCharmIdSlot>& Customization)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharmSpawnerComponent", "ReplaceCharmTextures");

	Params::CharmSpawnerComponent_ReplaceCharmTextures Parms{};

	Parms.Customization = std::move(Customization);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChaseeCharacterComponent.Authority_OnGeneratorPercentChanged
// (Final, Native, Private)
// Parameters:
// class UChargeableComponent*             ChargeableComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PercentCompletionChange                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TotalPercentComplete                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChaseeCharacterComponent::Authority_OnGeneratorPercentChanged(class UChargeableComponent* ChargeableComponent, float PercentCompletionChange, float TotalPercentComplete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaseeCharacterComponent", "Authority_OnGeneratorPercentChanged");

	Params::ChaseeCharacterComponent_Authority_OnGeneratorPercentChanged Parms{};

	Parms.ChargeableComponent = ChargeableComponent;
	Parms.PercentCompletionChange = PercentCompletionChange;
	Parms.TotalPercentComplete = TotalPercentComplete;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChaseeCharacterComponent.Authority_OnInvocationPercentChanged
// (Final, Native, Private)
// Parameters:
// class UChargeableComponent*             ChargeableComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PercentCompletionChange                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TotalPercentComplete                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChaseeCharacterComponent::Authority_OnInvocationPercentChanged(class UChargeableComponent* ChargeableComponent, float PercentCompletionChange, float TotalPercentComplete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaseeCharacterComponent", "Authority_OnInvocationPercentChanged");

	Params::ChaseeCharacterComponent_Authority_OnInvocationPercentChanged Parms{};

	Parms.ChargeableComponent = ChargeableComponent;
	Parms.PercentCompletionChange = PercentCompletionChange;
	Parms.TotalPercentComplete = TotalPercentComplete;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChaseeCharacterComponent.Authority_OnLevelReadyToPlay
// (Final, Native, Private)

void UChaseeCharacterComponent::Authority_OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaseeCharacterComponent", "Authority_OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChatManager.Multicast_DisplayMessage
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const class FString&                    chatIdentifier                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    MirrorsId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChatManager::Multicast_DisplayMessage(const class FString& chatIdentifier, int32 PlayerIndex, const class FString& MirrorsId, const class FString& Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatManager", "Multicast_DisplayMessage");

	Params::ChatManager_Multicast_DisplayMessage Parms{};

	Parms.chatIdentifier = std::move(chatIdentifier);
	Parms.PlayerIndex = PlayerIndex;
	Parms.MirrorsId = std::move(MirrorsId);
	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CinematicManager.CancelAllCinematicToPlay
// (Final, Native, Public, BlueprintCallable)

void UCinematicManager::CancelAllCinematicToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicManager", "CancelAllCinematicToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CinematicManager.GetNextCinematicToPlay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FCinematic                       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCinematic UCinematicManager::GetNextCinematicToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicManager", "GetNextCinematicToPlay");

	Params::CinematicManager_GetNextCinematicToPlay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CinematicManager.PlayMultiple
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FCinematic>&        Cinematics                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UCinematicManager::PlayMultiple(const TArray<struct FCinematic>& Cinematics)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicManager", "PlayMultiple");

	Params::CinematicManager_PlayMultiple Parms{};

	Parms.Cinematics = std::move(Cinematics);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CinematicManager.PlaySingle
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FCinematic&                Cinematic                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCinematicManager::PlaySingle(const struct FCinematic& Cinematic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicManager", "PlaySingle");

	Params::CinematicManager_PlaySingle Parms{};

	Parms.Cinematic = std::move(Cinematic);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CinematicManager.SetVideoThumbnailProperties
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FCinematic*                      Cinematic                                              (Parm, OutParm, NativeAccessSpecifierPublic)

void UCinematicManager::SetVideoThumbnailProperties(struct FCinematic* Cinematic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicManager", "SetVideoThumbnailProperties");

	Params::CinematicManager_SetVideoThumbnailProperties Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Cinematic != nullptr)
		*Cinematic = std::move(Parms.Cinematic);
}


// Function DeadByDaylight.CinematicManager.HasCinematicToPlay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCinematicManager::HasCinematicToPlay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicManager", "HasCinematicToPlay");

	Params::CinematicManager_HasCinematicToPlay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlayerInteractionHandler.AddInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInteractionDefinition*           Interaction                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::AddInteraction(class UInteractionDefinition* Interaction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "AddInteraction");

	Params::PlayerInteractionHandler_AddInteraction Parms{};

	Parms.Interaction = Interaction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Authority_ClearPlayerDependency
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       playerDependency                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::Authority_ClearPlayerDependency(class ADBDPlayer* playerDependency)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Authority_ClearPlayerDependency");

	Params::PlayerInteractionHandler_Authority_ClearPlayerDependency Parms{};

	Parms.playerDependency = playerDependency;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Broadcast_Multicast_ConfirmChargedCompleted
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    chargeComplete                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::Broadcast_Multicast_ConfirmChargedCompleted(bool chargeComplete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Broadcast_Multicast_ConfirmChargedCompleted");

	Params::PlayerInteractionHandler_Broadcast_Multicast_ConfirmChargedCompleted Parms{};

	Parms.chargeComplete = chargeComplete;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.CleanInteractionArray
// (Final, Native, Public)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::CleanInteractionArray(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "CleanInteractionArray");

	Params::PlayerInteractionHandler_CleanInteractionArray Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Client_Cheat_SetInteractionScanInterval
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// float                                   Interval                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::Client_Cheat_SetInteractionScanInterval(float Interval)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Client_Cheat_SetInteractionScanInterval");

	Params::PlayerInteractionHandler_Client_Cheat_SetInteractionScanInterval Parms{};

	Parms.Interval = Interval;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Client_NotifyChargeCompleted
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// const class UInteractionDefinition*     Interaction                                            (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::Client_NotifyChargeCompleted(const class UInteractionDefinition* Interaction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Client_NotifyChargeCompleted");

	Params::PlayerInteractionHandler_Client_NotifyChargeCompleted Parms{};

	Parms.Interaction = Interaction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.HasAvailableInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EInputInteractionType                   interactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerInteractionHandler::HasAvailableInteraction(EInputInteractionType interactionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "HasAvailableInteraction");

	Params::PlayerInteractionHandler_HasAvailableInteraction Parms{};

	Parms.interactionType = interactionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlayerInteractionHandler.Multicast_CancelCurrentInteractionByInput
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void UPlayerInteractionHandler::Multicast_CancelCurrentInteractionByInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Multicast_CancelCurrentInteractionByInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Multicast_InteractionPredictionValidationResult
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class UInteractionDefinition*           Interaction                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInteractionValidationState             State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::Multicast_InteractionPredictionValidationResult(class UInteractionDefinition* Interaction, EInteractionValidationState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Multicast_InteractionPredictionValidationResult");

	Params::PlayerInteractionHandler_Multicast_InteractionPredictionValidationResult Parms{};

	Parms.Interaction = Interaction;
	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Multicast_InterruptionRequestResult_Interruptor
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// ERequestState                           State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    grantInterruptScore                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::Multicast_InterruptionRequestResult_Interruptor(ERequestState State, bool grantInterruptScore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Multicast_InterruptionRequestResult_Interruptor");

	Params::PlayerInteractionHandler_Multicast_InterruptionRequestResult_Interruptor Parms{};

	Parms.State = State;
	Parms.grantInterruptScore = grantInterruptScore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Multicast_RequestInterruption_Interruptee
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ADBDPlayer*                       interruptionOtherParty                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInterruptionDefinition*          InterruptionDefinition                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::Multicast_RequestInterruption_Interruptee(class ADBDPlayer* interruptionOtherParty, class UInterruptionDefinition* InterruptionDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Multicast_RequestInterruption_Interruptee");

	Params::PlayerInteractionHandler_Multicast_RequestInterruption_Interruptee Parms{};

	Parms.interruptionOtherParty = interruptionOtherParty;
	Parms.InterruptionDefinition = InterruptionDefinition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Multicast_SetInteractionToSwapTo
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class UInteractionDefinition*           Interaction                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::Multicast_SetInteractionToSwapTo(class UInteractionDefinition* Interaction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Multicast_SetInteractionToSwapTo");

	Params::PlayerInteractionHandler_Multicast_SetInteractionToSwapTo Parms{};

	Parms.Interaction = Interaction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Multicast_StoreInteraction
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const struct FStoredInteraction&        interactionToStore                                     (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::Multicast_StoreInteraction(const struct FStoredInteraction& interactionToStore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Multicast_StoreInteraction");

	Params::PlayerInteractionHandler_Multicast_StoreInteraction Parms{};

	Parms.interactionToStore = std::move(interactionToStore);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Multicast_StoreInterruption_Interruptor
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ADBDPlayer*                       interruptionOtherParty                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInterruptionDefinition*          InterruptionDefinition                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::Multicast_StoreInterruption_Interruptor(class ADBDPlayer* interruptionOtherParty, class UInterruptionDefinition* InterruptionDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Multicast_StoreInterruption_Interruptor");

	Params::PlayerInteractionHandler_Multicast_StoreInterruption_Interruptor Parms{};

	Parms.interruptionOtherParty = interruptionOtherParty;
	Parms.InterruptionDefinition = InterruptionDefinition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.OnAttachedInteractorOwnerEndPlay
// (Final, Native, Private)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEndPlayReason                          EndPlayReason                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::OnAttachedInteractorOwnerEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "OnAttachedInteractorOwnerEndPlay");

	Params::PlayerInteractionHandler_OnAttachedInteractorOwnerEndPlay Parms{};

	Parms.Actor = Actor;
	Parms.EndPlayReason = EndPlayReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.RemoveInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInteractionDefinition*           Interaction                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::RemoveInteraction(class UInteractionDefinition* Interaction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "RemoveInteraction");

	Params::PlayerInteractionHandler_RemoveInteraction Parms{};

	Parms.Interaction = Interaction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Server_AnswerInterruption_Interruptee
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// ERequestState                           State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::Server_AnswerInterruption_Interruptee(ERequestState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Server_AnswerInterruption_Interruptee");

	Params::PlayerInteractionHandler_Server_AnswerInterruption_Interruptee Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Server_Broadcast_ConfirmChargedCompleted
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// bool                                    chargeComplete                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::Server_Broadcast_ConfirmChargedCompleted(bool chargeComplete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Server_Broadcast_ConfirmChargedCompleted");

	Params::PlayerInteractionHandler_Server_Broadcast_ConfirmChargedCompleted Parms{};

	Parms.chargeComplete = chargeComplete;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Server_Broadcast_StoreInteraction
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// const struct FStoredInteraction&        interactionToStore                                     (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::Server_Broadcast_StoreInteraction(const struct FStoredInteraction& interactionToStore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Server_Broadcast_StoreInteraction");

	Params::PlayerInteractionHandler_Server_Broadcast_StoreInteraction Parms{};

	Parms.interactionToStore = std::move(interactionToStore);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Server_CancelCurrentInteractionByInput
// (Net, NetReliable, Native, Event, Public, NetServer)

void UPlayerInteractionHandler::Server_CancelCurrentInteractionByInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Server_CancelCurrentInteractionByInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Server_Cheat_SetInteractionScanInterval
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// float                                   Interval                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::Server_Cheat_SetInteractionScanInterval(float Interval)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Server_Cheat_SetInteractionScanInterval");

	Params::PlayerInteractionHandler_Server_Cheat_SetInteractionScanInterval Parms{};

	Parms.Interval = Interval;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Server_RequestInterruption_Interruptor
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)

void UPlayerInteractionHandler::Server_RequestInterruption_Interruptor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Server_RequestInterruption_Interruptor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Server_SetInteractionToSwapTo
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// class UInteractionDefinition*           Interaction                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::Server_SetInteractionToSwapTo(class UInteractionDefinition* Interaction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Server_SetInteractionToSwapTo");

	Params::PlayerInteractionHandler_Server_SetInteractionToSwapTo Parms{};

	Parms.Interaction = Interaction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Server_StoreInterruption_Interruptor
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// class ADBDPlayer*                       interruptionOtherParty                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInterruptionDefinition*          InterruptionDefinition                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::Server_StoreInterruption_Interruptor(class ADBDPlayer* interruptionOtherParty, class UInterruptionDefinition* InterruptionDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Server_StoreInterruption_Interruptor");

	Params::PlayerInteractionHandler_Server_StoreInterruption_Interruptor Parms{};

	Parms.interruptionOtherParty = interruptionOtherParty;
	Parms.InterruptionDefinition = InterruptionDefinition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.GetAdditiveSkillCheckProbabilityModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPlayerInteractionHandler::GetAdditiveSkillCheckProbabilityModifier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "GetAdditiveSkillCheckProbabilityModifier");

	Params::PlayerInteractionHandler_GetAdditiveSkillCheckProbabilityModifier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlayerInteractionHandler.GetAvailableInteraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInputInteractionType                   interactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractionDefinition*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionDefinition* UPlayerInteractionHandler::GetAvailableInteraction(EInputInteractionType interactionType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "GetAvailableInteraction");

	Params::PlayerInteractionHandler_GetAvailableInteraction Parms{};

	Parms.interactionType = interactionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlayerInteractionHandler.GetCurrentInteraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractionDefinition*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionDefinition* UPlayerInteractionHandler::GetCurrentInteraction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "GetCurrentInteraction");

	Params::PlayerInteractionHandler_GetCurrentInteraction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlayerInteractionHandler.GetMultiplicativeSkillCheckProbabilityModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPlayerInteractionHandler::GetMultiplicativeSkillCheckProbabilityModifier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "GetMultiplicativeSkillCheckProbabilityModifier");

	Params::PlayerInteractionHandler_GetMultiplicativeSkillCheckProbabilityModifier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlayerInteractionHandler.HasActiveSkillCheck
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerInteractionHandler::HasActiveSkillCheck() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "HasActiveSkillCheck");

	Params::PlayerInteractionHandler_HasActiveSkillCheck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ClipManager.RemoveDissolveMaterials
// (Final, Native, Public, BlueprintCallable)

void AClipManager::RemoveDissolveMaterials()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClipManager", "RemoveDissolveMaterials");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ClipManager.SphericalDissolveAt
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AClipManager::SphericalDissolveAt(const struct FVector& Location, float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClipManager", "SphericalDissolveAt");

	Params::ClipManager_SphericalDissolveAt Parms{};

	Parms.Location = std::move(Location);
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CollectableAudioComponent.AddonConsumed
// (Final, Native, Private)
// Parameters:
// class UItemAddon*                       addon                                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCollectableAudioComponent::AddonConsumed(class UItemAddon* addon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectableAudioComponent", "AddonConsumed");

	Params::CollectableAudioComponent_AddonConsumed Parms{};

	Parms.addon = addon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CollectableAudioComponent.EnableComponent
// (Final, Native, Private)

void UCollectableAudioComponent::EnableComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectableAudioComponent", "EnableComponent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CollectableAudioComponent.OnChargeEmpty
// (Final, Native, Private)

void UCollectableAudioComponent::OnChargeEmpty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectableAudioComponent", "OnChargeEmpty");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CollectableAudioComponent.OnItemDropped
// (Final, Native, Private)
// Parameters:
// EItemDropType                           dropType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCollectableAudioComponent::OnItemDropped(EItemDropType dropType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectableAudioComponent", "OnItemDropped");

	Params::CollectableAudioComponent_OnItemDropped Parms{};

	Parms.dropType = dropType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CollectableAudioComponent.PlayerPickedUpCollectable
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCollectableAudioComponent::PlayerPickedUpCollectable(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectableAudioComponent", "PlayerPickedUpCollectable");

	Params::CollectableAudioComponent_PlayerPickedUpCollectable Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CollectableAudioComponent.PostAudioEvent
// (Final, Native, Private, Const)
// Parameters:
// const class FString&                    audioCall                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCollectableAudioComponent::PostAudioEvent(const class FString& audioCall) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectableAudioComponent", "PostAudioEvent");

	Params::CollectableAudioComponent_PostAudioEvent Parms{};

	Parms.audioCall = std::move(audioCall);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorDrivenActor.Authority_CheckActivation
// (Final, Native, Public)
// Parameters:
// bool                                    isAutoCompleted                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   generatorId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorDrivenActor::Authority_CheckActivation(bool isAutoCompleted, int32 generatorId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "Authority_CheckActivation");

	Params::GeneratorDrivenActor_Authority_CheckActivation Parms{};

	Parms.isAutoCompleted = isAutoCompleted;
	Parms.generatorId = generatorId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorDrivenActor.Authority_CheckGeneratorRepairedBySurvivor
// (Final, Native, Public)
// Parameters:
// class ADBDPlayer*                       repairingSurvivor                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   generatorId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorDrivenActor::Authority_CheckGeneratorRepairedBySurvivor(class ADBDPlayer* repairingSurvivor, int32 generatorId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "Authority_CheckGeneratorRepairedBySurvivor");

	Params::GeneratorDrivenActor_Authority_CheckGeneratorRepairedBySurvivor Parms{};

	Parms.repairingSurvivor = repairingSurvivor;
	Parms.generatorId = generatorId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorDrivenActor.GetSharedTileRandomizer
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRandomStream                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FRandomStream AGeneratorDrivenActor::GetSharedTileRandomizer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "GetSharedTileRandomizer");

	Params::GeneratorDrivenActor_GetSharedTileRandomizer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GeneratorDrivenActor.Multicast_ActivationChecked
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// bool                                    activated                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isAutoCompleted                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   generatorId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorDrivenActor::Multicast_ActivationChecked(bool activated, bool isAutoCompleted, int32 generatorId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "Multicast_ActivationChecked");

	Params::GeneratorDrivenActor_Multicast_ActivationChecked Parms{};

	Parms.activated = activated;
	Parms.isAutoCompleted = isAutoCompleted;
	Parms.generatorId = generatorId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorDrivenActor.Multicast_GeneratorRepairedBySurvivor
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class ADBDPlayer*                       repairingSurvivor                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   generatorId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorDrivenActor::Multicast_GeneratorRepairedBySurvivor(class ADBDPlayer* repairingSurvivor, int32 generatorId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "Multicast_GeneratorRepairedBySurvivor");

	Params::GeneratorDrivenActor_Multicast_GeneratorRepairedBySurvivor Parms{};

	Parms.repairingSurvivor = repairingSurvivor;
	Parms.generatorId = generatorId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorDrivenActor.OnActivateGeneratorDrivenActor
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    isAutoCompleted                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   generatorId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorDrivenActor::OnActivateGeneratorDrivenActor(bool isAutoCompleted, int32 generatorId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "OnActivateGeneratorDrivenActor");

	Params::GeneratorDrivenActor_OnActivateGeneratorDrivenActor Parms{};

	Parms.isAutoCompleted = isAutoCompleted;
	Parms.generatorId = generatorId;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.GeneratorDrivenActor.OnGeneratorRepairedBySurvivor
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       repairingSurvivor                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   generatorId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorDrivenActor::OnGeneratorRepairedBySurvivor(class ADBDPlayer* repairingSurvivor, int32 generatorId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "OnGeneratorRepairedBySurvivor");

	Params::GeneratorDrivenActor_OnGeneratorRepairedBySurvivor Parms{};

	Parms.repairingSurvivor = repairingSurvivor;
	Parms.generatorId = generatorId;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.GeneratorDrivenActor.OnInitGeneratorDrivenActor
// (Event, Public, BlueprintEvent)
// Parameters:
// class UObject*                          Generator                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   generatorId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorDrivenActor::OnInitGeneratorDrivenActor(class UObject* Generator, int32 generatorId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "OnInitGeneratorDrivenActor");

	Params::GeneratorDrivenActor_OnInitGeneratorDrivenActor Parms{};

	Parms.Generator = Generator;
	Parms.generatorId = generatorId;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.GeneratorDrivenActor.SetSpawnedObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          spawnedObject                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   generatorId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorDrivenActor::SetSpawnedObject(class UObject* spawnedObject, int32 generatorId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "SetSpawnedObject");

	Params::GeneratorDrivenActor_SetSpawnedObject Parms{};

	Parms.spawnedObject = spawnedObject;
	Parms.generatorId = generatorId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorDrivenActor.IsActivated
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   generatorId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGeneratorDrivenActor::IsActivated(int32 generatorId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "IsActivated");

	Params::GeneratorDrivenActor_IsActivated Parms{};

	Parms.generatorId = generatorId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GeneratorDrivenActor.IsValidGeneratorId
// (Final, Native, Private, Const)
// Parameters:
// int32                                   generatorId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGeneratorDrivenActor::IsValidGeneratorId(int32 generatorId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "IsValidGeneratorId");

	Params::GeneratorDrivenActor_IsValidGeneratorId Parms{};

	Parms.generatorId = generatorId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGeneratorDrivenReflectionCaptureActor.SwapToSecondState
// (Final, Native, Public, BlueprintCallable)

void ADBDGeneratorDrivenReflectionCaptureActor::SwapToSecondState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGeneratorDrivenReflectionCaptureActor", "SwapToSecondState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CombinedSpecialEventDataUtilities.GetSpecialMusicState
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FCombinedSpecialEventData& Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UCombinedSpecialEventDataUtilities::GetSpecialMusicState(const struct FCombinedSpecialEventData& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CombinedSpecialEventDataUtilities", "GetSpecialMusicState");

	Params::CombinedSpecialEventDataUtilities_GetSpecialMusicState Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CommentatorActorInterface.OnAudioEnded
// (Native, Event, Public, BlueprintEvent)

void ICommentatorActorInterface::OnAudioEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CommentatorActorInterface", "OnAudioEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CommentatorActorInterface.OnAudioStarted
// (Native, Event, Public, BlueprintEvent)

void ICommentatorActorInterface::OnAudioStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CommentatorActorInterface", "OnAudioStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Client
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    commandLine                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::Client(const class FString& commandLine)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Client");

	Params::DBDPlayerControllerBase_Client Parms{};

	Parms.commandLine = std::move(commandLine);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Client_CallConsoleCmdOnClient
// (Final, Net, NetReliable, Native, Event, Private, NetClient, NetValidate)
// Parameters:
// const class FString&                    commandLine                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::Client_CallConsoleCmdOnClient(const class FString& commandLine)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Client_CallConsoleCmdOnClient");

	Params::DBDPlayerControllerBase_Client_CallConsoleCmdOnClient Parms{};

	Parms.commandLine = std::move(commandLine);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Client_DisplayChatMessage
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// const class FString&                    chatIdentifier                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    MirrorsId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::Client_DisplayChatMessage(const class FString& chatIdentifier, int32 PlayerIndex, const class FString& MirrorsId, const class FString& Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Client_DisplayChatMessage");

	Params::DBDPlayerControllerBase_Client_DisplayChatMessage Parms{};

	Parms.chatIdentifier = std::move(chatIdentifier);
	Parms.PlayerIndex = PlayerIndex;
	Parms.MirrorsId = std::move(MirrorsId);
	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Client_EACBeginSession
// (Net, NetReliable, Native, Event, Public, NetClient)

void ADBDPlayerControllerBase::Client_EACBeginSession()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Client_EACBeginSession");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Client_EACDestroySession
// (Net, NetReliable, Native, Event, Public, NetClient)

void ADBDPlayerControllerBase::Client_EACDestroySession()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Client_EACDestroySession");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Client_EACMessageFromServer
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// const TArray<uint8>&                    Message                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::Client_EACMessageFromServer(const TArray<uint8>& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Client_EACMessageFromServer");

	Params::DBDPlayerControllerBase_Client_EACMessageFromServer Parms{};

	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Client_FinishedPlaying
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// const struct FEndGameInfo&              Info                                                   (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::Client_FinishedPlaying(const struct FEndGameInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Client_FinishedPlaying");

	Params::DBDPlayerControllerBase_Client_FinishedPlaying Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Client_GameEnded
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// const struct FEndGameInfo&              Info                                                   (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::Client_GameEnded(const struct FEndGameInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Client_GameEnded");

	Params::DBDPlayerControllerBase_Client_GameEnded Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Client_RequestPlayerProfile
// (Net, NetReliable, Native, Event, Public, NetClient)

void ADBDPlayerControllerBase::Client_RequestPlayerProfile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Client_RequestPlayerProfile");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Client_SendLogs
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// const TArray<class FString>&            ensures                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::Client_SendLogs(const TArray<class FString>& ensures)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Client_SendLogs");

	Params::DBDPlayerControllerBase_Client_SendLogs Parms{};

	Parms.ensures = std::move(ensures);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Client_SendServerAuthentication
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// const class FString&                    authServerTicket                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint64                                  SteamId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  ticketLength                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::Client_SendServerAuthentication(const class FString& authServerTicket, uint64 SteamId, uint32 ticketLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Client_SendServerAuthentication");

	Params::DBDPlayerControllerBase_Client_SendServerAuthentication Parms{};

	Parms.authServerTicket = std::move(authServerTicket);
	Parms.SteamId = SteamId;
	Parms.ticketLength = ticketLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Client_SendWarning
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                                    penaltyStarts                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::Client_SendWarning(bool penaltyStarts, float Seconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Client_SendWarning");

	Params::DBDPlayerControllerBase_Client_SendWarning Parms{};

	Parms.penaltyStarts = penaltyStarts;
	Parms.Seconds = Seconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.DBD_BuildFromMap
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    Map                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::DBD_BuildFromMap(const class FString& Map)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "DBD_BuildFromMap");

	Params::DBDPlayerControllerBase_DBD_BuildFromMap Parms{};

	Parms.Map = std::move(Map);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.DBD_BuildFromPlayerCount
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::DBD_BuildFromPlayerCount(int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "DBD_BuildFromPlayerCount");

	Params::DBDPlayerControllerBase_DBD_BuildFromPlayerCount Parms{};

	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.DBD_BuildFromSeed
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Seed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::DBD_BuildFromSeed(int32 Seed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "DBD_BuildFromSeed");

	Params::DBDPlayerControllerBase_DBD_BuildFromSeed Parms{};

	Parms.Seed = Seed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.DBD_BuildFromTile
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   matrixX                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   matrixY                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::DBD_BuildFromTile(int32 matrixX, int32 matrixY, int32 Rotation, const class FString& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "DBD_BuildFromTile");

	Params::DBDPlayerControllerBase_DBD_BuildFromTile Parms{};

	Parms.matrixX = matrixX;
	Parms.matrixY = matrixY;
	Parms.Rotation = Rotation;
	Parms.Name_0 = std::move(Name_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.DBD_DebugSendChatMessage
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::DBD_DebugSendChatMessage(const class FString& Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "DBD_DebugSendChatMessage");

	Params::DBDPlayerControllerBase_DBD_DebugSendChatMessage Parms{};

	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.DBD_FillAllScoreCategories
// (Final, Exec, Native, Public, BlueprintCallable)

void ADBDPlayerControllerBase::DBD_FillAllScoreCategories()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "DBD_FillAllScoreCategories");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.DBD_FillScoreCategory
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::DBD_FillScoreCategory(int32 category)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "DBD_FillScoreCategory");

	Params::DBDPlayerControllerBase_DBD_FillScoreCategory Parms{};

	Parms.category = category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.DBD_FireTestScore
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::DBD_FireTestScore(int32 category, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "DBD_FireTestScore");

	Params::DBDPlayerControllerBase_DBD_FireTestScore Parms{};

	Parms.category = category;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.DBD_SetCurrentCharacterPrestigeDatesFuture
// (Final, Exec, Native, Public)

void ADBDPlayerControllerBase::DBD_SetCurrentCharacterPrestigeDatesFuture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "DBD_SetCurrentCharacterPrestigeDatesFuture");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.DBD_SetCurrentCharacterPrestigeDatesNow
// (Final, Exec, Native, Public)

void ADBDPlayerControllerBase::DBD_SetCurrentCharacterPrestigeDatesNow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "DBD_SetCurrentCharacterPrestigeDatesNow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.DBD_SetCurrentCharacterPrestigeDatesPast
// (Final, Exec, Native, Public)

void ADBDPlayerControllerBase::DBD_SetCurrentCharacterPrestigeDatesPast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "DBD_SetCurrentCharacterPrestigeDatesPast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.DBD_UpdateLocalStats
// (Final, Exec, Native, Public, BlueprintCallable)

void ADBDPlayerControllerBase::DBD_UpdateLocalStats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "DBD_UpdateLocalStats");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Server
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    commandLine                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::Server(const class FString& commandLine)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Server");

	Params::DBDPlayerControllerBase_Server Parms{};

	Parms.commandLine = std::move(commandLine);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Server_CallConsoleCmdOnServer
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// const class FString&                    commandLine                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::Server_CallConsoleCmdOnServer(const class FString& commandLine)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Server_CallConsoleCmdOnServer");

	Params::DBDPlayerControllerBase_Server_CallConsoleCmdOnServer Parms{};

	Parms.commandLine = std::move(commandLine);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Server_EACMessageFromClient
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const TArray<uint8>&                    Message                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::Server_EACMessageFromClient(const TArray<uint8>& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Server_EACMessageFromClient");

	Params::DBDPlayerControllerBase_Server_EACMessageFromClient Parms{};

	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Server_ReceivePlayerProfile
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FPlayerSavedProfileDataShared&savedProfileData                                       (Parm, NativeAccessSpecifierPublic)
// const struct FPlayerLoadoutData&        playerLoadout                                          (Parm, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::Server_ReceivePlayerProfile(const struct FPlayerSavedProfileDataShared& savedProfileData, const struct FPlayerLoadoutData& playerLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Server_ReceivePlayerProfile");

	Params::DBDPlayerControllerBase_Server_ReceivePlayerProfile Parms{};

	Parms.savedProfileData = std::move(savedProfileData);
	Parms.playerLoadout = std::move(playerLoadout);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Server_SendClientAuthentication
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const class FString&                    authClientTicket                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint64                                  SteamId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  ticketLength                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::Server_SendClientAuthentication(const class FString& authClientTicket, uint64 SteamId, uint32 ticketLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Server_SendClientAuthentication");

	Params::DBDPlayerControllerBase_Server_SendClientAuthentication Parms{};

	Parms.authClientTicket = std::move(authClientTicket);
	Parms.SteamId = SteamId;
	Parms.ticketLength = ticketLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Server_SendMessage
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const class FString&                    Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::Server_SendMessage(const class FString& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Server_SendMessage");

	Params::DBDPlayerControllerBase_Server_SendMessage Parms{};

	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Server_SetConsecutiveMatchStreak
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// int32                                   consecutiveMatch                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::Server_SetConsecutiveMatchStreak(int32 consecutiveMatch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Server_SetConsecutiveMatchStreak");

	Params::DBDPlayerControllerBase_Server_SetConsecutiveMatchStreak Parms{};

	Parms.consecutiveMatch = consecutiveMatch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Server_SetPlayerCard
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const class FString&                    badgeId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    bannerId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::Server_SetPlayerCard(const class FString& badgeId, const class FString& bannerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Server_SetPlayerCard");

	Params::DBDPlayerControllerBase_Server_SetPlayerCard Parms{};

	Parms.badgeId = std::move(badgeId);
	Parms.bannerId = std::move(bannerId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Server_UpdateReplicatedPips
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// int32                                   pipsToAdd                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::Server_UpdateReplicatedPips(int32 pipsToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Server_UpdateReplicatedPips");

	Params::DBDPlayerControllerBase_Server_UpdateReplicatedPips Parms{};

	Parms.pipsToAdd = pipsToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ColorBlindFunctionLibrary.CallOnColorBlindSettingsChange
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UObject*                          callingObject                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UColorBlindFunctionLibrary::CallOnColorBlindSettingsChange(class UObject* callingObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ColorBlindFunctionLibrary", "CallOnColorBlindSettingsChange");

	Params::ColorBlindFunctionLibrary_CallOnColorBlindSettingsChange Parms{};

	Parms.callingObject = callingObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CommentatorSubsystem.OnCommentatorAudioFinished
// (Final, Native, Private)
// Parameters:
// EAkCallbackType                         CallbackType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkCallbackInfo*                  CallbackInfo                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCommentatorSubsystem::OnCommentatorAudioFinished(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommentatorSubsystem", "OnCommentatorAudioFinished");

	Params::CommentatorSubsystem_OnCommentatorAudioFinished Parms{};

	Parms.CallbackType = CallbackType;
	Parms.CallbackInfo = CallbackInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.RedStainComponent.DBD_HideRedStain
// (Final, Exec, Native, Public)
// Parameters:
// const bool                              hideStain                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URedStainComponent::DBD_HideRedStain(const bool hideStain)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RedStainComponent", "DBD_HideRedStain");

	Params::RedStainComponent_DBD_HideRedStain Parms{};

	Parms.hideStain = hideStain;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.RedStainComponent.UpdateRedStain
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    shouldBeHidden                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             alpha                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URedStainComponent::UpdateRedStain(bool shouldBeHidden, const float alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RedStainComponent", "UpdateRedStain");

	Params::RedStainComponent_UpdateRedStain Parms{};

	Parms.shouldBeHidden = shouldBeHidden;
	Parms.alpha = alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SkillCheck.CanSkillCheckTypeGrantScore
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ESkillCheckCustomType                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkillCheck::CanSkillCheckTypeGrantScore(ESkillCheckCustomType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SkillCheck", "CanSkillCheckTypeGrantScore");

	Params::SkillCheck_CanSkillCheckTypeGrantScore Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SkillCheck.Authority_OnSkillCheckTimeout
// (Final, Native, Public)

void USkillCheck::Authority_OnSkillCheckTimeout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillCheck", "Authority_OnSkillCheckTimeout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SkillCheck.Multicast_ActivateSkillCheck
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class UChargeableInteractionDefinition* Interaction                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   skillCheckCustomType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSkillCheckDefinition&     definition                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    executeOnlyOnNotControlled                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillCheck::Multicast_ActivateSkillCheck(class UChargeableInteractionDefinition* Interaction, ESkillCheckCustomType skillCheckCustomType, const struct FSkillCheckDefinition& definition, bool executeOnlyOnNotControlled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillCheck", "Multicast_ActivateSkillCheck");

	Params::SkillCheck_Multicast_ActivateSkillCheck Parms{};

	Parms.Interaction = Interaction;
	Parms.skillCheckCustomType = skillCheckCustomType;
	Parms.definition = std::move(definition);
	Parms.executeOnlyOnNotControlled = executeOnlyOnNotControlled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SkillCheck.Multicast_DeactivateSkillCheck
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void USkillCheck::Multicast_DeactivateSkillCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillCheck", "Multicast_DeactivateSkillCheck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SkillCheck.Multicast_OnTriggerContinuousCustomSkillCheck
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class UChargeableInteractionDefinition* currentInteraction                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   skillCheckCustomType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSkillCheckDefinition&     definition                                             (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void USkillCheck::Multicast_OnTriggerContinuousCustomSkillCheck(class UChargeableInteractionDefinition* currentInteraction, ESkillCheckCustomType skillCheckCustomType, const struct FSkillCheckDefinition& definition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillCheck", "Multicast_OnTriggerContinuousCustomSkillCheck");

	Params::SkillCheck_Multicast_OnTriggerContinuousCustomSkillCheck Parms{};

	Parms.currentInteraction = currentInteraction;
	Parms.skillCheckCustomType = skillCheckCustomType;
	Parms.definition = std::move(definition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SkillCheck.Multicast_OnTriggerCustomSkillCheck
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class UChargeableInteractionDefinition* currentInteraction                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   skillCheckCustomType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    ID                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    salt                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSkillCheckDefinition&     definition                                             (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void USkillCheck::Multicast_OnTriggerCustomSkillCheck(class UChargeableInteractionDefinition* currentInteraction, ESkillCheckCustomType skillCheckCustomType, const class FString& ID, const class FString& salt, const struct FSkillCheckDefinition& definition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillCheck", "Multicast_OnTriggerCustomSkillCheck");

	Params::SkillCheck_Multicast_OnTriggerCustomSkillCheck Parms{};

	Parms.currentInteraction = currentInteraction;
	Parms.skillCheckCustomType = skillCheckCustomType;
	Parms.ID = std::move(ID);
	Parms.salt = std::move(salt);
	Parms.definition = std::move(definition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SkillCheck.Multicast_SkillCheckResponse
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const struct FSkillCheckResponse&       SkillCheckResponse                                     (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    executeOnlyOnNotControlled                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillCheck::Multicast_SkillCheckResponse(const struct FSkillCheckResponse& SkillCheckResponse, bool executeOnlyOnNotControlled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillCheck", "Multicast_SkillCheckResponse");

	Params::SkillCheck_Multicast_SkillCheckResponse Parms{};

	Parms.SkillCheckResponse = std::move(SkillCheckResponse);
	Parms.executeOnlyOnNotControlled = executeOnlyOnNotControlled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SkillCheck.Server_ActivateSkillCheck
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// class UChargeableInteractionDefinition* Interaction                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   skillCheckCustomType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSkillCheckDefinition&     definition                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USkillCheck::Server_ActivateSkillCheck(class UChargeableInteractionDefinition* Interaction, ESkillCheckCustomType skillCheckCustomType, const struct FSkillCheckDefinition& definition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillCheck", "Server_ActivateSkillCheck");

	Params::SkillCheck_Server_ActivateSkillCheck Parms{};

	Parms.Interaction = Interaction;
	Parms.skillCheckCustomType = skillCheckCustomType;
	Parms.definition = std::move(definition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SkillCheck.Server_DeactivateSkillCheck
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void USkillCheck::Server_DeactivateSkillCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillCheck", "Server_DeactivateSkillCheck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SkillCheck.Server_OnSkillCheckFailure
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const struct FSkillCheckResponse&       SkillCheckResponse                                     (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void USkillCheck::Server_OnSkillCheckFailure(const struct FSkillCheckResponse& SkillCheckResponse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillCheck", "Server_OnSkillCheckFailure");

	Params::SkillCheck_Server_OnSkillCheckFailure Parms{};

	Parms.SkillCheckResponse = std::move(SkillCheckResponse);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SkillCheck.Server_OnSkillCheckSuccess
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const struct FSkillCheckResponse&       SkillCheckResponse                                     (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void USkillCheck::Server_OnSkillCheckSuccess(const struct FSkillCheckResponse& SkillCheckResponse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillCheck", "Server_OnSkillCheckSuccess");

	Params::SkillCheck_Server_OnSkillCheckSuccess Parms{};

	Parms.SkillCheckResponse = std::move(SkillCheckResponse);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDHookUtilities.ComputeHookStrugglePercent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ASurvivor*                  hookedCamper                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   hookStruggleThreshold                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDHookUtilities::ComputeHookStrugglePercent(const class ASurvivor* hookedCamper, float hookStruggleThreshold)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDHookUtilities", "ComputeHookStrugglePercent");

	Params::DBDHookUtilities_ComputeHookStrugglePercent Parms{};

	Parms.hookedCamper = hookedCamper;
	Parms.hookStruggleThreshold = hookStruggleThreshold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDHookUtilities.IsFreddyHook
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AMeatHook*                        targetHook                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDHookUtilities::IsFreddyHook(class AMeatHook* targetHook)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDHookUtilities", "IsFreddyHook");

	Params::DBDHookUtilities_IsFreddyHook Parms{};

	Parms.targetHook = targetHook;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDHookUtilities.IsHagHook
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AMeatHook*                        targetHook                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDHookUtilities::IsHagHook(class AMeatHook* targetHook)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDHookUtilities", "IsHagHook");

	Params::DBDHookUtilities_IsHagHook Parms{};

	Parms.targetHook = targetHook;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDHookUtilities.IsHookOf
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AMeatHook*                        targetHook                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              hookTag                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDHookUtilities::IsHookOf(class AMeatHook* targetHook, const struct FGameplayTag& hookTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDHookUtilities", "IsHookOf");

	Params::DBDHookUtilities_IsHookOf Parms{};

	Parms.targetHook = targetHook;
	Parms.hookTag = std::move(hookTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDHookUtilities.IsHuntressHook
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AMeatHook*                        targetHook                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDHookUtilities::IsHuntressHook(class AMeatHook* targetHook)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDHookUtilities", "IsHuntressHook");

	Params::DBDHookUtilities_IsHuntressHook Parms{};

	Parms.targetHook = targetHook;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDHookUtilities.IsLegionHook
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AMeatHook*                        targetHook                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDHookUtilities::IsLegionHook(class AMeatHook* targetHook)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDHookUtilities", "IsLegionHook");

	Params::DBDHookUtilities_IsLegionHook Parms{};

	Parms.targetHook = targetHook;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDHookUtilities.IsNurseHook
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AMeatHook*                        targetHook                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDHookUtilities::IsNurseHook(class AMeatHook* targetHook)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDHookUtilities", "IsNurseHook");

	Params::DBDHookUtilities_IsNurseHook Parms{};

	Parms.targetHook = targetHook;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDHookUtilities.IsPigHook
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AMeatHook*                        targetHook                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDHookUtilities::IsPigHook(class AMeatHook* targetHook)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDHookUtilities", "IsPigHook");

	Params::DBDHookUtilities_IsPigHook Parms{};

	Parms.targetHook = targetHook;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDHookUtilities.IsWraithHook
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AMeatHook*                        targetHook                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDHookUtilities::IsWraithHook(class AMeatHook* targetHook)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDHookUtilities", "IsWraithHook");

	Params::DBDHookUtilities_IsWraithHook Parms{};

	Parms.targetHook = targetHook;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ConstrainAspectRatioComponent.DBD_ToggleBlackBars
// (Final, Exec, Native, Private)
// Parameters:
// int32                                   Option                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstrainAspectRatioComponent::DBD_ToggleBlackBars(int32 Option)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConstrainAspectRatioComponent", "DBD_ToggleBlackBars");

	Params::ConstrainAspectRatioComponent_DBD_ToggleBlackBars Parms{};

	Parms.Option = Option;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ConstrainAspectRatioComponent.OnIntroCompleted
// (Final, Native, Private)

void UConstrainAspectRatioComponent::OnIntroCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConstrainAspectRatioComponent", "OnIntroCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ConstrainAspectRatioComponent.SetCinematicMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    cinematicMode                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstrainAspectRatioComponent::SetCinematicMode(bool cinematicMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConstrainAspectRatioComponent", "SetCinematicMode");

	Params::ConstrainAspectRatioComponent_SetCinematicMode Parms{};

	Parms.cinematicMode = cinematicMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ConstrainAspectRatioComponent.GetCameraConstrainedViewSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UConstrainAspectRatioComponent::GetCameraConstrainedViewSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConstrainAspectRatioComponent", "GetCameraConstrainedViewSize");

	Params::ConstrainAspectRatioComponent_GetCameraConstrainedViewSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDClientSyncer.Multicast_SyncActorToSpawnLocally
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const TArray<struct FSpawnInfo>&        spawnInfos                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   startIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDClientSyncer::Multicast_SyncActorToSpawnLocally(const TArray<struct FSpawnInfo>& spawnInfos, int32 startIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDClientSyncer", "Multicast_SyncActorToSpawnLocally");

	Params::DBDClientSyncer_Multicast_SyncActorToSpawnLocally Parms{};

	Parms.spawnInfos = std::move(spawnInfos);
	Parms.startIndex = startIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDClientSyncer.Multicast_SyncFinalLocallySpawnCount
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// int32                                   numLocal                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDClientSyncer::Multicast_SyncFinalLocallySpawnCount(int32 numLocal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDClientSyncer", "Multicast_SyncFinalLocallySpawnCount");

	Params::DBDClientSyncer_Multicast_SyncFinalLocallySpawnCount Parms{};

	Parms.numLocal = numLocal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDClientSyncer.Multicast_SyncSeed
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// int32                                   Seed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPaperTileMap*                    TileMap                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   GenerationPlayerCount                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDClientSyncer::Multicast_SyncSeed(int32 Seed, class UPaperTileMap* TileMap, int32 GenerationPlayerCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDClientSyncer", "Multicast_SyncSeed");

	Params::DBDClientSyncer_Multicast_SyncSeed Parms{};

	Parms.Seed = Seed;
	Parms.TileMap = TileMap;
	Parms.GenerationPlayerCount = GenerationPlayerCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Halloween2018EventComponent.OnFinishedPlaying
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UHalloween2018EventComponent::OnFinishedPlaying(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Halloween2018EventComponent", "OnFinishedPlaying");

	Params::Halloween2018EventComponent_OnFinishedPlaying Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Halloween2018EventComponent.OnRep_Vial
// (Final, Native, Private)

void UHalloween2018EventComponent::OnRep_Vial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Halloween2018EventComponent", "OnRep_Vial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Halloween2018EventComponent.Server_SpawnVial
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// float                                   initialCharge                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHalloween2018EventComponent::Server_SpawnVial(float initialCharge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Halloween2018EventComponent", "Server_SpawnVial");

	Params::Halloween2018EventComponent_Server_SpawnVial Parms{};

	Parms.initialCharge = initialCharge;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Halloween2018EventComponent.GetVial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USectionnedChargeableComponent*   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USectionnedChargeableComponent* UHalloween2018EventComponent::GetVial() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Halloween2018EventComponent", "GetVial");

	Params::Halloween2018EventComponent_GetVial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Halloween2018EventComponent.IsVialFull
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHalloween2018EventComponent::IsVialFull() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Halloween2018EventComponent", "IsVialFull");

	Params::Halloween2018EventComponent_IsVialFull Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ContextualQuestComponent.Authority_DebugAddSpecialBehaviour
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   amountRequired                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UContextualQuestComponent::Authority_DebugAddSpecialBehaviour(class FName ID, int32 amountRequired)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextualQuestComponent", "Authority_DebugAddSpecialBehaviour");

	Params::ContextualQuestComponent_Authority_DebugAddSpecialBehaviour Parms{};

	Parms.ID = ID;
	Parms.amountRequired = amountRequired;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ContextualQuestComponent.Authority_DebugRemoveSpecialBehaviour
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UContextualQuestComponent::Authority_DebugRemoveSpecialBehaviour(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextualQuestComponent", "Authority_DebugRemoveSpecialBehaviour");

	Params::ContextualQuestComponent_Authority_DebugRemoveSpecialBehaviour Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ContextualQuestComponent.OnRep_SpecialBehaviourObjectsInfo
// (Final, Native, Private)

void UContextualQuestComponent::OnRep_SpecialBehaviourObjectsInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextualQuestComponent", "OnRep_SpecialBehaviourObjectsInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CoreHudRootWidget.ApplyConstrainedAspectRatio
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    isConstrained                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AspectRatio                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoreHudRootWidget::ApplyConstrainedAspectRatio(bool isConstrained, float AspectRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoreHudRootWidget", "ApplyConstrainedAspectRatio");

	Params::CoreHudRootWidget_ApplyConstrainedAspectRatio Parms{};

	Parms.isConstrained = isConstrained;
	Parms.AspectRatio = AspectRatio;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.CoreHudRootWidget.FadeInWidgets
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UCoreHudRootWidget::FadeInWidgets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoreHudRootWidget", "FadeInWidgets");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.CoreHudRootWidget.FadeOutWidgets
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UCoreHudRootWidget::FadeOutWidgets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoreHudRootWidget", "FadeOutWidgets");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.CoreHudRootWidget.SetWidgetsVisibility
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Visible                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoreHudRootWidget::SetWidgetsVisibility(bool Visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoreHudRootWidget", "SetWidgetsVisibility");

	Params::CoreHudRootWidget_SetWidgetsVisibility Parms{};

	Parms.Visible = Visible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.PlayerLockerStateComponent.Authority_OnSurvivorEndPlay
// (Final, Native, Private)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEndPlayReason                          EndPlayReason                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerLockerStateComponent::Authority_OnSurvivorEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerLockerStateComponent", "Authority_OnSurvivorEndPlay");

	Params::PlayerLockerStateComponent_Authority_OnSurvivorEndPlay Parms{};

	Parms.Actor = Actor;
	Parms.EndPlayReason = EndPlayReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerLockerStateComponent.Multicast_EjectSurvivor
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ALocker*                          Locker                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerLockerStateComponent::Multicast_EjectSurvivor(class ALocker* Locker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerLockerStateComponent", "Multicast_EjectSurvivor");

	Params::PlayerLockerStateComponent_Multicast_EjectSurvivor Parms{};

	Parms.Locker = Locker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerLockerStateComponent.OnRep_LockerBeingOpenedByPlayer
// (Final, Native, Private)

void UPlayerLockerStateComponent::OnRep_LockerBeingOpenedByPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerLockerStateComponent", "OnRep_LockerBeingOpenedByPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerLockerStateComponent.OnRep_LockerPlayerIsHidingIn
// (Final, Native, Private)

void UPlayerLockerStateComponent::OnRep_LockerPlayerIsHidingIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerLockerStateComponent", "OnRep_LockerPlayerIsHidingIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerLockerStateComponent.OnSurvivorHealthChanged
// (Final, Native, Private)
// Parameters:
// EHealthState                            before                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHealthState                            after                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerLockerStateComponent::OnSurvivorHealthChanged(EHealthState before, EHealthState after)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerLockerStateComponent", "OnSurvivorHealthChanged");

	Params::PlayerLockerStateComponent_OnSurvivorHealthChanged Parms{};

	Parms.before = before;
	Parms.after = after;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CrowBomb.TriggerLand
// (Final, Native, Public, BlueprintCallable)

void ACrowBomb::TriggerLand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrowBomb", "TriggerLand");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CrowBomb.TriggerTakeOff
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   triggerLocation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrowBomb::TriggerTakeOff(const struct FVector& triggerLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrowBomb", "TriggerTakeOff");

	Params::CrowBomb_TriggerTakeOff Parms{};

	Parms.triggerLocation = std::move(triggerLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBD_SoundClipUtil.Cosmetic_OnSoundTriggered
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBD_SoundClipUtil::Cosmetic_OnSoundTriggered(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBD_SoundClipUtil", "Cosmetic_OnSoundTriggered");

	Params::DBD_SoundClipUtil_Cosmetic_OnSoundTriggered Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBD_SoundClipUtil.GetAudioEventForMesh
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             usm                                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAkAudioEvent* UDBD_SoundClipUtil::GetAudioEventForMesh(class UStaticMeshComponent* usm)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBD_SoundClipUtil", "GetAudioEventForMesh");

	Params::DBD_SoundClipUtil_GetAudioEventForMesh Parms{};

	Parms.usm = usm;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBD_SoundClipUtil.OnCharacterEnterSoundRegion
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDBD_SoundClipUtil::OnCharacterEnterSoundRegion(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBD_SoundClipUtil", "OnCharacterEnterSoundRegion");

	Params::DBD_SoundClipUtil_OnCharacterEnterSoundRegion Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CurrencyDisplayable.BeginDestroySequence_Internal
// (Native, Event, Protected, BlueprintEvent)

void ACurrencyDisplayable::BeginDestroySequence_Internal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CurrencyDisplayable", "BeginDestroySequence_Internal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CurrencyDisplayable.FinishSpawningCurrency
// (Event, Public, BlueprintEvent)
// Parameters:
// ECurrencyType                           currencyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACurrencyDisplayable::FinishSpawningCurrency(ECurrencyType currencyType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CurrencyDisplayable", "FinishSpawningCurrency");

	Params::CurrencyDisplayable_FinishSpawningCurrency Parms{};

	Parms.currencyType = currencyType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.SurvivorDisconnectionComponent.Authority_OnPlayerDisconnected
// (Final, Native, Protected)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorDisconnectionComponent::Authority_OnPlayerDisconnected(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorDisconnectionComponent", "Authority_OnPlayerDisconnected");

	Params::SurvivorDisconnectionComponent_Authority_OnPlayerDisconnected Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorAttackableComponent.Authority_HitCosmetic
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     Attacker                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttackType                             attackType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    causeKO                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsWeaponHit                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorAttackableComponent::Authority_HitCosmetic(const class AActor* Attacker, EAttackType attackType, bool causeKO, bool IsWeaponHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorAttackableComponent", "Authority_HitCosmetic");

	Params::SurvivorAttackableComponent_Authority_HitCosmetic Parms{};

	Parms.Attacker = Attacker;
	Parms.attackType = attackType;
	Parms.causeKO = causeKO;
	Parms.IsWeaponHit = IsWeaponHit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorAttackableComponent.Multicast_HitCosmetic
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, BlueprintCallable)
// Parameters:
// const struct FPlayerHitCosmeticParams&  params                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USurvivorAttackableComponent::Multicast_HitCosmetic(const struct FPlayerHitCosmeticParams& params)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorAttackableComponent", "Multicast_HitCosmetic");

	Params::SurvivorAttackableComponent_Multicast_HitCosmetic Parms{};

	Parms.params = std::move(params);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorAttackableComponent.Multicast_HitCosmetic_NonLocal
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const struct FPlayerHitCosmeticParams&  params                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USurvivorAttackableComponent::Multicast_HitCosmetic_NonLocal(const struct FPlayerHitCosmeticParams& params)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorAttackableComponent", "Multicast_HitCosmetic_NonLocal");

	Params::SurvivorAttackableComponent_Multicast_HitCosmetic_NonLocal Parms{};

	Parms.params = std::move(params);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDDebugInputComponent.DBD_ItsAlive
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    aliveEnabled                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDDebugInputComponent::DBD_ItsAlive(bool aliveEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDDebugInputComponent", "DBD_ItsAlive");

	Params::DBDDebugInputComponent_DBD_ItsAlive Parms{};

	Parms.aliveEnabled = aliveEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomizedAnimationComponent.OnCustomizationChanged
// (Final, Native, Private)

void UCustomizedAnimationComponent::OnCustomizationChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedAnimationComponent", "OnCustomizationChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomizedAudioComponent.GetAudioSwitchState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAudioCustomizationCategory             audioCustomizationCategory                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCustomizedAudioComponent::GetAudioSwitchState(EAudioCustomizationCategory audioCustomizationCategory) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedAudioComponent", "GetAudioSwitchState");

	Params::CustomizedAudioComponent_GetAudioSwitchState Parms{};

	Parms.audioCustomizationCategory = audioCustomizationCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CustomizedAudioComponent.GetOutfitCustomizedAudioCollectionState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UCustomizedAudioComponent::GetOutfitCustomizedAudioCollectionState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedAudioComponent", "GetOutfitCustomizedAudioCollectionState");

	Params::CustomizedAudioComponent_GetOutfitCustomizedAudioCollectionState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CustomizedSkeletalMesh.ClearAllVfxs
// (Final, Native, Public, BlueprintCallable)

void UCustomizedSkeletalMesh::ClearAllVfxs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedSkeletalMesh", "ClearAllVfxs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomizedSkeletalMesh.CopyCustomization
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UCustomizedSkeletalMesh*    CopyFrom                                               (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizedSkeletalMesh::CopyCustomization(const class UCustomizedSkeletalMesh* CopyFrom)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedSkeletalMesh", "CopyCustomization");

	Params::CustomizedSkeletalMesh_CopyCustomization Parms{};

	Parms.CopyFrom = CopyFrom;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomizedSkeletalMesh.GetMeshOwner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkinnedMeshComponent*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkinnedMeshComponent* UCustomizedSkeletalMesh::GetMeshOwner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedSkeletalMesh", "GetMeshOwner");

	Params::CustomizedSkeletalMesh_GetMeshOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CustomizedSkeletalMesh.SetAllAccessoriesVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Visible                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizedSkeletalMesh::SetAllAccessoriesVisibility(bool Visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedSkeletalMesh", "SetAllAccessoriesVisibility");

	Params::CustomizedSkeletalMesh_SetAllAccessoriesVisibility Parms{};

	Parms.Visible = Visible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomizedSkeletalMesh.SetAllVfxsVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Visible                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizedSkeletalMesh::SetAllVfxsVisibility(bool Visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedSkeletalMesh", "SetAllVfxsVisibility");

	Params::CustomizedSkeletalMesh_SetAllVfxsVisibility Parms{};

	Parms.Visible = Visible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomizedSkeletalMesh.SetCastShadow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    CastShadow                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizedSkeletalMesh::SetCastShadow(bool CastShadow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedSkeletalMesh", "SetCastShadow");

	Params::CustomizedSkeletalMesh_SetCastShadow Parms{};

	Parms.CastShadow = CastShadow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomizedSkeletalMesh.SetMeshOwner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkinnedMeshComponent*            Mesh                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizedSkeletalMesh::SetMeshOwner(class USkinnedMeshComponent* Mesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedSkeletalMesh", "SetMeshOwner");

	Params::CustomizedSkeletalMesh_SetMeshOwner Parms{};

	Parms.Mesh = Mesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomizedSkeletalMesh.SetMeshVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Visible                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizedSkeletalMesh::SetMeshVisibility(bool Visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedSkeletalMesh", "SetMeshVisibility");

	Params::CustomizedSkeletalMesh_SetMeshVisibility Parms{};

	Parms.Visible = Visible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomizedSkeletalMesh.SetVfxsVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECustomizationCategory                  category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Visible                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizedSkeletalMesh::SetVfxsVisibility(ECustomizationCategory category, bool Visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedSkeletalMesh", "SetVfxsVisibility");

	Params::CustomizedSkeletalMesh_SetVfxsVisibility Parms{};

	Parms.category = category;
	Parms.Visible = Visible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomizedSkeletalMesh.Contains
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class FName>&              itemIds                                                (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomizedSkeletalMesh::Contains(const TArray<class FName>& itemIds) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedSkeletalMesh", "Contains");

	Params::CustomizedSkeletalMesh_Contains Parms{};

	Parms.itemIds = std::move(itemIds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CustomizedSkeletalMesh.GetComponents
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class USkeletalMeshComponent*>ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TArray<class USkeletalMeshComponent*> UCustomizedSkeletalMesh::GetComponents() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedSkeletalMesh", "GetComponents");

	Params::CustomizedSkeletalMesh_GetComponents Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CustomizedSkeletalMesh.GetCurrentCustomizationItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UCustomizedSkeletalMesh::GetCurrentCustomizationItems() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedSkeletalMesh", "GetCurrentCustomizationItems");

	Params::CustomizedSkeletalMesh_GetCurrentCustomizationItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CustomizedSkeletalMesh.GetMeshVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomizedSkeletalMesh::GetMeshVisibility() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedSkeletalMesh", "GetMeshVisibility");

	Params::CustomizedSkeletalMesh_GetMeshVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CustomizedSkeletalMesh.GetSkeletalMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECustomizationCategory                  category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* UCustomizedSkeletalMesh::GetSkeletalMesh(ECustomizationCategory category) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedSkeletalMesh", "GetSkeletalMesh");

	Params::CustomizedSkeletalMesh_GetSkeletalMesh Parms{};

	Parms.category = category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CustomizedSkeletalMesh.HasValidCustomization
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomizedSkeletalMesh::HasValidCustomization() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedSkeletalMesh", "HasValidCustomization");

	Params::CustomizedSkeletalMesh_HasValidCustomization Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.GetLocallyObservedPlayerRole
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerRole                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerRole UDBDCharacterUtilities::GetLocallyObservedPlayerRole(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "GetLocallyObservedPlayerRole");

	Params::DBDCharacterUtilities_GetLocallyObservedPlayerRole Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsAceVisconti
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsAceVisconti(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsAceVisconti");

	Params::DBDCharacterUtilities_IsAceVisconti Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsAdamFrancis
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsAdamFrancis(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsAdamFrancis");

	Params::DBDCharacterUtilities_IsAdamFrancis Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsAshleyWilliams
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsAshleyWilliams(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsAshleyWilliams");

	Params::DBDCharacterUtilities_IsAshleyWilliams Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsClaudetteMorel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsClaudetteMorel(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsClaudetteMorel");

	Params::DBDCharacterUtilities_IsClaudetteMorel Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsDavidKing
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsDavidKing(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsDavidKing");

	Params::DBDCharacterUtilities_IsDavidKing Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsDavidTapp
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsDavidTapp(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsDavidTapp");

	Params::DBDCharacterUtilities_IsDavidTapp Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsDwightFairfield
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsDwightFairfield(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsDwightFairfield");

	Params::DBDCharacterUtilities_IsDwightFairfield Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsFengMin
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsFengMin(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsFengMin");

	Params::DBDCharacterUtilities_IsFengMin Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsInDreamworld
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsInDreamworld(const class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsInDreamworld");

	Params::DBDCharacterUtilities_IsInDreamworld Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsInSameTeamAsLocallyObservedPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDPlayer*                 TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsInSameTeamAsLocallyObservedPlayer(const class ADBDPlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsInSameTeamAsLocallyObservedPlayer");

	Params::DBDCharacterUtilities_IsInSameTeamAsLocallyObservedPlayer Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsJakePark
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsJakePark(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsJakePark");

	Params::DBDCharacterUtilities_IsJakePark Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsJaneRomero
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsJaneRomero(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsJaneRomero");

	Params::DBDCharacterUtilities_IsJaneRomero Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsJeffJohansen
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsJeffJohansen(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsJeffJohansen");

	Params::DBDCharacterUtilities_IsJeffJohansen Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsKateDenson
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsKateDenson(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsKateDenson");

	Params::DBDCharacterUtilities_IsKateDenson Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsLaurieStrode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsLaurieStrode(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsLaurieStrode");

	Params::DBDCharacterUtilities_IsLaurieStrode Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsMegThomas
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsMegThomas(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsMegThomas");

	Params::DBDCharacterUtilities_IsMegThomas Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsNancyWheeler
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsNancyWheeler(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsNancyWheeler");

	Params::DBDCharacterUtilities_IsNancyWheeler Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsNeaKarlsson
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsNeaKarlsson(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsNeaKarlsson");

	Params::DBDCharacterUtilities_IsNeaKarlsson Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsPlague
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsPlague(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsPlague");

	Params::DBDCharacterUtilities_IsPlague Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsQuentinSmith
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsQuentinSmith(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsQuentinSmith");

	Params::DBDCharacterUtilities_IsQuentinSmith Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsSlasherLocallyObserved
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsSlasherLocallyObserved(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsSlasherLocallyObserved");

	Params::DBDCharacterUtilities_IsSlasherLocallyObserved Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsSteveHarrington
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsSteveHarrington(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsSteveHarrington");

	Params::DBDCharacterUtilities_IsSteveHarrington Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheBlight
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheBlight(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheBlight");

	Params::DBDCharacterUtilities_IsTheBlight Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheCannibal
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheCannibal(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheCannibal");

	Params::DBDCharacterUtilities_IsTheCannibal Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheClown
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheClown(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheClown");

	Params::DBDCharacterUtilities_IsTheClown Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheDemogorgon
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheDemogorgon(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheDemogorgon");

	Params::DBDCharacterUtilities_IsTheDemogorgon Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheDoctor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheDoctor(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheDoctor");

	Params::DBDCharacterUtilities_IsTheDoctor Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheExecutioner
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheExecutioner(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheExecutioner");

	Params::DBDCharacterUtilities_IsTheExecutioner Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheGhost
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheGhost(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheGhost");

	Params::DBDCharacterUtilities_IsTheGhost Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheGoodGuy
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheGoodGuy(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheGoodGuy");

	Params::DBDCharacterUtilities_IsTheGoodGuy Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheHag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheHag(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheHag");

	Params::DBDCharacterUtilities_IsTheHag Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheHillBilly
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheHillBilly(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheHillBilly");

	Params::DBDCharacterUtilities_IsTheHillBilly Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheHuntress
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheHuntress(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheHuntress");

	Params::DBDCharacterUtilities_IsTheHuntress Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheLegion
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheLegion(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheLegion");

	Params::DBDCharacterUtilities_IsTheLegion Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheNightmare
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheNightmare(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheNightmare");

	Params::DBDCharacterUtilities_IsTheNightmare Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheNurse
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheNurse(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheNurse");

	Params::DBDCharacterUtilities_IsTheNurse Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheOni
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheOni(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheOni");

	Params::DBDCharacterUtilities_IsTheOni Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheOnryo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheOnryo(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheOnryo");

	Params::DBDCharacterUtilities_IsTheOnryo Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsThePig
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsThePig(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsThePig");

	Params::DBDCharacterUtilities_IsThePig Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheShape
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheShape(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheShape");

	Params::DBDCharacterUtilities_IsTheShape Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheSpirit
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheSpirit(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheSpirit");

	Params::DBDCharacterUtilities_IsTheSpirit Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheTrapper
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheTrapper(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheTrapper");

	Params::DBDCharacterUtilities_IsTheTrapper Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheTrickster
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheTrickster(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheTrickster");

	Params::DBDCharacterUtilities_IsTheTrickster Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheTwins
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheTwins(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheTwins");

	Params::DBDCharacterUtilities_IsTheTwins Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheTwins_Brother
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheTwins_Brother(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheTwins_Brother");

	Params::DBDCharacterUtilities_IsTheTwins_Brother Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheTwins_Sister
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheTwins_Sister(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheTwins_Sister");

	Params::DBDCharacterUtilities_IsTheTwins_Sister Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheWraith
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheWraith(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheWraith");

	Params::DBDCharacterUtilities_IsTheWraith Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsWilliamBillOverbeck
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             TargetPlayer                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsWilliamBillOverbeck(const class ADBDBasePlayer* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsWilliamBillOverbeck");

	Params::DBDCharacterUtilities_IsWilliamBillOverbeck Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CustomWidgetWrapper.ApplyOpacity
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   Opacity                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomWidgetWrapper::ApplyOpacity(float Opacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomWidgetWrapper", "ApplyOpacity");

	Params::CustomWidgetWrapper_ApplyOpacity Parms{};

	Parms.Opacity = Opacity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomWidgetWrapper.ApplyScale
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomWidgetWrapper::ApplyScale(float Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomWidgetWrapper", "ApplyScale");

	Params::CustomWidgetWrapper_ApplyScale Parms{};

	Parms.Scale = Scale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomWidgetWrapper.ApplyVersion
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Version                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomWidgetWrapper::ApplyVersion(int32 Version)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomWidgetWrapper", "ApplyVersion");

	Params::CustomWidgetWrapper_ApplyVersion Parms{};

	Parms.Version = Version;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState_Menu.Client_ChangeCharacterClass
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// const class FName&                      CharacterClass                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      previousClass                                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             CharacterId                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   classChangeAttempt                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState_Menu::Client_ChangeCharacterClass(const class FName& CharacterClass, const class FName& previousClass, const int32 CharacterId, int32 classChangeAttempt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState_Menu", "Client_ChangeCharacterClass");

	Params::DBDPlayerState_Menu_Client_ChangeCharacterClass Parms{};

	Parms.CharacterClass = CharacterClass;
	Parms.previousClass = previousClass;
	Parms.CharacterId = CharacterId;
	Parms.classChangeAttempt = classChangeAttempt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState_Menu.Multicast_SetSelectedCharacterCustomization
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// EPlayerRole                             forRole                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FEquippedPlayerCustomization&Customization                                          (ConstParm, Parm, NativeAccessSpecifierPublic)

void ADBDPlayerState_Menu::Multicast_SetSelectedCharacterCustomization(EPlayerRole forRole, int32 ID, const struct FEquippedPlayerCustomization& Customization)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState_Menu", "Multicast_SetSelectedCharacterCustomization");

	Params::DBDPlayerState_Menu_Multicast_SetSelectedCharacterCustomization Parms{};

	Parms.forRole = forRole;
	Parms.ID = ID;
	Parms.Customization = std::move(Customization);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState_Menu.Multicast_SetSelectedCharacterId
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// EPlayerRole                             forRole                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    updateDisplayData                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState_Menu::Multicast_SetSelectedCharacterId(EPlayerRole forRole, int32 ID, bool updateDisplayData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState_Menu", "Multicast_SetSelectedCharacterId");

	Params::DBDPlayerState_Menu_Multicast_SetSelectedCharacterId Parms{};

	Parms.forRole = forRole;
	Parms.ID = ID;
	Parms.updateDisplayData = updateDisplayData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState_Menu.Server_NotifyOnRep
// (Net, NetReliable, Native, Event, Public, NetServer)

void ADBDPlayerState_Menu::Server_NotifyOnRep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState_Menu", "Server_NotifyOnRep");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState_Menu.Server_SetCharacterClass
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// const class FName&                      CharacterClass                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      previousClass                                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             CharacterId                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   classChangeAttempt                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    callOnRep                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState_Menu::Server_SetCharacterClass(const class FName& CharacterClass, const class FName& previousClass, const int32 CharacterId, int32 classChangeAttempt, bool callOnRep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState_Menu", "Server_SetCharacterClass");

	Params::DBDPlayerState_Menu_Server_SetCharacterClass Parms{};

	Parms.CharacterClass = CharacterClass;
	Parms.previousClass = previousClass;
	Parms.CharacterId = CharacterId;
	Parms.classChangeAttempt = classChangeAttempt;
	Parms.callOnRep = callOnRep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState_Menu.Server_SetEquipment
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// ELoadoutSlot                            Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ItemId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    callOnRep                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState_Menu::Server_SetEquipment(ELoadoutSlot Slot, class FName ItemId, bool callOnRep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState_Menu", "Server_SetEquipment");

	Params::DBDPlayerState_Menu_Server_SetEquipment Parms{};

	Parms.Slot = Slot;
	Parms.ItemId = ItemId;
	Parms.callOnRep = callOnRep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState_Menu.Server_SetEquipmentAddons
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// const TArray<class FName>&              addonItemIds                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    callOnRep                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState_Menu::Server_SetEquipmentAddons(const TArray<class FName>& addonItemIds, bool callOnRep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState_Menu", "Server_SetEquipmentAddons");

	Params::DBDPlayerState_Menu_Server_SetEquipmentAddons Parms{};

	Parms.addonItemIds = std::move(addonItemIds);
	Parms.callOnRep = callOnRep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState_Menu.Server_SetSelectedCharacterId
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    updateDisplayData                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState_Menu::Server_SetSelectedCharacterId(int32 ID, bool updateDisplayData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState_Menu", "Server_SetSelectedCharacterId");

	Params::DBDPlayerState_Menu_Server_SetSelectedCharacterId Parms{};

	Parms.ID = ID;
	Parms.updateDisplayData = updateDisplayData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomWidgetWrapper_HudEditor.AddToTranslation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector2D&                 Translation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomWidgetWrapper_HudEditor::AddToTranslation(const struct FVector2D& Translation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomWidgetWrapper_HudEditor", "AddToTranslation");

	Params::CustomWidgetWrapper_HudEditor_AddToTranslation Parms{};

	Parms.Translation = std::move(Translation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomWidgetWrapper_HudEditor.ApplyScaleWithOverlappingWrappers
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class UCustomWidgetWrapper_HudEditor*>&allEditableWrappers                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    needDetectOverlapping                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomWidgetWrapper_HudEditor::ApplyScaleWithOverlappingWrappers(float Scale, class UWidget* Widget, const TArray<class UCustomWidgetWrapper_HudEditor*>& allEditableWrappers, bool needDetectOverlapping)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomWidgetWrapper_HudEditor", "ApplyScaleWithOverlappingWrappers");

	Params::CustomWidgetWrapper_HudEditor_ApplyScaleWithOverlappingWrappers Parms{};

	Parms.Scale = Scale;
	Parms.Widget = Widget;
	Parms.allEditableWrappers = std::move(allEditableWrappers);
	Parms.needDetectOverlapping = needDetectOverlapping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomWidgetWrapper_HudEditor.ClampToViewport
// (Final, Native, Public, BlueprintCallable)

void UCustomWidgetWrapper_HudEditor::ClampToViewport()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomWidgetWrapper_HudEditor", "ClampToViewport");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomWidgetWrapper_HudEditor.FlipPositionWithChildLinkWidget
// (Final, Native, Public, BlueprintCallable)

void UCustomWidgetWrapper_HudEditor::FlipPositionWithChildLinkWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomWidgetWrapper_HudEditor", "FlipPositionWithChildLinkWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomWidgetWrapper_HudEditor.FlipScreenPosition
// (Final, Native, Public, BlueprintCallable)

void UCustomWidgetWrapper_HudEditor::FlipScreenPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomWidgetWrapper_HudEditor", "FlipScreenPosition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomWidgetWrapper_HudEditor.CanEditOpacity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomWidgetWrapper_HudEditor::CanEditOpacity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomWidgetWrapper_HudEditor", "CanEditOpacity");

	Params::CustomWidgetWrapper_HudEditor_CanEditOpacity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CustomWidgetWrapper_HudEditor.CanEditScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomWidgetWrapper_HudEditor::CanEditScale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomWidgetWrapper_HudEditor", "CanEditScale");

	Params::CustomWidgetWrapper_HudEditor_CanEditScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CustomWidgetWrapper_HudEditor.GetOpacity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCustomWidgetWrapper_HudEditor::GetOpacity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomWidgetWrapper_HudEditor", "GetOpacity");

	Params::CustomWidgetWrapper_HudEditor_GetOpacity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CustomWidgetWrapper_HudEditor.GetScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCustomWidgetWrapper_HudEditor::GetScale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomWidgetWrapper_HudEditor", "GetScale");

	Params::CustomWidgetWrapper_HudEditor_GetScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CustomWidgetWrapper_InGame.UpdateSettings
// (Final, Native, Public)

void UCustomWidgetWrapper_InGame::UpdateSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomWidgetWrapper_InGame", "UpdateSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController_Menu.Authority_SetPlayerReady
// (Final, Native, Public)
// Parameters:
// bool                                    IsReady                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController_Menu::Authority_SetPlayerReady(bool IsReady)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController_Menu", "Authority_SetPlayerReady");

	Params::DBDPlayerController_Menu_Authority_SetPlayerReady Parms{};

	Parms.IsReady = IsReady;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController_Menu.Authority_TogglePlayerReadyState
// (Final, Native, Public)

void ADBDPlayerController_Menu::Authority_TogglePlayerReadyState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController_Menu", "Authority_TogglePlayerReadyState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController_Menu.Server_GamePresetDataFromClient
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FGamePresetData&           GameState                                              (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ADBDPlayerController_Menu::Server_GamePresetDataFromClient(const struct FGamePresetData& GameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController_Menu", "Server_GamePresetDataFromClient");

	Params::DBDPlayerController_Menu_Server_GamePresetDataFromClient Parms{};

	Parms.GameState = std::move(GameState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController_Menu.Server_OverrideBackendGameplayTunables
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FBackendGameplayTunablesContainer&tunablesOverride                                       (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ADBDPlayerController_Menu::Server_OverrideBackendGameplayTunables(const struct FBackendGameplayTunablesContainer& tunablesOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController_Menu", "Server_OverrideBackendGameplayTunables");

	Params::DBDPlayerController_Menu_Server_OverrideBackendGameplayTunables Parms{};

	Parms.tunablesOverride = std::move(tunablesOverride);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController_Menu.Server_SetCharacterData
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   characterIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPlayerDataSync&           PlayerDataSync                                         (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ADBDPlayerController_Menu::Server_SetCharacterData(int32 characterIndex, const struct FPlayerDataSync& PlayerDataSync)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController_Menu", "Server_SetCharacterData");

	Params::DBDPlayerController_Menu_Server_SetCharacterData Parms{};

	Parms.characterIndex = characterIndex;
	Parms.PlayerDataSync = std::move(PlayerDataSync);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController_Menu.Server_SetCharacterLevel
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// int32                                   CharacterLevel                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PrestigeLevel                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    callOnRep                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController_Menu::Server_SetCharacterLevel(int32 CharacterLevel, int32 PrestigeLevel, bool callOnRep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController_Menu", "Server_SetCharacterLevel");

	Params::DBDPlayerController_Menu_Server_SetCharacterLevel Parms{};

	Parms.CharacterLevel = CharacterLevel;
	Parms.PrestigeLevel = PrestigeLevel;
	Parms.callOnRep = callOnRep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController_Menu.Server_SetCustomizationCharm
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FName                             CharmId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int8                                    slotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController_Menu::Server_SetCustomizationCharm(class FName CharmId, int8 slotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController_Menu", "Server_SetCustomizationCharm");

	Params::DBDPlayerController_Menu_Server_SetCustomizationCharm Parms{};

	Parms.CharmId = CharmId;
	Parms.slotIndex = slotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController_Menu.Server_SetCustomizationMeshes
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// const struct FCharacterCustomization&   Customization                                          (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ADBDPlayerController_Menu::Server_SetCustomizationMeshes(const struct FCharacterCustomization& Customization)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController_Menu", "Server_SetCustomizationMeshes");

	Params::DBDPlayerController_Menu_Server_SetCustomizationMeshes Parms{};

	Parms.Customization = std::move(Customization);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController_Menu.Server_SetEquipedPerks
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// const TArray<class FName>&              perkIds                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<int32>&                    perkLevels                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    callOnRep                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    areRandomPerks                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController_Menu::Server_SetEquipedPerks(const TArray<class FName>& perkIds, const TArray<int32>& perkLevels, bool callOnRep, bool areRandomPerks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController_Menu", "Server_SetEquipedPerks");

	Params::DBDPlayerController_Menu_Server_SetEquipedPerks Parms{};

	Parms.perkIds = std::move(perkIds);
	Parms.perkLevels = std::move(perkLevels);
	Parms.callOnRep = callOnRep;
	Parms.areRandomPerks = areRandomPerks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController_Menu.Server_SetPlayerLoadout
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FPlayerLoadoutData&        desiredLoadout                                         (Parm, NativeAccessSpecifierPublic)

void ADBDPlayerController_Menu::Server_SetPlayerLoadout(const struct FPlayerLoadoutData& desiredLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController_Menu", "Server_SetPlayerLoadout");

	Params::DBDPlayerController_Menu_Server_SetPlayerLoadout Parms{};

	Parms.desiredLoadout = std::move(desiredLoadout);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController_Menu.Server_SetPlayerReady
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    IsReady                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController_Menu::Server_SetPlayerReady(bool IsReady)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController_Menu", "Server_SetPlayerReady");

	Params::DBDPlayerController_Menu_Server_SetPlayerReady Parms{};

	Parms.IsReady = IsReady;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController_Menu.Server_SetReadyToTravel
// (Net, NetReliable, Native, Event, Public, NetServer)

void ADBDPlayerController_Menu::Server_SetReadyToTravel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController_Menu", "Server_SetReadyToTravel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController_Menu.SetPlayerReady
// (Final, Native, Public)
// Parameters:
// bool                                    IsReady                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController_Menu::SetPlayerReady(bool IsReady)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController_Menu", "SetPlayerReady");

	Params::DBDPlayerController_Menu_SetPlayerReady Parms{};

	Parms.IsReady = IsReady;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController_Menu.TogglePlayerReadyState
// (Final, Native, Public)

void ADBDPlayerController_Menu::TogglePlayerReadyState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController_Menu", "TogglePlayerReadyState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAggregateCullDistanceVolumes.SpawnCullDistanceVolumes
// (Final, Native, Public)

void ADBDAggregateCullDistanceVolumes::SpawnCullDistanceVolumes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAggregateCullDistanceVolumes", "SpawnCullDistanceVolumes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorInteractable.ServerMoveOut
// (Final, Net, Native, Event, Private, NetServer)

void ASurvivorInteractable::ServerMoveOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorInteractable", "ServerMoveOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorInteractable.SetKillInteraction
// (Final, Native, Public)
// Parameters:
// class UInteractionDefinition*           killInteraction                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASurvivorInteractable::SetKillInteraction(class UInteractionDefinition* killInteraction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorInteractable", "SetKillInteraction");

	Params::SurvivorInteractable_SetKillInteraction Parms{};

	Parms.killInteraction = killInteraction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorInteractable.UpdateTargetHPSlot
// (Final, Native, Private)

void ASurvivorInteractable::UpdateTargetHPSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorInteractable", "UpdateTargetHPSlot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorInteractable.GetOwningSurvivor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASurvivor*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASurvivor* ASurvivorInteractable::GetOwningSurvivor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorInteractable", "GetOwningSurvivor");

	Params::SurvivorInteractable_GetOwningSurvivor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SurvivorInteractable.GetSlasherInteractor
// (Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UInteractor*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractor* ASurvivorInteractable::GetSlasherInteractor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorInteractable", "GetSlasherInteractor");

	Params::SurvivorInteractable_GetSlasherInteractor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.QuickTimeEventComponent.OnRep_IsInProgress
// (Final, Native, Private)

void UQuickTimeEventComponent::OnRep_IsInProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuickTimeEventComponent", "OnRep_IsInProgress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.QuickTimeEventComponent.Server_CompleteQuickTimeEvent
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// bool                                    isSuccess                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuickTimeEventComponent::Server_CompleteQuickTimeEvent(bool isSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuickTimeEventComponent", "Server_CompleteQuickTimeEvent");

	Params::QuickTimeEventComponent_Server_CompleteQuickTimeEvent Parms{};

	Parms.isSuccess = isSuccess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIPlayerController.MovePlayerToActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Goal                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AcceptanceRadius                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIPlayerController::MovePlayerToActor(class AActor* Goal, float AcceptanceRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIPlayerController", "MovePlayerToActor");

	Params::DBDAIPlayerController_MovePlayerToActor Parms{};

	Parms.Goal = Goal;
	Parms.AcceptanceRadius = AcceptanceRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIPlayerController.OnBehaviourEndedHandler
// (Final, Native, Private)
// Parameters:
// class UAICharacterBehaviour*            behaviourEnded                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIPlayerController::OnBehaviourEndedHandler(class UAICharacterBehaviour* behaviourEnded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIPlayerController", "OnBehaviourEndedHandler");

	Params::DBDAIPlayerController_OnBehaviourEndedHandler Parms{};

	Parms.behaviourEnded = behaviourEnded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIPlayerController.PauseCharacterBehaviour
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UClass*                     behaviourClass                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIPlayerController::PauseCharacterBehaviour(const class UClass* behaviourClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIPlayerController", "PauseCharacterBehaviour");

	Params::DBDAIPlayerController_PauseCharacterBehaviour Parms{};

	Parms.behaviourClass = behaviourClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIPlayerController.ResumeCharacterBehaviour
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UClass*                     behaviourClass                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIPlayerController::ResumeCharacterBehaviour(const class UClass* behaviourClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIPlayerController", "ResumeCharacterBehaviour");

	Params::DBDAIPlayerController_ResumeCharacterBehaviour Parms{};

	Parms.behaviourClass = behaviourClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIPlayerController.StartCharacterBehaviour
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                           behaviourClass                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAICharacterBehaviourData*        characterBehaviourData                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIPlayerController::StartCharacterBehaviour(class UClass* behaviourClass, class UAICharacterBehaviourData* characterBehaviourData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIPlayerController", "StartCharacterBehaviour");

	Params::DBDAIPlayerController_StartCharacterBehaviour Parms{};

	Parms.behaviourClass = behaviourClass;
	Parms.characterBehaviourData = characterBehaviourData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIPlayerController.StopAllCharacterBehaviours
// (Final, Native, Public, BlueprintCallable)

void ADBDAIPlayerController::StopAllCharacterBehaviours()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIPlayerController", "StopAllCharacterBehaviours");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIPlayerController.StopCharacterBehaviour
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UClass*                     behaviourClass                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIPlayerController::StopCharacterBehaviour(const class UClass* behaviourClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIPlayerController", "StopCharacterBehaviour");

	Params::DBDAIPlayerController_StopCharacterBehaviour Parms{};

	Parms.behaviourClass = behaviourClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDKeyDisplayInfo.GetActionForInteractionType
// (Final, Native, Public)
// Parameters:
// EPlayerRole                             PlayerRole                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputInteractionType                   inputInteractionType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    useGamePad                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ignoreInteractMash                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UDBDKeyDisplayInfo::GetActionForInteractionType(EPlayerRole PlayerRole, EInputInteractionType inputInteractionType, bool useGamePad, bool ignoreInteractMash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDKeyDisplayInfo", "GetActionForInteractionType");

	Params::DBDKeyDisplayInfo_GetActionForInteractionType Parms{};

	Parms.PlayerRole = PlayerRole;
	Parms.inputInteractionType = inputInteractionType;
	Parms.useGamePad = useGamePad;
	Parms.ignoreInteractMash = ignoreInteractMash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDKeyDisplayInfo.GetFirstKeyForAction
// (Final, Native, Public)
// Parameters:
// class UPlayerInput*                     PlayerInput                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ActionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    useGamePad                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FKey                       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FKey UDBDKeyDisplayInfo::GetFirstKeyForAction(class UPlayerInput* PlayerInput, class FName ActionName, bool useGamePad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDKeyDisplayInfo", "GetFirstKeyForAction");

	Params::DBDKeyDisplayInfo_GetFirstKeyForAction Parms{};

	Parms.PlayerInput = PlayerInput;
	Parms.ActionName = ActionName;
	Parms.useGamePad = useGamePad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDKeyDisplayInfo.GetKeyDisplayInfo
// (Final, Native, Public)
// Parameters:
// const struct FKey&                      Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FKeyDisplayInfo            ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FKeyDisplayInfo UDBDKeyDisplayInfo::GetKeyDisplayInfo(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDKeyDisplayInfo", "GetKeyDisplayInfo");

	Params::DBDKeyDisplayInfo_GetKeyDisplayInfo Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDKeyDisplayInfo.GetKeyDisplayInfoForInteractionType
// (Final, Native, Public)
// Parameters:
// class UPlayerInput*                     PlayerInput                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerRole                             PlayerRole                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputInteractionType                   interactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    useGamePad                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FKeyDisplayInfo            ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FKeyDisplayInfo UDBDKeyDisplayInfo::GetKeyDisplayInfoForInteractionType(class UPlayerInput* PlayerInput, EPlayerRole PlayerRole, EInputInteractionType interactionType, bool useGamePad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDKeyDisplayInfo", "GetKeyDisplayInfoForInteractionType");

	Params::DBDKeyDisplayInfo_GetKeyDisplayInfoForInteractionType Parms{};

	Parms.PlayerInput = PlayerInput;
	Parms.PlayerRole = PlayerRole;
	Parms.interactionType = interactionType;
	Parms.useGamePad = useGamePad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDKeyDisplayInfo.IsExcludedKey
// (Final, Native, Public)
// Parameters:
// const struct FKey&                      Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool UDBDKeyDisplayInfo::IsExcludedKey(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDKeyDisplayInfo", "IsExcludedKey");

	Params::DBDKeyDisplayInfo_IsExcludedKey Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDKeyDisplayInfo.IsIgnoredKey
// (Final, Native, Public)
// Parameters:
// const struct FKey&                      Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool UDBDKeyDisplayInfo::IsIgnoredKey(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDKeyDisplayInfo", "IsIgnoredKey");

	Params::DBDKeyDisplayInfo_IsIgnoredKey Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SectionnedChargeableComponent.GetSectionChargeRemaining
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USectionnedChargeableComponent::GetSectionChargeRemaining() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SectionnedChargeableComponent", "GetSectionChargeRemaining");

	Params::SectionnedChargeableComponent_GetSectionChargeRemaining Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.VaultableOutlineUpdateStrategy.SetCanBeRevealedToLocalPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    canBeRevealedToLocalPlayer                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVaultableOutlineUpdateStrategy::SetCanBeRevealedToLocalPlayer(bool canBeRevealedToLocalPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VaultableOutlineUpdateStrategy", "SetCanBeRevealedToLocalPlayer");

	Params::VaultableOutlineUpdateStrategy_SetCanBeRevealedToLocalPlayer Parms{};

	Parms.canBeRevealedToLocalPlayer = canBeRevealedToLocalPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DreamPalletOutlineUpdateStrategy.InitializeTunableValues
// (Final, Native, Protected)
// Parameters:
// class AKiller*                          Killer                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDreamPalletOutlineUpdateStrategy::InitializeTunableValues(class AKiller* Killer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamPalletOutlineUpdateStrategy", "InitializeTunableValues");

	Params::DreamPalletOutlineUpdateStrategy_InitializeTunableValues Parms{};

	Parms.Killer = Killer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAttackerComponent.Local_RequestAttack
// (Native, Public, BlueprintCallable)
// Parameters:
// const EAttackType                       attackType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDAttackerComponent::Local_RequestAttack(const EAttackType attackType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttackerComponent", "Local_RequestAttack");

	Params::DBDAttackerComponent_Local_RequestAttack Parms{};

	Parms.attackType = attackType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAttackerComponent.Multicast_StoreAttack
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const EAttackType                       attackType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDAttackerComponent::Multicast_StoreAttack(const EAttackType attackType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttackerComponent", "Multicast_StoreAttack");

	Params::DBDAttackerComponent_Multicast_StoreAttack Parms{};

	Parms.attackType = attackType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAttackerComponent.Server_StoreAttack
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const EAttackType                       attackType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDAttackerComponent::Server_StoreAttack(const EAttackType attackType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttackerComponent", "Server_StoreAttack");

	Params::DBDAttackerComponent_Server_StoreAttack Parms{};

	Parms.attackType = attackType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAttackerComponent.IsAnyAttackTransitionRequested
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDAttackerComponent::IsAnyAttackTransitionRequested() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttackerComponent", "IsAnyAttackTransitionRequested");

	Params::DBDAttackerComponent_IsAnyAttackTransitionRequested Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDAttackerComponent.IsAttacking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDAttackerComponent::IsAttacking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttackerComponent", "IsAttacking");

	Params::DBDAttackerComponent_IsAttacking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDAttackerComponent.IsAttackTransitionRequested
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const EAttackType                       attackType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDAttackerComponent::IsAttackTransitionRequested(const EAttackType attackType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttackerComponent", "IsAttackTransitionRequested");

	Params::DBDAttackerComponent_IsAttackTransitionRequested Parms{};

	Parms.attackType = attackType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDAttackUtilities.GetCurrentAttackSubstateRemainingTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Attacker                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDAttackUtilities::GetCurrentAttackSubstateRemainingTime(const class AActor* Attacker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDAttackUtilities", "GetCurrentAttackSubstateRemainingTime");

	Params::DBDAttackUtilities_GetCurrentAttackSubstateRemainingTime Parms{};

	Parms.Attacker = Attacker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDAttackUtilities.GetCurrentAttackType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Attacker                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttackType                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAttackType UDBDAttackUtilities::GetCurrentAttackType(const class AActor* Attacker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDAttackUtilities", "GetCurrentAttackType");

	Params::DBDAttackUtilities_GetCurrentAttackType Parms{};

	Parms.Attacker = Attacker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrapUtilities.GetAttachedRBT
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AReverseBearTrap*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AReverseBearTrap* UReverseBearTrapUtilities::GetAttachedRBT(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ReverseBearTrapUtilities", "GetAttachedRBT");

	Params::ReverseBearTrapUtilities_GetAttachedRBT Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDChildActorSpawnerComponent.BP_DestroyChild
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDChildActorSpawnerComponent::BP_DestroyChild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDChildActorSpawnerComponent", "BP_DestroyChild");

	Params::DBDChildActorSpawnerComponent_BP_DestroyChild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDChildActorSpawnerComponent.BP_SpawnChild
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDChildActorSpawnerComponent::BP_SpawnChild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDChildActorSpawnerComponent", "BP_SpawnChild");

	Params::DBDChildActorSpawnerComponent_BP_SpawnChild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDChildActorSpawnerComponent.BP_SpawnChildWithParams
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDBDChildActorSpawnParams& SpawnParams                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDChildActorSpawnerComponent::BP_SpawnChildWithParams(const struct FDBDChildActorSpawnParams& SpawnParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDChildActorSpawnerComponent", "BP_SpawnChildWithParams");

	Params::DBDChildActorSpawnerComponent_BP_SpawnChildWithParams Parms{};

	Parms.SpawnParams = std::move(SpawnParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDChildActorSpawnerComponent.OnRep_Child
// (Final, Native, Protected)

void UDBDChildActorSpawnerComponent::OnRep_Child()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDChildActorSpawnerComponent", "OnRep_Child");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDChildActorSpawnerComponent.BP_GetChild
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UDBDChildActorSpawnerComponent::BP_GetChild() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDChildActorSpawnerComponent", "BP_GetChild");

	Params::DBDChildActorSpawnerComponent_BP_GetChild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDChildActorSpawnerComponent.BP_IsChildAttached
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDChildActorSpawnerComponent::BP_IsChildAttached() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDChildActorSpawnerComponent", "BP_IsChildAttached");

	Params::DBDChildActorSpawnerComponent_BP_IsChildAttached Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDChildActorSpawnerComponent.BP_IsChildSpawned
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDChildActorSpawnerComponent::BP_IsChildSpawned() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDChildActorSpawnerComponent", "BP_IsChildSpawned");

	Params::DBDChildActorSpawnerComponent_BP_IsChildSpawned Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDDiceRoller.CalculateOverTimeRollResult
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     RollingActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseProbability                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ExpectedTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MultiplicativeModifier                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AdditiveModifier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDDiceRoller::CalculateOverTimeRollResult(const class AActor* RollingActor, float BaseProbability, float DeltaTime, float ExpectedTime, float MultiplicativeModifier, float AdditiveModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDDiceRoller", "CalculateOverTimeRollResult");

	Params::DBDDiceRoller_CalculateOverTimeRollResult Parms{};

	Parms.RollingActor = RollingActor;
	Parms.BaseProbability = BaseProbability;
	Parms.DeltaTime = DeltaTime;
	Parms.ExpectedTime = ExpectedTime;
	Parms.MultiplicativeModifier = MultiplicativeModifier;
	Parms.AdditiveModifier = AdditiveModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDDiceRoller.CalculateRollResult
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     RollingActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseProbability                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MultiplicativeModifier                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AdditiveModifier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDDiceRoller::CalculateRollResult(const class AActor* RollingActor, float BaseProbability, float MultiplicativeModifier, float AdditiveModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDDiceRoller", "CalculateRollResult");

	Params::DBDDiceRoller_CalculateRollResult Parms{};

	Parms.RollingActor = RollingActor;
	Parms.BaseProbability = BaseProbability;
	Parms.MultiplicativeModifier = MultiplicativeModifier;
	Parms.AdditiveModifier = AdditiveModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDDiceRoller.CalculateTickedRollResult
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     RollingActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseProbability                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ticks                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MultiplicativeModifier                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AdditiveModifier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDDiceRoller::CalculateTickedRollResult(const class AActor* RollingActor, float BaseProbability, float ticks, float MultiplicativeModifier, float AdditiveModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDDiceRoller", "CalculateTickedRollResult");

	Params::DBDDiceRoller_CalculateTickedRollResult Parms{};

	Parms.RollingActor = RollingActor;
	Parms.BaseProbability = BaseProbability;
	Parms.ticks = ticks;
	Parms.MultiplicativeModifier = MultiplicativeModifier;
	Parms.AdditiveModifier = AdditiveModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDDiceRoller.GetInteractionRollSuccessPercentageByDiceRollType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UInteractionDefinition*     Interaction                                            (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ADBDPlayer*                 rollingPlayer                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDiceRollType                           DiceRollType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDDiceRoller::GetInteractionRollSuccessPercentageByDiceRollType(const class UInteractionDefinition* Interaction, const class ADBDPlayer* rollingPlayer, EDiceRollType DiceRollType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDDiceRoller", "GetInteractionRollSuccessPercentageByDiceRollType");

	Params::DBDDiceRoller_GetInteractionRollSuccessPercentageByDiceRollType Parms{};

	Parms.Interaction = Interaction;
	Parms.rollingPlayer = rollingPlayer;
	Parms.DiceRollType = DiceRollType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDDiceRoller.GetRollResultByDiceRollType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class ADBDPlayer*                 rollingPlayer                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDiceRollType                           DiceRollType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDDiceRoller::GetRollResultByDiceRollType(const class ADBDPlayer* rollingPlayer, EDiceRollType DiceRollType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDDiceRoller", "GetRollResultByDiceRollType");

	Params::DBDDiceRoller_GetRollResultByDiceRollType Parms{};

	Parms.rollingPlayer = rollingPlayer;
	Parms.DiceRollType = DiceRollType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDDiceRoller.GetRollResultByTunableValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     RollingActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TunableValueName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MultiplicativeModifier                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AdditiveModifier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDDiceRoller::GetRollResultByTunableValue(const class AActor* RollingActor, class FName TunableValueName, float MultiplicativeModifier, float AdditiveModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDDiceRoller", "GetRollResultByTunableValue");

	Params::DBDDiceRoller_GetRollResultByTunableValue Parms{};

	Parms.RollingActor = RollingActor;
	Parms.TunableValueName = TunableValueName;
	Parms.MultiplicativeModifier = MultiplicativeModifier;
	Parms.AdditiveModifier = AdditiveModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameEventUtilities.Authority_AccumulateOngoingGameEvent
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CustomValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OngoingWaitTime                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          CustomObjectParameter                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CustomIntValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameEventUtilities::Authority_AccumulateOngoingGameEvent(const class UObject* WorldContextObject, const struct FGameplayTag& gameEventType, class ADBDPlayer* Instigator, class AActor* Target, float CustomValue, float OngoingWaitTime, class UObject* CustomObjectParameter, int32 CustomIntValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDGameEventUtilities", "Authority_AccumulateOngoingGameEvent");

	Params::DBDGameEventUtilities_Authority_AccumulateOngoingGameEvent Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.gameEventType = std::move(gameEventType);
	Parms.Instigator = Instigator;
	Parms.Target = Target;
	Parms.CustomValue = CustomValue;
	Parms.OngoingWaitTime = OngoingWaitTime;
	Parms.CustomObjectParameter = CustomObjectParameter;
	Parms.CustomIntValue = CustomIntValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameEventUtilities.Authority_DispatcherFireGameEvent
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    broadcastOverNetwork                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CustomValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          CustomObjectParameter                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CustomIntValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameEventUtilities::Authority_DispatcherFireGameEvent(const class UObject* WorldContextObject, const struct FGameplayTag& gameEventType, bool broadcastOverNetwork, class ADBDPlayer* Instigator, class AActor* Target, float CustomValue, class UObject* CustomObjectParameter, int32 CustomIntValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDGameEventUtilities", "Authority_DispatcherFireGameEvent");

	Params::DBDGameEventUtilities_Authority_DispatcherFireGameEvent Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.gameEventType = std::move(gameEventType);
	Parms.broadcastOverNetwork = broadcastOverNetwork;
	Parms.Instigator = Instigator;
	Parms.Target = Target;
	Parms.CustomValue = CustomValue;
	Parms.CustomObjectParameter = CustomObjectParameter;
	Parms.CustomIntValue = CustomIntValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameEventUtilities.DispatcherFireGameEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    broadcastOverNetwork                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CustomValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          CustomObjectParameter                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CustomIntValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameEventUtilities::DispatcherFireGameEvent(const class UObject* WorldContextObject, const struct FGameplayTag& gameEventType, bool broadcastOverNetwork, class ADBDPlayer* Instigator, class AActor* Target, float CustomValue, class UObject* CustomObjectParameter, int32 CustomIntValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDGameEventUtilities", "DispatcherFireGameEvent");

	Params::DBDGameEventUtilities_DispatcherFireGameEvent Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.gameEventType = std::move(gameEventType);
	Parms.broadcastOverNetwork = broadcastOverNetwork;
	Parms.Instigator = Instigator;
	Parms.Target = Target;
	Parms.CustomValue = CustomValue;
	Parms.CustomObjectParameter = CustomObjectParameter;
	Parms.CustomIntValue = CustomIntValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameEventUtilities.LocallyDispatchGameEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CustomValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          CustomObjectParameter                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CustomIntValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameEventUtilities::LocallyDispatchGameEvent(const class UObject* WorldContextObject, const struct FGameplayTag& gameEventType, class ADBDPlayer* Instigator, class AActor* Target, float CustomValue, class UObject* CustomObjectParameter, int32 CustomIntValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDGameEventUtilities", "LocallyDispatchGameEvent");

	Params::DBDGameEventUtilities_LocallyDispatchGameEvent Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.gameEventType = std::move(gameEventType);
	Parms.Instigator = Instigator;
	Parms.Target = Target;
	Parms.CustomValue = CustomValue;
	Parms.CustomObjectParameter = CustomObjectParameter;
	Parms.CustomIntValue = CustomIntValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameEventUtilities.RemotelyDispatchGameEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CustomValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          CustomObjectParameter                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CustomIntValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameEventUtilities::RemotelyDispatchGameEvent(const class UObject* WorldContextObject, const struct FGameplayTag& gameEventType, class ADBDPlayer* Instigator, class AActor* Target, float CustomValue, class UObject* CustomObjectParameter, int32 CustomIntValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDGameEventUtilities", "RemotelyDispatchGameEvent");

	Params::DBDGameEventUtilities_RemotelyDispatchGameEvent Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.gameEventType = std::move(gameEventType);
	Parms.Instigator = Instigator;
	Parms.Target = Target;
	Parms.CustomValue = CustomValue;
	Parms.CustomObjectParameter = CustomObjectParameter;
	Parms.CustomIntValue = CustomIntValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameFlowUtilities.IsCurrentlyInGame
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UDBDGameInstance*           GameInstance                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDGameFlowUtilities::IsCurrentlyInGame(const class UDBDGameInstance* GameInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDGameFlowUtilities", "IsCurrentlyInGame");

	Params::DBDGameFlowUtilities_IsCurrentlyInGame Parms{};

	Parms.GameInstance = GameInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameFlowUtilities.TriggerUIFlowEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUIFlowEvent                            uiFlowEvent                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    forceChange                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameFlowUtilities::TriggerUIFlowEvent(class UObject* WorldContextObject, EUIFlowEvent uiFlowEvent, bool forceChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDGameFlowUtilities", "TriggerUIFlowEvent");

	Params::DBDGameFlowUtilities_TriggerUIFlowEvent Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.uiFlowEvent = uiFlowEvent;
	Parms.forceChange = forceChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameFlowUtilities.TriggerWorldFlowEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWorldFlowEvent                         worldFlowEvent                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameFlowUtilities::TriggerWorldFlowEvent(class UObject* WorldContextObject, EWorldFlowEvent worldFlowEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDGameFlowUtilities", "TriggerWorldFlowEvent");

	Params::DBDGameFlowUtilities_TriggerWorldFlowEvent Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.worldFlowEvent = worldFlowEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDMaterialBlueprintLibrary.CreateDynamicMaterialInstanceForParticleSystem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UParticleSystemComponent*         System                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UMaterialInstanceDynamic*> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UMaterialInstanceDynamic*> UDBDMaterialBlueprintLibrary::CreateDynamicMaterialInstanceForParticleSystem(class UParticleSystemComponent* System)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDMaterialBlueprintLibrary", "CreateDynamicMaterialInstanceForParticleSystem");

	Params::DBDMaterialBlueprintLibrary_CreateDynamicMaterialInstanceForParticleSystem Parms{};

	Parms.System = System;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDMaterialBlueprintLibrary.SetTransformParameterInverseValueOnMaterialDynamic
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         Material                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                Value                                                  (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDMaterialBlueprintLibrary::SetTransformParameterInverseValueOnMaterialDynamic(class UMaterialInstanceDynamic* Material, class FName ParameterName, const struct FTransform& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDMaterialBlueprintLibrary", "SetTransformParameterInverseValueOnMaterialDynamic");

	Params::DBDMaterialBlueprintLibrary_SetTransformParameterInverseValueOnMaterialDynamic Parms{};

	Parms.Material = Material;
	Parms.ParameterName = ParameterName;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDMaterialBlueprintLibrary.SetTransformParameterValueOnMaterialDynamic
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         Material                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                Value                                                  (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDMaterialBlueprintLibrary::SetTransformParameterValueOnMaterialDynamic(class UMaterialInstanceDynamic* Material, class FName ParameterName, const struct FTransform& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDMaterialBlueprintLibrary", "SetTransformParameterValueOnMaterialDynamic");

	Params::DBDMaterialBlueprintLibrary_SetTransformParameterValueOnMaterialDynamic Parms{};

	Parms.Material = Material;
	Parms.ParameterName = ParameterName;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDMaterialBlueprintLibrary.SetTransformParameterValueOnMeshComponent
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   Mesh                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                Value                                                  (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDMaterialBlueprintLibrary::SetTransformParameterValueOnMeshComponent(class UMeshComponent* Mesh, class FName ParameterName, const struct FTransform& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDMaterialBlueprintLibrary", "SetTransformParameterValueOnMeshComponent");

	Params::DBDMaterialBlueprintLibrary_SetTransformParameterValueOnMeshComponent Parms{};

	Parms.Mesh = Mesh;
	Parms.ParameterName = ParameterName;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDMaterialBlueprintLibrary.SetVectorParameterValueOnMeshComponent
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   Mesh                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDMaterialBlueprintLibrary::SetVectorParameterValueOnMeshComponent(class UMeshComponent* Mesh, class FName ParameterName, const struct FLinearColor& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDMaterialBlueprintLibrary", "SetVectorParameterValueOnMeshComponent");

	Params::DBDMaterialBlueprintLibrary_SetVectorParameterValueOnMeshComponent Parms{};

	Parms.Mesh = Mesh;
	Parms.ParameterName = ParameterName;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDNavEvadeLoopComponent.OnLevelReadyToPlay
// (Final, Native, Private)

void UDBDNavEvadeLoopComponent::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDNavEvadeLoopComponent", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDObserverPlayer.Server_PlayerReady
// (Net, NetReliable, Native, Event, Public, NetServer)

void ADBDObserverPlayer::Server_PlayerReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDObserverPlayer", "Server_PlayerReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.ActivateAI
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Activate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   playerRank                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController::ActivateAI(bool Activate, int32 playerRank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "ActivateAI");

	Params::DBDPlayerController_ActivateAI Parms{};

	Parms.Activate = Activate;
	Parms.playerRank = playerRank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.Client_SetPlayerFinishStats
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// const struct FPlayerFinishStats&        Stats                                                  (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ADBDPlayerController::Client_SetPlayerFinishStats(const struct FPlayerFinishStats& Stats)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "Client_SetPlayerFinishStats");

	Params::DBDPlayerController_Client_SetPlayerFinishStats Parms{};

	Parms.Stats = std::move(Stats);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.Client_SetSpectatorMode
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                                    On                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController::Client_SetSpectatorMode(bool On)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "Client_SetSpectatorMode");

	Params::DBDPlayerController_Client_SetSpectatorMode Parms{};

	Parms.On = On;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.Client_SetSpectatorModeInEditor
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                                    On                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayerState*                  spectatingPlayerState                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController::Client_SetSpectatorModeInEditor(bool On, class ADBDPlayerState* spectatingPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "Client_SetSpectatorModeInEditor");

	Params::DBDPlayerController_Client_SetSpectatorModeInEditor Parms{};

	Parms.On = On;
	Parms.spectatingPlayerState = spectatingPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.Client_SpectateAI
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// class APawn*                            aiPawn                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController::Client_SpectateAI(class APawn* aiPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "Client_SpectateAI");

	Params::DBDPlayerController_Client_SpectateAI Parms{};

	Parms.aiPawn = aiPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.ImplementRunLockMechanic
// (Final, Native, Public, BlueprintCallable)

void ADBDPlayerController::ImplementRunLockMechanic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "ImplementRunLockMechanic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.OnRep_Fence
// (Final, Native, Private)

void ADBDPlayerController::OnRep_Fence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "OnRep_Fence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.Server_ClientTimeSinceLastLoadingProgress
// (Net, Native, Event, Public, NetServer)
// Parameters:
// float                                   lastProgression                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController::Server_ClientTimeSinceLastLoadingProgress(float lastProgression)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "Server_ClientTimeSinceLastLoadingProgress");

	Params::DBDPlayerController_Server_ClientTimeSinceLastLoadingProgress Parms{};

	Parms.lastProgression = lastProgression;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.Server_DebugSend
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const class FString&                    Data                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController::Server_DebugSend(const class FString& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "Server_DebugSend");

	Params::DBDPlayerController_Server_DebugSend Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.Server_ForceGameObjectivesCompleted
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    COMPLETED                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController::Server_ForceGameObjectivesCompleted(bool COMPLETED)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "Server_ForceGameObjectivesCompleted");

	Params::DBDPlayerController_Server_ForceGameObjectivesCompleted Parms{};

	Parms.COMPLETED = COMPLETED;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.Server_InitiateSecretRewardProcess
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const TArray<class FName>&              unclaimedIds                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ADBDPlayerController::Server_InitiateSecretRewardProcess(const TArray<class FName>& unclaimedIds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "Server_InitiateSecretRewardProcess");

	Params::DBDPlayerController_Server_InitiateSecretRewardProcess Parms{};

	Parms.unclaimedIds = std::move(unclaimedIds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.Server_LeaveGame
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    joiningLobby                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController::Server_LeaveGame(bool joiningLobby)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "Server_LeaveGame");

	Params::DBDPlayerController_Server_LeaveGame Parms{};

	Parms.joiningLobby = joiningLobby;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.Server_NotifyHasMoved
// (Net, NetReliable, Native, Event, Public, NetServer)

void ADBDPlayerController::Server_NotifyHasMoved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "Server_NotifyHasMoved");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.Server_RequestEndGame
// (Net, NetReliable, Native, Event, Public, NetServer)

void ADBDPlayerController::Server_RequestEndGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "Server_RequestEndGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.Server_SetReadyToTravel
// (Net, NetReliable, Native, Event, Public, NetServer)

void ADBDPlayerController::Server_SetReadyToTravel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "Server_SetReadyToTravel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.Server_SetSpectatorMode
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// bool                                    On                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController::Server_SetSpectatorMode(bool On)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "Server_SetSpectatorMode");

	Params::DBDPlayerController_Server_SetSpectatorMode Parms{};

	Parms.On = On;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.Server_SetSpectatorModeInEditor
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    On                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayerState*                  spectatingPlayerState                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController::Server_SetSpectatorModeInEditor(bool On, class ADBDPlayerState* spectatingPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "Server_SetSpectatorModeInEditor");

	Params::DBDPlayerController_Server_SetSpectatorModeInEditor Parms{};

	Parms.On = On;
	Parms.spectatingPlayerState = spectatingPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.Server_ViewPlayerWithId
// (Net, Native, Event, Public, NetServer)
// Parameters:
// const class FString&                    PlayerId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController::Server_ViewPlayerWithId(const class FString& PlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "Server_ViewPlayerWithId");

	Params::DBDPlayerController_Server_ViewPlayerWithId Parms{};

	Parms.PlayerId = std::move(PlayerId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.ServerViewPlayer
// (Net, Native, Event, Public, NetServer)
// Parameters:
// const class FString&                    PlayerName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController::ServerViewPlayer(const class FString& PlayerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "ServerViewPlayer");

	Params::DBDPlayerController_ServerViewPlayer Parms{};

	Parms.PlayerName = std::move(PlayerName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.GetAIPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* ADBDPlayerController::GetAIPawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "GetAIPawn");

	Params::DBDPlayerController_GetAIPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayerController.GetControlledPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* ADBDPlayerController::GetControlledPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "GetControlledPlayer");

	Params::DBDPlayerController_GetControlledPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayerController.GetSpectatedPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* ADBDPlayerController::GetSpectatedPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "GetSpectatedPlayer");

	Params::DBDPlayerController_GetSpectatedPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayerController.GetSpectatedPlayerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayerState*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayerState* ADBDPlayerController::GetSpectatedPlayerState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "GetSpectatedPlayerState");

	Params::DBDPlayerController_GetSpectatedPlayerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayerController.IsSpectating
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayerController::IsSpectating() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "IsSpectating");

	Params::DBDPlayerController_IsSpectating Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayerController.MobileJoystickInput_Pressed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   joystickIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayerController::MobileJoystickInput_Pressed(int32 joystickIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "MobileJoystickInput_Pressed");

	Params::DBDPlayerController_MobileJoystickInput_Pressed Parms{};

	Parms.joystickIndex = joystickIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayerData.Server_CampaignDataSynced
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void UDBDPlayerData::Server_CampaignDataSynced()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerData", "Server_CampaignDataSynced");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerData.Server_LoadoutSpawned
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void UDBDPlayerData::Server_LoadoutSpawned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerData", "Server_LoadoutSpawned");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerData.Server_NotifyAIPawnReady
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void UDBDPlayerData::Server_NotifyAIPawnReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerData", "Server_NotifyAIPawnReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerData.Server_RenderingFeaturesCompleted
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void UDBDPlayerData::Server_RenderingFeaturesCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerData", "Server_RenderingFeaturesCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerData.Server_SetIntroCompleted
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void UDBDPlayerData::Server_SetIntroCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerData", "Server_SetIntroCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerData.Server_SetKillerSpecificComponentReady
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void UDBDPlayerData::Server_SetKillerSpecificComponentReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerData", "Server_SetKillerSpecificComponentReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerData.Server_SetMapSpecificComponentReady
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const class FString&                    componentName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDPlayerData::Server_SetMapSpecificComponentReady(const class FString& componentName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerData", "Server_SetMapSpecificComponentReady");

	Params::DBDPlayerData_Server_SetMapSpecificComponentReady Parms{};

	Parms.componentName = std::move(componentName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerData.Server_SetMutatorComponentReady
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void UDBDPlayerData::Server_SetMutatorComponentReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerData", "Server_SetMutatorComponentReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerData.Server_SetPlayerReady
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void UDBDPlayerData::Server_SetPlayerReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerData", "Server_SetPlayerReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerData.GetControlRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UDBDPlayerData::GetControlRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerData", "GetControlRotation");

	Params::DBDPlayerData_GetControlRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayerData.IsInteractionInputPressed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInputInteractionType                   interactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDPlayerData::IsInteractionInputPressed(EInputInteractionType interactionType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerData", "IsInteractionInputPressed");

	Params::DBDPlayerData_IsInteractionInputPressed Parms{};

	Parms.interactionType = interactionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDProjectileUtilities.CreateProjectilePoolAdapter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Outer_0                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAuthoritativeActorPoolComponent* Pool                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAuthoritativePoolProjectileProviderAdapter*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAuthoritativePoolProjectileProviderAdapter* UDBDProjectileUtilities::CreateProjectilePoolAdapter(class UObject* Outer_0, class UAuthoritativeActorPoolComponent* Pool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDProjectileUtilities", "CreateProjectilePoolAdapter");

	Params::DBDProjectileUtilities_CreateProjectilePoolAdapter Parms{};

	Parms.Outer_0 = Outer_0;
	Parms.Pool = Pool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDSpecialEventUtilities.DoesPlayerHasEventOffering
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOfferingEffectType                     offeringEffectType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDSpecialEventUtilities::DoesPlayerHasEventOffering(const class ADBDPlayer* Player, EOfferingEffectType offeringEffectType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDSpecialEventUtilities", "DoesPlayerHasEventOffering");

	Params::DBDSpecialEventUtilities_DoesPlayerHasEventOffering Parms{};

	Parms.Player = Player;
	Parms.offeringEffectType = offeringEffectType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDSurfaceTypeName.Convert
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EPhysicalSurface                  SurfaceType                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UDBDSurfaceTypeName::Convert(const EPhysicalSurface SurfaceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDSurfaceTypeName", "Convert");

	Params::DBDSurfaceTypeName_Convert Parms{};

	Parms.SurfaceType = SurfaceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDSurfaceTypeName.ConvertFromPhysicalMaterial
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UPhysicalMaterial*          Material                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UDBDSurfaceTypeName::ConvertFromPhysicalMaterial(const class UPhysicalMaterial* Material)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDSurfaceTypeName", "ConvertFromPhysicalMaterial");

	Params::DBDSurfaceTypeName_ConvertFromPhysicalMaterial Parms{};

	Parms.Material = Material;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDSurfaceTypeName.GetSurfaceName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UPhysicalMaterial*          PhysicalMaterial                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDBDSurfaceTypeName::GetSurfaceName(const class UPhysicalMaterial* PhysicalMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDSurfaceTypeName", "GetSurfaceName");

	Params::DBDSurfaceTypeName_GetSurfaceName Parms{};

	Parms.PhysicalMaterial = PhysicalMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDSurfaceTypeName.GetSurfaceType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UPhysicalMaterial*          PhysicalMaterial                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhysicalSurface                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPhysicalSurface UDBDSurfaceTypeName::GetSurfaceType(const class UPhysicalMaterial* PhysicalMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDSurfaceTypeName", "GetSurfaceType");

	Params::DBDSurfaceTypeName_GetSurfaceType Parms{};

	Parms.PhysicalMaterial = PhysicalMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDTagUtilities.ActorHasReplicatedTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDTagUtilities::ActorHasReplicatedTag(const class AActor* Actor, class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDTagUtilities", "ActorHasReplicatedTag");

	Params::DBDTagUtilities_ActorHasReplicatedTag Parms{};

	Parms.Actor = Actor;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDTagUtilities.GetAllActorsOfClassWithReplicatedTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ActorClass                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>*                  OutActors                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDBDTagUtilities::GetAllActorsOfClassWithReplicatedTag(const class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, class FName Tag, TArray<class AActor*>* OutActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDTagUtilities", "GetAllActorsOfClassWithReplicatedTag");

	Params::DBDTagUtilities_GetAllActorsOfClassWithReplicatedTag Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ActorClass = ActorClass;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);
}


// Function DeadByDaylight.DBDTagUtilities.GetAllActorsWithReplicatedTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>*                  OutActors                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDBDTagUtilities::GetAllActorsWithReplicatedTag(const class UObject* WorldContextObject, class FName Tag, TArray<class AActor*>* OutActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDTagUtilities", "GetAllActorsWithReplicatedTag");

	Params::DBDTagUtilities_GetAllActorsWithReplicatedTag Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);
}


// Function DeadByDaylight.DBDTimerComponent.Pause
// (Final, Native, Public, BlueprintCallable)

void UDBDTimerComponent::Pause()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDTimerComponent", "Pause");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDTimerComponent.Reset
// (Final, Native, Public, BlueprintCallable)

void UDBDTimerComponent::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDTimerComponent", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDTimerComponent.ResetTo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDTimerComponent::ResetTo(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDTimerComponent", "ResetTo");

	Params::DBDTimerComponent_ResetTo Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDTimerComponent.Stop
// (Final, Native, Public, BlueprintCallable)

void UDBDTimerComponent::Stop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDTimerComponent", "Stop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDTimerComponent.Unpause
// (Final, Native, Public, BlueprintCallable)

void UDBDTimerComponent::Unpause()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDTimerComponent", "Unpause");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDTimerComponent.Update
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDTimerComponent::Update(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDTimerComponent", "Update");

	Params::DBDTimerComponent_Update Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDTimerComponent.GetPercentTimeElapsed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDTimerComponent::GetPercentTimeElapsed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDTimerComponent", "GetPercentTimeElapsed");

	Params::DBDTimerComponent_GetPercentTimeElapsed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDTimerComponent.GetPercentTimeLeft
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDTimerComponent::GetPercentTimeLeft() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDTimerComponent", "GetPercentTimeLeft");

	Params::DBDTimerComponent_GetPercentTimeLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDTimerComponent.GetStartTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDTimerComponent::GetStartTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDTimerComponent", "GetStartTime");

	Params::DBDTimerComponent_GetStartTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDTimerComponent.GetTimeElapsed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDTimerComponent::GetTimeElapsed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDTimerComponent", "GetTimeElapsed");

	Params::DBDTimerComponent_GetTimeElapsed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDTimerComponent.GetTimeLeft
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDTimerComponent::GetTimeLeft() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDTimerComponent", "GetTimeLeft");

	Params::DBDTimerComponent_GetTimeLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDTimerComponent.IsDone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDTimerComponent::IsDone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDTimerComponent", "IsDone");

	Params::DBDTimerComponent_IsDone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDTimerComponent.IsOnPause
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDTimerComponent::IsOnPause() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDTimerComponent", "IsOnPause");

	Params::DBDTimerComponent_IsOnPause Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilTimer.GetPercentTimeElapsed
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDBDTimer&                 Timer                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDUtilTimer::GetPercentTimeElapsed(const struct FDBDTimer& Timer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilTimer", "GetPercentTimeElapsed");

	Params::DBDUtilTimer_GetPercentTimeElapsed Parms{};

	Parms.Timer = std::move(Timer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilTimer.GetPercentTimeLeft
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDBDTimer&                 Timer                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDUtilTimer::GetPercentTimeLeft(const struct FDBDTimer& Timer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilTimer", "GetPercentTimeLeft");

	Params::DBDUtilTimer_GetPercentTimeLeft Parms{};

	Parms.Timer = std::move(Timer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilTimer.GetStartTime
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDBDTimer&                 Timer                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDUtilTimer::GetStartTime(const struct FDBDTimer& Timer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilTimer", "GetStartTime");

	Params::DBDUtilTimer_GetStartTime Parms{};

	Parms.Timer = std::move(Timer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilTimer.GetTimeElapsed
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDBDTimer&                 Timer                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDUtilTimer::GetTimeElapsed(const struct FDBDTimer& Timer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilTimer", "GetTimeElapsed");

	Params::DBDUtilTimer_GetTimeElapsed Parms{};

	Parms.Timer = std::move(Timer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilTimer.GetTimeLeft
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDBDTimer&                 Timer                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDUtilTimer::GetTimeLeft(const struct FDBDTimer& Timer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilTimer", "GetTimeLeft");

	Params::DBDUtilTimer_GetTimeLeft Parms{};

	Parms.Timer = std::move(Timer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilTimer.IsDone
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDBDTimer&                 Timer                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilTimer::IsDone(const struct FDBDTimer& Timer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilTimer", "IsDone");

	Params::DBDUtilTimer_IsDone Parms{};

	Parms.Timer = std::move(Timer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilTimer.Reset
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDBDTimer&                       Timer                                                  (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDBDUtilTimer::Reset(struct FDBDTimer& Timer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilTimer", "Reset");

	Params::DBDUtilTimer_Reset Parms{};

	Parms.Timer = std::move(Timer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Timer = std::move(Parms.Timer);
}


// Function DeadByDaylight.DBDUtilTimer.ResetTo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDBDTimer&                       Timer                                                  (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDUtilTimer::ResetTo(struct FDBDTimer& Timer, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilTimer", "ResetTo");

	Params::DBDUtilTimer_ResetTo Parms{};

	Parms.Timer = std::move(Timer);
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Timer = std::move(Parms.Timer);
}


// Function DeadByDaylight.DBDUtilTimer.Stop
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDBDTimer&                       Timer                                                  (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDBDUtilTimer::Stop(struct FDBDTimer& Timer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilTimer", "Stop");

	Params::DBDUtilTimer_Stop Parms{};

	Parms.Timer = std::move(Timer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Timer = std::move(Parms.Timer);
}


// Function DeadByDaylight.DBDUtilTimer.Update
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDBDTimer&                       Timer                                                  (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDUtilTimer::Update(struct FDBDTimer& Timer, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilTimer", "Update");

	Params::DBDUtilTimer_Update Parms{};

	Parms.Timer = std::move(Timer);
	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Timer = std::move(Parms.Timer);
}


// Function DeadByDaylight.DestroyBreakableDefinition.GetBreakable
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ABreakableBase*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABreakableBase* UDestroyBreakableDefinition::GetBreakable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DestroyBreakableDefinition", "GetBreakable");

	Params::DestroyBreakableDefinition_GetBreakable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DirectionalMinigameComponent.Authority_StartMinigameForSurvivor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDirectionalMiniGameDefinition&miniGameDefinition                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDirectionalMinigameComponent::Authority_StartMinigameForSurvivor(class ASurvivor* Survivor, const struct FDirectionalMiniGameDefinition& miniGameDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DirectionalMinigameComponent", "Authority_StartMinigameForSurvivor");

	Params::DirectionalMinigameComponent_Authority_StartMinigameForSurvivor Parms{};

	Parms.Survivor = Survivor;
	Parms.miniGameDefinition = std::move(miniGameDefinition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DirectionalMinigameComponent.Local_EnterKey
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDirectionalInputKey                    enteredKey                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDirectionalMinigameComponent::Local_EnterKey(EDirectionalInputKey enteredKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DirectionalMinigameComponent", "Local_EnterKey");

	Params::DirectionalMinigameComponent_Local_EnterKey Parms{};

	Parms.enteredKey = enteredKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DirectionalMinigameComponent.OnRep_IsInProgress
// (Final, Native, Private)

void UDirectionalMinigameComponent::OnRep_IsInProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DirectionalMinigameComponent", "OnRep_IsInProgress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DirectionalMinigameComponent.Server_CancelMinigame
// (Net, NetReliable, Native, Event, Public, NetServer)

void UDirectionalMinigameComponent::Server_CancelMinigame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DirectionalMinigameComponent", "Server_CancelMinigame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DirectionalMinigameComponent.Server_EnterKey
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// EDirectionalInputKey                    enteredKey                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDirectionalMinigameComponent::Server_EnterKey(EDirectionalInputKey enteredKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DirectionalMinigameComponent", "Server_EnterKey");

	Params::DirectionalMinigameComponent_Server_EnterKey Parms{};

	Parms.enteredKey = enteredKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DirectionalMinigameSurvivorComponent.Client_StopInteraction
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class UDirectionalMinigameComponent*    directionalMinigame                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDirectionalMinigameResult              Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDirectionalMinigameSurvivorComponent::Client_StopInteraction(class UDirectionalMinigameComponent* directionalMinigame, EDirectionalMinigameResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DirectionalMinigameSurvivorComponent", "Client_StopInteraction");

	Params::DirectionalMinigameSurvivorComponent_Client_StopInteraction Parms{};

	Parms.directionalMinigame = directionalMinigame;
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DirectionalMinigameSurvivorComponent.Server_CancelMinigame
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class UDirectionalMinigameComponent*    directionalMinigame                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDirectionalMinigameSurvivorComponent::Server_CancelMinigame(class UDirectionalMinigameComponent* directionalMinigame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DirectionalMinigameSurvivorComponent", "Server_CancelMinigame");

	Params::DirectionalMinigameSurvivorComponent_Server_CancelMinigame Parms{};

	Parms.directionalMinigame = directionalMinigame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DirectionalMinigameSurvivorComponent.Server_EnterKey
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class UDirectionalMinigameComponent*    directionalMinigame                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDirectionalInputKey                    Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDirectionalMinigameSurvivorComponent::Server_EnterKey(class UDirectionalMinigameComponent* directionalMinigame, EDirectionalInputKey Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DirectionalMinigameSurvivorComponent", "Server_EnterKey");

	Params::DirectionalMinigameSurvivorComponent_Server_EnterKey Parms{};

	Parms.directionalMinigame = directionalMinigame;
	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DischargeUntilThresholdIsReachedComponent.Authority_OnChargePercentChanged
// (Final, Native, Private)
// Parameters:
// class UChargeableComponent*             ChargeableComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PercentCompletionChange                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TotalPercentComplete                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDischargeUntilThresholdIsReachedComponent::Authority_OnChargePercentChanged(class UChargeableComponent* ChargeableComponent, float PercentCompletionChange, float TotalPercentComplete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DischargeUntilThresholdIsReachedComponent", "Authority_OnChargePercentChanged");

	Params::DischargeUntilThresholdIsReachedComponent_Authority_OnChargePercentChanged Parms{};

	Parms.ChargeableComponent = ChargeableComponent;
	Parms.PercentCompletionChange = PercentCompletionChange;
	Parms.TotalPercentComplete = TotalPercentComplete;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DischargeUntilThresholdIsReachedComponent.OnChargePercentChanged
// (Final, Native, Private)
// Parameters:
// class UChargeableComponent*             ChargeableComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TotalPercentComplete                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDischargeUntilThresholdIsReachedComponent::OnChargePercentChanged(class UChargeableComponent* ChargeableComponent, float TotalPercentComplete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DischargeUntilThresholdIsReachedComponent", "OnChargePercentChanged");

	Params::DischargeUntilThresholdIsReachedComponent_OnChargePercentChanged Parms{};

	Parms.ChargeableComponent = ChargeableComponent;
	Parms.TotalPercentComplete = TotalPercentComplete;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DoctorPowerAnimStateComponent.SetCurrentAbilityPhase
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDoctorAbilityPhase                     abilityPhase                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDoctorPowerAnimStateComponent::SetCurrentAbilityPhase(EDoctorAbilityPhase abilityPhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DoctorPowerAnimStateComponent", "SetCurrentAbilityPhase");

	Params::DoctorPowerAnimStateComponent_SetCurrentAbilityPhase Parms{};

	Parms.abilityPhase = abilityPhase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DoctorPowerAnimStateComponent.SetCurrentAbilityType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDoctorAbilityType                      abilityType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDoctorPowerAnimStateComponent::SetCurrentAbilityType(EDoctorAbilityType abilityType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DoctorPowerAnimStateComponent", "SetCurrentAbilityType");

	Params::DoctorPowerAnimStateComponent_SetCurrentAbilityType Parms{};

	Parms.abilityType = abilityType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EffectsLocator.OnActorTick
// (Event, Public, BlueprintEvent)
// Parameters:
// class UMaterialInstanceDynamic*         actorMaterialInstanceDynamic                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectsLocator::OnActorTick(class UMaterialInstanceDynamic* actorMaterialInstanceDynamic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectsLocator", "OnActorTick");

	Params::EffectsLocator_OnActorTick Parms{};

	Parms.actorMaterialInstanceDynamic = actorMaterialInstanceDynamic;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.EffectsLocator.OnEnterCollisionArea
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectsLocator::OnEnterCollisionArea(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectsLocator", "OnEnterCollisionArea");

	Params::EffectsLocator_OnEnterCollisionArea Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EffectsLocator.OnFoundActor
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           foundActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectsLocator::OnFoundActor(class AActor* foundActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectsLocator", "OnFoundActor");

	Params::EffectsLocator_OnFoundActor Parms{};

	Parms.foundActor = foundActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.EffectsLocator.OnLeaveCollisionArea
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectsLocator::OnLeaveCollisionArea(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectsLocator", "OnLeaveCollisionArea");

	Params::EffectsLocator_OnLeaveCollisionArea Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EffectsLocator.OnLostActor
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           lostActor                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectsLocator::OnLostActor(class AActor* lostActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectsLocator", "OnLostActor");

	Params::EffectsLocator_OnLostActor Parms{};

	Parms.lostActor = lostActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.EndGameStateComponent.Multicast_SetIsInEndGameSimulation
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// bool                                    endGameSimulation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEndGameStateComponent::Multicast_SetIsInEndGameSimulation(bool endGameSimulation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameStateComponent", "Multicast_SetIsInEndGameSimulation");

	Params::EndGameStateComponent_Multicast_SetIsInEndGameSimulation Parms{};

	Parms.endGameSimulation = endGameSimulation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EndGameStateComponent.OnRep_IsEndGameOver
// (Final, Native, Private)

void UEndGameStateComponent::OnRep_IsEndGameOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameStateComponent", "OnRep_IsEndGameOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EndGameStateComponent.OnRep_IsTimerPaused
// (Final, Native, Private)

void UEndGameStateComponent::OnRep_IsTimerPaused()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameStateComponent", "OnRep_IsTimerPaused");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EndGameStateComponent.OnRep_TimeDilation
// (Final, Native, Private)

void UEndGameStateComponent::OnRep_TimeDilation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameStateComponent", "OnRep_TimeDilation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EndGameStateComponent.OnRep_WorldTimeAtLastDilationModification
// (Final, Native, Private)

void UEndGameStateComponent::OnRep_WorldTimeAtLastDilationModification()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameStateComponent", "OnRep_WorldTimeAtLastDilationModification");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EndGameStateComponent.GetElapsedTimePercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UEndGameStateComponent::GetElapsedTimePercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameStateComponent", "GetElapsedTimePercent");

	Params::EndGameStateComponent_GetElapsedTimePercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EndGameStateComponent.HasEndGameBegun
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEndGameStateComponent::HasEndGameBegun() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameStateComponent", "HasEndGameBegun");

	Params::EndGameStateComponent_HasEndGameBegun Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EndGameStateComponent.IsEndGameOver
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEndGameStateComponent::IsEndGameOver() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameStateComponent", "IsEndGameOver");

	Params::EndGameStateComponent_IsEndGameOver Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EndGameStateComponent.IsTimerSlowedDown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEndGameStateComponent::IsTimerSlowedDown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameStateComponent", "IsTimerSlowedDown");

	Params::EndGameStateComponent_IsTimerSlowedDown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Entity.ChangeToIdleState
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void AEntity::ChangeToIdleState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Entity", "ChangeToIdleState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Entity.ChangeToSacrificeState
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void AEntity::ChangeToSacrificeState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Entity", "ChangeToSacrificeState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Entity.ChangeToStruggleState
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void AEntity::ChangeToStruggleState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Entity", "ChangeToStruggleState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Entity.CompleteSacrifice
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    isBasementHook                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEntity::CompleteSacrifice(bool isBasementHook)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Entity", "CompleteSacrifice");

	Params::Entity_CompleteSacrifice Parms{};

	Parms.isBasementHook = isBasementHook;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Entity.HideEntity
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void AEntity::HideEntity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Entity", "HideEntity");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Entity.InitEntity
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AMeatHook*                        MeatHook                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEntity::InitEntity(class AMeatHook* MeatHook)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Entity", "InitEntity");

	Params::Entity_InitEntity Parms{};

	Parms.MeatHook = MeatHook;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Entity.OnReactionStart
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void AEntity::OnReactionStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Entity", "OnReactionStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Entity.SetAnimationIsStruggling
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    isStruggling                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEntity::SetAnimationIsStruggling(bool isStruggling)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Entity", "SetAnimationIsStruggling");

	Params::Entity_SetAnimationIsStruggling Parms{};

	Parms.isStruggling = isStruggling;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Entity.SetAnimationStrugglePercent
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Percent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEntity::SetAnimationStrugglePercent(float Percent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Entity", "SetAnimationStrugglePercent");

	Params::Entity_SetAnimationStrugglePercent Parms{};

	Parms.Percent = Percent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.EscapeBlocker.ActivatePlayerBlockerFX
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void AEscapeBlocker::ActivatePlayerBlockerFX()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeBlocker", "ActivatePlayerBlockerFX");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.EscapeBlocker.DeactivatePlayerBlockerFX
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void AEscapeBlocker::DeactivatePlayerBlockerFX()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeBlocker", "DeactivatePlayerBlockerFX");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.EscapeBlocker.OnPlayerDetectionZoneBeginOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AEscapeBlocker::OnPlayerDetectionZoneBeginOverlap(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeBlocker", "OnPlayerDetectionZoneBeginOverlap");

	Params::EscapeBlocker_OnPlayerDetectionZoneBeginOverlap Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EscapeBlocker.OnPlayerDetectionZoneEndOverlap
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEscapeBlocker::OnPlayerDetectionZoneEndOverlap(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeBlocker", "OnPlayerDetectionZoneEndOverlap");

	Params::EscapeBlocker_OnPlayerDetectionZoneEndOverlap Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EscapeBlocker.SetCamperBlocker
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UBoxComponent*                    camperBlocker                                          (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEscapeBlocker::SetCamperBlocker(class UBoxComponent* camperBlocker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeBlocker", "SetCamperBlocker");

	Params::EscapeBlocker_SetCamperBlocker Parms{};

	Parms.camperBlocker = camperBlocker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EscapeBlocker.SetPlayerDetectionZone
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UBoxComponent*                    playerDetectionZone                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEscapeBlocker::SetPlayerDetectionZone(class UBoxComponent* playerDetectionZone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeBlocker", "SetPlayerDetectionZone");

	Params::EscapeBlocker_SetPlayerDetectionZone Parms{};

	Parms.playerDetectionZone = playerDetectionZone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EscapeDoorAnimInstance.PlaySound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAkAudioEvent*                    akEvent                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEscapeDoorAnimInstance::PlaySound(class UAkAudioEvent* akEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoorAnimInstance", "PlaySound");

	Params::EscapeDoorAnimInstance_PlaySound Parms{};

	Parms.akEvent = akEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EscapeDoorAnimInstance.SetIsOpen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsOpen                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEscapeDoorAnimInstance::SetIsOpen(bool IsOpen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoorAnimInstance", "SetIsOpen");

	Params::EscapeDoorAnimInstance_SetIsOpen Parms{};

	Parms.IsOpen = IsOpen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EscapeDoorAnimInstance.SetIsOpenByKiller
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              isOpenByKiller                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEscapeDoorAnimInstance::SetIsOpenByKiller(const bool isOpenByKiller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoorAnimInstance", "SetIsOpenByKiller");

	Params::EscapeDoorAnimInstance_SetIsOpenByKiller Parms{};

	Parms.isOpenByKiller = isOpenByKiller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EventGeneratorComponent.Authority_FireGenCompletedEventScore
// (Final, Native, Private)
// Parameters:
// bool                                    isAutoCompleted                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventGeneratorComponent::Authority_FireGenCompletedEventScore(bool isAutoCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventGeneratorComponent", "Authority_FireGenCompletedEventScore");

	Params::EventGeneratorComponent_Authority_FireGenCompletedEventScore Parms{};

	Parms.isAutoCompleted = isAutoCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EventHookComponent.Authority_FireHookedScoreEvent
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       hookedPlayer                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventHookComponent::Authority_FireHookedScoreEvent(class ADBDPlayer* hookedPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventHookComponent", "Authority_FireHookedScoreEvent");

	Params::EventHookComponent_Authority_FireHookedScoreEvent Parms{};

	Parms.hookedPlayer = hookedPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EventHookComponent.SetOutlineCarryingColorToDefault
// (Final, Native, Public, BlueprintCallable)

void UEventHookComponent::SetOutlineCarryingColorToDefault()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventHookComponent", "SetOutlineCarryingColorToDefault");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EvilWithinComponent.Authority_NotifyKill
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UEvilWithinComponent::Authority_NotifyKill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvilWithinComponent", "Authority_NotifyKill");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EvilWithinComponent.Authority_OnPlayerDisconnect
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEvilWithinComponent::Authority_OnPlayerDisconnect(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvilWithinComponent", "Authority_OnPlayerDisconnect");

	Params::EvilWithinComponent_Authority_OnPlayerDisconnect Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EvilWithinComponent.Authority_OnStalkPointsAdded
// (Final, Native, Private)
// Parameters:
// float                                   stalkPoints                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEvilWithinComponent::Authority_OnStalkPointsAdded(float stalkPoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvilWithinComponent", "Authority_OnStalkPointsAdded");

	Params::EvilWithinComponent_Authority_OnStalkPointsAdded Parms{};

	Parms.stalkPoints = stalkPoints;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EvilWithinComponent.OnLevelReadyToPlay
// (Final, Native, Private)

void UEvilWithinComponent::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvilWithinComponent", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EvilWithinComponent.OnRep_CurrentTier
// (Final, Native, Private)
// Parameters:
// int32                                   previousTier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEvilWithinComponent::OnRep_CurrentTier(int32 previousTier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvilWithinComponent", "OnRep_CurrentTier");

	Params::EvilWithinComponent_OnRep_CurrentTier Parms{};

	Parms.previousTier = previousTier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EvilWithinComponent.CanBeStandingKilled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEvilWithinComponent::CanBeStandingKilled(const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvilWithinComponent", "CanBeStandingKilled");

	Params::EvilWithinComponent_CanBeStandingKilled Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EvilWithinComponent.CanStandKill
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEvilWithinComponent::CanStandKill(const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvilWithinComponent", "CanStandKill");

	Params::EvilWithinComponent_CanStandKill Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EvilWithinComponent.GetCurrentTier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UEvilWithinComponent::GetCurrentTier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvilWithinComponent", "GetCurrentTier");

	Params::EvilWithinComponent_GetCurrentTier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EvilWithinComponent.GetMaxTier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UEvilWithinComponent::GetMaxTier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvilWithinComponent", "GetMaxTier");

	Params::EvilWithinComponent_GetMaxTier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EvilWithinComponent.GetPercentStalkingPointsInCurrentTier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UEvilWithinComponent::GetPercentStalkingPointsInCurrentTier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvilWithinComponent", "GetPercentStalkingPointsInCurrentTier");

	Params::EvilWithinComponent_GetPercentStalkingPointsInCurrentTier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EvilWithinComponent.GetRequirementForTier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   tier                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UEvilWithinComponent::GetRequirementForTier(int32 tier) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvilWithinComponent", "GetRequirementForTier");

	Params::EvilWithinComponent_GetRequirementForTier Parms{};

	Parms.tier = tier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EvilWithinComponent.IsAtLastTier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEvilWithinComponent::IsAtLastTier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvilWithinComponent", "IsAtLastTier");

	Params::EvilWithinComponent_IsAtLastTier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ExperimentsHelper.GetAllActive
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    contextObject                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FCombinedExperimentData>* outData                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UExperimentsHelper::GetAllActive(const class UObject* contextObject, TArray<struct FCombinedExperimentData>* outData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ExperimentsHelper", "GetAllActive");

	Params::ExperimentsHelper_GetAllActive Parms{};

	Parms.contextObject = contextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outData != nullptr)
		*outData = std::move(Parms.outData);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ExperimentsHelper.GetCombinedData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    contextObject                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             experimentId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCombinedExperimentData*         outData                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UExperimentsHelper::GetCombinedData(const class UObject* contextObject, class FName experimentId, struct FCombinedExperimentData* outData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ExperimentsHelper", "GetCombinedData");

	Params::ExperimentsHelper_GetCombinedData Parms{};

	Parms.contextObject = contextObject;
	Parms.experimentId = experimentId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outData != nullptr)
		*outData = std::move(Parms.outData);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ExperimentsHelper.IsActive
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    contextObject                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             experimentId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UExperimentsHelper::IsActive(const class UObject* contextObject, class FName experimentId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ExperimentsHelper", "IsActive");

	Params::ExperimentsHelper_IsActive Parms{};

	Parms.contextObject = contextObject;
	Parms.experimentId = experimentId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ExposerCirclingComponent.Reset
// (Final, Native, Public, BlueprintCallable)

void UExposerCirclingComponent::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExposerCirclingComponent", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ExposerCirclingComponent.SetIsCircling
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    circling                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExposerCirclingComponent::SetIsCircling(bool circling)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExposerCirclingComponent", "SetIsCircling");

	Params::ExposerCirclingComponent_SetIsCircling Parms{};

	Parms.circling = circling;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Fadeable.OnAlphaChanged
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   newAlpha                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IFadeable::OnAlphaChanged(float newAlpha, class AActor* Other)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Fadeable", "OnAlphaChanged");

	Params::Fadeable_OnAlphaChanged Parms{};

	Parms.newAlpha = newAlpha;
	Parms.Other = Other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Fadeable.OnFadeBegin
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IFadeable::OnFadeBegin(class AActor* Other)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Fadeable", "OnFadeBegin");

	Params::Fadeable_OnFadeBegin Parms{};

	Parms.Other = Other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Fadeable.OnFadeEnd
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IFadeable::OnFadeEnd(class AActor* Other)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Fadeable", "OnFadeEnd");

	Params::Fadeable_OnFadeEnd Parms{};

	Parms.Other = Other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FadeManager.AreAnyMaterialsFaded
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFadeManager::AreAnyMaterialsFaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FadeManager", "AreAnyMaterialsFaded");

	Params::FadeManager_AreAnyMaterialsFaded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.FadeManager.DBD_ContinuousCameraFading
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    IsEnabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFadeManager::DBD_ContinuousCameraFading(bool IsEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FadeManager", "DBD_ContinuousCameraFading");

	Params::FadeManager_DBD_ContinuousCameraFading Parms{};

	Parms.IsEnabled = IsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FadeManager.DBD_FadeAtCurrentCameraLocation
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    IsEnabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFadeManager::DBD_FadeAtCurrentCameraLocation(bool IsEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FadeManager", "DBD_FadeAtCurrentCameraLocation");

	Params::FadeManager_DBD_FadeAtCurrentCameraLocation Parms{};

	Parms.IsEnabled = IsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FadeManager.DBD_ForceDestroySomeFadedMeshes
// (Final, Exec, Native, Public)
// Parameters:
// const int32                             numberOfMeshToDestroy                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFadeManager::DBD_ForceDestroySomeFadedMeshes(const int32 numberOfMeshToDestroy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FadeManager", "DBD_ForceDestroySomeFadedMeshes");

	Params::FadeManager_DBD_ForceDestroySomeFadedMeshes Parms{};

	Parms.numberOfMeshToDestroy = numberOfMeshToDestroy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FadeManager.DBD_TurnCameraAroundPlayerWithFading
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    isTurning                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFadeManager::DBD_TurnCameraAroundPlayerWithFading(bool isTurning)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FadeManager", "DBD_TurnCameraAroundPlayerWithFading");

	Params::FadeManager_DBD_TurnCameraAroundPlayerWithFading Parms{};

	Parms.isTurning = isTurning;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FadeManager.FadeAt
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    adjustAudioOcclusions                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFadeManager::FadeAt(const struct FVector& Location, bool adjustAudioOcclusions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FadeManager", "FadeAt");

	Params::FadeManager_FadeAt Parms{};

	Parms.Location = std::move(Location);
	Parms.adjustAudioOcclusions = adjustAudioOcclusions;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FadeManager.RemoveFadeMaterials
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    adjustAudioOcclusions                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFadeManager::RemoveFadeMaterials(bool adjustAudioOcclusions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FadeManager", "RemoveFadeMaterials");

	Params::FadeManager_RemoveFadeMaterials Parms{};

	Parms.adjustAudioOcclusions = adjustAudioOcclusions;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FinisherMoriHandlerComponent.OnHealthStateChanged
// (Final, Native, Private)
// Parameters:
// EHealthState                            oldHealthState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHealthState                            newHealthState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFinisherMoriHandlerComponent::OnHealthStateChanged(EHealthState oldHealthState, EHealthState newHealthState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FinisherMoriHandlerComponent", "OnHealthStateChanged");

	Params::FinisherMoriHandlerComponent_OnHealthStateChanged Parms{};

	Parms.oldHealthState = oldHealthState;
	Parms.newHealthState = newHealthState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FlickeringLight.GetActiveLightComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULocalLightComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULocalLightComponent* AFlickeringLight::GetActiveLightComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlickeringLight", "GetActiveLightComponent");

	Params::FlickeringLight_GetActiveLightComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.FlickeringLight.GetSecondaryLightComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULocalLightComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULocalLightComponent* AFlickeringLight::GetSecondaryLightComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlickeringLight", "GetSecondaryLightComponent");

	Params::FlickeringLight_GetSecondaryLightComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.FlickeringLight.GetSecondaryLightVisibilty
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFlickeringLight::GetSecondaryLightVisibilty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlickeringLight", "GetSecondaryLightVisibilty");

	Params::FlickeringLight_GetSecondaryLightVisibilty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.FlickeringLight.Init
// (Final, Native, Protected, BlueprintCallable)

void AFlickeringLight::Init()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlickeringLight", "Init");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FlickeringLight.StartFlickering
// (Final, Native, Protected, BlueprintCallable)

void AFlickeringLight::StartFlickering()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlickeringLight", "StartFlickering");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FlickeringLight.StopFlickering
// (Final, Native, Protected, BlueprintCallable)

void AFlickeringLight::StopFlickering()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlickeringLight", "StopFlickering");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FriendsListScreen.OnAcceptFriendInvite
// (Final, Native, Private)
// Parameters:
// const class FString&                    friendId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFriendsListScreen::OnAcceptFriendInvite(const class FString& friendId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendsListScreen", "OnAcceptFriendInvite");

	Params::FriendsListScreen_OnAcceptFriendInvite Parms{};

	Parms.friendId = std::move(friendId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FriendsListScreen.OnBlockPlayer
// (Final, Native, Private)
// Parameters:
// const class FString&                    PlayerId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFriendsListScreen::OnBlockPlayer(const class FString& PlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendsListScreen", "OnBlockPlayer");

	Params::FriendsListScreen_OnBlockPlayer Parms{};

	Parms.PlayerId = std::move(PlayerId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FriendsListScreen.OnCancelFriendInvite
// (Final, Native, Private)
// Parameters:
// const class FString&                    friendId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFriendsListScreen::OnCancelFriendInvite(const class FString& friendId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendsListScreen", "OnCancelFriendInvite");

	Params::FriendsListScreen_OnCancelFriendInvite Parms{};

	Parms.friendId = std::move(friendId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FriendsListScreen.OnDeclineFriendInvite
// (Final, Native, Private)
// Parameters:
// const class FString&                    friendId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFriendsListScreen::OnDeclineFriendInvite(const class FString& friendId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendsListScreen", "OnDeclineFriendInvite");

	Params::FriendsListScreen_OnDeclineFriendInvite Parms{};

	Parms.friendId = std::move(friendId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FriendsListScreen.OnHideNameSelected
// (Final, Native, Private)
// Parameters:
// const class FString&                    PlayerId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFriendsListScreen::OnHideNameSelected(const class FString& PlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendsListScreen", "OnHideNameSelected");

	Params::FriendsListScreen_OnHideNameSelected Parms{};

	Parms.PlayerId = std::move(PlayerId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FriendsListScreen.OnPartyJoinRequest
// (Final, Native, Private)
// Parameters:
// const class FString&                    friendId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFriendsListScreen::OnPartyJoinRequest(const class FString& friendId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendsListScreen", "OnPartyJoinRequest");

	Params::FriendsListScreen_OnPartyJoinRequest Parms{};

	Parms.friendId = std::move(friendId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FriendsListScreen.OnRemoveFriend
// (Final, Native, Private)
// Parameters:
// const class FString&                    friendId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFriendsListScreen::OnRemoveFriend(const class FString& friendId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendsListScreen", "OnRemoveFriend");

	Params::FriendsListScreen_OnRemoveFriend Parms{};

	Parms.friendId = std::move(friendId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FriendsListScreen.OnSearchForFriend
// (Final, Native, Private)

void UFriendsListScreen::OnSearchForFriend()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendsListScreen", "OnSearchForFriend");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FriendsListScreen.OnSendPartyInvite
// (Final, Native, Private)
// Parameters:
// const class FString&                    friendId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFriendsListScreen::OnSendPartyInvite(const class FString& friendId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendsListScreen", "OnSendPartyInvite");

	Params::FriendsListScreen_OnSendPartyInvite Parms{};

	Parms.friendId = std::move(friendId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FriendsListScreen.OnShowNameSelected
// (Final, Native, Private)
// Parameters:
// const class FString&                    PlayerId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFriendsListScreen::OnShowNameSelected(const class FString& PlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendsListScreen", "OnShowNameSelected");

	Params::FriendsListScreen_OnShowNameSelected Parms{};

	Parms.PlayerId = std::move(PlayerId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FriendsListScreen.OnUnblockPlayer
// (Final, Native, Private)
// Parameters:
// const class FString&                    PlayerId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFriendsListScreen::OnUnblockPlayer(const class FString& PlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendsListScreen", "OnUnblockPlayer");

	Params::FriendsListScreen_OnUnblockPlayer Parms{};

	Parms.PlayerId = std::move(PlayerId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FriendsListScreen.OnViewProfile
// (Final, Native, Private)
// Parameters:
// const class FString&                    friendId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFriendsListScreen::OnViewProfile(const class FString& friendId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendsListScreen", "OnViewProfile");

	Params::FriendsListScreen_OnViewProfile Parms{};

	Parms.friendId = std::move(friendId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameEventDispatcher.Authority_AccumulateOngoingGameEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   OngoingWaitTime                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameEventDispatcher::Authority_AccumulateOngoingGameEvent(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData, float OngoingWaitTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameEventDispatcher", "Authority_AccumulateOngoingGameEvent");

	Params::GameEventDispatcher_Authority_AccumulateOngoingGameEvent Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.GameEventData = std::move(GameEventData);
	Parms.OngoingWaitTime = OngoingWaitTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameEventDispatcher.Authority_RemotelyDispatch
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UGameEventDispatcher::Authority_RemotelyDispatch(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameEventDispatcher", "Authority_RemotelyDispatch");

	Params::GameEventDispatcher_Authority_RemotelyDispatch Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameEventDispatcher.LocallyDispatch
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UGameEventDispatcher::LocallyDispatch(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameEventDispatcher", "LocallyDispatch");

	Params::GameEventDispatcher_LocallyDispatch Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameEventDispatcher.RegisterListener
// (Final, Native, Private, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameEventDispatcherHandleBP&GameEventDispatcherHandle                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UGameEventDispatcher::RegisterListener(const struct FGameEventDispatcherHandleBP& GameEventDispatcherHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameEventDispatcher", "RegisterListener");

	Params::GameEventDispatcher_RegisterListener Parms{};

	Parms.GameEventDispatcherHandle = std::move(GameEventDispatcherHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameEventDispatcher.RemotelyDispatch
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UGameEventDispatcher::RemotelyDispatch(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameEventDispatcher", "RemotelyDispatch");

	Params::GameEventDispatcher_RemotelyDispatch Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameEventDispatcher.UnregisterListener
// (Final, Native, Private, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameEventDispatcherHandleBP&GameEventDispatcherHandle                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UGameEventDispatcher::UnregisterListener(const struct FGameEventDispatcherHandleBP& GameEventDispatcherHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameEventDispatcher", "UnregisterListener");

	Params::GameEventDispatcher_UnregisterListener Parms{};

	Parms.GameEventDispatcherHandle = std::move(GameEventDispatcherHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameEventListenerCollectionComponent.ListenToGameEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              EventType                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData)>delegateToBind                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameEventListenerCollectionComponent::ListenToGameEvent(const struct FGameplayTag& EventType, TDelegate<void(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData)> delegateToBind)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameEventListenerCollectionComponent", "ListenToGameEvent");

	Params::GameEventListenerCollectionComponent_ListenToGameEvent Parms{};

	Parms.EventType = std::move(EventType);
	Parms.delegateToBind = delegateToBind;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameEventListenerCollectionComponent.UnlistenToAllGameEvents
// (Final, Native, Public, BlueprintCallable)

void UGameEventListenerCollectionComponent::UnlistenToAllGameEvents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameEventListenerCollectionComponent", "UnlistenToAllGameEvents");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameEventListenerCollectionComponent.UnlistenToGameEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              EventType                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameEventListenerCollectionComponent::UnlistenToGameEvent(const struct FGameplayTag& EventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameEventListenerCollectionComponent", "UnlistenToGameEvent");

	Params::GameEventListenerCollectionComponent_UnlistenToGameEvent Parms{};

	Parms.EventType = std::move(EventType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameEventTracker.FireGameEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDBDScoreTypes                          EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameEventTracker::FireGameEvent(EDBDScoreTypes EventType, float Amount, class AActor* Instigator, class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameEventTracker", "FireGameEvent");

	Params::GameEventTracker_FireGameEvent Parms{};

	Parms.EventType = EventType;
	Parms.Amount = Amount;
	Parms.Instigator = Instigator;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameEventTracker.FireGameflowEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDBDScoreTypes                          EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ADBDPlayerState*            Instigator                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Data                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameEventTracker::FireGameflowEvent(EDBDScoreTypes EventType, float Amount, const class ADBDPlayerState* Instigator, class FName Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameEventTracker", "FireGameflowEvent");

	Params::GameEventTracker_FireGameflowEvent Parms{};

	Parms.EventType = EventType;
	Parms.Amount = Amount;
	Parms.Instigator = Instigator;
	Parms.Data = Data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameObjectivesComponent.OnRep_GameObjectives
// (Final, Native, Public, HasOutParams)
// Parameters:
// const TArray<class AGameObjectiveBase*>&oldArray                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UGameObjectivesComponent::OnRep_GameObjectives(const TArray<class AGameObjectiveBase*>& oldArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameObjectivesComponent", "OnRep_GameObjectives");

	Params::GameObjectivesComponent_OnRep_GameObjectives Parms{};

	Parms.oldArray = std::move(oldArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameObjectivesUtilities.AreAllGameObjectivesCompleted
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameObjectivesUtilities::AreAllGameObjectivesCompleted(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameObjectivesUtilities", "AreAllGameObjectivesCompleted");

	Params::GameObjectivesUtilities_AreAllGameObjectivesCompleted Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameObjectivesUtilities.GetRemainingGeneratorsNeeded
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameObjectivesUtilities::GetRemainingGeneratorsNeeded(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameObjectivesUtilities", "GetRemainingGeneratorsNeeded");

	Params::GameObjectivesUtilities_GetRemainingGeneratorsNeeded Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameObjectivesUtilities.GetRequiredActivatedGeneratorCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameObjectivesUtilities::GetRequiredActivatedGeneratorCount(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameObjectivesUtilities", "GetRequiredActivatedGeneratorCount");

	Params::GameObjectivesUtilities_GetRequiredActivatedGeneratorCount Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameObjective_ActivatedGenerators.Authority_OnGeneratorActivated
// (Native, Protected)
// Parameters:
// bool                                    isAutoCompleted                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           generatorActor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameObjective_ActivatedGenerators::Authority_OnGeneratorActivated(bool isAutoCompleted, class AActor* generatorActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameObjective_ActivatedGenerators", "Authority_OnGeneratorActivated");

	Params::GameObjective_ActivatedGenerators_Authority_OnGeneratorActivated Parms{};

	Parms.isAutoCompleted = isAutoCompleted;
	Parms.generatorActor = generatorActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameObjective_ActivatedGenerators.OnRep_ActivatedCount
// (Final, Native, Protected)
// Parameters:
// int32                                   oldCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameObjective_ActivatedGenerators::OnRep_ActivatedCount(int32 oldCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameObjective_ActivatedGenerators", "OnRep_ActivatedCount");

	Params::GameObjective_ActivatedGenerators_OnRep_ActivatedCount Parms{};

	Parms.oldCount = oldCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameObjective_ActivatedGenerators.OnRep_RequiredCount
// (Final, Native, Protected)
// Parameters:
// int32                                   oldCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameObjective_ActivatedGenerators::OnRep_RequiredCount(int32 oldCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameObjective_ActivatedGenerators", "OnRep_RequiredCount");

	Params::GameObjective_ActivatedGenerators_OnRep_RequiredCount Parms{};

	Parms.oldCount = oldCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorOutlineUpdateStrategy.GetEffectsProtectingFromKillerAuraReading
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class ASurvivor*                  Subject                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AKiller*                    Killer                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UGameplayModifierContainer*>ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UGameplayModifierContainer*> USurvivorOutlineUpdateStrategy::GetEffectsProtectingFromKillerAuraReading(const class ASurvivor* Subject, const class AKiller* Killer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SurvivorOutlineUpdateStrategy", "GetEffectsProtectingFromKillerAuraReading");

	Params::SurvivorOutlineUpdateStrategy_GetEffectsProtectingFromKillerAuraReading Parms{};

	Parms.Subject = Subject;
	Parms.Killer = Killer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SurvivorOutlineUpdateStrategy.IsActivelyHidingAuraFromKiller
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class ASurvivor*                  Subject                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AKiller*                    witness                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USurvivorOutlineUpdateStrategy::IsActivelyHidingAuraFromKiller(const class ASurvivor* Subject, const class AKiller* witness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SurvivorOutlineUpdateStrategy", "IsActivelyHidingAuraFromKiller");

	Params::SurvivorOutlineUpdateStrategy_IsActivelyHidingAuraFromKiller Parms{};

	Parms.Subject = Subject;
	Parms.witness = witness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SurvivorOutlineUpdateStrategy.SetTrappedIconActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorOutlineUpdateStrategy::SetTrappedIconActive(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorOutlineUpdateStrategy", "SetTrappedIconActive");

	Params::SurvivorOutlineUpdateStrategy_SetTrappedIconActive Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorOutlineUpdateStrategy.IsBlockingAuraReadingFromKiller
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AKiller*                    Killer                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USurvivorOutlineUpdateStrategy::IsBlockingAuraReadingFromKiller(const class AKiller* Killer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorOutlineUpdateStrategy", "IsBlockingAuraReadingFromKiller");

	Params::SurvivorOutlineUpdateStrategy_IsBlockingAuraReadingFromKiller Parms{};

	Parms.Killer = Killer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameStateWatchdog.OnWorldLoaded
// (Final, Native, Private)
// Parameters:
// class UWorld*                           newWorld                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameStateWatchdog::OnWorldLoaded(class UWorld* newWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateWatchdog", "OnWorldLoaded");

	Params::GameStateWatchdog_OnWorldLoaded Parms{};

	Parms.newWorld = newWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GateFactory.GetGate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EGateType                               GateType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGate*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGate* AGateFactory::GetGate(EGateType GateType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GateFactory", "GetGate");

	Params::GateFactory_GetGate Parms{};

	Parms.GateType = GateType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CoopRepairTracker.SetHasEverCoopRepaired
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoopRepairTracker::SetHasEverCoopRepaired(const class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoopRepairTracker", "SetHasEverCoopRepaired");

	Params::CoopRepairTracker_SetHasEverCoopRepaired Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CoopRepairTracker.HasEverCoopRepaired
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoopRepairTracker::HasEverCoopRepaired(const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoopRepairTracker", "HasEverCoopRepaired");

	Params::CoopRepairTracker_HasEverCoopRepaired Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GeneratorDamageComponent.Multicast_DamageEffects
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const float                             immediateRegressionPercent                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class ADBDPlayer*>&        repairers                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const bool                              playLoudNoise                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorDamageComponent::Multicast_DamageEffects(const float immediateRegressionPercent, const TArray<class ADBDPlayer*>& repairers, const bool playLoudNoise)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDamageComponent", "Multicast_DamageEffects");

	Params::GeneratorDamageComponent_Multicast_DamageEffects Parms{};

	Parms.immediateRegressionPercent = immediateRegressionPercent;
	Parms.repairers = std::move(repairers);
	Parms.playLoudNoise = playLoudNoise;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorDamageComponent.OnRep_DamageData
// (Final, Native, Private)

void UGeneratorDamageComponent::OnRep_DamageData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDamageComponent", "OnRep_DamageData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorDamageComponent.IsIntenseDamage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGeneratorDamageComponent::IsIntenseDamage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDamageComponent", "IsIntenseDamage");

	Params::GeneratorDamageComponent_IsIntenseDamage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GeneratorDamageComponent.IsRegressing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGeneratorDamageComponent::IsRegressing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDamageComponent", "IsRegressing");

	Params::GeneratorDamageComponent_IsRegressing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GeneratorEntity.PlayMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FAnimationMontageDescriptor&animMontageID                                          (Parm, NativeAccessSpecifierPublic)
// float                                   PlayRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isFollower                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorEntity::PlayMontage(const struct FAnimationMontageDescriptor& animMontageID, float PlayRate, bool isFollower)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorEntity", "PlayMontage");

	Params::GeneratorEntity_PlayMontage Parms{};

	Parms.animMontageID = std::move(animMontageID);
	Parms.PlayRate = PlayRate;
	Parms.isFollower = isFollower;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorEntity.SetAssociatedGenerator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Generator                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorEntity::SetAssociatedGenerator(class UObject* Generator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorEntity", "SetAssociatedGenerator");

	Params::GeneratorEntity_SetAssociatedGenerator Parms{};

	Parms.Generator = Generator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorEntity.SetSkeletalMeshActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Active                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorEntity::SetSkeletalMeshActive(bool Active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorEntity", "SetSkeletalMeshActive");

	Params::GeneratorEntity_SetSkeletalMeshActive Parms{};

	Parms.Active = Active;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorEntity.GetMontagePlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMontagePlayer*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMontagePlayer* AGeneratorEntity::GetMontagePlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorEntity", "GetMontagePlayer");

	Params::GeneratorEntity_GetMontagePlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GeneratorOutlineUpdateStrategy.GetWhiteColor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UGeneratorOutlineUpdateStrategy::GetWhiteColor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorOutlineUpdateStrategy", "GetWhiteColor");

	Params::GeneratorOutlineUpdateStrategy_GetWhiteColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GeneratorOutlineUpdateStrategy.GetYellowColor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UGeneratorOutlineUpdateStrategy::GetYellowColor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorOutlineUpdateStrategy", "GetYellowColor");

	Params::GeneratorOutlineUpdateStrategy_GetYellowColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Hatch.Authority_CheckedChangeActiveState
// (Final, Native, Private)

void AHatch::Authority_CheckedChangeActiveState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "Authority_CheckedChangeActiveState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Hatch.Authority_CheckedCloseHatch
// (Final, Native, Private)

void AHatch::Authority_CheckedCloseHatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "Authority_CheckedCloseHatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Hatch.Authority_CheckedOpenForceClosedHatch
// (Final, Native, Private)

void AHatch::Authority_CheckedOpenForceClosedHatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "Authority_CheckedOpenForceClosedHatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Hatch.Authority_CheckedOpenHatch
// (Final, Native, Private)

void AHatch::Authority_CheckedOpenHatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "Authority_CheckedOpenHatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Hatch.Authority_OnCloseTimerComplete
// (Final, Native, Private)

void AHatch::Authority_OnCloseTimerComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "Authority_OnCloseTimerComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Hatch.Authority_OnEndGameOver
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AHatch::Authority_OnEndGameOver(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "Authority_OnEndGameOver");

	Params::Hatch_Authority_OnEndGameOver Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Hatch.Authority_OnHatchVisibilityChanged
// (Final, Native, Private)
// Parameters:
// bool                                    IsVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHatch::Authority_OnHatchVisibilityChanged(bool IsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "Authority_OnHatchVisibilityChanged");

	Params::Hatch_Authority_OnHatchVisibilityChanged Parms{};

	Parms.IsVisible = IsVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Hatch.Authority_ResetTimer
// (Final, BlueprintAuthorityOnly, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHatch::Authority_ResetTimer(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "Authority_ResetTimer");

	Params::Hatch_Authority_ResetTimer Parms{};

	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Hatch.Authority_SetHatchState
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// EHatchState                             newState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHatch::Authority_SetHatchState(EHatchState newState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "Authority_SetHatchState");

	Params::Hatch_Authority_SetHatchState Parms{};

	Parms.newState = newState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Hatch.Authority_SetIsForceOpen
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isForcedOpen                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHatch::Authority_SetIsForceOpen(bool isForcedOpen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "Authority_SetIsForceOpen");

	Params::Hatch_Authority_SetIsForceOpen Parms{};

	Parms.isForcedOpen = isForcedOpen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Hatch.FXCloseHatch
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AHatch::FXCloseHatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "FXCloseHatch");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Hatch.FXEndSmoke
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AHatch::FXEndSmoke()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "FXEndSmoke");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Hatch.FXOpenHatch
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AHatch::FXOpenHatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "FXOpenHatch");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Hatch.OnHatchStateModified
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// EHatchState                             oldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHatchState                             newState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHatch::OnHatchStateModified(EHatchState oldState, EHatchState newState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "OnHatchStateModified");

	Params::Hatch_OnHatchStateModified Parms{};

	Parms.oldState = oldState;
	Parms.newState = newState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Hatch.OnHatchStateUnhidden
// (Final, Native, Private)

void AHatch::OnHatchStateUnhidden()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "OnHatchStateUnhidden");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Hatch.OnRep_HatchState
// (Final, Native, Private)
// Parameters:
// EHatchState                             oldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHatch::OnRep_HatchState(EHatchState oldState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "OnRep_HatchState");

	Params::Hatch_OnRep_HatchState Parms{};

	Parms.oldState = oldState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Hatch.GetAnimationMontageSlave
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UAnimationMontageSlave*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimationMontageSlave* AHatch::GetAnimationMontageSlave() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "GetAnimationMontageSlave");

	Params::Hatch_GetAnimationMontageSlave Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Hatch.GetEscapeFocalPoint
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* AHatch::GetEscapeFocalPoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "GetEscapeFocalPoint");

	Params::Hatch_GetEscapeFocalPoint Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Hatch.GetHatchCenter
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* AHatch::GetHatchCenter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "GetHatchCenter");

	Params::Hatch_GetHatchCenter Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Hatch.GetHatchState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EHatchState                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EHatchState AHatch::GetHatchState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "GetHatchState");

	Params::Hatch_GetHatchState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Hatch.IsOpen
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHatch::IsOpen() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "IsOpen");

	Params::Hatch_IsOpen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.HealthComponent.Authority_ApplyDamage
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           damageSource                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacter*                       damagePlayerOwner                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bypassInjuredBleedout                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::Authority_ApplyDamage(class AActor* damageSource, class ACharacter* damagePlayerOwner, bool bypassInjuredBleedout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "Authority_ApplyDamage");

	Params::HealthComponent_Authority_ApplyDamage Parms{};

	Parms.damageSource = damageSource;
	Parms.damagePlayerOwner = damagePlayerOwner;
	Parms.bypassInjuredBleedout = bypassInjuredBleedout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HealthComponent.Authority_ApplyDeepWound
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           damageSource                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacter*                       damagePlayerOwner                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::Authority_ApplyDeepWound(class AActor* damageSource, class ACharacter* damagePlayerOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "Authority_ApplyDeepWound");

	Params::HealthComponent_Authority_ApplyDeepWound Parms{};

	Parms.damageSource = damageSource;
	Parms.damagePlayerOwner = damagePlayerOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HealthComponent.Authority_ApplyDoubleDamage
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           damageSource                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacter*                       damagePlayerOwner                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::Authority_ApplyDoubleDamage(class AActor* damageSource, class ACharacter* damagePlayerOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "Authority_ApplyDoubleDamage");

	Params::HealthComponent_Authority_ApplyDoubleDamage Parms{};

	Parms.damageSource = damageSource;
	Parms.damagePlayerOwner = damagePlayerOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HealthComponent.Authority_EndInjuredBleedout
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UHealthComponent::Authority_EndInjuredBleedout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "Authority_EndInjuredBleedout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HealthComponent.Authority_HealTryGrantScoresOnChargeApplied
// (Final, Native, Protected)
// Parameters:
// float                                   IndividualChargeAmount                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TotalChargeAmount                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ChargeInstigator                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    WasCoop                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::Authority_HealTryGrantScoresOnChargeApplied(float IndividualChargeAmount, float TotalChargeAmount, class AActor* ChargeInstigator, bool WasCoop, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "Authority_HealTryGrantScoresOnChargeApplied");

	Params::HealthComponent_Authority_HealTryGrantScoresOnChargeApplied Parms{};

	Parms.IndividualChargeAmount = IndividualChargeAmount;
	Parms.TotalChargeAmount = TotalChargeAmount;
	Parms.ChargeInstigator = ChargeInstigator;
	Parms.WasCoop = WasCoop;
	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HealthComponent.Authority_MendTryGrantScoresOnChargeApplied
// (Final, Native, Protected)
// Parameters:
// float                                   IndividualChargeAmount                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TotalChargeAmount                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ChargeInstigator                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    WasCoop                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::Authority_MendTryGrantScoresOnChargeApplied(float IndividualChargeAmount, float TotalChargeAmount, class AActor* ChargeInstigator, bool WasCoop, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "Authority_MendTryGrantScoresOnChargeApplied");

	Params::HealthComponent_Authority_MendTryGrantScoresOnChargeApplied Parms{};

	Parms.IndividualChargeAmount = IndividualChargeAmount;
	Parms.TotalChargeAmount = TotalChargeAmount;
	Parms.ChargeInstigator = ChargeInstigator;
	Parms.WasCoop = WasCoop;
	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HealthComponent.Authority_OnHealChargeChange
// (Final, Native, Private)
// Parameters:
// class UChargeableComponent*             ChargeableComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PercentCompletionChange                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TotalPercentComplete                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::Authority_OnHealChargeChange(class UChargeableComponent* ChargeableComponent, float PercentCompletionChange, float TotalPercentComplete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "Authority_OnHealChargeChange");

	Params::HealthComponent_Authority_OnHealChargeChange Parms{};

	Parms.ChargeableComponent = ChargeableComponent;
	Parms.PercentCompletionChange = PercentCompletionChange;
	Parms.TotalPercentComplete = TotalPercentComplete;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HealthComponent.Authority_OnHealthBarCharged
// (Final, Native, Public, HasOutParams)
// Parameters:
// bool                                    complete                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            instigators                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UHealthComponent::Authority_OnHealthBarCharged(bool complete, const TArray<class AActor*>& instigators)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "Authority_OnHealthBarCharged");

	Params::HealthComponent_Authority_OnHealthBarCharged Parms{};

	Parms.complete = complete;
	Parms.instigators = std::move(instigators);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HealthComponent.Authority_OnMendChargeCompletionStateChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// bool                                    complete                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            instigators                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UHealthComponent::Authority_OnMendChargeCompletionStateChanged(bool complete, const TArray<class AActor*>& instigators)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "Authority_OnMendChargeCompletionStateChanged");

	Params::HealthComponent_Authority_OnMendChargeCompletionStateChanged Parms{};

	Parms.complete = complete;
	Parms.instigators = std::move(instigators);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HealthComponent.Authority_OnSurvivorRemoved
// (Final, Native, Private)
// Parameters:
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::Authority_OnSurvivorRemoved(class ASurvivor* Survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "Authority_OnSurvivorRemoved");

	Params::HealthComponent_Authority_OnSurvivorRemoved Parms{};

	Parms.Survivor = Survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HealthComponent.Authority_SetDamageState
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// EHealthState                            damageState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    FireScoreEvent                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    sacrificed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::Authority_SetDamageState(EHealthState damageState, bool FireScoreEvent, bool sacrificed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "Authority_SetDamageState");

	Params::HealthComponent_Authority_SetDamageState Parms{};

	Parms.damageState = damageState;
	Parms.FireScoreEvent = FireScoreEvent;
	Parms.sacrificed = sacrificed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HealthComponent.GetCurrentHPSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UChargeableComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChargeableComponent* UHealthComponent::GetCurrentHPSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetCurrentHPSlot");

	Params::HealthComponent_GetCurrentHPSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.HealthComponent.Multicast_OnHealed
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// const struct FHealResult&               HealResult                                             (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UHealthComponent::Multicast_OnHealed(const struct FHealResult& HealResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "Multicast_OnHealed");

	Params::HealthComponent_Multicast_OnHealed Parms{};

	Parms.HealResult = std::move(HealResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HealthComponent.Multicast_OnInjuredBleedoutKO
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ADBDPlayer*                       injuredBleedoutInstigator                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::Multicast_OnInjuredBleedoutKO(class ADBDPlayer* injuredBleedoutInstigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "Multicast_OnInjuredBleedoutKO");

	Params::HealthComponent_Multicast_OnInjuredBleedoutKO Parms{};

	Parms.injuredBleedoutInstigator = injuredBleedoutInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HealthComponent.Multicast_OnSurvivorGainedHealthStateByOthersEvents
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const bool                              healedFromKO                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       healedSurvivor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class ADBDPlayer*>&        Healers                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<bool>&                     healedSurvivorFarEnoughAway                            (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UHealthComponent::Multicast_OnSurvivorGainedHealthStateByOthersEvents(const bool healedFromKO, class ADBDPlayer* healedSurvivor, const TArray<class ADBDPlayer*>& Healers, const TArray<bool>& healedSurvivorFarEnoughAway)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "Multicast_OnSurvivorGainedHealthStateByOthersEvents");

	Params::HealthComponent_Multicast_OnSurvivorGainedHealthStateByOthersEvents Parms{};

	Parms.healedFromKO = healedFromKO;
	Parms.healedSurvivor = healedSurvivor;
	Parms.Healers = std::move(Healers);
	Parms.healedSurvivorFarEnoughAway = std::move(healedSurvivorFarEnoughAway);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HealthComponent.Multicast_SetCurrentHealthStateCount
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// int32                                   newHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    FireScoreEvent                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::Multicast_SetCurrentHealthStateCount(int32 newHealth, bool FireScoreEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "Multicast_SetCurrentHealthStateCount");

	Params::HealthComponent_Multicast_SetCurrentHealthStateCount Parms{};

	Parms.newHealth = newHealth;
	Parms.FireScoreEvent = FireScoreEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HealthComponent.Multicast_SetHealthState
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// EHealthState                            healthState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    FireScoreEvent                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    sacrificed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::Multicast_SetHealthState(EHealthState healthState, bool FireScoreEvent, bool sacrificed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "Multicast_SetHealthState");

	Params::HealthComponent_Multicast_SetHealthState Parms{};

	Parms.healthState = healthState;
	Parms.FireScoreEvent = FireScoreEvent;
	Parms.sacrificed = sacrificed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HealthComponent.Multicast_SetHealthStateCountFromHealthState
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// EHealthState                            healthState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    FireScoreEvent                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::Multicast_SetHealthStateCountFromHealthState(EHealthState healthState, bool FireScoreEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "Multicast_SetHealthStateCountFromHealthState");

	Params::HealthComponent_Multicast_SetHealthStateCountFromHealthState Parms{};

	Parms.healthState = healthState;
	Parms.FireScoreEvent = FireScoreEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HealthComponent.Multicast_SetHealthType
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// EHealthType                             healthType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::Multicast_SetHealthType(EHealthType healthType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "Multicast_SetHealthType");

	Params::HealthComponent_Multicast_SetHealthType Parms{};

	Parms.healthType = healthType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HealthComponent.Multicast_StartInjuredBleedout
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ADBDPlayer*                       Killer                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayModifierContainer*       container                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::Multicast_StartInjuredBleedout(class ADBDPlayer* Killer, class UGameplayModifierContainer* container)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "Multicast_StartInjuredBleedout");

	Params::HealthComponent_Multicast_StartInjuredBleedout Parms{};

	Parms.Killer = Killer;
	Parms.container = container;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HealthComponent.Multicast_SurvivorDowned
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ADBDPlayer*                       Killer                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::Multicast_SurvivorDowned(class ADBDPlayer* Killer, class ASurvivor* Survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "Multicast_SurvivorDowned");

	Params::HealthComponent_Multicast_SurvivorDowned Parms{};

	Parms.Killer = Killer;
	Parms.Survivor = Survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HealthComponent.OnImmobilizedStateChanged
// (Final, Native, Private)
// Parameters:
// const EImmobilizedState                 oldImmobilizeState                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EImmobilizedState                 newImmobilizeState                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::OnImmobilizedStateChanged(const EImmobilizedState oldImmobilizeState, const EImmobilizedState newImmobilizeState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "OnImmobilizedStateChanged");

	Params::HealthComponent_OnImmobilizedStateChanged Parms{};

	Parms.oldImmobilizeState = oldImmobilizeState;
	Parms.newImmobilizeState = newImmobilizeState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HealthComponent.OnRep_InInjuredBleedOut
// (Final, Native, Private)

void UHealthComponent::OnRep_InInjuredBleedOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "OnRep_InInjuredBleedOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HealthComponent.OnRep_IsInjuredBleedOutPaused
// (Final, Native, Private)

void UHealthComponent::OnRep_IsInjuredBleedOutPaused()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "OnRep_IsInjuredBleedOutPaused");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HealthComponent.SetCanBleedout
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    canBleedout                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::SetCanBleedout(bool canBleedout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "SetCanBleedout");

	Params::HealthComponent_SetCanBleedout Parms{};

	Parms.canBleedout = canBleedout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HealthComponent.CanBecomeHealthy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHealthComponent::CanBecomeHealthy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "CanBecomeHealthy");

	Params::HealthComponent_CanBecomeHealthy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.HealthComponent.CanBeHealed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHealthComponent::CanBeHealed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "CanBeHealed");

	Params::HealthComponent_CanBeHealed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.HealthComponent.CanBeHealedFromInjured
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHealthComponent::CanBeHealedFromInjured() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "CanBeHealedFromInjured");

	Params::HealthComponent_CanBeHealedFromInjured Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.HealthComponent.CanHealSelf
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHealthComponent::CanHealSelf() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "CanHealSelf");

	Params::HealthComponent_CanHealSelf Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.HealthComponent.GetCurrentTotalHealthBarPercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::GetCurrentTotalHealthBarPercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetCurrentTotalHealthBarPercent");

	Params::HealthComponent_GetCurrentTotalHealthBarPercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.HealthComponent.GetDamageState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EHealthState                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EHealthState UHealthComponent::GetDamageState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetDamageState");

	Params::HealthComponent_GetDamageState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.HealthComponent.GetPercentDyingTimer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::GetPercentDyingTimer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetPercentDyingTimer");

	Params::HealthComponent_GetPercentDyingTimer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.HealthComponent.GetPercentInjuredBleedoutTimer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::GetPercentInjuredBleedoutTimer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetPercentInjuredBleedoutTimer");

	Params::HealthComponent_GetPercentInjuredBleedoutTimer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.HealthComponent.IsDead
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHealthComponent::IsDead() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "IsDead");

	Params::HealthComponent_IsDead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.HealthComponent.IsDyingTimerExpired
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHealthComponent::IsDyingTimerExpired() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "IsDyingTimerExpired");

	Params::HealthComponent_IsDyingTimerExpired Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.HealthComponent.IsHealthy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHealthComponent::IsHealthy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "IsHealthy");

	Params::HealthComponent_IsHealthy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.HealthComponent.IsInInjuredBleedout
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHealthComponent::IsInInjuredBleedout() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "IsInInjuredBleedout");

	Params::HealthComponent_IsInInjuredBleedout Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.HealthComponent.IsInjured
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHealthComponent::IsInjured() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "IsInjured");

	Params::HealthComponent_IsInjured Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.HealthComponent.IsInjuredBleedoutTimerExpired
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHealthComponent::IsInjuredBleedoutTimerExpired() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "IsInjuredBleedoutTimerExpired");

	Params::HealthComponent_IsInjuredBleedoutTimerExpired Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.HealthComponent.IsKO
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHealthComponent::IsKO() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "IsKO");

	Params::HealthComponent_IsKO Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.HitValidationConfigsComponent.DBD_PrintInGameHitValidationConfigs
// (Final, Exec, Native, Public)

void UHitValidationConfigsComponent::DBD_PrintInGameHitValidationConfigs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitValidationConfigsComponent", "DBD_PrintInGameHitValidationConfigs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HitValidatorComponent.Multicast_DrawDebugHit
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const struct FHitValidationReport&      report                                                 (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UHitValidatorComponent::Multicast_DrawDebugHit(const struct FHitValidationReport& report)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitValidatorComponent", "Multicast_DrawDebugHit");

	Params::HitValidatorComponent_Multicast_DrawDebugHit Parms{};

	Parms.report = std::move(report);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HookableComponent.Authority_DebugSetHookDrainStage
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   drainStage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHookableComponent::Authority_DebugSetHookDrainStage(int32 drainStage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookableComponent", "Authority_DebugSetHookDrainStage");

	Params::HookableComponent_Authority_DebugSetHookDrainStage Parms{};

	Parms.drainStage = drainStage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HookableComponent.Authority_DebugSetHookEscapeAutoFail
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              fail                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHookableComponent::Authority_DebugSetHookEscapeAutoFail(const bool fail)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookableComponent", "Authority_DebugSetHookEscapeAutoFail");

	Params::HookableComponent_Authority_DebugSetHookEscapeAutoFail Parms{};

	Parms.fail = fail;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HookableComponent.Authority_DebugSetHookEscapeAutoSuccess
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              Success                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHookableComponent::Authority_DebugSetHookEscapeAutoSuccess(const bool Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookableComponent", "Authority_DebugSetHookEscapeAutoSuccess");

	Params::HookableComponent_Authority_DebugSetHookEscapeAutoSuccess Parms{};

	Parms.Success = Success;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HookableComponent.Multicast_SetDrainStage
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// int32                                   newDrainStage                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              forceUpdateDrainTimer                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHookableComponent::Multicast_SetDrainStage(int32 newDrainStage, class ADBDPlayer* Instigator, const bool forceUpdateDrainTimer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookableComponent", "Multicast_SetDrainStage");

	Params::HookableComponent_Multicast_SetDrainStage Parms{};

	Parms.newDrainStage = newDrainStage;
	Parms.Instigator = Instigator;
	Parms.forceUpdateDrainTimer = forceUpdateDrainTimer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HookableComponent.Multicast_SetDrainTimerPercentLeft
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// float                                   percentTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHookableComponent::Multicast_SetDrainTimerPercentLeft(float percentTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookableComponent", "Multicast_SetDrainTimerPercentLeft");

	Params::HookableComponent_Multicast_SetDrainTimerPercentLeft Parms{};

	Parms.percentTime = percentTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HookableComponent.GetDrainStage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UHookableComponent::GetDrainStage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookableComponent", "GetDrainStage");

	Params::HookableComponent_GetDrainStage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.HookableComponent.GetDrainTimerPercentLeft
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHookableComponent::GetDrainTimerPercentLeft() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookableComponent", "GetDrainTimerPercentLeft");

	Params::HookableComponent_GetDrainTimerPercentLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.HookableComponent.GetHookedCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UHookableComponent::GetHookedCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookableComponent", "GetHookedCount");

	Params::HookableComponent_GetHookedCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.HookableComponent.GetSacrificeStageIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UHookableComponent::GetSacrificeStageIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookableComponent", "GetSacrificeStageIndex");

	Params::HookableComponent_GetSacrificeStageIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ScreenSpaceLocationComponent.GetCurrentResolution
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UScreenSpaceLocationComponent::GetCurrentResolution() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenSpaceLocationComponent", "GetCurrentResolution");

	Params::ScreenSpaceLocationComponent_GetCurrentResolution Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ScreenSpaceLocationComponent.HasValidPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UScreenSpaceLocationComponent::HasValidPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenSpaceLocationComponent", "HasValidPosition");

	Params::ScreenSpaceLocationComponent_HasValidPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.HudScreen.OnHemorrhageAnimationComplete
// (Final, Native, Private)

void UHudScreen::OnHemorrhageAnimationComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HudScreen", "OnHemorrhageAnimationComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HudScreen.OnHideStartSequenceCompleted
// (Final, Native, Private)

void UHudScreen::OnHideStartSequenceCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HudScreen", "OnHideStartSequenceCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HudScreen.OnHUDWidgetFadeOutCompleted
// (Final, Native, Private)

void UHudScreen::OnHUDWidgetFadeOutCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HudScreen", "OnHUDWidgetFadeOutCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HudScreen.OnTutorialHudFadeInTriggered
// (Final, Native, Private)

void UHudScreen::OnTutorialHudFadeInTriggered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HudScreen", "OnTutorialHudFadeInTriggered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HudScreen.OnTutorialHudFadeOutTriggered
// (Final, Native, Private)

void UHudScreen::OnTutorialHudFadeOutTriggered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HudScreen", "OnTutorialHudFadeOutTriggered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HudScreen.OnHUDWidgetDelayCompleted
// (Final, Native, Private, Const)

void UHudScreen::OnHUDWidgetDelayCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HudScreen", "OnHUDWidgetDelayCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HudStateComponent.OnRep_IsHudVisible
// (Final, Native, Private)
// Parameters:
// const bool                              OldValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHudStateComponent::OnRep_IsHudVisible(const bool OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HudStateComponent", "OnRep_IsHudVisible");

	Params::HudStateComponent_OnRep_IsHudVisible Parms{};

	Parms.OldValue = OldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ImmobilizeUtilities.GetGuidedState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGuidedState                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGuidedState UImmobilizeUtilities::GetGuidedState(const class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ImmobilizeUtilities", "GetGuidedState");

	Params::ImmobilizeUtilities_GetGuidedState Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ImmobilizeUtilities.GetImmobilizeState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EImmobilizedState                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EImmobilizedState UImmobilizeUtilities::GetImmobilizeState(const class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ImmobilizeUtilities", "GetImmobilizeState");

	Params::ImmobilizeUtilities_GetImmobilizeState Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ImmobilizeUtilities.HasGuidedState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGuidedState                            GuidedState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UImmobilizeUtilities::HasGuidedState(const class ADBDPlayer* Player, EGuidedState GuidedState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ImmobilizeUtilities", "HasGuidedState");

	Params::ImmobilizeUtilities_HasGuidedState Parms{};

	Parms.Player = Player;
	Parms.GuidedState = GuidedState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ImmobilizeUtilities.HasImmobilizeState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EImmobilizedState                       ImmobilizeState                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UImmobilizeUtilities::HasImmobilizeState(const class ADBDPlayer* Player, EImmobilizedState ImmobilizeState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ImmobilizeUtilities", "HasImmobilizeState");

	Params::ImmobilizeUtilities_HasImmobilizeState Parms{};

	Parms.Player = Player;
	Parms.ImmobilizeState = ImmobilizeState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ImmobilizeUtilities.IsGuided
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UImmobilizeUtilities::IsGuided(const class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ImmobilizeUtilities", "IsGuided");

	Params::ImmobilizeUtilities_IsGuided Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ImmobilizeUtilities.IsGuidedByPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ADBDPlayer*                 guidingPlayer                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UImmobilizeUtilities::IsGuidedByPlayer(const class ADBDPlayer* Player, const class ADBDPlayer* guidingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ImmobilizeUtilities", "IsGuidedByPlayer");

	Params::ImmobilizeUtilities_IsGuidedByPlayer Parms{};

	Parms.Player = Player;
	Parms.guidingPlayer = guidingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ImmobilizeUtilities.IsImmobilized
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UImmobilizeUtilities::IsImmobilized(const class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ImmobilizeUtilities", "IsImmobilized");

	Params::ImmobilizeUtilities_IsImmobilized Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ImmobilizeUtilities.RemoveAllGuidingPlayers
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UImmobilizeUtilities::RemoveAllGuidingPlayers(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ImmobilizeUtilities", "RemoveAllGuidingPlayers");

	Params::ImmobilizeUtilities_RemoveAllGuidingPlayers Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ImmobilizeUtilities.SetImmobilizeState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EImmobilizedState                       ImmobilizeState                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UImmobilizeUtilities::SetImmobilizeState(class ADBDPlayer* Player, EImmobilizedState ImmobilizeState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ImmobilizeUtilities", "SetImmobilizeState");

	Params::ImmobilizeUtilities_SetImmobilizeState Parms{};

	Parms.Player = Player;
	Parms.ImmobilizeState = ImmobilizeState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ImmobilizeUtilities.StartGuiding
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGuidedState                            GuidedState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       guidingPlayer                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UImmobilizeUtilities::StartGuiding(class ADBDPlayer* Player, EGuidedState GuidedState, class ADBDPlayer* guidingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ImmobilizeUtilities", "StartGuiding");

	Params::ImmobilizeUtilities_StartGuiding Parms{};

	Parms.Player = Player;
	Parms.GuidedState = GuidedState;
	Parms.guidingPlayer = guidingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ImmobilizeUtilities.StopGuiding
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       previouslyGuidingPlayer                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UImmobilizeUtilities::StopGuiding(class ADBDPlayer* Player, class ADBDPlayer* previouslyGuidingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ImmobilizeUtilities", "StopGuiding");

	Params::ImmobilizeUtilities_StopGuiding Parms{};

	Parms.Player = Player;
	Parms.previouslyGuidingPlayer = previouslyGuidingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InfectedInteractableComponent.Authority_OnHitWithVomit
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UInfectedInteractableComponent::Authority_OnHitWithVomit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InfectedInteractableComponent", "Authority_OnHitWithVomit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InfectedInteractableComponent.Authority_OnOwningInteractableBeginOrEndUse
// (Final, Native, Public)
// Parameters:
// bool                                    InUse                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       interactingPlayer                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInfectedInteractableComponent::Authority_OnOwningInteractableBeginOrEndUse(bool InUse, class ADBDPlayer* interactingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InfectedInteractableComponent", "Authority_OnOwningInteractableBeginOrEndUse");

	Params::InfectedInteractableComponent_Authority_OnOwningInteractableBeginOrEndUse Parms{};

	Parms.InUse = InUse;
	Parms.interactingPlayer = interactingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InfectedInteractableComponent.Multicast_DebugDisplayLifetime
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// float                                   RemainingLifeTime                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInfectedInteractableComponent::Multicast_DebugDisplayLifetime(float RemainingLifeTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InfectedInteractableComponent", "Multicast_DebugDisplayLifetime");

	Params::InfectedInteractableComponent_Multicast_DebugDisplayLifetime Parms{};

	Parms.RemainingLifeTime = RemainingLifeTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InfectedInteractableComponent.Multicast_DestroyComponent
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void UInfectedInteractableComponent::Multicast_DestroyComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InfectedInteractableComponent", "Multicast_DestroyComponent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InfectedInteractableComponent.Multicast_FadeInVomit
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void UInfectedInteractableComponent::Multicast_FadeInVomit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InfectedInteractableComponent", "Multicast_FadeInVomit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InfectedInteractableComponent.Multicast_FadeOutVomit
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void UInfectedInteractableComponent::Multicast_FadeOutVomit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InfectedInteractableComponent", "Multicast_FadeOutVomit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InfectedInteractableComponent.OnVomitAlphaUpdate
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInfectedInteractableComponent::OnVomitAlphaUpdate(float alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InfectedInteractableComponent", "OnVomitAlphaUpdate");

	Params::InfectedInteractableComponent_OnVomitAlphaUpdate Parms{};

	Parms.alpha = alpha;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InfectedInteractableComponent.SetInteractableMeshAlpha
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInfectedInteractableComponent::SetInteractableMeshAlpha(float alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InfectedInteractableComponent", "SetInteractableMeshAlpha");

	Params::InfectedInteractableComponent_SetInteractableMeshAlpha Parms{};

	Parms.alpha = alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InfectedInteractableComponent.Authority_GetEquippingPlayer
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASurvivor*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASurvivor* UInfectedInteractableComponent::Authority_GetEquippingPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InfectedInteractableComponent", "Authority_GetEquippingPlayer");

	Params::InfectedInteractableComponent_Authority_GetEquippingPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InfectedInteractableComponent.Authority_IsAMaxSicknessSurvivorInteracting
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInfectedInteractableComponent::Authority_IsAMaxSicknessSurvivorInteracting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InfectedInteractableComponent", "Authority_IsAMaxSicknessSurvivorInteracting");

	Params::InfectedInteractableComponent_Authority_IsAMaxSicknessSurvivorInteracting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InfectedInteractableComponent.GetOwningInteractable
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AInteractable*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AInteractable* UInfectedInteractableComponent::GetOwningInteractable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InfectedInteractableComponent", "GetOwningInteractable");

	Params::InfectedInteractableComponent_GetOwningInteractable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionProficiency.GetIsActive
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class UChargeableInteractionDefinition*chargeableInteraction                                  (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionProficiency::GetIsActive(const class UChargeableInteractionDefinition* chargeableInteraction, const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionProficiency", "GetIsActive");

	Params::InteractionProficiency_GetIsActive Parms{};

	Parms.chargeableInteraction = chargeableInteraction;
	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionProficiency.GetLevel
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class UChargeableInteractionDefinition*chargeableInteraction                                  (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInteractionProficiency::GetLevel(const class UChargeableInteractionDefinition* chargeableInteraction, const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionProficiency", "GetLevel");

	Params::InteractionProficiency_GetLevel Parms{};

	Parms.chargeableInteraction = chargeableInteraction;
	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionProficiency.GetType
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStatusEffectType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EStatusEffectType UInteractionProficiency::GetType(const float Value) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionProficiency", "GetType");

	Params::InteractionProficiency_GetType Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionProficiency.GetValue
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class UChargeableInteractionDefinition*chargeableInteraction                                  (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionProficiency::GetValue(const class UChargeableInteractionDefinition* chargeableInteraction, const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionProficiency", "GetValue");

	Params::InteractionProficiency_GetValue Parms{};

	Parms.chargeableInteraction = chargeableInteraction;
	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactor.BPPostInitializeComponents
// (Event, Public, BlueprintEvent)

void UInteractor::BPPostInitializeComponents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactor", "BPPostInitializeComponents");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Interactor.Multicast_LockStatus
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractionDefinition*           currentInteraction                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    lock                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractor::Multicast_LockStatus(class ADBDPlayer* Player, class UInteractionDefinition* currentInteraction, bool lock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactor", "Multicast_LockStatus");

	Params::Interactor_Multicast_LockStatus Parms{};

	Parms.Player = Player;
	Parms.currentInteraction = currentInteraction;
	Parms.lock = lock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Interactor.Multicast_ReservationStatus
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    lock                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractor::Multicast_ReservationStatus(class ADBDPlayer* Player, bool lock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactor", "Multicast_ReservationStatus");

	Params::Interactor_Multicast_ReservationStatus Parms{};

	Parms.Player = Player;
	Parms.lock = lock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Interactor.OnRep_IsUsable
// (Final, Native, Private)

void UInteractor::OnRep_IsUsable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactor", "OnRep_IsUsable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Interactor.SetIsUsable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isUsableParam                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractor::SetIsUsable(bool isUsableParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactor", "SetIsUsable");

	Params::Interactor_SetIsUsable Parms{};

	Parms.isUsableParam = isUsableParam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Interactor.Authority_GetInteractingPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UInteractor::Authority_GetInteractingPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactor", "Authority_GetInteractingPlayer");

	Params::Interactor_Authority_GetInteractingPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactor.CanPerformInteraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UInteractionDefinition*     definition                                             (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractor::CanPerformInteraction(const class ADBDPlayer* Player, const class UInteractionDefinition* definition) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactor", "CanPerformInteraction");

	Params::Interactor_CanPerformInteraction Parms{};

	Parms.Player = Player;
	Parms.definition = definition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactor.GetCurrentInteraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractionDefinition*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionDefinition* UInteractor::GetCurrentInteraction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactor", "GetCurrentInteraction");

	Params::Interactor_GetCurrentInteraction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactor.GetInteractable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AInteractable*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AInteractable* UInteractor::GetInteractable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactor", "GetInteractable");

	Params::Interactor_GetInteractable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactor.GetInteractingPlayerRaw
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UInteractor::GetInteractingPlayerRaw() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactor", "GetInteractingPlayerRaw");

	Params::Interactor_GetInteractingPlayerRaw Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactor.GetInteractionDefinitions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class UInteractionDefinition*>ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TArray<class UInteractionDefinition*> UInteractor::GetInteractionDefinitions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactor", "GetInteractionDefinitions");

	Params::Interactor_GetInteractionDefinitions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactor.GetIsUsable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractor::GetIsUsable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactor", "GetIsUsable");

	Params::Interactor_GetIsUsable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactor.IsInteracting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractor::IsInteracting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactor", "IsInteracting");

	Params::Interactor_IsInteracting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactor.IsInterruptionPossible
// (Final, Native, Public, Const)
// Parameters:
// const class ADBDPlayer*                 interruptor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ADBDPlayer*                 interruptee                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UInteractionDefinition*     definition                                             (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UInterruptionDefinition*    interruption                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractor::IsInterruptionPossible(const class ADBDPlayer* interruptor, const class ADBDPlayer* interruptee, const class UInteractionDefinition* definition, const class UInterruptionDefinition* interruption) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactor", "IsInterruptionPossible");

	Params::Interactor_IsInterruptionPossible Parms{};

	Parms.interruptor = interruptor;
	Parms.interruptee = interruptee;
	Parms.definition = definition;
	Parms.interruption = interruption;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InterruptionDefinition.OnInterruptionEnterStart
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       interruptor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       interruptee                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInterruptionDefinition::OnInterruptionEnterStart(class ADBDPlayer* interruptor, class ADBDPlayer* interruptee)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InterruptionDefinition", "OnInterruptionEnterStart");

	Params::InterruptionDefinition_OnInterruptionEnterStart Parms{};

	Parms.interruptor = interruptor;
	Parms.interruptee = interruptee;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InterruptionDefinition.OnInterruptionExitEnd
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       interruptor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       interruptee                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInterruptionDefinition::OnInterruptionExitEnd(class ADBDPlayer* interruptor, class ADBDPlayer* interruptee)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InterruptionDefinition", "OnInterruptionExitEnd");

	Params::InterruptionDefinition_OnInterruptionExitEnd Parms{};

	Parms.interruptor = interruptor;
	Parms.interruptee = interruptee;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InterruptionDefinition.OnInterruptionUpdateStart
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       interruptor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       interruptee                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInterruptionDefinition::OnInterruptionUpdateStart(class ADBDPlayer* interruptor, class ADBDPlayer* interruptee)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InterruptionDefinition", "OnInterruptionUpdateStart");

	Params::InterruptionDefinition_OnInterruptionUpdateStart Parms{};

	Parms.interruptor = interruptor;
	Parms.interruptee = interruptee;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InterruptionDefinition.SetInterruptorSnapPoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FTransform&                Point                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInterruptionDefinition::SetInterruptorSnapPoint(const struct FTransform& Point)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InterruptionDefinition", "SetInterruptorSnapPoint");

	Params::InterruptionDefinition_SetInterruptorSnapPoint Parms{};

	Parms.Point = std::move(Point);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InterruptionDefinition.CanInterruptWhileCarrying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInterruptionDefinition::CanInterruptWhileCarrying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InterruptionDefinition", "CanInterruptWhileCarrying");

	Params::InterruptionDefinition_CanInterruptWhileCarrying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InterruptionDefinition.GetInteractable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AInteractable*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AInteractable* UInterruptionDefinition::GetInteractable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InterruptionDefinition", "GetInteractable");

	Params::InterruptionDefinition_GetInteractable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InterruptionDefinition.GetInteractionDefinition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractionDefinition*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionDefinition* UInterruptionDefinition::GetInteractionDefinition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InterruptionDefinition", "GetInteractionDefinition");

	Params::InterruptionDefinition_GetInteractionDefinition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InterruptionDefinition.GetInterruptionSnapPointPositionForInterruptor
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 interruptor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ADBDPlayer*                 interruptee                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UInterruptionDefinition::GetInterruptionSnapPointPositionForInterruptor(const class ADBDPlayer* interruptor, const class ADBDPlayer* interruptee) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InterruptionDefinition", "GetInterruptionSnapPointPositionForInterruptor");

	Params::InterruptionDefinition_GetInterruptionSnapPointPositionForInterruptor Parms{};

	Parms.interruptor = interruptor;
	Parms.interruptee = interruptee;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InterruptionDefinition.GetInterruptionSnapPointRotationForInterruptor
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 interruptor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ADBDPlayer*                 interruptee                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UInterruptionDefinition::GetInterruptionSnapPointRotationForInterruptor(const class ADBDPlayer* interruptor, const class ADBDPlayer* interruptee) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InterruptionDefinition", "GetInterruptionSnapPointRotationForInterruptor");

	Params::InterruptionDefinition_GetInterruptionSnapPointRotationForInterruptor Parms{};

	Parms.interruptor = interruptor;
	Parms.interruptee = interruptee;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InterruptionDefinition.InteractionCheckHeightDelta
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 interruptor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ADBDPlayer*                 interruptee                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInterruptionDefinition::InteractionCheckHeightDelta(const class ADBDPlayer* interruptor, const class ADBDPlayer* interruptee) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InterruptionDefinition", "InteractionCheckHeightDelta");

	Params::InterruptionDefinition_InteractionCheckHeightDelta Parms{};

	Parms.interruptor = interruptor;
	Parms.interruptee = interruptee;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InterruptionDefinition.IsInterruptionPossible
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// const class ADBDPlayer*                 interruptor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ADBDPlayer*                 interruptee                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInterruptionDefinition::IsInterruptionPossible(const class ADBDPlayer* interruptor, const class ADBDPlayer* interruptee) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InterruptionDefinition", "IsInterruptionPossible");

	Params::InterruptionDefinition_IsInterruptionPossible Parms{};

	Parms.interruptor = interruptor;
	Parms.interruptee = interruptee;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InterruptionDefinition.IsUsingAttack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInterruptionDefinition::IsUsingAttack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InterruptionDefinition", "IsUsingAttack");

	Params::InterruptionDefinition_IsUsingAttack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InterruptionDefinition.IsUsingMontageFollower
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInterruptionDefinition::IsUsingMontageFollower() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InterruptionDefinition", "IsUsingMontageFollower");

	Params::InterruptionDefinition_IsUsingMontageFollower Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ProceduralLevelBuilder.ApplyMist
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   Modifier                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProceduralLevelBuilder::ApplyMist(float Modifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralLevelBuilder", "ApplyMist");

	Params::ProceduralLevelBuilder_ApplyMist Parms{};

	Parms.Modifier = Modifier;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.ProceduralLevelBuilder.BuildFromSeed
// (Final, Native, Private)

void AProceduralLevelBuilder::BuildFromSeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralLevelBuilder", "BuildFromSeed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ProceduralLevelBuilder.Multicast_DebugShareGenerationData
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const struct FGenerationParams&         usedParams                                             (Parm, NativeAccessSpecifierPublic)

void AProceduralLevelBuilder::Multicast_DebugShareGenerationData(const struct FGenerationParams& usedParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralLevelBuilder", "Multicast_DebugShareGenerationData");

	Params::ProceduralLevelBuilder_Multicast_DebugShareGenerationData Parms{};

	Parms.usedParams = std::move(usedParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ProceduralLevelBuilder.RemoveMist
// (Event, Public, BlueprintEvent)

void AProceduralLevelBuilder::RemoveMist()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralLevelBuilder", "RemoveMist");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.ProceduralLevelBuilder.SpawnActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                           ActorClass                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETileSpawnPointType                     spawnPointType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AProceduralLevelBuilder::SpawnActor(class UClass* ActorClass, ETileSpawnPointType spawnPointType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralLevelBuilder", "SpawnActor");

	Params::ProceduralLevelBuilder_SpawnActor Parms{};

	Parms.ActorClass = ActorClass;
	Parms.spawnPointType = spawnPointType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ProceduralLevelBuilder.StartGenerationOnSyncerReady
// (Final, Native, Private)

void AProceduralLevelBuilder::StartGenerationOnSyncerReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralLevelBuilder", "StartGenerationOnSyncerReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ProceduralLevelBuilder.SyncSeeds
// (Final, Native, Private)

void AProceduralLevelBuilder::SyncSeeds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralLevelBuilder", "SyncSeeds");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ProtectionHitComponent.Authority_HandleProtectionScoringEvents
// (Final, Native, Public, BlueprintCallable)

void UProtectionHitComponent::Authority_HandleProtectionScoringEvents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProtectionHitComponent", "Authority_HandleProtectionScoringEvents");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemVfx.AddNiagaraComponent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                NiagaraComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItemVfx::AddNiagaraComponent(class UNiagaraComponent* NiagaraComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemVfx", "AddNiagaraComponent");

	Params::ItemVfx_AddNiagaraComponent Parms{};

	Parms.NiagaraComponent = NiagaraComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemVfx.AddParticleSystemComponent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UParticleSystemComponent*         ParticleSystemComponent                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItemVfx::AddParticleSystemComponent(class UParticleSystemComponent* ParticleSystemComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemVfx", "AddParticleSystemComponent");

	Params::ItemVfx_AddParticleSystemComponent Parms{};

	Parms.ParticleSystemComponent = ParticleSystemComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemVfx.AttachToSkeletalMesh
// (Event, Public, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           SkeletonPart                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItemVfx::AttachToSkeletalMesh(class USkeletalMeshComponent* SkeletonPart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemVfx", "AttachToSkeletalMesh");

	Params::ItemVfx_AttachToSkeletalMesh Parms{};

	Parms.SkeletonPart = SkeletonPart;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.ItemVfx.ClearParticleSystems
// (Final, Native, Public, BlueprintCallable)

void AItemVfx::ClearParticleSystems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemVfx", "ClearParticleSystems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemVfx.OnAttackBegin
// (Event, Public, BlueprintEvent)

void AItemVfx::OnAttackBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemVfx", "OnAttackBegin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.ItemVfx.OnAttackEnd
// (Event, Public, BlueprintEvent)

void AItemVfx::OnAttackEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemVfx", "OnAttackEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.ItemVfx.SpawnNiagaraSystemAttached
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UNiagaraSystem*                   SystemTemplate                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  AttachToComponent                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             attachPointName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachLocation                         LocationType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AutoDestroy                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENCPoolMethod                           PoolingMethod                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector&                   Scale                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    autoActivate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    preCullCheck                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    absoluteRotation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    hideInFPV                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraComponent* AItemVfx::SpawnNiagaraSystemAttached(class UNiagaraSystem* SystemTemplate, class USceneComponent* AttachToComponent, class FName attachPointName, EAttachLocation LocationType, bool AutoDestroy, ENCPoolMethod PoolingMethod, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, bool autoActivate, bool preCullCheck, bool absoluteRotation, bool hideInFPV)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemVfx", "SpawnNiagaraSystemAttached");

	Params::ItemVfx_SpawnNiagaraSystemAttached Parms{};

	Parms.SystemTemplate = SystemTemplate;
	Parms.AttachToComponent = AttachToComponent;
	Parms.attachPointName = attachPointName;
	Parms.LocationType = LocationType;
	Parms.AutoDestroy = AutoDestroy;
	Parms.PoolingMethod = PoolingMethod;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.Scale = std::move(Scale);
	Parms.autoActivate = autoActivate;
	Parms.preCullCheck = preCullCheck;
	Parms.absoluteRotation = absoluteRotation;
	Parms.hideInFPV = hideInFPV;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TrapChemicalBomb.OnRep_CurrentState
// (Final, Native, Private)

void ATrapChemicalBomb::OnRep_CurrentState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrapChemicalBomb", "OnRep_CurrentState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TrapChemicalBomb.GetPallet
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APallet*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APallet* ATrapChemicalBomb::GetPallet() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrapChemicalBomb", "GetPallet");

	Params::TrapChemicalBomb_GetPallet Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TrapChemicalBomb.GetState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETrapBombState                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETrapBombState ATrapChemicalBomb::GetState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrapChemicalBomb", "GetState");

	Params::TrapChemicalBomb_GetState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TrapChemicalBomb.GetTrapPlacer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* ATrapChemicalBomb::GetTrapPlacer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrapChemicalBomb", "GetTrapPlacer");

	Params::TrapChemicalBomb_GetTrapPlacer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.Authority_AllowKilling
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   numKills                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::Authority_AllowKilling(int32 numKills)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "Authority_AllowKilling");

	Params::Killer_Authority_AllowKilling Parms{};

	Parms.numKills = numKills;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Killer.Authority_RequestStun
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// EStunType                               stunType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       requester                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   stunQueueTime                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::Authority_RequestStun(EStunType stunType, class ADBDPlayer* requester, float stunQueueTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "Authority_RequestStun");

	Params::Killer_Authority_RequestStun Parms{};

	Parms.stunType = stunType;
	Parms.requester = requester;
	Parms.stunQueueTime = stunQueueTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Killer.Authority_SetInStalkMode
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    stalkMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Forced                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::Authority_SetInStalkMode(bool stalkMode, bool Forced)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "Authority_SetInStalkMode");

	Params::Killer_Authority_SetInStalkMode Parms{};

	Parms.stalkMode = stalkMode;
	Parms.Forced = Forced;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Killer.BroadcastOnInstantTeleport
// (Final, Native, Public, BlueprintCallable)

void AKiller::BroadcastOnInstantTeleport()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "BroadcastOnInstantTeleport");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Killer.CancelAttackByInput
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AKiller::CancelAttackByInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "CancelAttackByInput");

	Params::Killer_CancelAttackByInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.Client_RequestStun
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// EStunType                               stunType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       stunner                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   stunQueueTime                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::Client_RequestStun(EStunType stunType, class ADBDPlayer* stunner, float stunQueueTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "Client_RequestStun");

	Params::Killer_Client_RequestStun Parms{};

	Parms.stunType = stunType;
	Parms.stunner = stunner;
	Parms.stunQueueTime = stunQueueTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Killer.Cosmetic_OnCancelCarry
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void AKiller::Cosmetic_OnCancelCarry()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "Cosmetic_OnCancelCarry");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Killer.Cosmetic_OnDropCamperEnd
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void AKiller::Cosmetic_OnDropCamperEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "Cosmetic_OnDropCamperEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Killer.Cosmetic_OnPickUpEnd
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void AKiller::Cosmetic_OnPickUpEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "Cosmetic_OnPickUpEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Killer.DBD_AllowKilling
// (Final, Exec, Native, Public)

void AKiller::DBD_AllowKilling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "DBD_AllowKilling");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Killer.DBD_DisplayAttackZones
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    Display                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::DBD_DisplayAttackZones(bool Display)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "DBD_DisplayAttackZones");

	Params::Killer_DBD_DisplayAttackZones Parms{};

	Parms.Display = Display;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Killer.DBD_MergeLockOnDamageZones
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::DBD_MergeLockOnDamageZones(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "DBD_MergeLockOnDamageZones");

	Params::Killer_DBD_MergeLockOnDamageZones Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Killer.DBD_SetAttackZones
// (Final, Exec, Native, Public)
// Parameters:
// EAttackZoneSet                          attackZoneSet                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::DBD_SetAttackZones(EAttackZoneSet attackZoneSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "DBD_SetAttackZones");

	Params::Killer_DBD_SetAttackZones Parms{};

	Parms.attackZoneSet = attackZoneSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Killer.DecrementInterruptBlock
// (Final, Native, Public, BlueprintCallable)

void AKiller::DecrementInterruptBlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "DecrementInterruptBlock");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Killer.DisplayAttackZones
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Display                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::DisplayAttackZones(bool Display)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "DisplayAttackZones");

	Params::Killer_DisplayAttackZones Parms{};

	Parms.Display = Display;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Killer.GetAttackZonePivot
// (Event, Public, BlueprintEvent)
// Parameters:
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* AKiller::GetAttackZonePivot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "GetAttackZonePivot");

	Params::Killer_GetAttackZonePivot Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.GetCurrentRotationYaw
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AKiller::GetCurrentRotationYaw()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "GetCurrentRotationYaw");

	Params::Killer_GetCurrentRotationYaw Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.IncrementInterruptBlock
// (Final, Native, Public, BlueprintCallable)

void AKiller::IncrementInterruptBlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "IncrementInterruptBlock");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Killer.IsCrouchAvailable_BP
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AKiller::IsCrouchAvailable_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "IsCrouchAvailable_BP");

	Params::Killer_IsCrouchAvailable_BP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.IsIdling
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AKiller::IsIdling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "IsIdling");

	Params::Killer_IsIdling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.Local_CancelAttack
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AKiller::Local_CancelAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "Local_CancelAttack");

	Params::Killer_Local_CancelAttack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.MergeLockOnDamageZones
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::MergeLockOnDamageZones(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "MergeLockOnDamageZones");

	Params::Killer_MergeLockOnDamageZones Parms{};

	Parms.Enable = Enable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Killer.Multicast_Cheat_SetAttackDetectionZoneSet
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// EAttackZoneSet                          attackZoneSet                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::Multicast_Cheat_SetAttackDetectionZoneSet(EAttackZoneSet attackZoneSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "Multicast_Cheat_SetAttackDetectionZoneSet");

	Params::Killer_Multicast_Cheat_SetAttackDetectionZoneSet Parms{};

	Parms.attackZoneSet = attackZoneSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Killer.Multicast_DisplayAttackZones
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    Display                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::Multicast_DisplayAttackZones(bool Display)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "Multicast_DisplayAttackZones");

	Params::Killer_Multicast_DisplayAttackZones Parms{};

	Parms.Display = Display;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Killer.Multicast_MergeLockOnDamageZones
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::Multicast_MergeLockOnDamageZones(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "Multicast_MergeLockOnDamageZones");

	Params::Killer_Multicast_MergeLockOnDamageZones Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Killer.OnAttackFinish
// (Final, Native, Private)
// Parameters:
// const EAttackType                       attackType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::OnAttackFinish(const EAttackType attackType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "OnAttackFinish");

	Params::Killer_OnAttackFinish Parms{};

	Parms.attackType = attackType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Killer.OnAttackStart
// (Final, Native, Private)
// Parameters:
// const EAttackType                       attackType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::OnAttackStart(const EAttackType attackType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "OnAttackStart");

	Params::Killer_OnAttackStart Parms{};

	Parms.attackType = attackType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Killer.OnIsKillingSurvivorWithMoriUpdated
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    isKillingSurvivorWithMori                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::OnIsKillingSurvivorWithMoriUpdated(bool isKillingSurvivorWithMori)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "OnIsKillingSurvivorWithMoriUpdated");

	Params::Killer_OnIsKillingSurvivorWithMoriUpdated Parms{};

	Parms.isKillingSurvivorWithMori = isKillingSurvivorWithMori;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Killer.OnKillerAbilityBeginActivate
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EKillerAbilities                        killerAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::OnKillerAbilityBeginActivate(EKillerAbilities killerAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "OnKillerAbilityBeginActivate");

	Params::Killer_OnKillerAbilityBeginActivate Parms{};

	Parms.killerAbility = killerAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Killer.OnKillerAbilityBeginDeactivate
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EKillerAbilities                        killerAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Forced                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::OnKillerAbilityBeginDeactivate(EKillerAbilities killerAbility, bool Forced)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "OnKillerAbilityBeginDeactivate");

	Params::Killer_OnKillerAbilityBeginDeactivate Parms{};

	Parms.killerAbility = killerAbility;
	Parms.Forced = Forced;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Killer.OnKillerAbilityEndActivate
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EKillerAbilities                        killerAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::OnKillerAbilityEndActivate(EKillerAbilities killerAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "OnKillerAbilityEndActivate");

	Params::Killer_OnKillerAbilityEndActivate Parms{};

	Parms.killerAbility = killerAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Killer.OnKillerAbilityEndDeactivate
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EKillerAbilities                        killerAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Forced                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::OnKillerAbilityEndDeactivate(EKillerAbilities killerAbility, bool Forced)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "OnKillerAbilityEndDeactivate");

	Params::Killer_OnKillerAbilityEndDeactivate Parms{};

	Parms.killerAbility = killerAbility;
	Parms.Forced = Forced;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Killer.OnLoudNoiseIndicatorDestroyed
// (Final, Native, Private)

void AKiller::OnLoudNoiseIndicatorDestroyed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "OnLoudNoiseIndicatorDestroyed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Killer.OnLoudNoiseTriggered
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           originator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           instigatingActor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    shouldTrack                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  audibleRange                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isQuickAction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isDeceivingNoise                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::OnLoudNoiseTriggered(class AActor* originator, class AActor* instigatingActor, const struct FVector& Location, bool shouldTrack, float* audibleRange, bool isQuickAction, bool isDeceivingNoise)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "OnLoudNoiseTriggered");

	Params::Killer_OnLoudNoiseTriggered Parms{};

	Parms.originator = originator;
	Parms.instigatingActor = instigatingActor;
	Parms.Location = std::move(Location);
	Parms.shouldTrack = shouldTrack;
	Parms.isQuickAction = isQuickAction;
	Parms.isDeceivingNoise = isDeceivingNoise;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (audibleRange != nullptr)
		*audibleRange = Parms.audibleRange;
}


// Function DeadByDaylight.Killer.OnPerformingChargableInteraction
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::OnPerformingChargableInteraction(float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "OnPerformingChargableInteraction");

	Params::Killer_OnPerformingChargableInteraction Parms{};

	Parms.Progress = Progress;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Killer.OnStalkModeChangedCosmetic
// (BlueprintCosmetic, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    stalkMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::OnStalkModeChangedCosmetic(bool stalkMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "OnStalkModeChangedCosmetic");

	Params::Killer_OnStalkModeChangedCosmetic Parms{};

	Parms.stalkMode = stalkMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Killer.OnStealthChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    stealth                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::OnStealthChanged(bool stealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "OnStealthChanged");

	Params::Killer_OnStealthChanged Parms{};

	Parms.stealth = stealth;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Killer.OnSurvivorHit
// (Event, Public, BlueprintEvent)
// Parameters:
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::OnSurvivorHit(class ASurvivor* Survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "OnSurvivorHit");

	Params::Killer_OnSurvivorHit Parms{};

	Parms.Survivor = Survivor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Killer.PlayBloodHitsEffects
// (BlueprintCosmetic, Event, Public, BlueprintCallable, BlueprintEvent)

void AKiller::PlayBloodHitsEffects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "PlayBloodHitsEffects");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Killer.Server_SendActionKillerInput
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    Pressed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::Server_SendActionKillerInput(bool Pressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "Server_SendActionKillerInput");

	Params::Killer_Server_SendActionKillerInput Parms{};

	Parms.Pressed = Pressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Killer.Server_SendAttackInput
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    Pressed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::Server_SendAttackInput(bool Pressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "Server_SendAttackInput");

	Params::Killer_Server_SendAttackInput Parms{};

	Parms.Pressed = Pressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Killer.SetAttackDetectionZoneSet
// (Event, Public, BlueprintEvent)
// Parameters:
// EAttackZoneSet                          attackZoneSet                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::SetAttackDetectionZoneSet(EAttackZoneSet attackZoneSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "SetAttackDetectionZoneSet");

	Params::Killer_SetAttackDetectionZoneSet Parms{};

	Parms.attackZoneSet = attackZoneSet;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Killer.SetAttackZonePivot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  attackZonePivot                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::SetAttackZonePivot(class USceneComponent* attackZonePivot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "SetAttackZonePivot");

	Params::Killer_SetAttackZonePivot Parms{};

	Parms.attackZonePivot = attackZonePivot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Killer.SetCarriedSurvivor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::SetCarriedSurvivor(class ASurvivor* Survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "SetCarriedSurvivor");

	Params::Killer_SetCarriedSurvivor Parms{};

	Parms.Survivor = Survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Killer.SetIsCloaked
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    IsCloaked_0                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Forced                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::SetIsCloaked(bool IsCloaked_0, bool Forced)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "SetIsCloaked");

	Params::Killer_SetIsCloaked Parms{};

	Parms.IsCloaked_0 = IsCloaked_0;
	Parms.Forced = Forced;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Killer.SetIsHookingSurvivor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::SetIsHookingSurvivor(const bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "SetIsHookingSurvivor");

	Params::Killer_SetIsHookingSurvivor Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Killer.SetIsKilling
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsKilling                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::SetIsKilling(bool IsKilling)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "SetIsKilling");

	Params::Killer_SetIsKilling Parms{};

	Parms.IsKilling = IsKilling;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Killer.SetLightIntensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Intensity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::SetLightIntensity(float Intensity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "SetLightIntensity");

	Params::Killer_SetLightIntensity Parms{};

	Parms.Intensity = Intensity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Killer.SetStalkTierWalkSpeedMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   stalkTierWalkSpeedMultiplier                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::SetStalkTierWalkSpeedMultiplier(float stalkTierWalkSpeedMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "SetStalkTierWalkSpeedMultiplier");

	Params::Killer_SetStalkTierWalkSpeedMultiplier Parms{};

	Parms.stalkTierWalkSpeedMultiplier = stalkTierWalkSpeedMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Killer.SetSurvivorBeingKilled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::SetSurvivorBeingKilled(class ASurvivor* Survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "SetSurvivorBeingKilled");

	Params::Killer_SetSurvivorBeingKilled Parms{};

	Parms.Survivor = Survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Killer.SpawnSlasherPower
// (Native, Event, Protected, BlueprintEvent)

void AKiller::SpawnSlasherPower()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "SpawnSlasherPower");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Killer.UpdateRageTierEffect
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// int32                                   previousTier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   currentTier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKiller::UpdateRageTierEffect(int32 previousTier, int32 currentTier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "UpdateRageTierEffect");

	Params::Killer_UpdateRageTierEffect Parms{};

	Parms.previousTier = previousTier;
	Parms.currentTier = currentTier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Killer.CanAffectLocalPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AKiller::CanAffectLocalPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "CanAffectLocalPlayer");

	Params::Killer_CanAffectLocalPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.CanAttack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const EAttackType                       attackType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AKiller::CanAttack(const EAttackType attackType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "CanAttack");

	Params::Killer_CanAttack Parms{};

	Parms.attackType = attackType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.CanAttack_BP
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// const EAttackType                       attackType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AKiller::CanAttack_BP(const EAttackType attackType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "CanAttack_BP");

	Params::Killer_CanAttack_BP Parms{};

	Parms.attackType = attackType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.CanGainRage
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AKiller::CanGainRage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "CanGainRage");

	Params::Killer_CanGainRage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.CanPerformKillerAbility
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// EKillerAbilities                        killerAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AKiller::CanPerformKillerAbility(EKillerAbilities killerAbility) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "CanPerformKillerAbility");

	Params::Killer_CanPerformKillerAbility Parms{};

	Parms.killerAbility = killerAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.CanSlashAttack_BP
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AKiller::CanSlashAttack_BP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "CanSlashAttack_BP");

	Params::Killer_CanSlashAttack_BP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.GetAnimDirection
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AKiller::GetAnimDirection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "GetAnimDirection");

	Params::Killer_GetAnimDirection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.GetBlindedPercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AKiller::GetBlindedPercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "GetBlindedPercent");

	Params::Killer_GetBlindedPercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.GetCarriedSurvivor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASurvivor*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASurvivor* AKiller::GetCarriedSurvivor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "GetCarriedSurvivor");

	Params::Killer_GetCarriedSurvivor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.GetCharacterCustomAnimTags
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> AKiller::GetCharacterCustomAnimTags() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "GetCharacterCustomAnimTags");

	Params::Killer_GetCharacterCustomAnimTags Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.GetChaserCharacterComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UChaserCharacterComponent*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChaserCharacterComponent* AKiller::GetChaserCharacterComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "GetChaserCharacterComponent");

	Params::Killer_GetChaserCharacterComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.GetIsAttacking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AKiller::GetIsAttacking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "GetIsAttacking");

	Params::Killer_GetIsAttacking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.GetKillerCarryAnimWeight
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// EKillerCarryAnimWeight                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EKillerCarryAnimWeight AKiller::GetKillerCarryAnimWeight() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "GetKillerCarryAnimWeight");

	Params::Killer_GetKillerCarryAnimWeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.GetKillerMovement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UKillerMovementComponent*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UKillerMovementComponent* AKiller::GetKillerMovement() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "GetKillerMovement");

	Params::Killer_GetKillerMovement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.GetLightIntensity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AKiller::GetLightIntensity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "GetLightIntensity");

	Params::Killer_GetLightIntensity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.GetLookRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator AKiller::GetLookRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "GetLookRotation");

	Params::Killer_GetLookRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.GetObsessionTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASurvivor*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASurvivor* AKiller::GetObsessionTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "GetObsessionTarget");

	Params::Killer_GetObsessionTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.GetPlayerDropOffPoint
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AKiller::GetPlayerDropOffPoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "GetPlayerDropOffPoint");

	Params::Killer_GetPlayerDropOffPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.GetPresenceTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag AKiller::GetPresenceTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "GetPresenceTag");

	Params::Killer_GetPresenceTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.GetRageTier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AKiller::GetRageTier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "GetRageTier");

	Params::Killer_GetRageTier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.GetStalkTierWalkSpeedMultiplier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AKiller::GetStalkTierWalkSpeedMultiplier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "GetStalkTierWalkSpeedMultiplier");

	Params::Killer_GetStalkTierWalkSpeedMultiplier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.GetStealthRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AKiller::GetStealthRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "GetStealthRatio");

	Params::Killer_GetStealthRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.GetSurvivorBeingKilled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASurvivor*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASurvivor* AKiller::GetSurvivorBeingKilled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "GetSurvivorBeingKilled");

	Params::Killer_GetSurvivorBeingKilled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.HasKillerAbility
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EKillerAbilities                        killerAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AKiller::HasKillerAbility(EKillerAbilities killerAbility) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "HasKillerAbility");

	Params::Killer_HasKillerAbility Parms{};

	Parms.killerAbility = killerAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.HasPreLevelGenerationModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             modifierID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AKiller::HasPreLevelGenerationModifier(class FName modifierID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "HasPreLevelGenerationModifier");

	Params::Killer_HasPreLevelGenerationModifier Parms{};

	Parms.modifierID = modifierID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.IsAllowedToKill
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ASurvivor*                  Survivor                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AKiller::IsAllowedToKill(const class ASurvivor* Survivor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "IsAllowedToKill");

	Params::Killer_IsAllowedToKill Parms{};

	Parms.Survivor = Survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.IsCarrying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AKiller::IsCarrying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "IsCarrying");

	Params::Killer_IsCarrying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.IsCloaking
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AKiller::IsCloaking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "IsCloaking");

	Params::Killer_IsCloaking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.IsImmuneToObservingPlayerDetection
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 observingPlayer                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AKiller::IsImmuneToObservingPlayerDetection(const class ADBDPlayer* observingPlayer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "IsImmuneToObservingPlayerDetection");

	Params::Killer_IsImmuneToObservingPlayerDetection Parms{};

	Parms.observingPlayer = observingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.IsInterruptBlocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AKiller::IsInterruptBlocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "IsInterruptBlocked");

	Params::Killer_IsInterruptBlocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.IsKilling
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AKiller::IsKilling() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "IsKilling");

	Params::Killer_IsKilling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.IsStunned
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AKiller::IsStunned() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "IsStunned");

	Params::Killer_IsStunned Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.IsUncloaking
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AKiller::IsUncloaking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "IsUncloaking");

	Params::Killer_IsUncloaking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.ShouldApplyBloodlustSpeedModifier
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AKiller::ShouldApplyBloodlustSpeedModifier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "ShouldApplyBloodlustSpeedModifier");

	Params::Killer_ShouldApplyBloodlustSpeedModifier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Killer.WasRecentlyCloaked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AKiller::WasRecentlyCloaked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Killer", "WasRecentlyCloaked");

	Params::Killer_WasRecentlyCloaked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.KillerAudioHandlerComponent.ChaseTriggerKillerReactionSpecificSurvivorSFX
// (BlueprintCosmetic, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerAudioHandlerComponent::ChaseTriggerKillerReactionSpecificSurvivorSFX(class ADBDPlayer* Survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAudioHandlerComponent", "ChaseTriggerKillerReactionSpecificSurvivorSFX");

	Params::KillerAudioHandlerComponent_ChaseTriggerKillerReactionSpecificSurvivorSFX Parms{};

	Parms.Survivor = Survivor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.KillerAudioHandlerComponent.HitImpactOnSurvivorSFX
// (BlueprintCosmetic, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttackType                             attackType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsWeaponHit                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerAudioHandlerComponent::HitImpactOnSurvivorSFX(class ASurvivor* Survivor, EAttackType attackType, bool IsWeaponHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAudioHandlerComponent", "HitImpactOnSurvivorSFX");

	Params::KillerAudioHandlerComponent_HitImpactOnSurvivorSFX Parms{};

	Parms.Survivor = Survivor;
	Parms.attackType = attackType;
	Parms.IsWeaponHit = IsWeaponHit;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.KillerAudioHandlerComponent.OnChaseStart
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       chasedSurvivor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerAudioHandlerComponent::OnChaseStart(class ADBDPlayer* chasedSurvivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAudioHandlerComponent", "OnChaseStart");

	Params::KillerAudioHandlerComponent_OnChaseStart Parms{};

	Parms.chasedSurvivor = chasedSurvivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerAudioHandlerComponent.TriggerKillerReactionSpecificSurvivorSFX
// (BlueprintCosmetic, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerAudioHandlerComponent::TriggerKillerReactionSpecificSurvivorSFX(class ADBDPlayer* Survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAudioHandlerComponent", "TriggerKillerReactionSpecificSurvivorSFX");

	Params::KillerAudioHandlerComponent_TriggerKillerReactionSpecificSurvivorSFX Parms{};

	Parms.Survivor = Survivor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.KillerAudioHandlerComponent.TriggerSurvivorDamageHitAudioSFX
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttackType                             attackType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CausedKO                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsWeaponHit                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isLightHit                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerAudioHandlerComponent::TriggerSurvivorDamageHitAudioSFX(class ASurvivor* Survivor, EAttackType attackType, bool CausedKO, bool IsWeaponHit, bool isLightHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAudioHandlerComponent", "TriggerSurvivorDamageHitAudioSFX");

	Params::KillerAudioHandlerComponent_TriggerSurvivorDamageHitAudioSFX Parms{};

	Parms.Survivor = Survivor;
	Parms.attackType = attackType;
	Parms.CausedKO = CausedKO;
	Parms.IsWeaponHit = IsWeaponHit;
	Parms.isLightHit = isLightHit;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.KillerAudioMenuReactionComponent.LobbyKillerReactionSpecificSurvivorSFX
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const TArray<class ADBDMenuPlayer*>&    menuPlayers                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKillerAudioMenuReactionComponent::LobbyKillerReactionSpecificSurvivorSFX(const TArray<class ADBDMenuPlayer*>& menuPlayers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAudioMenuReactionComponent", "LobbyKillerReactionSpecificSurvivorSFX");

	Params::KillerAudioMenuReactionComponent_LobbyKillerReactionSpecificSurvivorSFX Parms{};

	Parms.menuPlayers = std::move(menuPlayers);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.KillerAudioMenuReactionComponent.OnLobbyTimeChanged
// (Final, Native, Private)

void UKillerAudioMenuReactionComponent::OnLobbyTimeChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAudioMenuReactionComponent", "OnLobbyTimeChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerBloodFXComponent.PlayBloodSplatter
// (Final, Native, Public, BlueprintCallable)

void UKillerBloodFXComponent::PlayBloodSplatter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerBloodFXComponent", "PlayBloodSplatter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerBloodFXComponent.StopBloodSplatter
// (Final, Native, Public, BlueprintCallable)

void UKillerBloodFXComponent::StopBloodSplatter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerBloodFXComponent", "StopBloodSplatter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerBloodFXInterface.PlayBloodSplatter
// (Event, Public, BlueprintEvent)

void IKillerBloodFXInterface::PlayBloodSplatter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("KillerBloodFXInterface", "PlayBloodSplatter");

	AsUObject()->ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.KillerBloodFXInterface.StopBloodSplatter
// (Event, Public, BlueprintEvent)

void IKillerBloodFXInterface::StopBloodSplatter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("KillerBloodFXInterface", "StopBloodSplatter");

	AsUObject()->ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.KillerHitsWhileCarryingTrackerComponent.OnAttack
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UKillerHitsWhileCarryingTrackerComponent::OnAttack(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerHitsWhileCarryingTrackerComponent", "OnAttack");

	Params::KillerHitsWhileCarryingTrackerComponent_OnAttack Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerHitsWhileCarryingTrackerComponent.OnPickup
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UKillerHitsWhileCarryingTrackerComponent::OnPickup(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerHitsWhileCarryingTrackerComponent", "OnPickup");

	Params::KillerHitsWhileCarryingTrackerComponent_OnPickup Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerHitsWhileCarryingTrackerComponent.OnPostAttack
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UKillerHitsWhileCarryingTrackerComponent::OnPostAttack(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerHitsWhileCarryingTrackerComponent", "OnPostAttack");

	Params::KillerHitsWhileCarryingTrackerComponent_OnPostAttack Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StoreSpecialPackSubsystem.GetSpecialPacksUpdatedDelegate
// (Final, Native, Public)
// Parameters:
// TMulticastInlineDelegate<void()>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NativeAccessSpecifierPublic)

TMulticastInlineDelegate<void()> UStoreSpecialPackSubsystem::GetSpecialPacksUpdatedDelegate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoreSpecialPackSubsystem", "GetSpecialPacksUpdatedDelegate");

	Params::StoreSpecialPackSubsystem_GetSpecialPacksUpdatedDelegate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.KillerIntroComponent.KillerCameraPanInUpdateNative
// (Final, Native, Private)
// Parameters:
// const float                             killerIntroCompletedPercent                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerIntroComponent::KillerCameraPanInUpdateNative(const float killerIntroCompletedPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerIntroComponent", "KillerCameraPanInUpdateNative");

	Params::KillerIntroComponent_KillerCameraPanInUpdateNative Parms{};

	Parms.killerIntroCompletedPercent = killerIntroCompletedPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerIntroComponent.OnIntroCompleted
// (Final, Native, Private)

void UKillerIntroComponent::OnIntroCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerIntroComponent", "OnIntroCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerIntroComponent.OnLevelReadyToPlay
// (Final, Native, Private)

void UKillerIntroComponent::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerIntroComponent", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerMovementComponent.GetBaseMaxSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKillerMovementComponent::GetBaseMaxSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerMovementComponent", "GetBaseMaxSpeed");

	Params::KillerMovementComponent_GetBaseMaxSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.KillerOpenGate.UpdateSwitch
// (Event, Protected, BlueprintEvent, Const)

void UKillerOpenGate::UpdateSwitch() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerOpenGate", "UpdateSwitch");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.KillerStunnableComponent.Server_NotifyStunHasBeenProcessed
// (Net, NetReliable, Native, Event, Public, NetServer)

void UKillerStunnableComponent::Server_NotifyStunHasBeenProcessed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerStunnableComponent", "Server_NotifyStunHasBeenProcessed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LanternInteractable.ChangeLanternState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELanternState                           newLanternState                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALanternInteractable::ChangeLanternState(ELanternState newLanternState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LanternInteractable", "ChangeLanternState");

	Params::LanternInteractable_ChangeLanternState Parms{};

	Parms.newLanternState = newLanternState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LanternInteractable.CollectLight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALanternInteractable::CollectLight(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LanternInteractable", "CollectLight");

	Params::LanternInteractable_CollectLight Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LanternInteractable.OnBackToCollectableTimerEnd
// (Final, Native, Private)

void ALanternInteractable::OnBackToCollectableTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LanternInteractable", "OnBackToCollectableTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LanternInteractable.OnCamperLeavingHook
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ALanternInteractable::OnCamperLeavingHook(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LanternInteractable", "OnCamperLeavingHook");

	Params::LanternInteractable_OnCamperLeavingHook Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LanternInteractable.OnCamperWasHooked
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ALanternInteractable::OnCamperWasHooked(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LanternInteractable", "OnCamperWasHooked");

	Params::LanternInteractable_OnCamperWasHooked Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LanternInteractable.OnSlasherDestroyedLantern
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ALanternInteractable::OnSlasherDestroyedLantern(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LanternInteractable", "OnSlasherDestroyedLantern");

	Params::LanternInteractable_OnSlasherDestroyedLantern Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LanternInteractable.SlasherDestroyLantern
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALanternInteractable::SlasherDestroyLantern(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LanternInteractable", "SlasherDestroyLantern");

	Params::LanternInteractable_SlasherDestroyLantern Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LanternInteractable.CanBeCollected
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALanternInteractable::CanBeCollected() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LanternInteractable", "CanBeCollected");

	Params::LanternInteractable_CanBeCollected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.LanternInteractable.CanBeDestroyed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALanternInteractable::CanBeDestroyed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LanternInteractable", "CanBeDestroyed");

	Params::LanternInteractable_CanBeDestroyed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.LanternInteractable.GetLanternState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELanternState                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELanternState ALanternInteractable::GetLanternState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LanternInteractable", "GetLanternState");

	Params::LanternInteractable_GetLanternState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.LegalMenuScreen.OnAcceptClick
// (Final, Native, Protected)

void ULegalMenuScreen::OnAcceptClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LegalMenuScreen", "OnAcceptClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LegalMenuScreen.OnDeclineClick
// (Final, Native, Protected)

void ULegalMenuScreen::OnDeclineClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LegalMenuScreen", "OnDeclineClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LegalMenuScreen.OnOkClick
// (Final, Native, Protected)

void ULegalMenuScreen::OnOkClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LegalMenuScreen", "OnOkClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGGenericPopup.OnPopupAppearance
// (Event, Public, BlueprintEvent)

void UUMGGenericPopup::OnPopupAppearance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGGenericPopup", "OnPopupAppearance");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.UMGGenericPopup.OnPopupDisappearance
// (Event, Public, BlueprintEvent)

void UUMGGenericPopup::OnPopupDisappearance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGGenericPopup", "OnPopupDisappearance");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.WorldRunawayMeshComponent.SetShouldRunAway
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    should                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWorldRunawayMeshComponent::SetShouldRunAway(bool should)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldRunawayMeshComponent", "SetShouldRunAway");

	Params::WorldRunawayMeshComponent_SetShouldRunAway Parms{};

	Parms.should = should;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.WorldRunawayMeshComponent.SetShouldRunAwayWithDelay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    should                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWorldRunawayMeshComponent::SetShouldRunAwayWithDelay(bool should, float Delay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldRunawayMeshComponent", "SetShouldRunAwayWithDelay");

	Params::WorldRunawayMeshComponent_SetShouldRunAwayWithDelay Parms{};

	Parms.should = should;
	Parms.Delay = Delay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.WorldRunawayMeshComponent.SetShouldRunAwayWithRandomDelay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    should                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   delayRange                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWorldRunawayMeshComponent::SetShouldRunAwayWithRandomDelay(bool should, float delayRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldRunawayMeshComponent", "SetShouldRunAwayWithRandomDelay");

	Params::WorldRunawayMeshComponent_SetShouldRunAwayWithRandomDelay Parms{};

	Parms.should = should;
	Parms.delayRange = delayRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.WorldRunawayMeshComponent.GetShouldRunAway
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWorldRunawayMeshComponent::GetShouldRunAway() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldRunawayMeshComponent", "GetShouldRunAway");

	Params::WorldRunawayMeshComponent_GetShouldRunAway Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGPopupButton.OnButtonClicked
// (Native, Public)

void UUMGPopupButton::OnButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGPopupButton", "OnButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGPopupButton.OnButtonPressed
// (Native, Public)

void UUMGPopupButton::OnButtonPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGPopupButton", "OnButtonPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGPopupButton.OnButtonReleased
// (Native, Public)

void UUMGPopupButton::OnButtonReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGPopupButton", "OnButtonReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LightingHelper.DBD_ModifyExposure
// (Final, Exec, Native, Private, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightingHelper::DBD_ModifyExposure(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightingHelper", "DBD_ModifyExposure");

	Params::LightingHelper_DBD_ModifyExposure Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LightingHelper.GetASMController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ULightingHelper::GetASMController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightingHelper", "GetASMController");

	Params::LightingHelper_GetASMController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.LightingHelper.GetInitialComponentState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             componentName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorComponent* ULightingHelper::GetInitialComponentState(class FName componentName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightingHelper", "GetInitialComponentState");

	Params::LightingHelper_GetInitialComponentState Parms{};

	Parms.componentName = componentName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.LightingHelper.GetSourceLevelLightingClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClass* ULightingHelper::GetSourceLevelLightingClass()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightingHelper", "GetSourceLevelLightingClass");

	Params::LightingHelper_GetSourceLevelLightingClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.LightingHelper.GetTextureCube
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             mapTheme                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureCube*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTextureCube* ULightingHelper::GetTextureCube(class FName mapTheme)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightingHelper", "GetTextureCube");

	Params::LightingHelper_GetTextureCube Parms{};

	Parms.mapTheme = mapTheme;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.LightingHelper.ToggleLightingChange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bActivateLightingChange                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ThemeName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightingHelper::ToggleLightingChange(bool bActivateLightingChange, class FName ThemeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightingHelper", "ToggleLightingChange");

	Params::LightingHelper_ToggleLightingChange Parms{};

	Parms.bActivateLightingChange = bActivateLightingChange;
	Parms.ThemeName = ThemeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LightingInterpolator.LerpHeightFog
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UExponentialHeightFogComponent*   Target                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UExponentialHeightFogComponent*A                                                      (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UExponentialHeightFogComponent*B                                                      (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   thresholdBeforeSwitchingtoB                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightingInterpolator::LerpHeightFog(class UExponentialHeightFogComponent* Target, const class UExponentialHeightFogComponent* A, const class UExponentialHeightFogComponent* B, float alpha, float thresholdBeforeSwitchingtoB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightingInterpolator", "LerpHeightFog");

	Params::LightingInterpolator_LerpHeightFog Parms{};

	Parms.Target = Target;
	Parms.A = A;
	Parms.B = B;
	Parms.alpha = alpha;
	Parms.thresholdBeforeSwitchingtoB = thresholdBeforeSwitchingtoB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LightingInterpolator.LerpLight
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULightComponent*                  Target                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULightComponent*                  A                                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULightComponent*                  B                                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightingInterpolator::LerpLight(class ULightComponent* Target, class ULightComponent* A, class ULightComponent* B, float alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightingInterpolator", "LerpLight");

	Params::LightingInterpolator_LerpLight Parms{};

	Parms.Target = Target;
	Parms.A = A;
	Parms.B = B;
	Parms.alpha = alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LightingInterpolator.LerpSkylight
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkyLightComponent*               Target                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkyLightComponent*               A                                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkyLightComponent*               B                                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightingInterpolator::LerpSkylight(class USkyLightComponent* Target, class USkyLightComponent* A, class USkyLightComponent* B, float alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightingInterpolator", "LerpSkylight");

	Params::LightingInterpolator_LerpSkylight Parms{};

	Parms.Target = Target;
	Parms.A = A;
	Parms.B = B;
	Parms.alpha = alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LimitAccumulationSpawnerStrategy.SetMaxOverlapping
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   maxOverlapping                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULimitAccumulationSpawnerStrategy::SetMaxOverlapping(int32 maxOverlapping)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LimitAccumulationSpawnerStrategy", "SetMaxOverlapping");

	Params::LimitAccumulationSpawnerStrategy_SetMaxOverlapping Parms{};

	Parms.maxOverlapping = maxOverlapping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LimitAccumulationSpawnerStrategy.SetRecycleDistancePercentage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   recycleDistancePercentage                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULimitAccumulationSpawnerStrategy::SetRecycleDistancePercentage(float recycleDistancePercentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LimitAccumulationSpawnerStrategy", "SetRecycleDistancePercentage");

	Params::LimitAccumulationSpawnerStrategy_SetRecycleDistancePercentage Parms{};

	Parms.recycleDistancePercentage = recycleDistancePercentage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LimitAccumulationSpawnerStrategy.SetRecycleThresholdPercentage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   recycleThresholdPercentage                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULimitAccumulationSpawnerStrategy::SetRecycleThresholdPercentage(float recycleThresholdPercentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LimitAccumulationSpawnerStrategy", "SetRecycleThresholdPercentage");

	Params::LimitAccumulationSpawnerStrategy_SetRecycleThresholdPercentage Parms{};

	Parms.recycleThresholdPercentage = recycleThresholdPercentage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LobbyLevel.OnAdditionalSubLevelsLoaded
// (Final, Native, Private)

void ALobbyLevel::OnAdditionalSubLevelsLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyLevel", "OnAdditionalSubLevelsLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LobbyLevel.OnAnimationPreviewCompleted
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UAnimationPreviewSubsystem*       Subsystem                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAnimationPreviewRequest&  Request                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    completedSuccessfully                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALobbyLevel::OnAnimationPreviewCompleted(class UAnimationPreviewSubsystem* Subsystem, const struct FAnimationPreviewRequest& Request, bool completedSuccessfully)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyLevel", "OnAnimationPreviewCompleted");

	Params::LobbyLevel_OnAnimationPreviewCompleted Parms{};

	Parms.Subsystem = Subsystem;
	Parms.Request = std::move(Request);
	Parms.completedSuccessfully = completedSuccessfully;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LobbyLevel.OnAnimationPreviewStarted
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UAnimationPreviewSubsystem*       Subsystem                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAnimationPreviewRequest&  Request                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ALobbyLevel::OnAnimationPreviewStarted(class UAnimationPreviewSubsystem* Subsystem, const struct FAnimationPreviewRequest& Request)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyLevel", "OnAnimationPreviewStarted");

	Params::LobbyLevel_OnAnimationPreviewStarted Parms{};

	Parms.Subsystem = Subsystem;
	Parms.Request = std::move(Request);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LobbyLevel.OnEventObjectivesSubLevelLoaded
// (Final, Native, Private)

void ALobbyLevel::OnEventObjectivesSubLevelLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyLevel", "OnEventObjectivesSubLevelLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LobbyLevel.OnLobbySubLevelLoaded
// (Final, Native, Private)

void ALobbyLevel::OnLobbySubLevelLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyLevel", "OnLobbySubLevelLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LobbyLevel.OnShopSubLevelLoaded
// (Final, Native, Private)

void ALobbyLevel::OnShopSubLevelLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyLevel", "OnShopSubLevelLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LobbyLevel.ReceiveAnimationPreviewCompleted
// (Event, Protected, BlueprintEvent)

void ALobbyLevel::ReceiveAnimationPreviewCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyLevel", "ReceiveAnimationPreviewCompleted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.LobbyLevel.ReceiveAnimationPreviewStarted
// (Event, Protected, BlueprintEvent)

void ALobbyLevel::ReceiveAnimationPreviewStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyLevel", "ReceiveAnimationPreviewStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.LocalPlayerTrackerComponent.TriggerOnLocallyObservedChanged
// (Final, Native, Public)

void ULocalPlayerTrackerComponent::TriggerOnLocallyObservedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalPlayerTrackerComponent", "TriggerOnLocallyObservedChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Searchable.Authority_SpawnObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACollectable*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACollectable* ASearchable::Authority_SpawnObject(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Searchable", "Authority_SpawnObject");

	Params::Searchable_Authority_SpawnObject Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Searchable.Cosmetic_OnBlockSearchable
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASearchable::Cosmetic_OnBlockSearchable(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Searchable", "Cosmetic_OnBlockSearchable");

	Params::Searchable_Cosmetic_OnBlockSearchable Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Searchable.Cosmetic_OnUnblockSearchable
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASearchable::Cosmetic_OnUnblockSearchable(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Searchable", "Cosmetic_OnUnblockSearchable");

	Params::Searchable_Cosmetic_OnUnblockSearchable Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Searchable.Multicast_SetHasBeenSearched
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    HasBeenSearched                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASearchable::Multicast_SetHasBeenSearched(bool HasBeenSearched)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Searchable", "Multicast_SetHasBeenSearched");

	Params::Searchable_Multicast_SetHasBeenSearched Parms{};

	Parms.HasBeenSearched = HasBeenSearched;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Searchable.OnLocallyObservedChanged
// (Final, Native, Private)

void ASearchable::OnLocallyObservedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Searchable", "OnLocallyObservedChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Searchable.OnRep_IsOpened
// (Final, Native, Private)

void ASearchable::OnRep_IsOpened()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Searchable", "OnRep_IsOpened");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Searchable.OnSearchableBlockChanged
// (Final, Native, Private)

void ASearchable::OnSearchableBlockChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Searchable", "OnSearchableBlockChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Searchable.SetHasBeenSearched
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    newHasBeenSearched                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASearchable::SetHasBeenSearched(bool newHasBeenSearched)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Searchable", "SetHasBeenSearched");

	Params::Searchable_SetHasBeenSearched Parms{};

	Parms.newHasBeenSearched = newHasBeenSearched;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Searchable.ContainsSpawnedItem
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASearchable::ContainsSpawnedItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Searchable", "ContainsSpawnedItem");

	Params::Searchable_ContainsSpawnedItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Searchable.GetInteractorPrimitiveComponent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* ASearchable::GetInteractorPrimitiveComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Searchable", "GetInteractorPrimitiveComponent");

	Params::Searchable_GetInteractorPrimitiveComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Searchable.HasBeenSearched
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASearchable::HasBeenSearched() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Searchable", "HasBeenSearched");

	Params::Searchable_HasBeenSearched Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Searchable.IsSearchableBlockedForPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASearchable::IsSearchableBlockedForPlayer(const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Searchable", "IsSearchableBlockedForPlayer");

	Params::Searchable_IsSearchableBlockedForPlayer Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.LocalPlayerUtilities.GetFirstLocalValidHumanPlayerState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayerState*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayerState* ULocalPlayerUtilities::GetFirstLocalValidHumanPlayerState(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LocalPlayerUtilities", "GetFirstLocalValidHumanPlayerState");

	Params::LocalPlayerUtilities_GetFirstLocalValidHumanPlayerState Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Locker.Authority_EnableOtherInteractors
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const class UInteractor*                usableInteractor                                       (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    usable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALocker::Authority_EnableOtherInteractors(const class UInteractor* usableInteractor, bool usable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "Authority_EnableOtherInteractors");

	Params::Locker_Authority_EnableOtherInteractors Parms{};

	Parms.usableInteractor = usableInteractor;
	Parms.usable = usable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Locker.Authority_ReportOpenLockerNoiseEventToAI
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              fastActivation                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALocker::Authority_ReportOpenLockerNoiseEventToAI(const bool fastActivation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "Authority_ReportOpenLockerNoiseEventToAI");

	Params::Locker_Authority_ReportOpenLockerNoiseEventToAI Parms{};

	Parms.fastActivation = fastActivation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Locker.EjectSurvivor
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ALocker::EjectSurvivor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "EjectSurvivor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Locker.GetExposerInteriorZone
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UExposerInteriorZoneComponent*    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UExposerInteriorZoneComponent* ALocker::GetExposerInteriorZone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "GetExposerInteriorZone");

	Params::Locker_GetExposerInteriorZone Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Locker.GetPlayerInLockerLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ALocker::GetPlayerInLockerLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "GetPlayerInLockerLocation");

	Params::Locker_GetPlayerInLockerLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Locker.OnRep_PlayerInLocker
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       previousPlayerInLocker                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALocker::OnRep_PlayerInLocker(class ADBDPlayer* previousPlayerInLocker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "OnRep_PlayerInLocker");

	Params::Locker_OnRep_PlayerInLocker Parms{};

	Parms.previousPlayerInLocker = previousPlayerInLocker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Locker.OnRep_PlayerOpeningLocker
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       playerWhoWasOpeningLocker                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALocker::OnRep_PlayerOpeningLocker(class ADBDPlayer* playerWhoWasOpeningLocker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "OnRep_PlayerOpeningLocker");

	Params::Locker_OnRep_PlayerOpeningLocker Parms{};

	Parms.playerWhoWasOpeningLocker = playerWhoWasOpeningLocker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Locker.OnRep_PreventAllInteractions
// (Final, Native, Private)

void ALocker::OnRep_PreventAllInteractions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "OnRep_PreventAllInteractions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Locker.StartMinNearOutlineDistLerp
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALocker::StartMinNearOutlineDistLerp(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "StartMinNearOutlineDistLerp");

	Params::Locker_StartMinNearOutlineDistLerp Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Locker.StopMinNearOutlineDistLerp
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALocker::StopMinNearOutlineDistLerp(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "StopMinNearOutlineDistLerp");

	Params::Locker_StopMinNearOutlineDistLerp Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Locker.GetChildInteractionActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ALocker::GetChildInteractionActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "GetChildInteractionActor");

	Params::Locker_GetChildInteractionActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Locker.GetInteractor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractor*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractor* ALocker::GetInteractor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "GetInteractor");

	Params::Locker_GetInteractor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Locker.GetLockerHideEnterSneakInteraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractionDefinition*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionDefinition* ALocker::GetLockerHideEnterSneakInteraction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "GetLockerHideEnterSneakInteraction");

	Params::Locker_GetLockerHideEnterSneakInteraction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Locker.GetMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ALocker::GetMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "GetMesh");

	Params::Locker_GetMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Locker.GetPlayerInLocker
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* ALocker::GetPlayerInLocker() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "GetPlayerInLocker");

	Params::Locker_GetPlayerInLocker Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Locker.GetStunZone
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class UPrimitiveComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* ALocker::GetStunZone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "GetStunZone");

	Params::Locker_GetStunZone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Locker.GetSurvivorInLocker
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASurvivor*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASurvivor* ALocker::GetSurvivorInLocker() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "GetSurvivorInLocker");

	Params::Locker_GetSurvivorInLocker Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Locker.IsFacingLocker
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   toleranceDegreeAngle                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALocker::IsFacingLocker(const class ADBDPlayer* Player, float toleranceDegreeAngle) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "IsFacingLocker");

	Params::Locker_IsFacingLocker Parms{};

	Parms.Player = Player;
	Parms.toleranceDegreeAngle = toleranceDegreeAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Locker.IsOccupied
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALocker::IsOccupied() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "IsOccupied");

	Params::Locker_IsOccupied Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Locker.SetPlayerInLockerVisibility
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// const bool                              IsVisible                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALocker::SetPlayerInLockerVisibility(const bool IsVisible) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "SetPlayerInLockerVisibility");

	Params::Locker_SetPlayerInLockerVisibility Parms{};

	Parms.IsVisible = IsVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LockerOutlineUpdateStrategy.GetRedColor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor ULockerOutlineUpdateStrategy::GetRedColor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LockerOutlineUpdateStrategy", "GetRedColor");

	Params::LockerOutlineUpdateStrategy_GetRedColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.LoudNoiseHUDIndicator.AddTrackedNoise
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULoudNoiseHUDIndicator::AddTrackedNoise(const struct FVector& Location, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoudNoiseHUDIndicator", "AddTrackedNoise");

	Params::LoudNoiseHUDIndicator_AddTrackedNoise Parms{};

	Parms.Location = std::move(Location);
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LunarEventComponent.Authority_OnCamperEscape
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULunarEventComponent::Authority_OnCamperEscape(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LunarEventComponent", "Authority_OnCamperEscape");

	Params::LunarEventComponent_Authority_OnCamperEscape Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LunarEventComponent.Authority_OnCamperLostLantern
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULunarEventComponent::Authority_OnCamperLostLantern(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LunarEventComponent", "Authority_OnCamperLostLantern");

	Params::LunarEventComponent_Authority_OnCamperLostLantern Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LunarEventComponent.Authority_OnDestroyCamperLightGameEvent
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULunarEventComponent::Authority_OnDestroyCamperLightGameEvent(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LunarEventComponent", "Authority_OnDestroyCamperLightGameEvent");

	Params::LunarEventComponent_Authority_OnDestroyCamperLightGameEvent Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LunarEventComponent.Authority_OnFixGenerator
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULunarEventComponent::Authority_OnFixGenerator(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LunarEventComponent", "Authority_OnFixGenerator");

	Params::LunarEventComponent_Authority_OnFixGenerator Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LunarEventComponent.Authority_OnPickupLantern
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULunarEventComponent::Authority_OnPickupLantern(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LunarEventComponent", "Authority_OnPickupLantern");

	Params::LunarEventComponent_Authority_OnPickupLantern Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LunarEventComponent.Authority_OnPlayerLeaveGame
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULunarEventComponent::Authority_OnPlayerLeaveGame(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LunarEventComponent", "Authority_OnPlayerLeaveGame");

	Params::LunarEventComponent_Authority_OnPlayerLeaveGame Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LunarEventComponent.Authority_OnSlasherDestroysLantern
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULunarEventComponent::Authority_OnSlasherDestroysLantern(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LunarEventComponent", "Authority_OnSlasherDestroysLantern");

	Params::LunarEventComponent_Authority_OnSlasherDestroysLantern Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LunarEventComponent.Local_OnCamperEscape
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULunarEventComponent::Local_OnCamperEscape(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LunarEventComponent", "Local_OnCamperEscape");

	Params::LunarEventComponent_Local_OnCamperEscape Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LunarEventComponent.Local_OnCamperLostLantern
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULunarEventComponent::Local_OnCamperLostLantern(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LunarEventComponent", "Local_OnCamperLostLantern");

	Params::LunarEventComponent_Local_OnCamperLostLantern Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LunarEventComponent.Multicast_ResetLanternLight
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ALanternInteractable*             LanternInteractable                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULunarEventComponent::Multicast_ResetLanternLight(class ALanternInteractable* LanternInteractable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LunarEventComponent", "Multicast_ResetLanternLight");

	Params::LunarEventComponent_Multicast_ResetLanternLight Parms{};

	Parms.LanternInteractable = LanternInteractable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LunarEventComponent.OnFinishedPlaying
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULunarEventComponent::OnFinishedPlaying(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LunarEventComponent", "OnFinishedPlaying");

	Params::LunarEventComponent_OnFinishedPlaying Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LunarEventComponent.OnLanternHoldTimerEnd
// (Final, Native, Private)

void ULunarEventComponent::OnLanternHoldTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LunarEventComponent", "OnLanternHoldTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LunarEventComponent.OnRep_lanternCollectedCount
// (Final, Native, Private)

void ULunarEventComponent::OnRep_lanternCollectedCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LunarEventComponent", "OnRep_lanternCollectedCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SkillCollectionComponent.OnRep_Array
// (Final, Native, Private, HasOutParams)
// Parameters:
// const TArray<class USkill*>&            oldArray                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void USkillCollectionComponent::OnRep_Array(const TArray<class USkill*>& oldArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillCollectionComponent", "OnRep_Array");

	Params::SkillCollectionComponent_OnRep_Array Parms{};

	Parms.oldArray = std::move(oldArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MagicFountain.Authority_SetCorrupted
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    corrupted                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       interactingPlayer                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMagicFountain::Authority_SetCorrupted(bool corrupted, class ADBDPlayer* interactingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MagicFountain", "Authority_SetCorrupted");

	Params::MagicFountain_Authority_SetCorrupted Parms{};

	Parms.corrupted = corrupted;
	Parms.interactingPlayer = interactingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MagicFountain.IsCorrupted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMagicFountain::IsCorrupted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MagicFountain", "IsCorrupted");

	Params::MagicFountain_IsCorrupted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MapActorComponent.Multicast_SetDetectionEnabled
// (BlueprintAuthorityOnly, Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapActorComponent::Multicast_SetDetectionEnabled(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapActorComponent", "Multicast_SetDetectionEnabled");

	Params::MapActorComponent_Multicast_SetDetectionEnabled Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MapActorComponent.GetDetectionEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMapActorComponent::GetDetectionEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapActorComponent", "GetDetectionEnabled");

	Params::MapActorComponent_GetDetectionEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MapActorComponent.IsKnownBy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Character                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMapActorComponent::IsKnownBy(const class ADBDPlayer* Character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapActorComponent", "IsKnownBy");

	Params::MapActorComponent_IsKnownBy Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TriplanarDecalComponent.UpdateTriplanarDecal
// (Event, Public, BlueprintEvent)

void UTriplanarDecalComponent::UpdateTriplanarDecal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriplanarDecalComponent", "UpdateTriplanarDecal");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.MapActorDB.CopyListMinusCategories
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<EMapActorCategory>&        Categories                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<EMapActorCategory>&        categoriesToRemove                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<EMapActorCategory>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<EMapActorCategory> UMapActorDB::CopyListMinusCategories(const TArray<EMapActorCategory>& Categories, const TArray<EMapActorCategory>& categoriesToRemove) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapActorDB", "CopyListMinusCategories");

	Params::MapActorDB_CopyListMinusCategories Parms{};

	Parms.Categories = std::move(Categories);
	Parms.categoriesToRemove = std::move(categoriesToRemove);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MapActorDB.GetRandom
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMapActorCategory                       category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UMapActorDB::GetRandom(EMapActorCategory category) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapActorDB", "GetRandom");

	Params::MapActorDB_GetRandom Parms{};

	Parms.category = category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MapActorDB.GetUniqueRandom
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<EMapActorCategory>&        Categories                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UMapActorDB::GetUniqueRandom(const TArray<EMapActorCategory>& Categories, int32 Count) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapActorDB", "GetUniqueRandom");

	Params::MapActorDB_GetUniqueRandom Parms{};

	Parms.Categories = std::move(Categories);
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MapActorDetectorComponent.OnOverlapEnter
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMapActorDetectorComponent::OnOverlapEnter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapActorDetectorComponent", "OnOverlapEnter");

	Params::MapActorDetectorComponent_OnOverlapEnter Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MapActorDetectorComponent.SetDetectionPrimitive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Primitive                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapActorDetectorComponent::SetDetectionPrimitive(class UPrimitiveComponent* Primitive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapActorDetectorComponent", "SetDetectionPrimitive");

	Params::MapActorDetectorComponent_SetDetectionPrimitive Parms{};

	Parms.Primitive = Primitive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialFunctionLibrary.GetTutorialGameMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATutorialGameMode*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATutorialGameMode* UTutorialFunctionLibrary::GetTutorialGameMode(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TutorialFunctionLibrary", "GetTutorialGameMode");

	Params::TutorialFunctionLibrary_GetTutorialGameMode Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TutorialFunctionLibrary.GetTutorialGameState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATutorialGameState*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATutorialGameState* UTutorialFunctionLibrary::GetTutorialGameState(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TutorialFunctionLibrary", "GetTutorialGameState");

	Params::TutorialFunctionLibrary_GetTutorialGameState Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TutorialFunctionLibrary.GetTutorialHighlightController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTutorialHighlightController*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTutorialHighlightController* UTutorialFunctionLibrary::GetTutorialHighlightController(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TutorialFunctionLibrary", "GetTutorialHighlightController");

	Params::TutorialFunctionLibrary_GetTutorialHighlightController Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TutorialFunctionLibrary.GetTutorialNotificationController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTutorialNotificationController*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTutorialNotificationController* UTutorialFunctionLibrary::GetTutorialNotificationController(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TutorialFunctionLibrary", "GetTutorialNotificationController");

	Params::TutorialFunctionLibrary_GetTutorialNotificationController Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TutorialFunctionLibrary.GetTutorialObjectiveController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTutorialObjectiveController*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTutorialObjectiveController* UTutorialFunctionLibrary::GetTutorialObjectiveController(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TutorialFunctionLibrary", "GetTutorialObjectiveController");

	Params::TutorialFunctionLibrary_GetTutorialObjectiveController Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TutorialFunctionLibrary.IsInTutorial
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTutorialFunctionLibrary::IsInTutorial(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TutorialFunctionLibrary", "IsInTutorial");

	Params::TutorialFunctionLibrary_IsInTutorial Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MapSpecificSpawnActorsComponent.Authority_OnLevelReadyToPlay
// (Final, Native, Private)

void UMapSpecificSpawnActorsComponent::Authority_OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapSpecificSpawnActorsComponent", "Authority_OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialLevel.AddObjective
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ObjectiveId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialLevel::AddObjective(class FName ObjectiveId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialLevel", "AddObjective");

	Params::TutorialLevel_AddObjective Parms{};

	Parms.ObjectiveId = ObjectiveId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialLevel.CompleteObjective
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ObjectiveId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialLevel::CompleteObjective(class FName ObjectiveId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialLevel", "CompleteObjective");

	Params::TutorialLevel_CompleteObjective Parms{};

	Parms.ObjectiveId = ObjectiveId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialLevel.DisplayBlockingNotification
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             notificationId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialLevel::DisplayBlockingNotification(class FName notificationId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialLevel", "DisplayBlockingNotification");

	Params::TutorialLevel_DisplayBlockingNotification Parms{};

	Parms.notificationId = notificationId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialLevel.DisplayNotification
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             notificationId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialLevel::DisplayNotification(class FName notificationId, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialLevel", "DisplayNotification");

	Params::TutorialLevel_DisplayNotification Parms{};

	Parms.notificationId = notificationId;
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialLevel.HandleNotificationDismissed
// (Event, Protected, BlueprintEvent)
// Parameters:
// class FName                             notificationId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialLevel::HandleNotificationDismissed(class FName notificationId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialLevel", "HandleNotificationDismissed");

	Params::TutorialLevel_HandleNotificationDismissed Parms{};

	Parms.notificationId = notificationId;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.TutorialLevel.HandleTutorialStepReached
// (Event, Protected, BlueprintEvent)

void ATutorialLevel::HandleTutorialStepReached()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialLevel", "HandleTutorialStepReached");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.TutorialLevel.OnNotificationDismissed
// (Final, Native, Protected)
// Parameters:
// class FName                             notificationId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialLevel::OnNotificationDismissed(class FName notificationId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialLevel", "OnNotificationDismissed");

	Params::TutorialLevel_OnNotificationDismissed Parms{};

	Parms.notificationId = notificationId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialLevel.OnTutorialStepUpdated
// (Final, Native, Protected)
// Parameters:
// ETutorialStep                           tutorialStep                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialLevel::OnTutorialStepUpdated(ETutorialStep tutorialStep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialLevel", "OnTutorialStepUpdated");

	Params::TutorialLevel_OnTutorialStepUpdated Parms{};

	Parms.tutorialStep = tutorialStep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialLevel.RemoveObjective
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ObjectiveId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialLevel::RemoveObjective(class FName ObjectiveId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialLevel", "RemoveObjective");

	Params::TutorialLevel_RemoveObjective Parms{};

	Parms.ObjectiveId = ObjectiveId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialLevel.SetHandledTutorialStep
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETutorialStep                           tutorialStep                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialLevel::SetHandledTutorialStep(ETutorialStep tutorialStep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialLevel", "SetHandledTutorialStep");

	Params::TutorialLevel_SetHandledTutorialStep Parms{};

	Parms.tutorialStep = tutorialStep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialLevel.StartTutorial
// (Native, Public, BlueprintCallable)

void ATutorialLevel::StartTutorial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialLevel", "StartTutorial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MatchManagementScreen.OnAddMap
// (Final, Native, Private)
// Parameters:
// const class FString&                    MapId                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchManagementScreen::OnAddMap(const class FString& MapId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchManagementScreen", "OnAddMap");

	Params::MatchManagementScreen_OnAddMap Parms{};

	Parms.MapId = std::move(MapId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MatchManagementScreen.OnAllowDlcSettingsClick
// (Final, Native, Private)

void UMatchManagementScreen::OnAllowDlcSettingsClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchManagementScreen", "OnAllowDlcSettingsClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MatchManagementScreen.OnAllowIdleCrowsSettingsClick
// (Final, Native, Private)

void UMatchManagementScreen::OnAllowIdleCrowsSettingsClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchManagementScreen", "OnAllowIdleCrowsSettingsClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MatchManagementScreen.OnApplyChangesClicked
// (Final, Native, Private)

void UMatchManagementScreen::OnApplyChangesClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchManagementScreen", "OnApplyChangesClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MatchManagementScreen.OnBackButtonClick
// (Final, Native, Private)

void UMatchManagementScreen::OnBackButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchManagementScreen", "OnBackButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MatchManagementScreen.OnItemsAndAddonsSettingsChange
// (Final, Native, Private)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchManagementScreen::OnItemsAndAddonsSettingsChange(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchManagementScreen", "OnItemsAndAddonsSettingsChange");

	Params::MatchManagementScreen_OnItemsAndAddonsSettingsChange Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MatchManagementScreen.OnOfferingsSettingsChange
// (Final, Native, Private)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchManagementScreen::OnOfferingsSettingsChange(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchManagementScreen", "OnOfferingsSettingsChange");

	Params::MatchManagementScreen_OnOfferingsSettingsChange Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MatchManagementScreen.OnPerksSettingsChange
// (Final, Native, Private)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchManagementScreen::OnPerksSettingsChange(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchManagementScreen", "OnPerksSettingsChange");

	Params::MatchManagementScreen_OnPerksSettingsChange Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MatchManagementScreen.OnRemoveMap
// (Final, Native, Private)
// Parameters:
// const class FString&                    MapId                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchManagementScreen::OnRemoveMap(const class FString& MapId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchManagementScreen", "OnRemoveMap");

	Params::MatchManagementScreen_OnRemoveMap Parms{};

	Parms.MapId = std::move(MapId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.Authority_SetHookedSurvivor
// (Native, Public, BlueprintCallable)
// Parameters:
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::Authority_SetHookedSurvivor(class ASurvivor* Survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Authority_SetHookedSurvivor");

	Params::MeatHook_Authority_SetHookedSurvivor Parms{};

	Parms.Survivor = Survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.Authority_SetIsBrokenFromUnhook
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isBrokenFromUnhook                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       hookBreaker                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   overrideBaseHookRespawnDuration                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::Authority_SetIsBrokenFromUnhook(bool isBrokenFromUnhook, class ADBDPlayer* hookBreaker, float overrideBaseHookRespawnDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Authority_SetIsBrokenFromUnhook");

	Params::MeatHook_Authority_SetIsBrokenFromUnhook Parms{};

	Parms.isBrokenFromUnhook = isBrokenFromUnhook;
	Parms.hookBreaker = hookBreaker;
	Parms.overrideBaseHookRespawnDuration = overrideBaseHookRespawnDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.Authority_SetIsSabotaged
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isSabotaged                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       Saboteur                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    useCamperHookRespawnDurationModifiers                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   overrideBaseHookRespawnDuration                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::Authority_SetIsSabotaged(bool isSabotaged, class ADBDPlayer* Saboteur, bool useCamperHookRespawnDurationModifiers, float overrideBaseHookRespawnDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Authority_SetIsSabotaged");

	Params::MeatHook_Authority_SetIsSabotaged Parms{};

	Parms.isSabotaged = isSabotaged;
	Parms.Saboteur = Saboteur;
	Parms.useCamperHookRespawnDurationModifiers = useCamperHookRespawnDurationModifiers;
	Parms.overrideBaseHookRespawnDuration = overrideBaseHookRespawnDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.Authority_SetIsSacrificed
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isSacrificed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::Authority_SetIsSacrificed(bool isSacrificed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Authority_SetIsSacrificed");

	Params::MeatHook_Authority_SetIsSacrificed Parms{};

	Parms.isSacrificed = isSacrificed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.Authority_SignalSurvivorAttemptingEscape
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void AMeatHook::Authority_SignalSurvivorAttemptingEscape()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Authority_SignalSurvivorAttemptingEscape");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.Authority_SignalSurvivorAttemptingEscapeAborted
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void AMeatHook::Authority_SignalSurvivorAttemptingEscapeAborted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Authority_SignalSurvivorAttemptingEscapeAborted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.Authority_SignalUnhookingAborted
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void AMeatHook::Authority_SignalUnhookingAborted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Authority_SignalUnhookingAborted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.Authority_SignalUnhookingCharged
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void AMeatHook::Authority_SignalUnhookingCharged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Authority_SignalUnhookingCharged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.Authority_SignalUnhookingEnter
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void AMeatHook::Authority_SignalUnhookingEnter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Authority_SignalUnhookingEnter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.BP_OnHookInteractionStarted
// (Event, Protected, BlueprintEvent)

void AMeatHook::BP_OnHookInteractionStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "BP_OnHookInteractionStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.MeatHook.BroadcastUnhook
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       rescuer                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::BroadcastUnhook(class ADBDPlayer* rescuer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "BroadcastUnhook");

	Params::MeatHook_BroadcastUnhook Parms{};

	Parms.rescuer = rescuer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.Cosmetic_StartScourgeHookVFX
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    isNewScourgeHook                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::Cosmetic_StartScourgeHookVFX(bool isNewScourgeHook)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Cosmetic_StartScourgeHookVFX");

	Params::MeatHook_Cosmetic_StartScourgeHookVFX Parms{};

	Parms.isNewScourgeHook = isNewScourgeHook;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.MeatHook.Cosmetic_StopScourgeHookVFX
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void AMeatHook::Cosmetic_StopScourgeHookVFX()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Cosmetic_StopScourgeHookVFX");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.MeatHook.GetUnhookChargeableComponent
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UChargeableComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChargeableComponent* AMeatHook::GetUnhookChargeableComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetUnhookChargeableComponent");

	Params::MeatHook_GetUnhookChargeableComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.Local_MoveSurvivorToHook
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Duration                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::Local_MoveSurvivorToHook(class ASurvivor* Survivor, const float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Local_MoveSurvivorToHook");

	Params::MeatHook_Local_MoveSurvivorToHook Parms{};

	Parms.Survivor = Survivor;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.Multicast_EscapeAttemptResult
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::Multicast_EscapeAttemptResult(class ADBDPlayer* Player, bool Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Multicast_EscapeAttemptResult");

	Params::MeatHook_Multicast_EscapeAttemptResult Parms{};

	Parms.Player = Player;
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.Multicast_RefreshCharmCustomization
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void AMeatHook::Multicast_RefreshCharmCustomization()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Multicast_RefreshCharmCustomization");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.Multicast_SetHookedSurvivor
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::Multicast_SetHookedSurvivor(class ASurvivor* Survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Multicast_SetHookedSurvivor");

	Params::MeatHook_Multicast_SetHookedSurvivor Parms{};

	Parms.Survivor = Survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.Multicast_SetIsBrokenFromUnhook
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// bool                                    setIsBrokendFromUnhook                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       hookBreaker                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   overrideBaseHookRespawnDuration                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::Multicast_SetIsBrokenFromUnhook(bool setIsBrokendFromUnhook, class ADBDPlayer* hookBreaker, float overrideBaseHookRespawnDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Multicast_SetIsBrokenFromUnhook");

	Params::MeatHook_Multicast_SetIsBrokenFromUnhook Parms{};

	Parms.setIsBrokendFromUnhook = setIsBrokendFromUnhook;
	Parms.hookBreaker = hookBreaker;
	Parms.overrideBaseHookRespawnDuration = overrideBaseHookRespawnDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.Multicast_SetIsSabotaged
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// bool                                    setIsSabotaged                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       hookBreaker                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    useCamperHookRespawnDurationModifiers                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   overrideBaseHookRespawnDuration                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::Multicast_SetIsSabotaged(bool setIsSabotaged, class ADBDPlayer* hookBreaker, bool useCamperHookRespawnDurationModifiers, float overrideBaseHookRespawnDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Multicast_SetIsSabotaged");

	Params::MeatHook_Multicast_SetIsSabotaged Parms{};

	Parms.setIsSabotaged = setIsSabotaged;
	Parms.hookBreaker = hookBreaker;
	Parms.useCamperHookRespawnDurationModifiers = useCamperHookRespawnDurationModifiers;
	Parms.overrideBaseHookRespawnDuration = overrideBaseHookRespawnDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.Multicast_SetIsSacrificed
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// bool                                    isSacrificed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::Multicast_SetIsSacrificed(bool isSacrificed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Multicast_SetIsSacrificed");

	Params::MeatHook_Multicast_SetIsSacrificed Parms{};

	Parms.isSacrificed = isSacrificed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.OnAutoRepair
// (Event, Protected, BlueprintEvent)

void AMeatHook::OnAutoRepair()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnAutoRepair");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.MeatHook.OnHookedEnter
// (Event, Protected, BlueprintEvent)

void AMeatHook::OnHookedEnter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnHookedEnter");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.MeatHook.OnHookedExit
// (Event, Protected, BlueprintEvent)

void AMeatHook::OnHookedExit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnHookedExit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.MeatHook.OnHookedIdle
// (Event, Protected, BlueprintEvent)

void AMeatHook::OnHookedIdle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnHookedIdle");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.MeatHook.OnHookedSurvivorAttacked
// (Final, Native, Protected)

void AMeatHook::OnHookedSurvivorAttacked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnHookedSurvivorAttacked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.OnHookedSurvivorChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ASurvivor*                        before                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASurvivor*                        after                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::OnHookedSurvivorChanged(class ASurvivor* before, class ASurvivor* after)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnHookedSurvivorChanged");

	Params::MeatHook_OnHookedSurvivorChanged Parms{};

	Parms.before = before;
	Parms.after = after;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.MeatHook.OnHookingEnter
// (Event, Protected, BlueprintEvent)

void AMeatHook::OnHookingEnter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnHookingEnter");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.MeatHook.OnHookingExit
// (Event, Protected, BlueprintEvent)

void AMeatHook::OnHookingExit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnHookingExit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.MeatHook.OnOwnerReplicated
// (Event, Protected, BlueprintEvent)

void AMeatHook::OnOwnerReplicated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnOwnerReplicated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.MeatHook.OnReaction
// (Event, Protected, BlueprintEvent)

void AMeatHook::OnReaction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnReaction");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.MeatHook.OnReactionIn
// (Event, Protected, BlueprintEvent)

void AMeatHook::OnReactionIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnReactionIn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.MeatHook.OnSacrificeIn
// (Event, Protected, BlueprintEvent)

void AMeatHook::OnSacrificeIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnSacrificeIn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.MeatHook.OnSacrificeOut
// (Event, Protected, BlueprintEvent)

void AMeatHook::OnSacrificeOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnSacrificeOut");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.MeatHook.OnStartPushingPlayer
// (Final, Native, Private)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::OnStartPushingPlayer(class ACharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnStartPushingPlayer");

	Params::MeatHook_OnStartPushingPlayer Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.OnStopPushingPlayer
// (Final, Native, Private)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::OnStopPushingPlayer(class ACharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnStopPushingPlayer");

	Params::MeatHook_OnStopPushingPlayer Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.OnStruggleEnter
// (Event, Protected, BlueprintEvent)

void AMeatHook::OnStruggleEnter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnStruggleEnter");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.MeatHook.OnStruggleExit
// (Event, Protected, BlueprintEvent)

void AMeatHook::OnStruggleExit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnStruggleExit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.MeatHook.OnStruggleSkillCheckFailed_Cosmetic
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void AMeatHook::OnStruggleSkillCheckFailed_Cosmetic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnStruggleSkillCheckFailed_Cosmetic");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.MeatHook.OnTickStruggle
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::OnTickStruggle(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnTickStruggle");

	Params::MeatHook_OnTickStruggle Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.MeatHook.SetEntity
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AEntity*                          Entity                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::SetEntity(class AEntity* Entity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "SetEntity");

	Params::MeatHook_SetEntity Parms{};

	Parms.Entity = Entity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.SetInteractingPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       interactingPlayer                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::SetInteractingPlayer(class ADBDPlayer* interactingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "SetInteractingPlayer");

	Params::MeatHook_SetInteractingPlayer Parms{};

	Parms.interactingPlayer = interactingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.SetIsBeingSabotaged
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isBeingSabotaged                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::SetIsBeingSabotaged(bool isBeingSabotaged)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "SetIsBeingSabotaged");

	Params::MeatHook_SetIsBeingSabotaged Parms{};

	Parms.isBeingSabotaged = isBeingSabotaged;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.SetMapActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMapActorComponent*               Value                                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::SetMapActor(class UMapActorComponent* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "SetMapActor");

	Params::MeatHook_SetMapActor Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.UpdateSlasherBlockerCollision
// (Final, Native, Protected, BlueprintCallable)

void AMeatHook::UpdateSlasherBlockerCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "UpdateSlasherBlockerCollision");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.CanBeSabotaged
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMeatHook::CanBeSabotaged() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "CanBeSabotaged");

	Params::MeatHook_CanBeSabotaged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.CanHookSurvivor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMeatHook::CanHookSurvivor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "CanHookSurvivor");

	Params::MeatHook_CanHookSurvivor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.CanSurvivorAttemptEscape
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ASurvivor*                  Survivor                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMeatHook::CanSurvivorAttemptEscape(const class ASurvivor* Survivor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "CanSurvivorAttemptEscape");

	Params::MeatHook_CanSurvivorAttemptEscape Parms{};

	Parms.Survivor = Survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.CanSurvivorStruggle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMeatHook::CanSurvivorStruggle(class ASurvivor* Survivor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "CanSurvivorStruggle");

	Params::MeatHook_CanSurvivorStruggle Parms{};

	Parms.Survivor = Survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.CanUnhookSurvivor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ASurvivor*                  Survivor                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMeatHook::CanUnhookSurvivor(const class ASurvivor* Survivor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "CanUnhookSurvivor");

	Params::MeatHook_CanUnhookSurvivor Parms{};

	Parms.Survivor = Survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.DebugHookedSurvivor
// (Final, Native, Public, Const)
// Parameters:
// class ASurvivor*                        expectedSurvivor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::DebugHookedSurvivor(class ASurvivor* expectedSurvivor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "DebugHookedSurvivor");

	Params::MeatHook_DebugHookedSurvivor Parms{};

	Parms.expectedSurvivor = expectedSurvivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.FireHookSoundEvent
// (Event, Public, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// const class FName                       NoiseRangeTunable                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ADBDPlayer*                 soundInstigator                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::FireHookSoundEvent(const class FName NoiseRangeTunable, const class ADBDPlayer* soundInstigator) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "FireHookSoundEvent");

	Params::MeatHook_FireHookSoundEvent Parms{};

	Parms.NoiseRangeTunable = NoiseRangeTunable;
	Parms.soundInstigator = soundInstigator;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.MeatHook.GetCamperHookedSnapTransform
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* AMeatHook::GetCamperHookedSnapTransform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetCamperHookedSnapTransform");

	Params::MeatHook_GetCamperHookedSnapTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetCamperUnkookFocalPointTransform
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* AMeatHook::GetCamperUnkookFocalPointTransform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetCamperUnkookFocalPointTransform");

	Params::MeatHook_GetCamperUnkookFocalPointTransform Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetCharacterPusher
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCharacterPusherComponent*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCharacterPusherComponent* AMeatHook::GetCharacterPusher() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetCharacterPusher");

	Params::MeatHook_GetCharacterPusher Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetEscapeHookInteraction
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class UChargeableInteractionDefinition* ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChargeableInteractionDefinition* AMeatHook::GetEscapeHookInteraction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetEscapeHookInteraction");

	Params::MeatHook_GetEscapeHookInteraction Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetHookableComponentOfHookedActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UHookableComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UHookableComponent* AMeatHook::GetHookableComponentOfHookedActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetHookableComponentOfHookedActor");

	Params::MeatHook_GetHookableComponentOfHookedActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetHookedSurvivor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASurvivor*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASurvivor* AMeatHook::GetHookedSurvivor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetHookedSurvivor");

	Params::MeatHook_GetHookedSurvivor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetHookObstacleZoneComponent
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// class UShapeComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UShapeComponent* AMeatHook::GetHookObstacleZoneComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetHookObstacleZoneComponent");

	Params::MeatHook_GetHookObstacleZoneComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetHookPosition
// (Event, Protected, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AMeatHook::GetHookPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetHookPosition");

	Params::MeatHook_GetHookPosition Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetInteractingPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* AMeatHook::GetInteractingPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetInteractingPlayer");

	Params::MeatHook_GetInteractingPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetInteractorPrimitiveComponent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* AMeatHook::GetInteractorPrimitiveComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetInteractorPrimitiveComponent");

	Params::MeatHook_GetInteractorPrimitiveComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetInteractorZoneComponent
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UBoxComponent*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBoxComponent* AMeatHook::GetInteractorZoneComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetInteractorZoneComponent");

	Params::MeatHook_GetInteractorZoneComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetIsBroken
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMeatHook::GetIsBroken() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetIsBroken");

	Params::MeatHook_GetIsBroken Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetIsInBasement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMeatHook::GetIsInBasement() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetIsInBasement");

	Params::MeatHook_GetIsInBasement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetIsSabotaged
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMeatHook::GetIsSabotaged() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetIsSabotaged");

	Params::MeatHook_GetIsSabotaged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetIsSacrificed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMeatHook::GetIsSacrificed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetIsSacrificed");

	Params::MeatHook_GetIsSacrificed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetMainInteractor
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UInteractor*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractor* AMeatHook::GetMainInteractor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetMainInteractor");

	Params::MeatHook_GetMainInteractor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetMeatHookAkAudioComponent
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UAkComponent*                     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAkComponent* AMeatHook::GetMeatHookAkAudioComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetMeatHookAkAudioComponent");

	Params::MeatHook_GetMeatHookAkAudioComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetMontagePlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMontagePlayer*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMontagePlayer* AMeatHook::GetMontagePlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetMontagePlayer");

	Params::MeatHook_GetMontagePlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetSabotageHookRespawnDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMeatHook::GetSabotageHookRespawnDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetSabotageHookRespawnDuration");

	Params::MeatHook_GetSabotageHookRespawnDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetSaboteurPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* AMeatHook::GetSaboteurPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetSaboteurPlayer");

	Params::MeatHook_GetSaboteurPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetSnapPointsArray
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// TArray<class USceneComponent*>          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class USceneComponent*> AMeatHook::GetSnapPointsArray() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetSnapPointsArray");

	Params::MeatHook_GetSnapPointsArray Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetStrugglePercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMeatHook::GetStrugglePercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetStrugglePercent");

	Params::MeatHook_GetStrugglePercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetStruggleThreshold
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMeatHook::GetStruggleThreshold() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetStruggleThreshold");

	Params::MeatHook_GetStruggleThreshold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetUnhookInMontageDescriptor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FAnimationMontageDescriptor      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAnimationMontageDescriptor AMeatHook::GetUnhookInMontageDescriptor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetUnhookInMontageDescriptor");

	Params::MeatHook_GetUnhookInMontageDescriptor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetUnhookInteraction
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UChargeableInteractionDefinition* ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChargeableInteractionDefinition* AMeatHook::GetUnhookInteraction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetUnhookInteraction");

	Params::MeatHook_GetUnhookInteraction Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetUnhookOutMontageDescriptor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FAnimationMontageDescriptor      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAnimationMontageDescriptor AMeatHook::GetUnhookOutMontageDescriptor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetUnhookOutMontageDescriptor");

	Params::MeatHook_GetUnhookOutMontageDescriptor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlagueUtilities.Authority_AddSicknessToPlayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   sicknessToAdd                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlagueUtilities::Authority_AddSicknessToPlayer(class ADBDPlayer* Player, float sicknessToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlagueUtilities", "Authority_AddSicknessToPlayer");

	Params::PlagueUtilities_Authority_AddSicknessToPlayer Parms{};

	Parms.Player = Player;
	Parms.sicknessToAdd = sicknessToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlagueUtilities.Authority_CorruptRandomFountain
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlagueUtilities::Authority_CorruptRandomFountain(class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlagueUtilities", "Authority_CorruptRandomFountain");

	Params::PlagueUtilities_Authority_CorruptRandomFountain Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlagueUtilities.GetAllFountains
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AMagicFountain*>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AMagicFountain*> UPlagueUtilities::GetAllFountains(class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlagueUtilities", "GetAllFountains");

	Params::PlagueUtilities_GetAllFountains Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlagueUtilities.GetCleanFountains
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AMagicFountain*>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AMagicFountain*> UPlagueUtilities::GetCleanFountains(class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlagueUtilities", "GetCleanFountains");

	Params::PlagueUtilities_GetCleanFountains Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlagueUtilities.GetCorruptedFountains
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AMagicFountain*>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AMagicFountain*> UPlagueUtilities::GetCorruptedFountains(class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlagueUtilities", "GetCorruptedFountains");

	Params::PlagueUtilities_GetCorruptedFountains Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlagueUtilities.GetPlagueEffect
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USurvivorPlagueEffect*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USurvivorPlagueEffect* UPlagueUtilities::GetPlagueEffect(const class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlagueUtilities", "GetPlagueEffect");

	Params::PlagueUtilities_GetPlagueEffect Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlagueUtilities.HasMaxLevelSickness
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlagueUtilities::HasMaxLevelSickness(const class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlagueUtilities", "HasMaxLevelSickness");

	Params::PlagueUtilities_HasMaxLevelSickness Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlagueUtilities.IsInfected
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlagueUtilities::IsInfected(const class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlagueUtilities", "IsInfected");

	Params::PlagueUtilities_IsInfected Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlagueUtilities.IsPlagueDebugModeActive
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlagueUtilities::IsPlagueDebugModeActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlagueUtilities", "IsPlagueDebugModeActive");

	Params::PlagueUtilities_IsPlagueDebugModeActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlagueUtilities.IsSuperVomitActive
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlagueUtilities::IsSuperVomitActive(const class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlagueUtilities", "IsSuperVomitActive");

	Params::PlagueUtilities_IsSuperVomitActive Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlagueUtilities.SurvivorCanBeSickened
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class ASurvivor*                  Survivor                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlagueUtilities::SurvivorCanBeSickened(const class ASurvivor* Survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlagueUtilities", "SurvivorCanBeSickened");

	Params::PlagueUtilities_SurvivorCanBeSickened Parms{};

	Parms.Survivor = Survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHookOutlineUpdateStrategy.Authority_AddBasementHookToPlayerMapItem
// (Final, Native, Private)

void UMeatHookOutlineUpdateStrategy::Authority_AddBasementHookToPlayerMapItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHookOutlineUpdateStrategy", "Authority_AddBasementHookToPlayerMapItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHookOutlineUpdateStrategy.Local_AddBasementOfferingReveal
// (Final, Native, Private)

void UMeatHookOutlineUpdateStrategy::Local_AddBasementOfferingReveal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHookOutlineUpdateStrategy", "Local_AddBasementOfferingReveal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MenuCameraActor.CanTransition
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMenuCameraActor::CanTransition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuCameraActor", "CanTransition");

	Params::MenuCameraActor_CanTransition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MenuCameraActor.K2_TransitionFinished
// (Event, Public, BlueprintEvent)
// Parameters:
// EDBDCameraViewType                      View                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMenuCameraActor::K2_TransitionFinished(EDBDCameraViewType View)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuCameraActor", "K2_TransitionFinished");

	Params::MenuCameraActor_K2_TransitionFinished Parms{};

	Parms.View = View;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.MenuCameraActor.K2_TransitionStarted
// (Event, Public, BlueprintEvent)
// Parameters:
// EDBDCameraViewType                      View                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMenuCameraActor::K2_TransitionStarted(EDBDCameraViewType View)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuCameraActor", "K2_TransitionStarted");

	Params::MenuCameraActor_K2_TransitionStarted Parms{};

	Parms.View = View;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.MenuCameraActor.GetActiveView
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDBDCameraViewType                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDBDCameraViewType AMenuCameraActor::GetActiveView() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuCameraActor", "GetActiveView");

	Params::MenuCameraActor_GetActiveView Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MenuCameraActor.GetTransitionInitView
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMenuCameraView                  ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMenuCameraView AMenuCameraActor::GetTransitionInitView() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuCameraActor", "GetTransitionInitView");

	Params::MenuCameraActor_GetTransitionInitView Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MenuCameraActor.GetTransitionTargetView
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMenuCameraView                  ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMenuCameraView AMenuCameraActor::GetTransitionTargetView() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuCameraActor", "GetTransitionTargetView");

	Params::MenuCameraActor_GetTransitionTargetView Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MenuCameraActor.TransitionInProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMenuCameraActor::TransitionInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuCameraActor", "TransitionInProgress");

	Params::MenuCameraActor_TransitionInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlayerJoinWatchdog.OnPlayerStateAdded
// (Final, Native, Private)
// Parameters:
// class APlayerState*                     PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerJoinWatchdog::OnPlayerStateAdded(class APlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerJoinWatchdog", "OnPlayerStateAdded");

	Params::PlayerJoinWatchdog_OnPlayerStateAdded Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerJoinWatchdog.OnPlayerStateRemoved
// (Final, Native, Private)
// Parameters:
// class APlayerState*                     PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerJoinWatchdog::OnPlayerStateRemoved(class APlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerJoinWatchdog", "OnPlayerStateRemoved");

	Params::PlayerJoinWatchdog_OnPlayerStateRemoved Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerJoinWatchdog.OnPlayerStateUpdated
// (Final, Native, Private)
// Parameters:
// class ADBDPlayerState*                  DBDPlayerState                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerJoinWatchdog::OnPlayerStateUpdated(class ADBDPlayerState* DBDPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerJoinWatchdog", "OnPlayerStateUpdated");

	Params::PlayerJoinWatchdog_OnPlayerStateUpdated Parms{};

	Parms.DBDPlayerState = DBDPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MenuCameraSystem.Transition
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMenuCameraTransitionParams&params                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMenuCameraSystem::Transition(const struct FMenuCameraTransitionParams& params)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuCameraSystem", "Transition");

	Params::MenuCameraSystem_Transition Parms{};

	Parms.params = std::move(params);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MenuCameraSystem.CanTransition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMenuCameraSystem::CanTransition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuCameraSystem", "CanTransition");

	Params::MenuCameraSystem_CanTransition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MenuCameraSystem.GetActiveViewType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDBDCameraViewType                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDBDCameraViewType UMenuCameraSystem::GetActiveViewType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuCameraSystem", "GetActiveViewType");

	Params::MenuCameraSystem_GetActiveViewType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MenuCameraSystem.GetCamera
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCameraComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCameraComponent* UMenuCameraSystem::GetCamera() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuCameraSystem", "GetCamera");

	Params::MenuCameraSystem_GetCamera Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MenuCameraSystem.GetCurrentCameraViewType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDBDCameraViewType                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDBDCameraViewType UMenuCameraSystem::GetCurrentCameraViewType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuCameraSystem", "GetCurrentCameraViewType");

	Params::MenuCameraSystem_GetCurrentCameraViewType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MenuCameraSystem.GetTransitionInitView
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMenuCameraView                  ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMenuCameraView UMenuCameraSystem::GetTransitionInitView() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuCameraSystem", "GetTransitionInitView");

	Params::MenuCameraSystem_GetTransitionInitView Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MenuCameraSystem.GetTransitionTargetView
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMenuCameraView                  ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMenuCameraView UMenuCameraSystem::GetTransitionTargetView() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuCameraSystem", "GetTransitionTargetView");

	Params::MenuCameraSystem_GetTransitionTargetView Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MenuCameraSystem.IsTransitionInProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMenuCameraSystem::IsTransitionInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuCameraSystem", "IsTransitionInProgress");

	Params::MenuCameraSystem_IsTransitionInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MenuMeatHook.BeginDestroySequence_Internal
// (Native, Event, Protected, BlueprintEvent)

void AMenuMeatHook::BeginDestroySequence_Internal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuMeatHook", "BeginDestroySequence_Internal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MenuMeatHook.OnCharmsUpdated
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const TArray<struct FCharmIdSlot>&      charmIDs                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AMenuMeatHook::OnCharmsUpdated(const TArray<struct FCharmIdSlot>& charmIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuMeatHook", "OnCharmsUpdated");

	Params::MenuMeatHook_OnCharmsUpdated Parms{};

	Parms.charmIDs = std::move(charmIDs);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.MenuUtilities.AreAllGuestCharactersReady
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMenuUtilities::AreAllGuestCharactersReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MenuUtilities", "AreAllGuestCharactersReady");

	Params::MenuUtilities_AreAllGuestCharactersReady Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MenuUtilities.GetAllMenuCharacters
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class ADBDMenuPlayer*>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ADBDMenuPlayer*> UMenuUtilities::GetAllMenuCharacters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MenuUtilities", "GetAllMenuCharacters");

	Params::MenuUtilities_GetAllMenuCharacters Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MenuUtilities.GetLocalPlayerCharacter
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    contextObject                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDMenuPlayer*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDMenuPlayer* UMenuUtilities::GetLocalPlayerCharacter(const class UObject* contextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MenuUtilities", "GetLocalPlayerCharacter");

	Params::MenuUtilities_GetLocalPlayerCharacter Parms{};

	Parms.contextObject = contextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MenuUtilities.GetMenuCameraSystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    contextObject                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMenuCameraSystem*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMenuCameraSystem* UMenuUtilities::GetMenuCameraSystem(const class UObject* contextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MenuUtilities", "GetMenuCameraSystem");

	Params::MenuUtilities_GetMenuCameraSystem Parms{};

	Parms.contextObject = contextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MenuUtilities.IsInArchive
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    contextObject                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMenuUtilities::IsInArchive(const class UObject* contextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MenuUtilities", "IsInArchive");

	Params::MenuUtilities_IsInArchive Parms{};

	Parms.contextObject = contextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MenuUtilities.IsInChallenges
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    contextObject                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMenuUtilities::IsInChallenges(const class UObject* contextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MenuUtilities", "IsInChallenges");

	Params::MenuUtilities_IsInChallenges Parms{};

	Parms.contextObject = contextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MenuUtilities.IsInGame
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    contextObject                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMenuUtilities::IsInGame(const class UObject* contextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MenuUtilities", "IsInGame");

	Params::MenuUtilities_IsInGame Parms{};

	Parms.contextObject = contextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MenuUtilities.IsInRift
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    contextObject                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMenuUtilities::IsInRift(const class UObject* contextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MenuUtilities", "IsInRift");

	Params::MenuUtilities_IsInRift Parms{};

	Parms.contextObject = contextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MenuUtilities.IsInSomeLobby
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    contextObject                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMenuUtilities::IsInSomeLobby(const class UObject* contextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MenuUtilities", "IsInSomeLobby");

	Params::MenuUtilities_IsInSomeLobby Parms{};

	Parms.contextObject = contextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MenuUtilities.IsInStore
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    contextObject                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMenuUtilities::IsInStore(const class UObject* contextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MenuUtilities", "IsInStore");

	Params::MenuUtilities_IsInStore Parms{};

	Parms.contextObject = contextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MontagePlayer.JumpToSection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             sectionName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMontagePlayer::JumpToSection(class FName sectionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MontagePlayer", "JumpToSection");

	Params::MontagePlayer_JumpToSection Parms{};

	Parms.sectionName = sectionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MontagePlayer.JumpToSectionEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             sectionName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMontagePlayer::JumpToSectionEnd(class FName sectionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MontagePlayer", "JumpToSectionEnd");

	Params::MontagePlayer_JumpToSectionEnd Parms{};

	Parms.sectionName = sectionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MontagePlayer.OnMontageBlendingOutInternal
// (Final, Native, Private, HasDefaults)
// Parameters:
// const struct FGuid&                     Guid                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    interrupted                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMontagePlayer::OnMontageBlendingOutInternal(const struct FGuid& Guid, class UAnimMontage* Montage, bool interrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MontagePlayer", "OnMontageBlendingOutInternal");

	Params::MontagePlayer_OnMontageBlendingOutInternal Parms{};

	Parms.Guid = std::move(Guid);
	Parms.Montage = Montage;
	Parms.interrupted = interrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MontagePlayer.OnMontageEndedInternal
// (Final, Native, Private, HasDefaults)
// Parameters:
// const struct FGuid&                     Guid                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    interrupted                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMontagePlayer::OnMontageEndedInternal(const struct FGuid& Guid, class UAnimMontage* Montage, bool interrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MontagePlayer", "OnMontageEndedInternal");

	Params::MontagePlayer_OnMontageEndedInternal Parms{};

	Parms.Guid = std::move(Guid);
	Parms.Montage = Montage;
	Parms.interrupted = interrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MontagePlayer.Play
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FAnimationMontageDescriptor&animMontageID                                          (Parm, NativeAccessSpecifierPublic)
// float                                   PlayRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isFollower                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UMontagePlayer::Play(const struct FAnimationMontageDescriptor& animMontageID, float PlayRate, bool isFollower)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MontagePlayer", "Play");

	Params::MontagePlayer_Play Parms{};

	Parms.animMontageID = std::move(animMontageID);
	Parms.PlayRate = PlayRate;
	Parms.isFollower = isFollower;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MontagePlayer.PlayLoopForDuration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FAnimationMontageDescriptor&animMontageID                                          (Parm, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlayRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Out                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UMontagePlayer::PlayLoopForDuration(const struct FAnimationMontageDescriptor& animMontageID, float Duration, float PlayRate, class FName Out)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MontagePlayer", "PlayLoopForDuration");

	Params::MontagePlayer_PlayLoopForDuration Parms{};

	Parms.animMontageID = std::move(animMontageID);
	Parms.Duration = Duration;
	Parms.PlayRate = PlayRate;
	Parms.Out = Out;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MontagePlayer.SetPlayRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   PlayRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMontagePlayer::SetPlayRate(float PlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MontagePlayer", "SetPlayRate");

	Params::MontagePlayer_SetPlayRate Parms{};

	Parms.PlayRate = PlayRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MontagePlayer.SetSkeletalMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           SkeletalMeshComponent                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMontagePlayer::SetSkeletalMesh(class USkeletalMeshComponent* SkeletalMeshComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MontagePlayer", "SetSkeletalMesh");

	Params::MontagePlayer_SetSkeletalMesh Parms{};

	Parms.SkeletalMeshComponent = SkeletalMeshComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MontagePlayer.SignalAnimInstanceChanged
// (Final, Native, Private)

void UMontagePlayer::SignalAnimInstanceChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MontagePlayer", "SignalAnimInstanceChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MontagePlayer.Stop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   BlendOutTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMontagePlayer::Stop(float BlendOutTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MontagePlayer", "Stop");

	Params::MontagePlayer_Stop Parms{};

	Parms.BlendOutTime = BlendOutTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MontagePlayer.GetAnimInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimInstance*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimInstance* UMontagePlayer::GetAnimInstance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MontagePlayer", "GetAnimInstance");

	Params::MontagePlayer_GetAnimInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MontagePlayer.IsPlaying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FAnimationMontageDescriptor&montageDescriptor                                      (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMontagePlayer::IsPlaying(const struct FAnimationMontageDescriptor& montageDescriptor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MontagePlayer", "IsPlaying");

	Params::MontagePlayer_IsPlaying Parms{};

	Parms.montageDescriptor = std::move(montageDescriptor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MontagePlayer.IsPlayingAnyMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMontagePlayer::IsPlayingAnyMontage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MontagePlayer", "IsPlayingAnyMontage");

	Params::MontagePlayer_IsPlayingAnyMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MoriComponent.OnMoriChargeCompleted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASurvivor*                        survivorTarget                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMoriComponent::OnMoriChargeCompleted(class ASurvivor* survivorTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoriComponent", "OnMoriChargeCompleted");

	Params::MoriComponent_OnMoriChargeCompleted Parms{};

	Parms.survivorTarget = survivorTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MoriComponent.OnMoriFinished
// (Final, Native, Public, BlueprintCallable)

void UMoriComponent::OnMoriFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoriComponent", "OnMoriFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MoriComponent.OnMoriUpdateStart
// (Final, Native, Public, BlueprintCallable)

void UMoriComponent::OnMoriUpdateStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoriComponent", "OnMoriUpdateStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MultipleLightsFader.SetAffectedLights
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class ULightComponent*>&   affectedLights                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AMultipleLightsFader::SetAffectedLights(const TArray<class ULightComponent*>& affectedLights)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MultipleLightsFader", "SetAffectedLights");

	Params::MultipleLightsFader_SetAffectedLights Parms{};

	Parms.affectedLights = std::move(affectedLights);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MysteryBoxSubsystem.OnCurrentClaimEndTimeTimerElapsed
// (Final, Native, Private)
// Parameters:
// const class FString&                    Campaign                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMysteryBoxSubsystem::OnCurrentClaimEndTimeTimerElapsed(const class FString& Campaign)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MysteryBoxSubsystem", "OnCurrentClaimEndTimeTimerElapsed");

	Params::MysteryBoxSubsystem_OnCurrentClaimEndTimeTimerElapsed Parms{};

	Parms.Campaign = std::move(Campaign);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MysteryBoxSubsystem.OnGameInstanceInitialized
// (Final, Native, Private)

void UMysteryBoxSubsystem::OnGameInstanceInitialized()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MysteryBoxSubsystem", "OnGameInstanceInitialized");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MysteryBoxSubsystem.OnNextClaimTimeTimerElapsed
// (Final, Native, Private)
// Parameters:
// const class FString&                    Campaign                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMysteryBoxSubsystem::OnNextClaimTimeTimerElapsed(const class FString& Campaign)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MysteryBoxSubsystem", "OnNextClaimTimeTimerElapsed");

	Params::MysteryBoxSubsystem_OnNextClaimTimeTimerElapsed Parms{};

	Parms.Campaign = std::move(Campaign);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MysteryBoxSubsystem.OnTimeTravel
// (Final, Native, Private)
// Parameters:
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Date                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMysteryBoxSubsystem::OnTimeTravel(bool Success, const class FString& Date)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MysteryBoxSubsystem", "OnTimeTravel");

	Params::MysteryBoxSubsystem_OnTimeTravel Parms{};

	Parms.Success = Success;
	Parms.Date = std::move(Date);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NatAudioAmbienceBox.OnBeginOverlapAudioAmbience
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UNatAudioAmbienceBox::OnBeginOverlapAudioAmbience(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NatAudioAmbienceBox", "OnBeginOverlapAudioAmbience");

	Params::NatAudioAmbienceBox_OnBeginOverlapAudioAmbience Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NatAudioAmbienceBox.OnEndOverlapAudioAmbience
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNatAudioAmbienceBox::OnEndOverlapAudioAmbience(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NatAudioAmbienceBox", "OnEndOverlapAudioAmbience");

	Params::NatAudioAmbienceBox_OnEndOverlapAudioAmbience Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NatAudioCustomMesh.OnBeginOverlapAudioMesh
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UNatAudioCustomMesh::OnBeginOverlapAudioMesh(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NatAudioCustomMesh", "OnBeginOverlapAudioMesh");

	Params::NatAudioCustomMesh_OnBeginOverlapAudioMesh Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NatAudioCustomMesh.OnEndOverlapAudioMesh
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNatAudioCustomMesh::OnEndOverlapAudioMesh(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NatAudioCustomMesh", "OnEndOverlapAudioMesh");

	Params::NatAudioCustomMesh_OnEndOverlapAudioMesh Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorEndGameComponent.OnDelayBeforeSacrificeEnd
// (Final, Native, Private)

void USurvivorEndGameComponent::OnDelayBeforeSacrificeEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorEndGameComponent", "OnDelayBeforeSacrificeEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorEndGameComponent.OnEndGameSacrificeEnd
// (Final, Native, Public, BlueprintCallable)

void USurvivorEndGameComponent::OnEndGameSacrificeEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorEndGameComponent", "OnEndGameSacrificeEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorEndGameComponent.GetSacrificedByEndGame
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USurvivorEndGameComponent::GetSacrificedByEndGame() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorEndGameComponent", "GetSacrificedByEndGame");

	Params::SurvivorEndGameComponent_GetSacrificedByEndGame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.OfflineLobbyLevel.CheckDestroyingPawns
// (Final, Native, Protected)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOfflineLobbyLevel::CheckDestroyingPawns(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfflineLobbyLevel", "CheckDestroyingPawns");

	Params::OfflineLobbyLevel_CheckDestroyingPawns Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OfflineLobbyLevel.OnCharacterSpawned
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADBDMenuPlayer*                   Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOfflineLobbyLevel::OnCharacterSpawned(class ADBDMenuPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfflineLobbyLevel", "OnCharacterSpawned");

	Params::OfflineLobbyLevel_OnCharacterSpawned Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.OfflineLobbyLevel.OnStateChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// EOfflineLobbyState                      LobbyState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOfflineLobbyLevel::OnStateChanged(EOfflineLobbyState LobbyState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfflineLobbyLevel", "OnStateChanged");

	Params::OfflineLobbyLevel_OnStateChanged Parms{};

	Parms.LobbyState = LobbyState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.OniDemonModeAttackStateComponent.Multicast_ClearChargingState
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void UOniDemonModeAttackStateComponent::Multicast_ClearChargingState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OniDemonModeAttackStateComponent", "Multicast_ClearChargingState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OniDemonModeAttackStateComponent.Server_ClearChargingState
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void UOniDemonModeAttackStateComponent::Server_ClearChargingState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OniDemonModeAttackStateComponent", "Server_ClearChargingState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OtherCharactersVerticalCollisionsHandler.InitializeOverlapDetection
// (Final, Native, Private)

void UOtherCharactersVerticalCollisionsHandler::InitializeOverlapDetection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OtherCharactersVerticalCollisionsHandler", "InitializeOverlapDetection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OtherCharactersVerticalCollisionsHandler.OnPawnDetectorOverlapEnter
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UOtherCharactersVerticalCollisionsHandler::OnPawnDetectorOverlapEnter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OtherCharactersVerticalCollisionsHandler", "OnPawnDetectorOverlapEnter");

	Params::OtherCharactersVerticalCollisionsHandler_OnPawnDetectorOverlapEnter Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OtherCharactersVerticalCollisionsHandler.OnPawnDetectorOverlapExit
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOtherCharactersVerticalCollisionsHandler::OnPawnDetectorOverlapExit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OtherCharactersVerticalCollisionsHandler", "OnPawnDetectorOverlapExit");

	Params::OtherCharactersVerticalCollisionsHandler_OnPawnDetectorOverlapExit Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OtherCharactersVerticalCollisionsHandler.SetPawnDetector
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCapsuleComponent*                pawnDetector                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOtherCharactersVerticalCollisionsHandler::SetPawnDetector(class UCapsuleComponent* pawnDetector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OtherCharactersVerticalCollisionsHandler", "SetPawnDetector");

	Params::OtherCharactersVerticalCollisionsHandler_SetPawnDetector Parms{};

	Parms.pawnDetector = pawnDetector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SpecialEventUtilities.BP_Find
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    contextObject                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       eventID                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCombinedSpecialEventData*       outEvent                                               (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USpecialEventUtilities::BP_Find(const class UObject* contextObject, const class FName eventID, struct FCombinedSpecialEventData* outEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpecialEventUtilities", "BP_Find");

	Params::SpecialEventUtilities_BP_Find Parms{};

	Parms.contextObject = contextObject;
	Parms.eventID = eventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outEvent != nullptr)
		*outEvent = std::move(Parms.outEvent);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SpecialEventUtilities.BP_FindBestActive
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    contextObject                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCombinedSpecialEventData*       outEvent                                               (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USpecialEventUtilities::BP_FindBestActive(const class UObject* contextObject, struct FCombinedSpecialEventData* outEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpecialEventUtilities", "BP_FindBestActive");

	Params::SpecialEventUtilities_BP_FindBestActive Parms{};

	Parms.contextObject = contextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outEvent != nullptr)
		*outEvent = std::move(Parms.outEvent);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SpecialEventUtilities.BP_GetEventTrackerObjectiveLevel
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       eventID                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USpecialEventUtilities::BP_GetEventTrackerObjectiveLevel(const class UObject* WorldContextObject, const class FName eventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpecialEventUtilities", "BP_GetEventTrackerObjectiveLevel");

	Params::SpecialEventUtilities_BP_GetEventTrackerObjectiveLevel Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.eventID = eventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SpecialEventUtilities.BP_GetMainEndDate
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FCombinedSpecialEventData& Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime USpecialEventUtilities::BP_GetMainEndDate(const struct FCombinedSpecialEventData& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpecialEventUtilities", "BP_GetMainEndDate");

	Params::SpecialEventUtilities_BP_GetMainEndDate Parms{};

	Parms.Event = std::move(Event);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SpecialEventUtilities.BP_GetPostEndDate
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FCombinedSpecialEventData& Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime USpecialEventUtilities::BP_GetPostEndDate(const struct FCombinedSpecialEventData& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpecialEventUtilities", "BP_GetPostEndDate");

	Params::SpecialEventUtilities_BP_GetPostEndDate Parms{};

	Parms.Event = std::move(Event);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SpecialEventUtilities.BP_GetStartDate
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FCombinedSpecialEventData& Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime USpecialEventUtilities::BP_GetStartDate(const struct FCombinedSpecialEventData& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpecialEventUtilities", "BP_GetStartDate");

	Params::SpecialEventUtilities_BP_GetStartDate Parms{};

	Parms.Event = std::move(Event);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SpecialEventUtilities.BP_GetStatus
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FCombinedSpecialEventData& Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// ESpecialEventStatus                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESpecialEventStatus USpecialEventUtilities::BP_GetStatus(const struct FCombinedSpecialEventData& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpecialEventUtilities", "BP_GetStatus");

	Params::SpecialEventUtilities_BP_GetStatus Parms{};

	Parms.Event = std::move(Event);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SpecialEventUtilities.BP_GetTimeSinceStartDate
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FCombinedSpecialEventData& Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan USpecialEventUtilities::BP_GetTimeSinceStartDate(const struct FCombinedSpecialEventData& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpecialEventUtilities", "BP_GetTimeSinceStartDate");

	Params::SpecialEventUtilities_BP_GetTimeSinceStartDate Parms{};

	Parms.Event = std::move(Event);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SpecialEventUtilities.BP_GetTimeTillMainEndDate
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FCombinedSpecialEventData& Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan USpecialEventUtilities::BP_GetTimeTillMainEndDate(const struct FCombinedSpecialEventData& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpecialEventUtilities", "BP_GetTimeTillMainEndDate");

	Params::SpecialEventUtilities_BP_GetTimeTillMainEndDate Parms{};

	Parms.Event = std::move(Event);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SpecialEventUtilities.BP_GetTimeTillPostEndDate
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FCombinedSpecialEventData& Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan USpecialEventUtilities::BP_GetTimeTillPostEndDate(const struct FCombinedSpecialEventData& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpecialEventUtilities", "BP_GetTimeTillPostEndDate");

	Params::SpecialEventUtilities_BP_GetTimeTillPostEndDate Parms{};

	Parms.Event = std::move(Event);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SpecialEventUtilities.BP_IsActive
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FCombinedSpecialEventData& Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USpecialEventUtilities::BP_IsActive(const struct FCombinedSpecialEventData& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpecialEventUtilities", "BP_IsActive");

	Params::SpecialEventUtilities_BP_IsActive Parms{};

	Parms.Event = std::move(Event);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SpecialEventUtilities.BP_IsValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FCombinedSpecialEventData& Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USpecialEventUtilities::BP_IsValid(const struct FCombinedSpecialEventData& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpecialEventUtilities", "BP_IsValid");

	Params::SpecialEventUtilities_BP_IsValid Parms{};

	Parms.Event = std::move(Event);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.OutOfSightMeshRotator.SetMeshesToRotate
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const TArray<class UMeshComponent*>&    meshesToRotate                                         (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UOutOfSightMeshRotator::SetMeshesToRotate(const TArray<class UMeshComponent*>& meshesToRotate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OutOfSightMeshRotator", "SetMeshesToRotate");

	Params::OutOfSightMeshRotator_SetMeshesToRotate Parms{};

	Parms.meshesToRotate = std::move(meshesToRotate);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PalletDropInteractionDefinition.OnPalletDropped
// (Final, Native, Private)

void UPalletDropInteractionDefinition::OnPalletDropped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PalletDropInteractionDefinition", "OnPalletDropped");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PalletPulldownBlockerComponent.Multicast_PalletPulldownBlockedHideCosmetic
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class UObject*                          palletToUnblock                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPalletPulldownBlockerComponent::Multicast_PalletPulldownBlockedHideCosmetic(class UObject* palletToUnblock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PalletPulldownBlockerComponent", "Multicast_PalletPulldownBlockedHideCosmetic");

	Params::PalletPulldownBlockerComponent_Multicast_PalletPulldownBlockedHideCosmetic Parms{};

	Parms.palletToUnblock = palletToUnblock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PalletPulldownBlockerComponent.Multicast_PalletPulldownBlockedShowCosmetic
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class UObject*                          palletToBlock                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPalletPulldownBlockerComponent::Multicast_PalletPulldownBlockedShowCosmetic(class UObject* palletToBlock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PalletPulldownBlockerComponent", "Multicast_PalletPulldownBlockedShowCosmetic");

	Params::PalletPulldownBlockerComponent_Multicast_PalletPulldownBlockedShowCosmetic Parms{};

	Parms.palletToBlock = palletToBlock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PalletPulldownBlockerComponent.OnRep_PalletToBlock
// (Final, Native, Private)
// Parameters:
// class UObject*                          oldPalletToBlock                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPalletPulldownBlockerComponent::OnRep_PalletToBlock(class UObject* oldPalletToBlock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PalletPulldownBlockerComponent", "OnRep_PalletToBlock");

	Params::PalletPulldownBlockerComponent_OnRep_PalletToBlock Parms{};

	Parms.oldPalletToBlock = oldPalletToBlock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PalletTracker.CanSpawnPalletAtLocation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AActor*                     spawningActor                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APalletTracker::CanSpawnPalletAtLocation(const class AActor* spawningActor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PalletTracker", "CanSpawnPalletAtLocation");

	Params::PalletTracker_CanSpawnPalletAtLocation Parms{};

	Parms.spawningActor = spawningActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PalletTracker.OnRep_TrackedPallet
// (Final, Native, Private, Const)

void APalletTracker::OnRep_TrackedPallet() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PalletTracker", "OnRep_TrackedPallet");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PalletTracker.OnRep_TrackedPalletState
// (Final, Native, Private, Const)

void APalletTracker::OnRep_TrackedPalletState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PalletTracker", "OnRep_TrackedPalletState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PalletUtilities.GetDreamPalletBP
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftClassPtr<class UClass> UPalletUtilities::GetDreamPalletBP(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PalletUtilities", "GetDreamPalletBP");

	Params::PalletUtilities_GetDreamPalletBP Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PalletUtilities.GetIllusionaryPalletStaticMesh
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    worldContextObjec                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UStaticMesh>       ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UStaticMesh> UPalletUtilities::GetIllusionaryPalletStaticMesh(const class UObject* worldContextObjec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PalletUtilities", "GetIllusionaryPalletStaticMesh");

	Params::PalletUtilities_GetIllusionaryPalletStaticMesh Parms{};

	Parms.worldContextObjec = worldContextObjec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PalletUtilities.GetPalletTrackerBP
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftClassPtr<class UClass> UPalletUtilities::GetPalletTrackerBP(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PalletUtilities", "GetPalletTrackerBP");

	Params::PalletUtilities_GetPalletTrackerBP Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.RootMovie.AddCursorBlockingWidget
// (Final, Native, Public)
// Parameters:
// const class FString&                    ID                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Width                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URootMovie::AddCursorBlockingWidget(const class FString& ID, float X, float Y, float Width, float Height)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RootMovie", "AddCursorBlockingWidget");

	Params::RootMovie_AddCursorBlockingWidget Parms{};

	Parms.ID = std::move(ID);
	Parms.X = X;
	Parms.Y = Y;
	Parms.Width = Width;
	Parms.Height = Height;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.RootMovie.OnAssert
// (Final, Native, Public)
// Parameters:
// int32                                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URootMovie::OnAssert(int32 Type, const class FString& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RootMovie", "OnAssert");

	Params::RootMovie_OnAssert Parms{};

	Parms.Type = Type;
	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.RootMovie.OnFlashReady
// (Final, Native, Public)

void URootMovie::OnFlashReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RootMovie", "OnFlashReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.RootMovie.OnMovieClosed
// (Final, Native, Public)

void URootMovie::OnMovieClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RootMovie", "OnMovieClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.RootMovie.OnScreenEnter
// (Final, Native, Public)
// Parameters:
// const class FString&                    screenId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URootMovie::OnScreenEnter(const class FString& screenId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RootMovie", "OnScreenEnter");

	Params::RootMovie_OnScreenEnter Parms{};

	Parms.screenId = std::move(screenId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.RootMovie.OnScreenLeave
// (Final, Native, Public)
// Parameters:
// const class FString&                    screenId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URootMovie::OnScreenLeave(const class FString& screenId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RootMovie", "OnScreenLeave");

	Params::RootMovie_OnScreenLeave Parms{};

	Parms.screenId = std::move(screenId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.RootMovie.OnScreenReady
// (Final, Native, Public)
// Parameters:
// const class FString&                    screenId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URootMovie::OnScreenReady(const class FString& screenId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RootMovie", "OnScreenReady");

	Params::RootMovie_OnScreenReady Parms{};

	Parms.screenId = std::move(screenId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.RootMovie.OpenLinkInBrowser
// (Final, Native, Public)
// Parameters:
// const class FString&                    linkAddress                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URootMovie::OpenLinkInBrowser(const class FString& linkAddress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RootMovie", "OpenLinkInBrowser");

	Params::RootMovie_OpenLinkInBrowser Parms{};

	Parms.linkAddress = std::move(linkAddress);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.RootMovie.PlaySound
// (Final, Native, Public)
// Parameters:
// const class FString&                    soundId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URootMovie::PlaySound(const class FString& soundId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RootMovie", "PlaySound");

	Params::RootMovie_PlaySound Parms{};

	Parms.soundId = std::move(soundId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.RootMovie.RegisterScreenControl
// (Final, Native, Public)
// Parameters:
// class UGFxObject*                       flashObj                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URootMovie::RegisterScreenControl(class UGFxObject* flashObj)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RootMovie", "RegisterScreenControl");

	Params::RootMovie_RegisterScreenControl Parms{};

	Parms.flashObj = flashObj;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.RootMovie.RegisterUIControl
// (Final, Native, Public)
// Parameters:
// class UGFxObject*                       flashObj                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URootMovie::RegisterUIControl(class UGFxObject* flashObj)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RootMovie", "RegisterUIControl");

	Params::RootMovie_RegisterUIControl Parms{};

	Parms.flashObj = flashObj;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.RootMovie.RegisterView
// (Final, Native, Public)
// Parameters:
// const class FString&                    screenId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGFxObject*                       ScreenObject                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URootMovie::RegisterView(const class FString& screenId, class UGFxObject* ScreenObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RootMovie", "RegisterView");

	Params::RootMovie_RegisterView Parms{};

	Parms.screenId = std::move(screenId);
	Parms.ScreenObject = ScreenObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.RootMovie.RemoveCursorBlockingWidget
// (Final, Native, Public)
// Parameters:
// const class FString&                    ID                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URootMovie::RemoveCursorBlockingWidget(const class FString& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RootMovie", "RemoveCursorBlockingWidget");

	Params::RootMovie_RemoveCursorBlockingWidget Parms{};

	Parms.ID = std::move(ID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.RootMovie.SetCursorAsSticky
// (Final, Native, Public)
// Parameters:
// bool                                    IsSticky                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    lockVertical                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    lockHorizontal                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   stickinessOverride                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URootMovie::SetCursorAsSticky(bool IsSticky, bool lockVertical, bool lockHorizontal, float stickinessOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RootMovie", "SetCursorAsSticky");

	Params::RootMovie_SetCursorAsSticky Parms{};

	Parms.IsSticky = IsSticky;
	Parms.lockVertical = lockVertical;
	Parms.lockHorizontal = lockHorizontal;
	Parms.stickinessOverride = stickinessOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnAvailableItemClicked
// (Final, Native, Public)
// Parameters:
// int32                                   clickedItemIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPanelScreen::OnAvailableItemClicked(int32 clickedItemIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnAvailableItemClicked");

	Params::PanelScreen_OnAvailableItemClicked Parms{};

	Parms.clickedItemIndex = clickedItemIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnAvailableItemsSortingChange
// (Final, Native, Public)
// Parameters:
// int32                                   newSorting                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPanelScreen::OnAvailableItemsSortingChange(int32 newSorting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnAvailableItemsSortingChange");

	Params::PanelScreen_OnAvailableItemsSortingChange Parms{};

	Parms.newSorting = newSorting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnBloodwebCenterButtonHovered
// (Final, Native, Public)

void UPanelScreen::OnBloodwebCenterButtonHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnBloodwebCenterButtonHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnBloodwebCenterButtonSelected
// (Final, Native, Public)

void UPanelScreen::OnBloodwebCenterButtonSelected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnBloodwebCenterButtonSelected");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnCharacterSlotButtonClick
// (Final, Native, Public)
// Parameters:
// int32                                   characterIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPanelScreen::OnCharacterSlotButtonClick(int32 characterIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnCharacterSlotButtonClick");

	Params::PanelScreen_OnCharacterSlotButtonClick Parms{};

	Parms.characterIndex = characterIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnCharInfoClick
// (Final, Native, Public)

void UPanelScreen::OnCharInfoClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnCharInfoClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnConfirmCollectSelectedNode
// (Final, Native, Public)
// Parameters:
// int32                                   CharacterId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPanelScreen::OnConfirmCollectSelectedNode(int32 CharacterId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnConfirmCollectSelectedNode");

	Params::PanelScreen_OnConfirmCollectSelectedNode Parms{};

	Parms.CharacterId = CharacterId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnCustomizationPresetClick
// (Final, Native, Public)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPanelScreen::OnCustomizationPresetClick(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnCustomizationPresetClick");

	Params::PanelScreen_OnCustomizationPresetClick Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnEquipableSlotClicked
// (Final, Native, Public)
// Parameters:
// int32                                   clickedSlotCategory                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   clickedSlotIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPanelScreen::OnEquipableSlotClicked(int32 clickedSlotCategory, int32 clickedSlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnEquipableSlotClicked");

	Params::PanelScreen_OnEquipableSlotClicked Parms{};

	Parms.clickedSlotCategory = clickedSlotCategory;
	Parms.clickedSlotIndex = clickedSlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnLevelUpDone
// (Final, Native, Public)

void UPanelScreen::OnLevelUpDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnLevelUpDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnLevelUpShown
// (Final, Native, Public)

void UPanelScreen::OnLevelUpShown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnLevelUpShown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnNodeCollectionAnimDone
// (Final, Native, Public)

void UPanelScreen::OnNodeCollectionAnimDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnNodeCollectionAnimDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnNodeConsumptionAnimDone
// (Final, Native, Public)

void UPanelScreen::OnNodeConsumptionAnimDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnNodeConsumptionAnimDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnPanelsHidden
// (Final, Native, Public)

void UPanelScreen::OnPanelsHidden()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnPanelsHidden");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnPrestigeUp
// (Final, Native, Public)
// Parameters:
// int32                                   CharacterId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPanelScreen::OnPrestigeUp(int32 CharacterId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnPrestigeUp");

	Params::PanelScreen_OnPrestigeUp Parms{};

	Parms.CharacterId = CharacterId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnRegenerateButtonClick
// (Final, Native, Public)
// Parameters:
// int32                                   CharacterId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPanelScreen::OnRegenerateButtonClick(int32 CharacterId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnRegenerateButtonClick");

	Params::PanelScreen_OnRegenerateButtonClick Parms{};

	Parms.CharacterId = CharacterId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnReservedBloodPoints
// (Final, Native, Public)
// Parameters:
// int32                                   CharacterId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   BloodPoints                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    fullCost                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPanelScreen::OnReservedBloodPoints(int32 CharacterId, int32 BloodPoints, bool fullCost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnReservedBloodPoints");

	Params::PanelScreen_OnReservedBloodPoints Parms{};

	Parms.CharacterId = CharacterId;
	Parms.BloodPoints = BloodPoints;
	Parms.fullCost = fullCost;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnSelectedEquipableSlotZoomChange
// (Final, Native, Public)
// Parameters:
// bool                                    zoomIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPanelScreen::OnSelectedEquipableSlotZoomChange(bool zoomIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnSelectedEquipableSlotZoomChange");

	Params::PanelScreen_OnSelectedEquipableSlotZoomChange Parms{};

	Parms.zoomIn = zoomIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnSequenceStepCompleted
// (Final, Native, Public)
// Parameters:
// int32                                   CharacterId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPanelScreen::OnSequenceStepCompleted(int32 CharacterId, int32 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnSequenceStepCompleted");

	Params::PanelScreen_OnSequenceStepCompleted Parms{};

	Parms.CharacterId = CharacterId;
	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnWebBuilt
// (Final, Native, Public)
// Parameters:
// int32                                   CharacterId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsEmpty                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPanelScreen::OnWebBuilt(int32 CharacterId, bool IsEmpty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnWebBuilt");

	Params::PanelScreen_OnWebBuilt Parms{};

	Parms.CharacterId = CharacterId;
	Parms.IsEmpty = IsEmpty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnWebNodeHovered
// (Final, Native, Public)
// Parameters:
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPanelScreen::OnWebNodeHovered(int32 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnWebNodeHovered");

	Params::PanelScreen_OnWebNodeHovered Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnWebNodeSelected
// (Final, Native, Public)
// Parameters:
// int32                                   CharacterId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   nodeDepth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPanelScreen::OnWebNodeSelected(int32 CharacterId, int32 ID, int32 nodeDepth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnWebNodeSelected");

	Params::PanelScreen_OnWebNodeSelected Parms{};

	Parms.CharacterId = CharacterId;
	Parms.ID = ID;
	Parms.nodeDepth = nodeDepth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PawnAudioManager.ForcePawnAudioPriority
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDBasePlayer*                   Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPawnAudioManager::ForcePawnAudioPriority(class ADBDBasePlayer* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PawnAudioManager", "ForcePawnAudioPriority");

	Params::PawnAudioManager_ForcePawnAudioPriority Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PawnAudioManager.IsPawnCurrentlyActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDBasePlayer*                   Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPawnAudioManager::IsPawnCurrentlyActive(class ADBDBasePlayer* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PawnAudioManager", "IsPawnCurrentlyActive");

	Params::PawnAudioManager_IsPawnCurrentlyActive Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PawnAudioManager.PostAudioEventIfPawnCurrent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDBasePlayer*                   Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    AudioEvent                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPawnAudioManager::PostAudioEventIfPawnCurrent(class ADBDBasePlayer* Pawn, class UAkAudioEvent* AudioEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PawnAudioManager", "PostAudioEventIfPawnCurrent");

	Params::PawnAudioManager_PostAudioEventIfPawnCurrent Parms{};

	Parms.Pawn = Pawn;
	Parms.AudioEvent = AudioEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PawnAudioManager.RegisterSlasherPawnAudio
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDBasePlayer*                   SlasherPawn                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       onAudioEnabled                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       onAudioDisabled                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPawnAudioManager::RegisterSlasherPawnAudio(class ADBDBasePlayer* SlasherPawn, TDelegate<void()> onAudioEnabled, TDelegate<void()> onAudioDisabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PawnAudioManager", "RegisterSlasherPawnAudio");

	Params::PawnAudioManager_RegisterSlasherPawnAudio Parms{};

	Parms.SlasherPawn = SlasherPawn;
	Parms.onAudioEnabled = onAudioEnabled;
	Parms.onAudioDisabled = onAudioDisabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PawnAudioManager.UnregisterSlasherPawnAudio
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDBasePlayer*                   SlasherPawn                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPawnAudioManager::UnregisterSlasherPawnAudio(class ADBDBasePlayer* SlasherPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PawnAudioManager", "UnregisterSlasherPawnAudio");

	Params::PawnAudioManager_UnregisterSlasherPawnAudio Parms{};

	Parms.SlasherPawn = SlasherPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PerkCollectionComponent.OnRep_Array
// (Final, Native, Private, HasOutParams)
// Parameters:
// const TArray<class UPerk*>&             oldArray                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UPerkCollectionComponent::OnRep_Array(const TArray<class UPerk*>& oldArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkCollectionComponent", "OnRep_Array");

	Params::PerkCollectionComponent_OnRep_Array Parms{};

	Parms.oldArray = std::move(oldArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PerkManager.Authority_ImposeNewStatusEffectOfClassOrChangeLifeTime
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UStatusEffect>        EffectClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       OriginatingPlayer                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Lifetime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CustomParam                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayModifierContainer*       OriginatingEffect                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ShouldDisplay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    replaceInfiniteLifetime                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffect*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStatusEffect* UPerkManager::Authority_ImposeNewStatusEffectOfClassOrChangeLifeTime(TSubclassOf<class UStatusEffect> EffectClass, class ADBDPlayer* OriginatingPlayer, float Lifetime, float CustomParam, class UGameplayModifierContainer* OriginatingEffect, bool ShouldDisplay, bool replaceInfiniteLifetime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "Authority_ImposeNewStatusEffectOfClassOrChangeLifeTime");

	Params::PerkManager_Authority_ImposeNewStatusEffectOfClassOrChangeLifeTime Parms{};

	Parms.EffectClass = EffectClass;
	Parms.OriginatingPlayer = OriginatingPlayer;
	Parms.Lifetime = Lifetime;
	Parms.CustomParam = CustomParam;
	Parms.OriginatingEffect = OriginatingEffect;
	Parms.ShouldDisplay = ShouldDisplay;
	Parms.replaceInfiniteLifetime = replaceInfiniteLifetime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.Authority_ImposeStatusEffectFromTemplate
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UStatusEffect*                    effectTemplate                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       OriginatingPlayer                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CustomParam                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayModifierContainer*       OriginatingEffect                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ShouldDisplay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Lifetime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffect*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStatusEffect* UPerkManager::Authority_ImposeStatusEffectFromTemplate(class UStatusEffect* effectTemplate, class ADBDPlayer* OriginatingPlayer, float CustomParam, class UGameplayModifierContainer* OriginatingEffect, bool ShouldDisplay, float Lifetime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "Authority_ImposeStatusEffectFromTemplate");

	Params::PerkManager_Authority_ImposeStatusEffectFromTemplate Parms{};

	Parms.effectTemplate = effectTemplate;
	Parms.OriginatingPlayer = OriginatingPlayer;
	Parms.CustomParam = CustomParam;
	Parms.OriginatingEffect = OriginatingEffect;
	Parms.ShouldDisplay = ShouldDisplay;
	Parms.Lifetime = Lifetime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.Authority_ImposeStatusEffectOfClass
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UStatusEffect>        EffectClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       OriginatingPlayer                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CustomParam                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayModifierContainer*       OriginatingEffect                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ShouldDisplay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Lifetime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffect*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStatusEffect* UPerkManager::Authority_ImposeStatusEffectOfClass(TSubclassOf<class UStatusEffect> EffectClass, class ADBDPlayer* OriginatingPlayer, float CustomParam, class UGameplayModifierContainer* OriginatingEffect, bool ShouldDisplay, float Lifetime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "Authority_ImposeStatusEffectOfClass");

	Params::PerkManager_Authority_ImposeStatusEffectOfClass Parms{};

	Parms.EffectClass = EffectClass;
	Parms.OriginatingPlayer = OriginatingPlayer;
	Parms.CustomParam = CustomParam;
	Parms.OriginatingEffect = OriginatingEffect;
	Parms.ShouldDisplay = ShouldDisplay;
	Parms.Lifetime = Lifetime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.Authority_RemovePerks
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UPerkManager::Authority_RemovePerks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "Authority_RemovePerks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PerkManager.Authority_RemoveStatusEffect
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UStatusEffect*                    StatusEffect                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerkManager::Authority_RemoveStatusEffect(class UStatusEffect* StatusEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "Authority_RemoveStatusEffect");

	Params::PerkManager_Authority_RemoveStatusEffect Parms{};

	Parms.StatusEffect = StatusEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PerkManager.Authority_RemoveStatusEffectByClass
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const class UClass*                     EffectClass                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemoveAllOfSameClass                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerkManager::Authority_RemoveStatusEffectByClass(const class UClass* EffectClass, bool bRemoveAllOfSameClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "Authority_RemoveStatusEffectByClass");

	Params::PerkManager_Authority_RemoveStatusEffectByClass Parms{};

	Parms.EffectClass = EffectClass;
	Parms.bRemoveAllOfSameClass = bRemoveAllOfSameClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PerkManager.Authority_SpawnPerk
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             PerkId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PerkLevel                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerkManager::Authority_SpawnPerk(class FName PerkId, int32 PerkLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "Authority_SpawnPerk");

	Params::PerkManager_Authority_SpawnPerk Parms{};

	Parms.PerkId = PerkId;
	Parms.PerkLevel = PerkLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PerkManager.GetAllSourcesWithFlag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              Flag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UGameplayModifierContainer*>ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UGameplayModifierContainer*> UPerkManager::GetAllSourcesWithFlag(const struct FGameplayTag& Flag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetAllSourcesWithFlag");

	Params::PerkManager_GetAllSourcesWithFlag Parms{};

	Parms.Flag = std::move(Flag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetAllSourcesWithModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              Type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UGameplayModifierContainer*>ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UGameplayModifierContainer*> UPerkManager::GetAllSourcesWithModifier(const struct FGameplayTag& Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetAllSourcesWithModifier");

	Params::PerkManager_GetAllSourcesWithModifier Parms{};

	Parms.Type = std::move(Type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetAllStatusEffects
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UStatusEffect*>            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UStatusEffect*> UPerkManager::GetAllStatusEffects() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetAllStatusEffects");

	Params::PerkManager_GetAllStatusEffects Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetAllStatusEffectsByClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UClass*                     Type                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UStatusEffect*>            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UStatusEffect*> UPerkManager::GetAllStatusEffectsByClass(const class UClass* Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetAllStatusEffectsByClass");

	Params::PerkManager_GetAllStatusEffectsByClass Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetAllStatusEffectsByID
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UStatusEffect*>            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UStatusEffect*> UPerkManager::GetAllStatusEffectsByID(const class FName& ID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetAllStatusEffectsByID");

	Params::PerkManager_GetAllStatusEffectsByID Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetAveragePerkModifierValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              Type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPerkManager::GetAveragePerkModifierValue(const struct FGameplayTag& Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetAveragePerkModifierValue");

	Params::PerkManager_GetAveragePerkModifierValue Parms{};

	Parms.Type = std::move(Type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetCompoundedModifierValue
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              Type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPerkManager::GetCompoundedModifierValue(const struct FGameplayTag& Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetCompoundedModifierValue");

	Params::PerkManager_GetCompoundedModifierValue Parms{};

	Parms.Type = std::move(Type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetMultiplicativeModifierValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              Type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPerkManager::GetMultiplicativeModifierValue(const struct FGameplayTag& Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetMultiplicativeModifierValue");

	Params::PerkManager_GetMultiplicativeModifierValue Parms{};

	Parms.Type = std::move(Type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetMultiplicativeModifierValueOfContainerWithCompoundNegative
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTagContainer&     container                                              (Parm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPerkManager::GetMultiplicativeModifierValueOfContainerWithCompoundNegative(const struct FGameplayTagContainer& container) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetMultiplicativeModifierValueOfContainerWithCompoundNegative");

	Params::PerkManager_GetMultiplicativeModifierValueOfContainerWithCompoundNegative Parms{};

	Parms.container = std::move(container);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetMultiplicativeModifierValueWithCompoundNegative
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              Type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPerkManager::GetMultiplicativeModifierValueWithCompoundNegative(const struct FGameplayTag& Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetMultiplicativeModifierValueWithCompoundNegative");

	Params::PerkManager_GetMultiplicativeModifierValueWithCompoundNegative Parms{};

	Parms.Type = std::move(Type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetPerk
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPerk*                            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPerk* UPerkManager::GetPerk(class FName ID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetPerk");

	Params::PerkManager_GetPerk Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetPerkModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              Type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPerkManager::GetPerkModifier(const struct FGameplayTag& Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetPerkModifier");

	Params::PerkManager_GetPerkModifier Parms{};

	Parms.Type = std::move(Type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetPerkModifierAdditiveValue
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              Type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             BaseValue                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPerkManager::GetPerkModifierAdditiveValue(const struct FGameplayTag& Type, const float BaseValue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetPerkModifierAdditiveValue");

	Params::PerkManager_GetPerkModifierAdditiveValue Parms{};

	Parms.Type = std::move(Type);
	Parms.BaseValue = BaseValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetPerkModifierMaxValue
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              Type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPerkManager::GetPerkModifierMaxValue(const struct FGameplayTag& Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetPerkModifierMaxValue");

	Params::PerkManager_GetPerkModifierMaxValue Parms{};

	Parms.Type = std::move(Type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetPerkModifierMaxValueAndSource
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              Type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayModifierContainer**      outSource                                              (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPerkManager::GetPerkModifierMaxValueAndSource(const struct FGameplayTag& Type, class UGameplayModifierContainer** outSource) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetPerkModifierMaxValueAndSource");

	Params::PerkManager_GetPerkModifierMaxValueAndSource Parms{};

	Parms.Type = std::move(Type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outSource != nullptr)
		*outSource = Parms.outSource;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetPerkModifierMinValue
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              Type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPerkManager::GetPerkModifierMinValue(const struct FGameplayTag& Type, float StartValue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetPerkModifierMinValue");

	Params::PerkManager_GetPerkModifierMinValue Parms{};

	Parms.Type = std::move(Type);
	Parms.StartValue = StartValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetPerkModifierMinValueAndSource
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              Type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayModifierContainer**      outSource                                              (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPerkManager::GetPerkModifierMinValueAndSource(const struct FGameplayTag& Type, float StartValue, class UGameplayModifierContainer** outSource) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetPerkModifierMinValueAndSource");

	Params::PerkManager_GetPerkModifierMinValueAndSource Parms{};

	Parms.Type = std::move(Type);
	Parms.StartValue = StartValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outSource != nullptr)
		*outSource = Parms.outSource;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetPerks
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class UPerk*>              ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TArray<class UPerk*> UPerkManager::GetPerks() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetPerks");

	Params::PerkManager_GetPerks Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetSourceWithFlag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              Flag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayModifierContainer*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayModifierContainer* UPerkManager::GetSourceWithFlag(const struct FGameplayTag& Flag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetSourceWithFlag");

	Params::PerkManager_GetSourceWithFlag Parms{};

	Parms.Flag = std::move(Flag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetSourceWithModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              Type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayModifierContainer*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayModifierContainer* UPerkManager::GetSourceWithModifier(const struct FGameplayTag& Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetSourceWithModifier");

	Params::PerkManager_GetSourceWithModifier Parms{};

	Parms.Type = std::move(Type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetStatusEffectByClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UClass*                     Type                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffect*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStatusEffect* UPerkManager::GetStatusEffectByClass(const class UClass* Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetStatusEffectByClass");

	Params::PerkManager_GetStatusEffectByClass Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.HasAllCharacterPerksEquipped
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPerkManager::HasAllCharacterPerksEquipped() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "HasAllCharacterPerksEquipped");

	Params::PerkManager_HasAllCharacterPerksEquipped Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.HasAnyAddonWithTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPerkManager::HasAnyAddonWithTag(class FName Tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "HasAnyAddonWithTag");

	Params::PerkManager_HasAnyAddonWithTag Parms{};

	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.HasPerkFlag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              Flag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPerkManager::HasPerkFlag(const struct FGameplayTag& Flag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "HasPerkFlag");

	Params::PerkManager_HasPerkFlag Parms{};

	Parms.Flag = std::move(Flag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.HasPerkFlagFromSource
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              Flag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayModifierSource                 modifierSource                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPerkManager::HasPerkFlagFromSource(const struct FGameplayTag& Flag, EGameplayModifierSource modifierSource) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "HasPerkFlagFromSource");

	Params::PerkManager_HasPerkFlagFromSource Parms{};

	Parms.Flag = std::move(Flag);
	Parms.modifierSource = modifierSource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.HasPerkFlags
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FGameplayTag>&      Flags_0                                                (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPerkManager::HasPerkFlags(const TArray<struct FGameplayTag>& Flags_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "HasPerkFlags");

	Params::PerkManager_HasPerkFlags Parms{};

	Parms.Flags_0 = std::move(Flags_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.HasPerkModifierOfType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              Type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPerkManager::HasPerkModifierOfType(const struct FGameplayTag& Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "HasPerkModifierOfType");

	Params::PerkManager_HasPerkModifierOfType Parms{};

	Parms.Type = std::move(Type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.HasPerkSubFlag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              subFlag                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPerkManager::HasPerkSubFlag(const struct FGameplayTag& subFlag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "HasPerkSubFlag");

	Params::PerkManager_HasPerkSubFlag Parms{};

	Parms.subFlag = std::move(subFlag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.HasStatusEffect
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       statusEffectId                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPerkManager::HasStatusEffect(const class FName statusEffectId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "HasStatusEffect");

	Params::PerkManager_HasStatusEffect Parms{};

	Parms.statusEffectId = statusEffectId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.HasStatusEffectOfClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UClass*                     Type                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    includeChildrenOf                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPerkManager::HasStatusEffectOfClass(const class UClass* Type, bool includeChildrenOf) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "HasStatusEffectOfClass");

	Params::PerkManager_HasStatusEffectOfClass Parms{};

	Parms.Type = Type;
	Parms.includeChildrenOf = includeChildrenOf;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkTrappableComponent.OnRep_TrapsOnInteractable
// (Final, Native, Private)

void UPerkTrappableComponent::OnRep_TrapsOnInteractable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkTrappableComponent", "OnRep_TrapsOnInteractable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PerkTrappableComponent.HasAnyTrap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPerkTrappableComponent::HasAnyTrap() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkTrappableComponent", "HasAnyTrap");

	Params::PerkTrappableComponent_HasAnyTrap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkTrappableComponent.HasTrap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const ETrapType                         trapType                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPerkTrappableComponent::HasTrap(const ETrapType trapType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkTrappableComponent", "HasTrap");

	Params::PerkTrappableComponent_HasTrap Parms{};

	Parms.trapType = trapType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlayerInGameAssetPreloadState.Server_SetPreloadCompleted
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const class FString&                    preloadInfo                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInGameAssetPreloadState::Server_SetPreloadCompleted(const class FString& preloadInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInGameAssetPreloadState", "Server_SetPreloadCompleted");

	Params::PlayerInGameAssetPreloadState_Server_SetPreloadCompleted Parms{};

	Parms.preloadInfo = std::move(preloadInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerMoveBackAndForthComponent.OnMoveTimerDone
// (Final, Native, Private)

void UPlayerMoveBackAndForthComponent::OnMoveTimerDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerMoveBackAndForthComponent", "OnMoveTimerDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrap.AttachSurvivor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReverseBearTrap::AttachSurvivor(class ASurvivor* Survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "AttachSurvivor");

	Params::ReverseBearTrap_AttachSurvivor Parms{};

	Parms.Survivor = Survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrap.Authority_GenerateAttemptsNeeded
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             remainingAttemptsTotal                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             remainingRBTs                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             numRemovers                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReverseBearTrap::Authority_GenerateAttemptsNeeded(const int32 remainingAttemptsTotal, const int32 remainingRBTs, const int32 numRemovers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "Authority_GenerateAttemptsNeeded");

	Params::ReverseBearTrap_Authority_GenerateAttemptsNeeded Parms{};

	Parms.remainingAttemptsTotal = remainingAttemptsTotal;
	Parms.remainingRBTs = remainingRBTs;
	Parms.numRemovers = numRemovers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrap.Authority_OnGeneratorRepaired
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AReverseBearTrap::Authority_OnGeneratorRepaired(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "Authority_OnGeneratorRepaired");

	Params::ReverseBearTrap_Authority_OnGeneratorRepaired Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrap.Authority_SetKeyID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   KeyId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReverseBearTrap::Authority_SetKeyID(int32 KeyId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "Authority_SetKeyID");

	Params::ReverseBearTrap_Authority_SetKeyID Parms{};

	Parms.KeyId = KeyId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrap.DetachSurvivor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReverseBearTrap::DetachSurvivor(class ASurvivor* Survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "DetachSurvivor");

	Params::ReverseBearTrap_DetachSurvivor Parms{};

	Parms.Survivor = Survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrap.FastForwardExecutionTimer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReverseBearTrap::FastForwardExecutionTimer(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "FastForwardExecutionTimer");

	Params::ReverseBearTrap_FastForwardExecutionTimer Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrap.IncrementAttemptsMade
// (Final, Native, Public, BlueprintCallable)

void AReverseBearTrap::IncrementAttemptsMade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "IncrementAttemptsMade");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrap.NotifyDetachStarted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReverseBearTrap::NotifyDetachStarted(class ASurvivor* Survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "NotifyDetachStarted");

	Params::ReverseBearTrap_NotifyDetachStarted Parms{};

	Parms.Survivor = Survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrap.NotifyOnAttachSurvivorBegin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReverseBearTrap::NotifyOnAttachSurvivorBegin(class ASurvivor* Survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "NotifyOnAttachSurvivorBegin");

	Params::ReverseBearTrap_NotifyOnAttachSurvivorBegin Parms{};

	Parms.Survivor = Survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrap.OnAttachSurvivor
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReverseBearTrap::OnAttachSurvivor(class ASurvivor* Survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "OnAttachSurvivor");

	Params::ReverseBearTrap_OnAttachSurvivor Parms{};

	Parms.Survivor = Survivor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.ReverseBearTrap.OnAttachSurvivorBegin
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReverseBearTrap::OnAttachSurvivorBegin(class ASurvivor* Survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "OnAttachSurvivorBegin");

	Params::ReverseBearTrap_OnAttachSurvivorBegin Parms{};

	Parms.Survivor = Survivor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.ReverseBearTrap.OnDetachSurvivor
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReverseBearTrap::OnDetachSurvivor(class ASurvivor* Survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "OnDetachSurvivor");

	Params::ReverseBearTrap_OnDetachSurvivor Parms{};

	Parms.Survivor = Survivor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.ReverseBearTrap.OnEnterWarningZone
// (Final, Native, Public, BlueprintCallable)

void AReverseBearTrap::OnEnterWarningZone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "OnEnterWarningZone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrap.OnExitWarningZone
// (Final, Native, Public, BlueprintCallable)

void AReverseBearTrap::OnExitWarningZone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "OnExitWarningZone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrap.OnWarningLevelChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   previousWarningLevel                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   currentWarningLevel                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReverseBearTrap::OnWarningLevelChanged(int32 previousWarningLevel, int32 currentWarningLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "OnWarningLevelChanged");

	Params::ReverseBearTrap_OnWarningLevelChanged Parms{};

	Parms.previousWarningLevel = previousWarningLevel;
	Parms.currentWarningLevel = currentWarningLevel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.ReverseBearTrap.ResetExecutionTimer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReverseBearTrap::ResetExecutionTimer(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "ResetExecutionTimer");

	Params::ReverseBearTrap_ResetExecutionTimer Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrap.SetGateClosedAtAttachment
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    CLOSED                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReverseBearTrap::SetGateClosedAtAttachment(bool CLOSED)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "SetGateClosedAtAttachment");

	Params::ReverseBearTrap_SetGateClosedAtAttachment Parms{};

	Parms.CLOSED = CLOSED;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrap.SetVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Visible                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReverseBearTrap::SetVisible(bool Visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "SetVisible");

	Params::ReverseBearTrap_SetVisible Parms{};

	Parms.Visible = Visible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrap.StopExecutionTimer
// (Final, Native, Public, BlueprintCallable)

void AReverseBearTrap::StopExecutionTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "StopExecutionTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrap.StopMontage
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void AReverseBearTrap::StopMontage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "StopMontage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrap.CanExecute
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AReverseBearTrap::CanExecute() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "CanExecute");

	Params::ReverseBearTrap_CanExecute Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrap.GetAttachedSurvivor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASurvivor*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASurvivor* AReverseBearTrap::GetAttachedSurvivor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "GetAttachedSurvivor");

	Params::ReverseBearTrap_GetAttachedSurvivor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrap.GetAttemptsMade
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AReverseBearTrap::GetAttemptsMade() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "GetAttemptsMade");

	Params::ReverseBearTrap_GetAttemptsMade Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrap.GetAttemptsNeeded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AReverseBearTrap::GetAttemptsNeeded() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "GetAttemptsNeeded");

	Params::ReverseBearTrap_GetAttemptsNeeded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrap.GetExecutionTimerPercentTimeElapsed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AReverseBearTrap::GetExecutionTimerPercentTimeElapsed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "GetExecutionTimerPercentTimeElapsed");

	Params::ReverseBearTrap_GetExecutionTimerPercentTimeElapsed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrap.GetExecutionTimerTimeLeft
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AReverseBearTrap::GetExecutionTimerTimeLeft() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "GetExecutionTimerTimeLeft");

	Params::ReverseBearTrap_GetExecutionTimerTimeLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrap.GetExitGatesPoweredAfterAttachment
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AReverseBearTrap::GetExitGatesPoweredAfterAttachment() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "GetExitGatesPoweredAfterAttachment");

	Params::ReverseBearTrap_GetExitGatesPoweredAfterAttachment Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrap.GetGeneratorFixedAfterAttachment
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AReverseBearTrap::GetGeneratorFixedAfterAttachment() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "GetGeneratorFixedAfterAttachment");

	Params::ReverseBearTrap_GetGeneratorFixedAfterAttachment Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrap.GetKeyID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AReverseBearTrap::GetKeyID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "GetKeyID");

	Params::ReverseBearTrap_GetKeyID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrap.GetOwningKiller
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AKiller*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AKiller* AReverseBearTrap::GetOwningKiller() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "GetOwningKiller");

	Params::ReverseBearTrap_GetOwningKiller Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrap.GetWarningLevel
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AReverseBearTrap::GetWarningLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "GetWarningLevel");

	Params::ReverseBearTrap_GetWarningLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrap.GetWasGateClosedAtAttachment
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AReverseBearTrap::GetWasGateClosedAtAttachment() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "GetWasGateClosedAtAttachment");

	Params::ReverseBearTrap_GetWasGateClosedAtAttachment Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrap.HasDetachStarted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AReverseBearTrap::HasDetachStarted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "HasDetachStarted");

	Params::ReverseBearTrap_HasDetachStarted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrap.IsExecutionTimerActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AReverseBearTrap::IsExecutionTimerActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "IsExecutionTimerActive");

	Params::ReverseBearTrap_IsExecutionTimerActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrap.IsExecutionTimerDone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AReverseBearTrap::IsExecutionTimerDone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "IsExecutionTimerDone");

	Params::ReverseBearTrap_IsExecutionTimerDone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrap.IsInWarningZone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AReverseBearTrap::IsInWarningZone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "IsInWarningZone");

	Params::ReverseBearTrap_IsInWarningZone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrap.IsRBTActivated
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AReverseBearTrap::IsRBTActivated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "IsRBTActivated");

	Params::ReverseBearTrap_IsRBTActivated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrap.ShouldUpdateExecutionTimer
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AReverseBearTrap::ShouldUpdateExecutionTimer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "ShouldUpdateExecutionTimer");

	Params::ReverseBearTrap_ShouldUpdateExecutionTimer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SacrificeEnd.FX_SacrificeEnd
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ASacrificeEnd::FX_SacrificeEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SacrificeEnd", "FX_SacrificeEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.SacrificeEnd.FX_SacrificeEnd_Basement
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ASacrificeEnd::FX_SacrificeEnd_Basement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SacrificeEnd", "FX_SacrificeEnd_Basement");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.ScourgeHookManagerComponent.OnLocallyObservedChanged
// (Final, Native, Private)

void UScourgeHookManagerComponent::OnLocallyObservedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScourgeHookManagerComponent", "OnLocallyObservedChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScourgeHookManagerComponent.OnRep_ScourgeHooks
// (Final, Native, Private)

void UScourgeHookManagerComponent::OnRep_ScourgeHooks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScourgeHookManagerComponent", "OnRep_ScourgeHooks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreamComponent.OnDamageStateChanged
// (Final, Native, Private)
// Parameters:
// EHealthState                            oldDamageState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHealthState                            newDamageState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScreamComponent::OnDamageStateChanged(EHealthState oldDamageState, EHealthState newDamageState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreamComponent", "OnDamageStateChanged");

	Params::ScreamComponent_OnDamageStateChanged Parms{};

	Parms.oldDamageState = oldDamageState;
	Parms.newDamageState = newDamageState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreamComponent.CanScream
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UScreamComponent::CanScream() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreamComponent", "CanScream");

	Params::ScreamComponent_CanScream Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ScreamComponent.GetCanScreamAndPreventNextScreamIfNeeded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UScreamComponent::GetCanScreamAndPreventNextScreamIfNeeded() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreamComponent", "GetCanScreamAndPreventNextScreamIfNeeded");

	Params::ScreamComponent_GetCanScreamAndPreventNextScreamIfNeeded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ScreamComponent.ScreamRevealOwner
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// const bool                              SpawnBubbleIndicator                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             screamRevealDuration                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScreamComponent::ScreamRevealOwner(const bool SpawnBubbleIndicator, const float screamRevealDuration) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreamComponent", "ScreamRevealOwner");

	Params::ScreamComponent_ScreamRevealOwner Parms{};

	Parms.SpawnBubbleIndicator = SpawnBubbleIndicator;
	Parms.screamRevealDuration = screamRevealDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreamComponent.TriggerScreamEventsAndAndAnimationIfPossible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    fireLoudNoiseEvent                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMontagePlaybackDefinition&montageDefinition                                      (Parm, NativeAccessSpecifierPublic)
// float                                   audibleRange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UScreamComponent::TriggerScreamEventsAndAndAnimationIfPossible(bool fireLoudNoiseEvent, const struct FMontagePlaybackDefinition& montageDefinition, float audibleRange) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreamComponent", "TriggerScreamEventsAndAndAnimationIfPossible");

	Params::ScreamComponent_TriggerScreamEventsAndAndAnimationIfPossible Parms{};

	Parms.fireLoudNoiseEvent = fireLoudNoiseEvent;
	Parms.montageDefinition = std::move(montageDefinition);
	Parms.audibleRange = audibleRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ScreamComponent.TriggerScreamEventsIfPossible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    fireLoudNoiseEvent                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   audibleRange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UScreamComponent::TriggerScreamEventsIfPossible(bool fireLoudNoiseEvent, float audibleRange) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreamComponent", "TriggerScreamEventsIfPossible");

	Params::ScreamComponent_TriggerScreamEventsIfPossible Parms{};

	Parms.fireLoudNoiseEvent = fireLoudNoiseEvent;
	Parms.audibleRange = audibleRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ScreenshotToolHook.PostBatchItems
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const TArray<struct FCharacterToolItemData>&Items                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void IScreenshotToolHook::PostBatchItems(const TArray<struct FCharacterToolItemData>& Items)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ScreenshotToolHook", "PostBatchItems");

	Params::ScreenshotToolHook_PostBatchItems Parms{};

	Parms.Items = std::move(Items);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenshotToolHook.PostHookConstruction
// (Native, Event, Public, BlueprintEvent)

void IScreenshotToolHook::PostHookConstruction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ScreenshotToolHook", "PostHookConstruction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenshotToolHook.PostSpawnCharacter
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ADBDMenuPlayer*                   Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IScreenshotToolHook::PostSpawnCharacter(class ADBDMenuPlayer* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ScreenshotToolHook", "PostSpawnCharacter");

	Params::ScreenshotToolHook_PostSpawnCharacter Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenshotToolHook.PostSpawnCharm
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ACharm*                           Charm                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IScreenshotToolHook::PostSpawnCharm(class ACharm* Charm)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ScreenshotToolHook", "PostSpawnCharm");

	Params::ScreenshotToolHook_PostSpawnCharm Parms{};

	Parms.Charm = Charm;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenshotToolHook.PostStateChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// EScreenshotToolState                    previousState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EScreenshotToolState                    CurrentState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IScreenshotToolHook::PostStateChanged(EScreenshotToolState previousState, EScreenshotToolState CurrentState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ScreenshotToolHook", "PostStateChanged");

	Params::ScreenshotToolHook_PostStateChanged Parms{};

	Parms.previousState = previousState;
	Parms.CurrentState = CurrentState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenshotToolHook.PostTakeItemScreenshot
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FCharacterToolItemData&    Item                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IScreenshotToolHook::PostTakeItemScreenshot(const struct FCharacterToolItemData& Item, bool Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ScreenshotToolHook", "PostTakeItemScreenshot");

	Params::ScreenshotToolHook_PostTakeItemScreenshot Parms{};

	Parms.Item = std::move(Item);
	Parms.Success = Success;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenshotToolHook.PostUpdateCharacter
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ADBDMenuPlayer*                   Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IScreenshotToolHook::PostUpdateCharacter(class ADBDMenuPlayer* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ScreenshotToolHook", "PostUpdateCharacter");

	Params::ScreenshotToolHook_PostUpdateCharacter Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenshotToolHook.PreBatchItems
// (Native, Event, Public, BlueprintEvent)

void IScreenshotToolHook::PreBatchItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ScreenshotToolHook", "PreBatchItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenshotToolHook.PreDestroyCharacter
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ADBDMenuPlayer*                   Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IScreenshotToolHook::PreDestroyCharacter(class ADBDMenuPlayer* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ScreenshotToolHook", "PreDestroyCharacter");

	Params::ScreenshotToolHook_PreDestroyCharacter Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenshotToolHook.PreDestroyCharm
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ACharm*                           Charm                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IScreenshotToolHook::PreDestroyCharm(class ACharm* Charm)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ScreenshotToolHook", "PreDestroyCharm");

	Params::ScreenshotToolHook_PreDestroyCharm Parms{};

	Parms.Charm = Charm;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenshotToolHook.PreHookDestruction
// (Native, Event, Public, BlueprintEvent)

void IScreenshotToolHook::PreHookDestruction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ScreenshotToolHook", "PreHookDestruction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenshotToolHook.PreSpawnCharacter
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class ADBDMenuPlayer*                   Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCharacterToolSpawnParameters*   SpawnParams                                            (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void IScreenshotToolHook::PreSpawnCharacter(class ADBDMenuPlayer* Character, struct FCharacterToolSpawnParameters* SpawnParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ScreenshotToolHook", "PreSpawnCharacter");

	Params::ScreenshotToolHook_PreSpawnCharacter Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SpawnParams != nullptr)
		*SpawnParams = std::move(Parms.SpawnParams);
}


// Function DeadByDaylight.ScreenshotToolHook.PreSpawnCharm
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FCustomizationItemData&    Item                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void IScreenshotToolHook::PreSpawnCharm(const struct FCustomizationItemData& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ScreenshotToolHook", "PreSpawnCharm");

	Params::ScreenshotToolHook_PreSpawnCharm Parms{};

	Parms.Item = std::move(Item);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenshotToolHook.PreTakeItemScreenshot
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FCharacterToolItemData&    Item                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void IScreenshotToolHook::PreTakeItemScreenshot(const struct FCharacterToolItemData& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ScreenshotToolHook", "PreTakeItemScreenshot");

	Params::ScreenshotToolHook_PreTakeItemScreenshot Parms{};

	Parms.Item = std::move(Item);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenshotToolHook.ScreenshotBeginPlay
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    isPIE                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IScreenshotToolHook::ScreenshotBeginPlay(bool isPIE)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ScreenshotToolHook", "ScreenshotBeginPlay");

	Params::ScreenshotToolHook_ScreenshotBeginPlay Parms{};

	Parms.isPIE = isPIE;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenshotToolHook.IsPIEOnly
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IScreenshotToolHook::IsPIEOnly() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ScreenshotToolHook", "IsPIEOnly");

	Params::ScreenshotToolHook_IsPIEOnly Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SeanceRitualSpot.Authority_OnChargeApplied
// (Final, Native, Public)
// Parameters:
// float                                   IndividualChargeAmount                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TotalChargeAmount                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ChargeInstigator                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    WasCoop                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASeanceRitualSpot::Authority_OnChargeApplied(float IndividualChargeAmount, float TotalChargeAmount, class AActor* ChargeInstigator, bool WasCoop, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeanceRitualSpot", "Authority_OnChargeApplied");

	Params::SeanceRitualSpot_Authority_OnChargeApplied Parms{};

	Parms.IndividualChargeAmount = IndividualChargeAmount;
	Parms.TotalChargeAmount = TotalChargeAmount;
	Parms.ChargeInstigator = ChargeInstigator;
	Parms.WasCoop = WasCoop;
	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SeanceRitualSpot.Authority_OnPerformRitualChargePercentChanged
// (Final, Native, Public)
// Parameters:
// class UChargeableComponent*             ChargeableComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PercentCompletionChange                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TotalPercentComplete                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASeanceRitualSpot::Authority_OnPerformRitualChargePercentChanged(class UChargeableComponent* ChargeableComponent, float PercentCompletionChange, float TotalPercentComplete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeanceRitualSpot", "Authority_OnPerformRitualChargePercentChanged");

	Params::SeanceRitualSpot_Authority_OnPerformRitualChargePercentChanged Parms{};

	Parms.ChargeableComponent = ChargeableComponent;
	Parms.PercentCompletionChange = PercentCompletionChange;
	Parms.TotalPercentComplete = TotalPercentComplete;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SeanceRitualSpot.Cosmetic_OnInteractionCompleted
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void ASeanceRitualSpot::Cosmetic_OnInteractionCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeanceRitualSpot", "Cosmetic_OnInteractionCompleted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.SeanceRitualSpot.Cosmetic_OnInteractionUpdate
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// const class ADBDPlayer*                 interactingPlayer                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             ChargePercent                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASeanceRitualSpot::Cosmetic_OnInteractionUpdate(const class ADBDPlayer* interactingPlayer, const float ChargePercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeanceRitualSpot", "Cosmetic_OnInteractionUpdate");

	Params::SeanceRitualSpot_Cosmetic_OnInteractionUpdate Parms{};

	Parms.interactingPlayer = interactingPlayer;
	Parms.ChargePercent = ChargePercent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.SeanceRitualSpot.Cosmetic_OnStartedInteracting
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       interactingPlayer                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isOriginator                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASeanceRitualSpot::Cosmetic_OnStartedInteracting(class ADBDPlayer* interactingPlayer, bool isOriginator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeanceRitualSpot", "Cosmetic_OnStartedInteracting");

	Params::SeanceRitualSpot_Cosmetic_OnStartedInteracting Parms{};

	Parms.interactingPlayer = interactingPlayer;
	Parms.isOriginator = isOriginator;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.SeanceRitualSpot.Cosmetic_OnStoppedInteracting
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    interrupted                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASeanceRitualSpot::Cosmetic_OnStoppedInteracting(bool interrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeanceRitualSpot", "Cosmetic_OnStoppedInteracting");

	Params::SeanceRitualSpot_Cosmetic_OnStoppedInteracting Parms{};

	Parms.interrupted = interrupted;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.SeanceRitualSpot.Cosmetic_SurvivorsPerformingRitualUpdated
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void ASeanceRitualSpot::Cosmetic_SurvivorsPerformingRitualUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeanceRitualSpot", "Cosmetic_SurvivorsPerformingRitualUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.SeanceRitualSpot.Multicast_OnSeanceCompleted
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class ASurvivor*                        originator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASeanceRitualSpot::Multicast_OnSeanceCompleted(class ASurvivor* originator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeanceRitualSpot", "Multicast_OnSeanceCompleted");

	Params::SeanceRitualSpot_Multicast_OnSeanceCompleted Parms{};

	Parms.originator = originator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SeanceRitualSpot.OnFinishedRitual
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASeanceRitualSpot::OnFinishedRitual()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeanceRitualSpot", "OnFinishedRitual");

	Params::SeanceRitualSpot_OnFinishedRitual Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SeanceRitualSpot.OnRep_SurvivorsPerformingRitual
// (Final, Native, Protected)

void ASeanceRitualSpot::OnRep_SurvivorsPerformingRitual()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeanceRitualSpot", "OnRep_SurvivorsPerformingRitual");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SeanceRitualSpot.GetRitualPerformers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ASurvivor*>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ASurvivor*> ASeanceRitualSpot::GetRitualPerformers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeanceRitualSpot", "GetRitualPerformers");

	Params::SeanceRitualSpot_GetRitualPerformers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SeanceRitualSpot.IsSpotUsable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASeanceRitualSpot::IsSpotUsable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeanceRitualSpot", "IsSpotUsable");

	Params::SeanceRitualSpot_IsSpotUsable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherOutlineUpdateStrategy.OnLevelReadyToPlay
// (Final, Native, Private)

void USlasherOutlineUpdateStrategy::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherOutlineUpdateStrategy", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StalkerComponent.OnPlayerBeingStalkedChanged
// (Final, Native, Private)
// Parameters:
// bool                                    isBeingStalked                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStalkerComponent::OnPlayerBeingStalkedChanged(bool isBeingStalked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StalkerComponent", "OnPlayerBeingStalkedChanged");

	Params::StalkerComponent_OnPlayerBeingStalkedChanged Parms{};

	Parms.isBeingStalked = isBeingStalked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StalkerComponent.CanStalk
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStalkerComponent::CanStalk() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StalkerComponent", "CanStalk");

	Params::StalkerComponent_CanStalk Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StalkerComponent.GetMaxStalkingPoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UStalkerComponent::GetMaxStalkingPoints() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StalkerComponent", "GetMaxStalkingPoints");

	Params::StalkerComponent_GetMaxStalkingPoints Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StalkerComponent.GetPercentStalkingPoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UStalkerComponent::GetPercentStalkingPoints() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StalkerComponent", "GetPercentStalkingPoints");

	Params::StalkerComponent_GetPercentStalkingPoints Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StalkerComponent.GetScoreMultiplier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UStalkerComponent::GetScoreMultiplier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StalkerComponent", "GetScoreMultiplier");

	Params::StalkerComponent_GetScoreMultiplier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StalkerComponent.GetTotalStalkingPoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UStalkerComponent::GetTotalStalkingPoints() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StalkerComponent", "GetTotalStalkingPoints");

	Params::StalkerComponent_GetTotalStalkingPoints Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StalkerComponent.HasMaxStalkPoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStalkerComponent::HasMaxStalkPoints() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StalkerComponent", "HasMaxStalkPoints");

	Params::StalkerComponent_HasMaxStalkPoints Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StalkerComponent.IsStalkingSomeone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStalkerComponent::IsStalkingSomeone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StalkerComponent", "IsStalkingSomeone");

	Params::StalkerComponent_IsStalkingSomeone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StartScreenBase.BeginDestroyTravelSequence
// (Event, Public, BlueprintEvent)

void AStartScreenBase::BeginDestroyTravelSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StartScreenBase", "BeginDestroyTravelSequence");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.StartScreenBase.TravelToMenu
// (Final, Native, Public, BlueprintCallable)

void AStartScreenBase::TravelToMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StartScreenBase", "TravelToMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StateTagUtilities.AddStateTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const TScriptInterface<class IObjectStateProvider>ObjectStateProvider                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateTagUtilities::AddStateTag(const TScriptInterface<class IObjectStateProvider> ObjectStateProvider, const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StateTagUtilities", "AddStateTag");

	Params::StateTagUtilities_AddStateTag Parms{};

	Parms.ObjectStateProvider = ObjectStateProvider;
	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StateTagUtilities.AddStateTagToPlayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateTagUtilities::AddStateTagToPlayer(const class ADBDPlayer* Player, const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StateTagUtilities", "AddStateTagToPlayer");

	Params::StateTagUtilities_AddStateTagToPlayer Parms{};

	Parms.Player = Player;
	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StateTagUtilities.AddTagWithSource
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const TScriptInterface<class IObjectStateProvider>ObjectStateProvider                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UObject*                    Source                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateTagUtilities::AddTagWithSource(const TScriptInterface<class IObjectStateProvider> ObjectStateProvider, const struct FGameplayTag& Tag, const class UObject* Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StateTagUtilities", "AddTagWithSource");

	Params::StateTagUtilities_AddTagWithSource Parms{};

	Parms.ObjectStateProvider = ObjectStateProvider;
	Parms.Tag = std::move(Tag);
	Parms.Source = Source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StateTagUtilities.CurrentInteractionHasAnyStateTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     Tags                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStateTagUtilities::CurrentInteractionHasAnyStateTag(const class ADBDPlayer* Player, const struct FGameplayTagContainer& Tags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StateTagUtilities", "CurrentInteractionHasAnyStateTag");

	Params::StateTagUtilities_CurrentInteractionHasAnyStateTag Parms{};

	Parms.Player = Player;
	Parms.Tags = std::move(Tags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StateTagUtilities.CurrentInteractionHasStateTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStateTagUtilities::CurrentInteractionHasStateTag(const class ADBDPlayer* Player, const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StateTagUtilities", "CurrentInteractionHasStateTag");

	Params::StateTagUtilities_CurrentInteractionHasStateTag Parms{};

	Parms.Player = Player;
	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StateTagUtilities.HasAnyStateTags
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TScriptInterface<class IObjectStateProvider>ObjectStateProvider                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     Tags                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStateTagUtilities::HasAnyStateTags(const TScriptInterface<class IObjectStateProvider> ObjectStateProvider, const struct FGameplayTagContainer& Tags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StateTagUtilities", "HasAnyStateTags");

	Params::StateTagUtilities_HasAnyStateTags Parms{};

	Parms.ObjectStateProvider = ObjectStateProvider;
	Parms.Tags = std::move(Tags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StateTagUtilities.HasStateTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TScriptInterface<class IObjectStateProvider>ObjectStateProvider                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStateTagUtilities::HasStateTag(const TScriptInterface<class IObjectStateProvider> ObjectStateProvider, const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StateTagUtilities", "HasStateTag");

	Params::StateTagUtilities_HasStateTag Parms{};

	Parms.ObjectStateProvider = ObjectStateProvider;
	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StateTagUtilities.InteractionHasStateTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UInteractionDefinition*     Interaction                                            (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStateTagUtilities::InteractionHasStateTag(const class UInteractionDefinition* Interaction, const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StateTagUtilities", "InteractionHasStateTag");

	Params::StateTagUtilities_InteractionHasStateTag Parms{};

	Parms.Interaction = Interaction;
	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StateTagUtilities.RemoveStateTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const TScriptInterface<class IObjectStateProvider>ObjectStateProvider                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateTagUtilities::RemoveStateTag(const TScriptInterface<class IObjectStateProvider> ObjectStateProvider, const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StateTagUtilities", "RemoveStateTag");

	Params::StateTagUtilities_RemoveStateTag Parms{};

	Parms.ObjectStateProvider = ObjectStateProvider;
	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StateTagUtilities.RemoveStateTagToPlayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateTagUtilities::RemoveStateTagToPlayer(const class ADBDPlayer* Player, const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StateTagUtilities", "RemoveStateTagToPlayer");

	Params::StateTagUtilities_RemoveStateTagToPlayer Parms{};

	Parms.Player = Player;
	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StateTagUtilities.RemoveTagWithSource
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const TScriptInterface<class IObjectStateProvider>ObjectStateProvider                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UObject*                    Source                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateTagUtilities::RemoveTagWithSource(const TScriptInterface<class IObjectStateProvider> ObjectStateProvider, const struct FGameplayTag& Tag, const class UObject* Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StateTagUtilities", "RemoveTagWithSource");

	Params::StateTagUtilities_RemoveTagWithSource Parms{};

	Parms.ObjectStateProvider = ObjectStateProvider;
	Parms.Tag = std::move(Tag);
	Parms.Source = Source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SubtitlesManager.GetAudioEventNameFromLocalizedTextId
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    TextId                                                 (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USubtitlesManager::GetAudioEventNameFromLocalizedTextId(const class FString& TextId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SubtitlesManager", "GetAudioEventNameFromLocalizedTextId");

	Params::SubtitlesManager_GetAudioEventNameFromLocalizedTextId Parms{};

	Parms.TextId = std::move(TextId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SubtitlesManager.GetForcedAudioOrDialogLine
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USubtitlesManager::GetForcedAudioOrDialogLine()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SubtitlesManager", "GetForcedAudioOrDialogLine");

	Params::SubtitlesManager_GetForcedAudioOrDialogLine Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SubtitlesManager.HasAnimNotifyPlayedForThisMatch
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    AnimNotify                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USubtitlesManager::HasAnimNotifyPlayedForThisMatch(const class FString& AnimNotify)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SubtitlesManager", "HasAnimNotifyPlayedForThisMatch");

	Params::SubtitlesManager_HasAnimNotifyPlayedForThisMatch Parms{};

	Parms.AnimNotify = std::move(AnimNotify);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SubtitlesManager.IsDebuggingSubtitles
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USubtitlesManager::IsDebuggingSubtitles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SubtitlesManager", "IsDebuggingSubtitles");

	Params::SubtitlesManager_IsDebuggingSubtitles Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SubtitlesManager.Post2DAkEventWithSubtitles
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FAkEventWithSubtitle>&akEventRandomizer                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UAkAudioEvent**                   akEventPlayed                                          (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USubtitlesManager::Post2DAkEventWithSubtitles(const TArray<struct FAkEventWithSubtitle>& akEventRandomizer, class UAkAudioEvent** akEventPlayed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SubtitlesManager", "Post2DAkEventWithSubtitles");

	Params::SubtitlesManager_Post2DAkEventWithSubtitles Parms{};

	Parms.akEventRandomizer = std::move(akEventRandomizer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (akEventPlayed != nullptr)
		*akEventPlayed = Parms.akEventPlayed;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SubtitlesManager.PostAkEventWithSubtitles
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAkGameObject*                    Target                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FAkEventWithSubtitle>&akEventRandomizer                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   maxSubtitleDistance                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   callbackMask                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)>&postEventCallback                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent**                   akEventPlayed                                          (Parm, OutParm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USubtitlesManager::PostAkEventWithSubtitles(class UAkGameObject* Target, const TArray<struct FAkEventWithSubtitle>& akEventRandomizer, float maxSubtitleDistance, int32 callbackMask, const TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)>& postEventCallback, class UAkAudioEvent** akEventPlayed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SubtitlesManager", "PostAkEventWithSubtitles");

	Params::SubtitlesManager_PostAkEventWithSubtitles Parms{};

	Parms.Target = Target;
	Parms.akEventRandomizer = std::move(akEventRandomizer);
	Parms.maxSubtitleDistance = maxSubtitleDistance;
	Parms.callbackMask = callbackMask;
	Parms.postEventCallback = postEventCallback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (akEventPlayed != nullptr)
		*akEventPlayed = Parms.akEventPlayed;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SubtitlesManager.RecordAnimNotifyPlayedForThisMatch
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    AnimNotify                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USubtitlesManager::RecordAnimNotifyPlayedForThisMatch(const class FString& AnimNotify)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SubtitlesManager", "RecordAnimNotifyPlayedForThisMatch");

	Params::SubtitlesManager_RecordAnimNotifyPlayedForThisMatch Parms{};

	Parms.AnimNotify = std::move(AnimNotify);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SubtitlesManager.On3DEventCallback
// (Final, Native, Private)
// Parameters:
// EAkCallbackType                         CallbackType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkCallbackInfo*                  CallbackInfo                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USubtitlesManager::On3DEventCallback(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubtitlesManager", "On3DEventCallback");

	Params::SubtitlesManager_On3DEventCallback Parms{};

	Parms.CallbackType = CallbackType;
	Parms.CallbackInfo = CallbackInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurviveTimerScoreEventComponent.Authority_OnGameStarted
// (Final, Native, Private)

void USurviveTimerScoreEventComponent::Authority_OnGameStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurviveTimerScoreEventComponent", "Authority_OnGameStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorBloodTrailComponent.OnDamageStateChanged
// (Final, Native, Private)
// Parameters:
// EHealthState                            oldDamageState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHealthState                            currentDamageState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorBloodTrailComponent::OnDamageStateChanged(EHealthState oldDamageState, EHealthState currentDamageState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorBloodTrailComponent", "OnDamageStateChanged");

	Params::SurvivorBloodTrailComponent_OnDamageStateChanged Parms{};

	Parms.oldDamageState = oldDamageState;
	Parms.currentDamageState = currentDamageState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorExposerInstance.ExitSequenceComplete
// (Final, Native, Public, BlueprintCallable)

void ASurvivorExposerInstance::ExitSequenceComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorExposerInstance", "ExitSequenceComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorExposerInstance.OnRep_AggravationLevel
// (Final, Native, Protected)

void ASurvivorExposerInstance::OnRep_AggravationLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorExposerInstance", "OnRep_AggravationLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorExposerInstance.OnRep_OnAreaLocationChanged
// (Final, Native, Protected)
// Parameters:
// EExposerInstanceAreaLocation            OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASurvivorExposerInstance::OnRep_OnAreaLocationChanged(EExposerInstanceAreaLocation OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorExposerInstance", "OnRep_OnAreaLocationChanged");

	Params::SurvivorExposerInstance_OnRep_OnAreaLocationChanged Parms{};

	Parms.OldValue = OldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorExposerInstance.SetIsInteriorBP
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    interior                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASurvivorExposerInstance::SetIsInteriorBP(bool interior)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorExposerInstance", "SetIsInteriorBP");

	Params::SurvivorExposerInstance_SetIsInteriorBP Parms{};

	Parms.interior = interior;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.SurvivorExposerInstance.StartExitSequence
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    withRandomDelay                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASurvivorExposerInstance::StartExitSequence(bool withRandomDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorExposerInstance", "StartExitSequence");

	Params::SurvivorExposerInstance_StartExitSequence Parms{};

	Parms.withRandomDelay = withRandomDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorExposerInstance.StartSpawnSequence
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    withRandomDelay                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASurvivorExposerInstance::StartSpawnSequence(bool withRandomDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorExposerInstance", "StartSpawnSequence");

	Params::SurvivorExposerInstance_StartSpawnSequence Parms{};

	Parms.withRandomDelay = withRandomDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorExposerInstance.GetAreaLocation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EExposerInstanceAreaLocation            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EExposerInstanceAreaLocation ASurvivorExposerInstance::GetAreaLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorExposerInstance", "GetAreaLocation");

	Params::SurvivorExposerInstance_GetAreaLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SurvivorSlashableComponent.SetCrouchCapsuleHalfHeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorSlashableComponent::SetCrouchCapsuleHalfHeight(float Height)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorSlashableComponent", "SetCrouchCapsuleHalfHeight");

	Params::SurvivorSlashableComponent_SetCrouchCapsuleHalfHeight Parms{};

	Parms.Height = Height;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorSlashableComponent.SetHookSlashableZone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCapsuleComponent*                zone                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorSlashableComponent::SetHookSlashableZone(class UCapsuleComponent* zone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorSlashableComponent", "SetHookSlashableZone");

	Params::SurvivorSlashableComponent_SetHookSlashableZone Parms{};

	Parms.zone = zone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorSlashableComponent.SetSlashableZone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCapsuleComponent*                zone                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorSlashableComponent::SetSlashableZone(class UCapsuleComponent* zone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorSlashableComponent", "SetSlashableZone");

	Params::SurvivorSlashableComponent_SetSlashableZone Parms{};

	Parms.zone = zone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorSlashableComponent.SetStandingCapsuleHalfHeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorSlashableComponent::SetStandingCapsuleHalfHeight(float Height)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorSlashableComponent", "SetStandingCapsuleHalfHeight");

	Params::SurvivorSlashableComponent_SetStandingCapsuleHalfHeight Parms{};

	Parms.Height = Height;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorSlashableComponent.SetUseCrouchSlashableCapsule
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    useCrouchCapsule                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorSlashableComponent::SetUseCrouchSlashableCapsule(bool useCrouchCapsule)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorSlashableComponent", "SetUseCrouchSlashableCapsule");

	Params::SurvivorSlashableComponent_SetUseCrouchSlashableCapsule Parms{};

	Parms.useCrouchCapsule = useCrouchCapsule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorSpecialEventStatusIndicatorComponent.Cosmetic_OnStatusIndicatorShown
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void USurvivorSpecialEventStatusIndicatorComponent::Cosmetic_OnStatusIndicatorShown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorSpecialEventStatusIndicatorComponent", "Cosmetic_OnStatusIndicatorShown");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.SurvivorSpecialEventStatusIndicatorComponent.OnStatusChanged
// (Final, Native, Private)

void USurvivorSpecialEventStatusIndicatorComponent::OnStatusChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorSpecialEventStatusIndicatorComponent", "OnStatusChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TallyScreen.OnLeaveButtonClick
// (Final, Native, Protected)

void UTallyScreen::OnLeaveButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TallyScreen", "OnLeaveButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TallyScreen.OnLevelingSequenceComplete
// (Final, Native, Protected)

void UTallyScreen::OnLevelingSequenceComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TallyScreen", "OnLevelingSequenceComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TallyScreen.OnSpectateButtonClick
// (Final, Native, Protected)

void UTallyScreen::OnSpectateButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TallyScreen", "OnSpectateButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TallyScreen.OnUpdateUMGTallyScoreboardVisibility
// (Final, Native, Protected)
// Parameters:
// bool                                    IsVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTallyScreen::OnUpdateUMGTallyScoreboardVisibility(bool IsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TallyScreen", "OnUpdateUMGTallyScoreboardVisibility");

	Params::TallyScreen_OnUpdateUMGTallyScoreboardVisibility Parms{};

	Parms.IsVisible = IsVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TimerGate.AddTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATimerGate::AddTime(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimerGate", "AddTime");

	Params::TimerGate_AddTime Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TimerGate.RemoveTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATimerGate::RemoveTime(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimerGate", "RemoveTime");

	Params::TimerGate_RemoveTime Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TimerGate.Reset
// (Final, Native, Public, BlueprintCallable)

void ATimerGate::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimerGate", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TimerGate.Rushed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATimerGate::Rushed(bool Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimerGate", "Rushed");

	Params::TimerGate_Rushed Parms{};

	Parms.Success = Success;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TimerGate.SetValues
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TimerDuration                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RushGain                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RushBlockDuration                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATimerGate::SetValues(float TimerDuration, float RushGain, float RushBlockDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimerGate", "SetValues");

	Params::TimerGate_SetValues Parms{};

	Parms.TimerDuration = TimerDuration;
	Parms.RushGain = RushGain;
	Parms.RushBlockDuration = RushBlockDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TimerGate.Update
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATimerGate::Update(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimerGate", "Update");

	Params::TimerGate_Update Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TokenProvider.GetTokenProvider
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTokenCounter*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTokenCounter* ITokenProvider::GetTokenProvider() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("TokenProvider", "GetTokenProvider");

	Params::TokenProvider_GetTokenProvider Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ToolBoxInterface.GetChargerComponent
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UChargerComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChargerComponent* IToolBoxInterface::GetChargerComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ToolBoxInterface", "GetChargerComponent");

	Params::ToolBoxInterface_GetChargerComponent Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Totem.Authority_BindToPerk
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTotemBoundPerk*                  Perk                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATotem::Authority_BindToPerk(class UTotemBoundPerk* Perk)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "Authority_BindToPerk");

	Params::Totem_Authority_BindToPerk Parms{};

	Parms.Perk = Perk;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Totem.Authority_Cleanse
// (Final, Native, Public, BlueprintCallable)

void ATotem::Authority_Cleanse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "Authority_Cleanse");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Totem.Authority_UnbindFromAllPerks
// (Final, Native, Public, BlueprintCallable)

void ATotem::Authority_UnbindFromAllPerks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "Authority_UnbindFromAllPerks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Totem.Authority_UnbindFromPerk
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTotemBoundPerk*                  Perk                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATotem::Authority_UnbindFromPerk(class UTotemBoundPerk* Perk)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "Authority_UnbindFromPerk");

	Params::Totem_Authority_UnbindFromPerk Parms{};

	Parms.Perk = Perk;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Totem.OnBlockTotemCosmetic
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATotem::OnBlockTotemCosmetic(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "OnBlockTotemCosmetic");

	Params::Totem_OnBlockTotemCosmetic Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Totem.OnCleanseTotem
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ATotem*                           Totem                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ETotemState                       oldTotemState                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATotem::OnCleanseTotem(class ATotem* Totem, const ETotemState oldTotemState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "OnCleanseTotem");

	Params::Totem_OnCleanseTotem Parms{};

	Parms.Totem = Totem;
	Parms.oldTotemState = oldTotemState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Totem.OnLocallyObservedChanged
// (Final, Native, Private)

void ATotem::OnLocallyObservedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "OnLocallyObservedChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Totem.OnRep_TotemState
// (Final, Native, Private)
// Parameters:
// const ETotemState                       oldTotemState                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATotem::OnRep_TotemState(const ETotemState oldTotemState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "OnRep_TotemState");

	Params::Totem_OnRep_TotemState Parms{};

	Parms.oldTotemState = oldTotemState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Totem.OnTotemBlockChanged
// (Final, Native, Private)

void ATotem::OnTotemBlockChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "OnTotemBlockChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Totem.OnTotemStateChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// const ETotemState                       oldTotemState                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ETotemState                       newTotemState                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATotem::OnTotemStateChanged(const ETotemState oldTotemState, const ETotemState newTotemState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "OnTotemStateChanged");

	Params::Totem_OnTotemStateChanged Parms{};

	Parms.oldTotemState = oldTotemState;
	Parms.newTotemState = newTotemState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Totem.OnUnblockTotemCosmetic
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATotem::OnUnblockTotemCosmetic(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "OnUnblockTotemCosmetic");

	Params::Totem_OnUnblockTotemCosmetic Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Totem.GetAkAudioComponent
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class UAkComponent*                     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAkComponent* ATotem::GetAkAudioComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "GetAkAudioComponent");

	Params::Totem_GetAkAudioComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Totem.GetBlessTotemInteraction
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class UChargeableInteractionDefinition* ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChargeableInteractionDefinition* ATotem::GetBlessTotemInteraction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "GetBlessTotemInteraction");

	Params::Totem_GetBlessTotemInteraction Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Totem.GetBoonAuraRevealColor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor ATotem::GetBoonAuraRevealColor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "GetBoonAuraRevealColor");

	Params::Totem_GetBoonAuraRevealColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Totem.GetBoonTotemAuraRevealRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATotem::GetBoonTotemAuraRevealRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "GetBoonTotemAuraRevealRange");

	Params::Totem_GetBoonTotemAuraRevealRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Totem.GetBoonTotemBlessingRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATotem::GetBoonTotemBlessingRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "GetBoonTotemBlessingRange");

	Params::Totem_GetBoonTotemBlessingRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Totem.GetCleanseTotemInteraction
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class UChargeableInteractionDefinition* ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChargeableInteractionDefinition* ATotem::GetCleanseTotemInteraction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "GetCleanseTotemInteraction");

	Params::Totem_GetCleanseTotemInteraction Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Totem.GetMainInteractor
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// class UInteractor*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractor* ATotem::GetMainInteractor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "GetMainInteractor");

	Params::Totem_GetMainInteractor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Totem.GetTotemState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETotemState                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETotemState ATotem::GetTotemState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "GetTotemState");

	Params::Totem_GetTotemState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Totem.IsBoundToPerk
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATotem::IsBoundToPerk() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "IsBoundToPerk");

	Params::Totem_IsBoundToPerk Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Totem.IsTotemBlockedForPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATotem::IsTotemBlockedForPlayer(const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "IsTotemBlockedForPlayer");

	Params::Totem_IsTotemBlockedForPlayer Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TriggerableActivatorComponent.Authority_OnLevelReadyToPlay
// (Final, Native, Private)

void UTriggerableActivatorComponent::Authority_OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerableActivatorComponent", "Authority_OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialGameState.SetCurrentTutorialStep
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETutorialStep                           step                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialGameState::SetCurrentTutorialStep(ETutorialStep step)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialGameState", "SetCurrentTutorialStep");

	Params::TutorialGameState_SetCurrentTutorialStep Parms{};

	Parms.step = step;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialGameState.SetForcedHatchVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsHatchVisible_0                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialGameState::SetForcedHatchVisibility(bool IsHatchVisible_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialGameState", "SetForcedHatchVisibility");

	Params::TutorialGameState_SetForcedHatchVisibility Parms{};

	Parms.IsHatchVisible_0 = IsHatchVisible_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialGameState.TutorialEndReached
// (Final, Native, Public, BlueprintCallable)

void ATutorialGameState::TutorialEndReached()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialGameState", "TutorialEndReached");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialGameState.CompleteLocallyControlledCharacterIntros
// (Final, Native, Public, BlueprintCallable, Const)

void ATutorialGameState::CompleteLocallyControlledCharacterIntros() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialGameState", "CompleteLocallyControlledCharacterIntros");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialGameState.GetCurrentTutorialStep
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETutorialStep                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETutorialStep ATutorialGameState::GetCurrentTutorialStep() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialGameState", "GetCurrentTutorialStep");

	Params::TutorialGameState_GetCurrentTutorialStep Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TutorialGameState.IsTutorialStarted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATutorialGameState::IsTutorialStarted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialGameState", "IsTutorialStarted");

	Params::TutorialGameState_IsTutorialStarted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TutorialGameState.SetEscapeRequirementsVisibility
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// bool                                    IsVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialGameState::SetEscapeRequirementsVisibility(bool IsVisible) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialGameState", "SetEscapeRequirementsVisibility");

	Params::TutorialGameState_SetEscapeRequirementsVisibility Parms{};

	Parms.IsVisible = IsVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialHighlightController.SetHudComponentHighlight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHudComponent                           hudComponent                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Show                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialHighlightController::SetHudComponentHighlight(EHudComponent hudComponent, bool Show)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialHighlightController", "SetHudComponentHighlight");

	Params::TutorialHighlightController_SetHudComponentHighlight Parms{};

	Parms.hudComponent = hudComponent;
	Parms.Show = Show;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialNotificationController.HideNotification
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    removeAllCachedNotifs                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialNotificationController::HideNotification(bool removeAllCachedNotifs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialNotificationController", "HideNotification");

	Params::TutorialNotificationController_HideNotification Parms{};

	Parms.removeAllCachedNotifs = removeAllCachedNotifs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialNotificationController.OnBlockingNotificationDismissed
// (Final, Native, Private)

void UTutorialNotificationController::OnBlockingNotificationDismissed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialNotificationController", "OnBlockingNotificationDismissed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialNotificationController.ShowBlockingNotification
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             tutorialNotificationId                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialNotificationController::ShowBlockingNotification(class FName tutorialNotificationId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialNotificationController", "ShowBlockingNotification");

	Params::TutorialNotificationController_ShowBlockingNotification Parms{};

	Parms.tutorialNotificationId = tutorialNotificationId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialNotificationController.ShowNotification
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             tutorialNotificationId                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialNotificationController::ShowNotification(class FName tutorialNotificationId, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialNotificationController", "ShowNotification");

	Params::TutorialNotificationController_ShowNotification Parms{};

	Parms.tutorialNotificationId = tutorialNotificationId;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialObjectiveController.AddObjective
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             tutorialObjectiveId                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialObjectiveController::AddObjective(class FName tutorialObjectiveId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialObjectiveController", "AddObjective");

	Params::TutorialObjectiveController_AddObjective Parms{};

	Parms.tutorialObjectiveId = tutorialObjectiveId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialObjectiveController.CompleteObjective
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             tutorialObjectiveId                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    removeAfterCompletion                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialObjectiveController::CompleteObjective(class FName tutorialObjectiveId, bool removeAfterCompletion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialObjectiveController", "CompleteObjective");

	Params::TutorialObjectiveController_CompleteObjective Parms{};

	Parms.tutorialObjectiveId = tutorialObjectiveId;
	Parms.removeAfterCompletion = removeAfterCompletion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialObjectiveController.RemoveAllObjectives
// (Final, Native, Public, BlueprintCallable)

void UTutorialObjectiveController::RemoveAllObjectives()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialObjectiveController", "RemoveAllObjectives");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialObjectiveController.RemoveObjective
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             tutorialObjectiveId                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialObjectiveController::RemoveObjective(class FName tutorialObjectiveId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialObjectiveController", "RemoveObjective");

	Params::TutorialObjectiveController_RemoveObjective Parms{};

	Parms.tutorialObjectiveId = tutorialObjectiveId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UIController.DrawBlockingArea
// (Final, Native, Public, HasOutParams)
// Parameters:
// const class FString&                    ID                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGeometry&                 Geometry                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UUIController::DrawBlockingArea(const class FString& ID, const struct FGeometry& Geometry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIController", "DrawBlockingArea");

	Params::UIController_DrawBlockingArea Parms{};

	Parms.ID = std::move(ID);
	Parms.Geometry = std::move(Geometry);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UIController.RemoveBlockingArea
// (Final, Native, Public)
// Parameters:
// const class FString&                    ID                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIController::RemoveBlockingArea(const class FString& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIController", "RemoveBlockingArea");

	Params::UIController_RemoveBlockingArea Parms{};

	Parms.ID = std::move(ID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGDragWidget.SetClampToViewportDirty
// (Final, Native, Public, BlueprintCallable)

void UUMGDragWidget::SetClampToViewportDirty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGDragWidget", "SetClampToViewportDirty");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGDragWidget.GetAllEditableWidgets
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class UCustomWidgetWrapper_HudEditor*>ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TArray<class UCustomWidgetWrapper_HudEditor*> UUMGDragWidget::GetAllEditableWidgets() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGDragWidget", "GetAllEditableWidgets");

	Params::UMGDragWidget_GetAllEditableWidgets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGDragWidget_HudEditor.SetOnSelection
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsSelected                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGDragWidget_HudEditor::SetOnSelection(bool IsSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGDragWidget_HudEditor", "SetOnSelection");

	Params::UMGDragWidget_HudEditor_SetOnSelection Parms{};

	Parms.IsSelected = IsSelected;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGDragWidget_HudEditor.GetCustomWrapper
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCustomWidgetWrapper_HudEditor*   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCustomWidgetWrapper_HudEditor* UUMGDragWidget_HudEditor::GetCustomWrapper() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGDragWidget_HudEditor", "GetCustomWrapper");

	Params::UMGDragWidget_HudEditor_GetCustomWrapper Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGHtmlRichText.SetHTMLText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InText                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGHtmlRichText::SetHTMLText(const class FString& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHtmlRichText", "SetHTMLText");

	Params::UMGHtmlRichText_SetHTMLText Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGHudEditorLayoutWidget.FlagSaveAsDirty
// (Final, Native, Public, BlueprintCallable)

void UUMGHudEditorLayoutWidget::FlagSaveAsDirty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorLayoutWidget", "FlagSaveAsDirty");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGHudEditorLayoutWidget.FlipLayout
// (Final, Native, Public, BlueprintCallable)

void UUMGHudEditorLayoutWidget::FlipLayout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorLayoutWidget", "FlipLayout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGHudEditorLayoutWidget.OnSaveDirty
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsDirty                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGHudEditorLayoutWidget::OnSaveDirty(bool IsDirty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorLayoutWidget", "OnSaveDirty");

	Params::UMGHudEditorLayoutWidget_OnSaveDirty Parms{};

	Parms.IsDirty = IsDirty;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGHudEditorLayoutWidget.ResetLayout
// (Final, Native, Public, BlueprintCallable)

void UUMGHudEditorLayoutWidget::ResetLayout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorLayoutWidget", "ResetLayout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGHudEditorLayoutWidget.SaveLayout
// (Final, Native, Public, BlueprintCallable)

void UUMGHudEditorLayoutWidget::SaveLayout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorLayoutWidget", "SaveLayout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGHudEditorLayoutWidget.SetHudEditorScreen
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UUMGHudEditorScreen*              hudEditorScreen_0                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGHudEditorLayoutWidget::SetHudEditorScreen(class UUMGHudEditorScreen* hudEditorScreen_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorLayoutWidget", "SetHudEditorScreen");

	Params::UMGHudEditorLayoutWidget_SetHudEditorScreen Parms{};

	Parms.hudEditorScreen_0 = hudEditorScreen_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGHudEditorLayoutWidget.SetSaveOverlapSound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAkAudioEvent*                    onSaveOverlapSound                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGHudEditorLayoutWidget::SetSaveOverlapSound(class UAkAudioEvent* onSaveOverlapSound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorLayoutWidget", "SetSaveOverlapSound");

	Params::UMGHudEditorLayoutWidget_SetSaveOverlapSound Parms{};

	Parms.onSaveOverlapSound = onSaveOverlapSound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGHudEditorLayoutWidget.SetWidgetToEdit
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UUMGDragWidget_HudEditor*         Widget                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGHudEditorLayoutWidget::SetWidgetToEdit(class UUMGDragWidget_HudEditor* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorLayoutWidget", "SetWidgetToEdit");

	Params::UMGHudEditorLayoutWidget_SetWidgetToEdit Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGHudEditorLayoutWidget.ShowKillerLayout
// (Final, Native, Public, BlueprintCallable)

void UUMGHudEditorLayoutWidget::ShowKillerLayout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorLayoutWidget", "ShowKillerLayout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGHudEditorLayoutWidget.ShowSurvivorLayout
// (Final, Native, Public, BlueprintCallable)

void UUMGHudEditorLayoutWidget::ShowSurvivorLayout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorLayoutWidget", "ShowSurvivorLayout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGHudEditorLayoutWidget.GetCurrentDragWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UUMGDragWidget_HudEditor*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUMGDragWidget_HudEditor* UUMGHudEditorLayoutWidget::GetCurrentDragWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorLayoutWidget", "GetCurrentDragWidget");

	Params::UMGHudEditorLayoutWidget_GetCurrentDragWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGHudEditorLayoutWidget.GetHudEditorWrapperToEdit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCustomWidgetWrapper_HudEditor*   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCustomWidgetWrapper_HudEditor* UUMGHudEditorLayoutWidget::GetHudEditorWrapperToEdit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorLayoutWidget", "GetHudEditorWrapperToEdit");

	Params::UMGHudEditorLayoutWidget_GetHudEditorWrapperToEdit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGHudEditorScreen.Quit
// (Final, Native, Public, BlueprintCallable)

void UUMGHudEditorScreen::Quit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorScreen", "Quit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGHudEditorScreen.RegisterEditorLayoutScreen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPlayerRole                             Role                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUMGHudEditorLayoutScreen*        screen                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGHudEditorScreen::RegisterEditorLayoutScreen(EPlayerRole Role, class UUMGHudEditorLayoutScreen* screen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorScreen", "RegisterEditorLayoutScreen");

	Params::UMGHudEditorScreen_RegisterEditorLayoutScreen Parms{};

	Parms.Role = Role;
	Parms.screen = screen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGHudEditorScreen.SetEditorDropErrorOverlapSound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAkAudioEvent*                    onDropOverlapSound                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGHudEditorScreen::SetEditorDropErrorOverlapSound(class UAkAudioEvent* onDropOverlapSound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorScreen", "SetEditorDropErrorOverlapSound");

	Params::UMGHudEditorScreen_SetEditorDropErrorOverlapSound Parms{};

	Parms.onDropOverlapSound = onDropOverlapSound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGHudEditorScreen.SetWidgets
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UUMGHudEditorLayoutWidget*        hudEditorLayoutWidget                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUMGHudEditorVersionWidget*       versionSwapWidget                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGHudEditorScreen::SetWidgets(class UUMGHudEditorLayoutWidget* hudEditorLayoutWidget, class UUMGHudEditorVersionWidget* versionSwapWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorScreen", "SetWidgets");

	Params::UMGHudEditorScreen_SetWidgets Parms{};

	Parms.hudEditorLayoutWidget = hudEditorLayoutWidget;
	Parms.versionSwapWidget = versionSwapWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGHudEditorScreen.ShowHudLayout
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPlayerRole                             Role                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGHudEditorScreen::ShowHudLayout(EPlayerRole Role)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorScreen", "ShowHudLayout");

	Params::UMGHudEditorScreen_ShowHudLayout Parms{};

	Parms.Role = Role;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGHudEditorScreen.GetVersionSwapWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UUMGHudEditorVersionWidget*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUMGHudEditorVersionWidget* UUMGHudEditorScreen::GetVersionSwapWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorScreen", "GetVersionSwapWidget");

	Params::UMGHudEditorScreen_GetVersionSwapWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.VaultableComponent.OnChaseEnded
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       survivorPlayer                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ChaseTimer                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVaultableComponent::OnChaseEnded(class ADBDPlayer* survivorPlayer, float ChaseTimer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VaultableComponent", "OnChaseEnded");

	Params::VaultableComponent_OnChaseEnded Parms{};

	Parms.survivorPlayer = survivorPlayer;
	Parms.ChaseTimer = ChaseTimer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.VaultableComponent.SignalVault
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InteractionTime                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVaultableComponent::SignalVault(class ADBDPlayer* Survivor, float InteractionTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VaultableComponent", "SignalVault");

	Params::VaultableComponent_SignalVault Parms{};

	Parms.Survivor = Survivor;
	Parms.InteractionTime = InteractionTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.VomitStateComponent.SetObjectState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameplayTagContainerComponent*   objectState                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVomitStateComponent::SetObjectState(class UGameplayTagContainerComponent* objectState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VomitStateComponent", "SetObjectState");

	Params::VomitStateComponent_SetObjectState Parms{};

	Parms.objectState = objectState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.VomitStateComponent.SetVomitState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELinkedVomitState                       newVomitState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVomitStateComponent::SetVomitState(ELinkedVomitState newVomitState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VomitStateComponent", "SetVomitState");

	Params::VomitStateComponent_SetVomitState Parms{};

	Parms.newVomitState = newVomitState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.VomitStateComponent.GetVomitState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELinkedVomitState                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELinkedVomitState UVomitStateComponent::GetVomitState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VomitStateComponent", "GetVomitState");

	Params::VomitStateComponent_GetVomitState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.VomitStateComponent.IsVomiting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVomitStateComponent::IsVomiting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VomitStateComponent", "IsVomiting");

	Params::VomitStateComponent_IsVomiting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.WCSRComponent.Client_PlayBreakSound
// (Final, Net, NetReliable, Native, Event, Private, NetClient)

void UWCSRComponent::Client_PlayBreakSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WCSRComponent", "Client_PlayBreakSound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ZoneDetectorComponent.OnOverlapEnter
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UZoneDetectorComponent::OnOverlapEnter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZoneDetectorComponent", "OnOverlapEnter");

	Params::ZoneDetectorComponent_OnOverlapEnter Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ZoneDetectorComponent.OnOverlapExit
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UZoneDetectorComponent::OnOverlapExit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZoneDetectorComponent", "OnOverlapExit");

	Params::ZoneDetectorComponent_OnOverlapExit Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

