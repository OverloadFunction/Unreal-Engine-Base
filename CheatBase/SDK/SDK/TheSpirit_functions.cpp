#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheSpirit

#include "Basic.hpp"

#include "TheSpirit_classes.hpp"
#include "TheSpirit_parameters.hpp"


namespace SDK
{

// Function TheSpirit.PhaseWalkingComponent.Authority_SetIsInPostActivePhaseWalk
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhaseWalkingComponent::Authority_SetIsInPostActivePhaseWalk(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "Authority_SetIsInPostActivePhaseWalk");

	Params::PhaseWalkingComponent_Authority_SetIsInPostActivePhaseWalk Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.PhaseWalkingComponent.DBD_RefillActivePhaseWalkCharges
// (Final, Exec, Native, Private)

void UPhaseWalkingComponent::DBD_RefillActivePhaseWalkCharges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "DBD_RefillActivePhaseWalkCharges");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.PhaseWalkingComponent.Local_EndPhaseWalks
// (Final, Native, Public, BlueprintCallable)

void UPhaseWalkingComponent::Local_EndPhaseWalks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "Local_EndPhaseWalks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.PhaseWalkingComponent.MakePassivePhaseWalkHusksVisible
// (Event, Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FTransform&                huskTransform                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   opacityValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   speedValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhaseWalkingComponent::MakePassivePhaseWalkHusksVisible(const struct FTransform& huskTransform, float opacityValue, float speedValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "MakePassivePhaseWalkHusksVisible");

	Params::PhaseWalkingComponent_MakePassivePhaseWalkHusksVisible Parms{};

	Parms.huskTransform = std::move(huskTransform);
	Parms.opacityValue = opacityValue;
	Parms.speedValue = speedValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheSpirit.PhaseWalkingComponent.ModifyActivePhaseWalkCharges
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhaseWalkingComponent::ModifyActivePhaseWalkCharges(float Delta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "ModifyActivePhaseWalkCharges");

	Params::PhaseWalkingComponent_ModifyActivePhaseWalkCharges Parms{};

	Parms.Delta = Delta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.PhaseWalkingComponent.Multicast_Broadcast_PhaseWalk
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const struct FPhaseWalkInfo&            PhaseWalkInfo                                          (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UPhaseWalkingComponent::Multicast_Broadcast_PhaseWalk(const struct FPhaseWalkInfo& PhaseWalkInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "Multicast_Broadcast_PhaseWalk");

	Params::PhaseWalkingComponent_Multicast_Broadcast_PhaseWalk Parms{};

	Parms.PhaseWalkInfo = std::move(PhaseWalkInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.PhaseWalkingComponent.OnInRangeToKillerChanged
// (Final, Native, Private)
// Parameters:
// const bool                              inRange                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AKiller*                          Killer                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhaseWalkingComponent::OnInRangeToKillerChanged(const bool inRange, class AKiller* Killer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "OnInRangeToKillerChanged");

	Params::PhaseWalkingComponent_OnInRangeToKillerChanged Parms{};

	Parms.inRange = inRange;
	Parms.Killer = Killer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.PhaseWalkingComponent.OnLevelReadyToPlay
// (Final, Native, Private)

void UPhaseWalkingComponent::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.PhaseWalkingComponent.OnRep_Husk
// (Final, Native, Private)

void UPhaseWalkingComponent::OnRep_Husk()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "OnRep_Husk");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.PhaseWalkingComponent.RefillActivePhaseWalkCharges
// (Final, Native, Protected, BlueprintCallable)

void UPhaseWalkingComponent::RefillActivePhaseWalkCharges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "RefillActivePhaseWalkCharges");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.PhaseWalkingComponent.Server_Broadcast_PhaseWalk
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const struct FPhaseWalkInfo&            PhaseWalkInfo                                          (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UPhaseWalkingComponent::Server_Broadcast_PhaseWalk(const struct FPhaseWalkInfo& PhaseWalkInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "Server_Broadcast_PhaseWalk");

	Params::PhaseWalkingComponent_Server_Broadcast_PhaseWalk Parms{};

	Parms.PhaseWalkInfo = std::move(PhaseWalkInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.PhaseWalkingComponent.SpawnPassivePhaseWalkHusks
// (Event, Protected, BlueprintEvent)

void UPhaseWalkingComponent::SpawnPassivePhaseWalkHusks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "SpawnPassivePhaseWalkHusks");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TheSpirit.PhaseWalkingComponent.UpdateKillerVisibility
// (Final, Native, Public, BlueprintCallable)

void UPhaseWalkingComponent::UpdateKillerVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "UpdateKillerVisibility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.PhaseWalkingComponent.UpdateSurvivorVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Visible                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhaseWalkingComponent::UpdateSurvivorVisibility(bool Visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "UpdateSurvivorVisibility");

	Params::PhaseWalkingComponent_UpdateSurvivorVisibility Parms{};

	Parms.Visible = Visible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.PhaseWalkingComponent.CanStartActivePhaseWalk
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhaseWalkingComponent::CanStartActivePhaseWalk() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "CanStartActivePhaseWalk");

	Params::PhaseWalkingComponent_CanStartActivePhaseWalk Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheSpirit.PhaseWalkingComponent.GetActivePhaseWalkChargePercentage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPhaseWalkingComponent::GetActivePhaseWalkChargePercentage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "GetActivePhaseWalkChargePercentage");

	Params::PhaseWalkingComponent_GetActivePhaseWalkChargePercentage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheSpirit.PhaseWalkingComponent.GetActivePhaseWalkCharges
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPhaseWalkingComponent::GetActivePhaseWalkCharges() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "GetActivePhaseWalkCharges");

	Params::PhaseWalkingComponent_GetActivePhaseWalkCharges Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheSpirit.PhaseWalkingComponent.GetHusk
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UPhaseWalkingComponent::GetHusk() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "GetHusk");

	Params::PhaseWalkingComponent_GetHusk Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheSpirit.PhaseWalkingComponent.GetPassivePhaseWalkTimer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FDBDTimer                  ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FDBDTimer UPhaseWalkingComponent::GetPassivePhaseWalkTimer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "GetPassivePhaseWalkTimer");

	Params::PhaseWalkingComponent_GetPassivePhaseWalkTimer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheSpirit.PhaseWalkingComponent.GetSpiritPassivePhaseWalkHusksCountToSpawn
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPhaseWalkingComponent::GetSpiritPassivePhaseWalkHusksCountToSpawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "GetSpiritPassivePhaseWalkHusksCountToSpawn");

	Params::PhaseWalkingComponent_GetSpiritPassivePhaseWalkHusksCountToSpawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheSpirit.PhaseWalkingComponent.IsActivePhaseWalking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhaseWalkingComponent::IsActivePhaseWalking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "IsActivePhaseWalking");

	Params::PhaseWalkingComponent_IsActivePhaseWalking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheSpirit.PhaseWalkingComponent.IsHuskActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhaseWalkingComponent::IsHuskActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "IsHuskActive");

	Params::PhaseWalkingComponent_IsHuskActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheSpirit.PhaseWalkingComponent.IsPassivePhaseWalking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhaseWalkingComponent::IsPassivePhaseWalking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "IsPassivePhaseWalking");

	Params::PhaseWalkingComponent_IsPassivePhaseWalking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheSpirit.PhaseWalkingComponent.IsPhaseWalking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhaseWalkingComponent::IsPhaseWalking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "IsPhaseWalking");

	Params::PhaseWalkingComponent_IsPhaseWalking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheSpirit.ActivePhaseWalkInteraction.Cosmetic_ResetChargeVFX
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActivePhaseWalkInteraction::Cosmetic_ResetChargeVFX(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActivePhaseWalkInteraction", "Cosmetic_ResetChargeVFX");

	Params::ActivePhaseWalkInteraction_Cosmetic_ResetChargeVFX Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheSpirit.ActivePhaseWalkInteraction.OnPlayerLocallyObservedChanged
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActivePhaseWalkInteraction::OnPlayerLocallyObservedChanged(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActivePhaseWalkInteraction", "OnPlayerLocallyObservedChanged");

	Params::ActivePhaseWalkInteraction_OnPlayerLocallyObservedChanged Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.ActivePhaseWalkInteraction.OnPowerCollected
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       collector                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActivePhaseWalkInteraction::OnPowerCollected(class ADBDPlayer* collector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActivePhaseWalkInteraction", "OnPowerCollected");

	Params::ActivePhaseWalkInteraction_OnPowerCollected Parms{};

	Parms.collector = collector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.ActivePhaseWalkInteraction.GetChargeTime
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UActivePhaseWalkInteraction::GetChargeTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActivePhaseWalkInteraction", "GetChargeTime");

	Params::ActivePhaseWalkInteraction_GetChargeTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheSpirit.Rancor.SpawnBubbleAtSurvivorsLocation
// (Event, Protected, BlueprintEvent)

void URancor::SpawnBubbleAtSurvivorsLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Rancor", "SpawnBubbleAtSurvivorsLocation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TheSpirit.Rancor.GetKillerRevealToObsessionDurationAtLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URancor::GetKillerRevealToObsessionDurationAtLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Rancor", "GetKillerRevealToObsessionDurationAtLevel");

	Params::Rancor_GetKillerRevealToObsessionDurationAtLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheSpirit.Rancor.GetSurvivorRevealDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URancor::GetSurvivorRevealDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Rancor", "GetSurvivorRevealDuration");

	Params::Rancor_GetSurvivorRevealDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheSpirit.OwningPlayerInSpiritHuskRange.OnKillerSet
// (Final, Native, Public)
// Parameters:
// class AKiller*                          Killer                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOwningPlayerInSpiritHuskRange::OnKillerSet(class AKiller* Killer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OwningPlayerInSpiritHuskRange", "OnKillerSet");

	Params::OwningPlayerInSpiritHuskRange_OnKillerSet Parms{};

	Parms.Killer = Killer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.SpiritFury.GetPalletToBreakCountAtLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USpiritFury::GetPalletToBreakCountAtLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpiritFury", "GetPalletToBreakCountAtLevel");

	Params::SpiritFury_GetPalletToBreakCountAtLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheSpirit.SpiritHusk.ActivateHusk
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FTransform&                Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpiritHusk::ActivateHusk(const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpiritHusk", "ActivateHusk");

	Params::SpiritHusk_ActivateHusk Parms{};

	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.SpiritHusk.Cosmetic_OnHuskVisibilityChanged
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    IsVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpiritHusk::Cosmetic_OnHuskVisibilityChanged(bool IsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpiritHusk", "Cosmetic_OnHuskVisibilityChanged");

	Params::SpiritHusk_Cosmetic_OnHuskVisibilityChanged Parms{};

	Parms.IsVisible = IsVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheSpirit.SpiritHusk.DeactivateHusk
// (Final, Native, Public, BlueprintCallable)

void ASpiritHusk::DeactivateHusk()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpiritHusk", "DeactivateHusk");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.SpiritHusk.Multicast_HuskStunned
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ASpiritHusk::Multicast_HuskStunned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpiritHusk", "Multicast_HuskStunned");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.SpiritHusk.OnIntroCompleted
// (Final, Native, Private)

void ASpiritHusk::OnIntroCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpiritHusk", "OnIntroCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.SpiritHusk.OnKillerTerrorRadiusChanged
// (Final, Native, Private)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpiritHusk::OnKillerTerrorRadiusChanged(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpiritHusk", "OnKillerTerrorRadiusChanged");

	Params::SpiritHusk_OnKillerTerrorRadiusChanged Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.SpiritHuskOutlineUpdateStrategy.OnIntroCompleted
// (Final, Native, Private)

void USpiritHuskOutlineUpdateStrategy::OnIntroCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpiritHuskOutlineUpdateStrategy", "OnIntroCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}

}

