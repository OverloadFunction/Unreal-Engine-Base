#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DBDUIViewInterfaces

#include "Basic.hpp"

#include "RemoteContentCache_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "NewsAndMessagesCommon_structs.hpp"
#include "DBDSharedTypes_structs.hpp"
#include "DBDUIViewInterfaces_structs.hpp"
#include "Engine_classes.hpp"
#include "UMG_structs.hpp"


namespace SDK
{

// Class DBDUIViewInterfaces.AddonViewInterface
// 0x0000 (0x0000 - 0x0000)
class IAddonViewInterface final
{
public:
	void ClearData();
	void SetData(const struct FAddonViewData& BaseLoadoutPartViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddonViewInterface">();
	}
	static class IAddonViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAddonViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IAddonViewInterface) == 0x000001, "Wrong alignment on IAddonViewInterface");
static_assert(sizeof(IAddonViewInterface) == 0x000001, "Wrong size on IAddonViewInterface");

// Class DBDUIViewInterfaces.AlertsViewInterface
// 0x0000 (0x0000 - 0x0000)
class IAlertsViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AlertsViewInterface">();
	}
	static class IAlertsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAlertsViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IAlertsViewInterface) == 0x000001, "Wrong alignment on IAlertsViewInterface");
static_assert(sizeof(IAlertsViewInterface) == 0x000001, "Wrong size on IAlertsViewInterface");

// Class DBDUIViewInterfaces.BasePopupViewData
// 0x0040 (0x0070 - 0x0030)
class UBasePopupViewData : public UObject
{
public:
	EPopupPriority                                Priority;                                          // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0038(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Message;                                           // 0x0050(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          DisplayBackgroundOverlay;                          // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePopupViewData">();
	}
	static class UBasePopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBasePopupViewData>();
	}
};
static_assert(alignof(UBasePopupViewData) == 0x000008, "Wrong alignment on UBasePopupViewData");
static_assert(sizeof(UBasePopupViewData) == 0x000070, "Wrong size on UBasePopupViewData");
static_assert(offsetof(UBasePopupViewData, Priority) == 0x000030, "Member 'UBasePopupViewData::Priority' has a wrong offset!");
static_assert(offsetof(UBasePopupViewData, Title) == 0x000038, "Member 'UBasePopupViewData::Title' has a wrong offset!");
static_assert(offsetof(UBasePopupViewData, Message) == 0x000050, "Member 'UBasePopupViewData::Message' has a wrong offset!");
static_assert(offsetof(UBasePopupViewData, DisplayBackgroundOverlay) == 0x000068, "Member 'UBasePopupViewData::DisplayBackgroundOverlay' has a wrong offset!");

// Class DBDUIViewInterfaces.GenericPopupViewData
// 0x0180 (0x01F0 - 0x0070)
class UGenericPopupViewData : public UBasePopupViewData
{
public:
	struct FPopupButtonViewData                   ProgressionData;                                   // 0x0070(0x0080)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPopupButtonViewData                   RegressionData;                                    // 0x00F0(0x0080)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPopupButtonViewData                   AlternativeData;                                   // 0x0170(0x0080)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericPopupViewData">();
	}
	static class UGenericPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGenericPopupViewData>();
	}
};
static_assert(alignof(UGenericPopupViewData) == 0x000010, "Wrong alignment on UGenericPopupViewData");
static_assert(sizeof(UGenericPopupViewData) == 0x0001F0, "Wrong size on UGenericPopupViewData");
static_assert(offsetof(UGenericPopupViewData, ProgressionData) == 0x000070, "Member 'UGenericPopupViewData::ProgressionData' has a wrong offset!");
static_assert(offsetof(UGenericPopupViewData, RegressionData) == 0x0000F0, "Member 'UGenericPopupViewData::RegressionData' has a wrong offset!");
static_assert(offsetof(UGenericPopupViewData, AlternativeData) == 0x000170, "Member 'UGenericPopupViewData::AlternativeData' has a wrong offset!");

// Class DBDUIViewInterfaces.GenericRefreshingPopupViewData
// 0x0050 (0x0240 - 0x01F0)
class UGenericRefreshingPopupViewData final : public UGenericPopupViewData
{
public:
	float                                         RefreshingIntervalsTime;                           // 0x01F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeoutTime;                                       // 0x01F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F8[0x48];                                     // 0x01F8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericRefreshingPopupViewData">();
	}
	static class UGenericRefreshingPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGenericRefreshingPopupViewData>();
	}
};
static_assert(alignof(UGenericRefreshingPopupViewData) == 0x000010, "Wrong alignment on UGenericRefreshingPopupViewData");
static_assert(sizeof(UGenericRefreshingPopupViewData) == 0x000240, "Wrong size on UGenericRefreshingPopupViewData");
static_assert(offsetof(UGenericRefreshingPopupViewData, RefreshingIntervalsTime) == 0x0001F0, "Member 'UGenericRefreshingPopupViewData::RefreshingIntervalsTime' has a wrong offset!");
static_assert(offsetof(UGenericRefreshingPopupViewData, TimeoutTime) == 0x0001F4, "Member 'UGenericRefreshingPopupViewData::TimeoutTime' has a wrong offset!");

// Class DBDUIViewInterfaces.AnimationPreviewViewInterface
// 0x0000 (0x0000 - 0x0000)
class IAnimationPreviewViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationPreviewViewInterface">();
	}
	static class IAnimationPreviewViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAnimationPreviewViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IAnimationPreviewViewInterface) == 0x000001, "Wrong alignment on IAnimationPreviewViewInterface");
static_assert(sizeof(IAnimationPreviewViewInterface) == 0x000001, "Wrong size on IAnimationPreviewViewInterface");

// Class DBDUIViewInterfaces.KillerStatusData
// 0x0000 (0x0030 - 0x0030)
class UKillerStatusData : public UObject
{
public:
	bool IsEqual(const class UKillerStatusData* Other) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerStatusData">();
	}
	static class UKillerStatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerStatusData>();
	}
};
static_assert(alignof(UKillerStatusData) == 0x000008, "Wrong alignment on UKillerStatusData");
static_assert(sizeof(UKillerStatusData) == 0x000030, "Wrong size on UKillerStatusData");

// Class DBDUIViewInterfaces.ArchiveCompendiumViewInterface
// 0x0000 (0x0000 - 0x0000)
class IArchiveCompendiumViewInterface final
{
public:
	void SetPastTomesViewData(const TArray<struct FCompendiumButtonData>& pastStoryButtonData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveCompendiumViewInterface">();
	}
	static class IArchiveCompendiumViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IArchiveCompendiumViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IArchiveCompendiumViewInterface) == 0x000001, "Wrong alignment on IArchiveCompendiumViewInterface");
static_assert(sizeof(IArchiveCompendiumViewInterface) == 0x000001, "Wrong size on IArchiveCompendiumViewInterface");

// Class DBDUIViewInterfaces.ArchiveImageViewerViewInterface
// 0x0000 (0x0000 - 0x0000)
class IArchiveImageViewerViewInterface final
{
public:
	void SetTextVisibility(bool Visible);
	void SetVoiceOverAutoplay(bool voiceOverAutoplay);
	void SetVoiceOverPlaying(bool voiceOverPlaying);
	void UpdateContent(const struct FArchivesVignetteEntryViewData& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveImageViewerViewInterface">();
	}
	static class IArchiveImageViewerViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IArchiveImageViewerViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IArchiveImageViewerViewInterface) == 0x000001, "Wrong alignment on IArchiveImageViewerViewInterface");
static_assert(sizeof(IArchiveImageViewerViewInterface) == 0x000001, "Wrong size on IArchiveImageViewerViewInterface");

// Class DBDUIViewInterfaces.ArchiveJournalViewInterface
// 0x0000 (0x0000 - 0x0000)
class IArchiveJournalViewInterface final
{
public:
	void OnImageViewerVoiceOverAutoplay(bool autoplay);
	void OnImageViewerVoiceOverPlayed();
	void SetArrowButtonEnabled(const bool IsEnabled);
	void SetCinematicButtonsEnabled(bool Enabled);
	void SetEntryData(const struct FArchivesVignetteEntryViewData& entryViewData);
	void SetVignetteData(const struct FArchivesVignetteViewData& vignetteViewData);
	void SetVignetteInputsEnabled(bool Enabled);
	void SetVignetteList(const TArray<struct FArchivesVignetteViewData>& vignetteDataList);
	void SetVoiceOverAutoplay(bool voiceOverAutoplay);
	void SetVoiceOverPlaying(bool voiceOverPlaying);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveJournalViewInterface">();
	}
	static class IArchiveJournalViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IArchiveJournalViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IArchiveJournalViewInterface) == 0x000001, "Wrong alignment on IArchiveJournalViewInterface");
static_assert(sizeof(IArchiveJournalViewInterface) == 0x000001, "Wrong size on IArchiveJournalViewInterface");

// Class DBDUIViewInterfaces.GlobalProcessingIconViewInterface
// 0x0000 (0x0000 - 0x0000)
class IGlobalProcessingIconViewInterface final
{
public:
	void SetGlobalLoadingIconVisibility(bool IsVisible);
	void SetGlobalSavingIconVisibility(bool IsVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlobalProcessingIconViewInterface">();
	}
	static class IGlobalProcessingIconViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGlobalProcessingIconViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IGlobalProcessingIconViewInterface) == 0x000001, "Wrong alignment on IGlobalProcessingIconViewInterface");
static_assert(sizeof(IGlobalProcessingIconViewInterface) == 0x000001, "Wrong size on IGlobalProcessingIconViewInterface");

// Class DBDUIViewInterfaces.ArchiveLevelProgressionViewInterface
// 0x0000 (0x0000 - 0x0000)
class IArchiveLevelProgressionViewInterface final
{
public:
	void GoToNextLevel(int32 LevelIndex);
	void PlayRewardsAnimation();
	void SetActiveLevel(int32 LevelIndex, bool performAction);
	void SetLevelSelectorEnabled(const bool Enabled);
	void SetLevelSelectorVisibility(bool IsVisible);
	void SetRewardsContainerVisibility(bool IsVisible);
	void SetTomeLevelsData(const TArray<class UArchiveStoryLevelViewData*>& levelsData, int32 selectedLevel);
	void SetTomeRewardsData(const TArray<struct FRewardWrapperViewData>& RewardsData, bool areLocked);
	void UpdateLevelStatus(int32 Level, EArchivesStoryLevelStatus status);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveLevelProgressionViewInterface">();
	}
	static class IArchiveLevelProgressionViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IArchiveLevelProgressionViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IArchiveLevelProgressionViewInterface) == 0x000001, "Wrong alignment on IArchiveLevelProgressionViewInterface");
static_assert(sizeof(IArchiveLevelProgressionViewInterface) == 0x000001, "Wrong size on IArchiveLevelProgressionViewInterface");

// Class DBDUIViewInterfaces.ArchiveStoryLevelViewData
// 0x0010 (0x0040 - 0x0030)
class UArchiveStoryLevelViewData final : public UObject
{
public:
	int32                                         Level;                                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EArchivesStoryLevelStatus                     status;                                            // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              StartDate;                                         // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveStoryLevelViewData">();
	}
	static class UArchiveStoryLevelViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArchiveStoryLevelViewData>();
	}
};
static_assert(alignof(UArchiveStoryLevelViewData) == 0x000008, "Wrong alignment on UArchiveStoryLevelViewData");
static_assert(sizeof(UArchiveStoryLevelViewData) == 0x000040, "Wrong size on UArchiveStoryLevelViewData");
static_assert(offsetof(UArchiveStoryLevelViewData, Level) == 0x000030, "Member 'UArchiveStoryLevelViewData::Level' has a wrong offset!");
static_assert(offsetof(UArchiveStoryLevelViewData, status) == 0x000034, "Member 'UArchiveStoryLevelViewData::status' has a wrong offset!");
static_assert(offsetof(UArchiveStoryLevelViewData, StartDate) == 0x000038, "Member 'UArchiveStoryLevelViewData::StartDate' has a wrong offset!");

// Class DBDUIViewInterfaces.GammaSettingsPopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class IGammaSettingsPopupViewInterface final
{
public:
	void SetGamma(const float gamma);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GammaSettingsPopupViewInterface">();
	}
	static class IGammaSettingsPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGammaSettingsPopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IGammaSettingsPopupViewInterface) == 0x000001, "Wrong alignment on IGammaSettingsPopupViewInterface");
static_assert(sizeof(IGammaSettingsPopupViewInterface) == 0x000001, "Wrong size on IGammaSettingsPopupViewInterface");

// Class DBDUIViewInterfaces.PlayerProfileViewInterface
// 0x0000 (0x0000 - 0x0000)
class IPlayerProfileViewInterface final
{
public:
	void FullUpdateCurrency(const struct FCurrencyLabelViewData& ViewData);
	void HidePlayerCard();
	void HidePlayerName();
	void HideUI();
	void SetPlayerCard(const struct FPlayerCardViewData& Badge, const struct FPlayerCardViewData& Banner);
	void SetPlayerCardAnimationMode(const EPlayerCardAnimationMode PlayerCardAnimationMode);
	void SetPlayerCardBannerOpacity(float Opacity);
	void SetPlayerName(const class FText& playerNameText);
	void SetPlayerProfileEnabled(bool IsEnabled);
	void SetWalletData(const TArray<struct FCurrencyLabelViewData>& walletData);
	void SetWalletVisibility(const bool IsVisible);
	void ShowPlayerCard();
	void ShowUI();
	void UpdatePlayerCardButton(const bool isProfileMenuContextEntered);
	void UpdatePlayerProfileOpacity(const bool isFocused);
	void UpdateWallet(const ECurrencyType Type, int32 newBalance, int32 previousBalance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerProfileViewInterface">();
	}
	static class IPlayerProfileViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPlayerProfileViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPlayerProfileViewInterface) == 0x000001, "Wrong alignment on IPlayerProfileViewInterface");
static_assert(sizeof(IPlayerProfileViewInterface) == 0x000001, "Wrong size on IPlayerProfileViewInterface");

// Class DBDUIViewInterfaces.ArchivePassPurchasePopupViewData
// 0x0150 (0x0340 - 0x01F0)
class UArchivePassPurchasePopupViewData final : public UGenericPopupViewData
{
public:
	class FText                                   AvailabilityDates;                                 // 0x01F0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0208(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20C[0x4];                                      // 0x020C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMaterialInterface>      BackgroundKeyArtMaterial;                          // 0x0210(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPriceTagViewData                      PriceTagViewData;                                  // 0x0248(0x0050)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	bool                                          ContainsArchivePack;                               // 0x0298(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ArchivePackTitle;                                  // 0x02A0(0x0018)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	class FText                                   ArchivePackDescription;                            // 0x02B8(0x0018)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	struct FPriceTagViewData                      ArchivePackPriceTagViewData;                       // 0x02D0(0x0050)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	class FName                                   ArchivePackId;                                     // 0x0320(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32C[0x4];                                      // 0x032C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRewardWrapperViewData>         RewardsViewData;                                   // 0x0330(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchivePassPurchasePopupViewData">();
	}
	static class UArchivePassPurchasePopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArchivePassPurchasePopupViewData>();
	}
};
static_assert(alignof(UArchivePassPurchasePopupViewData) == 0x000010, "Wrong alignment on UArchivePassPurchasePopupViewData");
static_assert(sizeof(UArchivePassPurchasePopupViewData) == 0x000340, "Wrong size on UArchivePassPurchasePopupViewData");
static_assert(offsetof(UArchivePassPurchasePopupViewData, AvailabilityDates) == 0x0001F0, "Member 'UArchivePassPurchasePopupViewData::AvailabilityDates' has a wrong offset!");
static_assert(offsetof(UArchivePassPurchasePopupViewData, Quantity) == 0x000208, "Member 'UArchivePassPurchasePopupViewData::Quantity' has a wrong offset!");
static_assert(offsetof(UArchivePassPurchasePopupViewData, BackgroundKeyArtMaterial) == 0x000210, "Member 'UArchivePassPurchasePopupViewData::BackgroundKeyArtMaterial' has a wrong offset!");
static_assert(offsetof(UArchivePassPurchasePopupViewData, PriceTagViewData) == 0x000248, "Member 'UArchivePassPurchasePopupViewData::PriceTagViewData' has a wrong offset!");
static_assert(offsetof(UArchivePassPurchasePopupViewData, ContainsArchivePack) == 0x000298, "Member 'UArchivePassPurchasePopupViewData::ContainsArchivePack' has a wrong offset!");
static_assert(offsetof(UArchivePassPurchasePopupViewData, ArchivePackTitle) == 0x0002A0, "Member 'UArchivePassPurchasePopupViewData::ArchivePackTitle' has a wrong offset!");
static_assert(offsetof(UArchivePassPurchasePopupViewData, ArchivePackDescription) == 0x0002B8, "Member 'UArchivePassPurchasePopupViewData::ArchivePackDescription' has a wrong offset!");
static_assert(offsetof(UArchivePassPurchasePopupViewData, ArchivePackPriceTagViewData) == 0x0002D0, "Member 'UArchivePassPurchasePopupViewData::ArchivePackPriceTagViewData' has a wrong offset!");
static_assert(offsetof(UArchivePassPurchasePopupViewData, ArchivePackId) == 0x000320, "Member 'UArchivePassPurchasePopupViewData::ArchivePackId' has a wrong offset!");
static_assert(offsetof(UArchivePassPurchasePopupViewData, RewardsViewData) == 0x000330, "Member 'UArchivePassPurchasePopupViewData::RewardsViewData' has a wrong offset!");

// Class DBDUIViewInterfaces.TricksterStatusData
// 0x0010 (0x0040 - 0x0030)
class UTricksterStatusData final : public UKillerStatusData
{
public:
	float                                         CurrentLacerationLevel;                            // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumLacerationLevel;                            // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDangerousLacerationLevel;                        // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WasRecentlyDamagedByLaceration;                    // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TricksterStatusData">();
	}
	static class UTricksterStatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTricksterStatusData>();
	}
};
static_assert(alignof(UTricksterStatusData) == 0x000008, "Wrong alignment on UTricksterStatusData");
static_assert(sizeof(UTricksterStatusData) == 0x000040, "Wrong size on UTricksterStatusData");
static_assert(offsetof(UTricksterStatusData, CurrentLacerationLevel) == 0x000030, "Member 'UTricksterStatusData::CurrentLacerationLevel' has a wrong offset!");
static_assert(offsetof(UTricksterStatusData, MaximumLacerationLevel) == 0x000034, "Member 'UTricksterStatusData::MaximumLacerationLevel' has a wrong offset!");
static_assert(offsetof(UTricksterStatusData, IsDangerousLacerationLevel) == 0x000038, "Member 'UTricksterStatusData::IsDangerousLacerationLevel' has a wrong offset!");
static_assert(offsetof(UTricksterStatusData, WasRecentlyDamagedByLaceration) == 0x000039, "Member 'UTricksterStatusData::WasRecentlyDamagedByLaceration' has a wrong offset!");

// Class DBDUIViewInterfaces.ArchivePassPurchasePopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class IArchivePassPurchasePopupViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchivePassPurchasePopupViewInterface">();
	}
	static class IArchivePassPurchasePopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IArchivePassPurchasePopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IArchivePassPurchasePopupViewInterface) == 0x000001, "Wrong alignment on IArchivePassPurchasePopupViewInterface");
static_assert(sizeof(IArchivePassPurchasePopupViewInterface) == 0x000001, "Wrong size on IArchivePassPurchasePopupViewInterface");

// Class DBDUIViewInterfaces.ArchiveQuestMapViewInterface
// 0x0000 (0x0000 - 0x0000)
class IArchiveQuestMapViewInterface final
{
public:
	void Reset();
	void SetLoadingSpinner(bool IsLoading);
	void SetQuestMapData(const TArray<struct FArchiveNodeGraphViewData>& nodeDataList, const TArray<struct FArchiveMapPathViewData>& pathDataList, bool needsCascadeAppear);
	void UpdateQuestMapData(const TArray<struct FArchiveNodeGraphViewData>& nodeDataList, const TArray<struct FArchiveMapPathViewData>& pathDataList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveQuestMapViewInterface">();
	}
	static class IArchiveQuestMapViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IArchiveQuestMapViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IArchiveQuestMapViewInterface) == 0x000001, "Wrong alignment on IArchiveQuestMapViewInterface");
static_assert(sizeof(IArchiveQuestMapViewInterface) == 0x000001, "Wrong size on IArchiveQuestMapViewInterface");

// Class DBDUIViewInterfaces.ExecutionerStatusData
// 0x0008 (0x0038 - 0x0030)
class UExecutionerStatusData final : public UKillerStatusData
{
public:
	float                                         AgonyProgress;                                     // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExecutionerStatusData">();
	}
	static class UExecutionerStatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExecutionerStatusData>();
	}
};
static_assert(alignof(UExecutionerStatusData) == 0x000008, "Wrong alignment on UExecutionerStatusData");
static_assert(sizeof(UExecutionerStatusData) == 0x000038, "Wrong size on UExecutionerStatusData");
static_assert(offsetof(UExecutionerStatusData, AgonyProgress) == 0x000030, "Member 'UExecutionerStatusData::AgonyProgress' has a wrong offset!");

// Class DBDUIViewInterfaces.ArchivesViewInterface
// 0x0000 (0x0000 - 0x0000)
class IArchivesViewInterface final
{
public:
	void ClearChallengeReminderData(EPlayerRole Role);
	void CloseSlotSelector();
	void HideUI();
	void Init();
	void SetChallengeReminderData(const struct FArchiveChallengeReminderViewData& Data, EPlayerRole Role, bool needsAnimation, const struct FVector2D& animationOriginalPosition);
	void SetChallengeReminderVisibility(bool IsVisible);
	void SetControllerElementsEnabled(bool Enabled);
	void SetInfoButtonEnabled(bool IsEnabled);
	void SetMenuState(EArchivesMenuState menuState);
	void SetQuestNodeHoverEffect(EPlayerRole Role, bool IsHovered);
	void SetReminderSlotsEnabled(bool IsEnabled);
	void SetTitle(const class FText& Title);
	void ShowSlotSelector(const struct FArchiveNodeViewData& Data);
	void ShowUI();

	TScriptInterface<class IArchiveCompendiumViewInterface> GetArchiveCompendiumInterface() const;
	TScriptInterface<class IArchiveTomeViewInterface> GetArchiveTomeInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchivesViewInterface">();
	}
	static class IArchivesViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IArchivesViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IArchivesViewInterface) == 0x000001, "Wrong alignment on IArchivesViewInterface");
static_assert(sizeof(IArchivesViewInterface) == 0x000001, "Wrong size on IArchivesViewInterface");

// Class DBDUIViewInterfaces.ArchiveTierPurchasePopupViewData
// 0x00C0 (0x02B0 - 0x01F0)
class UArchiveTierPurchasePopupViewData final : public UGenericPopupViewData
{
public:
	bool                                          isPurchasingInfiniteTiers;                         // 0x01F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F1[0x7];                                      // 0x01F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              ImageTexture;                                      // 0x01F8(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTiers;                                          // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         currentTier;                                       // 0x0234(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0238(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UnitPrice;                                         // 0x023C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentWalletAmount;                               // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FirstDeepTier;                                     // 0x0244(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastDeepTier;                                      // 0x0248(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InfiniteTier;                                      // 0x024C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDeepTier;                                        // 0x0250(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInfiniteTier;                                    // 0x0251(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_252[0x6];                                      // 0x0252(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPriceTagViewData                      PriceTagViewData;                                  // 0x0258(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveTierPurchasePopupViewData">();
	}
	static class UArchiveTierPurchasePopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArchiveTierPurchasePopupViewData>();
	}
};
static_assert(alignof(UArchiveTierPurchasePopupViewData) == 0x000010, "Wrong alignment on UArchiveTierPurchasePopupViewData");
static_assert(sizeof(UArchiveTierPurchasePopupViewData) == 0x0002B0, "Wrong size on UArchiveTierPurchasePopupViewData");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, isPurchasingInfiniteTiers) == 0x0001F0, "Member 'UArchiveTierPurchasePopupViewData::isPurchasingInfiniteTiers' has a wrong offset!");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, ImageTexture) == 0x0001F8, "Member 'UArchiveTierPurchasePopupViewData::ImageTexture' has a wrong offset!");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, MaxTiers) == 0x000230, "Member 'UArchiveTierPurchasePopupViewData::MaxTiers' has a wrong offset!");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, currentTier) == 0x000234, "Member 'UArchiveTierPurchasePopupViewData::currentTier' has a wrong offset!");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, Quantity) == 0x000238, "Member 'UArchiveTierPurchasePopupViewData::Quantity' has a wrong offset!");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, UnitPrice) == 0x00023C, "Member 'UArchiveTierPurchasePopupViewData::UnitPrice' has a wrong offset!");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, CurrentWalletAmount) == 0x000240, "Member 'UArchiveTierPurchasePopupViewData::CurrentWalletAmount' has a wrong offset!");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, FirstDeepTier) == 0x000244, "Member 'UArchiveTierPurchasePopupViewData::FirstDeepTier' has a wrong offset!");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, LastDeepTier) == 0x000248, "Member 'UArchiveTierPurchasePopupViewData::LastDeepTier' has a wrong offset!");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, InfiniteTier) == 0x00024C, "Member 'UArchiveTierPurchasePopupViewData::InfiniteTier' has a wrong offset!");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, IsDeepTier) == 0x000250, "Member 'UArchiveTierPurchasePopupViewData::IsDeepTier' has a wrong offset!");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, IsInfiniteTier) == 0x000251, "Member 'UArchiveTierPurchasePopupViewData::IsInfiniteTier' has a wrong offset!");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, PriceTagViewData) == 0x000258, "Member 'UArchiveTierPurchasePopupViewData::PriceTagViewData' has a wrong offset!");

// Class DBDUIViewInterfaces.PlayerCardAnimationViewInterface
// 0x0000 (0x0000 - 0x0000)
class IPlayerCardAnimationViewInterface final
{
public:
	void OnPlayAnimation();
	void OnStopAnimation();
	void SetRetainerBoxMaterial(const TSoftObjectPtr<class UTexture2D>& bannerTexture);
	void SetRetainerBoxOpacity(const float Opacity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCardAnimationViewInterface">();
	}
	static class IPlayerCardAnimationViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPlayerCardAnimationViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPlayerCardAnimationViewInterface) == 0x000001, "Wrong alignment on IPlayerCardAnimationViewInterface");
static_assert(sizeof(IPlayerCardAnimationViewInterface) == 0x000001, "Wrong size on IPlayerCardAnimationViewInterface");

// Class DBDUIViewInterfaces.ArchiveTierPurchasePopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class IArchiveTierPurchasePopupViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveTierPurchasePopupViewInterface">();
	}
	static class IArchiveTierPurchasePopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IArchiveTierPurchasePopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IArchiveTierPurchasePopupViewInterface) == 0x000001, "Wrong alignment on IArchiveTierPurchasePopupViewInterface");
static_assert(sizeof(IArchiveTierPurchasePopupViewInterface) == 0x000001, "Wrong size on IArchiveTierPurchasePopupViewInterface");

// Class DBDUIViewInterfaces.ArchiveTomeViewInterface
// 0x0000 (0x0000 - 0x0000)
class IArchiveTomeViewInterface final
{
public:
	void SetMenuState(EArchiveTomeMenuState menuState);
	void SetNotificationVisibility(int32 Key, bool HasNotification);
	void SetSubTabsData(const TArray<struct FTabWidgetData>& tabsData, int32 SelectedKey);
	void SetSubTabsEnabled(int32 Key, bool IsEnabled);
	void SetSubTabsVisibility(int32 Key, bool IsVisible);

	TScriptInterface<class IArchiveJournalViewInterface> GetArchiveJournalInterface() const;
	TScriptInterface<class IArchiveLevelProgressionViewInterface> GetArchiveLevelProgressionInterface() const;
	TScriptInterface<class IArchiveQuestMapViewInterface> GetArchiveQuestMapInterface() const;
	const EArchiveTomeMenuState GetMenuState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveTomeViewInterface">();
	}
	static class IArchiveTomeViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IArchiveTomeViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IArchiveTomeViewInterface) == 0x000001, "Wrong alignment on IArchiveTomeViewInterface");
static_assert(sizeof(IArchiveTomeViewInterface) == 0x000001, "Wrong size on IArchiveTomeViewInterface");

// Class DBDUIViewInterfaces.PigStatusData
// 0x0008 (0x0038 - 0x0030)
class UPigStatusData final : public UKillerStatusData
{
public:
	EReverseBearTrapUIState                       ReverseBearTrapState;                              // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimerProgress;                                     // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PigStatusData">();
	}
	static class UPigStatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPigStatusData>();
	}
};
static_assert(alignof(UPigStatusData) == 0x000008, "Wrong alignment on UPigStatusData");
static_assert(sizeof(UPigStatusData) == 0x000038, "Wrong size on UPigStatusData");
static_assert(offsetof(UPigStatusData, ReverseBearTrapState) == 0x000030, "Member 'UPigStatusData::ReverseBearTrapState' has a wrong offset!");
static_assert(offsetof(UPigStatusData, TimerProgress) == 0x000034, "Member 'UPigStatusData::TimerProgress' has a wrong offset!");

// Class DBDUIViewInterfaces.AuricCellsViewInterface
// 0x0000 (0x0000 - 0x0000)
class IAuricCellsViewInterface final
{
public:
	void SetData(const struct FAuricCellsViewData& ViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuricCellsViewInterface">();
	}
	static class IAuricCellsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAuricCellsViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IAuricCellsViewInterface) == 0x000001, "Wrong alignment on IAuricCellsViewInterface");
static_assert(sizeof(IAuricCellsViewInterface) == 0x000001, "Wrong size on IAuricCellsViewInterface");

// Class DBDUIViewInterfaces.BasePopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class IBasePopupViewInterface final
{
public:
	void Enter(class UBasePopupViewData* Data);
	void Leave();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePopupViewInterface">();
	}
	static class IBasePopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBasePopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IBasePopupViewInterface) == 0x000001, "Wrong alignment on IBasePopupViewInterface");
static_assert(sizeof(IBasePopupViewInterface) == 0x000001, "Wrong size on IBasePopupViewInterface");

// Class DBDUIViewInterfaces.K31StatusData
// 0x0008 (0x0038 - 0x0030)
class UK31StatusData final : public UKillerStatusData
{
public:
	float                                         EffectProgressPercentage;                          // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsClawTrapped;                                     // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K31StatusData">();
	}
	static class UK31StatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK31StatusData>();
	}
};
static_assert(alignof(UK31StatusData) == 0x000008, "Wrong alignment on UK31StatusData");
static_assert(sizeof(UK31StatusData) == 0x000038, "Wrong size on UK31StatusData");
static_assert(offsetof(UK31StatusData, EffectProgressPercentage) == 0x000030, "Member 'UK31StatusData::EffectProgressPercentage' has a wrong offset!");
static_assert(offsetof(UK31StatusData, IsClawTrapped) == 0x000034, "Member 'UK31StatusData::IsClawTrapped' has a wrong offset!");

// Class DBDUIViewInterfaces.BloodPointBulkSpendingPopupViewData
// 0x0010 (0x0200 - 0x01F0)
class UBloodPointBulkSpendingPopupViewData final : public UGenericPopupViewData
{
public:
	struct FPrestigeViewData                      CurrentPrestigeData;                               // 0x01F0(0x0008)(BlueprintVisible, Transient, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         CurrentLevel;                                      // 0x01F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxLevel;                                          // 0x01FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodPointBulkSpendingPopupViewData">();
	}
	static class UBloodPointBulkSpendingPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodPointBulkSpendingPopupViewData>();
	}
};
static_assert(alignof(UBloodPointBulkSpendingPopupViewData) == 0x000010, "Wrong alignment on UBloodPointBulkSpendingPopupViewData");
static_assert(sizeof(UBloodPointBulkSpendingPopupViewData) == 0x000200, "Wrong size on UBloodPointBulkSpendingPopupViewData");
static_assert(offsetof(UBloodPointBulkSpendingPopupViewData, CurrentPrestigeData) == 0x0001F0, "Member 'UBloodPointBulkSpendingPopupViewData::CurrentPrestigeData' has a wrong offset!");
static_assert(offsetof(UBloodPointBulkSpendingPopupViewData, CurrentLevel) == 0x0001F8, "Member 'UBloodPointBulkSpendingPopupViewData::CurrentLevel' has a wrong offset!");
static_assert(offsetof(UBloodPointBulkSpendingPopupViewData, MaxLevel) == 0x0001FC, "Member 'UBloodPointBulkSpendingPopupViewData::MaxLevel' has a wrong offset!");

// Class DBDUIViewInterfaces.BloodPointBulkSpendingPopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class IBloodPointBulkSpendingPopupViewInterface final
{
public:
	void UpdatedExpectedLevels(const struct FPrestigeViewData& expectedPrestige, const int32 expectedLevel, const int32 expectedCost);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodPointBulkSpendingPopupViewInterface">();
	}
	static class IBloodPointBulkSpendingPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBloodPointBulkSpendingPopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IBloodPointBulkSpendingPopupViewInterface) == 0x000001, "Wrong alignment on IBloodPointBulkSpendingPopupViewInterface");
static_assert(sizeof(IBloodPointBulkSpendingPopupViewInterface) == 0x000001, "Wrong size on IBloodPointBulkSpendingPopupViewInterface");

// Class DBDUIViewInterfaces.K25StatusData
// 0x0008 (0x0038 - 0x0030)
class UK25StatusData final : public UKillerStatusData
{
public:
	float                                         ChainHuntProgressPercentage;                       // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHoldingLamentConfiguration;                      // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSolvingLamentConfiguration;                      // 0x0035(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25StatusData">();
	}
	static class UK25StatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25StatusData>();
	}
};
static_assert(alignof(UK25StatusData) == 0x000008, "Wrong alignment on UK25StatusData");
static_assert(sizeof(UK25StatusData) == 0x000038, "Wrong size on UK25StatusData");
static_assert(offsetof(UK25StatusData, ChainHuntProgressPercentage) == 0x000030, "Member 'UK25StatusData::ChainHuntProgressPercentage' has a wrong offset!");
static_assert(offsetof(UK25StatusData, IsHoldingLamentConfiguration) == 0x000034, "Member 'UK25StatusData::IsHoldingLamentConfiguration' has a wrong offset!");
static_assert(offsetof(UK25StatusData, IsSolvingLamentConfiguration) == 0x000035, "Member 'UK25StatusData::IsSolvingLamentConfiguration' has a wrong offset!");

// Class DBDUIViewInterfaces.BotLoadoutViewInterface
// 0x0000 (0x0000 - 0x0000)
class IBotLoadoutViewInterface final
{
public:
	void SetSelectableCharacters(const TArray<struct FTabWidgetData>& selectableCharacters, const EPlayerRole PlayerRole, const struct FTabWidgetData& TabWidgetData, const int32 botIndex);
	void UpdatePresetData(const TArray<int32>& presetData, const int32 selectedPreset);

	TScriptInterface<class ILoadoutViewInterface> GetLoadoutViewInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotLoadoutViewInterface">();
	}
	static class IBotLoadoutViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBotLoadoutViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IBotLoadoutViewInterface) == 0x000001, "Wrong alignment on IBotLoadoutViewInterface");
static_assert(sizeof(IBotLoadoutViewInterface) == 0x000001, "Wrong size on IBotLoadoutViewInterface");

// Class DBDUIViewInterfaces.ChallengesMenuChallengeSetViewInterface
// 0x0000 (0x0000 - 0x0000)
class IChallengesMenuChallengeSetViewInterface final
{
public:
	void SetEventVisuals(const class FString& eventFrameLabel);
	void SetTabEnabled(const int32 Key, const bool Enabled);
	void SetTabsData(const TArray<struct FTabWidgetData>& tabsData, const int32 SelectedKey);
	void SetTabSelected(const int32 Key);

	TScriptInterface<class IChallengesMenuRitualsViewInterface> GetRitualsInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengesMenuChallengeSetViewInterface">();
	}
	static class IChallengesMenuChallengeSetViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IChallengesMenuChallengeSetViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IChallengesMenuChallengeSetViewInterface) == 0x000001, "Wrong alignment on IChallengesMenuChallengeSetViewInterface");
static_assert(sizeof(IChallengesMenuChallengeSetViewInterface) == 0x000001, "Wrong size on IChallengesMenuChallengeSetViewInterface");

// Class DBDUIViewInterfaces.GhostfaceStatusData
// 0x0008 (0x0038 - 0x0030)
class UGhostfaceStatusData final : public UKillerStatusData
{
public:
	bool                                          IsExposed;                                         // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StalkingProgress;                                  // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GhostfaceStatusData">();
	}
	static class UGhostfaceStatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGhostfaceStatusData>();
	}
};
static_assert(alignof(UGhostfaceStatusData) == 0x000008, "Wrong alignment on UGhostfaceStatusData");
static_assert(sizeof(UGhostfaceStatusData) == 0x000038, "Wrong size on UGhostfaceStatusData");
static_assert(offsetof(UGhostfaceStatusData, IsExposed) == 0x000030, "Member 'UGhostfaceStatusData::IsExposed' has a wrong offset!");
static_assert(offsetof(UGhostfaceStatusData, StalkingProgress) == 0x000034, "Member 'UGhostfaceStatusData::StalkingProgress' has a wrong offset!");

// Class DBDUIViewInterfaces.ChallengesMenuRewardTrackViewInterface
// 0x0000 (0x0000 - 0x0000)
class IChallengesMenuRewardTrackViewInterface final
{
public:
	void SetEventVisuals(const class FString& eventFrameLabel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengesMenuRewardTrackViewInterface">();
	}
	static class IChallengesMenuRewardTrackViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IChallengesMenuRewardTrackViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IChallengesMenuRewardTrackViewInterface) == 0x000001, "Wrong alignment on IChallengesMenuRewardTrackViewInterface");
static_assert(sizeof(IChallengesMenuRewardTrackViewInterface) == 0x000001, "Wrong size on IChallengesMenuRewardTrackViewInterface");

// Class DBDUIViewInterfaces.EffectCardViewInterface
// 0x0000 (0x0000 - 0x0000)
class IEffectCardViewInterface final
{
public:
	void SetData(const struct FEffectCardViewData& effectCardData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectCardViewInterface">();
	}
	static class IEffectCardViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEffectCardViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IEffectCardViewInterface) == 0x000001, "Wrong alignment on IEffectCardViewInterface");
static_assert(sizeof(IEffectCardViewInterface) == 0x000001, "Wrong size on IEffectCardViewInterface");

// Class DBDUIViewInterfaces.ChallengesMenuRitualsViewInterface
// 0x0000 (0x0000 - 0x0000)
class IChallengesMenuRitualsViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengesMenuRitualsViewInterface">();
	}
	static class IChallengesMenuRitualsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IChallengesMenuRitualsViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IChallengesMenuRitualsViewInterface) == 0x000001, "Wrong alignment on IChallengesMenuRitualsViewInterface");
static_assert(sizeof(IChallengesMenuRitualsViewInterface) == 0x000001, "Wrong size on IChallengesMenuRitualsViewInterface");

// Class DBDUIViewInterfaces.K29StatusData
// 0x0008 (0x0038 - 0x0030)
class UK29StatusData final : public UKillerStatusData
{
public:
	float                                         InfectionPercentage;                               // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInfected;                                        // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInfectionActive;                                 // 0x0035(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInfectionCritical;                               // 0x0036(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37[0x1];                                       // 0x0037(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29StatusData">();
	}
	static class UK29StatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29StatusData>();
	}
};
static_assert(alignof(UK29StatusData) == 0x000008, "Wrong alignment on UK29StatusData");
static_assert(sizeof(UK29StatusData) == 0x000038, "Wrong size on UK29StatusData");
static_assert(offsetof(UK29StatusData, InfectionPercentage) == 0x000030, "Member 'UK29StatusData::InfectionPercentage' has a wrong offset!");
static_assert(offsetof(UK29StatusData, IsInfected) == 0x000034, "Member 'UK29StatusData::IsInfected' has a wrong offset!");
static_assert(offsetof(UK29StatusData, IsInfectionActive) == 0x000035, "Member 'UK29StatusData::IsInfectionActive' has a wrong offset!");
static_assert(offsetof(UK29StatusData, IsInfectionCritical) == 0x000036, "Member 'UK29StatusData::IsInfectionCritical' has a wrong offset!");

// Class DBDUIViewInterfaces.ChallengesMenuViewInterface
// 0x0000 (0x0000 - 0x0000)
class IChallengesMenuViewInterface final
{
public:
	TScriptInterface<class IChallengesMenuChallengeSetViewInterface> AddChallengeSet(const struct FChallengeSetMenuViewData& ViewData);
	void InitializeChallengeSetButtons(const TArray<struct FChallengeSetMenuViewData>& challengeSetsData);
	void SetIsFocused(const bool isFocused);
	void SetSelectedChallengeSet(const class FString& ChallengeSetId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengesMenuViewInterface">();
	}
	static class IChallengesMenuViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IChallengesMenuViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IChallengesMenuViewInterface) == 0x000001, "Wrong alignment on IChallengesMenuViewInterface");
static_assert(sizeof(IChallengesMenuViewInterface) == 0x000001, "Wrong size on IChallengesMenuViewInterface");

// Class DBDUIViewInterfaces.CoreBaseViewInterface
// 0x0000 (0x0000 - 0x0000)
class ICoreBaseViewInterface final
{
public:
	void OnStartAsyncOperation();
	void OnStopAsyncOperation();

	TArray<TScriptInterface<class ILockedFeatureElementViewInterface>> GetLockedFeatureElements() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreBaseViewInterface">();
	}
	static class ICoreBaseViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICoreBaseViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ICoreBaseViewInterface) == 0x000001, "Wrong alignment on ICoreBaseViewInterface");
static_assert(sizeof(ICoreBaseViewInterface) == 0x000001, "Wrong size on ICoreBaseViewInterface");

// Class DBDUIViewInterfaces.ChallengeTrackerContainerViewInterface
// 0x0000 (0x0000 - 0x0000)
class IChallengeTrackerContainerViewInterface final
{
public:
	void Deinitialize();
	void InitWidgetData(const TArray<struct FChallengeTrackerViewData>& ViewData);
	void ResetChallenges(const TArray<struct FChallengeTrackerViewData>& ViewData);
	void UpdateChallenge(const struct FChallengeTrackerViewData& ViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengeTrackerContainerViewInterface">();
	}
	static class IChallengeTrackerContainerViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IChallengeTrackerContainerViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IChallengeTrackerContainerViewInterface) == 0x000001, "Wrong alignment on IChallengeTrackerContainerViewInterface");
static_assert(sizeof(IChallengeTrackerContainerViewInterface) == 0x000001, "Wrong size on IChallengeTrackerContainerViewInterface");

// Class DBDUIViewInterfaces.PowerBundleViewInterface
// 0x0000 (0x0000 - 0x0000)
class IPowerBundleViewInterface final
{
public:
	void ClearData();
	void SetData(const struct FPowerBundleViewData& PowerBundleViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PowerBundleViewInterface">();
	}
	static class IPowerBundleViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPowerBundleViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPowerBundleViewInterface) == 0x000001, "Wrong alignment on IPowerBundleViewInterface");
static_assert(sizeof(IPowerBundleViewInterface) == 0x000001, "Wrong size on IPowerBundleViewInterface");

// Class DBDUIViewInterfaces.ChallengeTrackerViewInterface
// 0x0000 (0x0000 - 0x0000)
class IChallengeTrackerViewInterface final
{
public:
	void CloseWidget();
	void InitWidgetData(const struct FChallengeTrackerViewData& ViewData);
	void OpenWidget();
	void SetWidgetVisuals(const struct FChallengeTrackerSkinData& skinData, const class FString& eventFrameLabel);
	void UpdateWidgetProgression(const struct FArchiveNodeObjectiveViewData& ProgressionData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengeTrackerViewInterface">();
	}
	static class IChallengeTrackerViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IChallengeTrackerViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IChallengeTrackerViewInterface) == 0x000001, "Wrong alignment on IChallengeTrackerViewInterface");
static_assert(sizeof(IChallengeTrackerViewInterface) == 0x000001, "Wrong size on IChallengeTrackerViewInterface");

// Class DBDUIViewInterfaces.ChatViewInterface
// 0x0000 (0x0000 - 0x0000)
class IChatViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChatViewInterface">();
	}
	static class IChatViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IChatViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IChatViewInterface) == 0x000001, "Wrong alignment on IChatViewInterface");
static_assert(sizeof(IChatViewInterface) == 0x000001, "Wrong size on IChatViewInterface");

// Class DBDUIViewInterfaces.K35StatusData
// 0x0008 (0x0038 - 0x0030)
class UK35StatusData final : public UKillerStatusData
{
public:
	bool                                          IsAfflictedWithKillerEffect;                       // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRemovingKillerEffect;                            // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KillerEffectRemovalProgress;                       // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35StatusData">();
	}
	static class UK35StatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK35StatusData>();
	}
};
static_assert(alignof(UK35StatusData) == 0x000008, "Wrong alignment on UK35StatusData");
static_assert(sizeof(UK35StatusData) == 0x000038, "Wrong size on UK35StatusData");
static_assert(offsetof(UK35StatusData, IsAfflictedWithKillerEffect) == 0x000030, "Member 'UK35StatusData::IsAfflictedWithKillerEffect' has a wrong offset!");
static_assert(offsetof(UK35StatusData, IsRemovingKillerEffect) == 0x000031, "Member 'UK35StatusData::IsRemovingKillerEffect' has a wrong offset!");
static_assert(offsetof(UK35StatusData, KillerEffectRemovalProgress) == 0x000034, "Member 'UK35StatusData::KillerEffectRemovalProgress' has a wrong offset!");

// Class DBDUIViewInterfaces.CinematicViewInterface
// 0x0000 (0x0000 - 0x0000)
class ICinematicViewInterface final
{
public:
	void FadeInAnimation(const float FadeInDuration, const float Delay);
	void FadeOutAnimation(const float FadeOutDuration, const float Delay);
	class UBinkMediaPlayer* GetBinkVideoPlayer();
	void SetSize(const struct FVector2D& Size);
	void SetSkipInputSwitcherEnabled(bool IsEnabled);
	void SetSkipInputSwitcherVisibility(bool IsVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CinematicViewInterface">();
	}
	static class ICinematicViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICinematicViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ICinematicViewInterface) == 0x000001, "Wrong alignment on ICinematicViewInterface");
static_assert(sizeof(ICinematicViewInterface) == 0x000001, "Wrong size on ICinematicViewInterface");

// Class DBDUIViewInterfaces.CustomizationRewardOutfitPartsViewData
// 0x0010 (0x0040 - 0x0030)
class UCustomizationRewardOutfitPartsViewData final : public UObject
{
public:
	TArray<struct FCustomizationRewardViewData>   OutfitParts;                                       // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationRewardOutfitPartsViewData">();
	}
	static class UCustomizationRewardOutfitPartsViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationRewardOutfitPartsViewData>();
	}
};
static_assert(alignof(UCustomizationRewardOutfitPartsViewData) == 0x000008, "Wrong alignment on UCustomizationRewardOutfitPartsViewData");
static_assert(sizeof(UCustomizationRewardOutfitPartsViewData) == 0x000040, "Wrong size on UCustomizationRewardOutfitPartsViewData");
static_assert(offsetof(UCustomizationRewardOutfitPartsViewData, OutfitParts) == 0x000030, "Member 'UCustomizationRewardOutfitPartsViewData::OutfitParts' has a wrong offset!");

// Class DBDUIViewInterfaces.CommonStoreDelegates
// 0x0000 (0x0030 - 0x0030)
class UCommonStoreDelegates final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonStoreDelegates">();
	}
	static class UCommonStoreDelegates* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonStoreDelegates>();
	}
};
static_assert(alignof(UCommonStoreDelegates) == 0x000008, "Wrong alignment on UCommonStoreDelegates");
static_assert(sizeof(UCommonStoreDelegates) == 0x000030, "Wrong size on UCommonStoreDelegates");

// Class DBDUIViewInterfaces.TheOnryoStatusData
// 0x0010 (0x0040 - 0x0030)
class UTheOnryoStatusData final : public UKillerStatusData
{
public:
	bool                                          IsCondemnedActive;                                 // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CondemnedProgress;                                 // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockedProgress;                                    // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFullCondemned;                                   // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHoldingTape;                                     // 0x003D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TheOnryoStatusData">();
	}
	static class UTheOnryoStatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTheOnryoStatusData>();
	}
};
static_assert(alignof(UTheOnryoStatusData) == 0x000008, "Wrong alignment on UTheOnryoStatusData");
static_assert(sizeof(UTheOnryoStatusData) == 0x000040, "Wrong size on UTheOnryoStatusData");
static_assert(offsetof(UTheOnryoStatusData, IsCondemnedActive) == 0x000030, "Member 'UTheOnryoStatusData::IsCondemnedActive' has a wrong offset!");
static_assert(offsetof(UTheOnryoStatusData, CondemnedProgress) == 0x000034, "Member 'UTheOnryoStatusData::CondemnedProgress' has a wrong offset!");
static_assert(offsetof(UTheOnryoStatusData, LockedProgress) == 0x000038, "Member 'UTheOnryoStatusData::LockedProgress' has a wrong offset!");
static_assert(offsetof(UTheOnryoStatusData, IsFullCondemned) == 0x00003C, "Member 'UTheOnryoStatusData::IsFullCondemned' has a wrong offset!");
static_assert(offsetof(UTheOnryoStatusData, IsHoldingTape) == 0x00003D, "Member 'UTheOnryoStatusData::IsHoldingTape' has a wrong offset!");

// Class DBDUIViewInterfaces.CommonUIDelegates
// 0x0000 (0x0030 - 0x0030)
class UCommonUIDelegates final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonUIDelegates">();
	}
	static class UCommonUIDelegates* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonUIDelegates>();
	}
};
static_assert(alignof(UCommonUIDelegates) == 0x000008, "Wrong alignment on UCommonUIDelegates");
static_assert(sizeof(UCommonUIDelegates) == 0x000030, "Wrong size on UCommonUIDelegates");

// Class DBDUIViewInterfaces.CompetenceContainerViewInterface
// 0x0000 (0x0000 - 0x0000)
class ICompetenceContainerViewInterface final
{
public:
	TScriptInterface<class IPerkViewInterface> GetPerkInterface(int32 Index_0);
	TScriptInterface<class ISkillViewInterface> GetSkillInterface(int32 Index_0);
	void RevealPerks(bool useAnimation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CompetenceContainerViewInterface">();
	}
	static class ICompetenceContainerViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICompetenceContainerViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ICompetenceContainerViewInterface) == 0x000001, "Wrong alignment on ICompetenceContainerViewInterface");
static_assert(sizeof(ICompetenceContainerViewInterface) == 0x000001, "Wrong size on ICompetenceContainerViewInterface");

// Class DBDUIViewInterfaces.CreditsViewInterface
// 0x0000 (0x0000 - 0x0000)
class ICreditsViewInterface final
{
public:
	void ScrollToEnd();
	void ScrollToName(const class FString& Name_0, float Delay);
	void SetText(const class FText& Text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CreditsViewInterface">();
	}
	static class ICreditsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICreditsViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ICreditsViewInterface) == 0x000001, "Wrong alignment on ICreditsViewInterface");
static_assert(sizeof(ICreditsViewInterface) == 0x000001, "Wrong size on ICreditsViewInterface");

// Class DBDUIViewInterfaces.CurrencyConversionPopupViewData
// 0x0030 (0x0220 - 0x01F0)
class UCurrencyConversionPopupViewData final : public UGenericPopupViewData
{
public:
	class FText                                   EventName;                                         // 0x01F0(0x0018)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	ECurrencyType                                 FromCurrencyType;                                  // 0x0208(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_209[0x3];                                      // 0x0209(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FromCurrencyAmount;                                // 0x020C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECurrencyType                                 ToCurrencyType;                                    // 0x0210(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_211[0x3];                                      // 0x0211(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ToCurrencyAmount;                                  // 0x0214(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_218[0x8];                                      // 0x0218(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurrencyConversionPopupViewData">();
	}
	static class UCurrencyConversionPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurrencyConversionPopupViewData>();
	}
};
static_assert(alignof(UCurrencyConversionPopupViewData) == 0x000010, "Wrong alignment on UCurrencyConversionPopupViewData");
static_assert(sizeof(UCurrencyConversionPopupViewData) == 0x000220, "Wrong size on UCurrencyConversionPopupViewData");
static_assert(offsetof(UCurrencyConversionPopupViewData, EventName) == 0x0001F0, "Member 'UCurrencyConversionPopupViewData::EventName' has a wrong offset!");
static_assert(offsetof(UCurrencyConversionPopupViewData, FromCurrencyType) == 0x000208, "Member 'UCurrencyConversionPopupViewData::FromCurrencyType' has a wrong offset!");
static_assert(offsetof(UCurrencyConversionPopupViewData, FromCurrencyAmount) == 0x00020C, "Member 'UCurrencyConversionPopupViewData::FromCurrencyAmount' has a wrong offset!");
static_assert(offsetof(UCurrencyConversionPopupViewData, ToCurrencyType) == 0x000210, "Member 'UCurrencyConversionPopupViewData::ToCurrencyType' has a wrong offset!");
static_assert(offsetof(UCurrencyConversionPopupViewData, ToCurrencyAmount) == 0x000214, "Member 'UCurrencyConversionPopupViewData::ToCurrencyAmount' has a wrong offset!");

// Class DBDUIViewInterfaces.CurrencyConversionPopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class ICurrencyConversionPopupViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurrencyConversionPopupViewInterface">();
	}
	static class ICurrencyConversionPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICurrencyConversionPopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ICurrencyConversionPopupViewInterface) == 0x000001, "Wrong alignment on ICurrencyConversionPopupViewInterface");
static_assert(sizeof(ICurrencyConversionPopupViewInterface) == 0x000001, "Wrong size on ICurrencyConversionPopupViewInterface");

// Class DBDUIViewInterfaces.DisplayStandViewInterface
// 0x0000 (0x0000 - 0x0000)
class IDisplayStandViewInterface final
{
public:
	void SetViewData(const struct FDisplayStandViewData& ViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisplayStandViewInterface">();
	}
	static class IDisplayStandViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDisplayStandViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IDisplayStandViewInterface) == 0x000001, "Wrong alignment on IDisplayStandViewInterface");
static_assert(sizeof(IDisplayStandViewInterface) == 0x000001, "Wrong size on IDisplayStandViewInterface");

// Class DBDUIViewInterfaces.EndGameCollapseBarViewInterface
// 0x0000 (0x0000 - 0x0000)
class IEndGameCollapseBarViewInterface final
{
public:
	void InitEndGameScenario();
	void SetEndGameScenarioProgressionMode(const bool isSlowMode);
	void SetEndGameScenarioProgressionValue(const float Amount, bool forceUpdate);
	void StartEndGameScenario();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndGameCollapseBarViewInterface">();
	}
	static class IEndGameCollapseBarViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEndGameCollapseBarViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IEndGameCollapseBarViewInterface) == 0x000001, "Wrong alignment on IEndGameCollapseBarViewInterface");
static_assert(sizeof(IEndGameCollapseBarViewInterface) == 0x000001, "Wrong size on IEndGameCollapseBarViewInterface");

// Class DBDUIViewInterfaces.EquippedItemViewInterface
// 0x0000 (0x0000 - 0x0000)
class IEquippedItemViewInterface final
{
public:
	void ClearData(bool fullClear);
	bool GetIsEquippedItemVisible();
	void SetActiveState(bool IsActive);
	void SetData(const struct FItemBundleViewData& itemBundleData);
	void SetFakeItem(bool isHoldingFakeItem, const struct FItemBundleViewData& itemBundleData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquippedItemViewInterface">();
	}
	static class IEquippedItemViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEquippedItemViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IEquippedItemViewInterface) == 0x000001, "Wrong alignment on IEquippedItemViewInterface");
static_assert(sizeof(IEquippedItemViewInterface) == 0x000001, "Wrong size on IEquippedItemViewInterface");

// Class DBDUIViewInterfaces.EquippedPowerViewInterface
// 0x0000 (0x0000 - 0x0000)
class IEquippedPowerViewInterface final
{
public:
	void ClearData();
	void SetActiveState(bool IsActive);
	void SetCarryingMode(const bool IsCarrying, const struct FPowerViewData& carryingViewData);
	void SetData(const struct FPowerBundleViewData& powerBundleData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquippedPowerViewInterface">();
	}
	static class IEquippedPowerViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEquippedPowerViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IEquippedPowerViewInterface) == 0x000001, "Wrong alignment on IEquippedPowerViewInterface");
static_assert(sizeof(IEquippedPowerViewInterface) == 0x000001, "Wrong size on IEquippedPowerViewInterface");

// Class DBDUIViewInterfaces.EventCollectionViewInterface
// 0x0000 (0x0000 - 0x0000)
class IEventCollectionViewInterface final
{
public:
	void Deinit();
	void DeselectReward();
	void DisableInstructionArchivesButton();
	void DisableInstructionChallengesButton();
	void DisableInstructionCurrencyButton();
	void DisableInstructionInputs();
	void DisableInstructionStoreButton();
	void Init(const struct FEventEntryPopupSkinUIData& skinData);
	void SetInstructionWidgetData(const struct FCustomizationItemOriginViewData& ViewData);
	void SetItemsData(const TArray<class UStoreCustomizationItemViewData*>& customizationRewardsData, const int32 selectedIndex);
	void SetPreviewAreaData(const struct FCustomizationItemPreviewAreaViewData& ViewData);
	void SetSelectedReward(const int32 selectedIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventCollectionViewInterface">();
	}
	static class IEventCollectionViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEventCollectionViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IEventCollectionViewInterface) == 0x000001, "Wrong alignment on IEventCollectionViewInterface");
static_assert(sizeof(IEventCollectionViewInterface) == 0x000001, "Wrong size on IEventCollectionViewInterface");

// Class DBDUIViewInterfaces.EventDetailsViewInterface
// 0x0000 (0x0000 - 0x0000)
class IEventDetailsViewInterface final
{
public:
	void Deinit();
	void Init(const struct FDetailsTabViewData& ViewData, const struct FEventEntryPopupSkinUIData& skinData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventDetailsViewInterface">();
	}
	static class IEventDetailsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEventDetailsViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IEventDetailsViewInterface) == 0x000001, "Wrong alignment on IEventDetailsViewInterface");
static_assert(sizeof(IEventDetailsViewInterface) == 0x000001, "Wrong size on IEventDetailsViewInterface");

// Class DBDUIViewInterfaces.EventEntryViewData
// 0x00F8 (0x0128 - 0x0030)
class UEventEntryViewData final : public UObject
{
public:
	class FName                                   eventID;                                           // 0x0030(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0040(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 Message;                                           // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              StartDate;                                         // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              EndDate;                                           // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   AvailabilityDates;                                 // 0x0078(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   eventFrameLabel;                                   // 0x0090(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ImageBannerText;                                   // 0x00A8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   EventTabMessage;                                   // 0x00C0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ImageTexture;                                      // 0x00D8(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ChallengesButtonSetId;                             // 0x0110(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldActivateUiTakeover;                          // 0x0120(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventEntryViewData">();
	}
	static class UEventEntryViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventEntryViewData>();
	}
};
static_assert(alignof(UEventEntryViewData) == 0x000008, "Wrong alignment on UEventEntryViewData");
static_assert(sizeof(UEventEntryViewData) == 0x000128, "Wrong size on UEventEntryViewData");
static_assert(offsetof(UEventEntryViewData, eventID) == 0x000030, "Member 'UEventEntryViewData::eventID' has a wrong offset!");
static_assert(offsetof(UEventEntryViewData, Title) == 0x000040, "Member 'UEventEntryViewData::Title' has a wrong offset!");
static_assert(offsetof(UEventEntryViewData, Message) == 0x000058, "Member 'UEventEntryViewData::Message' has a wrong offset!");
static_assert(offsetof(UEventEntryViewData, StartDate) == 0x000068, "Member 'UEventEntryViewData::StartDate' has a wrong offset!");
static_assert(offsetof(UEventEntryViewData, EndDate) == 0x000070, "Member 'UEventEntryViewData::EndDate' has a wrong offset!");
static_assert(offsetof(UEventEntryViewData, AvailabilityDates) == 0x000078, "Member 'UEventEntryViewData::AvailabilityDates' has a wrong offset!");
static_assert(offsetof(UEventEntryViewData, eventFrameLabel) == 0x000090, "Member 'UEventEntryViewData::eventFrameLabel' has a wrong offset!");
static_assert(offsetof(UEventEntryViewData, ImageBannerText) == 0x0000A8, "Member 'UEventEntryViewData::ImageBannerText' has a wrong offset!");
static_assert(offsetof(UEventEntryViewData, EventTabMessage) == 0x0000C0, "Member 'UEventEntryViewData::EventTabMessage' has a wrong offset!");
static_assert(offsetof(UEventEntryViewData, ImageTexture) == 0x0000D8, "Member 'UEventEntryViewData::ImageTexture' has a wrong offset!");
static_assert(offsetof(UEventEntryViewData, ChallengesButtonSetId) == 0x000110, "Member 'UEventEntryViewData::ChallengesButtonSetId' has a wrong offset!");
static_assert(offsetof(UEventEntryViewData, ShouldActivateUiTakeover) == 0x000120, "Member 'UEventEntryViewData::ShouldActivateUiTakeover' has a wrong offset!");

// Class DBDUIViewInterfaces.EventEntryViewInterface
// 0x0000 (0x0000 - 0x0000)
class IEventEntryViewInterface final
{
public:
	void ChangeSelectedTab(const int32 Key);
	void DeselectMilestoneTrackerItems();
	bool GetRowDataFromEventSkinDataTable(struct FEventEntryPopupSkinUIData* skinData, const class FText& eventFrameLabel);
	void InitializeOverlay(class UEventEntryViewData* ViewData);
	void PlayMilestoneTrackerItemUnlockAnimation(const int32 Index_0);
	void RequestOverlayClosure();
	void SelectMilestoneTrackerItem(class FName ItemId);
	void SetMilestoneTrackerData(const struct FMilestoneTrackerViewData& ViewData);
	void SetMilestoneTrackerVisibility(bool IsVisible);
	void SetOverlayState(const EEventEntryTabState& tabState);
	void SetTabsData(const TArray<struct FTabWidgetData>& tabsData, const int32 SelectedKey);

	TScriptInterface<class IEventCollectionViewInterface> GetCollectionSubPresenterInterface() const;
	TScriptInterface<class IEventDetailsViewInterface> GetDetailsSubPresenterInterface() const;
	class UDataTable* GetEventSkinDataTable() const;
	TScriptInterface<class IEventInfoViewInterface> GetEventSubPresenterInterface() const;
	TScriptInterface<class IEventCollectionViewInterface> GetStoreSubPresenterInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventEntryViewInterface">();
	}
	static class IEventEntryViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEventEntryViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IEventEntryViewInterface) == 0x000001, "Wrong alignment on IEventEntryViewInterface");
static_assert(sizeof(IEventEntryViewInterface) == 0x000001, "Wrong size on IEventEntryViewInterface");

// Class DBDUIViewInterfaces.EventTabViewData
// 0x0060 (0x0090 - 0x0030)
class UEventTabViewData final : public UObject
{
public:
	TSoftObjectPtr<class UTexture2D>              ImageTexture;                                      // 0x0030(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ChallengesButtonSetId;                             // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Message;                                           // 0x0078(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventTabViewData">();
	}
	static class UEventTabViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventTabViewData>();
	}
};
static_assert(alignof(UEventTabViewData) == 0x000008, "Wrong alignment on UEventTabViewData");
static_assert(sizeof(UEventTabViewData) == 0x000090, "Wrong size on UEventTabViewData");
static_assert(offsetof(UEventTabViewData, ImageTexture) == 0x000030, "Member 'UEventTabViewData::ImageTexture' has a wrong offset!");
static_assert(offsetof(UEventTabViewData, ChallengesButtonSetId) == 0x000068, "Member 'UEventTabViewData::ChallengesButtonSetId' has a wrong offset!");
static_assert(offsetof(UEventTabViewData, Message) == 0x000078, "Member 'UEventTabViewData::Message' has a wrong offset!");

// Class DBDUIViewInterfaces.EventInfoViewInterface
// 0x0000 (0x0000 - 0x0000)
class IEventInfoViewInterface final
{
public:
	void Deinit();
	void GetRowDataFromEventObjectiveTrackerSkinDataTable(const class FString& eventID);
	void Init(class UEventTabViewData* ViewData, const struct FEventEntryPopupSkinUIData& skinData);
	void SetChallengesButtonEnabled(bool IsEnabled);
	void SetChallengesButtonVisibility(bool IsVisible);
	void SetEventObjectiveTrackerData(const struct FEventObjectiveTrackerViewData& ViewData);
	void SetEventObjectiveTrackerVisibility(const bool IsVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventInfoViewInterface">();
	}
	static class IEventInfoViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEventInfoViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IEventInfoViewInterface) == 0x000001, "Wrong alignment on IEventInfoViewInterface");
static_assert(sizeof(IEventInfoViewInterface) == 0x000001, "Wrong size on IEventInfoViewInterface");

// Class DBDUIViewInterfaces.ExampleViewInterface
// 0x0000 (0x0000 - 0x0000)
class IExampleViewInterface final
{
public:
	void SetExampleProgressRatio(float Ratio);
	void SetExampleText(const class FString& Text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExampleViewInterface">();
	}
	static class IExampleViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IExampleViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IExampleViewInterface) == 0x000001, "Wrong alignment on IExampleViewInterface");
static_assert(sizeof(IExampleViewInterface) == 0x000001, "Wrong size on IExampleViewInterface");

// Class DBDUIViewInterfaces.ExternalEffectsViewInterface
// 0x0000 (0x0000 - 0x0000)
class IExternalEffectsViewInterface final
{
public:
	void HideAllExternalAddons();
	void HideAllExternalPerks();
	void HideExternalAddon(const class FName ItemId);
	void HideExternalPerk(const class FName ItemId);
	void HideExternalSkill(const class FName ItemId);
	void ShowExternalAddon(const struct FAddonViewData& AddonViewData);
	void ShowExternalPerk(const struct FPerkViewData& PerkViewData);
	void ShowExternalSkill(const struct FSkillViewData& SkillViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExternalEffectsViewInterface">();
	}
	static class IExternalEffectsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IExternalEffectsViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IExternalEffectsViewInterface) == 0x000001, "Wrong alignment on IExternalEffectsViewInterface");
static_assert(sizeof(IExternalEffectsViewInterface) == 0x000001, "Wrong size on IExternalEffectsViewInterface");

// Class DBDUIViewInterfaces.FearMarketPopupViewData
// 0x0020 (0x0210 - 0x01F0)
class UFearMarketPopupViewData final : public UGenericPopupViewData
{
public:
	class UMenuPerkViewData*                      ItemData;                                          // 0x01F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost;                                              // 0x01F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BloodpointConversion;                              // 0x01FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPurchased;                                       // 0x0200(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AlreadyOwned;                                      // 0x0201(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_202[0x2];                                      // 0x0202(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AvailableTokens;                                   // 0x0204(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_208[0x8];                                      // 0x0208(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FearMarketPopupViewData">();
	}
	static class UFearMarketPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFearMarketPopupViewData>();
	}
};
static_assert(alignof(UFearMarketPopupViewData) == 0x000010, "Wrong alignment on UFearMarketPopupViewData");
static_assert(sizeof(UFearMarketPopupViewData) == 0x000210, "Wrong size on UFearMarketPopupViewData");
static_assert(offsetof(UFearMarketPopupViewData, ItemData) == 0x0001F0, "Member 'UFearMarketPopupViewData::ItemData' has a wrong offset!");
static_assert(offsetof(UFearMarketPopupViewData, Cost) == 0x0001F8, "Member 'UFearMarketPopupViewData::Cost' has a wrong offset!");
static_assert(offsetof(UFearMarketPopupViewData, BloodpointConversion) == 0x0001FC, "Member 'UFearMarketPopupViewData::BloodpointConversion' has a wrong offset!");
static_assert(offsetof(UFearMarketPopupViewData, IsPurchased) == 0x000200, "Member 'UFearMarketPopupViewData::IsPurchased' has a wrong offset!");
static_assert(offsetof(UFearMarketPopupViewData, AlreadyOwned) == 0x000201, "Member 'UFearMarketPopupViewData::AlreadyOwned' has a wrong offset!");
static_assert(offsetof(UFearMarketPopupViewData, AvailableTokens) == 0x000204, "Member 'UFearMarketPopupViewData::AvailableTokens' has a wrong offset!");

// Class DBDUIViewInterfaces.FearMarketPopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class IFearMarketPopupViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FearMarketPopupViewInterface">();
	}
	static class IFearMarketPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFearMarketPopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IFearMarketPopupViewInterface) == 0x000001, "Wrong alignment on IFearMarketPopupViewInterface");
static_assert(sizeof(IFearMarketPopupViewInterface) == 0x000001, "Wrong size on IFearMarketPopupViewInterface");

// Class DBDUIViewInterfaces.FriendSearchPopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class IFriendSearchPopupViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FriendSearchPopupViewInterface">();
	}
	static class IFriendSearchPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFriendSearchPopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IFriendSearchPopupViewInterface) == 0x000001, "Wrong alignment on IFriendSearchPopupViewInterface");
static_assert(sizeof(IFriendSearchPopupViewInterface) == 0x000001, "Wrong size on IFriendSearchPopupViewInterface");

// Class DBDUIViewInterfaces.GameManualViewInterface
// 0x0000 (0x0000 - 0x0000)
class IGameManualViewInterface final
{
public:
	void SetCategoryData(const struct FHelpCategoryData& categoryData, const TArray<struct FHelpTopicData>& topicsData);
	void SetCurrentManualMenuState(const EGameManualMenuState menuState);

	const EGameManualMenuState GetCurrentManualMenuState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameManualViewInterface">();
	}
	static class IGameManualViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGameManualViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IGameManualViewInterface) == 0x000001, "Wrong alignment on IGameManualViewInterface");
static_assert(sizeof(IGameManualViewInterface) == 0x000001, "Wrong size on IGameManualViewInterface");

// Class DBDUIViewInterfaces.GammaSettingsPopupViewData
// 0x0010 (0x0200 - 0x01F0)
class UGammaSettingsPopupViewData final : public UGenericPopupViewData
{
public:
	float                                         gamma;                                             // 0x01F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F4[0xC];                                      // 0x01F4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GammaSettingsPopupViewData">();
	}
	static class UGammaSettingsPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGammaSettingsPopupViewData>();
	}
};
static_assert(alignof(UGammaSettingsPopupViewData) == 0x000010, "Wrong alignment on UGammaSettingsPopupViewData");
static_assert(sizeof(UGammaSettingsPopupViewData) == 0x000200, "Wrong size on UGammaSettingsPopupViewData");
static_assert(offsetof(UGammaSettingsPopupViewData, gamma) == 0x0001F0, "Member 'UGammaSettingsPopupViewData::gamma' has a wrong offset!");

// Class DBDUIViewInterfaces.GenericPopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class IGenericPopupViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericPopupViewInterface">();
	}
	static class IGenericPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGenericPopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IGenericPopupViewInterface) == 0x000001, "Wrong alignment on IGenericPopupViewInterface");
static_assert(sizeof(IGenericPopupViewInterface) == 0x000001, "Wrong size on IGenericPopupViewInterface");

// Class DBDUIViewInterfaces.GenericRefreshingPopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class IGenericRefreshingPopupViewInterface final
{
public:
	void Refresh(float RemainingTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericRefreshingPopupViewInterface">();
	}
	static class IGenericRefreshingPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGenericRefreshingPopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IGenericRefreshingPopupViewInterface) == 0x000001, "Wrong alignment on IGenericRefreshingPopupViewInterface");
static_assert(sizeof(IGenericRefreshingPopupViewInterface) == 0x000001, "Wrong size on IGenericRefreshingPopupViewInterface");

// Class DBDUIViewInterfaces.GenericTextInputPopupViewData
// 0x00F0 (0x02E0 - 0x01F0)
class UGenericTextInputPopupViewData final : public UGenericPopupViewData
{
public:
	class FString                                 InputDefaultText;                                  // 0x01F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SavedText;                                         // 0x0200(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowCopyPaste;                                    // 0x0210(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoFocusTextInput;                                // 0x0211(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_212[0x2];                                      // 0x0212(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CharacterLimit;                                    // 0x0214(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_218[0xC8];                                     // 0x0218(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericTextInputPopupViewData">();
	}
	static class UGenericTextInputPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGenericTextInputPopupViewData>();
	}
};
static_assert(alignof(UGenericTextInputPopupViewData) == 0x000010, "Wrong alignment on UGenericTextInputPopupViewData");
static_assert(sizeof(UGenericTextInputPopupViewData) == 0x0002E0, "Wrong size on UGenericTextInputPopupViewData");
static_assert(offsetof(UGenericTextInputPopupViewData, InputDefaultText) == 0x0001F0, "Member 'UGenericTextInputPopupViewData::InputDefaultText' has a wrong offset!");
static_assert(offsetof(UGenericTextInputPopupViewData, SavedText) == 0x000200, "Member 'UGenericTextInputPopupViewData::SavedText' has a wrong offset!");
static_assert(offsetof(UGenericTextInputPopupViewData, AllowCopyPaste) == 0x000210, "Member 'UGenericTextInputPopupViewData::AllowCopyPaste' has a wrong offset!");
static_assert(offsetof(UGenericTextInputPopupViewData, AutoFocusTextInput) == 0x000211, "Member 'UGenericTextInputPopupViewData::AutoFocusTextInput' has a wrong offset!");
static_assert(offsetof(UGenericTextInputPopupViewData, CharacterLimit) == 0x000214, "Member 'UGenericTextInputPopupViewData::CharacterLimit' has a wrong offset!");

// Class DBDUIViewInterfaces.GenericTextInputPopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class IGenericTextInputPopupViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericTextInputPopupViewInterface">();
	}
	static class IGenericTextInputPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGenericTextInputPopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IGenericTextInputPopupViewInterface) == 0x000001, "Wrong alignment on IGenericTextInputPopupViewInterface");
static_assert(sizeof(IGenericTextInputPopupViewInterface) == 0x000001, "Wrong size on IGenericTextInputPopupViewInterface");

// Class DBDUIViewInterfaces.GradeChangePopupViewData
// 0x0050 (0x0240 - 0x01F0)
class UGradeChangePopupViewData final : public UGenericPopupViewData
{
public:
	struct FRankViewData                          OldGradeViewData;                                  // 0x01F0(0x0028)(Edit, BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	struct FRankViewData                          NewGradeViewData;                                  // 0x0218(0x0028)(Edit, BlueprintVisible, Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GradeChangePopupViewData">();
	}
	static class UGradeChangePopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGradeChangePopupViewData>();
	}
};
static_assert(alignof(UGradeChangePopupViewData) == 0x000010, "Wrong alignment on UGradeChangePopupViewData");
static_assert(sizeof(UGradeChangePopupViewData) == 0x000240, "Wrong size on UGradeChangePopupViewData");
static_assert(offsetof(UGradeChangePopupViewData, OldGradeViewData) == 0x0001F0, "Member 'UGradeChangePopupViewData::OldGradeViewData' has a wrong offset!");
static_assert(offsetof(UGradeChangePopupViewData, NewGradeViewData) == 0x000218, "Member 'UGradeChangePopupViewData::NewGradeViewData' has a wrong offset!");

// Class DBDUIViewInterfaces.GradeChangePopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class IGradeChangePopupViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GradeChangePopupViewInterface">();
	}
	static class IGradeChangePopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGradeChangePopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IGradeChangePopupViewInterface) == 0x000001, "Wrong alignment on IGradeChangePopupViewInterface");
static_assert(sizeof(IGradeChangePopupViewInterface) == 0x000001, "Wrong size on IGradeChangePopupViewInterface");

// Class DBDUIViewInterfaces.HideableHudViewInterface
// 0x0000 (0x0000 - 0x0000)
class IHideableHudViewInterface final
{
public:
	void ToggleForcedVisibility(uint8 invisibilityFlag, bool Visible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HideableHudViewInterface">();
	}
	static class IHideableHudViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHideableHudViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHideableHudViewInterface) == 0x000001, "Wrong alignment on IHideableHudViewInterface");
static_assert(sizeof(IHideableHudViewInterface) == 0x000001, "Wrong size on IHideableHudViewInterface");

// Class DBDUIViewInterfaces.HookCountViewInterface
// 0x0000 (0x0000 - 0x0000)
class IHookCountViewInterface final
{
public:
	void ClearData();
	void InitWidget(const EGameType gameType, const int32 numberOfSegments);
	void SetData(const int32 currentHookCount, const int32 maxHookCount, const int32 initialMaxHookCount, const TSet<int32>& assistedHookIndices, const bool isFinisherMoriAvailable);
	void SetHookCountVisibility(bool Visible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HookCountViewInterface">();
	}
	static class IHookCountViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHookCountViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHookCountViewInterface) == 0x000001, "Wrong alignment on IHookCountViewInterface");
static_assert(sizeof(IHookCountViewInterface) == 0x000001, "Wrong size on IHookCountViewInterface");

// Class DBDUIViewInterfaces.HudAimingCrosshairViewInterface
// 0x0000 (0x0000 - 0x0000)
class IHudAimingCrosshairViewInterface final
{
public:
	void SetProgress(const float Progress);
	void SetState(const EAimingCrosshairState newState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HudAimingCrosshairViewInterface">();
	}
	static class IHudAimingCrosshairViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHudAimingCrosshairViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHudAimingCrosshairViewInterface) == 0x000001, "Wrong alignment on IHudAimingCrosshairViewInterface");
static_assert(sizeof(IHudAimingCrosshairViewInterface) == 0x000001, "Wrong size on IHudAimingCrosshairViewInterface");

// Class DBDUIViewInterfaces.HudAlertViewInterface
// 0x0000 (0x0000 - 0x0000)
class IHudAlertViewInterface final
{
public:
	void FadeIn();
	void FadeOut(float Delay);
	void SetScoreEventsVisibility(bool Visible);
	void ShowScoreAlert(const struct FScoreAlertViewData& Data);
	void ShowStatusEffectAlert(const struct FStatusEffectAlertViewData& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HudAlertViewInterface">();
	}
	static class IHudAlertViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHudAlertViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHudAlertViewInterface) == 0x000001, "Wrong alignment on IHudAlertViewInterface");
static_assert(sizeof(IHudAlertViewInterface) == 0x000001, "Wrong size on IHudAlertViewInterface");

// Class DBDUIViewInterfaces.HudDirectionalMiniGameViewInterface
// 0x0000 (0x0000 - 0x0000)
class IHudDirectionalMiniGameViewInterface final
{
public:
	void Hide();
	void Init(int32 maxItems, EDirectionalMiniGameType Type);
	void Show(const TArray<EDirectionalInputKey>& directions);
	void UpdateFinalResult(EDirectionalMinigameResult finalResult);
	void UpdateResult(int32 Index_0, bool IsSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HudDirectionalMiniGameViewInterface">();
	}
	static class IHudDirectionalMiniGameViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHudDirectionalMiniGameViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHudDirectionalMiniGameViewInterface) == 0x000001, "Wrong alignment on IHudDirectionalMiniGameViewInterface");
static_assert(sizeof(IHudDirectionalMiniGameViewInterface) == 0x000001, "Wrong size on IHudDirectionalMiniGameViewInterface");

// Class DBDUIViewInterfaces.HudEffectCardViewInterface
// 0x0000 (0x0000 - 0x0000)
class IHudEffectCardViewInterface final
{
public:
	void ActivateNextCard();
	void FadeIn();
	void FadeOut();
	void SetData(const TArray<struct FEffectCardViewData>& effectCardsViewData, const int32 activeCardIndex, const int32 Points, const float activeCardTime);
	void SetMatchPoints(const int32 Points);
	void UpdateTimerFeedback(const float ElapsedTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HudEffectCardViewInterface">();
	}
	static class IHudEffectCardViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHudEffectCardViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHudEffectCardViewInterface) == 0x000001, "Wrong alignment on IHudEffectCardViewInterface");
static_assert(sizeof(IHudEffectCardViewInterface) == 0x000001, "Wrong size on IHudEffectCardViewInterface");

// Class DBDUIViewInterfaces.HudEventObjectiveItemViewInterface
// 0x0000 (0x0000 - 0x0000)
class IHudEventObjectiveItemViewInterface final
{
public:
	void BP_OnStateAnimationFinished(const EEventObjectiveItemState finishedEventItemState);
	void ClearData();
	void InitWidget(bool isLocalKiller);
	void SetAction(const struct FGameplayTag& Tag);
	void SetAvailableCharges(const int32 charges, const int32 maxCharges);
	void SetChargePercentage(const float ChargePercent);
	void SetCooldownPercentage(const float cooldownPercent);
	void SetInputKey(const struct FKey& InputKey);
	void SetWidgetData(const EEventObjectiveItemState eventItemState, const int32 charges, const int32 maxCharges, const float ChargePercent);
	void SetWidgetState(const EEventObjectiveItemState eventItemState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HudEventObjectiveItemViewInterface">();
	}
	static class IHudEventObjectiveItemViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHudEventObjectiveItemViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHudEventObjectiveItemViewInterface) == 0x000001, "Wrong alignment on IHudEventObjectiveItemViewInterface");
static_assert(sizeof(IHudEventObjectiveItemViewInterface) == 0x000001, "Wrong size on IHudEventObjectiveItemViewInterface");

// Class DBDUIViewInterfaces.HudEventProgression2023ViewInterface
// 0x0000 (0x0000 - 0x0000)
class IHudEventProgression2023ViewInterface final
{
public:
	void EnableEventProgression(const bool IsEnabled);
	void InitEventProgression(const struct FHudEventProgression2023ViewData& HudEventProgressionViewData);
	void UpdateEnergyProgress(const struct FHudEventProgression2023ViewData& HudEventProgressionViewData);
	void UpdateHauntTarget(const struct FHudEventProgression2023ViewData& HudEventProgressionViewData);
	void UpdateVoidZoneState(const struct FHudEventProgression2023ViewData& HudEventProgressionViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HudEventProgression2023ViewInterface">();
	}
	static class IHudEventProgression2023ViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHudEventProgression2023ViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHudEventProgression2023ViewInterface) == 0x000001, "Wrong alignment on IHudEventProgression2023ViewInterface");
static_assert(sizeof(IHudEventProgression2023ViewInterface) == 0x000001, "Wrong size on IHudEventProgression2023ViewInterface");

// Class DBDUIViewInterfaces.HudEventProgressionViewInterface
// 0x0000 (0x0000 - 0x0000)
class IHudEventProgressionViewInterface final
{
public:
	void EnableEventProgression(const bool IsEnabled);
	void InitEventProgression(const struct FHudEventProgressionViewData& HudEventProgressionViewData);
	void UpdateEventBankedProgress(const struct FHudEventProgressionViewData& HudEventProgressionViewData);
	void UpdateEventPendingProgress(const struct FHudEventProgressionViewData& HudEventProgressionViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HudEventProgressionViewInterface">();
	}
	static class IHudEventProgressionViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHudEventProgressionViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHudEventProgressionViewInterface) == 0x000001, "Wrong alignment on IHudEventProgressionViewInterface");
static_assert(sizeof(IHudEventProgressionViewInterface) == 0x000001, "Wrong size on IHudEventProgressionViewInterface");

// Class DBDUIViewInterfaces.HudItemPickupViewInterface
// 0x0000 (0x0000 - 0x0000)
class IHudItemPickupViewInterface final
{
public:
	void HideItemPickupPrompt();
	void SetData(const struct FItemPickupViewData& itemToPickUpData, const struct FItemPickupViewData& currentItem);
	void ShowItemPickupPrompt();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HudItemPickupViewInterface">();
	}
	static class IHudItemPickupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHudItemPickupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHudItemPickupViewInterface) == 0x000001, "Wrong alignment on IHudItemPickupViewInterface");
static_assert(sizeof(IHudItemPickupViewInterface) == 0x000001, "Wrong size on IHudItemPickupViewInterface");

// Class DBDUIViewInterfaces.HudObjectivesViewInterface
// 0x0000 (0x0000 - 0x0000)
class IHudObjectivesViewInterface final
{
public:
	void ClearData();
	void ClearHookCountData();
	void HighlightGeneratorCompleted(const bool isFuelGenerator);
	void InitWidget(const EGameType gameType, const int32 numberOfSegments);
	void SetHookCountData(const int32 currentHookCount, const int32 maxHookCount, const int32 initialMaxHookCount, const TSet<int32>& assistedHookIndices, const bool isFinisherMoriAvailable);
	void SetHookCountVisibility(bool Visible);
	void SetHudObjectiveData(const struct FHudObjectivesViewData& hudObjectiveViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HudObjectivesViewInterface">();
	}
	static class IHudObjectivesViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHudObjectivesViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHudObjectivesViewInterface) == 0x000001, "Wrong alignment on IHudObjectivesViewInterface");
static_assert(sizeof(IHudObjectivesViewInterface) == 0x000001, "Wrong size on IHudObjectivesViewInterface");

// Class DBDUIViewInterfaces.InboxBodySectionViewData
// 0x00E0 (0x0110 - 0x0030)
class UInboxBodySectionViewData final : public UObject
{
public:
	ENewsAndMessagesSectionType                   Type;                                              // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Text;                                              // 0x0038(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	struct FSoftRemoteContentCacheObjectPtr       Image;                                             // 0x0050(0x0070)(BlueprintVisible, BlueprintReadOnly, Transient, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRewardWrapperViewData>         Rewards;                                           // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class UTexture2D*                             QRCode;                                            // 0x00D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInboxSkinUIData                       skinData;                                          // 0x00D8(0x0038)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InboxBodySectionViewData">();
	}
	static class UInboxBodySectionViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInboxBodySectionViewData>();
	}
};
static_assert(alignof(UInboxBodySectionViewData) == 0x000008, "Wrong alignment on UInboxBodySectionViewData");
static_assert(sizeof(UInboxBodySectionViewData) == 0x000110, "Wrong size on UInboxBodySectionViewData");
static_assert(offsetof(UInboxBodySectionViewData, Type) == 0x000030, "Member 'UInboxBodySectionViewData::Type' has a wrong offset!");
static_assert(offsetof(UInboxBodySectionViewData, Text) == 0x000038, "Member 'UInboxBodySectionViewData::Text' has a wrong offset!");
static_assert(offsetof(UInboxBodySectionViewData, Image) == 0x000050, "Member 'UInboxBodySectionViewData::Image' has a wrong offset!");
static_assert(offsetof(UInboxBodySectionViewData, Rewards) == 0x0000C0, "Member 'UInboxBodySectionViewData::Rewards' has a wrong offset!");
static_assert(offsetof(UInboxBodySectionViewData, QRCode) == 0x0000D0, "Member 'UInboxBodySectionViewData::QRCode' has a wrong offset!");
static_assert(offsetof(UInboxBodySectionViewData, skinData) == 0x0000D8, "Member 'UInboxBodySectionViewData::skinData' has a wrong offset!");

// Class DBDUIViewInterfaces.InboxBodyViewData
// 0x00E0 (0x0110 - 0x0030)
class UInboxBodyViewData final : public UObject
{
public:
	TArray<class UInboxBodySectionViewData*>      Sections;                                          // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	struct FSoftRemoteContentCacheObjectPtr       Image;                                             // 0x0040(0x0070)(BlueprintVisible, BlueprintReadOnly, Transient, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInboxCallToActionViewData             CallToAction;                                      // 0x00B0(0x0058)(BlueprintVisible, BlueprintReadOnly, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	bool                                          HasCallToAction;                                   // 0x0108(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InboxBodyViewData">();
	}
	static class UInboxBodyViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInboxBodyViewData>();
	}
};
static_assert(alignof(UInboxBodyViewData) == 0x000008, "Wrong alignment on UInboxBodyViewData");
static_assert(sizeof(UInboxBodyViewData) == 0x000110, "Wrong size on UInboxBodyViewData");
static_assert(offsetof(UInboxBodyViewData, Sections) == 0x000030, "Member 'UInboxBodyViewData::Sections' has a wrong offset!");
static_assert(offsetof(UInboxBodyViewData, Image) == 0x000040, "Member 'UInboxBodyViewData::Image' has a wrong offset!");
static_assert(offsetof(UInboxBodyViewData, CallToAction) == 0x0000B0, "Member 'UInboxBodyViewData::CallToAction' has a wrong offset!");
static_assert(offsetof(UInboxBodyViewData, HasCallToAction) == 0x000108, "Member 'UInboxBodyViewData::HasCallToAction' has a wrong offset!");

// Class DBDUIViewInterfaces.InboxItemViewData
// 0x00C8 (0x00F8 - 0x0030)
class UInboxItemViewData final : public UObject
{
public:
	class FName                                   ID;                                                // 0x0030(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0040(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class FText                                   subtitle;                                          // 0x0058(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class FText                                   ExpirationMessage;                                 // 0x0070(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	ENewsAndMessagesIconType                      IconType;                                          // 0x0088(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNew;                                             // 0x0089(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSticky;                                          // 0x008A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B[0x5];                                       // 0x008B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        SortWeight;                                        // 0x0090(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              StartDate;                                         // 0x0098(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ExpirationDate;                                    // 0x00A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInboxRewardStatus                            RewardStatus;                                      // 0x00A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UInboxBodyViewData*                     BodyViewData;                                      // 0x00B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         MessageId;                                         // 0x00B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInboxSkinUIData                       skinData;                                          // 0x00C0(0x0038)(BlueprintVisible, BlueprintReadOnly, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InboxItemViewData">();
	}
	static class UInboxItemViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInboxItemViewData>();
	}
};
static_assert(alignof(UInboxItemViewData) == 0x000008, "Wrong alignment on UInboxItemViewData");
static_assert(sizeof(UInboxItemViewData) == 0x0000F8, "Wrong size on UInboxItemViewData");
static_assert(offsetof(UInboxItemViewData, ID) == 0x000030, "Member 'UInboxItemViewData::ID' has a wrong offset!");
static_assert(offsetof(UInboxItemViewData, Title) == 0x000040, "Member 'UInboxItemViewData::Title' has a wrong offset!");
static_assert(offsetof(UInboxItemViewData, subtitle) == 0x000058, "Member 'UInboxItemViewData::subtitle' has a wrong offset!");
static_assert(offsetof(UInboxItemViewData, ExpirationMessage) == 0x000070, "Member 'UInboxItemViewData::ExpirationMessage' has a wrong offset!");
static_assert(offsetof(UInboxItemViewData, IconType) == 0x000088, "Member 'UInboxItemViewData::IconType' has a wrong offset!");
static_assert(offsetof(UInboxItemViewData, IsNew) == 0x000089, "Member 'UInboxItemViewData::IsNew' has a wrong offset!");
static_assert(offsetof(UInboxItemViewData, IsSticky) == 0x00008A, "Member 'UInboxItemViewData::IsSticky' has a wrong offset!");
static_assert(offsetof(UInboxItemViewData, SortWeight) == 0x000090, "Member 'UInboxItemViewData::SortWeight' has a wrong offset!");
static_assert(offsetof(UInboxItemViewData, StartDate) == 0x000098, "Member 'UInboxItemViewData::StartDate' has a wrong offset!");
static_assert(offsetof(UInboxItemViewData, ExpirationDate) == 0x0000A0, "Member 'UInboxItemViewData::ExpirationDate' has a wrong offset!");
static_assert(offsetof(UInboxItemViewData, RewardStatus) == 0x0000A8, "Member 'UInboxItemViewData::RewardStatus' has a wrong offset!");
static_assert(offsetof(UInboxItemViewData, BodyViewData) == 0x0000B0, "Member 'UInboxItemViewData::BodyViewData' has a wrong offset!");
static_assert(offsetof(UInboxItemViewData, MessageId) == 0x0000B8, "Member 'UInboxItemViewData::MessageId' has a wrong offset!");
static_assert(offsetof(UInboxItemViewData, skinData) == 0x0000C0, "Member 'UInboxItemViewData::skinData' has a wrong offset!");

// Class DBDUIViewInterfaces.InboxViewInterface
// 0x0000 (0x0000 - 0x0000)
class IInboxViewInterface final
{
public:
	void SetData(const EInboxTab Tab, const TArray<class UInboxItemViewData*>& Data);
	void SetEmpty(const EInboxTab Tab);
	void SetError(const EInboxTab Tab);
	void SetLoading(const EInboxTab Tab);
	void SetSelectedItem(const class UInboxItemViewData* ViewData, const EInboxTab Tab);
	void SetSupportMessageText(const class FText& supportMessage);
	void SetTabNotificationIcon(const EInboxTab Tab, const bool showNotificationIcon);
	void SetTabsData(const TArray<struct FTabWidgetData>& tabsData, const EInboxTab selectedTab);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InboxViewInterface">();
	}
	static class IInboxViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInboxViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IInboxViewInterface) == 0x000001, "Wrong alignment on IInboxViewInterface");
static_assert(sizeof(IInboxViewInterface) == 0x000001, "Wrong size on IInboxViewInterface");

// Class DBDUIViewInterfaces.InteractionProgressViewInterface
// 0x0000 (0x0000 - 0x0000)
class IInteractionProgressViewInterface final
{
public:
	void HideInputProgressPrompt();
	void PlayHemorrhageAnimation();
	void SetInputProgressPrompt(const struct FInteractionProgressViewData& Data);
	void UpdateInputProgress(const float Progress, const float ItemCharge, bool IsBlocked, float PercentageStopDischarge);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionProgressViewInterface">();
	}
	static class IInteractionProgressViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInteractionProgressViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IInteractionProgressViewInterface) == 0x000001, "Wrong alignment on IInteractionProgressViewInterface");
static_assert(sizeof(IInteractionProgressViewInterface) == 0x000001, "Wrong size on IInteractionProgressViewInterface");

// Class DBDUIViewInterfaces.InteractionPromptsContainerViewInterface
// 0x0000 (0x0000 - 0x0000)
class IInteractionPromptsContainerViewInterface final
{
public:
	void AddPrompt(const struct FInteractionPromptViewData& Data);
	void RemoveAllPrompts();
	void RemovePrompt(class FName ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionPromptsContainerViewInterface">();
	}
	static class IInteractionPromptsContainerViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInteractionPromptsContainerViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IInteractionPromptsContainerViewInterface) == 0x000001, "Wrong alignment on IInteractionPromptsContainerViewInterface");
static_assert(sizeof(IInteractionPromptsContainerViewInterface) == 0x000001, "Wrong size on IInteractionPromptsContainerViewInterface");

// Class DBDUIViewInterfaces.ItemBundleViewInterface
// 0x0000 (0x0000 - 0x0000)
class IItemBundleViewInterface final
{
public:
	void ClearData();
	void SetData(const struct FItemBundleViewData& ItemBundleViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemBundleViewInterface">();
	}
	static class IItemBundleViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IItemBundleViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IItemBundleViewInterface) == 0x000001, "Wrong alignment on IItemBundleViewInterface");
static_assert(sizeof(IItemBundleViewInterface) == 0x000001, "Wrong size on IItemBundleViewInterface");

// Class DBDUIViewInterfaces.ItemInteractionViewInterface
// 0x0000 (0x0000 - 0x0000)
class IItemInteractionViewInterface final
{
public:
	void ClearData();
	void SetData(const struct FItemBundleViewData& itemBundleData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemInteractionViewInterface">();
	}
	static class IItemInteractionViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IItemInteractionViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IItemInteractionViewInterface) == 0x000001, "Wrong alignment on IItemInteractionViewInterface");
static_assert(sizeof(IItemInteractionViewInterface) == 0x000001, "Wrong size on IItemInteractionViewInterface");

// Class DBDUIViewInterfaces.ItemSummaryPopupViewData
// 0x0010 (0x0200 - 0x01F0)
class UItemSummaryPopupViewData final : public UGenericPopupViewData
{
public:
	TArray<class ULoadoutItemViewData*>           ItemData;                                          // 0x01F0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemSummaryPopupViewData">();
	}
	static class UItemSummaryPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemSummaryPopupViewData>();
	}
};
static_assert(alignof(UItemSummaryPopupViewData) == 0x000010, "Wrong alignment on UItemSummaryPopupViewData");
static_assert(sizeof(UItemSummaryPopupViewData) == 0x000200, "Wrong size on UItemSummaryPopupViewData");
static_assert(offsetof(UItemSummaryPopupViewData, ItemData) == 0x0001F0, "Member 'UItemSummaryPopupViewData::ItemData' has a wrong offset!");

// Class DBDUIViewInterfaces.ItemSummaryPopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class IItemSummaryPopupViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemSummaryPopupViewInterface">();
	}
	static class IItemSummaryPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IItemSummaryPopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IItemSummaryPopupViewInterface) == 0x000001, "Wrong alignment on IItemSummaryPopupViewInterface");
static_assert(sizeof(IItemSummaryPopupViewInterface) == 0x000001, "Wrong size on IItemSummaryPopupViewInterface");

// Class DBDUIViewInterfaces.ItemViewInterface
// 0x0000 (0x0000 - 0x0000)
class IItemViewInterface final
{
public:
	void ClearData();
	void SetData(const struct FItemViewData& ItemViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemViewInterface">();
	}
	static class IItemViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IItemViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IItemViewInterface) == 0x000001, "Wrong alignment on IItemViewInterface");
static_assert(sizeof(IItemViewInterface) == 0x000001, "Wrong size on IItemViewInterface");

// Class DBDUIViewInterfaces.KillerStatusViewInterface
// 0x0000 (0x0000 - 0x0000)
class IKillerStatusViewInterface final
{
public:
	void ClearData();
	void SetData(const struct FPlayerStatusViewData& Data);
	void SetPlayerNameVisibility(bool Visible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerStatusViewInterface">();
	}
	static class IKillerStatusViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IKillerStatusViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IKillerStatusViewInterface) == 0x000001, "Wrong alignment on IKillerStatusViewInterface");
static_assert(sizeof(IKillerStatusViewInterface) == 0x000001, "Wrong size on IKillerStatusViewInterface");

// Class DBDUIViewInterfaces.LeaningArrowsViewInterface
// 0x0000 (0x0000 - 0x0000)
class ILeaningArrowsViewInterface final
{
public:
	void SetData(const ELeanState& leanState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaningArrowsViewInterface">();
	}
	static class ILeaningArrowsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILeaningArrowsViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ILeaningArrowsViewInterface) == 0x000001, "Wrong alignment on ILeaningArrowsViewInterface");
static_assert(sizeof(ILeaningArrowsViewInterface) == 0x000001, "Wrong size on ILeaningArrowsViewInterface");

// Class DBDUIViewInterfaces.LeaveMatchPopupViewData
// 0x0040 (0x0230 - 0x01F0)
class ULeaveMatchPopupViewData final : public UGenericPopupViewData
{
public:
	bool                                          isSurrenderMatch;                                  // 0x01F0(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F1[0x7];                                      // 0x01F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   keepMessage;                                       // 0x01F8(0x0018)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	class FText                                   loseMessage;                                       // 0x0210(0x0018)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaveMatchPopupViewData">();
	}
	static class ULeaveMatchPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaveMatchPopupViewData>();
	}
};
static_assert(alignof(ULeaveMatchPopupViewData) == 0x000010, "Wrong alignment on ULeaveMatchPopupViewData");
static_assert(sizeof(ULeaveMatchPopupViewData) == 0x000230, "Wrong size on ULeaveMatchPopupViewData");
static_assert(offsetof(ULeaveMatchPopupViewData, isSurrenderMatch) == 0x0001F0, "Member 'ULeaveMatchPopupViewData::isSurrenderMatch' has a wrong offset!");
static_assert(offsetof(ULeaveMatchPopupViewData, keepMessage) == 0x0001F8, "Member 'ULeaveMatchPopupViewData::keepMessage' has a wrong offset!");
static_assert(offsetof(ULeaveMatchPopupViewData, loseMessage) == 0x000210, "Member 'ULeaveMatchPopupViewData::loseMessage' has a wrong offset!");

// Class DBDUIViewInterfaces.LeaveMatchPopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class ILeaveMatchPopupViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaveMatchPopupViewInterface">();
	}
	static class ILeaveMatchPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILeaveMatchPopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ILeaveMatchPopupViewInterface) == 0x000001, "Wrong alignment on ILeaveMatchPopupViewInterface");
static_assert(sizeof(ILeaveMatchPopupViewInterface) == 0x000001, "Wrong size on ILeaveMatchPopupViewInterface");

// Class DBDUIViewInterfaces.LightSensitivityViewInterface
// 0x0000 (0x0000 - 0x0000)
class ILightSensitivityViewInterface final
{
public:
	void StartFadeOut();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightSensitivityViewInterface">();
	}
	static class ILightSensitivityViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILightSensitivityViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ILightSensitivityViewInterface) == 0x000001, "Wrong alignment on ILightSensitivityViewInterface");
static_assert(sizeof(ILightSensitivityViewInterface) == 0x000001, "Wrong size on ILightSensitivityViewInterface");

// Class DBDUIViewInterfaces.LoadingScreenViewInterface
// 0x0000 (0x0000 - 0x0000)
class ILoadingScreenViewInterface final
{
public:
	bool HasCustomWidgetForEvent(const class FName& eventID);
	void SetLoadingHint(const struct FLoadingHintViewData& loadingHintData);
	void SetLoadingScreenType(ELoadingScreenType loadingScreenType);
	void SetSpecialEventLoadingScreen(const class FName eventID);
	void Setup();
	void ShowLoadingBannerImage(const bool IsKiller);
	void UpdateProgress(float Progress);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadingScreenViewInterface">();
	}
	static class ILoadingScreenViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILoadingScreenViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ILoadingScreenViewInterface) == 0x000001, "Wrong alignment on ILoadingScreenViewInterface");
static_assert(sizeof(ILoadingScreenViewInterface) == 0x000001, "Wrong size on ILoadingScreenViewInterface");

// Class DBDUIViewInterfaces.LoadoutItemViewData
// 0x0240 (0x0270 - 0x0030)
class ULoadoutItemViewData final : public UObject
{
public:
	TSoftObjectPtr<class UTexture2D>              LoadoutIcon;                                       // 0x0030(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemId;                                            // 0x0068(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0078(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ParentDisplayName;                                 // 0x0090(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ParentTypeDisplayName;                             // 0x00A8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          IsParentAvailable;                                 // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Description;                                       // 0x00C8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EInventoryItemType                            ItemType;                                          // 0x00E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x00E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatusEffectType                             StatusEffectType;                                  // 0x00E2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E3[0x1];                                       // 0x00E3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Level;                                             // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   subtitle;                                          // 0x00E8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         StackCount;                                        // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsStackFull;                                       // 0x0104(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowStackCount;                                    // 0x0105(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemAvailability                             Availability;                                      // 0x0106(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEquipped;                                        // 0x0107(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTeachablePerk;                                   // 0x0108(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSlasherPerk;                                     // 0x0109(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRandomPerk;                                      // 0x010A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSlasher;                                         // 0x010B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLocked;                                          // 0x010C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UnlockableLevel;                                   // 0x0110(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEnabled;                                         // 0x0114(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_115[0x3];                                      // 0x0115(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   EventName;                                         // 0x0118(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	class FString                                 eventID;                                           // 0x0130(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPastEvent;                                       // 0x0140(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_141[0x7];                                      // 0x0141(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EventBannerLabel;                                  // 0x0148(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterClass;                                    // 0x0158(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSkillUnlockable;                                 // 0x0168(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLoadoutTooltipData                    TooltipData;                                       // 0x0170(0x00F8)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	EItemSourceTag                                ItemSourceTags;                                    // 0x0268(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_269[0x7];                                      // 0x0269(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutItemViewData">();
	}
	static class ULoadoutItemViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutItemViewData>();
	}
};
static_assert(alignof(ULoadoutItemViewData) == 0x000008, "Wrong alignment on ULoadoutItemViewData");
static_assert(sizeof(ULoadoutItemViewData) == 0x000270, "Wrong size on ULoadoutItemViewData");
static_assert(offsetof(ULoadoutItemViewData, LoadoutIcon) == 0x000030, "Member 'ULoadoutItemViewData::LoadoutIcon' has a wrong offset!");
static_assert(offsetof(ULoadoutItemViewData, ItemId) == 0x000068, "Member 'ULoadoutItemViewData::ItemId' has a wrong offset!");
static_assert(offsetof(ULoadoutItemViewData, DisplayName) == 0x000078, "Member 'ULoadoutItemViewData::DisplayName' has a wrong offset!");
static_assert(offsetof(ULoadoutItemViewData, ParentDisplayName) == 0x000090, "Member 'ULoadoutItemViewData::ParentDisplayName' has a wrong offset!");
static_assert(offsetof(ULoadoutItemViewData, ParentTypeDisplayName) == 0x0000A8, "Member 'ULoadoutItemViewData::ParentTypeDisplayName' has a wrong offset!");
static_assert(offsetof(ULoadoutItemViewData, IsParentAvailable) == 0x0000C0, "Member 'ULoadoutItemViewData::IsParentAvailable' has a wrong offset!");
static_assert(offsetof(ULoadoutItemViewData, Description) == 0x0000C8, "Member 'ULoadoutItemViewData::Description' has a wrong offset!");
static_assert(offsetof(ULoadoutItemViewData, ItemType) == 0x0000E0, "Member 'ULoadoutItemViewData::ItemType' has a wrong offset!");
static_assert(offsetof(ULoadoutItemViewData, Rarity) == 0x0000E1, "Member 'ULoadoutItemViewData::Rarity' has a wrong offset!");
static_assert(offsetof(ULoadoutItemViewData, StatusEffectType) == 0x0000E2, "Member 'ULoadoutItemViewData::StatusEffectType' has a wrong offset!");
static_assert(offsetof(ULoadoutItemViewData, Level) == 0x0000E4, "Member 'ULoadoutItemViewData::Level' has a wrong offset!");
static_assert(offsetof(ULoadoutItemViewData, subtitle) == 0x0000E8, "Member 'ULoadoutItemViewData::subtitle' has a wrong offset!");
static_assert(offsetof(ULoadoutItemViewData, StackCount) == 0x000100, "Member 'ULoadoutItemViewData::StackCount' has a wrong offset!");
static_assert(offsetof(ULoadoutItemViewData, IsStackFull) == 0x000104, "Member 'ULoadoutItemViewData::IsStackFull' has a wrong offset!");
static_assert(offsetof(ULoadoutItemViewData, ShowStackCount) == 0x000105, "Member 'ULoadoutItemViewData::ShowStackCount' has a wrong offset!");
static_assert(offsetof(ULoadoutItemViewData, Availability) == 0x000106, "Member 'ULoadoutItemViewData::Availability' has a wrong offset!");
static_assert(offsetof(ULoadoutItemViewData, IsEquipped) == 0x000107, "Member 'ULoadoutItemViewData::IsEquipped' has a wrong offset!");
static_assert(offsetof(ULoadoutItemViewData, IsTeachablePerk) == 0x000108, "Member 'ULoadoutItemViewData::IsTeachablePerk' has a wrong offset!");
static_assert(offsetof(ULoadoutItemViewData, IsSlasherPerk) == 0x000109, "Member 'ULoadoutItemViewData::IsSlasherPerk' has a wrong offset!");
static_assert(offsetof(ULoadoutItemViewData, IsRandomPerk) == 0x00010A, "Member 'ULoadoutItemViewData::IsRandomPerk' has a wrong offset!");
static_assert(offsetof(ULoadoutItemViewData, IsSlasher) == 0x00010B, "Member 'ULoadoutItemViewData::IsSlasher' has a wrong offset!");
static_assert(offsetof(ULoadoutItemViewData, IsLocked) == 0x00010C, "Member 'ULoadoutItemViewData::IsLocked' has a wrong offset!");
static_assert(offsetof(ULoadoutItemViewData, UnlockableLevel) == 0x000110, "Member 'ULoadoutItemViewData::UnlockableLevel' has a wrong offset!");
static_assert(offsetof(ULoadoutItemViewData, IsEnabled) == 0x000114, "Member 'ULoadoutItemViewData::IsEnabled' has a wrong offset!");
static_assert(offsetof(ULoadoutItemViewData, EventName) == 0x000118, "Member 'ULoadoutItemViewData::EventName' has a wrong offset!");
static_assert(offsetof(ULoadoutItemViewData, eventID) == 0x000130, "Member 'ULoadoutItemViewData::eventID' has a wrong offset!");
static_assert(offsetof(ULoadoutItemViewData, IsPastEvent) == 0x000140, "Member 'ULoadoutItemViewData::IsPastEvent' has a wrong offset!");
static_assert(offsetof(ULoadoutItemViewData, EventBannerLabel) == 0x000148, "Member 'ULoadoutItemViewData::EventBannerLabel' has a wrong offset!");
static_assert(offsetof(ULoadoutItemViewData, CharacterClass) == 0x000158, "Member 'ULoadoutItemViewData::CharacterClass' has a wrong offset!");
static_assert(offsetof(ULoadoutItemViewData, IsSkillUnlockable) == 0x000168, "Member 'ULoadoutItemViewData::IsSkillUnlockable' has a wrong offset!");
static_assert(offsetof(ULoadoutItemViewData, TooltipData) == 0x000170, "Member 'ULoadoutItemViewData::TooltipData' has a wrong offset!");
static_assert(offsetof(ULoadoutItemViewData, ItemSourceTags) == 0x000268, "Member 'ULoadoutItemViewData::ItemSourceTags' has a wrong offset!");

// Class DBDUIViewInterfaces.LoadoutViewInterface
// 0x0000 (0x0000 - 0x0000)
class ILoadoutViewInterface final
{
public:
	void SetIsBeginnerModeActive(const bool isBeginnerModeActive);
	void SetLayout(const int32 loadoutLayoutMask, const EPlayerRole PlayerRole);
	void SetLoadoutEnabled(const bool IsEnabled);
	void SetLoadoutSlotData(const TArray<class ULoadoutItemViewData*>& slotData);
	void SetSelectedSlot(const ELoadoutSlot slotSelected);

	TScriptInterface<class ISearchBarViewInterface> GetSearchBarViewInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutViewInterface">();
	}
	static class ILoadoutViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILoadoutViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ILoadoutViewInterface) == 0x000001, "Wrong alignment on ILoadoutViewInterface");
static_assert(sizeof(ILoadoutViewInterface) == 0x000001, "Wrong size on ILoadoutViewInterface");

// Class DBDUIViewInterfaces.LobbyCharactersViewInterface
// 0x0000 (0x0000 - 0x0000)
class ILobbyCharactersViewInterface final
{
public:
	TScriptInterface<class IStoreCharactersBioViewInterface> GetStoreCharactersBioInterface() const;
	TScriptInterface<class IStoreCharactersCustomizationsViewInterface> GetStoreCharactersCustomizationsInterface() const;
	TScriptInterface<class IStoreCharactersSelectionViewInterface> GetStoreCharactersSelectionInterface() const;
	TScriptInterface<class IWardrobeActionButtonsViewInterface> GetWardrobeActionButtonsInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyCharactersViewInterface">();
	}
	static class ILobbyCharactersViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILobbyCharactersViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ILobbyCharactersViewInterface) == 0x000001, "Wrong alignment on ILobbyCharactersViewInterface");
static_assert(sizeof(ILobbyCharactersViewInterface) == 0x000001, "Wrong size on ILobbyCharactersViewInterface");

// Class DBDUIViewInterfaces.LobbyLoadoutViewInterface
// 0x0000 (0x0000 - 0x0000)
class ILobbyLoadoutViewInterface final
{
public:
	void UpdatePresetData(const TArray<int32>& presetData, const int32 selectedPreset);

	TScriptInterface<class ILoadoutViewInterface> GetLoadoutViewInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyLoadoutViewInterface">();
	}
	static class ILobbyLoadoutViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILobbyLoadoutViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ILobbyLoadoutViewInterface) == 0x000001, "Wrong alignment on ILobbyLoadoutViewInterface");
static_assert(sizeof(ILobbyLoadoutViewInterface) == 0x000001, "Wrong size on ILobbyLoadoutViewInterface");

// Class DBDUIViewInterfaces.LobbyPerkPreviewerViewInterface
// 0x0000 (0x0000 - 0x0000)
class ILobbyPerkPreviewerViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyPerkPreviewerViewInterface">();
	}
	static class ILobbyPerkPreviewerViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILobbyPerkPreviewerViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ILobbyPerkPreviewerViewInterface) == 0x000001, "Wrong alignment on ILobbyPerkPreviewerViewInterface");
static_assert(sizeof(ILobbyPerkPreviewerViewInterface) == 0x000001, "Wrong size on ILobbyPerkPreviewerViewInterface");

// Class DBDUIViewInterfaces.LobbyPlayerListViewInterface
// 0x0000 (0x0000 - 0x0000)
class ILobbyPlayerListViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyPlayerListViewInterface">();
	}
	static class ILobbyPlayerListViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILobbyPlayerListViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ILobbyPlayerListViewInterface) == 0x000001, "Wrong alignment on ILobbyPlayerListViewInterface");
static_assert(sizeof(ILobbyPlayerListViewInterface) == 0x000001, "Wrong size on ILobbyPlayerListViewInterface");

// Class DBDUIViewInterfaces.LobbySidePanelInterface
// 0x0000 (0x0000 - 0x0000)
class ILobbySidePanelInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbySidePanelInterface">();
	}
	static class ILobbySidePanelInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILobbySidePanelInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ILobbySidePanelInterface) == 0x000001, "Wrong alignment on ILobbySidePanelInterface");
static_assert(sizeof(ILobbySidePanelInterface) == 0x000001, "Wrong size on ILobbySidePanelInterface");

// Class DBDUIViewInterfaces.LobbyTitleViewInterface
// 0x0000 (0x0000 - 0x0000)
class ILobbyTitleViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyTitleViewInterface">();
	}
	static class ILobbyTitleViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILobbyTitleViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ILobbyTitleViewInterface) == 0x000001, "Wrong alignment on ILobbyTitleViewInterface");
static_assert(sizeof(ILobbyTitleViewInterface) == 0x000001, "Wrong size on ILobbyTitleViewInterface");

// Class DBDUIViewInterfaces.LobbyViewInterface
// 0x0000 (0x0000 - 0x0000)
class ILobbyViewInterface final
{
public:
	void OnLobbySubPageChanged();
	void PlayLevelUpAnimation(const bool isPrestigeUp);
	void SetBloodPointBulkSpendingButtonEnabled(const bool IsEnabled);
	void SetBloodPointBulkSpendingButtonVisibility(const bool IsVisible);
	void SetButtonBetaFeatureVisibility(bool IsVisible);
	void SetLobbyTitle(const bool IsVisible, const struct FLobbyTitleViewData& LobbyTitleViewData);
	void SetLobbyTitleFadeOutAnimation();
	void UpdateArchivesButtonState(const struct FMainMenuButtonData& buttonData, bool isCustomGame);
	void UpdateBackButtonState(const bool IsEnabled, const class FText& label);

	TScriptInterface<class IChatViewInterface> GetChatInterface() const;
	TScriptInterface<class IDisplayStandViewInterface> GetDisplayStandInterface() const;
	TScriptInterface<class ILobbyCharactersViewInterface> GetLobbyCharactersInterface() const;
	TScriptInterface<class ILobbyLoadoutViewInterface> GetLobbyLoadoutInterface() const;
	TScriptInterface<class ILobbySidePanelInterface> GetLobbySidePanelInterface() const;
	TScriptInterface<class ILobbyPerkPreviewerViewInterface> GetPerkPreviewerInterface() const;
	TScriptInterface<class ILobbyPlayerListViewInterface> GetPlayerListInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyViewInterface">();
	}
	static class ILobbyViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILobbyViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ILobbyViewInterface) == 0x000001, "Wrong alignment on ILobbyViewInterface");
static_assert(sizeof(ILobbyViewInterface) == 0x000001, "Wrong size on ILobbyViewInterface");

// Class DBDUIViewInterfaces.LockedFeatureElementViewInterface
// 0x0000 (0x0000 - 0x0000)
class ILockedFeatureElementViewInterface final
{
public:
	bool IsLockedFeature() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LockedFeatureElementViewInterface">();
	}
	static class ILockedFeatureElementViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILockedFeatureElementViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ILockedFeatureElementViewInterface) == 0x000001, "Wrong alignment on ILockedFeatureElementViewInterface");
static_assert(sizeof(ILockedFeatureElementViewInterface) == 0x000001, "Wrong size on ILockedFeatureElementViewInterface");

// Class DBDUIViewInterfaces.MainMenuButtonsEventDataAsset
// 0x00B8 (0x00F0 - 0x0038)
class UMainMenuButtonsEventDataAsset final : public UDataAsset
{
public:
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0038(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   EventDecorationWidget;                             // 0x0070(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   HighlightWidget;                                   // 0x00A8(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           EventButtonsTintColor;                             // 0x00E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainMenuButtonsEventDataAsset">();
	}
	static class UMainMenuButtonsEventDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainMenuButtonsEventDataAsset>();
	}
};
static_assert(alignof(UMainMenuButtonsEventDataAsset) == 0x000008, "Wrong alignment on UMainMenuButtonsEventDataAsset");
static_assert(sizeof(UMainMenuButtonsEventDataAsset) == 0x0000F0, "Wrong size on UMainMenuButtonsEventDataAsset");
static_assert(offsetof(UMainMenuButtonsEventDataAsset, Icon) == 0x000038, "Member 'UMainMenuButtonsEventDataAsset::Icon' has a wrong offset!");
static_assert(offsetof(UMainMenuButtonsEventDataAsset, EventDecorationWidget) == 0x000070, "Member 'UMainMenuButtonsEventDataAsset::EventDecorationWidget' has a wrong offset!");
static_assert(offsetof(UMainMenuButtonsEventDataAsset, HighlightWidget) == 0x0000A8, "Member 'UMainMenuButtonsEventDataAsset::HighlightWidget' has a wrong offset!");
static_assert(offsetof(UMainMenuButtonsEventDataAsset, EventButtonsTintColor) == 0x0000E0, "Member 'UMainMenuButtonsEventDataAsset::EventButtonsTintColor' has a wrong offset!");

// Class DBDUIViewInterfaces.MainMenuButtonViewInterface
// 0x0000 (0x0000 - 0x0000)
class IMainMenuButtonViewInterface final
{
public:
	void SetHighlightVisibility(const bool IsVisible);
	void SetMainMenuButtonIndex(int32 ButtonIndex);
	void SetMainMenuButtonType(EMainMenuButtonType mainMenuButtonType);
	void SetNotificationVisibility(bool IsVisible);

	int32 GetMainMenuButtonIndex() const;
	EMainMenuButtonType GetMainMenuButtonType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainMenuButtonViewInterface">();
	}
	static class IMainMenuButtonViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMainMenuButtonViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IMainMenuButtonViewInterface) == 0x000001, "Wrong alignment on IMainMenuButtonViewInterface");
static_assert(sizeof(IMainMenuButtonViewInterface) == 0x000001, "Wrong size on IMainMenuButtonViewInterface");

// Class DBDUIViewInterfaces.MainMenuViewInterface
// 0x0000 (0x0000 - 0x0000)
class IMainMenuViewInterface final
{
public:
	void AddButtonTimerFlag(EMainMenuButtonType ButtonType, const struct FTimerFlagViewData& TimerFlagViewData, int32 ButtonIndex);
	void ClearButtonTimerFlags(EMainMenuButtonType ButtonType, int32 ButtonIndex);
	void DisplayMainMenu(const bool isDisplayed);
	void ResetAllButtons();
	void ResetButton(EMainMenuButtonType ButtonType, int32 ButtonIndex);
	void SetButtonBetaFeatureVisibility(EMainMenuButtonType ButtonType, bool IsVisible, int32 ButtonIndex);
	void SetButtonDecoration(EMainMenuButtonType ButtonType, const class FString& decorationId, int32 ButtonIndex);
	void SetButtonDecorationVisible(EMainMenuButtonType ButtonType, bool IsVisible, int32 ButtonIndex);
	void SetButtonDisableState(const EMainMenuButtonType ButtonType, EButtonDisableState buttonDisableState, int32 ButtonIndex, const class FText& disabledButtonTooltipViewData);
	void SetButtonEnabled(const EMainMenuButtonType ButtonType, bool IsEnabled, int32 ButtonIndex);
	void SetButtonHighlightVisibility(EMainMenuButtonType ButtonType, bool IsVisible, int32 ButtonIndex);
	void SetButtonIcon(EMainMenuButtonType ButtonType, const class FString& iconId, int32 ButtonIndex);
	void SetButtonNotificationVisibility(EMainMenuButtonType ButtonType, bool IsVisible, int32 ButtonIndex);
	void SetButtonVisibility(EMainMenuButtonType ButtonType, bool IsVisible);
	void SetChallengesButtonVisibility(const bool IsVisible);
	void SetChangeAccountInputSwitcherPlayerNickname(const class FString& playerNickname);
	void SetChangeAccountInputSwitcherVisible(bool Visible);
	void SetLabelButton(EMainMenuButtonType ButtonType, const class FText& label, int32 ButtonIndex);
	void SetLTEButtons(const TArray<class FName>& eventNames, const TArray<EGameType>& eventGameTypes);
	void SetMatchmakingIncentive(const class FName& GameMode, int32 survivorIncentive, int32 killerIncentive);
	void SetStoreButtonFlags(bool hasNewItem, const struct FTimerFlagViewData& remainingLimitedItemTimeData, const struct FTimerFlagViewData& remainingSaleTimeData);
	void SetSubtitle(EMainMenuButtonType ButtonType, const class FText& subtitle, int32 ButtonIndex);
	void SetSubtitleTimerIconVisible(EMainMenuButtonType ButtonType, bool IsVisible, int32 ButtonIndex);
	void SetSubtitleVisible(EMainMenuButtonType ButtonType, bool IsVisible, int32 ButtonIndex);
	void SetUiTakeoverActive(const bool IsActive);

	void SetExitButtonEnabled(bool IsEnabled) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainMenuViewInterface">();
	}
	static class IMainMenuViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMainMenuViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IMainMenuViewInterface) == 0x000001, "Wrong alignment on IMainMenuViewInterface");
static_assert(sizeof(IMainMenuViewInterface) == 0x000001, "Wrong size on IMainMenuViewInterface");

// Class DBDUIViewInterfaces.MarketingInvitationPopupViewData
// 0x00D0 (0x02C0 - 0x01F0)
class UMarketingInvitationPopupViewData final : public UGenericPopupViewData
{
public:
	bool                                          ShouldShowRewards;                                 // 0x01F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldShowOptOutToggle;                            // 0x01F1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InitialOptOutToggleValue;                          // 0x01F2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F3[0x5];                                      // 0x01F3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              KeyArtImage;                                       // 0x01F8(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              QrCodeImage;                                       // 0x0230(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   InstructionText;                                   // 0x0268(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	class FText                                   RewardTitleText;                                   // 0x0280(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FCurrencyProgressionRewardViewData> Rewards;                                       // 0x0298(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                VideosUri;                                         // 0x02A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarketingInvitationPopupViewData">();
	}
	static class UMarketingInvitationPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarketingInvitationPopupViewData>();
	}
};
static_assert(alignof(UMarketingInvitationPopupViewData) == 0x000010, "Wrong alignment on UMarketingInvitationPopupViewData");
static_assert(sizeof(UMarketingInvitationPopupViewData) == 0x0002C0, "Wrong size on UMarketingInvitationPopupViewData");
static_assert(offsetof(UMarketingInvitationPopupViewData, ShouldShowRewards) == 0x0001F0, "Member 'UMarketingInvitationPopupViewData::ShouldShowRewards' has a wrong offset!");
static_assert(offsetof(UMarketingInvitationPopupViewData, ShouldShowOptOutToggle) == 0x0001F1, "Member 'UMarketingInvitationPopupViewData::ShouldShowOptOutToggle' has a wrong offset!");
static_assert(offsetof(UMarketingInvitationPopupViewData, InitialOptOutToggleValue) == 0x0001F2, "Member 'UMarketingInvitationPopupViewData::InitialOptOutToggleValue' has a wrong offset!");
static_assert(offsetof(UMarketingInvitationPopupViewData, KeyArtImage) == 0x0001F8, "Member 'UMarketingInvitationPopupViewData::KeyArtImage' has a wrong offset!");
static_assert(offsetof(UMarketingInvitationPopupViewData, QrCodeImage) == 0x000230, "Member 'UMarketingInvitationPopupViewData::QrCodeImage' has a wrong offset!");
static_assert(offsetof(UMarketingInvitationPopupViewData, InstructionText) == 0x000268, "Member 'UMarketingInvitationPopupViewData::InstructionText' has a wrong offset!");
static_assert(offsetof(UMarketingInvitationPopupViewData, RewardTitleText) == 0x000280, "Member 'UMarketingInvitationPopupViewData::RewardTitleText' has a wrong offset!");
static_assert(offsetof(UMarketingInvitationPopupViewData, Rewards) == 0x000298, "Member 'UMarketingInvitationPopupViewData::Rewards' has a wrong offset!");
static_assert(offsetof(UMarketingInvitationPopupViewData, VideosUri) == 0x0002A8, "Member 'UMarketingInvitationPopupViewData::VideosUri' has a wrong offset!");

// Class DBDUIViewInterfaces.MarketingInvitationPopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class IMarketingInvitationPopupViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarketingInvitationPopupViewInterface">();
	}
	static class IMarketingInvitationPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMarketingInvitationPopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IMarketingInvitationPopupViewInterface) == 0x000001, "Wrong alignment on IMarketingInvitationPopupViewInterface");
static_assert(sizeof(IMarketingInvitationPopupViewInterface) == 0x000001, "Wrong size on IMarketingInvitationPopupViewInterface");

// Class DBDUIViewInterfaces.MatchmakingViewInterface
// 0x0000 (0x0000 - 0x0000)
class IMatchmakingViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchmakingViewInterface">();
	}
	static class IMatchmakingViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMatchmakingViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IMatchmakingViewInterface) == 0x000001, "Wrong alignment on IMatchmakingViewInterface");
static_assert(sizeof(IMatchmakingViewInterface) == 0x000001, "Wrong size on IMatchmakingViewInterface");

// Class DBDUIViewInterfaces.MatchResultViewInterface
// 0x0000 (0x0000 - 0x0000)
class IMatchResultViewInterface final
{
public:
	void PlayAnimationSequence();
	void SetMatchResultVisibility(ESlateVisibility Visibility);
	void UpdateWidget(const struct FMatchResultViewData& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchResultViewInterface">();
	}
	static class IMatchResultViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMatchResultViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IMatchResultViewInterface) == 0x000001, "Wrong alignment on IMatchResultViewInterface");
static_assert(sizeof(IMatchResultViewInterface) == 0x000001, "Wrong size on IMatchResultViewInterface");

// Class DBDUIViewInterfaces.MenuLoadoutPartViewData
// 0x0178 (0x01A8 - 0x0030)
class UMenuLoadoutPartViewData : public UObject
{
public:
	class FName                                   ItemId;                                            // 0x0030(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              iconTexture;                                       // 0x0040(0x0038)(Edit, BlueprintVisible, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StackCount;                                        // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowStackCount;                                    // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ParentDisplayName;                                 // 0x0088(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          IsParentAvailable;                                 // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLocked;                                          // 0x00A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2[0x2];                                       // 0x00A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UnlockableLevel;                                   // 0x00A4(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemAvailability                             Availability;                                      // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEquipped;                                        // 0x00A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEnabled;                                         // 0x00AA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemSourceTag                                ItemSourceTags;                                    // 0x00AB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLoadoutTooltipData                    TooltipData;                                       // 0x00B0(0x00F8)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuLoadoutPartViewData">();
	}
	static class UMenuLoadoutPartViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuLoadoutPartViewData>();
	}
};
static_assert(alignof(UMenuLoadoutPartViewData) == 0x000008, "Wrong alignment on UMenuLoadoutPartViewData");
static_assert(sizeof(UMenuLoadoutPartViewData) == 0x0001A8, "Wrong size on UMenuLoadoutPartViewData");
static_assert(offsetof(UMenuLoadoutPartViewData, ItemId) == 0x000030, "Member 'UMenuLoadoutPartViewData::ItemId' has a wrong offset!");
static_assert(offsetof(UMenuLoadoutPartViewData, iconTexture) == 0x000040, "Member 'UMenuLoadoutPartViewData::iconTexture' has a wrong offset!");
static_assert(offsetof(UMenuLoadoutPartViewData, Rarity) == 0x000078, "Member 'UMenuLoadoutPartViewData::Rarity' has a wrong offset!");
static_assert(offsetof(UMenuLoadoutPartViewData, StackCount) == 0x00007C, "Member 'UMenuLoadoutPartViewData::StackCount' has a wrong offset!");
static_assert(offsetof(UMenuLoadoutPartViewData, ShowStackCount) == 0x000080, "Member 'UMenuLoadoutPartViewData::ShowStackCount' has a wrong offset!");
static_assert(offsetof(UMenuLoadoutPartViewData, ParentDisplayName) == 0x000088, "Member 'UMenuLoadoutPartViewData::ParentDisplayName' has a wrong offset!");
static_assert(offsetof(UMenuLoadoutPartViewData, IsParentAvailable) == 0x0000A0, "Member 'UMenuLoadoutPartViewData::IsParentAvailable' has a wrong offset!");
static_assert(offsetof(UMenuLoadoutPartViewData, IsLocked) == 0x0000A1, "Member 'UMenuLoadoutPartViewData::IsLocked' has a wrong offset!");
static_assert(offsetof(UMenuLoadoutPartViewData, UnlockableLevel) == 0x0000A4, "Member 'UMenuLoadoutPartViewData::UnlockableLevel' has a wrong offset!");
static_assert(offsetof(UMenuLoadoutPartViewData, Availability) == 0x0000A8, "Member 'UMenuLoadoutPartViewData::Availability' has a wrong offset!");
static_assert(offsetof(UMenuLoadoutPartViewData, IsEquipped) == 0x0000A9, "Member 'UMenuLoadoutPartViewData::IsEquipped' has a wrong offset!");
static_assert(offsetof(UMenuLoadoutPartViewData, IsEnabled) == 0x0000AA, "Member 'UMenuLoadoutPartViewData::IsEnabled' has a wrong offset!");
static_assert(offsetof(UMenuLoadoutPartViewData, ItemSourceTags) == 0x0000AB, "Member 'UMenuLoadoutPartViewData::ItemSourceTags' has a wrong offset!");
static_assert(offsetof(UMenuLoadoutPartViewData, TooltipData) == 0x0000B0, "Member 'UMenuLoadoutPartViewData::TooltipData' has a wrong offset!");

// Class DBDUIViewInterfaces.MenuAddonViewData
// 0x0000 (0x01A8 - 0x01A8)
class UMenuAddonViewData final : public UMenuLoadoutPartViewData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuAddonViewData">();
	}
	static class UMenuAddonViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuAddonViewData>();
	}
};
static_assert(alignof(UMenuAddonViewData) == 0x000008, "Wrong alignment on UMenuAddonViewData");
static_assert(sizeof(UMenuAddonViewData) == 0x0001A8, "Wrong size on UMenuAddonViewData");

// Class DBDUIViewInterfaces.MenuClassViewData
// 0x0008 (0x01B0 - 0x01A8)
class UMenuClassViewData final : public UMenuLoadoutPartViewData
{
public:
	bool                                          IsMaxPlayerUsingClassReached;                      // 0x01A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A9[0x7];                                      // 0x01A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuClassViewData">();
	}
	static class UMenuClassViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuClassViewData>();
	}
};
static_assert(alignof(UMenuClassViewData) == 0x000008, "Wrong alignment on UMenuClassViewData");
static_assert(sizeof(UMenuClassViewData) == 0x0001B0, "Wrong size on UMenuClassViewData");
static_assert(offsetof(UMenuClassViewData, IsMaxPlayerUsingClassReached) == 0x0001A8, "Member 'UMenuClassViewData::IsMaxPlayerUsingClassReached' has a wrong offset!");

// Class DBDUIViewInterfaces.MenuItemViewData
// 0x0000 (0x01A8 - 0x01A8)
class UMenuItemViewData final : public UMenuLoadoutPartViewData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuItemViewData">();
	}
	static class UMenuItemViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuItemViewData>();
	}
};
static_assert(alignof(UMenuItemViewData) == 0x000008, "Wrong alignment on UMenuItemViewData");
static_assert(sizeof(UMenuItemViewData) == 0x0001A8, "Wrong size on UMenuItemViewData");

// Class DBDUIViewInterfaces.MenuOfferingViewData
// 0x0000 (0x01A8 - 0x01A8)
class UMenuOfferingViewData final : public UMenuLoadoutPartViewData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuOfferingViewData">();
	}
	static class UMenuOfferingViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuOfferingViewData>();
	}
};
static_assert(alignof(UMenuOfferingViewData) == 0x000008, "Wrong alignment on UMenuOfferingViewData");
static_assert(sizeof(UMenuOfferingViewData) == 0x0001A8, "Wrong size on UMenuOfferingViewData");

// Class DBDUIViewInterfaces.MenuPerkViewData
// 0x0068 (0x0210 - 0x01A8)
class UMenuPerkViewData final : public UMenuLoadoutPartViewData
{
public:
	int32                                         Level;                                             // 0x01A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AC[0x4];                                      // 0x01AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x01B0(0x0018)(Edit, BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x01C8(0x0018)(Edit, BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	class FText                                   EventName;                                         // 0x01E0(0x0018)(Edit, BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	class FString                                 eventID;                                           // 0x01F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRandomPerk;                                      // 0x0208(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_209[0x7];                                      // 0x0209(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuPerkViewData">();
	}
	static class UMenuPerkViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuPerkViewData>();
	}
};
static_assert(alignof(UMenuPerkViewData) == 0x000008, "Wrong alignment on UMenuPerkViewData");
static_assert(sizeof(UMenuPerkViewData) == 0x000210, "Wrong size on UMenuPerkViewData");
static_assert(offsetof(UMenuPerkViewData, Level) == 0x0001A8, "Member 'UMenuPerkViewData::Level' has a wrong offset!");
static_assert(offsetof(UMenuPerkViewData, DisplayName) == 0x0001B0, "Member 'UMenuPerkViewData::DisplayName' has a wrong offset!");
static_assert(offsetof(UMenuPerkViewData, Description) == 0x0001C8, "Member 'UMenuPerkViewData::Description' has a wrong offset!");
static_assert(offsetof(UMenuPerkViewData, EventName) == 0x0001E0, "Member 'UMenuPerkViewData::EventName' has a wrong offset!");
static_assert(offsetof(UMenuPerkViewData, eventID) == 0x0001F8, "Member 'UMenuPerkViewData::eventID' has a wrong offset!");
static_assert(offsetof(UMenuPerkViewData, IsRandomPerk) == 0x000208, "Member 'UMenuPerkViewData::IsRandomPerk' has a wrong offset!");

// Class DBDUIViewInterfaces.MenuPowerViewData
// 0x0050 (0x01F8 - 0x01A8)
class UMenuPowerViewData final : public UMenuLoadoutPartViewData
{
public:
	class FText                                   DisplayName;                                       // 0x01A8(0x0018)(Edit, BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x01C0(0x0018)(Edit, BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	class FText                                   EventName;                                         // 0x01D8(0x0018)(Edit, BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	EInventoryItemType                            ItemType;                                          // 0x01F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F1[0x7];                                      // 0x01F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuPowerViewData">();
	}
	static class UMenuPowerViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuPowerViewData>();
	}
};
static_assert(alignof(UMenuPowerViewData) == 0x000008, "Wrong alignment on UMenuPowerViewData");
static_assert(sizeof(UMenuPowerViewData) == 0x0001F8, "Wrong size on UMenuPowerViewData");
static_assert(offsetof(UMenuPowerViewData, DisplayName) == 0x0001A8, "Member 'UMenuPowerViewData::DisplayName' has a wrong offset!");
static_assert(offsetof(UMenuPowerViewData, Description) == 0x0001C0, "Member 'UMenuPowerViewData::Description' has a wrong offset!");
static_assert(offsetof(UMenuPowerViewData, EventName) == 0x0001D8, "Member 'UMenuPowerViewData::EventName' has a wrong offset!");
static_assert(offsetof(UMenuPowerViewData, ItemType) == 0x0001F0, "Member 'UMenuPowerViewData::ItemType' has a wrong offset!");

// Class DBDUIViewInterfaces.MenuSkillViewData
// 0x0008 (0x01B0 - 0x01A8)
class UMenuSkillViewData final : public UMenuLoadoutPartViewData
{
public:
	bool                                          IsSkillUnlockable;                                 // 0x01A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A9[0x7];                                      // 0x01A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuSkillViewData">();
	}
	static class UMenuSkillViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuSkillViewData>();
	}
};
static_assert(alignof(UMenuSkillViewData) == 0x000008, "Wrong alignment on UMenuSkillViewData");
static_assert(sizeof(UMenuSkillViewData) == 0x0001B0, "Wrong size on UMenuSkillViewData");
static_assert(offsetof(UMenuSkillViewData, IsSkillUnlockable) == 0x0001A8, "Member 'UMenuSkillViewData::IsSkillUnlockable' has a wrong offset!");

// Class DBDUIViewInterfaces.MultipleDisableStateButtonViewInterface
// 0x0000 (0x0000 - 0x0000)
class IMultipleDisableStateButtonViewInterface final
{
public:
	void SetButtonDisableState(const EButtonDisableState& buttonDisableState, const class FText& disabledButtonTooltipText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MultipleDisableStateButtonViewInterface">();
	}
	static class IMultipleDisableStateButtonViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMultipleDisableStateButtonViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IMultipleDisableStateButtonViewInterface) == 0x000001, "Wrong alignment on IMultipleDisableStateButtonViewInterface");
static_assert(sizeof(IMultipleDisableStateButtonViewInterface) == 0x000001, "Wrong size on IMultipleDisableStateButtonViewInterface");

// Class DBDUIViewInterfaces.NewRiftPopupViewData
// 0x0000 (0x01F0 - 0x01F0)
class UNewRiftPopupViewData final : public UGenericPopupViewData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NewRiftPopupViewData">();
	}
	static class UNewRiftPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNewRiftPopupViewData>();
	}
};
static_assert(alignof(UNewRiftPopupViewData) == 0x000010, "Wrong alignment on UNewRiftPopupViewData");
static_assert(sizeof(UNewRiftPopupViewData) == 0x0001F0, "Wrong size on UNewRiftPopupViewData");

// Class DBDUIViewInterfaces.NewRiftPopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class INewRiftPopupViewInterface final
{
public:
	void SetRemainingTime(const class FString& RemainingTime);
	void SetRiftButtonEnabled(const bool IsEnabled);
	void SetRiftTimerEnabled(const bool IsEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NewRiftPopupViewInterface">();
	}
	static class INewRiftPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<INewRiftPopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(INewRiftPopupViewInterface) == 0x000001, "Wrong alignment on INewRiftPopupViewInterface");
static_assert(sizeof(INewRiftPopupViewInterface) == 0x000001, "Wrong size on INewRiftPopupViewInterface");

// Class DBDUIViewInterfaces.NewsViewInterface
// 0x0000 (0x0000 - 0x0000)
class INewsViewInterface final
{
public:
	void SetLoading();
	void SetSelectedNewsArticle(const class UInboxItemViewData* ViewData);
	void SetTabsData(const TArray<struct FTabWidgetData>& tabsData, const int32 selectedTab);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NewsViewInterface">();
	}
	static class INewsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<INewsViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(INewsViewInterface) == 0x000001, "Wrong alignment on INewsViewInterface");
static_assert(sizeof(INewsViewInterface) == 0x000001, "Wrong size on INewsViewInterface");

// Class DBDUIViewInterfaces.OfferingInteractionViewInterface
// 0x0000 (0x0000 - 0x0000)
class IOfferingInteractionViewInterface final
{
public:
	void ClearData();
	void SetData(const struct FOfferingViewData& OfferingData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OfferingInteractionViewInterface">();
	}
	static class IOfferingInteractionViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOfferingInteractionViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOfferingInteractionViewInterface) == 0x000001, "Wrong alignment on IOfferingInteractionViewInterface");
static_assert(sizeof(IOfferingInteractionViewInterface) == 0x000001, "Wrong size on IOfferingInteractionViewInterface");

// Class DBDUIViewInterfaces.OfferingViewInterface
// 0x0000 (0x0000 - 0x0000)
class IOfferingViewInterface final
{
public:
	void ClearData();
	void SetData(const struct FOfferingViewData& OfferingViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OfferingViewInterface">();
	}
	static class IOfferingViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOfferingViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOfferingViewInterface) == 0x000001, "Wrong alignment on IOfferingViewInterface");
static_assert(sizeof(IOfferingViewInterface) == 0x000001, "Wrong size on IOfferingViewInterface");

// Class DBDUIViewInterfaces.OnboardingMenuViewInterface
// 0x0000 (0x0000 - 0x0000)
class IOnboardingMenuViewInterface final
{
public:
	void SetBackButtonVisible(bool Visible);
	void SetChangeAccountInputSwitcherPlayerNickname(const class FString& playerNickname);
	void SetChangeAccountInputSwitcherVisible(bool Visible);
	void SetFirstTimeUserExperience(bool ftue);
	void SetOnboardingMenuState(EOnboardingMenuState menuState);
	void SetQuitGameButtonVisible(bool Visible);
	void SetUIEnabled(bool Enabled);

	TScriptInterface<class IGameManualViewInterface> GetGameManualInterface() const;
	TScriptInterface<class IOnboardingTutorialViewInterface> GetOnboardingTutorialInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnboardingMenuViewInterface">();
	}
	static class IOnboardingMenuViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOnboardingMenuViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOnboardingMenuViewInterface) == 0x000001, "Wrong alignment on IOnboardingMenuViewInterface");
static_assert(sizeof(IOnboardingMenuViewInterface) == 0x000001, "Wrong size on IOnboardingMenuViewInterface");

// Class DBDUIViewInterfaces.OnboardingTutorialViewInterface
// 0x0000 (0x0000 - 0x0000)
class IOnboardingTutorialViewInterface final
{
public:
	void SetCanShowGoToMainMenuTutorialButton(bool canShowGoToMainMenuTutorialButton);
	void SetIsKillSwitch(bool isKillSwitch);
	void SetProgress(const TArray<struct FOnboardingStepViewData>& Progress);
	void SetTutorialProgressionFeedbacks(const class FString& completedStepId, const bool isOnboardingEnabled);
	void SetUIEnabled(bool Enabled);
	void StopLoadingSpinner();
	void UpdateProgress(const TArray<struct FOnboardingStepViewData>& before, const TArray<struct FOnboardingStepViewData>& after, const TArray<struct FRewardWrapperViewData>& Rewards);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnboardingTutorialViewInterface">();
	}
	static class IOnboardingTutorialViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOnboardingTutorialViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOnboardingTutorialViewInterface) == 0x000001, "Wrong alignment on IOnboardingTutorialViewInterface");
static_assert(sizeof(IOnboardingTutorialViewInterface) == 0x000001, "Wrong size on IOnboardingTutorialViewInterface");

// Class DBDUIViewInterfaces.PerkViewInterface
// 0x0000 (0x0000 - 0x0000)
class IPerkViewInterface final
{
public:
	void ClearData();
	void Reveal(bool useAnimation);
	void SetData(const struct FPerkViewData& PerkViewData);
	void TriggerRandomSuccess(const struct FPerkRandomSuccessViewData& randomSuccessViewData);
	void UpdatePerkCooldown(float cooldownValue, bool IsRechargeable, bool IsRechargeableActive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkViewInterface">();
	}
	static class IPerkViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPerkViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPerkViewInterface) == 0x000001, "Wrong alignment on IPerkViewInterface");
static_assert(sizeof(IPerkViewInterface) == 0x000001, "Wrong size on IPerkViewInterface");

// Class DBDUIViewInterfaces.PingStatusViewInterface
// 0x0000 (0x0000 - 0x0000)
class IPingStatusViewInterface final
{
public:
	void InitPingStatus(const int32 numberOfSurvivors);
	void SetKillerConnectionQualityStatus(const EConnectionQuality& killerConnectionQuality);
	void SetLocalPacketLossStatus(const EConnectionQuality& localPacketLoss);
	void SetLocalPingStatus(const EConnectionQuality& localPing);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PingStatusViewInterface">();
	}
	static class IPingStatusViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPingStatusViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPingStatusViewInterface) == 0x000001, "Wrong alignment on IPingStatusViewInterface");
static_assert(sizeof(IPingStatusViewInterface) == 0x000001, "Wrong size on IPingStatusViewInterface");

// Class DBDUIViewInterfaces.PlayerCardViewInterface
// 0x0000 (0x0000 - 0x0000)
class IPlayerCardViewInterface final
{
public:
	void SetData(const struct FPlayerCardViewData& playerCardData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCardViewInterface">();
	}
	static class IPlayerCardViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPlayerCardViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPlayerCardViewInterface) == 0x000001, "Wrong alignment on IPlayerCardViewInterface");
static_assert(sizeof(IPlayerCardViewInterface) == 0x000001, "Wrong size on IPlayerCardViewInterface");

// Class DBDUIViewInterfaces.PlayerStatusesContainerViewInterface
// 0x0000 (0x0000 - 0x0000)
class IPlayerStatusesContainerViewInterface final
{
public:
	TScriptInterface<class IPlayerStatusViewInterface> GetPlayerStatusInterface(int32 Index_0);
	void SetPlayerStatusesCount(const int32 TotalCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStatusesContainerViewInterface">();
	}
	static class IPlayerStatusesContainerViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPlayerStatusesContainerViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPlayerStatusesContainerViewInterface) == 0x000001, "Wrong alignment on IPlayerStatusesContainerViewInterface");
static_assert(sizeof(IPlayerStatusesContainerViewInterface) == 0x000001, "Wrong size on IPlayerStatusesContainerViewInterface");

// Class DBDUIViewInterfaces.DoctorStatusData
// 0x0008 (0x0038 - 0x0030)
class UDoctorStatusData final : public UKillerStatusData
{
public:
	EAfflictionLevel                              AfflictionLevel;                                   // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoctorStatusData">();
	}
	static class UDoctorStatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDoctorStatusData>();
	}
};
static_assert(alignof(UDoctorStatusData) == 0x000008, "Wrong alignment on UDoctorStatusData");
static_assert(sizeof(UDoctorStatusData) == 0x000038, "Wrong size on UDoctorStatusData");
static_assert(offsetof(UDoctorStatusData, AfflictionLevel) == 0x000030, "Member 'UDoctorStatusData::AfflictionLevel' has a wrong offset!");

// Class DBDUIViewInterfaces.TwinsStatusData
// 0x0008 (0x0038 - 0x0030)
class UTwinsStatusData final : public UKillerStatusData
{
public:
	bool                                          TwinsActive;                                       // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinsStatusData">();
	}
	static class UTwinsStatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinsStatusData>();
	}
};
static_assert(alignof(UTwinsStatusData) == 0x000008, "Wrong alignment on UTwinsStatusData");
static_assert(sizeof(UTwinsStatusData) == 0x000038, "Wrong size on UTwinsStatusData");
static_assert(offsetof(UTwinsStatusData, TwinsActive) == 0x000030, "Member 'UTwinsStatusData::TwinsActive' has a wrong offset!");

// Class DBDUIViewInterfaces.NightmareStatusData
// 0x0010 (0x0040 - 0x0030)
class UNightmareStatusData final : public UKillerStatusData
{
public:
	ESleepingUIState                              SleepingState;                                     // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SleepingProgress;                                  // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SleepProtectionRemainingDuration;                  // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NightmareStatusData">();
	}
	static class UNightmareStatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNightmareStatusData>();
	}
};
static_assert(alignof(UNightmareStatusData) == 0x000008, "Wrong alignment on UNightmareStatusData");
static_assert(sizeof(UNightmareStatusData) == 0x000040, "Wrong size on UNightmareStatusData");
static_assert(offsetof(UNightmareStatusData, SleepingState) == 0x000030, "Member 'UNightmareStatusData::SleepingState' has a wrong offset!");
static_assert(offsetof(UNightmareStatusData, SleepingProgress) == 0x000034, "Member 'UNightmareStatusData::SleepingProgress' has a wrong offset!");
static_assert(offsetof(UNightmareStatusData, SleepProtectionRemainingDuration) == 0x000038, "Member 'UNightmareStatusData::SleepProtectionRemainingDuration' has a wrong offset!");

// Class DBDUIViewInterfaces.PlagueStatusData
// 0x0008 (0x0038 - 0x0030)
class UPlagueStatusData final : public UKillerStatusData
{
public:
	ESicknessLevel                                SicknessLevel;                                     // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SicknessProgress;                                  // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlagueStatusData">();
	}
	static class UPlagueStatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlagueStatusData>();
	}
};
static_assert(alignof(UPlagueStatusData) == 0x000008, "Wrong alignment on UPlagueStatusData");
static_assert(sizeof(UPlagueStatusData) == 0x000038, "Wrong size on UPlagueStatusData");
static_assert(offsetof(UPlagueStatusData, SicknessLevel) == 0x000030, "Member 'UPlagueStatusData::SicknessLevel' has a wrong offset!");
static_assert(offsetof(UPlagueStatusData, SicknessProgress) == 0x000034, "Member 'UPlagueStatusData::SicknessProgress' has a wrong offset!");

// Class DBDUIViewInterfaces.K24StatusData
// 0x0008 (0x0038 - 0x0030)
class UK24StatusData final : public UKillerStatusData
{
public:
	bool                                          IsContaminated;                                    // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K24StatusData">();
	}
	static class UK24StatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK24StatusData>();
	}
};
static_assert(alignof(UK24StatusData) == 0x000008, "Wrong alignment on UK24StatusData");
static_assert(sizeof(UK24StatusData) == 0x000038, "Wrong size on UK24StatusData");
static_assert(offsetof(UK24StatusData, IsContaminated) == 0x000030, "Member 'UK24StatusData::IsContaminated' has a wrong offset!");

// Class DBDUIViewInterfaces.K26StatusData
// 0x0008 (0x0038 - 0x0030)
class UK26StatusData final : public UKillerStatusData
{
public:
	bool                                          IsCrowAttached;                                    // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26StatusData">();
	}
	static class UK26StatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26StatusData>();
	}
};
static_assert(alignof(UK26StatusData) == 0x000008, "Wrong alignment on UK26StatusData");
static_assert(sizeof(UK26StatusData) == 0x000038, "Wrong size on UK26StatusData");
static_assert(offsetof(UK26StatusData, IsCrowAttached) == 0x000030, "Member 'UK26StatusData::IsCrowAttached' has a wrong offset!");

// Class DBDUIViewInterfaces.K28StatusData
// 0x0008 (0x0038 - 0x0030)
class UK28StatusData final : public UKillerStatusData
{
public:
	float                                         DayNightCycleProgressPercentage;                   // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDaytime;                                         // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTransitioningToNighttime;                        // 0x0035(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNighttime;                                       // 0x0036(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTransitioningToDaytime;                          // 0x0037(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28StatusData">();
	}
	static class UK28StatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28StatusData>();
	}
};
static_assert(alignof(UK28StatusData) == 0x000008, "Wrong alignment on UK28StatusData");
static_assert(sizeof(UK28StatusData) == 0x000038, "Wrong size on UK28StatusData");
static_assert(offsetof(UK28StatusData, DayNightCycleProgressPercentage) == 0x000030, "Member 'UK28StatusData::DayNightCycleProgressPercentage' has a wrong offset!");
static_assert(offsetof(UK28StatusData, IsDaytime) == 0x000034, "Member 'UK28StatusData::IsDaytime' has a wrong offset!");
static_assert(offsetof(UK28StatusData, IsTransitioningToNighttime) == 0x000035, "Member 'UK28StatusData::IsTransitioningToNighttime' has a wrong offset!");
static_assert(offsetof(UK28StatusData, IsNighttime) == 0x000036, "Member 'UK28StatusData::IsNighttime' has a wrong offset!");
static_assert(offsetof(UK28StatusData, IsTransitioningToDaytime) == 0x000037, "Member 'UK28StatusData::IsTransitioningToDaytime' has a wrong offset!");

// Class DBDUIViewInterfaces.K30StatusData
// 0x0008 (0x0038 - 0x0030)
class UK30StatusData final : public UKillerStatusData
{
public:
	float                                         HuntRemainingPercentage;                           // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHuntingSurvivor;                                 // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30StatusData">();
	}
	static class UK30StatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30StatusData>();
	}
};
static_assert(alignof(UK30StatusData) == 0x000008, "Wrong alignment on UK30StatusData");
static_assert(sizeof(UK30StatusData) == 0x000038, "Wrong size on UK30StatusData");
static_assert(offsetof(UK30StatusData, HuntRemainingPercentage) == 0x000030, "Member 'UK30StatusData::HuntRemainingPercentage' has a wrong offset!");
static_assert(offsetof(UK30StatusData, IsHuntingSurvivor) == 0x000034, "Member 'UK30StatusData::IsHuntingSurvivor' has a wrong offset!");

// Class DBDUIViewInterfaces.K32StatusData
// 0x0008 (0x0038 - 0x0030)
class UK32StatusData final : public UKillerStatusData
{
public:
	bool                                          IsAssimilated;                                     // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32StatusData">();
	}
	static class UK32StatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32StatusData>();
	}
};
static_assert(alignof(UK32StatusData) == 0x000008, "Wrong alignment on UK32StatusData");
static_assert(sizeof(UK32StatusData) == 0x000038, "Wrong size on UK32StatusData");
static_assert(offsetof(UK32StatusData, IsAssimilated) == 0x000030, "Member 'UK32StatusData::IsAssimilated' has a wrong offset!");

// Class DBDUIViewInterfaces.K36StatusData
// 0x0018 (0x0048 - 0x0030)
class UK36StatusData final : public UKillerStatusData
{
public:
	bool                                          HasBracers;                                        // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasBoots;                                          // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          hasAssimilatedEyeArtifact;                         // 0x0032(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanUseEyeArtifactPower;                            // 0x0033(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasAssimilatedHandArtifact;                        // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanUseHandArtifactPower;                           // 0x0035(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldSeeBootsCounterSpell;                        // 0x0036(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldSeeBracersCounterSpell;                      // 0x0037(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInjured;                                         // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AreMagicItemsVFXsHidden;                           // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BootsCounterID;                                    // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BracersCounterID;                                  // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisableMagicItemProgressionPercentage;             // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36StatusData">();
	}
	static class UK36StatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36StatusData>();
	}
};
static_assert(alignof(UK36StatusData) == 0x000008, "Wrong alignment on UK36StatusData");
static_assert(sizeof(UK36StatusData) == 0x000048, "Wrong size on UK36StatusData");
static_assert(offsetof(UK36StatusData, HasBracers) == 0x000030, "Member 'UK36StatusData::HasBracers' has a wrong offset!");
static_assert(offsetof(UK36StatusData, HasBoots) == 0x000031, "Member 'UK36StatusData::HasBoots' has a wrong offset!");
static_assert(offsetof(UK36StatusData, hasAssimilatedEyeArtifact) == 0x000032, "Member 'UK36StatusData::hasAssimilatedEyeArtifact' has a wrong offset!");
static_assert(offsetof(UK36StatusData, CanUseEyeArtifactPower) == 0x000033, "Member 'UK36StatusData::CanUseEyeArtifactPower' has a wrong offset!");
static_assert(offsetof(UK36StatusData, HasAssimilatedHandArtifact) == 0x000034, "Member 'UK36StatusData::HasAssimilatedHandArtifact' has a wrong offset!");
static_assert(offsetof(UK36StatusData, CanUseHandArtifactPower) == 0x000035, "Member 'UK36StatusData::CanUseHandArtifactPower' has a wrong offset!");
static_assert(offsetof(UK36StatusData, ShouldSeeBootsCounterSpell) == 0x000036, "Member 'UK36StatusData::ShouldSeeBootsCounterSpell' has a wrong offset!");
static_assert(offsetof(UK36StatusData, ShouldSeeBracersCounterSpell) == 0x000037, "Member 'UK36StatusData::ShouldSeeBracersCounterSpell' has a wrong offset!");
static_assert(offsetof(UK36StatusData, IsInjured) == 0x000038, "Member 'UK36StatusData::IsInjured' has a wrong offset!");
static_assert(offsetof(UK36StatusData, AreMagicItemsVFXsHidden) == 0x000039, "Member 'UK36StatusData::AreMagicItemsVFXsHidden' has a wrong offset!");
static_assert(offsetof(UK36StatusData, BootsCounterID) == 0x00003C, "Member 'UK36StatusData::BootsCounterID' has a wrong offset!");
static_assert(offsetof(UK36StatusData, BracersCounterID) == 0x000040, "Member 'UK36StatusData::BracersCounterID' has a wrong offset!");
static_assert(offsetof(UK36StatusData, DisableMagicItemProgressionPercentage) == 0x000044, "Member 'UK36StatusData::DisableMagicItemProgressionPercentage' has a wrong offset!");

// Class DBDUIViewInterfaces.K38StatusData
// 0x0010 (0x0040 - 0x0030)
class UK38StatusData final : public UKillerStatusData
{
public:
	bool                                          IsHeldByDog;                                       // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PercentageCompleted;                               // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDetectedKillerEffect;                            // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSurvivorKOKillerEffect;                          // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38StatusData">();
	}
	static class UK38StatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38StatusData>();
	}
};
static_assert(alignof(UK38StatusData) == 0x000008, "Wrong alignment on UK38StatusData");
static_assert(sizeof(UK38StatusData) == 0x000040, "Wrong size on UK38StatusData");
static_assert(offsetof(UK38StatusData, IsHeldByDog) == 0x000030, "Member 'UK38StatusData::IsHeldByDog' has a wrong offset!");
static_assert(offsetof(UK38StatusData, PercentageCompleted) == 0x000034, "Member 'UK38StatusData::PercentageCompleted' has a wrong offset!");
static_assert(offsetof(UK38StatusData, IsDetectedKillerEffect) == 0x000038, "Member 'UK38StatusData::IsDetectedKillerEffect' has a wrong offset!");
static_assert(offsetof(UK38StatusData, IsSurvivorKOKillerEffect) == 0x000039, "Member 'UK38StatusData::IsSurvivorKOKillerEffect' has a wrong offset!");

// Class DBDUIViewInterfaces.K39StatusData
// 0x0008 (0x0038 - 0x0030)
class UK39StatusData final : public UKillerStatusData
{
public:
	bool                                          IsInfected;                                        // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WithdrawalTimeRemainingPercent;                    // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K39StatusData">();
	}
	static class UK39StatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK39StatusData>();
	}
};
static_assert(alignof(UK39StatusData) == 0x000008, "Wrong alignment on UK39StatusData");
static_assert(sizeof(UK39StatusData) == 0x000038, "Wrong size on UK39StatusData");
static_assert(offsetof(UK39StatusData, IsInfected) == 0x000030, "Member 'UK39StatusData::IsInfected' has a wrong offset!");
static_assert(offsetof(UK39StatusData, WithdrawalTimeRemainingPercent) == 0x000034, "Member 'UK39StatusData::WithdrawalTimeRemainingPercent' has a wrong offset!");

// Class DBDUIViewInterfaces.K40StatusData
// 0x0008 (0x0038 - 0x0030)
class UK40StatusData final : public UKillerStatusData
{
public:
	bool                                          HasAttachedProjectile;                             // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K40StatusData">();
	}
	static class UK40StatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK40StatusData>();
	}
};
static_assert(alignof(UK40StatusData) == 0x000008, "Wrong alignment on UK40StatusData");
static_assert(sizeof(UK40StatusData) == 0x000038, "Wrong size on UK40StatusData");
static_assert(offsetof(UK40StatusData, HasAttachedProjectile) == 0x000030, "Member 'UK40StatusData::HasAttachedProjectile' has a wrong offset!");

// Class DBDUIViewInterfaces.PlayerStatusViewInterface
// 0x0000 (0x0000 - 0x0000)
class IPlayerStatusViewInterface final
{
public:
	void ClearData();
	void DimObsessionAndChaseClaws(const bool disableLeftClaw, const bool disableRightClaw);
	void EnableChasesMode(const bool isChased);
	void HideSurvivorActivity();
	void PlayHookEscapeFailedAnimation();
	void PlayTimerAnimation();
	void SetCampProgress(float Value, bool IsLocalPlayerAKiller);
	void SetData(const struct FPlayerStatusViewData& Data);
	void SetKiller(const struct FGameplayTag& killerTag, bool isPrimaryKillerEffect);
	void SetPlayerNameVisibility(bool Visible);
	void SetTimerProgress(float Value, bool IsDeepWound);
	void ShowSurvivorActivity(const TSoftObjectPtr<class UTexture2D>& activityIcon, const bool ShouldDisplayProgress);
	void TriggerAfflictionHit();
	void UpdateSurvivorActivityProgress(const float Progress);
	void UpdateSurvivorSpecificPingIcon(const EConnectionQuality& connectionQuality);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStatusViewInterface">();
	}
	static class IPlayerStatusViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPlayerStatusViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPlayerStatusViewInterface) == 0x000001, "Wrong alignment on IPlayerStatusViewInterface");
static_assert(sizeof(IPlayerStatusViewInterface) == 0x000001, "Wrong size on IPlayerStatusViewInterface");

// Class DBDUIViewInterfaces.PowerViewInterface
// 0x0000 (0x0000 - 0x0000)
class IPowerViewInterface final
{
public:
	void ClearData();
	void SetData(const struct FPowerViewData& PowerViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PowerViewInterface">();
	}
	static class IPowerViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPowerViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPowerViewInterface) == 0x000001, "Wrong alignment on IPowerViewInterface");
static_assert(sizeof(IPowerViewInterface) == 0x000001, "Wrong size on IPowerViewInterface");

// Class DBDUIViewInterfaces.ProcessingPopupViewData
// 0x0000 (0x0070 - 0x0070)
class UProcessingPopupViewData final : public UBasePopupViewData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProcessingPopupViewData">();
	}
	static class UProcessingPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProcessingPopupViewData>();
	}
};
static_assert(alignof(UProcessingPopupViewData) == 0x000008, "Wrong alignment on UProcessingPopupViewData");
static_assert(sizeof(UProcessingPopupViewData) == 0x000070, "Wrong size on UProcessingPopupViewData");

// Class DBDUIViewInterfaces.ProcessingPopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class IProcessingPopupViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProcessingPopupViewInterface">();
	}
	static class IProcessingPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IProcessingPopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IProcessingPopupViewInterface) == 0x000001, "Wrong alignment on IProcessingPopupViewInterface");
static_assert(sizeof(IProcessingPopupViewInterface) == 0x000001, "Wrong size on IProcessingPopupViewInterface");

// Class DBDUIViewInterfaces.ProfileMenuCustomizationViewInterface
// 0x0000 (0x0000 - 0x0000)
class IProfileMenuCustomizationViewInterface final
{
public:
	void DeselectItem();
	void EnableInputs(const bool Enable);
	void Init(ECustomizationCategory CustomizationCategory, ESortingOption SortingOption);
	void SetEquipButtonText(const bool canEquip, const bool IsEquipped);
	void SetEquippedItem(const bool IsEquipped);
	void SetItemsData(const TArray<class UStoreCustomizationItemViewData*>& customizationRewardsData, const int32 selectedIndex);
	void SetPreviewAreaData(const struct FCustomizationItemPreviewAreaViewData& ViewData, const bool noCustomizationEquipped);
	void SetSelectedItem(const int32 selectedIndex);

	TScriptInterface<class ISearchBarViewInterface> GetSearchBarInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProfileMenuCustomizationViewInterface">();
	}
	static class IProfileMenuCustomizationViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IProfileMenuCustomizationViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IProfileMenuCustomizationViewInterface) == 0x000001, "Wrong alignment on IProfileMenuCustomizationViewInterface");
static_assert(sizeof(IProfileMenuCustomizationViewInterface) == 0x000001, "Wrong size on IProfileMenuCustomizationViewInterface");

// Class DBDUIViewInterfaces.ProfileMenuStatsViewInterface
// 0x0000 (0x0000 - 0x0000)
class IProfileMenuStatsViewInterface final
{
public:
	void SetPlayerLevel(const struct FPlayerLevelViewData& ViewData);
	void SetPlayerRanks(const struct FRankViewData& survivorViewData, const struct FRankViewData& killerViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProfileMenuStatsViewInterface">();
	}
	static class IProfileMenuStatsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IProfileMenuStatsViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IProfileMenuStatsViewInterface) == 0x000001, "Wrong alignment on IProfileMenuStatsViewInterface");
static_assert(sizeof(IProfileMenuStatsViewInterface) == 0x000001, "Wrong size on IProfileMenuStatsViewInterface");

// Class DBDUIViewInterfaces.ProfileMenuViewInterface
// 0x0000 (0x0000 - 0x0000)
class IProfileMenuViewInterface final
{
public:
	void SetIsFocused(const bool isFocused);
	void SetMenuState(EProfileMenuState menuState);
	void SetSubtitle(const class FText& subtitle);
	void SetTabEnabled(int32 Key, bool Enabled);
	void SetTabsData(const TArray<struct FTabWidgetData>& tabsData, int32 SelectedKey);
	void SetTabSelected(int32 Key);
	void SetTitle(const class FText& Title);

	TScriptInterface<class IProfileMenuCustomizationViewInterface> GetProfileMenuBadgeInterface() const;
	TScriptInterface<class IProfileMenuCustomizationViewInterface> GetProfileMenuBannerInterface() const;
	TScriptInterface<class IProfileMenuStatsViewInterface> GetProfileMenuStatsInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProfileMenuViewInterface">();
	}
	static class IProfileMenuViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IProfileMenuViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IProfileMenuViewInterface) == 0x000001, "Wrong alignment on IProfileMenuViewInterface");
static_assert(sizeof(IProfileMenuViewInterface) == 0x000001, "Wrong size on IProfileMenuViewInterface");

// Class DBDUIViewInterfaces.ProgressionSystemInfoPopupViewData
// 0x0000 (0x01F0 - 0x01F0)
class UProgressionSystemInfoPopupViewData final : public UGenericPopupViewData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProgressionSystemInfoPopupViewData">();
	}
	static class UProgressionSystemInfoPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProgressionSystemInfoPopupViewData>();
	}
};
static_assert(alignof(UProgressionSystemInfoPopupViewData) == 0x000010, "Wrong alignment on UProgressionSystemInfoPopupViewData");
static_assert(sizeof(UProgressionSystemInfoPopupViewData) == 0x0001F0, "Wrong size on UProgressionSystemInfoPopupViewData");

// Class DBDUIViewInterfaces.ProgressionSystemInfoPopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class IProgressionSystemInfoPopupViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProgressionSystemInfoPopupViewInterface">();
	}
	static class IProgressionSystemInfoPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IProgressionSystemInfoPopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IProgressionSystemInfoPopupViewInterface) == 0x000001, "Wrong alignment on IProgressionSystemInfoPopupViewInterface");
static_assert(sizeof(IProgressionSystemInfoPopupViewInterface) == 0x000001, "Wrong size on IProgressionSystemInfoPopupViewInterface");

// Class DBDUIViewInterfaces.QuickTimeEventViewInterface
// 0x0000 (0x0000 - 0x0000)
class IQuickTimeEventViewInterface final
{
public:
	void HideQuickTimeEvent();
	void ShowQuickTimeEvent(const struct FQuickTimeEventViewData& quickTimeEventData);
	void ShowQuickTimeEventFail();
	void ShowQuickTimeEventSuccess();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuickTimeEventViewInterface">();
	}
	static class IQuickTimeEventViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IQuickTimeEventViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IQuickTimeEventViewInterface) == 0x000001, "Wrong alignment on IQuickTimeEventViewInterface");
static_assert(sizeof(IQuickTimeEventViewInterface) == 0x000001, "Wrong size on IQuickTimeEventViewInterface");

// Class DBDUIViewInterfaces.ReportFeedbackPopupViewData
// 0x0010 (0x0200 - 0x01F0)
class UReportFeedbackPopupViewData final : public UGenericPopupViewData
{
public:
	uint8                                         Pad_1F0[0x10];                                     // 0x01F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReportFeedbackPopupViewData">();
	}
	static class UReportFeedbackPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReportFeedbackPopupViewData>();
	}
};
static_assert(alignof(UReportFeedbackPopupViewData) == 0x000010, "Wrong alignment on UReportFeedbackPopupViewData");
static_assert(sizeof(UReportFeedbackPopupViewData) == 0x000200, "Wrong size on UReportFeedbackPopupViewData");

// Class DBDUIViewInterfaces.ReportFeedbackPopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class IReportFeedbackPopupViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReportFeedbackPopupViewInterface">();
	}
	static class IReportFeedbackPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IReportFeedbackPopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IReportFeedbackPopupViewInterface) == 0x000001, "Wrong alignment on IReportFeedbackPopupViewInterface");
static_assert(sizeof(IReportFeedbackPopupViewInterface) == 0x000001, "Wrong size on IReportFeedbackPopupViewInterface");

// Class DBDUIViewInterfaces.GrantedRewardPopupViewData
// 0x0028 (0x0058 - 0x0030)
class UGrantedRewardPopupViewData : public UObject
{
public:
	ERewardPopupType                              Type;                                              // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TitleText;                                         // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, ExposeOnSpawn, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GrantedRewardPopupViewData">();
	}
	static class UGrantedRewardPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGrantedRewardPopupViewData>();
	}
};
static_assert(alignof(UGrantedRewardPopupViewData) == 0x000008, "Wrong alignment on UGrantedRewardPopupViewData");
static_assert(sizeof(UGrantedRewardPopupViewData) == 0x000058, "Wrong size on UGrantedRewardPopupViewData");
static_assert(offsetof(UGrantedRewardPopupViewData, Type) == 0x000030, "Member 'UGrantedRewardPopupViewData::Type' has a wrong offset!");
static_assert(offsetof(UGrantedRewardPopupViewData, TitleText) == 0x000038, "Member 'UGrantedRewardPopupViewData::TitleText' has a wrong offset!");
static_assert(offsetof(UGrantedRewardPopupViewData, Rarity) == 0x000050, "Member 'UGrantedRewardPopupViewData::Rarity' has a wrong offset!");

// Class DBDUIViewInterfaces.AuricCellBundleRewardPopupViewData
// 0x0098 (0x00F0 - 0x0058)
class UAuricCellBundleRewardPopupViewData final : public UGrantedRewardPopupViewData
{
public:
	struct FAuricCellsBundleViewData              AuricCellsBundleViewData;                          // 0x0058(0x0098)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuricCellBundleRewardPopupViewData">();
	}
	static class UAuricCellBundleRewardPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuricCellBundleRewardPopupViewData>();
	}
};
static_assert(alignof(UAuricCellBundleRewardPopupViewData) == 0x000008, "Wrong alignment on UAuricCellBundleRewardPopupViewData");
static_assert(sizeof(UAuricCellBundleRewardPopupViewData) == 0x0000F0, "Wrong size on UAuricCellBundleRewardPopupViewData");
static_assert(offsetof(UAuricCellBundleRewardPopupViewData, AuricCellsBundleViewData) == 0x000058, "Member 'UAuricCellBundleRewardPopupViewData::AuricCellsBundleViewData' has a wrong offset!");

// Class DBDUIViewInterfaces.RewardWrapperRewardPopupViewData
// 0x0590 (0x05E8 - 0x0058)
class URewardWrapperRewardPopupViewData final : public UGrantedRewardPopupViewData
{
public:
	struct FRewardWrapperViewData                 WrappedViewData;                                   // 0x0058(0x0590)(BlueprintVisible, BlueprintReadOnly, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RewardWrapperRewardPopupViewData">();
	}
	static class URewardWrapperRewardPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URewardWrapperRewardPopupViewData>();
	}
};
static_assert(alignof(URewardWrapperRewardPopupViewData) == 0x000008, "Wrong alignment on URewardWrapperRewardPopupViewData");
static_assert(sizeof(URewardWrapperRewardPopupViewData) == 0x0005E8, "Wrong size on URewardWrapperRewardPopupViewData");
static_assert(offsetof(URewardWrapperRewardPopupViewData, WrappedViewData) == 0x000058, "Member 'URewardWrapperRewardPopupViewData::WrappedViewData' has a wrong offset!");

// Class DBDUIViewInterfaces.RewardListRewardPopupViewData
// 0x0010 (0x0068 - 0x0058)
class URewardListRewardPopupViewData final : public UGrantedRewardPopupViewData
{
public:
	TArray<class URewardWrapperRewardPopupViewData*> RewardList;                                     // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RewardListRewardPopupViewData">();
	}
	static class URewardListRewardPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URewardListRewardPopupViewData>();
	}
};
static_assert(alignof(URewardListRewardPopupViewData) == 0x000008, "Wrong alignment on URewardListRewardPopupViewData");
static_assert(sizeof(URewardListRewardPopupViewData) == 0x000068, "Wrong size on URewardListRewardPopupViewData");
static_assert(offsetof(URewardListRewardPopupViewData, RewardList) == 0x000058, "Member 'URewardListRewardPopupViewData::RewardList' has a wrong offset!");

// Class DBDUIViewInterfaces.PackRewardPopupViewData
// 0x00E8 (0x0140 - 0x0058)
class UPackRewardPopupViewData final : public UGrantedRewardPopupViewData
{
public:
	class FName                                   ID;                                                // 0x0058(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   PackName;                                          // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, ExposeOnSpawn, NativeAccessSpecifierPublic)
	struct FSoftRemoteContentCacheObjectPtr       RemoteImagePtr;                                    // 0x0080(0x0070)(BlueprintVisible, BlueprintReadOnly, Transient, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              TexturePtr;                                        // 0x00F0(0x0038)(BlueprintVisible, BlueprintReadOnly, Transient, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCompositionForPackImage;                        // 0x0128(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x3];                                      // 0x0129(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PackImageCompositionNumberOfItems;                 // 0x012C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UStorePackContentData*>          SortedContent;                                     // 0x0130(0x0010)(BlueprintVisible, ZeroConstructor, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PackRewardPopupViewData">();
	}
	static class UPackRewardPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPackRewardPopupViewData>();
	}
};
static_assert(alignof(UPackRewardPopupViewData) == 0x000008, "Wrong alignment on UPackRewardPopupViewData");
static_assert(sizeof(UPackRewardPopupViewData) == 0x000140, "Wrong size on UPackRewardPopupViewData");
static_assert(offsetof(UPackRewardPopupViewData, ID) == 0x000058, "Member 'UPackRewardPopupViewData::ID' has a wrong offset!");
static_assert(offsetof(UPackRewardPopupViewData, PackName) == 0x000068, "Member 'UPackRewardPopupViewData::PackName' has a wrong offset!");
static_assert(offsetof(UPackRewardPopupViewData, RemoteImagePtr) == 0x000080, "Member 'UPackRewardPopupViewData::RemoteImagePtr' has a wrong offset!");
static_assert(offsetof(UPackRewardPopupViewData, TexturePtr) == 0x0000F0, "Member 'UPackRewardPopupViewData::TexturePtr' has a wrong offset!");
static_assert(offsetof(UPackRewardPopupViewData, UseCompositionForPackImage) == 0x000128, "Member 'UPackRewardPopupViewData::UseCompositionForPackImage' has a wrong offset!");
static_assert(offsetof(UPackRewardPopupViewData, PackImageCompositionNumberOfItems) == 0x00012C, "Member 'UPackRewardPopupViewData::PackImageCompositionNumberOfItems' has a wrong offset!");
static_assert(offsetof(UPackRewardPopupViewData, SortedContent) == 0x000130, "Member 'UPackRewardPopupViewData::SortedContent' has a wrong offset!");

// Class DBDUIViewInterfaces.RewardPopupViewData
// 0x0030 (0x0220 - 0x01F0)
class URewardPopupViewData final : public UGenericPopupViewData
{
public:
	class FName                                   RewardId;                                          // 0x01F0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FC[0x4];                                      // 0x01FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGrantedRewardPopupViewData*>    Rewards;                                           // 0x0200(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, NativeAccessSpecifierPublic)
	bool                                          ShouldShowListOfRewards;                           // 0x0210(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_211[0xF];                                      // 0x0211(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RewardPopupViewData">();
	}
	static class URewardPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URewardPopupViewData>();
	}
};
static_assert(alignof(URewardPopupViewData) == 0x000010, "Wrong alignment on URewardPopupViewData");
static_assert(sizeof(URewardPopupViewData) == 0x000220, "Wrong size on URewardPopupViewData");
static_assert(offsetof(URewardPopupViewData, RewardId) == 0x0001F0, "Member 'URewardPopupViewData::RewardId' has a wrong offset!");
static_assert(offsetof(URewardPopupViewData, Rewards) == 0x000200, "Member 'URewardPopupViewData::Rewards' has a wrong offset!");
static_assert(offsetof(URewardPopupViewData, ShouldShowListOfRewards) == 0x000210, "Member 'URewardPopupViewData::ShouldShowListOfRewards' has a wrong offset!");

// Class DBDUIViewInterfaces.RewardPopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class IRewardPopupViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RewardPopupViewInterface">();
	}
	static class IRewardPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRewardPopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IRewardPopupViewInterface) == 0x000001, "Wrong alignment on IRewardPopupViewInterface");
static_assert(sizeof(IRewardPopupViewInterface) == 0x000001, "Wrong size on IRewardPopupViewInterface");

// Class DBDUIViewInterfaces.RiftViewInterface
// 0x0000 (0x0000 - 0x0000)
class IRiftViewInterface final
{
public:
	void PlayUnlockingAnimation(const struct FArchivesRiftUnlockSequenceData& Data);
	void SetData(const struct FArchivesRiftGenericViewData& Data);
	void SetImagePreviewAreaData(const struct FCustomizationItemPreviewAreaViewData& ViewData);
	void SetMatchmakingSoftlockState(bool isInMatchmakingSoftlock);
	void SetOutfitPreviewButtonVisible(const bool IsVisible);
	void SetRewardTiersData(const TArray<struct FArchiveRiftTierRewardsViewData>& riftTiersData);
	void SetRiftFragmentTooltipViewData(const struct FCurrencyProgressionTooltipViewData& RiftFragmentTooltipViewData);
	void SetRiftPackButtonEnabled(bool IsEnabled);
	void SetTitle(const class FText& Title);

	TScriptInterface<class IDisplayStandViewInterface> GetDisplayStandViewInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RiftViewInterface">();
	}
	static class IRiftViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRiftViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IRiftViewInterface) == 0x000001, "Wrong alignment on IRiftViewInterface");
static_assert(sizeof(IRiftViewInterface) == 0x000001, "Wrong size on IRiftViewInterface");

// Class DBDUIViewInterfaces.ScaleformTooltipViewInterface
// 0x0000 (0x0000 - 0x0000)
class IScaleformTooltipViewInterface final
{
public:
	void OnLoadoutTooltipHovered(const struct FTooltipTriggerGeometry& triggeredGeometry, const struct FLoadoutTooltipData& TooltipData);
	void OnTooltipTargetUnhovered();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScaleformTooltipViewInterface">();
	}
	static class IScaleformTooltipViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IScaleformTooltipViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IScaleformTooltipViewInterface) == 0x000001, "Wrong alignment on IScaleformTooltipViewInterface");
static_assert(sizeof(IScaleformTooltipViewInterface) == 0x000001, "Wrong size on IScaleformTooltipViewInterface");

// Class DBDUIViewInterfaces.ScreenIndicatorsContainerViewInterface
// 0x0000 (0x0000 - 0x0000)
class IScreenIndicatorsContainerViewInterface final
{
public:
	void RemoveDirectionIndicator(const class FString& ID);
	void ShowDirectionIndicator(const struct FScreenIndicatorViewData& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenIndicatorsContainerViewInterface">();
	}
	static class IScreenIndicatorsContainerViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IScreenIndicatorsContainerViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IScreenIndicatorsContainerViewInterface) == 0x000001, "Wrong alignment on IScreenIndicatorsContainerViewInterface");
static_assert(sizeof(IScreenIndicatorsContainerViewInterface) == 0x000001, "Wrong size on IScreenIndicatorsContainerViewInterface");

// Class DBDUIViewInterfaces.SearchBarViewInterface
// 0x0000 (0x0000 - 0x0000)
class ISearchBarViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SearchBarViewInterface">();
	}
	static class ISearchBarViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISearchBarViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ISearchBarViewInterface) == 0x000001, "Wrong alignment on ISearchBarViewInterface");
static_assert(sizeof(ISearchBarViewInterface) == 0x000001, "Wrong size on ISearchBarViewInterface");

// Class DBDUIViewInterfaces.SeasonEndRankRewardsPopupViewData
// 0x0030 (0x0220 - 0x01F0)
class USeasonEndRankRewardsPopupViewData final : public UGenericPopupViewData
{
public:
	int32                                         OldKillerRank;                                     // 0x01F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OldSurvivorRank;                                   // 0x01F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRewardWrapperViewData>         SurvivorRewards;                                   // 0x01F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FRewardWrapperViewData>         KillerRewards;                                     // 0x0208(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_218[0x8];                                      // 0x0218(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeasonEndRankRewardsPopupViewData">();
	}
	static class USeasonEndRankRewardsPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeasonEndRankRewardsPopupViewData>();
	}
};
static_assert(alignof(USeasonEndRankRewardsPopupViewData) == 0x000010, "Wrong alignment on USeasonEndRankRewardsPopupViewData");
static_assert(sizeof(USeasonEndRankRewardsPopupViewData) == 0x000220, "Wrong size on USeasonEndRankRewardsPopupViewData");
static_assert(offsetof(USeasonEndRankRewardsPopupViewData, OldKillerRank) == 0x0001F0, "Member 'USeasonEndRankRewardsPopupViewData::OldKillerRank' has a wrong offset!");
static_assert(offsetof(USeasonEndRankRewardsPopupViewData, OldSurvivorRank) == 0x0001F4, "Member 'USeasonEndRankRewardsPopupViewData::OldSurvivorRank' has a wrong offset!");
static_assert(offsetof(USeasonEndRankRewardsPopupViewData, SurvivorRewards) == 0x0001F8, "Member 'USeasonEndRankRewardsPopupViewData::SurvivorRewards' has a wrong offset!");
static_assert(offsetof(USeasonEndRankRewardsPopupViewData, KillerRewards) == 0x000208, "Member 'USeasonEndRankRewardsPopupViewData::KillerRewards' has a wrong offset!");

// Class DBDUIViewInterfaces.SeasonEndRankRewardsPopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class ISeasonEndRankRewardsPopupViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeasonEndRankRewardsPopupViewInterface">();
	}
	static class ISeasonEndRankRewardsPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISeasonEndRankRewardsPopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ISeasonEndRankRewardsPopupViewInterface) == 0x000001, "Wrong alignment on ISeasonEndRankRewardsPopupViewInterface");
static_assert(sizeof(ISeasonEndRankRewardsPopupViewInterface) == 0x000001, "Wrong size on ISeasonEndRankRewardsPopupViewInterface");

// Class DBDUIViewInterfaces.SecurityCameraOverlayViewInterface
// 0x0000 (0x0000 - 0x0000)
class ISecurityCameraOverlayViewInterface final
{
public:
	void SetBatteryPercent(const float Percent);
	void SetCameraMapStatus(const int32 cameraIndex, const ESecurityCameraMapState newState);
	void SetCurrentDoor(const int32 doorIndex);
	void SetState(const int32 cameraIndex, const ESecurityCameraState newState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SecurityCameraOverlayViewInterface">();
	}
	static class ISecurityCameraOverlayViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISecurityCameraOverlayViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ISecurityCameraOverlayViewInterface) == 0x000001, "Wrong alignment on ISecurityCameraOverlayViewInterface");
static_assert(sizeof(ISecurityCameraOverlayViewInterface) == 0x000001, "Wrong size on ISecurityCameraOverlayViewInterface");

// Class DBDUIViewInterfaces.SettingsMatchDetailsViewInterface
// 0x0000 (0x0000 - 0x0000)
class ISettingsMatchDetailsViewInterface final
{
public:
	void SetChallengeCardList(const TArray<struct FChallengeViewData>& challengesData, int32 maximumNumberOfFollowedChallenges, bool IsDisabled, const class FText& DisabledText);
	void SetLayout(const EGameType gameType);
	void SetMapData(const class FString& mapThemeName, const class FString& mapTileName);
	void SetOfferings(const TMap<class FString, class UMenuOfferingViewData*>& playerIdToOfferingMapping);
	void SetPerks(const TArray<class UMenuPerkViewData*>& PerksData);
	void SetPlayersInfo(const TArray<struct FPlayerInfoData>& SurvivorInfoData, const TArray<struct FPlayerInfoData>& killerInfoData, bool isLocalPlayerSurvivor);
	void SetPlayersInfoButtonsInteractable(const bool IsInteractable);
	void SetPlayersPings(const TMap<class FString, float>& pingData);
	void SetSkills(const TArray<class UMenuSkillViewData*>& skillsData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SettingsMatchDetailsViewInterface">();
	}
	static class ISettingsMatchDetailsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISettingsMatchDetailsViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ISettingsMatchDetailsViewInterface) == 0x000001, "Wrong alignment on ISettingsMatchDetailsViewInterface");
static_assert(sizeof(ISettingsMatchDetailsViewInterface) == 0x000001, "Wrong size on ISettingsMatchDetailsViewInterface");

// Class DBDUIViewInterfaces.SettingsViewInterface
// 0x0000 (0x0000 - 0x0000)
class ISettingsViewInterface final
{
public:
	void SetMenuState(EOverlayTabs State);
	void SetQuitInputSwitcherLabel(const class FText& label);
	void SetQuitInputSwitcherVisibility(bool IsVisible);
	void SetResetDefaultsInputSwitcherLabel(const class FText& label);
	void SetResetDefaultsInputSwitcherVisibility(bool IsVisible);
	void SetScrollPromptVisibility(bool IsVisible);

	TScriptInterface<class ISettingsMatchDetailsViewInterface> GetSettingsMatchDetailsInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SettingsViewInterface">();
	}
	static class ISettingsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISettingsViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ISettingsViewInterface) == 0x000001, "Wrong alignment on ISettingsViewInterface");
static_assert(sizeof(ISettingsViewInterface) == 0x000001, "Wrong size on ISettingsViewInterface");

// Class DBDUIViewInterfaces.ShrineOfSecretsViewInterface
// 0x0000 (0x0000 - 0x0000)
class IShrineOfSecretsViewInterface final
{
public:
	void SetData(const struct FShrineOfSecretsViewData& ShrineOfSecretsViewData);
	void UpdateItemsFromPurchase(const struct FShrineOfSecretsViewData& ShrineOfSecretsViewData, const struct FShrineOfSecretsItemViewData& purchasedItem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShrineOfSecretsViewInterface">();
	}
	static class IShrineOfSecretsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IShrineOfSecretsViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IShrineOfSecretsViewInterface) == 0x000001, "Wrong alignment on IShrineOfSecretsViewInterface");
static_assert(sizeof(IShrineOfSecretsViewInterface) == 0x000001, "Wrong size on IShrineOfSecretsViewInterface");

// Class DBDUIViewInterfaces.SkillCheckViewInterface
// 0x0000 (0x0000 - 0x0000)
class ISkillCheckViewInterface final
{
public:
	void ApplyScaleFactor(float Scale);
	void HideSkillCheck();
	void ShowSkillCheck(const struct FSkillCheckViewData& skillCheckData);
	void ShowSkillCheckFail();
	void ShowSkillCheckSuccess(bool IsBonus);
	void UpdatePositionOffset(int32 X, int32 Y);
	void UpdateProgress(float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillCheckViewInterface">();
	}
	static class ISkillCheckViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISkillCheckViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ISkillCheckViewInterface) == 0x000001, "Wrong alignment on ISkillCheckViewInterface");
static_assert(sizeof(ISkillCheckViewInterface) == 0x000001, "Wrong size on ISkillCheckViewInterface");

// Class DBDUIViewInterfaces.SkillUnlockedNotificationViewInterface
// 0x0000 (0x0000 - 0x0000)
class ISkillUnlockedNotificationViewInterface final
{
public:
	void Hide();
	void Show(const struct FSkillUnlockedNotificationViewData& skillUnlockedNotificationData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillUnlockedNotificationViewInterface">();
	}
	static class ISkillUnlockedNotificationViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISkillUnlockedNotificationViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ISkillUnlockedNotificationViewInterface) == 0x000001, "Wrong alignment on ISkillUnlockedNotificationViewInterface");
static_assert(sizeof(ISkillUnlockedNotificationViewInterface) == 0x000001, "Wrong size on ISkillUnlockedNotificationViewInterface");

// Class DBDUIViewInterfaces.SkillViewInterface
// 0x0000 (0x0000 - 0x0000)
class ISkillViewInterface final
{
public:
	void ClearData();
	void SetData(const struct FSkillViewData& SkillViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillViewInterface">();
	}
	static class ISkillViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISkillViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ISkillViewInterface) == 0x000001, "Wrong alignment on ISkillViewInterface");
static_assert(sizeof(ISkillViewInterface) == 0x000001, "Wrong size on ISkillViewInterface");

// Class DBDUIViewInterfaces.SpectateBarViewInterface
// 0x0000 (0x0000 - 0x0000)
class ISpectateBarViewInterface final
{
public:
	void SetArrowsVisibility(const bool IsVisible);
	void SetBotTag(const bool IsBot);
	void SetSpectateBarVisibility(const bool IsVisible);
	void SetSpectatedName(const class FString& PlayerName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpectateBarViewInterface">();
	}
	static class ISpectateBarViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISpectateBarViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ISpectateBarViewInterface) == 0x000001, "Wrong alignment on ISpectateBarViewInterface");
static_assert(sizeof(ISpectateBarViewInterface) == 0x000001, "Wrong size on ISpectateBarViewInterface");

// Class DBDUIViewInterfaces.SplashViewInterface
// 0x0000 (0x0000 - 0x0000)
class ISplashViewInterface final
{
public:
	void SetLoadingText(const class FText& Text);
	void SetLoadingTextVisibility(const bool IsVisible);
	void SetPressKeyTextVisibility(const bool IsVisible);
	void SetSpecialEvent(const class FName& eventLabel);
	void SetVersionText(const class FText& Text);
	void ShowSaveGameOverlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SplashViewInterface">();
	}
	static class ISplashViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISplashViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ISplashViewInterface) == 0x000001, "Wrong alignment on ISplashViewInterface");
static_assert(sizeof(ISplashViewInterface) == 0x000001, "Wrong size on ISplashViewInterface");

// Class DBDUIViewInterfaces.StartSequenceViewInterface
// 0x0000 (0x0000 - 0x0000)
class IStartSequenceViewInterface final
{
public:
	void HideStartSequence();
	void ShowStartSequence(const struct FStartSequenceViewData& Data);

	bool GetIsStartSequenceVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StartSequenceViewInterface">();
	}
	static class IStartSequenceViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStartSequenceViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IStartSequenceViewInterface) == 0x000001, "Wrong alignment on IStartSequenceViewInterface");
static_assert(sizeof(IStartSequenceViewInterface) == 0x000001, "Wrong size on IStartSequenceViewInterface");

// Class DBDUIViewInterfaces.StatusEffectViewInterface
// 0x0000 (0x0000 - 0x0000)
class IStatusEffectViewInterface final
{
public:
	void RemoveExistingStatusEffect(const class FName& statusEffectId);
	void ShowActiveStatusEffect(const struct FStatusEffectViewData& StatusEffectData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusEffectViewInterface">();
	}
	static class IStatusEffectViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStatusEffectViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IStatusEffectViewInterface) == 0x000001, "Wrong alignment on IStatusEffectViewInterface");
static_assert(sizeof(IStatusEffectViewInterface) == 0x000001, "Wrong size on IStatusEffectViewInterface");

// Class DBDUIViewInterfaces.StoreBaseSubTabsViewInterface
// 0x0000 (0x0000 - 0x0000)
class IStoreBaseSubTabsViewInterface final
{
public:
	void ActivateSubTabContent(const int32 State);
	void HideSubTab(const int32 subTabId);
	bool IsSubTabVisible(const int32 subTabId);
	void SelectSubTab(const int32 SelectedKey);
	void SetSubTabsData(const TArray<struct FTabWidgetData>& tabsData);
	void ShowSubTab(const int32 subTabId);
	void UnselectCurrentTab();
	void UpdateTabData(const int32 subTabId, const struct FTabWidgetData& TabWidgetData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreBaseSubTabsViewInterface">();
	}
	static class IStoreBaseSubTabsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStoreBaseSubTabsViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IStoreBaseSubTabsViewInterface) == 0x000001, "Wrong alignment on IStoreBaseSubTabsViewInterface");
static_assert(sizeof(IStoreBaseSubTabsViewInterface) == 0x000001, "Wrong size on IStoreBaseSubTabsViewInterface");

// Class DBDUIViewInterfaces.StoreChapterPackViewData
// 0x01D0 (0x0200 - 0x0030)
class UStoreChapterPackViewData final : public UObject
{
public:
	class FString                                 ID;                                                // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OriginalDlcId;                                     // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayTitle;                                      // 0x0050(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class FString                                 HeritagePackId;                                    // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   FullDescription;                                   // 0x0078(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              PackImage;                                         // 0x0090(0x0038)(BlueprintVisible, BlueprintReadOnly, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UStoreCharacterItemViewData*>    CharactersData;                                    // 0x00C8(0x0010)(BlueprintVisible, ZeroConstructor, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	TArray<class UStoreCustomizationItemViewData*> CustomizationsData;                               // 0x00D8(0x0010)(BlueprintVisible, ZeroConstructor, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	TArray<class UStorePackContentData*>          SortedContent;                                     // 0x00E8(0x0010)(BlueprintVisible, ZeroConstructor, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	int32                                         SortOrder;                                         // 0x00F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNew;                                             // 0x00FC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOwned;                                           // 0x00FD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsIndividuallyAvailable;                           // 0x00FE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FF[0x1];                                       // 0x00FF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              ActivationStartDate;                               // 0x0100(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ActivationEndDate;                                 // 0x0108(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerFlagViewData                     TimerViewData;                                     // 0x0110(0x0030)(BlueprintVisible, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	struct FSoftRemoteContentCacheObjectPtr       PackImagePtr;                                      // 0x0140(0x0070)(BlueprintVisible, BlueprintReadOnly, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPriceTagViewData                      PriceTagData;                                      // 0x01B0(0x0050)(BlueprintVisible, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreChapterPackViewData">();
	}
	static class UStoreChapterPackViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreChapterPackViewData>();
	}
};
static_assert(alignof(UStoreChapterPackViewData) == 0x000008, "Wrong alignment on UStoreChapterPackViewData");
static_assert(sizeof(UStoreChapterPackViewData) == 0x000200, "Wrong size on UStoreChapterPackViewData");
static_assert(offsetof(UStoreChapterPackViewData, ID) == 0x000030, "Member 'UStoreChapterPackViewData::ID' has a wrong offset!");
static_assert(offsetof(UStoreChapterPackViewData, OriginalDlcId) == 0x000040, "Member 'UStoreChapterPackViewData::OriginalDlcId' has a wrong offset!");
static_assert(offsetof(UStoreChapterPackViewData, DisplayTitle) == 0x000050, "Member 'UStoreChapterPackViewData::DisplayTitle' has a wrong offset!");
static_assert(offsetof(UStoreChapterPackViewData, HeritagePackId) == 0x000068, "Member 'UStoreChapterPackViewData::HeritagePackId' has a wrong offset!");
static_assert(offsetof(UStoreChapterPackViewData, FullDescription) == 0x000078, "Member 'UStoreChapterPackViewData::FullDescription' has a wrong offset!");
static_assert(offsetof(UStoreChapterPackViewData, PackImage) == 0x000090, "Member 'UStoreChapterPackViewData::PackImage' has a wrong offset!");
static_assert(offsetof(UStoreChapterPackViewData, CharactersData) == 0x0000C8, "Member 'UStoreChapterPackViewData::CharactersData' has a wrong offset!");
static_assert(offsetof(UStoreChapterPackViewData, CustomizationsData) == 0x0000D8, "Member 'UStoreChapterPackViewData::CustomizationsData' has a wrong offset!");
static_assert(offsetof(UStoreChapterPackViewData, SortedContent) == 0x0000E8, "Member 'UStoreChapterPackViewData::SortedContent' has a wrong offset!");
static_assert(offsetof(UStoreChapterPackViewData, SortOrder) == 0x0000F8, "Member 'UStoreChapterPackViewData::SortOrder' has a wrong offset!");
static_assert(offsetof(UStoreChapterPackViewData, IsNew) == 0x0000FC, "Member 'UStoreChapterPackViewData::IsNew' has a wrong offset!");
static_assert(offsetof(UStoreChapterPackViewData, IsOwned) == 0x0000FD, "Member 'UStoreChapterPackViewData::IsOwned' has a wrong offset!");
static_assert(offsetof(UStoreChapterPackViewData, IsIndividuallyAvailable) == 0x0000FE, "Member 'UStoreChapterPackViewData::IsIndividuallyAvailable' has a wrong offset!");
static_assert(offsetof(UStoreChapterPackViewData, ActivationStartDate) == 0x000100, "Member 'UStoreChapterPackViewData::ActivationStartDate' has a wrong offset!");
static_assert(offsetof(UStoreChapterPackViewData, ActivationEndDate) == 0x000108, "Member 'UStoreChapterPackViewData::ActivationEndDate' has a wrong offset!");
static_assert(offsetof(UStoreChapterPackViewData, TimerViewData) == 0x000110, "Member 'UStoreChapterPackViewData::TimerViewData' has a wrong offset!");
static_assert(offsetof(UStoreChapterPackViewData, PackImagePtr) == 0x000140, "Member 'UStoreChapterPackViewData::PackImagePtr' has a wrong offset!");
static_assert(offsetof(UStoreChapterPackViewData, PriceTagData) == 0x0001B0, "Member 'UStoreChapterPackViewData::PriceTagData' has a wrong offset!");

// Class DBDUIViewInterfaces.StoreItemViewData
// 0x0158 (0x0188 - 0x0030)
class UStoreItemViewData : public UObject
{
public:
	class FText                                   DisplayName;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	TArray<struct FPriceTagViewData>              PriceTagData;                                      // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	bool                                          IsInStore;                                         // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNewInStore;                                      // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTutorialItem;                                    // 0x005A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B[0x5];                                       // 0x005B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerFlagViewData                     LimitedTimeFlag;                                   // 0x0060(0x0030)(Edit, BlueprintVisible, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	struct FTimerFlagViewData                     DiscountTimeFlag;                                  // 0x0090(0x0030)(Edit, BlueprintVisible, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	struct FSpecialEventInfoViewData              EventInfo;                                         // 0x00C0(0x0060)(Edit, BlueprintVisible, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class FString                                 chapterPackId;                                     // 0x0120(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HeritagePackId;                                    // 0x0130(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           SpecialPackIds;                                    // 0x0140(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	struct FStoreItemUnlockInfoViewData           UnlockInfo;                                        // 0x0150(0x0030)(Edit, BlueprintVisible, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	EDisabledItemOption                           DisabledItemOption;                                // 0x0180(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetHasNotification() const;
	TSoftObjectPtr<class UTexture2D> GetIcon() const;
	bool GetIsAvailable() const;
	bool GetIsBuyable() const;
	bool GetIsEnabled() const;
	bool GetIsOwned() const;
	bool GetIsUnlocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreItemViewData">();
	}
	static class UStoreItemViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreItemViewData>();
	}
};
static_assert(alignof(UStoreItemViewData) == 0x000008, "Wrong alignment on UStoreItemViewData");
static_assert(sizeof(UStoreItemViewData) == 0x000188, "Wrong size on UStoreItemViewData");
static_assert(offsetof(UStoreItemViewData, DisplayName) == 0x000030, "Member 'UStoreItemViewData::DisplayName' has a wrong offset!");
static_assert(offsetof(UStoreItemViewData, PriceTagData) == 0x000048, "Member 'UStoreItemViewData::PriceTagData' has a wrong offset!");
static_assert(offsetof(UStoreItemViewData, IsInStore) == 0x000058, "Member 'UStoreItemViewData::IsInStore' has a wrong offset!");
static_assert(offsetof(UStoreItemViewData, IsNewInStore) == 0x000059, "Member 'UStoreItemViewData::IsNewInStore' has a wrong offset!");
static_assert(offsetof(UStoreItemViewData, IsTutorialItem) == 0x00005A, "Member 'UStoreItemViewData::IsTutorialItem' has a wrong offset!");
static_assert(offsetof(UStoreItemViewData, LimitedTimeFlag) == 0x000060, "Member 'UStoreItemViewData::LimitedTimeFlag' has a wrong offset!");
static_assert(offsetof(UStoreItemViewData, DiscountTimeFlag) == 0x000090, "Member 'UStoreItemViewData::DiscountTimeFlag' has a wrong offset!");
static_assert(offsetof(UStoreItemViewData, EventInfo) == 0x0000C0, "Member 'UStoreItemViewData::EventInfo' has a wrong offset!");
static_assert(offsetof(UStoreItemViewData, chapterPackId) == 0x000120, "Member 'UStoreItemViewData::chapterPackId' has a wrong offset!");
static_assert(offsetof(UStoreItemViewData, HeritagePackId) == 0x000130, "Member 'UStoreItemViewData::HeritagePackId' has a wrong offset!");
static_assert(offsetof(UStoreItemViewData, SpecialPackIds) == 0x000140, "Member 'UStoreItemViewData::SpecialPackIds' has a wrong offset!");
static_assert(offsetof(UStoreItemViewData, UnlockInfo) == 0x000150, "Member 'UStoreItemViewData::UnlockInfo' has a wrong offset!");
static_assert(offsetof(UStoreItemViewData, DisabledItemOption) == 0x000180, "Member 'UStoreItemViewData::DisabledItemOption' has a wrong offset!");

// Class DBDUIViewInterfaces.StoreCharacterItemViewData
// 0x01E0 (0x0368 - 0x0188)
class UStoreCharacterItemViewData final : public UStoreItemViewData
{
public:
	struct FCharacterRewardViewData               CharacterReward;                                   // 0x0188(0x0148)(Edit, BlueprintVisible, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	int32                                         characterIndex;                                    // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CharacterId;                                       // 0x02D4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   BackStory;                                         // 0x02E0(0x0018)(Edit, BlueprintVisible, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class FName                                   BackgroundImagePath;                               // 0x02F8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKillerAttributes                      KillerAttributes;                                  // 0x0304(0x000C)(Edit, BlueprintVisible, Transient, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	ECharacterDifficulty                          Difficulty;                                        // 0x0310(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_311[0x3];                                      // 0x0311(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EquippedPowerItemId;                               // 0x0314(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEquipped;                                        // 0x0320(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasNonSelectedPerks;                               // 0x0321(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDlcLockedKiller;                                 // 0x0322(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_323[0x1];                                      // 0x0323(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPrestigeViewData                      Prestige;                                          // 0x0324(0x0008)(Edit, BlueprintVisible, Transient, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	int32                                         NewItemsCount;                                     // 0x032C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DlcUiOrder;                                        // 0x0330(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBaseCharacter;                                   // 0x0334(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTrialCharacter;                                  // 0x0335(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_336[0x2];                                      // 0x0336(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerFlagViewData                     TrialTimeFlag;                                     // 0x0338(0x0030)(Edit, BlueprintVisible, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreCharacterItemViewData">();
	}
	static class UStoreCharacterItemViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreCharacterItemViewData>();
	}
};
static_assert(alignof(UStoreCharacterItemViewData) == 0x000008, "Wrong alignment on UStoreCharacterItemViewData");
static_assert(sizeof(UStoreCharacterItemViewData) == 0x000368, "Wrong size on UStoreCharacterItemViewData");
static_assert(offsetof(UStoreCharacterItemViewData, CharacterReward) == 0x000188, "Member 'UStoreCharacterItemViewData::CharacterReward' has a wrong offset!");
static_assert(offsetof(UStoreCharacterItemViewData, characterIndex) == 0x0002D0, "Member 'UStoreCharacterItemViewData::characterIndex' has a wrong offset!");
static_assert(offsetof(UStoreCharacterItemViewData, CharacterId) == 0x0002D4, "Member 'UStoreCharacterItemViewData::CharacterId' has a wrong offset!");
static_assert(offsetof(UStoreCharacterItemViewData, BackStory) == 0x0002E0, "Member 'UStoreCharacterItemViewData::BackStory' has a wrong offset!");
static_assert(offsetof(UStoreCharacterItemViewData, BackgroundImagePath) == 0x0002F8, "Member 'UStoreCharacterItemViewData::BackgroundImagePath' has a wrong offset!");
static_assert(offsetof(UStoreCharacterItemViewData, KillerAttributes) == 0x000304, "Member 'UStoreCharacterItemViewData::KillerAttributes' has a wrong offset!");
static_assert(offsetof(UStoreCharacterItemViewData, Difficulty) == 0x000310, "Member 'UStoreCharacterItemViewData::Difficulty' has a wrong offset!");
static_assert(offsetof(UStoreCharacterItemViewData, EquippedPowerItemId) == 0x000314, "Member 'UStoreCharacterItemViewData::EquippedPowerItemId' has a wrong offset!");
static_assert(offsetof(UStoreCharacterItemViewData, IsEquipped) == 0x000320, "Member 'UStoreCharacterItemViewData::IsEquipped' has a wrong offset!");
static_assert(offsetof(UStoreCharacterItemViewData, HasNonSelectedPerks) == 0x000321, "Member 'UStoreCharacterItemViewData::HasNonSelectedPerks' has a wrong offset!");
static_assert(offsetof(UStoreCharacterItemViewData, IsDlcLockedKiller) == 0x000322, "Member 'UStoreCharacterItemViewData::IsDlcLockedKiller' has a wrong offset!");
static_assert(offsetof(UStoreCharacterItemViewData, Prestige) == 0x000324, "Member 'UStoreCharacterItemViewData::Prestige' has a wrong offset!");
static_assert(offsetof(UStoreCharacterItemViewData, NewItemsCount) == 0x00032C, "Member 'UStoreCharacterItemViewData::NewItemsCount' has a wrong offset!");
static_assert(offsetof(UStoreCharacterItemViewData, DlcUiOrder) == 0x000330, "Member 'UStoreCharacterItemViewData::DlcUiOrder' has a wrong offset!");
static_assert(offsetof(UStoreCharacterItemViewData, IsBaseCharacter) == 0x000334, "Member 'UStoreCharacterItemViewData::IsBaseCharacter' has a wrong offset!");
static_assert(offsetof(UStoreCharacterItemViewData, IsTrialCharacter) == 0x000335, "Member 'UStoreCharacterItemViewData::IsTrialCharacter' has a wrong offset!");
static_assert(offsetof(UStoreCharacterItemViewData, TrialTimeFlag) == 0x000338, "Member 'UStoreCharacterItemViewData::TrialTimeFlag' has a wrong offset!");

// Class DBDUIViewInterfaces.StoreCharactersBioViewInterface
// 0x0000 (0x0000 - 0x0000)
class IStoreCharactersBioViewInterface final
{
public:
	void SetData(const struct FCharacterBioViewData& CharacterBioViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreCharactersBioViewInterface">();
	}
	static class IStoreCharactersBioViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStoreCharactersBioViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IStoreCharactersBioViewInterface) == 0x000001, "Wrong alignment on IStoreCharactersBioViewInterface");
static_assert(sizeof(IStoreCharactersBioViewInterface) == 0x000001, "Wrong size on IStoreCharactersBioViewInterface");

// Class DBDUIViewInterfaces.StoreCharactersCustomizationsViewInterface
// 0x0000 (0x0000 - 0x0000)
class IStoreCharactersCustomizationsViewInterface final
{
public:
	void SetData(const struct FStoreCharactersCustomizationsViewData& Data, const EScrollAction scrollAction);
	void ToggleCharmSlotsVisibility();
	void UpdateCategories(const TArray<struct FStoreCategoryViewData>& Categories, const ECustomizationCategory SelectedCategory);
	void UpdateCurrentPresetButton(const bool isPreviewingAnyCustomization);
	void UpdateSelectedCustomizations(const TArray<class UStoreCustomizationItemViewData*>& SelectedCustomizations, const int32 SelectedSlotIndex, const EScrollAction scrollAction);

	TScriptInterface<class ISearchBarViewInterface> GetSearchBarViewInterface() const;
	TScriptInterface<class IStoreCharactersFilterViewInterface> GetStoreCharactersFilterInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreCharactersCustomizationsViewInterface">();
	}
	static class IStoreCharactersCustomizationsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStoreCharactersCustomizationsViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IStoreCharactersCustomizationsViewInterface) == 0x000001, "Wrong alignment on IStoreCharactersCustomizationsViewInterface");
static_assert(sizeof(IStoreCharactersCustomizationsViewInterface) == 0x000001, "Wrong size on IStoreCharactersCustomizationsViewInterface");

// Class DBDUIViewInterfaces.StoreCharactersFilterViewInterface
// 0x0000 (0x0000 - 0x0000)
class IStoreCharactersFilterViewInterface final
{
public:
	void SetFiltersState(const struct FStoreCharactersFiltersData& newFiltersData);
	void SetFiltersVisibility(bool showAvailabilityFilter, bool showRarityFilters, bool showSourceFilters, bool showClearFiltersButton);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreCharactersFilterViewInterface">();
	}
	static class IStoreCharactersFilterViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStoreCharactersFilterViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IStoreCharactersFilterViewInterface) == 0x000001, "Wrong alignment on IStoreCharactersFilterViewInterface");
static_assert(sizeof(IStoreCharactersFilterViewInterface) == 0x000001, "Wrong size on IStoreCharactersFilterViewInterface");

// Class DBDUIViewInterfaces.StoreCharactersSelectionViewInterface
// 0x0000 (0x0000 - 0x0000)
class IStoreCharactersSelectionViewInterface final
{
public:
	void SetData(const struct FStoreCharactersSelectionViewData& Data);
	void SetPerksAndKillerPowerData(const TArray<class UMenuPerkViewData*>& Perks, const EPlayerRole Role, class UMenuPowerViewData* KillerPowerViewData);
	void UpdateSelectedCharacter(const int32 SelectedCharacterIndex, const bool scrollToSelection);

	TScriptInterface<class ISearchBarViewInterface> GetSearchBarViewInterface() const;
	TScriptInterface<class IStoreCharactersFilterViewInterface> GetStoreCharactersFilterInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreCharactersSelectionViewInterface">();
	}
	static class IStoreCharactersSelectionViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStoreCharactersSelectionViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IStoreCharactersSelectionViewInterface) == 0x000001, "Wrong alignment on IStoreCharactersSelectionViewInterface");
static_assert(sizeof(IStoreCharactersSelectionViewInterface) == 0x000001, "Wrong size on IStoreCharactersSelectionViewInterface");

// Class DBDUIViewInterfaces.StoreCharactersViewInterface
// 0x0000 (0x0000 - 0x0000)
class IStoreCharactersViewInterface final
{
public:
	void SetCharacterData(const class FText& CharacterName);
	void SetCharacterNameVisibility(const bool showCharacterName);

	TScriptInterface<class IStoreCharactersBioViewInterface> GetStoreCharactersBioInterface() const;
	TScriptInterface<class IStoreCharactersCustomizationsViewInterface> GetStoreCharactersCustomizationsInterface() const;
	TScriptInterface<class IStoreCharactersSelectionViewInterface> GetStoreCharactersSelectionInterface() const;
	TScriptInterface<class IWardrobeActionButtonsViewInterface> GetWardrobeActionButtonsViewInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreCharactersViewInterface">();
	}
	static class IStoreCharactersViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStoreCharactersViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IStoreCharactersViewInterface) == 0x000001, "Wrong alignment on IStoreCharactersViewInterface");
static_assert(sizeof(IStoreCharactersViewInterface) == 0x000001, "Wrong size on IStoreCharactersViewInterface");

// Class DBDUIViewInterfaces.StoreCollectionsCustomizationsViewInterface
// 0x0000 (0x0000 - 0x0000)
class IStoreCollectionsCustomizationsViewInterface final
{
public:
	TScriptInterface<class IStoreCharactersCustomizationsViewInterface> GetStoreCharactersSelectionInterface() const;
	TScriptInterface<class IWardrobeActionButtonsViewInterface> GetWardrobeActionButtonsViewInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreCollectionsCustomizationsViewInterface">();
	}
	static class IStoreCollectionsCustomizationsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStoreCollectionsCustomizationsViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IStoreCollectionsCustomizationsViewInterface) == 0x000001, "Wrong alignment on IStoreCollectionsCustomizationsViewInterface");
static_assert(sizeof(IStoreCollectionsCustomizationsViewInterface) == 0x000001, "Wrong size on IStoreCollectionsCustomizationsViewInterface");

// Class DBDUIViewInterfaces.StoreCollectionsListViewInterface
// 0x0000 (0x0000 - 0x0000)
class IStoreCollectionsListViewInterface final
{
public:
	TScriptInterface<class ISearchBarViewInterface> GetSearchBarViewInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreCollectionsListViewInterface">();
	}
	static class IStoreCollectionsListViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStoreCollectionsListViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IStoreCollectionsListViewInterface) == 0x000001, "Wrong alignment on IStoreCollectionsListViewInterface");
static_assert(sizeof(IStoreCollectionsListViewInterface) == 0x000001, "Wrong size on IStoreCollectionsListViewInterface");

// Class DBDUIViewInterfaces.StoreCollectionsViewInterface
// 0x0000 (0x0000 - 0x0000)
class IStoreCollectionsViewInterface final
{
public:
	void SetMenuState(EStoreCollectionsMenuState menuState);

	TScriptInterface<class IStoreCollectionsCustomizationsViewInterface> GetCollectionsCustomizationsInterface() const;
	TScriptInterface<class IStoreCollectionsListViewInterface> GetCollectionsListViewInterface() const;
	EStoreCollectionsMenuState GetMenuState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreCollectionsViewInterface">();
	}
	static class IStoreCollectionsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStoreCollectionsViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IStoreCollectionsViewInterface) == 0x000001, "Wrong alignment on IStoreCollectionsViewInterface");
static_assert(sizeof(IStoreCollectionsViewInterface) == 0x000001, "Wrong size on IStoreCollectionsViewInterface");

// Class DBDUIViewInterfaces.StoreCollectionViewData
// 0x0188 (0x01B8 - 0x0030)
class UStoreCollectionViewData final : public UObject
{
public:
	class FString                                 CollectionId;                                      // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayTitle;                                      // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplaySubtitle;                                   // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              LimitedAvailabilityStartDate;                      // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VisibleBeforeStartDate;                            // 0x0068(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              LimitedAvailabilityEndDate;                        // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VisibleAfterEndDate;                               // 0x0078(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SortOrder;                                         // 0x007C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftRemoteContentCacheObjectPtr       HeroImage;                                         // 0x0080(0x0070)(BlueprintVisible, BlueprintReadOnly, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFileMediaSource>        HeroVideo;                                         // 0x00F0(0x0038)(BlueprintVisible, BlueprintReadOnly, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftRemoteContentCacheObjectPtr> AdditionalImages;                                // 0x0128(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	bool                                          IsNew;                                             // 0x0138(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UStoreCustomizationItemViewData*> Items;                                            // 0x0140(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         AvailableItemsCount;                               // 0x0150(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OwnedItemsCount;                                   // 0x0154(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerFlagViewData                     DiscountTimerViewData;                             // 0x0158(0x0030)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	struct FTimerFlagViewData                     AvailabilityTimerViewData;                         // 0x0188(0x0030)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)

public:
	bool HasHeroImage() const;
	bool HasHeroVideo() const;
	bool IsCollectionActive() const;
	bool IsCollectionHidden() const;
	bool IsSpecial() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreCollectionViewData">();
	}
	static class UStoreCollectionViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreCollectionViewData>();
	}
};
static_assert(alignof(UStoreCollectionViewData) == 0x000008, "Wrong alignment on UStoreCollectionViewData");
static_assert(sizeof(UStoreCollectionViewData) == 0x0001B8, "Wrong size on UStoreCollectionViewData");
static_assert(offsetof(UStoreCollectionViewData, CollectionId) == 0x000030, "Member 'UStoreCollectionViewData::CollectionId' has a wrong offset!");
static_assert(offsetof(UStoreCollectionViewData, DisplayTitle) == 0x000040, "Member 'UStoreCollectionViewData::DisplayTitle' has a wrong offset!");
static_assert(offsetof(UStoreCollectionViewData, DisplaySubtitle) == 0x000050, "Member 'UStoreCollectionViewData::DisplaySubtitle' has a wrong offset!");
static_assert(offsetof(UStoreCollectionViewData, LimitedAvailabilityStartDate) == 0x000060, "Member 'UStoreCollectionViewData::LimitedAvailabilityStartDate' has a wrong offset!");
static_assert(offsetof(UStoreCollectionViewData, VisibleBeforeStartDate) == 0x000068, "Member 'UStoreCollectionViewData::VisibleBeforeStartDate' has a wrong offset!");
static_assert(offsetof(UStoreCollectionViewData, LimitedAvailabilityEndDate) == 0x000070, "Member 'UStoreCollectionViewData::LimitedAvailabilityEndDate' has a wrong offset!");
static_assert(offsetof(UStoreCollectionViewData, VisibleAfterEndDate) == 0x000078, "Member 'UStoreCollectionViewData::VisibleAfterEndDate' has a wrong offset!");
static_assert(offsetof(UStoreCollectionViewData, SortOrder) == 0x00007C, "Member 'UStoreCollectionViewData::SortOrder' has a wrong offset!");
static_assert(offsetof(UStoreCollectionViewData, HeroImage) == 0x000080, "Member 'UStoreCollectionViewData::HeroImage' has a wrong offset!");
static_assert(offsetof(UStoreCollectionViewData, HeroVideo) == 0x0000F0, "Member 'UStoreCollectionViewData::HeroVideo' has a wrong offset!");
static_assert(offsetof(UStoreCollectionViewData, AdditionalImages) == 0x000128, "Member 'UStoreCollectionViewData::AdditionalImages' has a wrong offset!");
static_assert(offsetof(UStoreCollectionViewData, IsNew) == 0x000138, "Member 'UStoreCollectionViewData::IsNew' has a wrong offset!");
static_assert(offsetof(UStoreCollectionViewData, Items) == 0x000140, "Member 'UStoreCollectionViewData::Items' has a wrong offset!");
static_assert(offsetof(UStoreCollectionViewData, AvailableItemsCount) == 0x000150, "Member 'UStoreCollectionViewData::AvailableItemsCount' has a wrong offset!");
static_assert(offsetof(UStoreCollectionViewData, OwnedItemsCount) == 0x000154, "Member 'UStoreCollectionViewData::OwnedItemsCount' has a wrong offset!");
static_assert(offsetof(UStoreCollectionViewData, DiscountTimerViewData) == 0x000158, "Member 'UStoreCollectionViewData::DiscountTimerViewData' has a wrong offset!");
static_assert(offsetof(UStoreCollectionViewData, AvailabilityTimerViewData) == 0x000188, "Member 'UStoreCollectionViewData::AvailabilityTimerViewData' has a wrong offset!");

// Class DBDUIViewInterfaces.StoreCustomizationItemViewData
// 0x0300 (0x0488 - 0x0188)
class UStoreCustomizationItemViewData final : public UStoreItemViewData
{
public:
	struct FCustomizationRewardViewData           CustomizationReward;                               // 0x0188(0x0240)(BlueprintVisible, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class FName                                   MirrorsId;                                         // 0x03C8(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   RarityInfoText;                                    // 0x03D8(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	bool                                          IsLocked;                                          // 0x03F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUsingSmallTemplate;                              // 0x03F1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRole                                   AssociatedRole;                                    // 0x03F2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F3[0x5];                                      // 0x03F3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              ReleaseDate;                                       // 0x03F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOutfitInfoViewData                    OutfitInfo;                                        // 0x0400(0x0048)(BlueprintVisible, BlueprintReadOnly, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class FText                                   AssociatedCharacterDisplayName;                    // 0x0448(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class FName                                   AssociatedCharacterName;                           // 0x0460(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46C[0x4];                                      // 0x046C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CategoryInfoText;                                  // 0x0470(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreCustomizationItemViewData">();
	}
	static class UStoreCustomizationItemViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreCustomizationItemViewData>();
	}
};
static_assert(alignof(UStoreCustomizationItemViewData) == 0x000008, "Wrong alignment on UStoreCustomizationItemViewData");
static_assert(sizeof(UStoreCustomizationItemViewData) == 0x000488, "Wrong size on UStoreCustomizationItemViewData");
static_assert(offsetof(UStoreCustomizationItemViewData, CustomizationReward) == 0x000188, "Member 'UStoreCustomizationItemViewData::CustomizationReward' has a wrong offset!");
static_assert(offsetof(UStoreCustomizationItemViewData, MirrorsId) == 0x0003C8, "Member 'UStoreCustomizationItemViewData::MirrorsId' has a wrong offset!");
static_assert(offsetof(UStoreCustomizationItemViewData, RarityInfoText) == 0x0003D8, "Member 'UStoreCustomizationItemViewData::RarityInfoText' has a wrong offset!");
static_assert(offsetof(UStoreCustomizationItemViewData, IsLocked) == 0x0003F0, "Member 'UStoreCustomizationItemViewData::IsLocked' has a wrong offset!");
static_assert(offsetof(UStoreCustomizationItemViewData, IsUsingSmallTemplate) == 0x0003F1, "Member 'UStoreCustomizationItemViewData::IsUsingSmallTemplate' has a wrong offset!");
static_assert(offsetof(UStoreCustomizationItemViewData, AssociatedRole) == 0x0003F2, "Member 'UStoreCustomizationItemViewData::AssociatedRole' has a wrong offset!");
static_assert(offsetof(UStoreCustomizationItemViewData, ReleaseDate) == 0x0003F8, "Member 'UStoreCustomizationItemViewData::ReleaseDate' has a wrong offset!");
static_assert(offsetof(UStoreCustomizationItemViewData, OutfitInfo) == 0x000400, "Member 'UStoreCustomizationItemViewData::OutfitInfo' has a wrong offset!");
static_assert(offsetof(UStoreCustomizationItemViewData, AssociatedCharacterDisplayName) == 0x000448, "Member 'UStoreCustomizationItemViewData::AssociatedCharacterDisplayName' has a wrong offset!");
static_assert(offsetof(UStoreCustomizationItemViewData, AssociatedCharacterName) == 0x000460, "Member 'UStoreCustomizationItemViewData::AssociatedCharacterName' has a wrong offset!");
static_assert(offsetof(UStoreCustomizationItemViewData, CategoryInfoText) == 0x000470, "Member 'UStoreCustomizationItemViewData::CategoryInfoText' has a wrong offset!");

// Class DBDUIViewInterfaces.StoreFeaturedViewInterface
// 0x0000 (0x0000 - 0x0000)
class IStoreFeaturedViewInterface final
{
public:
	void InitFeaturedCharacters(const TArray<class UStoreCharacterItemViewData*>& characterViewDataArray);
	void InitFeaturedContent(const TArray<struct FStoreContentViewData>& featuredContentViewData);
	void InitFeaturedCustomizationItems(const TArray<struct FStoreContentViewData>& viewDataArray);
	void InitMysteryBox(const struct FStoreMysteryBoxViewData& mysteryBoxViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreFeaturedViewInterface">();
	}
	static class IStoreFeaturedViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStoreFeaturedViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IStoreFeaturedViewInterface) == 0x000001, "Wrong alignment on IStoreFeaturedViewInterface");
static_assert(sizeof(IStoreFeaturedViewInterface) == 0x000001, "Wrong size on IStoreFeaturedViewInterface");

// Class DBDUIViewInterfaces.StoreMenuViewInterface
// 0x0000 (0x0000 - 0x0000)
class IStoreMenuViewInterface final
{
public:
	void HandlePageStateUpdate();
	void SetBackButtonLabel(const class FText& label);
	void SetMenuState(EStoreMenuState State);
	void SetTabEnabled(int32 Key, bool Enabled);
	void SetTabsData(const TArray<struct FTabWidgetData>& tabsData, int32 SelectedKey);
	void SetTabSelected(int32 Key);

	TScriptInterface<class IDisplayStandViewInterface> GetDisplayStandViewInterface() const;
	TScriptInterface<class IStoreCollectionsViewInterface> GetStoreCollectionsInterface() const;
	TScriptInterface<class IStoreFeaturedViewInterface> GetStoreFeaturedInterface() const;
	TScriptInterface<class IStoreCharactersViewInterface> GetStoreKillersInterface() const;
	TScriptInterface<class IStoreSpecialPacksViewInterface> GetStoreSpecialPacksInterface() const;
	TScriptInterface<class IStoreSpecialsViewInterface> GetStoreSpecialsInterface() const;
	TScriptInterface<class IStoreCharactersViewInterface> GetStoreSurvivorsInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreMenuViewInterface">();
	}
	static class IStoreMenuViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStoreMenuViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IStoreMenuViewInterface) == 0x000001, "Wrong alignment on IStoreMenuViewInterface");
static_assert(sizeof(IStoreMenuViewInterface) == 0x000001, "Wrong size on IStoreMenuViewInterface");

// Class DBDUIViewInterfaces.MysteryBoxPreviousReward
// 0x0008 (0x0038 - 0x0030)
class UMysteryBoxPreviousReward : public UObject
{
public:
	ERewardType                                   Type;                                              // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MysteryBoxPreviousReward">();
	}
	static class UMysteryBoxPreviousReward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMysteryBoxPreviousReward>();
	}
};
static_assert(alignof(UMysteryBoxPreviousReward) == 0x000008, "Wrong alignment on UMysteryBoxPreviousReward");
static_assert(sizeof(UMysteryBoxPreviousReward) == 0x000038, "Wrong size on UMysteryBoxPreviousReward");
static_assert(offsetof(UMysteryBoxPreviousReward, Type) == 0x000030, "Member 'UMysteryBoxPreviousReward::Type' has a wrong offset!");

// Class DBDUIViewInterfaces.MysteryBoxPreviousCurrencyReward
// 0x0008 (0x0040 - 0x0038)
class UMysteryBoxPreviousCurrencyReward final : public UMysteryBoxPreviousReward
{
public:
	ECurrencyType                                 Currency;                                          // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Amount;                                            // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MysteryBoxPreviousCurrencyReward">();
	}
	static class UMysteryBoxPreviousCurrencyReward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMysteryBoxPreviousCurrencyReward>();
	}
};
static_assert(alignof(UMysteryBoxPreviousCurrencyReward) == 0x000008, "Wrong alignment on UMysteryBoxPreviousCurrencyReward");
static_assert(sizeof(UMysteryBoxPreviousCurrencyReward) == 0x000040, "Wrong size on UMysteryBoxPreviousCurrencyReward");
static_assert(offsetof(UMysteryBoxPreviousCurrencyReward, Currency) == 0x000038, "Member 'UMysteryBoxPreviousCurrencyReward::Currency' has a wrong offset!");
static_assert(offsetof(UMysteryBoxPreviousCurrencyReward, Amount) == 0x00003C, "Member 'UMysteryBoxPreviousCurrencyReward::Amount' has a wrong offset!");

// Class DBDUIViewInterfaces.MysteryBoxPreviousProgressionReward
// 0x0008 (0x0040 - 0x0038)
class UMysteryBoxPreviousProgressionReward final : public UMysteryBoxPreviousReward
{
public:
	EProgressionType                              Progression;                                       // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Amount;                                            // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MysteryBoxPreviousProgressionReward">();
	}
	static class UMysteryBoxPreviousProgressionReward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMysteryBoxPreviousProgressionReward>();
	}
};
static_assert(alignof(UMysteryBoxPreviousProgressionReward) == 0x000008, "Wrong alignment on UMysteryBoxPreviousProgressionReward");
static_assert(sizeof(UMysteryBoxPreviousProgressionReward) == 0x000040, "Wrong size on UMysteryBoxPreviousProgressionReward");
static_assert(offsetof(UMysteryBoxPreviousProgressionReward, Progression) == 0x000038, "Member 'UMysteryBoxPreviousProgressionReward::Progression' has a wrong offset!");
static_assert(offsetof(UMysteryBoxPreviousProgressionReward, Amount) == 0x00003C, "Member 'UMysteryBoxPreviousProgressionReward::Amount' has a wrong offset!");

// Class DBDUIViewInterfaces.StorePackContentData
// 0x02C8 (0x02F8 - 0x0030)
class UStorePackContentData final : public UObject
{
public:
	class UStoreCharacterItemViewData*            CharacterViewData;                                 // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStoreCustomizationItemViewData*        CustomizationViewData;                             // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStoreArchivePassViewData              ArchivePassViewData;                               // 0x0040(0x0158)(Transient, NativeAccessSpecifierPublic)
	struct FStoreRiftTierViewData                 RiftTierViewData;                                  // 0x0198(0x0158)(Transient, NativeAccessSpecifierPublic)
	bool                                          HasPriority;                                       // 0x02F0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F1[0x7];                                      // 0x02F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TSoftObjectPtr<class UTexture2D> GetIconTexturePtr();

	class FName GetId() const;
	EPlayerRole GetPlayerRole() const;
	ERewardType GetRewardType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StorePackContentData">();
	}
	static class UStorePackContentData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStorePackContentData>();
	}
};
static_assert(alignof(UStorePackContentData) == 0x000008, "Wrong alignment on UStorePackContentData");
static_assert(sizeof(UStorePackContentData) == 0x0002F8, "Wrong size on UStorePackContentData");
static_assert(offsetof(UStorePackContentData, CharacterViewData) == 0x000030, "Member 'UStorePackContentData::CharacterViewData' has a wrong offset!");
static_assert(offsetof(UStorePackContentData, CustomizationViewData) == 0x000038, "Member 'UStorePackContentData::CustomizationViewData' has a wrong offset!");
static_assert(offsetof(UStorePackContentData, ArchivePassViewData) == 0x000040, "Member 'UStorePackContentData::ArchivePassViewData' has a wrong offset!");
static_assert(offsetof(UStorePackContentData, RiftTierViewData) == 0x000198, "Member 'UStorePackContentData::RiftTierViewData' has a wrong offset!");
static_assert(offsetof(UStorePackContentData, HasPriority) == 0x0002F0, "Member 'UStorePackContentData::HasPriority' has a wrong offset!");

// Class DBDUIViewInterfaces.StoreSpecialPacksDetailsViewInterface
// 0x0000 (0x0000 - 0x0000)
class IStoreSpecialPacksDetailsViewInterface final
{
public:
	void OnEnter();
	void OnLeave();
	void SetChapterPackData(class UStoreChapterPackViewData* Data);
	void SetHeritagePackData(const struct FStoreHeritagePackViewData& Data);
	void SetSpecialPackData(class UStoreSpecialPackViewData* Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreSpecialPacksDetailsViewInterface">();
	}
	static class IStoreSpecialPacksDetailsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStoreSpecialPacksDetailsViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IStoreSpecialPacksDetailsViewInterface) == 0x000001, "Wrong alignment on IStoreSpecialPacksDetailsViewInterface");
static_assert(sizeof(IStoreSpecialPacksDetailsViewInterface) == 0x000001, "Wrong size on IStoreSpecialPacksDetailsViewInterface");

// Class DBDUIViewInterfaces.StoreSpecialPacksListViewInterface
// 0x0000 (0x0000 - 0x0000)
class IStoreSpecialPacksListViewInterface final
{
public:
	void SetChapterPacksData(const TArray<class UStoreChapterPackViewData*>& Data);
	void SetHeritagePacksData(const TArray<struct FStoreHeritagePackViewData>& Data);
	void SetSpecialPacksData(const TArray<class UStoreSpecialPackViewData*>& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreSpecialPacksListViewInterface">();
	}
	static class IStoreSpecialPacksListViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStoreSpecialPacksListViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IStoreSpecialPacksListViewInterface) == 0x000001, "Wrong alignment on IStoreSpecialPacksListViewInterface");
static_assert(sizeof(IStoreSpecialPacksListViewInterface) == 0x000001, "Wrong size on IStoreSpecialPacksListViewInterface");

// Class DBDUIViewInterfaces.StoreSpecialPacksViewInterface
// 0x0000 (0x0000 - 0x0000)
class IStoreSpecialPacksViewInterface final
{
public:
	bool IsAnimating();
	void SetScreenState(EStoreSpecialPacksScreenState State, bool shouldAnimate);

	TScriptInterface<class IStoreSpecialPacksDetailsViewInterface> GetDetailsInterface() const;
	TScriptInterface<class IStoreSpecialPacksListViewInterface> GetTabChaptersInterface() const;
	TScriptInterface<class IStoreSpecialPacksListViewInterface> GetTabHeritageInterface() const;
	TScriptInterface<class IStoreSpecialPacksListViewInterface> GetTabSpecialsInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreSpecialPacksViewInterface">();
	}
	static class IStoreSpecialPacksViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStoreSpecialPacksViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IStoreSpecialPacksViewInterface) == 0x000001, "Wrong alignment on IStoreSpecialPacksViewInterface");
static_assert(sizeof(IStoreSpecialPacksViewInterface) == 0x000001, "Wrong size on IStoreSpecialPacksViewInterface");

// Class DBDUIViewInterfaces.StoreSpecialPackViewData
// 0x0428 (0x0458 - 0x0030)
class UStoreSpecialPackViewData final : public UObject
{
public:
	class FString                                 ID;                                                // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayTitle;                                      // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   FullDescription;                                   // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	struct FSoftRemoteContentCacheObjectPtr       PackImage;                                         // 0x0068(0x0070)(BlueprintVisible, BlueprintReadOnly, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPriceTagViewData                      PriceTagData;                                      // 0x00D8(0x0050)(BlueprintVisible, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	TArray<class UStorePackContentData*>          SortedContent;                                     // 0x0128(0x0010)(BlueprintVisible, ZeroConstructor, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	TArray<class UStoreCharacterItemViewData*>    CharactersData;                                    // 0x0138(0x0010)(BlueprintVisible, ZeroConstructor, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	TArray<class UStoreCustomizationItemViewData*> CustomizationsData;                               // 0x0148(0x0010)(BlueprintVisible, ZeroConstructor, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	struct FStoreArchivePassViewData              ArchivePassData;                                   // 0x0158(0x0158)(BlueprintVisible, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	struct FStoreRiftTierViewData                 ArchiveFragmentData;                               // 0x02B0(0x0158)(BlueprintVisible, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	struct FTimerFlagViewData                     TimerViewData;                                     // 0x0408(0x0030)(BlueprintVisible, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	struct FDateTime                              ActivationStartDate;                               // 0x0438(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ActivationEndDate;                                 // 0x0440(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortOrder;                                         // 0x0448(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNew;                                             // 0x044C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOwned;                                           // 0x044D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCompositionForPackImage;                        // 0x044E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44F[0x1];                                      // 0x044F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PackImageCompositionNumberOfItems;                 // 0x0450(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_454[0x4];                                      // 0x0454(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ContainsArchivePass() const;
	bool ContainsArchivePassFragments() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreSpecialPackViewData">();
	}
	static class UStoreSpecialPackViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreSpecialPackViewData>();
	}
};
static_assert(alignof(UStoreSpecialPackViewData) == 0x000008, "Wrong alignment on UStoreSpecialPackViewData");
static_assert(sizeof(UStoreSpecialPackViewData) == 0x000458, "Wrong size on UStoreSpecialPackViewData");
static_assert(offsetof(UStoreSpecialPackViewData, ID) == 0x000030, "Member 'UStoreSpecialPackViewData::ID' has a wrong offset!");
static_assert(offsetof(UStoreSpecialPackViewData, DisplayTitle) == 0x000040, "Member 'UStoreSpecialPackViewData::DisplayTitle' has a wrong offset!");
static_assert(offsetof(UStoreSpecialPackViewData, FullDescription) == 0x000050, "Member 'UStoreSpecialPackViewData::FullDescription' has a wrong offset!");
static_assert(offsetof(UStoreSpecialPackViewData, PackImage) == 0x000068, "Member 'UStoreSpecialPackViewData::PackImage' has a wrong offset!");
static_assert(offsetof(UStoreSpecialPackViewData, PriceTagData) == 0x0000D8, "Member 'UStoreSpecialPackViewData::PriceTagData' has a wrong offset!");
static_assert(offsetof(UStoreSpecialPackViewData, SortedContent) == 0x000128, "Member 'UStoreSpecialPackViewData::SortedContent' has a wrong offset!");
static_assert(offsetof(UStoreSpecialPackViewData, CharactersData) == 0x000138, "Member 'UStoreSpecialPackViewData::CharactersData' has a wrong offset!");
static_assert(offsetof(UStoreSpecialPackViewData, CustomizationsData) == 0x000148, "Member 'UStoreSpecialPackViewData::CustomizationsData' has a wrong offset!");
static_assert(offsetof(UStoreSpecialPackViewData, ArchivePassData) == 0x000158, "Member 'UStoreSpecialPackViewData::ArchivePassData' has a wrong offset!");
static_assert(offsetof(UStoreSpecialPackViewData, ArchiveFragmentData) == 0x0002B0, "Member 'UStoreSpecialPackViewData::ArchiveFragmentData' has a wrong offset!");
static_assert(offsetof(UStoreSpecialPackViewData, TimerViewData) == 0x000408, "Member 'UStoreSpecialPackViewData::TimerViewData' has a wrong offset!");
static_assert(offsetof(UStoreSpecialPackViewData, ActivationStartDate) == 0x000438, "Member 'UStoreSpecialPackViewData::ActivationStartDate' has a wrong offset!");
static_assert(offsetof(UStoreSpecialPackViewData, ActivationEndDate) == 0x000440, "Member 'UStoreSpecialPackViewData::ActivationEndDate' has a wrong offset!");
static_assert(offsetof(UStoreSpecialPackViewData, SortOrder) == 0x000448, "Member 'UStoreSpecialPackViewData::SortOrder' has a wrong offset!");
static_assert(offsetof(UStoreSpecialPackViewData, IsNew) == 0x00044C, "Member 'UStoreSpecialPackViewData::IsNew' has a wrong offset!");
static_assert(offsetof(UStoreSpecialPackViewData, IsOwned) == 0x00044D, "Member 'UStoreSpecialPackViewData::IsOwned' has a wrong offset!");
static_assert(offsetof(UStoreSpecialPackViewData, UseCompositionForPackImage) == 0x00044E, "Member 'UStoreSpecialPackViewData::UseCompositionForPackImage' has a wrong offset!");
static_assert(offsetof(UStoreSpecialPackViewData, PackImageCompositionNumberOfItems) == 0x000450, "Member 'UStoreSpecialPackViewData::PackImageCompositionNumberOfItems' has a wrong offset!");

// Class DBDUIViewInterfaces.StoreSpecialsViewInterface
// 0x0000 (0x0000 - 0x0000)
class IStoreSpecialsViewInterface final
{
public:
	void HideAuricCellsSpecialOffer();
	void SetAuricCellsSpecialOfferData(const struct FAuricCellsBundleViewData& auricCellsSpecialOfferData, const struct FAuricCellsFirstPurchaseViewData& AuricCellsFirstPurchaseViewData);
	void SetSpecialsData(const TArray<class UStoreCustomizationItemViewData*>& specialsData, const struct FStoreArchivePassViewData& ArchivePassViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreSpecialsViewInterface">();
	}
	static class IStoreSpecialsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStoreSpecialsViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IStoreSpecialsViewInterface) == 0x000001, "Wrong alignment on IStoreSpecialsViewInterface");
static_assert(sizeof(IStoreSpecialsViewInterface) == 0x000001, "Wrong size on IStoreSpecialsViewInterface");

// Class DBDUIViewInterfaces.StoreUnlockConfirmationPopupViewData
// 0x0050 (0x0240 - 0x01F0)
class UStoreUnlockConfirmationPopupViewData final : public UGenericPopupViewData
{
public:
	struct FPriceTagViewData                      PriceTagData;                                      // 0x01F0(0x0050)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreUnlockConfirmationPopupViewData">();
	}
	static class UStoreUnlockConfirmationPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreUnlockConfirmationPopupViewData>();
	}
};
static_assert(alignof(UStoreUnlockConfirmationPopupViewData) == 0x000010, "Wrong alignment on UStoreUnlockConfirmationPopupViewData");
static_assert(sizeof(UStoreUnlockConfirmationPopupViewData) == 0x000240, "Wrong size on UStoreUnlockConfirmationPopupViewData");
static_assert(offsetof(UStoreUnlockConfirmationPopupViewData, PriceTagData) == 0x0001F0, "Member 'UStoreUnlockConfirmationPopupViewData::PriceTagData' has a wrong offset!");

// Class DBDUIViewInterfaces.StoreUnlockConfirmationPopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class IStoreUnlockConfirmationPopupViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreUnlockConfirmationPopupViewInterface">();
	}
	static class IStoreUnlockConfirmationPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStoreUnlockConfirmationPopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IStoreUnlockConfirmationPopupViewInterface) == 0x000001, "Wrong alignment on IStoreUnlockConfirmationPopupViewInterface");
static_assert(sizeof(IStoreUnlockConfirmationPopupViewInterface) == 0x000001, "Wrong size on IStoreUnlockConfirmationPopupViewInterface");

// Class DBDUIViewInterfaces.SubtitlesViewInterface
// 0x0000 (0x0000 - 0x0000)
class ISubtitlesViewInterface final
{
public:
	void HideSubtitles();
	void SetConstrainAspectRatioChanged(bool isConstrained, float AspectRatio);
	void SetSubtitlesBackgroundOpacity(ESubtitlesBackgroundOpacity Opacity);
	void SetSubtitlesPosition(ESubtitlesPosition Position);
	void SetSubtitlesSize(ESubtitlesSize Size);
	void ShowSubtitle(const class FText& SubtitleText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubtitlesViewInterface">();
	}
	static class ISubtitlesViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISubtitlesViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ISubtitlesViewInterface) == 0x000001, "Wrong alignment on ISubtitlesViewInterface");
static_assert(sizeof(ISubtitlesViewInterface) == 0x000001, "Wrong size on ISubtitlesViewInterface");

// Class DBDUIViewInterfaces.SurrenderNotificationViewInterface
// 0x0000 (0x0000 - 0x0000)
class ISurrenderNotificationViewInterface final
{
public:
	void SetData(const struct FSurrenderNotificationViewData& SurrenderNotificationViewData);
	void SetSurrenderNotificationVisibility(const bool IsVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurrenderNotificationViewInterface">();
	}
	static class ISurrenderNotificationViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISurrenderNotificationViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ISurrenderNotificationViewInterface) == 0x000001, "Wrong alignment on ISurrenderNotificationViewInterface");
static_assert(sizeof(ISurrenderNotificationViewInterface) == 0x000001, "Wrong size on ISurrenderNotificationViewInterface");

// Class DBDUIViewInterfaces.TallyMenuViewInterface
// 0x0000 (0x0000 - 0x0000)
class ITallyMenuViewInterface final
{
public:
	void SetBackgroundVisibility(bool IsVisible);
	void SetTabSelected(const ETallyTabState& tabState);

	TScriptInterface<class IChatViewInterface> GetChatInterface() const;
	TScriptInterface<class ITallyScoreboardViewInterface> GetTallyScoreboardInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TallyMenuViewInterface">();
	}
	static class ITallyMenuViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITallyMenuViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITallyMenuViewInterface) == 0x000001, "Wrong alignment on ITallyMenuViewInterface");
static_assert(sizeof(ITallyMenuViewInterface) == 0x000001, "Wrong size on ITallyMenuViewInterface");

// Class DBDUIViewInterfaces.TallyScoreboardViewInterface
// 0x0000 (0x0000 - 0x0000)
class ITallyScoreboardViewInterface final
{
public:
	void SetKillerLoadoutBlocked(const bool IsBlocked);
	void SetPlayerCardAnimationMode(const EPlayerCardAnimationMode PlayerCardAnimationMode);
	void SetTallyPlayerStatusWidgets(const EGameType gameType);
	void SetTallyScoreboardData(const TArray<struct FTallyPlayerStatusViewData>& tallyPlayerStatus, EGameType gameType, bool isUsingCharacterClass);
	void ShowOptionsMenu(const TArray<struct FPlayerSocialOptionViewData>& playerOptionsData);
	void UpdateReportedPlayer(const class FString& MirrorsId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TallyScoreboardViewInterface">();
	}
	static class ITallyScoreboardViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITallyScoreboardViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITallyScoreboardViewInterface) == 0x000001, "Wrong alignment on ITallyScoreboardViewInterface");
static_assert(sizeof(ITallyScoreboardViewInterface) == 0x000001, "Wrong size on ITallyScoreboardViewInterface");

// Class DBDUIViewInterfaces.TemplateViewInterface
// 0x0000 (0x0000 - 0x0000)
class ITemplateViewInterface final
{
public:
	void TemplateExampleFunction(const struct FTemplateViewData& templateData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TemplateViewInterface">();
	}
	static class ITemplateViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITemplateViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITemplateViewInterface) == 0x000001, "Wrong alignment on ITemplateViewInterface");
static_assert(sizeof(ITemplateViewInterface) == 0x000001, "Wrong size on ITemplateViewInterface");

// Class DBDUIViewInterfaces.TestBuildFlagViewInterface
// 0x0000 (0x0000 - 0x0000)
class ITestBuildFlagViewInterface final
{
public:
	void UpdateWidget(ETestBuildType testBuildType, ETestBuildFlagPosition testBuildFlagPosition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestBuildFlagViewInterface">();
	}
	static class ITestBuildFlagViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITestBuildFlagViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITestBuildFlagViewInterface) == 0x000001, "Wrong alignment on ITestBuildFlagViewInterface");
static_assert(sizeof(ITestBuildFlagViewInterface) == 0x000001, "Wrong size on ITestBuildFlagViewInterface");

// Class DBDUIViewInterfaces.TimedEffectMeterViewInterface
// 0x0000 (0x0000 - 0x0000)
class ITimedEffectMeterViewInterface final
{
public:
	void Reset();
	void SetProgress(const float Progress);
	void SetState(const ETimedEffectMeterState newState, bool force);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimedEffectMeterViewInterface">();
	}
	static class ITimedEffectMeterViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITimedEffectMeterViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITimedEffectMeterViewInterface) == 0x000001, "Wrong alignment on ITimedEffectMeterViewInterface");
static_assert(sizeof(ITimedEffectMeterViewInterface) == 0x000001, "Wrong size on ITimedEffectMeterViewInterface");

// Class DBDUIViewInterfaces.ToastNotificationContainerViewInterface
// 0x0000 (0x0000 - 0x0000)
class IToastNotificationContainerViewInterface final
{
public:
	void AddToastNotification(const struct FToastNotificationViewData& toastData);
	void RemoveToastNotification(const int32 notificationId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ToastNotificationContainerViewInterface">();
	}
	static class IToastNotificationContainerViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IToastNotificationContainerViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IToastNotificationContainerViewInterface) == 0x000001, "Wrong alignment on IToastNotificationContainerViewInterface");
static_assert(sizeof(IToastNotificationContainerViewInterface) == 0x000001, "Wrong size on IToastNotificationContainerViewInterface");

// Class DBDUIViewInterfaces.TutorialHighlightViewInterface
// 0x0000 (0x0000 - 0x0000)
class ITutorialHighlightViewInterface final
{
public:
	void SetTutorialHighlight(const bool Show, const EHudComponent& componentId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialHighlightViewInterface">();
	}
	static class ITutorialHighlightViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITutorialHighlightViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITutorialHighlightViewInterface) == 0x000001, "Wrong alignment on ITutorialHighlightViewInterface");
static_assert(sizeof(ITutorialHighlightViewInterface) == 0x000001, "Wrong size on ITutorialHighlightViewInterface");

// Class DBDUIViewInterfaces.TutorialMysteryNoteViewInterface
// 0x0000 (0x0000 - 0x0000)
class ITutorialMysteryNoteViewInterface final
{
public:
	void HideMysteryNote();
	void ShowMysteryNote(const struct FNotifTutorialPopupViewData& notifData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialMysteryNoteViewInterface">();
	}
	static class ITutorialMysteryNoteViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITutorialMysteryNoteViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITutorialMysteryNoteViewInterface) == 0x000001, "Wrong alignment on ITutorialMysteryNoteViewInterface");
static_assert(sizeof(ITutorialMysteryNoteViewInterface) == 0x000001, "Wrong size on ITutorialMysteryNoteViewInterface");

// Class DBDUIViewInterfaces.TutorialObjectivesViewInterface
// 0x0000 (0x0000 - 0x0000)
class ITutorialObjectivesViewInterface final
{
public:
	void AddTutorialObjective(const class FName& ID, const struct FTutorialObjectivesViewData& InteractionPromptViewData);
	void CompleteTutorialObjective(const class FName& ID, bool removeAfterCompletion);
	void RemoveAllTutorialObjectives();
	void RemoveTutorialObjective(const class FName& ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialObjectivesViewInterface">();
	}
	static class ITutorialObjectivesViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITutorialObjectivesViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITutorialObjectivesViewInterface) == 0x000001, "Wrong alignment on ITutorialObjectivesViewInterface");
static_assert(sizeof(ITutorialObjectivesViewInterface) == 0x000001, "Wrong size on ITutorialObjectivesViewInterface");

// Class DBDUIViewInterfaces.TutorialPopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class ITutorialPopupViewInterface final
{
public:
	void HideTutorialPopup(bool PlaySoundEffect);
	void ShowNotifTutorialPopup(const struct FNotifTutorialPopupViewData& notifTutoData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialPopupViewInterface">();
	}
	static class ITutorialPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITutorialPopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITutorialPopupViewInterface) == 0x000001, "Wrong alignment on ITutorialPopupViewInterface");
static_assert(sizeof(ITutorialPopupViewInterface) == 0x000001, "Wrong size on ITutorialPopupViewInterface");

// Class DBDUIViewInterfaces.UIUtilities
// 0x0000 (0x0030 - 0x0030)
class UUIUtilities final : public UBlueprintFunctionLibrary
{
public:
	static void ConvertArchiveCurrentAndMaxProgressionInPercentage(int32& outCurrentProgression, int32& outMaxProgression);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIUtilities">();
	}
	static class UUIUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIUtilities>();
	}
};
static_assert(alignof(UUIUtilities) == 0x000008, "Wrong alignment on UUIUtilities");
static_assert(sizeof(UUIUtilities) == 0x000030, "Wrong size on UUIUtilities");

// Class DBDUIViewInterfaces.UnlockPersonalPerksPopupViewData
// 0x0010 (0x0200 - 0x01F0)
class UUnlockPersonalPerksPopupViewData final : public UGenericPopupViewData
{
public:
	TArray<class UMenuPerkViewData*>              PerksData;                                         // 0x01F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnlockPersonalPerksPopupViewData">();
	}
	static class UUnlockPersonalPerksPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnlockPersonalPerksPopupViewData>();
	}
};
static_assert(alignof(UUnlockPersonalPerksPopupViewData) == 0x000010, "Wrong alignment on UUnlockPersonalPerksPopupViewData");
static_assert(sizeof(UUnlockPersonalPerksPopupViewData) == 0x000200, "Wrong size on UUnlockPersonalPerksPopupViewData");
static_assert(offsetof(UUnlockPersonalPerksPopupViewData, PerksData) == 0x0001F0, "Member 'UUnlockPersonalPerksPopupViewData::PerksData' has a wrong offset!");

// Class DBDUIViewInterfaces.UnlockPersonalPerksPopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class IUnlockPersonalPerksPopupViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnlockPersonalPerksPopupViewInterface">();
	}
	static class IUnlockPersonalPerksPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IUnlockPersonalPerksPopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IUnlockPersonalPerksPopupViewInterface) == 0x000001, "Wrong alignment on IUnlockPersonalPerksPopupViewInterface");
static_assert(sizeof(IUnlockPersonalPerksPopupViewInterface) == 0x000001, "Wrong size on IUnlockPersonalPerksPopupViewInterface");

// Class DBDUIViewInterfaces.WardrobeActionButtonsViewInterface
// 0x0000 (0x0000 - 0x0000)
class IWardrobeActionButtonsViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WardrobeActionButtonsViewInterface">();
	}
	static class IWardrobeActionButtonsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IWardrobeActionButtonsViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IWardrobeActionButtonsViewInterface) == 0x000001, "Wrong alignment on IWardrobeActionButtonsViewInterface");
static_assert(sizeof(IWardrobeActionButtonsViewInterface) == 0x000001, "Wrong size on IWardrobeActionButtonsViewInterface");

// Class DBDUIViewInterfaces.WatermarkViewInterface
// 0x0000 (0x0000 - 0x0000)
class IWatermarkViewInterface final
{
public:
	void SetSteamValuesText(const class FString& SteamName, const class FString& SteamId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WatermarkViewInterface">();
	}
	static class IWatermarkViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IWatermarkViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IWatermarkViewInterface) == 0x000001, "Wrong alignment on IWatermarkViewInterface");
static_assert(sizeof(IWatermarkViewInterface) == 0x000001, "Wrong size on IWatermarkViewInterface");

}

