#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheNightmare

#include "Basic.hpp"

#include "TheNightmare_classes.hpp"
#include "TheNightmare_parameters.hpp"


namespace SDK
{

// Function TheNightmare.CharacterDreamworldComponent.GetLocallyObservedOrLocalCharacter
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UCharacterDreamworldComponent::GetLocallyObservedOrLocalCharacter(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterDreamworldComponent", "GetLocallyObservedOrLocalCharacter");

	Params::CharacterDreamworldComponent_GetLocallyObservedOrLocalCharacter Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.CharacterDreamworldComponent.Authority_SetIsInDreamworld
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isScripted                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterDreamworldComponent::Authority_SetIsInDreamworld(bool NewValue, bool isScripted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDreamworldComponent", "Authority_SetIsInDreamworld");

	Params::CharacterDreamworldComponent_Authority_SetIsInDreamworld Parms{};

	Parms.NewValue = NewValue;
	Parms.isScripted = isScripted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.CharacterDreamworldComponent.FireWakeUpScoreEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterDreamworldComponent::FireWakeUpScoreEvent(class ADBDPlayer* Instigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDreamworldComponent", "FireWakeUpScoreEvent");

	Params::CharacterDreamworldComponent_FireWakeUpScoreEvent Parms{};

	Parms.Instigator = Instigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.CharacterDreamworldComponent.OnRep_IsInDreamworld
// (Final, Native, Private)

void UCharacterDreamworldComponent::OnRep_IsInDreamworld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDreamworldComponent", "OnRep_IsInDreamworld");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.CharacterDreamworldComponent.IsInDreamworld
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterDreamworldComponent::IsInDreamworld() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDreamworldComponent", "IsInDreamworld");

	Params::CharacterDreamworldComponent_IsInDreamworld Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.CharacterDreamworldComponent.ShouldShowVignette
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterDreamworldComponent::ShouldShowVignette() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDreamworldComponent", "ShouldShowVignette");

	Params::CharacterDreamworldComponent_ShouldShowVignette Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.SurvivorDreamworldComponent.Authority_HandleSkillCheckFailure
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    wakeUpEveryoneInteracting                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorDreamworldComponent::Authority_HandleSkillCheckFailure(bool wakeUpEveryoneInteracting, class ADBDPlayer* Instigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorDreamworldComponent", "Authority_HandleSkillCheckFailure");

	Params::SurvivorDreamworldComponent_Authority_HandleSkillCheckFailure Parms{};

	Parms.wakeUpEveryoneInteracting = wakeUpEveryoneInteracting;
	Parms.Instigator = Instigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.SurvivorDreamworldComponent.Authority_OnAttacked
// (Final, Native, Private)

void USurvivorDreamworldComponent::Authority_OnAttacked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorDreamworldComponent", "Authority_OnAttacked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.SurvivorDreamworldComponent.Authority_OnHealthStateChanged
// (Final, Native, Private)
// Parameters:
// EHealthState                            oldHealthState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHealthState                            newHealthState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorDreamworldComponent::Authority_OnHealthStateChanged(EHealthState oldHealthState, EHealthState newHealthState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorDreamworldComponent", "Authority_OnHealthStateChanged");

	Params::SurvivorDreamworldComponent_Authority_OnHealthStateChanged Parms{};

	Parms.oldHealthState = oldHealthState;
	Parms.newHealthState = newHealthState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.SurvivorDreamworldComponent.Authority_PutAsleep
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void USurvivorDreamworldComponent::Authority_PutAsleep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorDreamworldComponent", "Authority_PutAsleep");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.SurvivorDreamworldComponent.Authority_WakeUpByHookOrDying
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void USurvivorDreamworldComponent::Authority_WakeUpByHookOrDying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorDreamworldComponent", "Authority_WakeUpByHookOrDying");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.SurvivorDreamworldComponent.Authority_WakeUpByOther
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorDreamworldComponent::Authority_WakeUpByOther(class ADBDPlayer* Instigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorDreamworldComponent", "Authority_WakeUpByOther");

	Params::SurvivorDreamworldComponent_Authority_WakeUpByOther Parms{};

	Parms.Instigator = Instigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.SurvivorDreamworldComponent.Authority_WakeUpByWakerObject
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void USurvivorDreamworldComponent::Authority_WakeUpByWakerObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorDreamworldComponent", "Authority_WakeUpByWakerObject");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.SurvivorDreamworldComponent.HandleShowKillerChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    showKiller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    instantly                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorDreamworldComponent::HandleShowKillerChanged(bool showKiller, bool instantly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorDreamworldComponent", "HandleShowKillerChanged");

	Params::SurvivorDreamworldComponent_HandleShowKillerChanged Parms{};

	Parms.showKiller = showKiller;
	Parms.instantly = instantly;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.SurvivorDreamworldComponent.InitializeTunableValues
// (Final, Native, Private)
// Parameters:
// class AKiller*                          Killer                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorDreamworldComponent::InitializeTunableValues(class AKiller* Killer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorDreamworldComponent", "InitializeTunableValues");

	Params::SurvivorDreamworldComponent_InitializeTunableValues Parms{};

	Parms.Killer = Killer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.SurvivorDreamworldComponent.Local_SetShowKiller
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    showKiller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    instantly                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorDreamworldComponent::Local_SetShowKiller(bool showKiller, bool instantly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorDreamworldComponent", "Local_SetShowKiller");

	Params::SurvivorDreamworldComponent_Local_SetShowKiller Parms{};

	Parms.showKiller = showKiller;
	Parms.instantly = instantly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.SurvivorDreamworldComponent.OnRep_ShowKiller
// (Final, Native, Private)

void USurvivorDreamworldComponent::OnRep_ShowKiller()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorDreamworldComponent", "OnRep_ShowKiller");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.SurvivorDreamworldComponent.SetScriptedKillerVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    useScriptedKillerVisibility                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorDreamworldComponent::SetScriptedKillerVisibility(bool useScriptedKillerVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorDreamworldComponent", "SetScriptedKillerVisibility");

	Params::SurvivorDreamworldComponent_SetScriptedKillerVisibility Parms{};

	Parms.useScriptedKillerVisibility = useScriptedKillerVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.SurvivorDreamworldComponent.GetLinkedKiller
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AKiller*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AKiller* USurvivorDreamworldComponent::GetLinkedKiller() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorDreamworldComponent", "GetLinkedKiller");

	Params::SurvivorDreamworldComponent_GetLinkedKiller Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.DreamInducerComponent.Authority_OnLevelReadyToPlay
// (Final, Native, Private)

void UDreamInducerComponent::Authority_OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamInducerComponent", "Authority_OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.WakerObject.Cosmetic_CooldownTimeElapsed
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// float                                   timeElapsedPercent                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWakerObject::Cosmetic_CooldownTimeElapsed(float timeElapsedPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObject", "Cosmetic_CooldownTimeElapsed");

	Params::WakerObject_Cosmetic_CooldownTimeElapsed Parms{};

	Parms.timeElapsedPercent = timeElapsedPercent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.WakerObject.Cosmetic_InteractionCancelled
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void AWakerObject::Cosmetic_InteractionCancelled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObject", "Cosmetic_InteractionCancelled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TheNightmare.WakerObject.Cosmetic_OnCooldownFinished
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void AWakerObject::Cosmetic_OnCooldownFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObject", "Cosmetic_OnCooldownFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TheNightmare.WakerObject.Cosmetic_OnCooldownStarted
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void AWakerObject::Cosmetic_OnCooldownStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObject", "Cosmetic_OnCooldownStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TheNightmare.WakerObject.Cosmetic_UpdateVisibility
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// const class ADBDPlayer*                 locallyObservedPlayer                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsInDreamworld                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWakerObject::Cosmetic_UpdateVisibility(const class ADBDPlayer* locallyObservedPlayer, bool IsInDreamworld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObject", "Cosmetic_UpdateVisibility");

	Params::WakerObject_Cosmetic_UpdateVisibility Parms{};

	Parms.locallyObservedPlayer = locallyObservedPlayer;
	Parms.IsInDreamworld = IsInDreamworld;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.WakerObject.OnInteractionEntered
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWakerObject::OnInteractionEntered(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObject", "OnInteractionEntered");

	Params::WakerObject_OnInteractionEntered Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.WakerObject.OnRep_CooldownTimer
// (Final, Native, Private)

void AWakerObject::OnRep_CooldownTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObject", "OnRep_CooldownTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.WakerObject.OnRep_EscapeDreamInteraction
// (Final, Native, Private)

void AWakerObject::OnRep_EscapeDreamInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObject", "OnRep_EscapeDreamInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.WakerObject.GetChargeComplete
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AWakerObject::GetChargeComplete() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObject", "GetChargeComplete");

	Params::WakerObject_GetChargeComplete Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.WakerObject.GetInteractionPercentComplete
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AWakerObject::GetInteractionPercentComplete() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObject", "GetInteractionPercentComplete");

	Params::WakerObject_GetInteractionPercentComplete Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.WakerObject.GetInteractorPrimitiveComponent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* AWakerObject::GetInteractorPrimitiveComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObject", "GetInteractorPrimitiveComponent");

	Params::WakerObject_GetInteractorPrimitiveComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.WakerObject.GetIsInteracting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AWakerObject::GetIsInteracting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObject", "GetIsInteracting");

	Params::WakerObject_GetIsInteracting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.WakerObject.GetMesh
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* AWakerObject::GetMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObject", "GetMesh");

	Params::WakerObject_GetMesh Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function TheNightmare.WakerObjectAnimInstance.OnReappear
// (Event, Protected, BlueprintEvent)

void UWakerObjectAnimInstance::OnReappear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObjectAnimInstance", "OnReappear");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TheNightmare.WakerObjectAnimInstance.ResetReappearTimer
// (Final, Native, Private, BlueprintCallable)

void UWakerObjectAnimInstance::ResetReappearTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObjectAnimInstance", "ResetReappearTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.WakerObjectAnimInstance.GetWakerObject
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AWakerObject*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AWakerObject* UWakerObjectAnimInstance::GetWakerObject() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObjectAnimInstance", "GetWakerObject");

	Params::WakerObjectAnimInstance_GetWakerObject Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.WakerObjectAnimInstance.GetWakerObjectCharge
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWakerObjectAnimInstance::GetWakerObjectCharge() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObjectAnimInstance", "GetWakerObjectCharge");

	Params::WakerObjectAnimInstance_GetWakerObjectCharge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.WakerObjectAnimInstance.GetWakerObjectChargeComplete
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWakerObjectAnimInstance::GetWakerObjectChargeComplete() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObjectAnimInstance", "GetWakerObjectChargeComplete");

	Params::WakerObjectAnimInstance_GetWakerObjectChargeComplete Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.WakerObjectAnimInstance.GetWakerObjectStarted
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWakerObjectAnimInstance::GetWakerObjectStarted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObjectAnimInstance", "GetWakerObjectStarted");

	Params::WakerObjectAnimInstance_GetWakerObjectStarted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.BloodWarden.GetPerkLevelSpikeDurationsAtLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBloodWarden::GetPerkLevelSpikeDurationsAtLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodWarden", "GetPerkLevelSpikeDurationsAtLevel");

	Params::BloodWarden_GetPerkLevelSpikeDurationsAtLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.DreamPalletAbility.BP_Authority_RecycleDreamPallet
// (Event, Protected, BlueprintEvent)
// Parameters:
// class APallet*                          Pallet                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDreamPalletAbility::BP_Authority_RecycleDreamPallet(class APallet* Pallet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamPalletAbility", "BP_Authority_RecycleDreamPallet");

	Params::DreamPalletAbility_BP_Authority_RecycleDreamPallet Parms{};

	Parms.Pallet = Pallet;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.DreamPalletAbility.OnRep_PalletTargets
// (Final, Native, Private)

void UDreamPalletAbility::OnRep_PalletTargets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamPalletAbility", "OnRep_PalletTargets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.DreamPalletAbility.OnRep_PalletTrackers
// (Final, Native, Private)

void UDreamPalletAbility::OnRep_PalletTrackers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamPalletAbility", "OnRep_PalletTrackers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.DreamPalletAbility.Server_SetTarget
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// class UTargetableComponent*             Target                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDreamPalletAbility::Server_SetTarget(class UTargetableComponent* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamPalletAbility", "Server_SetTarget");

	Params::DreamPalletAbility_Server_SetTarget Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.DreamPalletAbilityData.GetExplosionRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDreamPalletAbilityData::GetExplosionRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamPalletAbilityData", "GetExplosionRadius");

	Params::DreamPalletAbilityData_GetExplosionRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.DreamPalletCosmeticComponent.Cosmetic_UpdateSurvivorDistanceToPallet
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDreamPalletCosmeticComponent::Cosmetic_UpdateSurvivorDistanceToPallet(float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamPalletCosmeticComponent", "Cosmetic_UpdateSurvivorDistanceToPallet");

	Params::DreamPalletCosmeticComponent_Cosmetic_UpdateSurvivorDistanceToPallet Parms{};

	Parms.Distance = Distance;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.DreamPalletCosmeticComponent.GetMaxCosmeticVisibilityDistance
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDreamPalletCosmeticComponent::GetMaxCosmeticVisibilityDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamPalletCosmeticComponent", "GetMaxCosmeticVisibilityDistance");

	Params::DreamPalletCosmeticComponent_GetMaxCosmeticVisibilityDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.DreamProjectionAbility.OnRep_TeleportTargets
// (Final, Native, Private)

void UDreamProjectionAbility::OnRep_TeleportTargets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamProjectionAbility", "OnRep_TeleportTargets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.DreamProjectionInteractionDefinition.Cosmetic_OnTeleportChargeStarted
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDreamProjectionInteractionDefinition::Cosmetic_OnTeleportChargeStarted(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamProjectionInteractionDefinition", "Cosmetic_OnTeleportChargeStarted");

	Params::DreamProjectionInteractionDefinition_Cosmetic_OnTeleportChargeStarted Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.DreamProjectionInteractionDefinition.Cosmetic_OnTeleported
// (BlueprintCosmetic, Event, Protected, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FTransform&                transformBeforeTeleport                                (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   teleportLocation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDreamProjectionInteractionDefinition::Cosmetic_OnTeleported(const struct FTransform& transformBeforeTeleport, const struct FVector& teleportLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamProjectionInteractionDefinition", "Cosmetic_OnTeleported");

	Params::DreamProjectionInteractionDefinition_Cosmetic_OnTeleported Parms{};

	Parms.transformBeforeTeleport = std::move(transformBeforeTeleport);
	Parms.teleportLocation = std::move(teleportLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.DreamProjectionInteractionDefinition.Cosmetic_OnTeleportLocationChosen
// (BlueprintCosmetic, Event, Protected, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FTransform&                Location                                               (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ASurvivor*                  TargetSurvivor                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDreamProjectionInteractionDefinition::Cosmetic_OnTeleportLocationChosen(const struct FTransform& Location, const class ASurvivor* TargetSurvivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamProjectionInteractionDefinition", "Cosmetic_OnTeleportLocationChosen");

	Params::DreamProjectionInteractionDefinition_Cosmetic_OnTeleportLocationChosen Parms{};

	Parms.Location = std::move(Location);
	Parms.TargetSurvivor = TargetSurvivor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.DreamProjectionInteractionDefinition.Cosmetic_ShowBloodSpurts
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// const class AGenerator*                 targetGenerator                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDreamProjectionInteractionDefinition::Cosmetic_ShowBloodSpurts(const class AGenerator* targetGenerator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamProjectionInteractionDefinition", "Cosmetic_ShowBloodSpurts");

	Params::DreamProjectionInteractionDefinition_Cosmetic_ShowBloodSpurts Parms{};

	Parms.targetGenerator = targetGenerator;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.DreamProjectionInteractionDefinition.Multicast_OnTeleportLocationChosen
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// const struct FTransform&                Location                                               (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     TargetActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDreamProjectionInteractionDefinition::Multicast_OnTeleportLocationChosen(const struct FTransform& Location, const class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamProjectionInteractionDefinition", "Multicast_OnTeleportLocationChosen");

	Params::DreamProjectionInteractionDefinition_Multicast_OnTeleportLocationChosen Parms{};

	Parms.Location = std::move(Location);
	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.DreamProjectionInteractionDefinition.Multicast_TeleportPlayer
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UDreamProjectionInteractionDefinition::Multicast_TeleportPlayer(const struct FVector& Location, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamProjectionInteractionDefinition", "Multicast_TeleportPlayer");

	Params::DreamProjectionInteractionDefinition_Multicast_TeleportPlayer Parms{};

	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.DreamProjectionInteractionDefinition.OnBloodSpurts
// (Final, Native, Protected)
// Parameters:
// const class AGenerator*                 targetGenerator                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDreamProjectionInteractionDefinition::OnBloodSpurts(const class AGenerator* targetGenerator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamProjectionInteractionDefinition", "OnBloodSpurts");

	Params::DreamProjectionInteractionDefinition_OnBloodSpurts Parms{};

	Parms.targetGenerator = targetGenerator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.DreamProjectionInteractionDefinition.OnRep_TeleportTarget
// (Final, Native, Private)

void UDreamProjectionInteractionDefinition::OnRep_TeleportTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamProjectionInteractionDefinition", "OnRep_TeleportTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.DreamProjectionInteractionDefinition.Server_SetTeleportTarget
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// class UTargetableComponent*             Target                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDreamProjectionInteractionDefinition::Server_SetTeleportTarget(class UTargetableComponent* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamProjectionInteractionDefinition", "Server_SetTeleportTarget");

	Params::DreamProjectionInteractionDefinition_Server_SetTeleportTarget Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.DreamProjectionInteractionDefinition.GetOwningPlayer
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UDreamProjectionInteractionDefinition::GetOwningPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamProjectionInteractionDefinition", "GetOwningPlayer");

	Params::DreamProjectionInteractionDefinition_GetOwningPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.DreamProjectionInteractionDefinition.HasTeleportFailed
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDreamProjectionInteractionDefinition::HasTeleportFailed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamProjectionInteractionDefinition", "HasTeleportFailed");

	Params::DreamProjectionInteractionDefinition_HasTeleportFailed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.DreamSnare.Authority_OnAcquiredChanged
// (Final, Native, Private)
// Parameters:
// const bool                              acquired                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADreamSnare::Authority_OnAcquiredChanged(const bool acquired)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamSnare", "Authority_OnAcquiredChanged");

	Params::DreamSnare_Authority_OnAcquiredChanged Parms{};

	Parms.acquired = acquired;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.DreamSnare.Cosmetic_DespawnSnare
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void ADreamSnare::Cosmetic_DespawnSnare()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamSnare", "Cosmetic_DespawnSnare");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TheNightmare.DreamSnare.Cosmetic_OnSurvivorTriggerDreamTrap
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADreamSnare::Cosmetic_OnSurvivorTriggerDreamTrap(class ASurvivor* Survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamSnare", "Cosmetic_OnSurvivorTriggerDreamTrap");

	Params::DreamSnare_Cosmetic_OnSurvivorTriggerDreamTrap Parms{};

	Parms.Survivor = Survivor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.DreamSnare.Cosmetic_SnareInitialized
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void ADreamSnare::Cosmetic_SnareInitialized()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamSnare", "Cosmetic_SnareInitialized");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TheNightmare.DreamSnare.Cosmetic_SpawnSnare
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void ADreamSnare::Cosmetic_SpawnSnare()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamSnare", "Cosmetic_SpawnSnare");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TheNightmare.DreamSnare.InitializeSnare
// (Final, Native, Private)

void ADreamSnare::InitializeSnare()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamSnare", "InitializeSnare");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.DreamSnare.Multicast_OnSnareTriggered
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ASurvivor*                        survivorTriggering                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADreamSnare::Multicast_OnSnareTriggered(class ASurvivor* survivorTriggering)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamSnare", "Multicast_OnSnareTriggered");

	Params::DreamSnare_Multicast_OnSnareTriggered Parms{};

	Parms.survivorTriggering = survivorTriggering;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.DreamSnare.OnRep_IsActive
// (Final, Native, Private)

void ADreamSnare::OnRep_IsActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamSnare", "OnRep_IsActive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.DreamSnare.OnRep_Velocity
// (Final, Native, Private)

void ADreamSnare::OnRep_Velocity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamSnare", "OnRep_Velocity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.DreamSnare.IsSnareStatic
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADreamSnare::IsSnareStatic() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamSnare", "IsSnareStatic");

	Params::DreamSnare_IsSnareStatic Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.DreamSnarePlacerComponent.Cosmetic_ActivateSnarePlacement
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    Activate_0                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDreamSnarePlacerComponent::Cosmetic_ActivateSnarePlacement(bool Activate_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamSnarePlacerComponent", "Cosmetic_ActivateSnarePlacement");

	Params::DreamSnarePlacerComponent_Cosmetic_ActivateSnarePlacement Parms{};

	Parms.Activate_0 = Activate_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.DreamSnarePlacerComponent.Cosmetic_UpdateSnareIndicator
// (BlueprintCosmetic, Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FTransform&                NewTransform                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDreamSnarePlacerComponent::Cosmetic_UpdateSnareIndicator(const struct FTransform& NewTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamSnarePlacerComponent", "Cosmetic_UpdateSnareIndicator");

	Params::DreamSnarePlacerComponent_Cosmetic_UpdateSnareIndicator Parms{};

	Parms.NewTransform = std::move(NewTransform);

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.EscapeDreamInteraction.GetOwningWakerObject
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AWakerObject*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AWakerObject* UEscapeDreamInteraction::GetOwningWakerObject() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDreamInteraction", "GetOwningWakerObject");

	Params::EscapeDreamInteraction_GetOwningWakerObject Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.ExplodeDreamPalletInteraction.Cosmetic_BeginExplodeDreamPallet
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// class APallet*                          Pallet                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             explosionRadius                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExplodeDreamPalletInteraction::Cosmetic_BeginExplodeDreamPallet(class APallet* Pallet, const float explosionRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExplodeDreamPalletInteraction", "Cosmetic_BeginExplodeDreamPallet");

	Params::ExplodeDreamPalletInteraction_Cosmetic_BeginExplodeDreamPallet Parms{};

	Parms.Pallet = Pallet;
	Parms.explosionRadius = explosionRadius;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.ExplodeDreamPalletInteraction.Cosmetic_CancelExplosion
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void UExplodeDreamPalletInteraction::Cosmetic_CancelExplosion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExplodeDreamPalletInteraction", "Cosmetic_CancelExplosion");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TheNightmare.ExplodeDreamPalletInteraction.Cosmetic_ExplodeDreamPallet
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// class APallet*                          Pallet                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExplodeDreamPalletInteraction::Cosmetic_ExplodeDreamPallet(class APallet* Pallet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExplodeDreamPalletInteraction", "Cosmetic_ExplodeDreamPallet");

	Params::ExplodeDreamPalletInteraction_Cosmetic_ExplodeDreamPallet Parms{};

	Parms.Pallet = Pallet;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.ExplodeDreamPalletInteraction.OnRep_ExplosionTimer
// (Final, Native, Private)

void UExplodeDreamPalletInteraction::OnRep_ExplosionTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExplodeDreamPalletInteraction", "OnRep_ExplosionTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.FireUp.GetSpeedBonusAtLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFireUp::GetSpeedBonusAtLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FireUp", "GetSpeedBonusAtLevel");

	Params::FireUp_GetSpeedBonusAtLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.GeneratorDreamworldComponent.Cosmetic_OnPlayerFailSkillCheck
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorDreamworldComponent::Cosmetic_OnPlayerFailSkillCheck(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDreamworldComponent", "Cosmetic_OnPlayerFailSkillCheck");

	Params::GeneratorDreamworldComponent_Cosmetic_OnPlayerFailSkillCheck Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.GeneratorDreamworldComponent.Cosmetic_SpawnBloodOnGenerator
// (BlueprintCosmetic, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class AGenerator*                       Generator                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FName>&              socketNames                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UGeneratorDreamworldComponent::Cosmetic_SpawnBloodOnGenerator(class AGenerator* Generator, const TArray<class FName>& socketNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDreamworldComponent", "Cosmetic_SpawnBloodOnGenerator");

	Params::GeneratorDreamworldComponent_Cosmetic_SpawnBloodOnGenerator Parms{};

	Parms.Generator = Generator;
	Parms.socketNames = std::move(socketNames);

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.GeneratorDreamworldComponent.OnRepairSkillCheckFailed
// (Final, Native, Private)
// Parameters:
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Bonus                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TriggerLoudNoise                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    hadInput                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ChargeChange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorDreamworldComponent::OnRepairSkillCheckFailed(bool Success, bool Bonus, class ADBDPlayer* Player, bool TriggerLoudNoise, bool hadInput, ESkillCheckCustomType Type, float ChargeChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDreamworldComponent", "OnRepairSkillCheckFailed");

	Params::GeneratorDreamworldComponent_OnRepairSkillCheckFailed Parms{};

	Parms.Success = Success;
	Parms.Bonus = Bonus;
	Parms.Player = Player;
	Parms.TriggerLoudNoise = TriggerLoudNoise;
	Parms.hadInput = hadInput;
	Parms.Type = Type;
	Parms.ChargeChange = ChargeChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.NightmareCheatComponent.DBD_PutSurvivorToSleep
// (Final, Exec, Native, Public, Const)
// Parameters:
// const class FString&                    PlayerId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNightmareCheatComponent::DBD_PutSurvivorToSleep(const class FString& PlayerId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NightmareCheatComponent", "DBD_PutSurvivorToSleep");

	Params::NightmareCheatComponent_DBD_PutSurvivorToSleep Parms{};

	Parms.PlayerId = std::move(PlayerId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.NightmareCheatComponent.DBD_WakeUpSurvivor
// (Final, Exec, Native, Public, Const)
// Parameters:
// const class FString&                    PlayerId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNightmareCheatComponent::DBD_WakeUpSurvivor(const class FString& PlayerId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NightmareCheatComponent", "DBD_WakeUpSurvivor");

	Params::NightmareCheatComponent_DBD_WakeUpSurvivor Parms{};

	Parms.PlayerId = std::move(PlayerId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.NightmarePowerSwitchingAbility.OnRep_IsUsingDreamPallets
// (Final, Native, Private, Const)

void UNightmarePowerSwitchingAbility::OnRep_IsUsingDreamPallets() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NightmarePowerSwitchingAbility", "OnRep_IsUsingDreamPallets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.NightmarePowerSwitchingAbility.OnRep_PowerSwitchingInteraction
// (Final, Native, Private, Const)

void UNightmarePowerSwitchingAbility::OnRep_PowerSwitchingInteraction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NightmarePowerSwitchingAbility", "OnRep_PowerSwitchingInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.NightmarePowerSwitchingInteraction.Cosmetic_OnPowerSwitch
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void UNightmarePowerSwitchingInteraction::Cosmetic_OnPowerSwitch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NightmarePowerSwitchingInteraction", "Cosmetic_OnPowerSwitch");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TheNightmare.NightmareSurvivorCosmeticHelperActor.Cosmetic_OnPlayerHitWithDreamAttack
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AKiller*                          Killer                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANightmareSurvivorCosmeticHelperActor::Cosmetic_OnPlayerHitWithDreamAttack(class ASurvivor* Survivor, class AKiller* Killer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NightmareSurvivorCosmeticHelperActor", "Cosmetic_OnPlayerHitWithDreamAttack");

	Params::NightmareSurvivorCosmeticHelperActor_Cosmetic_OnPlayerHitWithDreamAttack Parms{};

	Parms.Survivor = Survivor;
	Parms.Killer = Killer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.NightmareSurvivorCosmeticHelperActor.Cosmetic_OnPlayerHitWithDreamAttackImmune
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AKiller*                          Killer                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANightmareSurvivorCosmeticHelperActor::Cosmetic_OnPlayerHitWithDreamAttackImmune(class ASurvivor* Survivor, class AKiller* Killer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NightmareSurvivorCosmeticHelperActor", "Cosmetic_OnPlayerHitWithDreamAttackImmune");

	Params::NightmareSurvivorCosmeticHelperActor_Cosmetic_OnPlayerHitWithDreamAttackImmune Parms{};

	Parms.Survivor = Survivor;
	Parms.Killer = Killer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.NightmareSurvivorCosmeticHelperActor.Cosmetic_OnPlayerInducedSleepWithDreamAttack
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AKiller*                          Killer                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANightmareSurvivorCosmeticHelperActor::Cosmetic_OnPlayerInducedSleepWithDreamAttack(class ASurvivor* Survivor, class AKiller* Killer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NightmareSurvivorCosmeticHelperActor", "Cosmetic_OnPlayerInducedSleepWithDreamAttack");

	Params::NightmareSurvivorCosmeticHelperActor_Cosmetic_OnPlayerInducedSleepWithDreamAttack Parms{};

	Parms.Survivor = Survivor;
	Parms.Killer = Killer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.NightmareSurvivorCosmeticHelperActor.Cosmetic_ShouldShowTeleportWarning
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ShouldShow                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANightmareSurvivorCosmeticHelperActor::Cosmetic_ShouldShowTeleportWarning(bool ShouldShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NightmareSurvivorCosmeticHelperActor", "Cosmetic_ShouldShowTeleportWarning");

	Params::NightmareSurvivorCosmeticHelperActor_Cosmetic_ShouldShowTeleportWarning Parms{};

	Parms.ShouldShow = ShouldShow;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.NightmareSurvivorCosmeticHelperActor.GetDreamworldComponent
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USurvivorDreamworldComponent*     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USurvivorDreamworldComponent* ANightmareSurvivorCosmeticHelperActor::GetDreamworldComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NightmareSurvivorCosmeticHelperActor", "GetDreamworldComponent");

	Params::NightmareSurvivorCosmeticHelperActor_GetDreamworldComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.PlaceDreamPalletInteraction.Cosmetic_DespawnOldDreamPallet
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// class APallet*                          oldDreamPallet                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlaceDreamPalletInteraction::Cosmetic_DespawnOldDreamPallet(class APallet* oldDreamPallet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlaceDreamPalletInteraction", "Cosmetic_DespawnOldDreamPallet");

	Params::PlaceDreamPalletInteraction_Cosmetic_DespawnOldDreamPallet Parms{};

	Parms.oldDreamPallet = oldDreamPallet;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.RememberMe.DidLoseHealthState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AActor*                     DamagedActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   oldHealthStateCount                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URememberMe::DidLoseHealthState(const class AActor* DamagedActor, int32 oldHealthStateCount) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RememberMe", "DidLoseHealthState");

	Params::RememberMe_DidLoseHealthState Parms{};

	Parms.DamagedActor = DamagedActor;
	Parms.oldHealthStateCount = oldHealthStateCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.SetDreamSnareInteraction.Cosmetic_BeginShowSnareIndicator
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void USetDreamSnareInteraction::Cosmetic_BeginShowSnareIndicator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SetDreamSnareInteraction", "Cosmetic_BeginShowSnareIndicator");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TheNightmare.SetDreamSnareInteraction.Cosmetic_SetSnareCancelled
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void USetDreamSnareInteraction::Cosmetic_SetSnareCancelled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SetDreamSnareInteraction", "Cosmetic_SetSnareCancelled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TheNightmare.SetDreamSnareInteraction.Cosmetic_SnarePlacementFailed
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void USetDreamSnareInteraction::Cosmetic_SnarePlacementFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SetDreamSnareInteraction", "Cosmetic_SnarePlacementFailed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TheNightmare.SetDreamSnareInteraction.Cosmetic_StopShowSnareIndicator
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void USetDreamSnareInteraction::Cosmetic_StopShowSnareIndicator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SetDreamSnareInteraction", "Cosmetic_StopShowSnareIndicator");

	UObject::ProcessEvent(Func, nullptr);
}

}

