#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheK38

#include "Basic.hpp"

#include "DBDBots_classes.hpp"
#include "DBDInteraction_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "TheK38_structs.hpp"
#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "GameplayUtilities_classes.hpp"
#include "DBDAnimation_classes.hpp"
#include "DBDGameplay_structs.hpp"
#include "DBDGameplay_classes.hpp"
#include "DataTableUtilities_structs.hpp"
#include "AnimationUtilities_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "StatSystem_structs.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "DBDSharedTypes_structs.hpp"
#include "Competence_classes.hpp"
#include "DBDCompetence_classes.hpp"
#include "DBDCosmetic_classes.hpp"


namespace SDK
{

// Class TheK38.K38DogBaseState
// 0x0008 (0x0058 - 0x0050)
class UK38DogBaseState : public UBaseReplicatedState
{
public:
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38DogBaseState">();
	}
	static class UK38DogBaseState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38DogBaseState>();
	}
};
static_assert(alignof(UK38DogBaseState) == 0x000008, "Wrong alignment on UK38DogBaseState");
static_assert(sizeof(UK38DogBaseState) == 0x000058, "Wrong size on UK38DogBaseState");

// Class TheK38.K38ReturnToOwnerDogState
// 0x0018 (0x0070 - 0x0058)
class UK38ReturnToOwnerDogState final : public UK38DogBaseState
{
public:
	bool                                          _enableCharacterAvoidance;                         // 0x0058(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _minDistanceToKiller;                              // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x4];                                       // 0x0060(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _minTimeBetweenNavmeshChecks;                      // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnMoveCompleted(const struct FAIRequestID& RequestID, EPathFollowingResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38ReturnToOwnerDogState">();
	}
	static class UK38ReturnToOwnerDogState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38ReturnToOwnerDogState>();
	}
};
static_assert(alignof(UK38ReturnToOwnerDogState) == 0x000008, "Wrong alignment on UK38ReturnToOwnerDogState");
static_assert(sizeof(UK38ReturnToOwnerDogState) == 0x000070, "Wrong size on UK38ReturnToOwnerDogState");
static_assert(offsetof(UK38ReturnToOwnerDogState, _enableCharacterAvoidance) == 0x000058, "Member 'UK38ReturnToOwnerDogState::_enableCharacterAvoidance' has a wrong offset!");
static_assert(offsetof(UK38ReturnToOwnerDogState, _minDistanceToKiller) == 0x00005C, "Member 'UK38ReturnToOwnerDogState::_minDistanceToKiller' has a wrong offset!");
static_assert(offsetof(UK38ReturnToOwnerDogState, _minTimeBetweenNavmeshChecks) == 0x000064, "Member 'UK38ReturnToOwnerDogState::_minTimeBetweenNavmeshChecks' has a wrong offset!");

// Class TheK38.AISkill_Interaction_StunK38Dog
// 0x0000 (0x0280 - 0x0280)
class UAISkill_Interaction_StunK38Dog final : public UAISkill_Interaction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_StunK38Dog">();
	}
	static class UAISkill_Interaction_StunK38Dog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_StunK38Dog>();
	}
};
static_assert(alignof(UAISkill_Interaction_StunK38Dog) == 0x000008, "Wrong alignment on UAISkill_Interaction_StunK38Dog");
static_assert(sizeof(UAISkill_Interaction_StunK38Dog) == 0x000280, "Wrong size on UAISkill_Interaction_StunK38Dog");

// Class TheK38.K38StunnedDogState
// 0x00D0 (0x0128 - 0x0058)
class UK38StunnedDogState final : public UK38DogBaseState
{
public:
	struct FTunableStat                           _stunDuration;                                     // 0x0058(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _stunMontage;                                      // 0x00D8(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x30];                                      // 0x00F8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38StunnedDogState">();
	}
	static class UK38StunnedDogState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38StunnedDogState>();
	}
};
static_assert(alignof(UK38StunnedDogState) == 0x000008, "Wrong alignment on UK38StunnedDogState");
static_assert(sizeof(UK38StunnedDogState) == 0x000128, "Wrong size on UK38StunnedDogState");
static_assert(offsetof(UK38StunnedDogState, _stunDuration) == 0x000058, "Member 'UK38StunnedDogState::_stunDuration' has a wrong offset!");
static_assert(offsetof(UK38StunnedDogState, _stunMontage) == 0x0000D8, "Member 'UK38StunnedDogState::_stunMontage' has a wrong offset!");

// Class TheK38.K38DashFootprints
// 0x0008 (0x02A8 - 0x02A0)
class AK38DashFootprints final : public AActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_Hide();
	void Cosmetic_Show();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38DashFootprints">();
	}
	static class AK38DashFootprints* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK38DashFootprints>();
	}
};
static_assert(alignof(AK38DashFootprints) == 0x000008, "Wrong alignment on AK38DashFootprints");
static_assert(sizeof(AK38DashFootprints) == 0x0002A8, "Wrong size on AK38DashFootprints");

// Class TheK38.K38DashTarget
// 0x0028 (0x02C8 - 0x02A0)
class AK38DashTarget final : public AActor
{
public:
	float                                         _distanceBetweenPrints;                            // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _maxPawPrintsCount;                                // 0x02A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _spawnFootprintsActor;                             // 0x02A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A9[0x7];                                      // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AK38DashFootprints>         _footprintActorClass;                              // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AK38DashFootprints*>             _footprintPool;                                    // 0x02B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void HideFootprints();
	void HideTargetBeam();
	void HideVaultOrPallet();
	void ShowFootprints(const TArray<struct FTransform>& footprintsTransforms);
	void ShowTargetBeam(const struct FVector& Start, const struct FVector& End, EK38DogDashAimStatus aimStatus);
	void ShowVaultOrPallet(const struct FVector& vaultActorLocation, const struct FRotator& Rotation, const struct FVector& StartLocation, const struct FVector& endLocation, bool isVault, bool isPallet, int32 Count);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38DashTarget">();
	}
	static class AK38DashTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK38DashTarget>();
	}
};
static_assert(alignof(AK38DashTarget) == 0x000008, "Wrong alignment on AK38DashTarget");
static_assert(sizeof(AK38DashTarget) == 0x0002C8, "Wrong size on AK38DashTarget");
static_assert(offsetof(AK38DashTarget, _distanceBetweenPrints) == 0x0002A0, "Member 'AK38DashTarget::_distanceBetweenPrints' has a wrong offset!");
static_assert(offsetof(AK38DashTarget, _maxPawPrintsCount) == 0x0002A4, "Member 'AK38DashTarget::_maxPawPrintsCount' has a wrong offset!");
static_assert(offsetof(AK38DashTarget, _spawnFootprintsActor) == 0x0002A8, "Member 'AK38DashTarget::_spawnFootprintsActor' has a wrong offset!");
static_assert(offsetof(AK38DashTarget, _footprintActorClass) == 0x0002B0, "Member 'AK38DashTarget::_footprintActorClass' has a wrong offset!");
static_assert(offsetof(AK38DashTarget, _footprintPool) == 0x0002B8, "Member 'AK38DashTarget::_footprintPool' has a wrong offset!");

// Class TheK38.K38Addon14ScreamEffect
// 0x0068 (0x0400 - 0x0398)
class UK38Addon14ScreamEffect final : public UStatusEffect
{
public:
	uint8                                         Pad_398[0x60];                                     // 0x0398(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _screamFrequency;                                  // 0x03F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3FC[0x4];                                      // 0x03FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsScreamTimerActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38Addon14ScreamEffect">();
	}
	static class UK38Addon14ScreamEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38Addon14ScreamEffect>();
	}
};
static_assert(alignof(UK38Addon14ScreamEffect) == 0x000008, "Wrong alignment on UK38Addon14ScreamEffect");
static_assert(sizeof(UK38Addon14ScreamEffect) == 0x000400, "Wrong size on UK38Addon14ScreamEffect");
static_assert(offsetof(UK38Addon14ScreamEffect, _screamFrequency) == 0x0003F8, "Member 'UK38Addon14ScreamEffect::_screamFrequency' has a wrong offset!");

// Class TheK38.K38AimDash
// 0x0020 (0x0940 - 0x0920)
class UK38AimDash final : public UBasicChargeableInteraction
{
public:
	uint8                                         Pad_920[0x18];                                     // 0x0920(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _chargeMovementSpeedCurve;                         // 0x0938(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38AimDash">();
	}
	static class UK38AimDash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38AimDash>();
	}
};
static_assert(alignof(UK38AimDash) == 0x000010, "Wrong alignment on UK38AimDash");
static_assert(sizeof(UK38AimDash) == 0x000940, "Wrong size on UK38AimDash");
static_assert(offsetof(UK38AimDash, _chargeMovementSpeedCurve) == 0x000938, "Member 'UK38AimDash::_chargeMovementSpeedCurve' has a wrong offset!");

// Class TheK38.K38PowerWidgetPresentationComponent
// 0x0018 (0x00E8 - 0x00D0)
class UK38PowerWidgetPresentationComponent : public UPowerWidgetPresentationComponent
{
public:
	uint8                                         Pad_D0[0x18];                                      // 0x00D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38PowerWidgetPresentationComponent">();
	}
	static class UK38PowerWidgetPresentationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38PowerWidgetPresentationComponent>();
	}
};
static_assert(alignof(UK38PowerWidgetPresentationComponent) == 0x000008, "Wrong alignment on UK38PowerWidgetPresentationComponent");
static_assert(sizeof(UK38PowerWidgetPresentationComponent) == 0x0000E8, "Wrong size on UK38PowerWidgetPresentationComponent");

// Class TheK38.K38AimDashWidgetComponent
// 0x0018 (0x0100 - 0x00E8)
class UK38AimDashWidgetComponent final : public UK38PowerWidgetPresentationComponent
{
public:
	uint8                                         Pad_E8[0x18];                                      // 0x00E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38AimDashWidgetComponent">();
	}
	static class UK38AimDashWidgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38AimDashWidgetComponent>();
	}
};
static_assert(alignof(UK38AimDashWidgetComponent) == 0x000008, "Wrong alignment on UK38AimDashWidgetComponent");
static_assert(sizeof(UK38AimDashWidgetComponent) == 0x000100, "Wrong size on UK38AimDashWidgetComponent");

// Class TheK38.K38AimPatrol
// 0x0060 (0x0980 - 0x0920)
class UK38AimPatrol final : public UBasicChargeableInteraction
{
public:
	float                                         _groundTargetEaseInSeconds;                        // 0x0920(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_924[0x4C];                                     // 0x0924(0x004C)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _chargeMovementSpeedCurve;                         // 0x0970(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_978[0x8];                                      // 0x0978(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnPatrolChargeBegin();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38AimPatrol">();
	}
	static class UK38AimPatrol* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38AimPatrol>();
	}
};
static_assert(alignof(UK38AimPatrol) == 0x000010, "Wrong alignment on UK38AimPatrol");
static_assert(sizeof(UK38AimPatrol) == 0x000980, "Wrong size on UK38AimPatrol");
static_assert(offsetof(UK38AimPatrol, _groundTargetEaseInSeconds) == 0x000920, "Member 'UK38AimPatrol::_groundTargetEaseInSeconds' has a wrong offset!");
static_assert(offsetof(UK38AimPatrol, _chargeMovementSpeedCurve) == 0x000970, "Member 'UK38AimPatrol::_chargeMovementSpeedCurve' has a wrong offset!");

// Class TheK38.K38AimPatrolWidgetComponent
// 0x0000 (0x00E8 - 0x00E8)
class UK38AimPatrolWidgetComponent final : public UK38PowerWidgetPresentationComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38AimPatrolWidgetComponent">();
	}
	static class UK38AimPatrolWidgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38AimPatrolWidgetComponent>();
	}
};
static_assert(alignof(UK38AimPatrolWidgetComponent) == 0x000008, "Wrong alignment on UK38AimPatrolWidgetComponent");
static_assert(sizeof(UK38AimPatrolWidgetComponent) == 0x0000E8, "Wrong size on UK38AimPatrolWidgetComponent");

// Class TheK38.K38AnimInstance
// 0x0010 (0x0730 - 0x0720)
class UK38AnimInstance final : public UKillerAnimInstance
{
public:
	bool                                          _isChargingDash;                                   // 0x0720(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOrderingDash;                                   // 0x0721(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isChargingRedirect;                               // 0x0722(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOrderingRedirect;                               // 0x0723(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isChargingPatrol;                                 // 0x0724(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOrderingPatrol;                                 // 0x0725(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOrderingReturn;                                 // 0x0726(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOrderingPetting;                                // 0x0727(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_728[0x8];                                      // 0x0728(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38AnimInstance">();
	}
	static class UK38AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38AnimInstance>();
	}
};
static_assert(alignof(UK38AnimInstance) == 0x000010, "Wrong alignment on UK38AnimInstance");
static_assert(sizeof(UK38AnimInstance) == 0x000730, "Wrong size on UK38AnimInstance");
static_assert(offsetof(UK38AnimInstance, _isChargingDash) == 0x000720, "Member 'UK38AnimInstance::_isChargingDash' has a wrong offset!");
static_assert(offsetof(UK38AnimInstance, _isOrderingDash) == 0x000721, "Member 'UK38AnimInstance::_isOrderingDash' has a wrong offset!");
static_assert(offsetof(UK38AnimInstance, _isChargingRedirect) == 0x000722, "Member 'UK38AnimInstance::_isChargingRedirect' has a wrong offset!");
static_assert(offsetof(UK38AnimInstance, _isOrderingRedirect) == 0x000723, "Member 'UK38AnimInstance::_isOrderingRedirect' has a wrong offset!");
static_assert(offsetof(UK38AnimInstance, _isChargingPatrol) == 0x000724, "Member 'UK38AnimInstance::_isChargingPatrol' has a wrong offset!");
static_assert(offsetof(UK38AnimInstance, _isOrderingPatrol) == 0x000725, "Member 'UK38AnimInstance::_isOrderingPatrol' has a wrong offset!");
static_assert(offsetof(UK38AnimInstance, _isOrderingReturn) == 0x000726, "Member 'UK38AnimInstance::_isOrderingReturn' has a wrong offset!");
static_assert(offsetof(UK38AnimInstance, _isOrderingPetting) == 0x000727, "Member 'UK38AnimInstance::_isOrderingPetting' has a wrong offset!");

// Class TheK38.K38ApplyStatusEffectOnSurivorDetectedAddon
// 0x0020 (0x0320 - 0x0300)
class UK38ApplyStatusEffectOnSurivorDetectedAddon final : public UItemAddon
{
public:
	TSubclassOf<class UStatusEffect>              _statusEffectToSpawn;                              // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _effectLifetime;                                   // 0x0308(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30C[0x14];                                     // 0x030C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38ApplyStatusEffectOnSurivorDetectedAddon">();
	}
	static class UK38ApplyStatusEffectOnSurivorDetectedAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38ApplyStatusEffectOnSurivorDetectedAddon>();
	}
};
static_assert(alignof(UK38ApplyStatusEffectOnSurivorDetectedAddon) == 0x000008, "Wrong alignment on UK38ApplyStatusEffectOnSurivorDetectedAddon");
static_assert(sizeof(UK38ApplyStatusEffectOnSurivorDetectedAddon) == 0x000320, "Wrong size on UK38ApplyStatusEffectOnSurivorDetectedAddon");
static_assert(offsetof(UK38ApplyStatusEffectOnSurivorDetectedAddon, _statusEffectToSpawn) == 0x000300, "Member 'UK38ApplyStatusEffectOnSurivorDetectedAddon::_statusEffectToSpawn' has a wrong offset!");
static_assert(offsetof(UK38ApplyStatusEffectOnSurivorDetectedAddon, _effectLifetime) == 0x000308, "Member 'UK38ApplyStatusEffectOnSurivorDetectedAddon::_effectLifetime' has a wrong offset!");

// Class TheK38.K38AssignDogToKillerComponent
// 0x0008 (0x00C0 - 0x00B8)
class UK38AssignDogToKillerComponent final : public UActorComponent
{
public:
	TSubclassOf<class AK38Dog>                    _dogClass;                                         // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38AssignDogToKillerComponent">();
	}
	static class UK38AssignDogToKillerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38AssignDogToKillerComponent>();
	}
};
static_assert(alignof(UK38AssignDogToKillerComponent) == 0x000008, "Wrong alignment on UK38AssignDogToKillerComponent");
static_assert(sizeof(UK38AssignDogToKillerComponent) == 0x0000C0, "Wrong size on UK38AssignDogToKillerComponent");
static_assert(offsetof(UK38AssignDogToKillerComponent, _dogClass) == 0x0000B8, "Member 'UK38AssignDogToKillerComponent::_dogClass' has a wrong offset!");

// Class TheK38.K38CancelDashRedirectWidgetComponent
// 0x0000 (0x00E8 - 0x00E8)
class UK38CancelDashRedirectWidgetComponent final : public UK38PowerWidgetPresentationComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38CancelDashRedirectWidgetComponent">();
	}
	static class UK38CancelDashRedirectWidgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38CancelDashRedirectWidgetComponent>();
	}
};
static_assert(alignof(UK38CancelDashRedirectWidgetComponent) == 0x000008, "Wrong alignment on UK38CancelDashRedirectWidgetComponent");
static_assert(sizeof(UK38CancelDashRedirectWidgetComponent) == 0x0000E8, "Wrong size on UK38CancelDashRedirectWidgetComponent");

// Class TheK38.K38CheatComponent
// 0x0000 (0x00B8 - 0x00B8)
class UK38CheatComponent final : public UDLCCheatComponent
{
public:
	void DBD_K38ComeToMeDoggy(const class FString& localPlayerId) const;
	void DBD_K38DebugDogState(float timeToDisplayDebug) const;
	void DBD_K38DebugSurvivorHeldByDogPath(bool isDebugActive) const;
	void DBD_K38PlayDogMontage(class FName MontageID, float Duration, const class FString& localPlayerId) const;
	void DBD_K38TriggerDogStruggle(const class FString& localPlayerId) const;
	void DBD_K38TriggerDogTeleport(const class FString& localPlayerId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38CheatComponent">();
	}
	static class UK38CheatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38CheatComponent>();
	}
};
static_assert(alignof(UK38CheatComponent) == 0x000008, "Wrong alignment on UK38CheatComponent");
static_assert(sizeof(UK38CheatComponent) == 0x0000B8, "Wrong size on UK38CheatComponent");

// Class TheK38.K38DashDogState
// 0x0210 (0x0268 - 0x0058)
class UK38DashDogState : public UK38DogBaseState
{
public:
	struct FDBDTunableRowHandle                   _dogCollisionRadius;                               // 0x0058(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _dogCollisionRadiusDrawOffset;                     // 0x0080(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _dogMaxDashDeviationFromStraightLine;              // 0x00A8(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         _dogDashSpeedConsideredStuck;                      // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _timeStuckBeforeStopping;                          // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _dogJustVaultedTime;                               // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _perchRadiusThreshold;                             // 0x00DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0xB8];                                      // 0x00E0(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _distanceBeforeGoingToNextPathNode;                // 0x0198(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_19C[0x4];                                      // 0x019C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ASurvivor*>                      _potentialDodgedDashSurvivors;                     // 0x01A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _evadeDashScoreReductionPointThreshold;            // 0x01B0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _evadeDashScoreReductioPercentage;                 // 0x01D8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_200[0x68];                                     // 0x0200(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnProximityDashHitboxBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38DashDogState">();
	}
	static class UK38DashDogState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38DashDogState>();
	}
};
static_assert(alignof(UK38DashDogState) == 0x000008, "Wrong alignment on UK38DashDogState");
static_assert(sizeof(UK38DashDogState) == 0x000268, "Wrong size on UK38DashDogState");
static_assert(offsetof(UK38DashDogState, _dogCollisionRadius) == 0x000058, "Member 'UK38DashDogState::_dogCollisionRadius' has a wrong offset!");
static_assert(offsetof(UK38DashDogState, _dogCollisionRadiusDrawOffset) == 0x000080, "Member 'UK38DashDogState::_dogCollisionRadiusDrawOffset' has a wrong offset!");
static_assert(offsetof(UK38DashDogState, _dogMaxDashDeviationFromStraightLine) == 0x0000A8, "Member 'UK38DashDogState::_dogMaxDashDeviationFromStraightLine' has a wrong offset!");
static_assert(offsetof(UK38DashDogState, _dogDashSpeedConsideredStuck) == 0x0000D0, "Member 'UK38DashDogState::_dogDashSpeedConsideredStuck' has a wrong offset!");
static_assert(offsetof(UK38DashDogState, _timeStuckBeforeStopping) == 0x0000D4, "Member 'UK38DashDogState::_timeStuckBeforeStopping' has a wrong offset!");
static_assert(offsetof(UK38DashDogState, _dogJustVaultedTime) == 0x0000D8, "Member 'UK38DashDogState::_dogJustVaultedTime' has a wrong offset!");
static_assert(offsetof(UK38DashDogState, _perchRadiusThreshold) == 0x0000DC, "Member 'UK38DashDogState::_perchRadiusThreshold' has a wrong offset!");
static_assert(offsetof(UK38DashDogState, _distanceBeforeGoingToNextPathNode) == 0x000198, "Member 'UK38DashDogState::_distanceBeforeGoingToNextPathNode' has a wrong offset!");
static_assert(offsetof(UK38DashDogState, _potentialDodgedDashSurvivors) == 0x0001A0, "Member 'UK38DashDogState::_potentialDodgedDashSurvivors' has a wrong offset!");
static_assert(offsetof(UK38DashDogState, _evadeDashScoreReductionPointThreshold) == 0x0001B0, "Member 'UK38DashDogState::_evadeDashScoreReductionPointThreshold' has a wrong offset!");
static_assert(offsetof(UK38DashDogState, _evadeDashScoreReductioPercentage) == 0x0001D8, "Member 'UK38DashDogState::_evadeDashScoreReductioPercentage' has a wrong offset!");

// Class TheK38.K38RedirectDashDogState
// 0x0000 (0x0268 - 0x0268)
class UK38RedirectDashDogState final : public UK38DashDogState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38RedirectDashDogState">();
	}
	static class UK38RedirectDashDogState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38RedirectDashDogState>();
	}
};
static_assert(alignof(UK38RedirectDashDogState) == 0x000008, "Wrong alignment on UK38RedirectDashDogState");
static_assert(sizeof(UK38RedirectDashDogState) == 0x000268, "Wrong size on UK38RedirectDashDogState");

// Class TheK38.K38DashRedirectComponent
// 0x01F8 (0x02B0 - 0x00B8)
class alignas(0x10) UK38DashRedirectComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        _cameraSpringArmToRotate;                          // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x68];                                      // 0x00D8(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _pitchLimit;                                       // 0x0140(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _yawMultiplier;                                    // 0x0144(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pitchMultiplier;                                  // 0x0148(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxYawPerTick;                                    // 0x014C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _fadeToBlackDuration;                              // 0x0150(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _fadeToWhiteDuration;                              // 0x0154(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _cameraBlendTime;                                  // 0x0158(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _turnSmoothingTime;                                // 0x015C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_160[0x4];                                      // 0x0160(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _cameraDirectionUpdateThreshold;                   // 0x0164(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _killerInstinctEffectClass;                        // 0x0168(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class ASurvivor*, class UStatusEffect*>  _appliedStatusEffects;                             // 0x0170(0x0050)(ExportObject, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C0[0xF0];                                     // 0x01C0(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FadeToWhiteKiller(float fadeDuration);
	void OnPawnControllerSet(class APawn* Pawn, class AController* OldController, class AController* NewController);
	void Server_UpdateCurrentAimDirection(const struct FVector_NetQuantizeNormal& Direction);

	class AK38Dog* GetDog() const;
	class AKiller* GetOwningPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38DashRedirectComponent">();
	}
	static class UK38DashRedirectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38DashRedirectComponent>();
	}
};
static_assert(alignof(UK38DashRedirectComponent) == 0x000010, "Wrong alignment on UK38DashRedirectComponent");
static_assert(sizeof(UK38DashRedirectComponent) == 0x0002B0, "Wrong size on UK38DashRedirectComponent");
static_assert(offsetof(UK38DashRedirectComponent, _cameraSpringArmToRotate) == 0x0000D0, "Member 'UK38DashRedirectComponent::_cameraSpringArmToRotate' has a wrong offset!");
static_assert(offsetof(UK38DashRedirectComponent, _pitchLimit) == 0x000140, "Member 'UK38DashRedirectComponent::_pitchLimit' has a wrong offset!");
static_assert(offsetof(UK38DashRedirectComponent, _yawMultiplier) == 0x000144, "Member 'UK38DashRedirectComponent::_yawMultiplier' has a wrong offset!");
static_assert(offsetof(UK38DashRedirectComponent, _pitchMultiplier) == 0x000148, "Member 'UK38DashRedirectComponent::_pitchMultiplier' has a wrong offset!");
static_assert(offsetof(UK38DashRedirectComponent, _maxYawPerTick) == 0x00014C, "Member 'UK38DashRedirectComponent::_maxYawPerTick' has a wrong offset!");
static_assert(offsetof(UK38DashRedirectComponent, _fadeToBlackDuration) == 0x000150, "Member 'UK38DashRedirectComponent::_fadeToBlackDuration' has a wrong offset!");
static_assert(offsetof(UK38DashRedirectComponent, _fadeToWhiteDuration) == 0x000154, "Member 'UK38DashRedirectComponent::_fadeToWhiteDuration' has a wrong offset!");
static_assert(offsetof(UK38DashRedirectComponent, _cameraBlendTime) == 0x000158, "Member 'UK38DashRedirectComponent::_cameraBlendTime' has a wrong offset!");
static_assert(offsetof(UK38DashRedirectComponent, _turnSmoothingTime) == 0x00015C, "Member 'UK38DashRedirectComponent::_turnSmoothingTime' has a wrong offset!");
static_assert(offsetof(UK38DashRedirectComponent, _cameraDirectionUpdateThreshold) == 0x000164, "Member 'UK38DashRedirectComponent::_cameraDirectionUpdateThreshold' has a wrong offset!");
static_assert(offsetof(UK38DashRedirectComponent, _killerInstinctEffectClass) == 0x000168, "Member 'UK38DashRedirectComponent::_killerInstinctEffectClass' has a wrong offset!");
static_assert(offsetof(UK38DashRedirectComponent, _appliedStatusEffects) == 0x000170, "Member 'UK38DashRedirectComponent::_appliedStatusEffects' has a wrong offset!");

// Class TheK38.K38Dog
// 0x06E0 (0x0D30 - 0x0650)
class AK38Dog final : public ACharacter
{
public:
	uint8                                         Pad_650[0xE0];                                     // 0x0650(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	class UDecalComponent*                        _fakeShadowComponent;                              // 0x0730(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationMontageSlave*                 _animationFollower;                                // 0x0738(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAuthoritativeMovementComponent*        _authoritativeMovementComponent;                   // 0x0740(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayTagContainerComponent*         _objectState;                                      // 0x0748(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK38DogOutlineUpdateStrategy*           _outlineUpdateStrategy;                            // 0x0750(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK38DogStunnableComponent*              _dogStunnableComponent;                            // 0x0758(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK38DogFollowKillerComponent*           _dogFollowKillerComponent;                         // 0x0760(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK38DogTeleportComponent*               _dogTeleportComponent;                             // 0x0768(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK38DogPathPreviewComponent*            _dogPathPreviewComponent;                          // 0x0770(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChargeableComponent*                   _dogHoldingSurvivorChargeableComponent;            // 0x0778(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK38DogSurvivorDetectionComponent*      _dogSurvivorDetectionComponent;                    // 0x0780(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UK38DogSlipStreamComponent> _dogSlipStreamComponentClass;                      // 0x0788(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK38DogSlipStreamComponent*             _dogSlipStreamComponent;                           // 0x0790(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMontagePlayer*                         _montagePlayer;                                    // 0x0798(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStateController*                       _stateController;                                  // 0x07A0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDOutlineComponent*                   _outlineComponent;                                 // 0x07A8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    _dashHitbox;                                       // 0x07B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    _dashProximityHitBox;                              // 0x07B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       _redirectCamera;                                   // 0x07C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBaseGroundDetectorComponent*           _leftFootGroundDetector;                           // 0x07C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBaseGroundDetectorComponent*           _rightFootGroundDetector;                          // 0x07D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBaseGroundDetectorComponent*           _leftFrontFootGroundDetector;                      // 0x07D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBaseGroundDetectorComponent*           _rightFrontFootGroundDetector;                     // 0x07E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK38DogDangerPredictionComponent*       _dangerPredictionComponent;                        // 0x07E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAIPerceptionStimuliSourceComponent*    _perceptionStimuliComponent;                       // 0x07F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minFallHeight;                                    // 0x07F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minFallHeightToEndStruggle;                       // 0x07FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _dogStruggleFallingTestCapsuleShrink;              // 0x0800(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _closeEnoughToDashDistance;                        // 0x0804(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _projectionExtentSizeForNavMeshSearch;             // 0x0808(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _timesToIncreaseReachableRadiusSearch;             // 0x080C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAnimationMontageDescriptor            _dogLandingMontage;                                // 0x0810(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FK38DogMovementTunables                _movementTunables;                                 // 0x0830(0x0400)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         _ignoreActors;                                     // 0x0C30(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ASurvivor>               _heldSurvivor;                                     // 0x0C40(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _dogHoldingSurvivorSocketName;                     // 0x0C48(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _groundHeightOffset;                               // 0x0C54(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C58[0x18];                                     // 0x0C58(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AInteractable>              _dogInteractableClass;                             // 0x0C70(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AInteractable*                          _dogInteractable;                                  // 0x0C78(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _dogHoldingSurvivorSecondsToCharge;                // 0x0C80(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _dogHoldingSurvivorWithEnduranceSecondsToCharge;   // 0x0CA8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _forwardOffsetFromSurvivorAttachmentSocket;        // 0x0CD0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CD4[0x16];                                     // 0x0CD4(0x0016)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isDetectingSurvivor;                              // 0x0CEA(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CEB[0x5];                                      // 0x0CEB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _stateTagsToHideDog;                               // 0x0CF0(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D10[0x20];                                     // 0x0D10(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnDogMovementModeChange(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);
	void Cosmetic_BindK38Signals();
	void Cosmetic_DrawCollisionRangeCircle(const struct FVector& circleCenter, float Radius);
	void Cosmetic_DrawDetectionRangeCircle(const struct FVector& circleCenter, float Radius, bool isInPatrolIdleState);
	void Cosmetic_EndCollisionRangeCircle(const struct FVector& circleCenter, float Radius);
	void Cosmetic_OnDogInjuredSurvivorDoingInteracton(class ASurvivor* Survivor, class AK38Dog* dog, EHealthState newDamageState);
	void Cosmetic_OnDogSnapToKillerForMori();
	void Cosmetic_OnDogTeleport(EK38DogTeleportReasons Reason, bool showVFX);
	void Cosmetic_OnDogTeleportStartFade(EK38DogTeleportReasons Reason);
	void Cosmetic_OnRedirectActivated();
	void Cosmetic_OnRedirectTick(float elapsedDurationPercent);
	void Cosmetic_RedirectFadeToBlack(float fadeDuration);
	void Cosmetic_StartAimingRedirect();
	void Cosmetic_StartCollisionRangeCircle(const struct FVector& circleCenter, float Radius);
	void Cosmetic_StartDetectionRangeCircle(const struct FVector& circleCenter, float Radius, bool isInPatrolIdleState);
	void Cosmetic_StopAimingRedirect();
	void Cosmetic_StopDetectionRangeCircle(const struct FVector& circleCenter, float Radius, bool isInPatrolIdleState);
	void Multicast_CosmeticOnDogInjuredSurivor(class ASurvivor* Survivor);
	void Multicast_PlayDogMontage(bool Enable, const struct FAnimationMontageDescriptor& MontageID, float Duration, bool addFPVTag);
	void OnLevelReadyToPlay();
	void OnRep_HeldSurvivor();
	void OnStateChanged(const struct FGameplayTag& oldState, const struct FGameplayTag& newState);

	class UAkComponent* GetAudioComponent() const;
	class UBaseGroundDetectorComponent* GetLeftFootGroundDetector() const;
	class UBaseGroundDetectorComponent* GetLeftFrontFootGroundDetector() const;
	class UBaseGroundDetectorComponent* GetRightFootGroundDetector() const;
	class UBaseGroundDetectorComponent* GetRightFrontFootGroundDetector() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38Dog">();
	}
	static class AK38Dog* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK38Dog>();
	}
};
static_assert(alignof(AK38Dog) == 0x000010, "Wrong alignment on AK38Dog");
static_assert(sizeof(AK38Dog) == 0x000D30, "Wrong size on AK38Dog");
static_assert(offsetof(AK38Dog, _fakeShadowComponent) == 0x000730, "Member 'AK38Dog::_fakeShadowComponent' has a wrong offset!");
static_assert(offsetof(AK38Dog, _animationFollower) == 0x000738, "Member 'AK38Dog::_animationFollower' has a wrong offset!");
static_assert(offsetof(AK38Dog, _authoritativeMovementComponent) == 0x000740, "Member 'AK38Dog::_authoritativeMovementComponent' has a wrong offset!");
static_assert(offsetof(AK38Dog, _objectState) == 0x000748, "Member 'AK38Dog::_objectState' has a wrong offset!");
static_assert(offsetof(AK38Dog, _outlineUpdateStrategy) == 0x000750, "Member 'AK38Dog::_outlineUpdateStrategy' has a wrong offset!");
static_assert(offsetof(AK38Dog, _dogStunnableComponent) == 0x000758, "Member 'AK38Dog::_dogStunnableComponent' has a wrong offset!");
static_assert(offsetof(AK38Dog, _dogFollowKillerComponent) == 0x000760, "Member 'AK38Dog::_dogFollowKillerComponent' has a wrong offset!");
static_assert(offsetof(AK38Dog, _dogTeleportComponent) == 0x000768, "Member 'AK38Dog::_dogTeleportComponent' has a wrong offset!");
static_assert(offsetof(AK38Dog, _dogPathPreviewComponent) == 0x000770, "Member 'AK38Dog::_dogPathPreviewComponent' has a wrong offset!");
static_assert(offsetof(AK38Dog, _dogHoldingSurvivorChargeableComponent) == 0x000778, "Member 'AK38Dog::_dogHoldingSurvivorChargeableComponent' has a wrong offset!");
static_assert(offsetof(AK38Dog, _dogSurvivorDetectionComponent) == 0x000780, "Member 'AK38Dog::_dogSurvivorDetectionComponent' has a wrong offset!");
static_assert(offsetof(AK38Dog, _dogSlipStreamComponentClass) == 0x000788, "Member 'AK38Dog::_dogSlipStreamComponentClass' has a wrong offset!");
static_assert(offsetof(AK38Dog, _dogSlipStreamComponent) == 0x000790, "Member 'AK38Dog::_dogSlipStreamComponent' has a wrong offset!");
static_assert(offsetof(AK38Dog, _montagePlayer) == 0x000798, "Member 'AK38Dog::_montagePlayer' has a wrong offset!");
static_assert(offsetof(AK38Dog, _stateController) == 0x0007A0, "Member 'AK38Dog::_stateController' has a wrong offset!");
static_assert(offsetof(AK38Dog, _outlineComponent) == 0x0007A8, "Member 'AK38Dog::_outlineComponent' has a wrong offset!");
static_assert(offsetof(AK38Dog, _dashHitbox) == 0x0007B0, "Member 'AK38Dog::_dashHitbox' has a wrong offset!");
static_assert(offsetof(AK38Dog, _dashProximityHitBox) == 0x0007B8, "Member 'AK38Dog::_dashProximityHitBox' has a wrong offset!");
static_assert(offsetof(AK38Dog, _redirectCamera) == 0x0007C0, "Member 'AK38Dog::_redirectCamera' has a wrong offset!");
static_assert(offsetof(AK38Dog, _leftFootGroundDetector) == 0x0007C8, "Member 'AK38Dog::_leftFootGroundDetector' has a wrong offset!");
static_assert(offsetof(AK38Dog, _rightFootGroundDetector) == 0x0007D0, "Member 'AK38Dog::_rightFootGroundDetector' has a wrong offset!");
static_assert(offsetof(AK38Dog, _leftFrontFootGroundDetector) == 0x0007D8, "Member 'AK38Dog::_leftFrontFootGroundDetector' has a wrong offset!");
static_assert(offsetof(AK38Dog, _rightFrontFootGroundDetector) == 0x0007E0, "Member 'AK38Dog::_rightFrontFootGroundDetector' has a wrong offset!");
static_assert(offsetof(AK38Dog, _dangerPredictionComponent) == 0x0007E8, "Member 'AK38Dog::_dangerPredictionComponent' has a wrong offset!");
static_assert(offsetof(AK38Dog, _perceptionStimuliComponent) == 0x0007F0, "Member 'AK38Dog::_perceptionStimuliComponent' has a wrong offset!");
static_assert(offsetof(AK38Dog, _minFallHeight) == 0x0007F8, "Member 'AK38Dog::_minFallHeight' has a wrong offset!");
static_assert(offsetof(AK38Dog, _minFallHeightToEndStruggle) == 0x0007FC, "Member 'AK38Dog::_minFallHeightToEndStruggle' has a wrong offset!");
static_assert(offsetof(AK38Dog, _dogStruggleFallingTestCapsuleShrink) == 0x000800, "Member 'AK38Dog::_dogStruggleFallingTestCapsuleShrink' has a wrong offset!");
static_assert(offsetof(AK38Dog, _closeEnoughToDashDistance) == 0x000804, "Member 'AK38Dog::_closeEnoughToDashDistance' has a wrong offset!");
static_assert(offsetof(AK38Dog, _projectionExtentSizeForNavMeshSearch) == 0x000808, "Member 'AK38Dog::_projectionExtentSizeForNavMeshSearch' has a wrong offset!");
static_assert(offsetof(AK38Dog, _timesToIncreaseReachableRadiusSearch) == 0x00080C, "Member 'AK38Dog::_timesToIncreaseReachableRadiusSearch' has a wrong offset!");
static_assert(offsetof(AK38Dog, _dogLandingMontage) == 0x000810, "Member 'AK38Dog::_dogLandingMontage' has a wrong offset!");
static_assert(offsetof(AK38Dog, _movementTunables) == 0x000830, "Member 'AK38Dog::_movementTunables' has a wrong offset!");
static_assert(offsetof(AK38Dog, _ignoreActors) == 0x000C30, "Member 'AK38Dog::_ignoreActors' has a wrong offset!");
static_assert(offsetof(AK38Dog, _heldSurvivor) == 0x000C40, "Member 'AK38Dog::_heldSurvivor' has a wrong offset!");
static_assert(offsetof(AK38Dog, _dogHoldingSurvivorSocketName) == 0x000C48, "Member 'AK38Dog::_dogHoldingSurvivorSocketName' has a wrong offset!");
static_assert(offsetof(AK38Dog, _groundHeightOffset) == 0x000C54, "Member 'AK38Dog::_groundHeightOffset' has a wrong offset!");
static_assert(offsetof(AK38Dog, _dogInteractableClass) == 0x000C70, "Member 'AK38Dog::_dogInteractableClass' has a wrong offset!");
static_assert(offsetof(AK38Dog, _dogInteractable) == 0x000C78, "Member 'AK38Dog::_dogInteractable' has a wrong offset!");
static_assert(offsetof(AK38Dog, _dogHoldingSurvivorSecondsToCharge) == 0x000C80, "Member 'AK38Dog::_dogHoldingSurvivorSecondsToCharge' has a wrong offset!");
static_assert(offsetof(AK38Dog, _dogHoldingSurvivorWithEnduranceSecondsToCharge) == 0x000CA8, "Member 'AK38Dog::_dogHoldingSurvivorWithEnduranceSecondsToCharge' has a wrong offset!");
static_assert(offsetof(AK38Dog, _forwardOffsetFromSurvivorAttachmentSocket) == 0x000CD0, "Member 'AK38Dog::_forwardOffsetFromSurvivorAttachmentSocket' has a wrong offset!");
static_assert(offsetof(AK38Dog, _isDetectingSurvivor) == 0x000CEA, "Member 'AK38Dog::_isDetectingSurvivor' has a wrong offset!");
static_assert(offsetof(AK38Dog, _stateTagsToHideDog) == 0x000CF0, "Member 'AK38Dog::_stateTagsToHideDog' has a wrong offset!");

// Class TheK38.K38DogAnimInstance
// 0x0040 (0x03C0 - 0x0380)
class UK38DogAnimInstance final : public UDBDBaseAnimInstance
{
public:
	bool                                          _isStunned;                                        // 0x0380(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHoldingSurvivor;                                // 0x0381(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_382[0x2];                                      // 0x0382(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _animSpeed;                                        // 0x0384(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _forwardVelocity;                                  // 0x0388(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _lateralVelocity;                                  // 0x038C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _angularVelocity;                                  // 0x0390(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInFollowKillerMode;                             // 0x0394(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isFollowingInFrontOfKiller;                       // 0x0395(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isFollowingBehindKiller;                          // 0x0396(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isFollowingOnLeftOfKiller;                        // 0x0397(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isFollowingOnRightOfKiller;                       // 0x0398(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIntroCompleted;                                 // 0x0399(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIdle;                                           // 0x039A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39B[0x1];                                      // 0x039B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _idleTime;                                         // 0x039C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInAir;                                          // 0x03A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isLeaping;                                        // 0x03A1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isReturning;                                      // 0x03A2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAOLHowl;                                        // 0x03A3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOrderingDash;                                   // 0x03A4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOrderingPatrol;                                 // 0x03A5(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDashing;                                        // 0x03A6(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isRedirecting;                                    // 0x03A7(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isLiningUpToDash;                                 // 0x03A8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isRunningInFrontOfKiller;                         // 0x03A9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3AA[0x2];                                      // 0x03AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _forwardVelocityMultiplier;                        // 0x03AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isPatrolIdleWithSurvivorInRange;                  // 0x03B0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isPatrolIdleWithNoSurvivorInRange;                // 0x03B1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B2[0xE];                                      // 0x03B2(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnIntroCompleted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38DogAnimInstance">();
	}
	static class UK38DogAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38DogAnimInstance>();
	}
};
static_assert(alignof(UK38DogAnimInstance) == 0x000010, "Wrong alignment on UK38DogAnimInstance");
static_assert(sizeof(UK38DogAnimInstance) == 0x0003C0, "Wrong size on UK38DogAnimInstance");
static_assert(offsetof(UK38DogAnimInstance, _isStunned) == 0x000380, "Member 'UK38DogAnimInstance::_isStunned' has a wrong offset!");
static_assert(offsetof(UK38DogAnimInstance, _isHoldingSurvivor) == 0x000381, "Member 'UK38DogAnimInstance::_isHoldingSurvivor' has a wrong offset!");
static_assert(offsetof(UK38DogAnimInstance, _animSpeed) == 0x000384, "Member 'UK38DogAnimInstance::_animSpeed' has a wrong offset!");
static_assert(offsetof(UK38DogAnimInstance, _forwardVelocity) == 0x000388, "Member 'UK38DogAnimInstance::_forwardVelocity' has a wrong offset!");
static_assert(offsetof(UK38DogAnimInstance, _lateralVelocity) == 0x00038C, "Member 'UK38DogAnimInstance::_lateralVelocity' has a wrong offset!");
static_assert(offsetof(UK38DogAnimInstance, _angularVelocity) == 0x000390, "Member 'UK38DogAnimInstance::_angularVelocity' has a wrong offset!");
static_assert(offsetof(UK38DogAnimInstance, _isInFollowKillerMode) == 0x000394, "Member 'UK38DogAnimInstance::_isInFollowKillerMode' has a wrong offset!");
static_assert(offsetof(UK38DogAnimInstance, _isFollowingInFrontOfKiller) == 0x000395, "Member 'UK38DogAnimInstance::_isFollowingInFrontOfKiller' has a wrong offset!");
static_assert(offsetof(UK38DogAnimInstance, _isFollowingBehindKiller) == 0x000396, "Member 'UK38DogAnimInstance::_isFollowingBehindKiller' has a wrong offset!");
static_assert(offsetof(UK38DogAnimInstance, _isFollowingOnLeftOfKiller) == 0x000397, "Member 'UK38DogAnimInstance::_isFollowingOnLeftOfKiller' has a wrong offset!");
static_assert(offsetof(UK38DogAnimInstance, _isFollowingOnRightOfKiller) == 0x000398, "Member 'UK38DogAnimInstance::_isFollowingOnRightOfKiller' has a wrong offset!");
static_assert(offsetof(UK38DogAnimInstance, _isIntroCompleted) == 0x000399, "Member 'UK38DogAnimInstance::_isIntroCompleted' has a wrong offset!");
static_assert(offsetof(UK38DogAnimInstance, _isIdle) == 0x00039A, "Member 'UK38DogAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(UK38DogAnimInstance, _idleTime) == 0x00039C, "Member 'UK38DogAnimInstance::_idleTime' has a wrong offset!");
static_assert(offsetof(UK38DogAnimInstance, _isInAir) == 0x0003A0, "Member 'UK38DogAnimInstance::_isInAir' has a wrong offset!");
static_assert(offsetof(UK38DogAnimInstance, _isLeaping) == 0x0003A1, "Member 'UK38DogAnimInstance::_isLeaping' has a wrong offset!");
static_assert(offsetof(UK38DogAnimInstance, _isReturning) == 0x0003A2, "Member 'UK38DogAnimInstance::_isReturning' has a wrong offset!");
static_assert(offsetof(UK38DogAnimInstance, _isAOLHowl) == 0x0003A3, "Member 'UK38DogAnimInstance::_isAOLHowl' has a wrong offset!");
static_assert(offsetof(UK38DogAnimInstance, _isOrderingDash) == 0x0003A4, "Member 'UK38DogAnimInstance::_isOrderingDash' has a wrong offset!");
static_assert(offsetof(UK38DogAnimInstance, _isOrderingPatrol) == 0x0003A5, "Member 'UK38DogAnimInstance::_isOrderingPatrol' has a wrong offset!");
static_assert(offsetof(UK38DogAnimInstance, _isDashing) == 0x0003A6, "Member 'UK38DogAnimInstance::_isDashing' has a wrong offset!");
static_assert(offsetof(UK38DogAnimInstance, _isRedirecting) == 0x0003A7, "Member 'UK38DogAnimInstance::_isRedirecting' has a wrong offset!");
static_assert(offsetof(UK38DogAnimInstance, _isLiningUpToDash) == 0x0003A8, "Member 'UK38DogAnimInstance::_isLiningUpToDash' has a wrong offset!");
static_assert(offsetof(UK38DogAnimInstance, _isRunningInFrontOfKiller) == 0x0003A9, "Member 'UK38DogAnimInstance::_isRunningInFrontOfKiller' has a wrong offset!");
static_assert(offsetof(UK38DogAnimInstance, _forwardVelocityMultiplier) == 0x0003AC, "Member 'UK38DogAnimInstance::_forwardVelocityMultiplier' has a wrong offset!");
static_assert(offsetof(UK38DogAnimInstance, _isPatrolIdleWithSurvivorInRange) == 0x0003B0, "Member 'UK38DogAnimInstance::_isPatrolIdleWithSurvivorInRange' has a wrong offset!");
static_assert(offsetof(UK38DogAnimInstance, _isPatrolIdleWithNoSurvivorInRange) == 0x0003B1, "Member 'UK38DogAnimInstance::_isPatrolIdleWithNoSurvivorInRange' has a wrong offset!");

// Class TheK38.K38DogCompanionAbility
// 0x0418 (0x05F8 - 0x01E0)
class UK38DogCompanionAbility final : public UKillerAbilityComponent
{
public:
	uint8                                         Pad_1E0[0x8];                                      // 0x01E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTunableStat                           _dashAimInteractionCooldownTime;                   // 0x01E8(0x0080)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _patrolAimInteractionCooldownTime;                 // 0x0268(0x0080)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _dashDirectionDogIndicatorHeightOffset;            // 0x02E8(0x0028)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _dogMaxDashDeviationFromStraightLine;              // 0x0310(0x0028)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _aimCancelledPowerCooldown;                        // 0x0338(0x0028)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         _requestCanExtendDashWithShortPathSeconds;         // 0x0360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_364[0x4];                                      // 0x0364(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AK38DogNavigationDummy*                 _navigationDummy;                                  // 0x0368(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _dogSpawnOffsetFromKiller;                         // 0x0370(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _dogSpawnZOffset;                                  // 0x0374(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _downRaycastLength;                                // 0x0378(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _raycastZOffset;                                   // 0x037C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _surfaceNormalTolerance;                           // 0x0380(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _dogCapsuleRadius;                                 // 0x0384(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _dogCapsuleHalfHeight;                             // 0x0388(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxDistanceFromExpectedStartPointOnDashRequest;   // 0x038C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _cancelDashMovementSpeedCurve;                     // 0x0390(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _activationDashMovementSpeedCurve;                 // 0x0398(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _cancelPatrolMovementSpeedCurve;                   // 0x03A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _activationPatrolMovementSpeedCurve;               // 0x03A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _activateRedirectMovementSpeedCurve;               // 0x03B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _cancelRedirectMovementSpeedCurve;                 // 0x03B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDogCompanionAbilityAimMode                   _currentAimMode;                                   // 0x03C0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C1[0x7];                                      // 0x03C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UK38SwapCommand>            _swapInteractionClass;                             // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK38RedirectDash>           _redirectInteractionClass;                         // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK38RecallDog>              _recallDogClass;                                   // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK38AimDash>                _aimDashClass;                                     // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK38AimPatrol>              _aimPatrolClass;                                   // 0x03E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AK38GroundTarget>           _patrolTargetIndicatorClass;                       // 0x03F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AK38ObjectiveAimAssistTarget> _objectiveAimAssistTargetClass;                  // 0x03F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AK38DashTarget>             _dashTargetIndicatorClass;                         // 0x0400(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK38Dog*                                _dog;                                              // 0x0408(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK38GroundTarget*                       _groundTarget;                                     // 0x0410(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK38ObjectiveAimAssistTarget*           _objectiveAimAssistTarget;                         // 0x0418(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK38DashTarget*                         _dashTarget;                                       // 0x0420(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_428[0x8];                                      // 0x0428(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UK38DashRedirectComponent>  _redirectComponentClass;                           // 0x0430(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_438[0x118];                                    // 0x0438(0x0118)(Fixing Size After Last Property [ Dumper-7 ])
	class UK38DogCompanionAbilityData*            _dogAbilityData;                                   // 0x0550(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_558[0x58];                                     // 0x0558(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isLiningUpToDash;                                 // 0x05B0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B1[0x47];                                     // 0x05B1(0x0047)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_ShowDashPath(const TArray<struct FVector>& Positions);
	void Multicast_CosmeticEndRedirect(bool Success);
	void Multicast_GiveDashCommand();
	void Multicast_GivePatrolCommand(const struct FVector& targetLocation);
	void OnRep_Dog();
	void OnRep_GroundTarget();
	void Server_RequestDashCommand(const struct FVector& StartLocation, const struct FVector& Direction);
	void Server_RequestPatrolCommand(const struct FVector& targetLocation);
	void Server_RequestRedirectCommand(const struct FVector& Direction);
	void Server_RequestStopRedirectCommand();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38DogCompanionAbility">();
	}
	static class UK38DogCompanionAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38DogCompanionAbility>();
	}
};
static_assert(alignof(UK38DogCompanionAbility) == 0x000008, "Wrong alignment on UK38DogCompanionAbility");
static_assert(sizeof(UK38DogCompanionAbility) == 0x0005F8, "Wrong size on UK38DogCompanionAbility");
static_assert(offsetof(UK38DogCompanionAbility, _dashAimInteractionCooldownTime) == 0x0001E8, "Member 'UK38DogCompanionAbility::_dashAimInteractionCooldownTime' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _patrolAimInteractionCooldownTime) == 0x000268, "Member 'UK38DogCompanionAbility::_patrolAimInteractionCooldownTime' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _dashDirectionDogIndicatorHeightOffset) == 0x0002E8, "Member 'UK38DogCompanionAbility::_dashDirectionDogIndicatorHeightOffset' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _dogMaxDashDeviationFromStraightLine) == 0x000310, "Member 'UK38DogCompanionAbility::_dogMaxDashDeviationFromStraightLine' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _aimCancelledPowerCooldown) == 0x000338, "Member 'UK38DogCompanionAbility::_aimCancelledPowerCooldown' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _requestCanExtendDashWithShortPathSeconds) == 0x000360, "Member 'UK38DogCompanionAbility::_requestCanExtendDashWithShortPathSeconds' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _navigationDummy) == 0x000368, "Member 'UK38DogCompanionAbility::_navigationDummy' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _dogSpawnOffsetFromKiller) == 0x000370, "Member 'UK38DogCompanionAbility::_dogSpawnOffsetFromKiller' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _dogSpawnZOffset) == 0x000374, "Member 'UK38DogCompanionAbility::_dogSpawnZOffset' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _downRaycastLength) == 0x000378, "Member 'UK38DogCompanionAbility::_downRaycastLength' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _raycastZOffset) == 0x00037C, "Member 'UK38DogCompanionAbility::_raycastZOffset' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _surfaceNormalTolerance) == 0x000380, "Member 'UK38DogCompanionAbility::_surfaceNormalTolerance' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _dogCapsuleRadius) == 0x000384, "Member 'UK38DogCompanionAbility::_dogCapsuleRadius' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _dogCapsuleHalfHeight) == 0x000388, "Member 'UK38DogCompanionAbility::_dogCapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _maxDistanceFromExpectedStartPointOnDashRequest) == 0x00038C, "Member 'UK38DogCompanionAbility::_maxDistanceFromExpectedStartPointOnDashRequest' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _cancelDashMovementSpeedCurve) == 0x000390, "Member 'UK38DogCompanionAbility::_cancelDashMovementSpeedCurve' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _activationDashMovementSpeedCurve) == 0x000398, "Member 'UK38DogCompanionAbility::_activationDashMovementSpeedCurve' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _cancelPatrolMovementSpeedCurve) == 0x0003A0, "Member 'UK38DogCompanionAbility::_cancelPatrolMovementSpeedCurve' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _activationPatrolMovementSpeedCurve) == 0x0003A8, "Member 'UK38DogCompanionAbility::_activationPatrolMovementSpeedCurve' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _activateRedirectMovementSpeedCurve) == 0x0003B0, "Member 'UK38DogCompanionAbility::_activateRedirectMovementSpeedCurve' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _cancelRedirectMovementSpeedCurve) == 0x0003B8, "Member 'UK38DogCompanionAbility::_cancelRedirectMovementSpeedCurve' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _currentAimMode) == 0x0003C0, "Member 'UK38DogCompanionAbility::_currentAimMode' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _swapInteractionClass) == 0x0003C8, "Member 'UK38DogCompanionAbility::_swapInteractionClass' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _redirectInteractionClass) == 0x0003D0, "Member 'UK38DogCompanionAbility::_redirectInteractionClass' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _recallDogClass) == 0x0003D8, "Member 'UK38DogCompanionAbility::_recallDogClass' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _aimDashClass) == 0x0003E0, "Member 'UK38DogCompanionAbility::_aimDashClass' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _aimPatrolClass) == 0x0003E8, "Member 'UK38DogCompanionAbility::_aimPatrolClass' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _patrolTargetIndicatorClass) == 0x0003F0, "Member 'UK38DogCompanionAbility::_patrolTargetIndicatorClass' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _objectiveAimAssistTargetClass) == 0x0003F8, "Member 'UK38DogCompanionAbility::_objectiveAimAssistTargetClass' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _dashTargetIndicatorClass) == 0x000400, "Member 'UK38DogCompanionAbility::_dashTargetIndicatorClass' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _dog) == 0x000408, "Member 'UK38DogCompanionAbility::_dog' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _groundTarget) == 0x000410, "Member 'UK38DogCompanionAbility::_groundTarget' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _objectiveAimAssistTarget) == 0x000418, "Member 'UK38DogCompanionAbility::_objectiveAimAssistTarget' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _dashTarget) == 0x000420, "Member 'UK38DogCompanionAbility::_dashTarget' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _redirectComponentClass) == 0x000430, "Member 'UK38DogCompanionAbility::_redirectComponentClass' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _dogAbilityData) == 0x000550, "Member 'UK38DogCompanionAbility::_dogAbilityData' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbility, _isLiningUpToDash) == 0x0005B0, "Member 'UK38DogCompanionAbility::_isLiningUpToDash' has a wrong offset!");

// Class TheK38.K38DogCompanionAbilityData
// 0x00D0 (0x0140 - 0x0070)
class UK38DogCompanionAbilityData final : public UKillerAbilityData
{
public:
	float                                         AimPatrolChargeTime;                               // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimPatrolCancelChargeTime;                         // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CommandPatrolChargeGracePercentage;                // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimPatrolActivateChargeTime;                       // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundTargetPlacementMaxDistance;                  // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundTargetMinDistanceFromPlayer;                 // 0x0084(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundTargetMinDistanceFromPlayerForDeployment;    // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundTargetMaximumVisibilityRangeForSurvivor;     // 0x008C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DogDetectionRadiusVisibleToSurvivorRange;          // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PatrolSpeed;                                       // 0x0094(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PatrolAcceleration;                                // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PatrolBrakeDistance;                               // 0x009C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PatrolPounceSpeed;                                 // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PatrolPounceAcceleration;                          // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PatrolPounceBrakeDistance;                         // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnSpeed;                                       // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnAcceleration;                                // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnBrakeDistance;                               // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnToKillerAcceptanceRadius;                    // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FollowSpeed;                                       // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FollowAcceleration;                                // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FollowBrakeDistance;                               // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FollowKillerRunningSpeed;                          // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FollowKillerRunningAcceleration;                   // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FollowKillerRunningBrakeDistance;                  // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DogFollowDistanceWalkingBackwards;                 // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineUpDashDogFollowDistanceInFrontOfKiller;        // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DogFollowInFrontOfKillerCenterOffset;              // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineUpDashDogSpeed;                                // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineUpDashDogAcceleration;                         // 0x00E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineUpDashDogRotationMultiplier;                   // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimDashChargeTime;                                 // 0x00EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimDashCancelChargeTime;                           // 0x00F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CommandDashChargeGracePercentage;                  // 0x00F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimDashActivateChargeTime;                         // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashSpeed;                                         // 0x00FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashAcceleration;                                  // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashBrakeDistance;                                 // 0x0104(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashDistance;                                      // 0x0108(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashRedirectDistance;                              // 0x010C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVaultAngle;                                     // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RedirectGracePeriodAfterDash;                      // 0x0114(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RedirectMaxDuration;                               // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivateRedirectChargeTime;                        // 0x011C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CancelRedirectChargeTime;                          // 0x0120(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnDogTowardKillerToPetSeconds;                   // 0x0124(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DogDistanceToKillerDuringPet;                      // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AllowPettingDelaySeconds;                          // 0x012C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DogStopFollowThresholdWhileKillerTurning;          // 0x0130(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DogStopFollowThresholdWhileKillerWalking;          // 0x0134(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DogFollowAccelerationFromStopped;                  // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RedirectRangeToSurvivorsForKillerInstinct;         // 0x013C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38DogCompanionAbilityData">();
	}
	static class UK38DogCompanionAbilityData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38DogCompanionAbilityData>();
	}
};
static_assert(alignof(UK38DogCompanionAbilityData) == 0x000008, "Wrong alignment on UK38DogCompanionAbilityData");
static_assert(sizeof(UK38DogCompanionAbilityData) == 0x000140, "Wrong size on UK38DogCompanionAbilityData");
static_assert(offsetof(UK38DogCompanionAbilityData, AimPatrolChargeTime) == 0x000070, "Member 'UK38DogCompanionAbilityData::AimPatrolChargeTime' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, AimPatrolCancelChargeTime) == 0x000074, "Member 'UK38DogCompanionAbilityData::AimPatrolCancelChargeTime' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, CommandPatrolChargeGracePercentage) == 0x000078, "Member 'UK38DogCompanionAbilityData::CommandPatrolChargeGracePercentage' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, AimPatrolActivateChargeTime) == 0x00007C, "Member 'UK38DogCompanionAbilityData::AimPatrolActivateChargeTime' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, GroundTargetPlacementMaxDistance) == 0x000080, "Member 'UK38DogCompanionAbilityData::GroundTargetPlacementMaxDistance' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, GroundTargetMinDistanceFromPlayer) == 0x000084, "Member 'UK38DogCompanionAbilityData::GroundTargetMinDistanceFromPlayer' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, GroundTargetMinDistanceFromPlayerForDeployment) == 0x000088, "Member 'UK38DogCompanionAbilityData::GroundTargetMinDistanceFromPlayerForDeployment' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, GroundTargetMaximumVisibilityRangeForSurvivor) == 0x00008C, "Member 'UK38DogCompanionAbilityData::GroundTargetMaximumVisibilityRangeForSurvivor' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, DogDetectionRadiusVisibleToSurvivorRange) == 0x000090, "Member 'UK38DogCompanionAbilityData::DogDetectionRadiusVisibleToSurvivorRange' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, PatrolSpeed) == 0x000094, "Member 'UK38DogCompanionAbilityData::PatrolSpeed' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, PatrolAcceleration) == 0x000098, "Member 'UK38DogCompanionAbilityData::PatrolAcceleration' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, PatrolBrakeDistance) == 0x00009C, "Member 'UK38DogCompanionAbilityData::PatrolBrakeDistance' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, PatrolPounceSpeed) == 0x0000A0, "Member 'UK38DogCompanionAbilityData::PatrolPounceSpeed' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, PatrolPounceAcceleration) == 0x0000A4, "Member 'UK38DogCompanionAbilityData::PatrolPounceAcceleration' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, PatrolPounceBrakeDistance) == 0x0000A8, "Member 'UK38DogCompanionAbilityData::PatrolPounceBrakeDistance' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, ReturnSpeed) == 0x0000AC, "Member 'UK38DogCompanionAbilityData::ReturnSpeed' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, ReturnAcceleration) == 0x0000B0, "Member 'UK38DogCompanionAbilityData::ReturnAcceleration' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, ReturnBrakeDistance) == 0x0000B4, "Member 'UK38DogCompanionAbilityData::ReturnBrakeDistance' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, ReturnToKillerAcceptanceRadius) == 0x0000B8, "Member 'UK38DogCompanionAbilityData::ReturnToKillerAcceptanceRadius' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, FollowSpeed) == 0x0000BC, "Member 'UK38DogCompanionAbilityData::FollowSpeed' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, FollowAcceleration) == 0x0000C0, "Member 'UK38DogCompanionAbilityData::FollowAcceleration' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, FollowBrakeDistance) == 0x0000C4, "Member 'UK38DogCompanionAbilityData::FollowBrakeDistance' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, FollowKillerRunningSpeed) == 0x0000C8, "Member 'UK38DogCompanionAbilityData::FollowKillerRunningSpeed' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, FollowKillerRunningAcceleration) == 0x0000CC, "Member 'UK38DogCompanionAbilityData::FollowKillerRunningAcceleration' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, FollowKillerRunningBrakeDistance) == 0x0000D0, "Member 'UK38DogCompanionAbilityData::FollowKillerRunningBrakeDistance' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, DogFollowDistanceWalkingBackwards) == 0x0000D4, "Member 'UK38DogCompanionAbilityData::DogFollowDistanceWalkingBackwards' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, LineUpDashDogFollowDistanceInFrontOfKiller) == 0x0000D8, "Member 'UK38DogCompanionAbilityData::LineUpDashDogFollowDistanceInFrontOfKiller' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, DogFollowInFrontOfKillerCenterOffset) == 0x0000DC, "Member 'UK38DogCompanionAbilityData::DogFollowInFrontOfKillerCenterOffset' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, LineUpDashDogSpeed) == 0x0000E0, "Member 'UK38DogCompanionAbilityData::LineUpDashDogSpeed' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, LineUpDashDogAcceleration) == 0x0000E4, "Member 'UK38DogCompanionAbilityData::LineUpDashDogAcceleration' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, LineUpDashDogRotationMultiplier) == 0x0000E8, "Member 'UK38DogCompanionAbilityData::LineUpDashDogRotationMultiplier' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, AimDashChargeTime) == 0x0000EC, "Member 'UK38DogCompanionAbilityData::AimDashChargeTime' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, AimDashCancelChargeTime) == 0x0000F0, "Member 'UK38DogCompanionAbilityData::AimDashCancelChargeTime' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, CommandDashChargeGracePercentage) == 0x0000F4, "Member 'UK38DogCompanionAbilityData::CommandDashChargeGracePercentage' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, AimDashActivateChargeTime) == 0x0000F8, "Member 'UK38DogCompanionAbilityData::AimDashActivateChargeTime' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, DashSpeed) == 0x0000FC, "Member 'UK38DogCompanionAbilityData::DashSpeed' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, DashAcceleration) == 0x000100, "Member 'UK38DogCompanionAbilityData::DashAcceleration' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, DashBrakeDistance) == 0x000104, "Member 'UK38DogCompanionAbilityData::DashBrakeDistance' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, DashDistance) == 0x000108, "Member 'UK38DogCompanionAbilityData::DashDistance' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, DashRedirectDistance) == 0x00010C, "Member 'UK38DogCompanionAbilityData::DashRedirectDistance' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, MaxVaultAngle) == 0x000110, "Member 'UK38DogCompanionAbilityData::MaxVaultAngle' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, RedirectGracePeriodAfterDash) == 0x000114, "Member 'UK38DogCompanionAbilityData::RedirectGracePeriodAfterDash' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, RedirectMaxDuration) == 0x000118, "Member 'UK38DogCompanionAbilityData::RedirectMaxDuration' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, ActivateRedirectChargeTime) == 0x00011C, "Member 'UK38DogCompanionAbilityData::ActivateRedirectChargeTime' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, CancelRedirectChargeTime) == 0x000120, "Member 'UK38DogCompanionAbilityData::CancelRedirectChargeTime' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, TurnDogTowardKillerToPetSeconds) == 0x000124, "Member 'UK38DogCompanionAbilityData::TurnDogTowardKillerToPetSeconds' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, DogDistanceToKillerDuringPet) == 0x000128, "Member 'UK38DogCompanionAbilityData::DogDistanceToKillerDuringPet' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, AllowPettingDelaySeconds) == 0x00012C, "Member 'UK38DogCompanionAbilityData::AllowPettingDelaySeconds' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, DogStopFollowThresholdWhileKillerTurning) == 0x000130, "Member 'UK38DogCompanionAbilityData::DogStopFollowThresholdWhileKillerTurning' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, DogStopFollowThresholdWhileKillerWalking) == 0x000134, "Member 'UK38DogCompanionAbilityData::DogStopFollowThresholdWhileKillerWalking' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, DogFollowAccelerationFromStopped) == 0x000138, "Member 'UK38DogCompanionAbilityData::DogFollowAccelerationFromStopped' has a wrong offset!");
static_assert(offsetof(UK38DogCompanionAbilityData, RedirectRangeToSurvivorsForKillerInstinct) == 0x00013C, "Member 'UK38DogCompanionAbilityData::RedirectRangeToSurvivorsForKillerInstinct' has a wrong offset!");

// Class TheK38.K38DogController
// 0x0068 (0x0438 - 0x03D0)
class AK38DogController final : public AAIController
{
public:
	float                                         _followKillerAcceptanceRadius;                     // 0x03D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D4[0x64];                                     // 0x03D4(0x0064)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38DogController">();
	}
	static class AK38DogController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK38DogController>();
	}
};
static_assert(alignof(AK38DogController) == 0x000008, "Wrong alignment on AK38DogController");
static_assert(sizeof(AK38DogController) == 0x000438, "Wrong size on AK38DogController");
static_assert(offsetof(AK38DogController, _followKillerAcceptanceRadius) == 0x0003D0, "Member 'AK38DogController::_followKillerAcceptanceRadius' has a wrong offset!");

// Class TheK38.K38DogCrowTriggeringComponent
// 0x0000 (0x00C0 - 0x00C0)
class UK38DogCrowTriggeringComponent final : public UWorldObjectTriggeringActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38DogCrowTriggeringComponent">();
	}
	static class UK38DogCrowTriggeringComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38DogCrowTriggeringComponent>();
	}
};
static_assert(alignof(UK38DogCrowTriggeringComponent) == 0x000008, "Wrong alignment on UK38DogCrowTriggeringComponent");
static_assert(sizeof(UK38DogCrowTriggeringComponent) == 0x0000C0, "Wrong size on UK38DogCrowTriggeringComponent");

// Class TheK38.K38DogDangerPredictionComponent
// 0x0040 (0x0160 - 0x0120)
class UK38DogDangerPredictionComponent final : public UDBDDangerPredictionComponent
{
public:
	float                                         DashDodgeRange;                                    // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashRelevantRangeMargin;                           // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PatrolDangerRangeMargin;                           // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PatrolRelevantRangeMargin;                         // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PatrolAudibleRange;                                // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_134[0x2C];                                     // 0x0134(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38DogDangerPredictionComponent">();
	}
	static class UK38DogDangerPredictionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38DogDangerPredictionComponent>();
	}
};
static_assert(alignof(UK38DogDangerPredictionComponent) == 0x000008, "Wrong alignment on UK38DogDangerPredictionComponent");
static_assert(sizeof(UK38DogDangerPredictionComponent) == 0x000160, "Wrong size on UK38DogDangerPredictionComponent");
static_assert(offsetof(UK38DogDangerPredictionComponent, DashDodgeRange) == 0x000120, "Member 'UK38DogDangerPredictionComponent::DashDodgeRange' has a wrong offset!");
static_assert(offsetof(UK38DogDangerPredictionComponent, DashRelevantRangeMargin) == 0x000124, "Member 'UK38DogDangerPredictionComponent::DashRelevantRangeMargin' has a wrong offset!");
static_assert(offsetof(UK38DogDangerPredictionComponent, PatrolDangerRangeMargin) == 0x000128, "Member 'UK38DogDangerPredictionComponent::PatrolDangerRangeMargin' has a wrong offset!");
static_assert(offsetof(UK38DogDangerPredictionComponent, PatrolRelevantRangeMargin) == 0x00012C, "Member 'UK38DogDangerPredictionComponent::PatrolRelevantRangeMargin' has a wrong offset!");
static_assert(offsetof(UK38DogDangerPredictionComponent, PatrolAudibleRange) == 0x000130, "Member 'UK38DogDangerPredictionComponent::PatrolAudibleRange' has a wrong offset!");

// Class TheK38.K38DogFollowKillerComponent
// 0x0308 (0x03C0 - 0x00B8)
class UK38DogFollowKillerComponent final : public UActorComponent
{
public:
	TSubclassOf<class AActor>                     _dogFollowKillerActorClass;                        // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _requestMoveDelaySeconds;                          // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _findFloorRaycastStartHeight;                      // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _findFloorRaycastLength;                           // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _dogFollowOffsetToRightOrLeftOfKiller;             // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _dogFollowOffsetBehindKiller;                      // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _dogCloseEnoughToGoalToSlowDown;                   // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _targetFallLocationOffset;                         // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _rangeForFollowingKillerIntoFall;                  // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _dogFallTimeoutSeconds;                            // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _dogLookAtMultiplier;                              // 0x00E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _dogLookAtRotationEpsilon;                         // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _considerPettingDistance;                          // 0x00EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _dogPathCostThreshold;                             // 0x00F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _dogFollowInFrontOfKillerDistance;                 // 0x00F8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         _dogSlightlyFasterThanKillerDuringFollow;          // 0x0120(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _dogVaultExtension;                                // 0x0124(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _dogMaximumZOffsetFromKillerAfterFall;             // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _dogStuckHeightDeltaToTryFalling;                  // 0x012C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _shiftAmountWhenFollowPointBlocked;                // 0x0130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _shiftCountMax;                                    // 0x0134(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _keepDogWithKillerTimeout;                         // 0x0138(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _movingAroundObstacleTimeout;                      // 0x013C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 _dogFollowKillerActor;                             // 0x0140(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _canBePetByKiller;                                 // 0x0148(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_149[0x3B];                                     // 0x0149(0x003B)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AK38Dog>                 _dog;                                              // 0x0184(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AKiller>                 _killer;                                           // 0x018C(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_194[0xBC];                                     // 0x0194(0x00BC)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _targetFallLocation;                               // 0x0250(0x0018)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_268[0x50];                                     // 0x0268(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _targetVaultStartLocation;                         // 0x02B8(0x0018)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D0[0x68];                                     // 0x02D0(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isRunningInFrontOfKiller;                         // 0x0338(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_339[0x7F];                                     // 0x0339(0x007F)(Fixing Size After Last Property [ Dumper-7 ])
	class UK38DogCompanionAbilityData*            _dogAbilityData;                                   // 0x03B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnDogMovementModeChange(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);
	void Authority_OnKillerMovementModeChange(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);
	void Authority_OnMoveCompleted(const struct FAIRequestID& RequestID, EPathFollowingResult Result);
	void OnRep_CanBePetByKiller();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38DogFollowKillerComponent">();
	}
	static class UK38DogFollowKillerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38DogFollowKillerComponent>();
	}
};
static_assert(alignof(UK38DogFollowKillerComponent) == 0x000008, "Wrong alignment on UK38DogFollowKillerComponent");
static_assert(sizeof(UK38DogFollowKillerComponent) == 0x0003C0, "Wrong size on UK38DogFollowKillerComponent");
static_assert(offsetof(UK38DogFollowKillerComponent, _dogFollowKillerActorClass) == 0x0000B8, "Member 'UK38DogFollowKillerComponent::_dogFollowKillerActorClass' has a wrong offset!");
static_assert(offsetof(UK38DogFollowKillerComponent, _requestMoveDelaySeconds) == 0x0000C0, "Member 'UK38DogFollowKillerComponent::_requestMoveDelaySeconds' has a wrong offset!");
static_assert(offsetof(UK38DogFollowKillerComponent, _findFloorRaycastStartHeight) == 0x0000C4, "Member 'UK38DogFollowKillerComponent::_findFloorRaycastStartHeight' has a wrong offset!");
static_assert(offsetof(UK38DogFollowKillerComponent, _findFloorRaycastLength) == 0x0000C8, "Member 'UK38DogFollowKillerComponent::_findFloorRaycastLength' has a wrong offset!");
static_assert(offsetof(UK38DogFollowKillerComponent, _dogFollowOffsetToRightOrLeftOfKiller) == 0x0000CC, "Member 'UK38DogFollowKillerComponent::_dogFollowOffsetToRightOrLeftOfKiller' has a wrong offset!");
static_assert(offsetof(UK38DogFollowKillerComponent, _dogFollowOffsetBehindKiller) == 0x0000D0, "Member 'UK38DogFollowKillerComponent::_dogFollowOffsetBehindKiller' has a wrong offset!");
static_assert(offsetof(UK38DogFollowKillerComponent, _dogCloseEnoughToGoalToSlowDown) == 0x0000D4, "Member 'UK38DogFollowKillerComponent::_dogCloseEnoughToGoalToSlowDown' has a wrong offset!");
static_assert(offsetof(UK38DogFollowKillerComponent, _targetFallLocationOffset) == 0x0000D8, "Member 'UK38DogFollowKillerComponent::_targetFallLocationOffset' has a wrong offset!");
static_assert(offsetof(UK38DogFollowKillerComponent, _rangeForFollowingKillerIntoFall) == 0x0000DC, "Member 'UK38DogFollowKillerComponent::_rangeForFollowingKillerIntoFall' has a wrong offset!");
static_assert(offsetof(UK38DogFollowKillerComponent, _dogFallTimeoutSeconds) == 0x0000E0, "Member 'UK38DogFollowKillerComponent::_dogFallTimeoutSeconds' has a wrong offset!");
static_assert(offsetof(UK38DogFollowKillerComponent, _dogLookAtMultiplier) == 0x0000E4, "Member 'UK38DogFollowKillerComponent::_dogLookAtMultiplier' has a wrong offset!");
static_assert(offsetof(UK38DogFollowKillerComponent, _dogLookAtRotationEpsilon) == 0x0000E8, "Member 'UK38DogFollowKillerComponent::_dogLookAtRotationEpsilon' has a wrong offset!");
static_assert(offsetof(UK38DogFollowKillerComponent, _considerPettingDistance) == 0x0000EC, "Member 'UK38DogFollowKillerComponent::_considerPettingDistance' has a wrong offset!");
static_assert(offsetof(UK38DogFollowKillerComponent, _dogPathCostThreshold) == 0x0000F0, "Member 'UK38DogFollowKillerComponent::_dogPathCostThreshold' has a wrong offset!");
static_assert(offsetof(UK38DogFollowKillerComponent, _dogFollowInFrontOfKillerDistance) == 0x0000F8, "Member 'UK38DogFollowKillerComponent::_dogFollowInFrontOfKillerDistance' has a wrong offset!");
static_assert(offsetof(UK38DogFollowKillerComponent, _dogSlightlyFasterThanKillerDuringFollow) == 0x000120, "Member 'UK38DogFollowKillerComponent::_dogSlightlyFasterThanKillerDuringFollow' has a wrong offset!");
static_assert(offsetof(UK38DogFollowKillerComponent, _dogVaultExtension) == 0x000124, "Member 'UK38DogFollowKillerComponent::_dogVaultExtension' has a wrong offset!");
static_assert(offsetof(UK38DogFollowKillerComponent, _dogMaximumZOffsetFromKillerAfterFall) == 0x000128, "Member 'UK38DogFollowKillerComponent::_dogMaximumZOffsetFromKillerAfterFall' has a wrong offset!");
static_assert(offsetof(UK38DogFollowKillerComponent, _dogStuckHeightDeltaToTryFalling) == 0x00012C, "Member 'UK38DogFollowKillerComponent::_dogStuckHeightDeltaToTryFalling' has a wrong offset!");
static_assert(offsetof(UK38DogFollowKillerComponent, _shiftAmountWhenFollowPointBlocked) == 0x000130, "Member 'UK38DogFollowKillerComponent::_shiftAmountWhenFollowPointBlocked' has a wrong offset!");
static_assert(offsetof(UK38DogFollowKillerComponent, _shiftCountMax) == 0x000134, "Member 'UK38DogFollowKillerComponent::_shiftCountMax' has a wrong offset!");
static_assert(offsetof(UK38DogFollowKillerComponent, _keepDogWithKillerTimeout) == 0x000138, "Member 'UK38DogFollowKillerComponent::_keepDogWithKillerTimeout' has a wrong offset!");
static_assert(offsetof(UK38DogFollowKillerComponent, _movingAroundObstacleTimeout) == 0x00013C, "Member 'UK38DogFollowKillerComponent::_movingAroundObstacleTimeout' has a wrong offset!");
static_assert(offsetof(UK38DogFollowKillerComponent, _dogFollowKillerActor) == 0x000140, "Member 'UK38DogFollowKillerComponent::_dogFollowKillerActor' has a wrong offset!");
static_assert(offsetof(UK38DogFollowKillerComponent, _canBePetByKiller) == 0x000148, "Member 'UK38DogFollowKillerComponent::_canBePetByKiller' has a wrong offset!");
static_assert(offsetof(UK38DogFollowKillerComponent, _dog) == 0x000184, "Member 'UK38DogFollowKillerComponent::_dog' has a wrong offset!");
static_assert(offsetof(UK38DogFollowKillerComponent, _killer) == 0x00018C, "Member 'UK38DogFollowKillerComponent::_killer' has a wrong offset!");
static_assert(offsetof(UK38DogFollowKillerComponent, _targetFallLocation) == 0x000250, "Member 'UK38DogFollowKillerComponent::_targetFallLocation' has a wrong offset!");
static_assert(offsetof(UK38DogFollowKillerComponent, _targetVaultStartLocation) == 0x0002B8, "Member 'UK38DogFollowKillerComponent::_targetVaultStartLocation' has a wrong offset!");
static_assert(offsetof(UK38DogFollowKillerComponent, _isRunningInFrontOfKiller) == 0x000338, "Member 'UK38DogFollowKillerComponent::_isRunningInFrontOfKiller' has a wrong offset!");
static_assert(offsetof(UK38DogFollowKillerComponent, _dogAbilityData) == 0x0003B8, "Member 'UK38DogFollowKillerComponent::_dogAbilityData' has a wrong offset!");

// Class TheK38.K38DogMovementComponent
// 0x0000 (0x0F60 - 0x0F60)
class UK38DogMovementComponent final : public UCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38DogMovementComponent">();
	}
	static class UK38DogMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38DogMovementComponent>();
	}
};
static_assert(alignof(UK38DogMovementComponent) == 0x000010, "Wrong alignment on UK38DogMovementComponent");
static_assert(sizeof(UK38DogMovementComponent) == 0x000F60, "Wrong size on UK38DogMovementComponent");

// Class TheK38.K38DogNavigationDummy
// 0x0020 (0x0670 - 0x0650)
class AK38DogNavigationDummy final : public ACharacter
{
public:
	uint8                                         Pad_650[0x20];                                     // 0x0650(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38DogNavigationDummy">();
	}
	static class AK38DogNavigationDummy* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK38DogNavigationDummy>();
	}
};
static_assert(alignof(AK38DogNavigationDummy) == 0x000010, "Wrong alignment on AK38DogNavigationDummy");
static_assert(sizeof(AK38DogNavigationDummy) == 0x000670, "Wrong size on AK38DogNavigationDummy");

// Class TheK38.K38DogOutlineUpdateStrategy
// 0x0020 (0x0180 - 0x0160)
class UK38DogOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _vaultingColor;                                    // 0x0160(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _stunnedColor;                                     // 0x0170(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38DogOutlineUpdateStrategy">();
	}
	static class UK38DogOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38DogOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UK38DogOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UK38DogOutlineUpdateStrategy");
static_assert(sizeof(UK38DogOutlineUpdateStrategy) == 0x000180, "Wrong size on UK38DogOutlineUpdateStrategy");
static_assert(offsetof(UK38DogOutlineUpdateStrategy, _vaultingColor) == 0x000160, "Member 'UK38DogOutlineUpdateStrategy::_vaultingColor' has a wrong offset!");
static_assert(offsetof(UK38DogOutlineUpdateStrategy, _stunnedColor) == 0x000170, "Member 'UK38DogOutlineUpdateStrategy::_stunnedColor' has a wrong offset!");

// Class TheK38.K38DogPathPreviewComponent
// 0x00A8 (0x0160 - 0x00B8)
class UK38DogPathPreviewComponent final : public UActorComponent
{
public:
	TSubclassOf<class UNavigationQueryFilter>     NavigationFilterClass;                             // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AK38PatrolPathNode>         _patrolPathNodeClass;                              // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pathLineThickness;                                // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _visualPathZOffset;                                // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maximumDistanceBetweenNodes;                      // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minimumDistanceBetweenNodes;                      // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maximumHeightDeltaBetweenNodes;                   // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _nodeMultiplierForSlopesAndStairs;                 // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _clearPathNodeDelay;                               // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _findFloorRaycastStartHeight;                      // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _findFloorRaycastLength;                           // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector_NetQuantize>            _pathPoints;                                       // 0x00F0(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x10];                                     // 0x0100(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AK38PatrolPathNode*>             _visualNodes;                                      // 0x0110(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x40];                                     // 0x0120(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_PathPoints();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38DogPathPreviewComponent">();
	}
	static class UK38DogPathPreviewComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38DogPathPreviewComponent>();
	}
};
static_assert(alignof(UK38DogPathPreviewComponent) == 0x000008, "Wrong alignment on UK38DogPathPreviewComponent");
static_assert(sizeof(UK38DogPathPreviewComponent) == 0x000160, "Wrong size on UK38DogPathPreviewComponent");
static_assert(offsetof(UK38DogPathPreviewComponent, NavigationFilterClass) == 0x0000B8, "Member 'UK38DogPathPreviewComponent::NavigationFilterClass' has a wrong offset!");
static_assert(offsetof(UK38DogPathPreviewComponent, _patrolPathNodeClass) == 0x0000C0, "Member 'UK38DogPathPreviewComponent::_patrolPathNodeClass' has a wrong offset!");
static_assert(offsetof(UK38DogPathPreviewComponent, _pathLineThickness) == 0x0000C8, "Member 'UK38DogPathPreviewComponent::_pathLineThickness' has a wrong offset!");
static_assert(offsetof(UK38DogPathPreviewComponent, _visualPathZOffset) == 0x0000CC, "Member 'UK38DogPathPreviewComponent::_visualPathZOffset' has a wrong offset!");
static_assert(offsetof(UK38DogPathPreviewComponent, _maximumDistanceBetweenNodes) == 0x0000D0, "Member 'UK38DogPathPreviewComponent::_maximumDistanceBetweenNodes' has a wrong offset!");
static_assert(offsetof(UK38DogPathPreviewComponent, _minimumDistanceBetweenNodes) == 0x0000D4, "Member 'UK38DogPathPreviewComponent::_minimumDistanceBetweenNodes' has a wrong offset!");
static_assert(offsetof(UK38DogPathPreviewComponent, _maximumHeightDeltaBetweenNodes) == 0x0000D8, "Member 'UK38DogPathPreviewComponent::_maximumHeightDeltaBetweenNodes' has a wrong offset!");
static_assert(offsetof(UK38DogPathPreviewComponent, _nodeMultiplierForSlopesAndStairs) == 0x0000DC, "Member 'UK38DogPathPreviewComponent::_nodeMultiplierForSlopesAndStairs' has a wrong offset!");
static_assert(offsetof(UK38DogPathPreviewComponent, _clearPathNodeDelay) == 0x0000E0, "Member 'UK38DogPathPreviewComponent::_clearPathNodeDelay' has a wrong offset!");
static_assert(offsetof(UK38DogPathPreviewComponent, _findFloorRaycastStartHeight) == 0x0000E4, "Member 'UK38DogPathPreviewComponent::_findFloorRaycastStartHeight' has a wrong offset!");
static_assert(offsetof(UK38DogPathPreviewComponent, _findFloorRaycastLength) == 0x0000E8, "Member 'UK38DogPathPreviewComponent::_findFloorRaycastLength' has a wrong offset!");
static_assert(offsetof(UK38DogPathPreviewComponent, _pathPoints) == 0x0000F0, "Member 'UK38DogPathPreviewComponent::_pathPoints' has a wrong offset!");
static_assert(offsetof(UK38DogPathPreviewComponent, _visualNodes) == 0x000110, "Member 'UK38DogPathPreviewComponent::_visualNodes' has a wrong offset!");

// Class TheK38.K38DogSlipStreamComponent
// 0x0188 (0x0240 - 0x00B8)
class UK38DogSlipStreamComponent final : public UActorComponent
{
public:
	struct FDBDTunableRowHandle                   _slipStreamRange;                                  // 0x00B8(0x0028)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _slipStreamPointsGainRate;                         // 0x00E0(0x0028)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _slipStreamPointsLoseRate;                         // 0x0108(0x0028)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _killerSpeedPercentageCurve;                       // 0x0130(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _killerDecelerationPercentageCurve;                // 0x0138(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_140[0x18];                                     // 0x0140(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector_NetQuantize>            _pathPoints;                                       // 0x0158(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AKiller>                 _killer;                                           // 0x0168(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_170[0x10];                                     // 0x0170(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FK38SlipStreamData                     _slipStreamData;                                   // 0x0180(0x0040)(Edit, NativeAccessSpecifierPrivate)
	bool                                          _killerIsOnPatrolPath;                             // 0x01C0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _stateTagsToPreventSlipStream;                     // 0x01C8(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E8[0x48];                                     // 0x01E8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _currentSpeedCurve;                                // 0x0230(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Killer();
	void OnRep_KillerIsOnPatrolPath();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38DogSlipStreamComponent">();
	}
	static class UK38DogSlipStreamComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38DogSlipStreamComponent>();
	}
};
static_assert(alignof(UK38DogSlipStreamComponent) == 0x000008, "Wrong alignment on UK38DogSlipStreamComponent");
static_assert(sizeof(UK38DogSlipStreamComponent) == 0x000240, "Wrong size on UK38DogSlipStreamComponent");
static_assert(offsetof(UK38DogSlipStreamComponent, _slipStreamRange) == 0x0000B8, "Member 'UK38DogSlipStreamComponent::_slipStreamRange' has a wrong offset!");
static_assert(offsetof(UK38DogSlipStreamComponent, _slipStreamPointsGainRate) == 0x0000E0, "Member 'UK38DogSlipStreamComponent::_slipStreamPointsGainRate' has a wrong offset!");
static_assert(offsetof(UK38DogSlipStreamComponent, _slipStreamPointsLoseRate) == 0x000108, "Member 'UK38DogSlipStreamComponent::_slipStreamPointsLoseRate' has a wrong offset!");
static_assert(offsetof(UK38DogSlipStreamComponent, _killerSpeedPercentageCurve) == 0x000130, "Member 'UK38DogSlipStreamComponent::_killerSpeedPercentageCurve' has a wrong offset!");
static_assert(offsetof(UK38DogSlipStreamComponent, _killerDecelerationPercentageCurve) == 0x000138, "Member 'UK38DogSlipStreamComponent::_killerDecelerationPercentageCurve' has a wrong offset!");
static_assert(offsetof(UK38DogSlipStreamComponent, _pathPoints) == 0x000158, "Member 'UK38DogSlipStreamComponent::_pathPoints' has a wrong offset!");
static_assert(offsetof(UK38DogSlipStreamComponent, _killer) == 0x000168, "Member 'UK38DogSlipStreamComponent::_killer' has a wrong offset!");
static_assert(offsetof(UK38DogSlipStreamComponent, _slipStreamData) == 0x000180, "Member 'UK38DogSlipStreamComponent::_slipStreamData' has a wrong offset!");
static_assert(offsetof(UK38DogSlipStreamComponent, _killerIsOnPatrolPath) == 0x0001C0, "Member 'UK38DogSlipStreamComponent::_killerIsOnPatrolPath' has a wrong offset!");
static_assert(offsetof(UK38DogSlipStreamComponent, _stateTagsToPreventSlipStream) == 0x0001C8, "Member 'UK38DogSlipStreamComponent::_stateTagsToPreventSlipStream' has a wrong offset!");
static_assert(offsetof(UK38DogSlipStreamComponent, _currentSpeedCurve) == 0x000230, "Member 'UK38DogSlipStreamComponent::_currentSpeedCurve' has a wrong offset!");

// Class TheK38.K38DogStunnableComponent
// 0x00E0 (0x0198 - 0x00B8)
class UK38DogStunnableComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _killerInstinctEffectClass;                        // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _killerInstinctFromDogStunDuration;                // 0x00C8(0x0028)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _stunDogScoreReductionPointThreshold;              // 0x00F0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _stunDogScoreReductioPercentage;                   // 0x0118(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_140[0x58];                                     // 0x0140(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38DogStunnableComponent">();
	}
	static class UK38DogStunnableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38DogStunnableComponent>();
	}
};
static_assert(alignof(UK38DogStunnableComponent) == 0x000008, "Wrong alignment on UK38DogStunnableComponent");
static_assert(sizeof(UK38DogStunnableComponent) == 0x000198, "Wrong size on UK38DogStunnableComponent");
static_assert(offsetof(UK38DogStunnableComponent, _killerInstinctEffectClass) == 0x0000C0, "Member 'UK38DogStunnableComponent::_killerInstinctEffectClass' has a wrong offset!");
static_assert(offsetof(UK38DogStunnableComponent, _killerInstinctFromDogStunDuration) == 0x0000C8, "Member 'UK38DogStunnableComponent::_killerInstinctFromDogStunDuration' has a wrong offset!");
static_assert(offsetof(UK38DogStunnableComponent, _stunDogScoreReductionPointThreshold) == 0x0000F0, "Member 'UK38DogStunnableComponent::_stunDogScoreReductionPointThreshold' has a wrong offset!");
static_assert(offsetof(UK38DogStunnableComponent, _stunDogScoreReductioPercentage) == 0x000118, "Member 'UK38DogStunnableComponent::_stunDogScoreReductioPercentage' has a wrong offset!");

// Class TheK38.K38DogSurvivorDetectionComponent
// 0x01B0 (0x0268 - 0x00B8)
class UK38DogSurvivorDetectionComponent final : public UActorComponent
{
public:
	TSubclassOf<class UStatusEffect>              _k38KillerInstinctLingeringEffectClass;            // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UK38SurvivorStatusComponent> _K38SurvivorStatusComponentClass;                 // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _rangeCircleThickness;                             // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _dogDetectionRadiusStart;                          // 0x00D0(0x0028)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _dogDetectionRadiusEnd;                            // 0x00F8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _dogDetectionRadiusGrowDistance;                   // 0x0120(0x0028)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         _dogDetectionRadiusFadeOutSeconds;                 // 0x0148(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TWeakObjectPtr<class ASurvivor>, TWeakObjectPtr<class UK38KillerInstinctLingeringEffect>> _survivorKillerInstinctMap; // 0x0150(0x0050)(ExportObject, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class ASurvivor*>                      _survivorsDetectedThisPatrol;                      // 0x01A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B0[0xB8];                                     // 0x01B0(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38DogSurvivorDetectionComponent">();
	}
	static class UK38DogSurvivorDetectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38DogSurvivorDetectionComponent>();
	}
};
static_assert(alignof(UK38DogSurvivorDetectionComponent) == 0x000008, "Wrong alignment on UK38DogSurvivorDetectionComponent");
static_assert(sizeof(UK38DogSurvivorDetectionComponent) == 0x000268, "Wrong size on UK38DogSurvivorDetectionComponent");
static_assert(offsetof(UK38DogSurvivorDetectionComponent, _k38KillerInstinctLingeringEffectClass) == 0x0000B8, "Member 'UK38DogSurvivorDetectionComponent::_k38KillerInstinctLingeringEffectClass' has a wrong offset!");
static_assert(offsetof(UK38DogSurvivorDetectionComponent, _K38SurvivorStatusComponentClass) == 0x0000C0, "Member 'UK38DogSurvivorDetectionComponent::_K38SurvivorStatusComponentClass' has a wrong offset!");
static_assert(offsetof(UK38DogSurvivorDetectionComponent, _rangeCircleThickness) == 0x0000C8, "Member 'UK38DogSurvivorDetectionComponent::_rangeCircleThickness' has a wrong offset!");
static_assert(offsetof(UK38DogSurvivorDetectionComponent, _dogDetectionRadiusStart) == 0x0000D0, "Member 'UK38DogSurvivorDetectionComponent::_dogDetectionRadiusStart' has a wrong offset!");
static_assert(offsetof(UK38DogSurvivorDetectionComponent, _dogDetectionRadiusEnd) == 0x0000F8, "Member 'UK38DogSurvivorDetectionComponent::_dogDetectionRadiusEnd' has a wrong offset!");
static_assert(offsetof(UK38DogSurvivorDetectionComponent, _dogDetectionRadiusGrowDistance) == 0x000120, "Member 'UK38DogSurvivorDetectionComponent::_dogDetectionRadiusGrowDistance' has a wrong offset!");
static_assert(offsetof(UK38DogSurvivorDetectionComponent, _dogDetectionRadiusFadeOutSeconds) == 0x000148, "Member 'UK38DogSurvivorDetectionComponent::_dogDetectionRadiusFadeOutSeconds' has a wrong offset!");
static_assert(offsetof(UK38DogSurvivorDetectionComponent, _survivorKillerInstinctMap) == 0x000150, "Member 'UK38DogSurvivorDetectionComponent::_survivorKillerInstinctMap' has a wrong offset!");
static_assert(offsetof(UK38DogSurvivorDetectionComponent, _survivorsDetectedThisPatrol) == 0x0001A0, "Member 'UK38DogSurvivorDetectionComponent::_survivorsDetectedThisPatrol' has a wrong offset!");

// Class TheK38.K38DogTeleportComponent
// 0x0150 (0x0208 - 0x00B8)
class UK38DogTeleportComponent final : public UActorComponent
{
public:
	float                                         _preventDogGettingStuckRangeToKiller;              // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _dogStuckTimeoutSeconds;                           // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _dogFallingTimeoutSeconds;                         // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _dogTeleportCosmeticFadeTimeoutSeconds;            // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _killerTeleportedThreshold;                        // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _dogMoriForwardOffset;                             // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _maxAllowedTeleportDistanceToKiller;               // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _desiredMinTeleportDistanceToKiller;               // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxTeleportPathDistanceToKiller;                  // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E4[0x124];                                     // 0x00E4(0x0124)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_OnDogTeleportEnd(const struct FVector& StartLocation, const struct FVector& endLocation, const EK38DogTeleportReasons Reason, bool skipCosmeticCall);
	void Multicast_OnDogTeleportStart(const struct FVector& StartLocation, const struct FVector& endLocation, const EK38DogTeleportReasons Reason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38DogTeleportComponent">();
	}
	static class UK38DogTeleportComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38DogTeleportComponent>();
	}
};
static_assert(alignof(UK38DogTeleportComponent) == 0x000008, "Wrong alignment on UK38DogTeleportComponent");
static_assert(sizeof(UK38DogTeleportComponent) == 0x000208, "Wrong size on UK38DogTeleportComponent");
static_assert(offsetof(UK38DogTeleportComponent, _preventDogGettingStuckRangeToKiller) == 0x0000B8, "Member 'UK38DogTeleportComponent::_preventDogGettingStuckRangeToKiller' has a wrong offset!");
static_assert(offsetof(UK38DogTeleportComponent, _dogStuckTimeoutSeconds) == 0x0000BC, "Member 'UK38DogTeleportComponent::_dogStuckTimeoutSeconds' has a wrong offset!");
static_assert(offsetof(UK38DogTeleportComponent, _dogFallingTimeoutSeconds) == 0x0000C0, "Member 'UK38DogTeleportComponent::_dogFallingTimeoutSeconds' has a wrong offset!");
static_assert(offsetof(UK38DogTeleportComponent, _dogTeleportCosmeticFadeTimeoutSeconds) == 0x0000C4, "Member 'UK38DogTeleportComponent::_dogTeleportCosmeticFadeTimeoutSeconds' has a wrong offset!");
static_assert(offsetof(UK38DogTeleportComponent, _killerTeleportedThreshold) == 0x0000C8, "Member 'UK38DogTeleportComponent::_killerTeleportedThreshold' has a wrong offset!");
static_assert(offsetof(UK38DogTeleportComponent, _dogMoriForwardOffset) == 0x0000CC, "Member 'UK38DogTeleportComponent::_dogMoriForwardOffset' has a wrong offset!");
static_assert(offsetof(UK38DogTeleportComponent, _maxAllowedTeleportDistanceToKiller) == 0x0000D8, "Member 'UK38DogTeleportComponent::_maxAllowedTeleportDistanceToKiller' has a wrong offset!");
static_assert(offsetof(UK38DogTeleportComponent, _desiredMinTeleportDistanceToKiller) == 0x0000DC, "Member 'UK38DogTeleportComponent::_desiredMinTeleportDistanceToKiller' has a wrong offset!");
static_assert(offsetof(UK38DogTeleportComponent, _maxTeleportPathDistanceToKiller) == 0x0000E0, "Member 'UK38DogTeleportComponent::_maxTeleportPathDistanceToKiller' has a wrong offset!");

// Class TheK38.K38FollowOwnerDogState
// 0x0000 (0x0058 - 0x0058)
class UK38FollowOwnerDogState final : public UK38DogBaseState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38FollowOwnerDogState">();
	}
	static class UK38FollowOwnerDogState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38FollowOwnerDogState>();
	}
};
static_assert(alignof(UK38FollowOwnerDogState) == 0x000008, "Wrong alignment on UK38FollowOwnerDogState");
static_assert(sizeof(UK38FollowOwnerDogState) == 0x000058, "Wrong size on UK38FollowOwnerDogState");

// Class TheK38.K38FreeSurvivorFromDogInteraction
// 0x00E0 (0x09A0 - 0x08C0)
class UK38FreeSurvivorFromDogInteraction final : public UChargeableInteractionDefinition
{
public:
	struct FDBDTunableRowHandle                   _interactionChargeDuration;                        // 0x08C0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8E8[0x28];                                     // 0x08E8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimationAsset*                        _freeSurvivorAnimation;                            // 0x0910(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_918[0x30];                                     // 0x0918(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _injureSurvivorPerformingRescueScoreReductionPointThreshold; // 0x0948(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _injureSurvivorPerformingRescueScoreReductioPercentage; // 0x0970(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_998[0x8];                                      // 0x0998(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38FreeSurvivorFromDogInteraction">();
	}
	static class UK38FreeSurvivorFromDogInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38FreeSurvivorFromDogInteraction>();
	}
};
static_assert(alignof(UK38FreeSurvivorFromDogInteraction) == 0x000010, "Wrong alignment on UK38FreeSurvivorFromDogInteraction");
static_assert(sizeof(UK38FreeSurvivorFromDogInteraction) == 0x0009A0, "Wrong size on UK38FreeSurvivorFromDogInteraction");
static_assert(offsetof(UK38FreeSurvivorFromDogInteraction, _interactionChargeDuration) == 0x0008C0, "Member 'UK38FreeSurvivorFromDogInteraction::_interactionChargeDuration' has a wrong offset!");
static_assert(offsetof(UK38FreeSurvivorFromDogInteraction, _freeSurvivorAnimation) == 0x000910, "Member 'UK38FreeSurvivorFromDogInteraction::_freeSurvivorAnimation' has a wrong offset!");
static_assert(offsetof(UK38FreeSurvivorFromDogInteraction, _injureSurvivorPerformingRescueScoreReductionPointThreshold) == 0x000948, "Member 'UK38FreeSurvivorFromDogInteraction::_injureSurvivorPerformingRescueScoreReductionPointThreshold' has a wrong offset!");
static_assert(offsetof(UK38FreeSurvivorFromDogInteraction, _injureSurvivorPerformingRescueScoreReductioPercentage) == 0x000970, "Member 'UK38FreeSurvivorFromDogInteraction::_injureSurvivorPerformingRescueScoreReductioPercentage' has a wrong offset!");

// Class TheK38.K38GroundTarget
// 0x0130 (0x03D0 - 0x02A0)
class AK38GroundTarget final : public AActor
{
public:
	bool                                          _growDeployDistanceBasedOnCharge;                  // 0x02A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A1[0x3];                                      // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _minimumIndicatorVelocity;                         // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _indicatorVelocityEasingFactor;                    // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGroundTargetPlacement                 _targetPlacement;                                  // 0x02AC(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 _distancePercentLocations;                         // 0x02B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         _pitchLevelChangeAngleThreshold;                   // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maximumCameraPitchOrientationAngle;               // 0x02CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minimumCameraPitchOrientationAngle;               // 0x02D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _targetSlopeChangeThreshold;                       // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _rootComponent;                                    // 0x02D8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   _staticMeshComponent;                              // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDOutlineComponent*                   _outlineComponent;                                 // 0x02E8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoClear, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK38GroundTargetOutlineUpdateStrategy*  _outlineUpdateStrategy;                            // 0x02F0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoClear, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _distancePercentScalingCurveFromPitch;             // 0x02F8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_300[0x14];                                     // 0x0300(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _minimumTimeBeforeTargetLocationServerCall;        // 0x0314(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_318[0x41];                                     // 0x0318(0x0041)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isActivated;                                      // 0x0359(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isInMarkerVisibleToAllMode;                       // 0x035A(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isHiddenWhileAimAssistArrowVisible;               // 0x035B(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_35C[0x34];                                     // 0x035C(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _groundTargetHideDelay;                            // 0x0390(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _largestMeshScale;                                 // 0x0394(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_398[0x38];                                     // 0x0398(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnGroundTargetTooCloseToKillerToDeployChanged(bool tooCloseToKillerToDeploy);
	void Cosmetic_OnGroundTargetVisibilityChanged(bool Visible);
	void Cosmetic_SetIsGroundTargetPositionValid(bool isGroundTargetPlacementValid);
	void Multicast_SetTargetLocation(const struct FVector_NetQuantize& targetLocation, bool isValidLocation);
	void OnLocallyObservedChanged(const bool isPlayerLocallyObserved);
	void OnRep_Activated();
	void OnRep_HiddenWhileAimAssistArrowVisible();
	void OnRep_InMarkerVisibleToAllMode();
	void Server_SetTargetLocation(const struct FVector_NetQuantize& targetLocation, bool isValidLocation);

	float GetGroundTargetDistancePercentToKiller() const;
	float GetGroundTargetDistanceToKiller() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38GroundTarget">();
	}
	static class AK38GroundTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK38GroundTarget>();
	}
};
static_assert(alignof(AK38GroundTarget) == 0x000008, "Wrong alignment on AK38GroundTarget");
static_assert(sizeof(AK38GroundTarget) == 0x0003D0, "Wrong size on AK38GroundTarget");
static_assert(offsetof(AK38GroundTarget, _growDeployDistanceBasedOnCharge) == 0x0002A0, "Member 'AK38GroundTarget::_growDeployDistanceBasedOnCharge' has a wrong offset!");
static_assert(offsetof(AK38GroundTarget, _minimumIndicatorVelocity) == 0x0002A4, "Member 'AK38GroundTarget::_minimumIndicatorVelocity' has a wrong offset!");
static_assert(offsetof(AK38GroundTarget, _indicatorVelocityEasingFactor) == 0x0002A8, "Member 'AK38GroundTarget::_indicatorVelocityEasingFactor' has a wrong offset!");
static_assert(offsetof(AK38GroundTarget, _targetPlacement) == 0x0002AC, "Member 'AK38GroundTarget::_targetPlacement' has a wrong offset!");
static_assert(offsetof(AK38GroundTarget, _distancePercentLocations) == 0x0002B8, "Member 'AK38GroundTarget::_distancePercentLocations' has a wrong offset!");
static_assert(offsetof(AK38GroundTarget, _pitchLevelChangeAngleThreshold) == 0x0002C8, "Member 'AK38GroundTarget::_pitchLevelChangeAngleThreshold' has a wrong offset!");
static_assert(offsetof(AK38GroundTarget, _maximumCameraPitchOrientationAngle) == 0x0002CC, "Member 'AK38GroundTarget::_maximumCameraPitchOrientationAngle' has a wrong offset!");
static_assert(offsetof(AK38GroundTarget, _minimumCameraPitchOrientationAngle) == 0x0002D0, "Member 'AK38GroundTarget::_minimumCameraPitchOrientationAngle' has a wrong offset!");
static_assert(offsetof(AK38GroundTarget, _targetSlopeChangeThreshold) == 0x0002D4, "Member 'AK38GroundTarget::_targetSlopeChangeThreshold' has a wrong offset!");
static_assert(offsetof(AK38GroundTarget, _rootComponent) == 0x0002D8, "Member 'AK38GroundTarget::_rootComponent' has a wrong offset!");
static_assert(offsetof(AK38GroundTarget, _staticMeshComponent) == 0x0002E0, "Member 'AK38GroundTarget::_staticMeshComponent' has a wrong offset!");
static_assert(offsetof(AK38GroundTarget, _outlineComponent) == 0x0002E8, "Member 'AK38GroundTarget::_outlineComponent' has a wrong offset!");
static_assert(offsetof(AK38GroundTarget, _outlineUpdateStrategy) == 0x0002F0, "Member 'AK38GroundTarget::_outlineUpdateStrategy' has a wrong offset!");
static_assert(offsetof(AK38GroundTarget, _distancePercentScalingCurveFromPitch) == 0x0002F8, "Member 'AK38GroundTarget::_distancePercentScalingCurveFromPitch' has a wrong offset!");
static_assert(offsetof(AK38GroundTarget, _minimumTimeBeforeTargetLocationServerCall) == 0x000314, "Member 'AK38GroundTarget::_minimumTimeBeforeTargetLocationServerCall' has a wrong offset!");
static_assert(offsetof(AK38GroundTarget, _isActivated) == 0x000359, "Member 'AK38GroundTarget::_isActivated' has a wrong offset!");
static_assert(offsetof(AK38GroundTarget, _isInMarkerVisibleToAllMode) == 0x00035A, "Member 'AK38GroundTarget::_isInMarkerVisibleToAllMode' has a wrong offset!");
static_assert(offsetof(AK38GroundTarget, _isHiddenWhileAimAssistArrowVisible) == 0x00035B, "Member 'AK38GroundTarget::_isHiddenWhileAimAssistArrowVisible' has a wrong offset!");
static_assert(offsetof(AK38GroundTarget, _groundTargetHideDelay) == 0x000390, "Member 'AK38GroundTarget::_groundTargetHideDelay' has a wrong offset!");
static_assert(offsetof(AK38GroundTarget, _largestMeshScale) == 0x000394, "Member 'AK38GroundTarget::_largestMeshScale' has a wrong offset!");

// Class TheK38.K38GroundTargetOutlineUpdateStrategy
// 0x0030 (0x0190 - 0x0160)
class UK38GroundTargetOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _visibleToAllModeColor;                            // 0x0160(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _inRangeToBePlacedColor;                           // 0x0170(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _outOfRangeToBePlacedColor;                        // 0x0180(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38GroundTargetOutlineUpdateStrategy">();
	}
	static class UK38GroundTargetOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38GroundTargetOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UK38GroundTargetOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UK38GroundTargetOutlineUpdateStrategy");
static_assert(sizeof(UK38GroundTargetOutlineUpdateStrategy) == 0x000190, "Wrong size on UK38GroundTargetOutlineUpdateStrategy");
static_assert(offsetof(UK38GroundTargetOutlineUpdateStrategy, _visibleToAllModeColor) == 0x000160, "Member 'UK38GroundTargetOutlineUpdateStrategy::_visibleToAllModeColor' has a wrong offset!");
static_assert(offsetof(UK38GroundTargetOutlineUpdateStrategy, _inRangeToBePlacedColor) == 0x000170, "Member 'UK38GroundTargetOutlineUpdateStrategy::_inRangeToBePlacedColor' has a wrong offset!");
static_assert(offsetof(UK38GroundTargetOutlineUpdateStrategy, _outOfRangeToBePlacedColor) == 0x000180, "Member 'UK38GroundTargetOutlineUpdateStrategy::_outOfRangeToBePlacedColor' has a wrong offset!");

// Class TheK38.K38HoldingSurvivorDogState
// 0x00D8 (0x0130 - 0x0058)
class UK38HoldingSurvivorDogState final : public UK38DogBaseState
{
public:
	TSubclassOf<class UStatusEffect>              _hinderedStatusEffectClass;                        // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _hinderedEffectPercent;                            // 0x0060(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _hinderedEffectDuration;                           // 0x0088(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UInteractionDefinition>> _interactionTypesCancelledByDogStruggle;       // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UInteractionDefinition>> _interactionsCancellingDogStruggle;            // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x60];                                      // 0x00D0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnSurvivorHeldGameStateChanged(class ADBDPlayerState* PlayerState, const EGameState GameState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38HoldingSurvivorDogState">();
	}
	static class UK38HoldingSurvivorDogState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38HoldingSurvivorDogState>();
	}
};
static_assert(alignof(UK38HoldingSurvivorDogState) == 0x000008, "Wrong alignment on UK38HoldingSurvivorDogState");
static_assert(sizeof(UK38HoldingSurvivorDogState) == 0x000130, "Wrong size on UK38HoldingSurvivorDogState");
static_assert(offsetof(UK38HoldingSurvivorDogState, _hinderedStatusEffectClass) == 0x000058, "Member 'UK38HoldingSurvivorDogState::_hinderedStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK38HoldingSurvivorDogState, _hinderedEffectPercent) == 0x000060, "Member 'UK38HoldingSurvivorDogState::_hinderedEffectPercent' has a wrong offset!");
static_assert(offsetof(UK38HoldingSurvivorDogState, _hinderedEffectDuration) == 0x000088, "Member 'UK38HoldingSurvivorDogState::_hinderedEffectDuration' has a wrong offset!");
static_assert(offsetof(UK38HoldingSurvivorDogState, _interactionTypesCancelledByDogStruggle) == 0x0000B0, "Member 'UK38HoldingSurvivorDogState::_interactionTypesCancelledByDogStruggle' has a wrong offset!");
static_assert(offsetof(UK38HoldingSurvivorDogState, _interactionsCancellingDogStruggle) == 0x0000C0, "Member 'UK38HoldingSurvivorDogState::_interactionsCancellingDogStruggle' has a wrong offset!");

// Class TheK38.K38InMoriDogState
// 0x0000 (0x0058 - 0x0058)
class UK38InMoriDogState final : public UK38DogBaseState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38InMoriDogState">();
	}
	static class UK38InMoriDogState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38InMoriDogState>();
	}
};
static_assert(alignof(UK38InMoriDogState) == 0x000008, "Wrong alignment on UK38InMoriDogState");
static_assert(sizeof(UK38InMoriDogState) == 0x000058, "Wrong size on UK38InMoriDogState");

// Class TheK38.K38IntroDogState
// 0x0008 (0x0060 - 0x0058)
class UK38IntroDogState final : public UK38DogBaseState
{
public:
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnIntroCompleted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38IntroDogState">();
	}
	static class UK38IntroDogState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38IntroDogState>();
	}
};
static_assert(alignof(UK38IntroDogState) == 0x000008, "Wrong alignment on UK38IntroDogState");
static_assert(sizeof(UK38IntroDogState) == 0x000060, "Wrong size on UK38IntroDogState");

// Class TheK38.K38IsDogFollowingKillerCondition
// 0x0038 (0x0128 - 0x00F0)
class UK38IsDogFollowingKillerCondition final : public UEventDrivenModifierCondition
{
public:
	bool                                          _shouldNegateCondition;                            // 0x00F0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AKiller*                                _cachedKiller;                                     // 0x00F8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x28];                                     // 0x0100(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38IsDogFollowingKillerCondition">();
	}
	static class UK38IsDogFollowingKillerCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38IsDogFollowingKillerCondition>();
	}
};
static_assert(alignof(UK38IsDogFollowingKillerCondition) == 0x000008, "Wrong alignment on UK38IsDogFollowingKillerCondition");
static_assert(sizeof(UK38IsDogFollowingKillerCondition) == 0x000128, "Wrong size on UK38IsDogFollowingKillerCondition");
static_assert(offsetof(UK38IsDogFollowingKillerCondition, _shouldNegateCondition) == 0x0000F0, "Member 'UK38IsDogFollowingKillerCondition::_shouldNegateCondition' has a wrong offset!");
static_assert(offsetof(UK38IsDogFollowingKillerCondition, _cachedKiller) == 0x0000F8, "Member 'UK38IsDogFollowingKillerCondition::_cachedKiller' has a wrong offset!");

// Class TheK38.K38KillerInstinctLingeringEffect
// 0x00E0 (0x04E8 - 0x0408)
class UK38KillerInstinctLingeringEffect final : public UBaseLingeringStatusEffect
{
public:
	struct FDBDTunableRowHandle                   _dogDetectionRadiusStart;                          // 0x0408(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _killerInstinctLingerDuration;                     // 0x0430(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _maximumDetectionHeightDifference;                 // 0x0458(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_45C[0x4];                                      // 0x045C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AK38Dog*                                _dogInRange;                                       // 0x0460(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isInDogDetectionRadius;                           // 0x0468(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_469[0x7F];                                     // 0x0469(0x007F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnSurvivorCrouchChanged(const struct FGameplayTag& GameEvent, const struct FGameEventData& GameEventData);
	void OnRep_IsInDogDetectionRadius();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38KillerInstinctLingeringEffect">();
	}
	static class UK38KillerInstinctLingeringEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38KillerInstinctLingeringEffect>();
	}
};
static_assert(alignof(UK38KillerInstinctLingeringEffect) == 0x000008, "Wrong alignment on UK38KillerInstinctLingeringEffect");
static_assert(sizeof(UK38KillerInstinctLingeringEffect) == 0x0004E8, "Wrong size on UK38KillerInstinctLingeringEffect");
static_assert(offsetof(UK38KillerInstinctLingeringEffect, _dogDetectionRadiusStart) == 0x000408, "Member 'UK38KillerInstinctLingeringEffect::_dogDetectionRadiusStart' has a wrong offset!");
static_assert(offsetof(UK38KillerInstinctLingeringEffect, _killerInstinctLingerDuration) == 0x000430, "Member 'UK38KillerInstinctLingeringEffect::_killerInstinctLingerDuration' has a wrong offset!");
static_assert(offsetof(UK38KillerInstinctLingeringEffect, _maximumDetectionHeightDifference) == 0x000458, "Member 'UK38KillerInstinctLingeringEffect::_maximumDetectionHeightDifference' has a wrong offset!");
static_assert(offsetof(UK38KillerInstinctLingeringEffect, _dogInRange) == 0x000460, "Member 'UK38KillerInstinctLingeringEffect::_dogInRange' has a wrong offset!");
static_assert(offsetof(UK38KillerInstinctLingeringEffect, _isInDogDetectionRadius) == 0x000468, "Member 'UK38KillerInstinctLingeringEffect::_isInDogDetectionRadius' has a wrong offset!");

// Class TheK38.K38MenuDog
// 0x0108 (0x03A8 - 0x02A0)
class AK38MenuDog final : public AActor
{
public:
	class USceneComponent*                        _root;                                             // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDSkeletalMeshComponentBudgeted*      _skeletalMesh;                                     // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FK38DogMeshLinkerData>          _meshLinker;                                       // 0x02B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0[0xE8];                                     // 0x02C0(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38MenuDog">();
	}
	static class AK38MenuDog* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK38MenuDog>();
	}
};
static_assert(alignof(AK38MenuDog) == 0x000008, "Wrong alignment on AK38MenuDog");
static_assert(sizeof(AK38MenuDog) == 0x0003A8, "Wrong size on AK38MenuDog");
static_assert(offsetof(AK38MenuDog, _root) == 0x0002A0, "Member 'AK38MenuDog::_root' has a wrong offset!");
static_assert(offsetof(AK38MenuDog, _skeletalMesh) == 0x0002A8, "Member 'AK38MenuDog::_skeletalMesh' has a wrong offset!");
static_assert(offsetof(AK38MenuDog, _meshLinker) == 0x0002B0, "Member 'AK38MenuDog::_meshLinker' has a wrong offset!");

// Class TheK38.K38MenuDogAnimInstance
// 0x0010 (0x0360 - 0x0350)
class UK38MenuDogAnimInstance final : public UAnimInstance
{
public:
	class UAnimSequenceBase*                      _faceAdditive;                                     // 0x0350(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38MenuDogAnimInstance">();
	}
	static class UK38MenuDogAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38MenuDogAnimInstance>();
	}
};
static_assert(alignof(UK38MenuDogAnimInstance) == 0x000010, "Wrong alignment on UK38MenuDogAnimInstance");
static_assert(sizeof(UK38MenuDogAnimInstance) == 0x000360, "Wrong size on UK38MenuDogAnimInstance");
static_assert(offsetof(UK38MenuDogAnimInstance, _faceAdditive) == 0x000350, "Member 'UK38MenuDogAnimInstance::_faceAdditive' has a wrong offset!");

// Class TheK38.K38MoveToTargetLocationDogState
// 0x0008 (0x0060 - 0x0058)
class UK38MoveToTargetLocationDogState final : public UK38DogBaseState
{
public:
	float                                         _perchRadiusThreshold;                             // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnMoveCompleted(const struct FAIRequestID& RequestID, EPathFollowingResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38MoveToTargetLocationDogState">();
	}
	static class UK38MoveToTargetLocationDogState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38MoveToTargetLocationDogState>();
	}
};
static_assert(alignof(UK38MoveToTargetLocationDogState) == 0x000008, "Wrong alignment on UK38MoveToTargetLocationDogState");
static_assert(sizeof(UK38MoveToTargetLocationDogState) == 0x000060, "Wrong size on UK38MoveToTargetLocationDogState");
static_assert(offsetof(UK38MoveToTargetLocationDogState, _perchRadiusThreshold) == 0x000058, "Member 'UK38MoveToTargetLocationDogState::_perchRadiusThreshold' has a wrong offset!");

// Class TheK38.K38ObjectiveAimAssistTarget
// 0x0070 (0x0318 - 0x02A8)
class AK38ObjectiveAimAssistTarget final : public ADBDActorIndicator
{
public:
	uint8                                         Pad_2A8[0x18];                                     // 0x02A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _scanForObjectivesPeriod;                          // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _acquisitionAngle;                                 // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _releaseAngle;                                     // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _objectiveCenteringHeightMultiplier;               // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FK38AimAssistObjectiveInfo>     _pointsOfInterest;                                 // 0x02D0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   _jointCrankTargetName;                             // 0x02E0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EC[0x2C];                                     // 0x02EC(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnAimAssistObjectiveSelected(class AActor* selectedObject, class AKiller* Killer);
	void Multicast_SetSelectedObjective(class AActor* newSelectedObjective);
	void Server_SetSelectedObjective(class AActor* newSelectedObjective);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38ObjectiveAimAssistTarget">();
	}
	static class AK38ObjectiveAimAssistTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK38ObjectiveAimAssistTarget>();
	}
};
static_assert(alignof(AK38ObjectiveAimAssistTarget) == 0x000008, "Wrong alignment on AK38ObjectiveAimAssistTarget");
static_assert(sizeof(AK38ObjectiveAimAssistTarget) == 0x000318, "Wrong size on AK38ObjectiveAimAssistTarget");
static_assert(offsetof(AK38ObjectiveAimAssistTarget, _scanForObjectivesPeriod) == 0x0002C0, "Member 'AK38ObjectiveAimAssistTarget::_scanForObjectivesPeriod' has a wrong offset!");
static_assert(offsetof(AK38ObjectiveAimAssistTarget, _acquisitionAngle) == 0x0002C4, "Member 'AK38ObjectiveAimAssistTarget::_acquisitionAngle' has a wrong offset!");
static_assert(offsetof(AK38ObjectiveAimAssistTarget, _releaseAngle) == 0x0002C8, "Member 'AK38ObjectiveAimAssistTarget::_releaseAngle' has a wrong offset!");
static_assert(offsetof(AK38ObjectiveAimAssistTarget, _objectiveCenteringHeightMultiplier) == 0x0002CC, "Member 'AK38ObjectiveAimAssistTarget::_objectiveCenteringHeightMultiplier' has a wrong offset!");
static_assert(offsetof(AK38ObjectiveAimAssistTarget, _pointsOfInterest) == 0x0002D0, "Member 'AK38ObjectiveAimAssistTarget::_pointsOfInterest' has a wrong offset!");
static_assert(offsetof(AK38ObjectiveAimAssistTarget, _jointCrankTargetName) == 0x0002E0, "Member 'AK38ObjectiveAimAssistTarget::_jointCrankTargetName' has a wrong offset!");

// Class TheK38.K38P01
// 0x0028 (0x0488 - 0x0460)
class UK38P01 final : public UPerk
{
public:
	float                                         _lungeAttackAddDurationMultiplier[0x3];            // 0x0460(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _activationDuration[0x3];                          // 0x046C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _cooldownDuration[0x3];                            // 0x0478(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_484[0x4];                                      // 0x0484(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnStaggeringLanding(class AKiller* Killer);
	void Multicast_OnK38P01Landing(class AKiller* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38P01">();
	}
	static class UK38P01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38P01>();
	}
};
static_assert(alignof(UK38P01) == 0x000008, "Wrong alignment on UK38P01");
static_assert(sizeof(UK38P01) == 0x000488, "Wrong size on UK38P01");
static_assert(offsetof(UK38P01, _lungeAttackAddDurationMultiplier) == 0x000460, "Member 'UK38P01::_lungeAttackAddDurationMultiplier' has a wrong offset!");
static_assert(offsetof(UK38P01, _activationDuration) == 0x00046C, "Member 'UK38P01::_activationDuration' has a wrong offset!");
static_assert(offsetof(UK38P01, _cooldownDuration) == 0x000478, "Member 'UK38P01::_cooldownDuration' has a wrong offset!");

// Class TheK38.K38P02
// 0x0028 (0x0488 - 0x0460)
class UK38P02 final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _revealGeneratorStatusEffectClass;                 // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _generatorRevealDuration[0x3];                     // 0x0468(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_474[0x4];                                      // 0x0474(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffect*                          _authority_revealGeneratorStatusEffect;            // 0x0478(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_480[0x8];                                      // 0x0480(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnSurvivorHookedOnScourgeHook(const struct FGameEventData& GameEventData);
	void Cosmetic_NewScourgeHookEvent(class AKiller* Killer, class AMeatHook* Hook);
	void Multicast_NewScourgeHookEvent(class AKiller* Killer, class AMeatHook* Hook);

	float GetGeneratorRevealDurationAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38P02">();
	}
	static class UK38P02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38P02>();
	}
};
static_assert(alignof(UK38P02) == 0x000008, "Wrong alignment on UK38P02");
static_assert(sizeof(UK38P02) == 0x000488, "Wrong size on UK38P02");
static_assert(offsetof(UK38P02, _revealGeneratorStatusEffectClass) == 0x000460, "Member 'UK38P02::_revealGeneratorStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK38P02, _generatorRevealDuration) == 0x000468, "Member 'UK38P02::_generatorRevealDuration' has a wrong offset!");
static_assert(offsetof(UK38P02, _authority_revealGeneratorStatusEffect) == 0x000478, "Member 'UK38P02::_authority_revealGeneratorStatusEffect' has a wrong offset!");

// Class TheK38.K38P03
// 0x0020 (0x0480 - 0x0460)
class UK38P03 final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _brokenStatusEffectClass;                          // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _externalPerkIconStatusEffectClass;                // 0x0468(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _selfHealPercentCondition;                         // 0x0470(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _brokenStatusDuration[0x3];                        // 0x0474(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnSelfHealInteractionFinished(class ADBDPlayer* Player, bool hasInteractionStarted);
	void Multicast_ActivateSkillCheck(class ADBDPlayer* Survivor);

	float GetBrokenStatusDurationAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38P03">();
	}
	static class UK38P03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38P03>();
	}
};
static_assert(alignof(UK38P03) == 0x000008, "Wrong alignment on UK38P03");
static_assert(sizeof(UK38P03) == 0x000480, "Wrong size on UK38P03");
static_assert(offsetof(UK38P03, _brokenStatusEffectClass) == 0x000460, "Member 'UK38P03::_brokenStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK38P03, _externalPerkIconStatusEffectClass) == 0x000468, "Member 'UK38P03::_externalPerkIconStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK38P03, _selfHealPercentCondition) == 0x000470, "Member 'UK38P03::_selfHealPercentCondition' has a wrong offset!");
static_assert(offsetof(UK38P03, _brokenStatusDuration) == 0x000474, "Member 'UK38P03::_brokenStatusDuration' has a wrong offset!");

// Class TheK38.K38PatrolIdleDogState
// 0x00B8 (0x0110 - 0x0058)
class UK38PatrolIdleDogState final : public UK38DogBaseState
{
public:
	struct FTunableStat                           _patrolIdleSeconds;                                // 0x0058(0x0080)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _distanceFromKillerMultiplierCurve;                // 0x00D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x30];                                      // 0x00E0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38PatrolIdleDogState">();
	}
	static class UK38PatrolIdleDogState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38PatrolIdleDogState>();
	}
};
static_assert(alignof(UK38PatrolIdleDogState) == 0x000008, "Wrong alignment on UK38PatrolIdleDogState");
static_assert(sizeof(UK38PatrolIdleDogState) == 0x000110, "Wrong size on UK38PatrolIdleDogState");
static_assert(offsetof(UK38PatrolIdleDogState, _patrolIdleSeconds) == 0x000058, "Member 'UK38PatrolIdleDogState::_patrolIdleSeconds' has a wrong offset!");
static_assert(offsetof(UK38PatrolIdleDogState, _distanceFromKillerMultiplierCurve) == 0x0000D8, "Member 'UK38PatrolIdleDogState::_distanceFromKillerMultiplierCurve' has a wrong offset!");

// Class TheK38.K38PatrolPathNode
// 0x0018 (0x02B8 - 0x02A0)
class AK38PatrolPathNode final : public AActor
{
public:
	struct FVector                                _previousNodePosition;                             // 0x02A0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Cosmetic_OnFollowPatrolPathChanged(bool patrolPathFollowed);
	void Cosmetic_PrepareForRemoval();
	void OnPatrolPathFollowedChanged(bool isOnPatrolPath);
	void OnPreviousNodePositionSet();

	bool IsFirstNode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38PatrolPathNode">();
	}
	static class AK38PatrolPathNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK38PatrolPathNode>();
	}
};
static_assert(alignof(AK38PatrolPathNode) == 0x000008, "Wrong alignment on AK38PatrolPathNode");
static_assert(sizeof(AK38PatrolPathNode) == 0x0002B8, "Wrong size on AK38PatrolPathNode");
static_assert(offsetof(AK38PatrolPathNode, _previousNodePosition) == 0x0002A0, "Member 'AK38PatrolPathNode::_previousNodePosition' has a wrong offset!");

// Class TheK38.K38PetByKillerState
// 0x0000 (0x0058 - 0x0058)
class UK38PetByKillerState final : public UK38DogBaseState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38PetByKillerState">();
	}
	static class UK38PetByKillerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38PetByKillerState>();
	}
};
static_assert(alignof(UK38PetByKillerState) == 0x000008, "Wrong alignment on UK38PetByKillerState");
static_assert(sizeof(UK38PetByKillerState) == 0x000058, "Wrong size on UK38PetByKillerState");

// Class TheK38.K38PetTheDogInteraction
// 0x0080 (0x0940 - 0x08C0)
class UK38PetTheDogInteraction final : public UChargeableInteractionDefinition
{
public:
	uint8                                         Pad_8C0[0x8];                                      // 0x08C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimationMontageDescriptor            _pettingMontage;                                   // 0x08C8(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8E8[0x58];                                     // 0x08E8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnPetTheDogChargeBegin();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38PetTheDogInteraction">();
	}
	static class UK38PetTheDogInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38PetTheDogInteraction>();
	}
};
static_assert(alignof(UK38PetTheDogInteraction) == 0x000010, "Wrong alignment on UK38PetTheDogInteraction");
static_assert(sizeof(UK38PetTheDogInteraction) == 0x000940, "Wrong size on UK38PetTheDogInteraction");
static_assert(offsetof(UK38PetTheDogInteraction, _pettingMontage) == 0x0008C8, "Member 'UK38PetTheDogInteraction::_pettingMontage' has a wrong offset!");

// Class TheK38.K38Power
// 0x0140 (0x0750 - 0x0610)
class AK38Power final : public AKillerPower
{
public:
	float                                         _paradiseDogRightOffset;                           // 0x0610(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _paradiseDogForwardOffset;                         // 0x0614(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_618[0x18];                                     // 0x0618(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   _dogParadisePawnClass;                             // 0x0630(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_668[0xE8];                                     // 0x0668(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnAimCommandSwitched(const class AKiller* Killer, bool switchToPatrol);
	void Cosmetic_OnAimDashActivated(const class AKiller* killerPlayer, const class AK38Dog* dog);
	void Cosmetic_OnAimDashChargeCancelled(const class AKiller* killerPlayer, const class AK38Dog* dog);
	void Cosmetic_OnAimDashChargeComplete(const class AKiller* killerPlayer, const class AK38Dog* dog);
	void Cosmetic_OnAimPatrolActivated(const class AKiller* killerPlayer, const class AK38Dog* dog);
	void Cosmetic_OnAimPatrolChargeCancelled(const class AKiller* killerPlayer, const class AK38Dog* dog);
	void Cosmetic_OnAimPatrolChargeComplete(const class AKiller* killerPlayer, const class AK38Dog* dog);
	void Cosmetic_OnAimReady(const class AKiller* Killer);
	void Cosmetic_OnKillerEffectActivated(const class AK38Dog* dog, const class ASurvivor* Survivor);
	void Cosmetic_OnKillerRecallDog(const class AK38Dog* dog);
	void Cosmetic_OnPatrolDetectionRadiusMax(const class AKiller* killerPlayer, const class AK38Dog* dog);
	void Cosmetic_OnRedirectActivated(const class AKiller* killerPlayer, const class AK38Dog* dog);
	void Cosmetic_OnRedirectCancelled(const class AKiller* killerPlayer, const class AK38Dog* dog);
	void Cosmetic_OnRedirectDogStruggleInteractionCooldownComplete(class AKiller* killerPlayer);
	void Cosmetic_OnRedirectDogStruggleTargetLocationChanged(class AKiller* killerPlayer);
	void Cosmetic_OnRedirectStarted(const class AKiller* killerPlayer, const class AK38Dog* dog);
	void Cosmetic_OnSlipStreamChanged(float lastSlipStreamPoints, float currentSlipStreamPoints, float maxSlipStreamPoints);
	void Cosmetic_OnSlipStreamDisabled();
	void Cosmetic_OnSlipStreamEnabled();
	void Cosmetic_OnSlipStreamPathFollowedChanged(bool onPath);
	void Cosmetic_OnSlipStreamReachedMax();
	void Cosmetic_OnSlipStreamReachedMaxFirstTime();
	void Cosmetic_OnSlipStreamReachedZero();
	void Cosmetic_OnStartAimDashCharge(const class AKiller* killerPlayer, const class AK38Dog* dog);
	void Cosmetic_OnStartAimPatrolCharge(const class AKiller* killerPlayer, const class AK38Dog* dog);
	void Cosmetic_RedirectFadeToWhite(const class AKiller* killerPlayer, float Duration);

	class AK38Dog* GetK38DogActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38Power">();
	}
	static class AK38Power* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK38Power>();
	}
};
static_assert(alignof(AK38Power) == 0x000008, "Wrong alignment on AK38Power");
static_assert(sizeof(AK38Power) == 0x000750, "Wrong size on AK38Power");
static_assert(offsetof(AK38Power, _paradiseDogRightOffset) == 0x000610, "Member 'AK38Power::_paradiseDogRightOffset' has a wrong offset!");
static_assert(offsetof(AK38Power, _paradiseDogForwardOffset) == 0x000614, "Member 'AK38Power::_paradiseDogForwardOffset' has a wrong offset!");
static_assert(offsetof(AK38Power, _dogParadisePawnClass) == 0x000630, "Member 'AK38Power::_dogParadisePawnClass' has a wrong offset!");

// Class TheK38.K38PowerAddon08
// 0x0038 (0x0338 - 0x0300)
class UK38PowerAddon08 final : public UItemAddon
{
public:
	uint8                                         Pad_300[0x28];                                     // 0x0300(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _reduceHitCooldownStatusEffect;                    // 0x0328(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _timeToReduceHitCooldown;                          // 0x0330(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_334[0x4];                                      // 0x0334(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38PowerAddon08">();
	}
	static class UK38PowerAddon08* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38PowerAddon08>();
	}
};
static_assert(alignof(UK38PowerAddon08) == 0x000008, "Wrong alignment on UK38PowerAddon08");
static_assert(sizeof(UK38PowerAddon08) == 0x000338, "Wrong size on UK38PowerAddon08");
static_assert(offsetof(UK38PowerAddon08, _reduceHitCooldownStatusEffect) == 0x000328, "Member 'UK38PowerAddon08::_reduceHitCooldownStatusEffect' has a wrong offset!");
static_assert(offsetof(UK38PowerAddon08, _timeToReduceHitCooldown) == 0x000330, "Member 'UK38PowerAddon08::_timeToReduceHitCooldown' has a wrong offset!");

// Class TheK38.K38PowerAddon15
// 0x0040 (0x0340 - 0x0300)
class UK38PowerAddon15 final : public UItemAddon
{
public:
	uint8                                         Pad_300[0x3C];                                     // 0x0300(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _generatorCompletedEffectTime;                     // 0x033C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38PowerAddon15">();
	}
	static class UK38PowerAddon15* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38PowerAddon15>();
	}
};
static_assert(alignof(UK38PowerAddon15) == 0x000008, "Wrong alignment on UK38PowerAddon15");
static_assert(sizeof(UK38PowerAddon15) == 0x000340, "Wrong size on UK38PowerAddon15");
static_assert(offsetof(UK38PowerAddon15, _generatorCompletedEffectTime) == 0x00033C, "Member 'UK38PowerAddon15::_generatorCompletedEffectTime' has a wrong offset!");

// Class TheK38.K38PowerAddon17
// 0x0008 (0x0308 - 0x0300)
class UK38PowerAddon17 final : public UItemAddon
{
public:
	float                                         _survivorRangeToStruggleToApplyEffect;             // 0x0300(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38PowerAddon17">();
	}
	static class UK38PowerAddon17* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38PowerAddon17>();
	}
};
static_assert(alignof(UK38PowerAddon17) == 0x000008, "Wrong alignment on UK38PowerAddon17");
static_assert(sizeof(UK38PowerAddon17) == 0x000308, "Wrong size on UK38PowerAddon17");
static_assert(offsetof(UK38PowerAddon17, _survivorRangeToStruggleToApplyEffect) == 0x000300, "Member 'UK38PowerAddon17::_survivorRangeToStruggleToApplyEffect' has a wrong offset!");

// Class TheK38.K38PowerAddon19
// 0x00C0 (0x03C0 - 0x0300)
class UK38PowerAddon19 final : public UItemAddon
{
public:
	uint8                                         Pad_300[0x80];                                     // 0x0300(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _lingerTime;                                       // 0x0380(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _effectiveRangeToDog;                              // 0x0384(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _lingeringRevealStatusEffect;                      // 0x0388(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_390[0x30];                                     // 0x0390(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38PowerAddon19">();
	}
	static class UK38PowerAddon19* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38PowerAddon19>();
	}
};
static_assert(alignof(UK38PowerAddon19) == 0x000008, "Wrong alignment on UK38PowerAddon19");
static_assert(sizeof(UK38PowerAddon19) == 0x0003C0, "Wrong size on UK38PowerAddon19");
static_assert(offsetof(UK38PowerAddon19, _lingerTime) == 0x000380, "Member 'UK38PowerAddon19::_lingerTime' has a wrong offset!");
static_assert(offsetof(UK38PowerAddon19, _effectiveRangeToDog) == 0x000384, "Member 'UK38PowerAddon19::_effectiveRangeToDog' has a wrong offset!");
static_assert(offsetof(UK38PowerAddon19, _lingeringRevealStatusEffect) == 0x000388, "Member 'UK38PowerAddon19::_lingeringRevealStatusEffect' has a wrong offset!");

// Class TheK38.K38PowerAddon20
// 0x0018 (0x0318 - 0x0300)
class UK38PowerAddon20 final : public UItemAddon
{
public:
	TSubclassOf<class UStatusEffect>              _undetectableEffectClass;                          // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _dogPatrolIdleTimeEffectClass;                     // 0x0308(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_310[0x8];                                      // 0x0310(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDogStateChanged(const struct FGameplayTag& oldState, const struct FGameplayTag& newState);
	void OnPatrolPathFollowedChanged(bool isOnPatrolPath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38PowerAddon20">();
	}
	static class UK38PowerAddon20* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38PowerAddon20>();
	}
};
static_assert(alignof(UK38PowerAddon20) == 0x000008, "Wrong alignment on UK38PowerAddon20");
static_assert(sizeof(UK38PowerAddon20) == 0x000318, "Wrong size on UK38PowerAddon20");
static_assert(offsetof(UK38PowerAddon20, _undetectableEffectClass) == 0x000300, "Member 'UK38PowerAddon20::_undetectableEffectClass' has a wrong offset!");
static_assert(offsetof(UK38PowerAddon20, _dogPatrolIdleTimeEffectClass) == 0x000308, "Member 'UK38PowerAddon20::_dogPatrolIdleTimeEffectClass' has a wrong offset!");

// Class TheK38.K38RecallDog
// 0x0010 (0x0780 - 0x0770)
class UK38RecallDog final : public UInteractionDefinition
{
public:
	uint8                                         Pad_768[0x18];                                     // 0x0768(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38RecallDog">();
	}
	static class UK38RecallDog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38RecallDog>();
	}
};
static_assert(alignof(UK38RecallDog) == 0x000010, "Wrong alignment on UK38RecallDog");
static_assert(sizeof(UK38RecallDog) == 0x000780, "Wrong size on UK38RecallDog");

// Class TheK38.K38RedirectDash
// 0x0050 (0x07C0 - 0x0770)
class UK38RedirectDash final : public UInteractionDefinition
{
public:
	uint8                                         Pad_768[0x3];                                      // 0x0768(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _shouldDashByDefault;                              // 0x076B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_76C[0x4];                                      // 0x076C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _blindnessImmuneStatusEffectClass;                 // 0x0770(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStatusEffect*                          _appliedBlindnessEffect;                           // 0x0778(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_780[0x40];                                     // 0x0780(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38RedirectDash">();
	}
	static class UK38RedirectDash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38RedirectDash>();
	}
};
static_assert(alignof(UK38RedirectDash) == 0x000010, "Wrong alignment on UK38RedirectDash");
static_assert(sizeof(UK38RedirectDash) == 0x0007C0, "Wrong size on UK38RedirectDash");
static_assert(offsetof(UK38RedirectDash, _shouldDashByDefault) == 0x00076B, "Member 'UK38RedirectDash::_shouldDashByDefault' has a wrong offset!");
static_assert(offsetof(UK38RedirectDash, _blindnessImmuneStatusEffectClass) == 0x000770, "Member 'UK38RedirectDash::_blindnessImmuneStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK38RedirectDash, _appliedBlindnessEffect) == 0x000778, "Member 'UK38RedirectDash::_appliedBlindnessEffect' has a wrong offset!");

// Class TheK38.K38SurvivorAnimInstance
// 0x0050 (0x0630 - 0x05E0)
class UK38SurvivorAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	bool                                          _isPerformingRescueAnimation;                      // 0x05E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHeldByDog;                                      // 0x05E1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isMale;                                           // 0x05E2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E3[0x5];                                      // 0x05E3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _dogJawLocation;                                   // 0x05E8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animSpeed;                                        // 0x0600(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _forwardVelocity;                                  // 0x0604(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _lateralVelocity;                                  // 0x0608(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _dogJawSocket;                                     // 0x060C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_618[0x18];                                     // 0x0618(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38SurvivorAnimInstance">();
	}
	static class UK38SurvivorAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38SurvivorAnimInstance>();
	}
};
static_assert(alignof(UK38SurvivorAnimInstance) == 0x000010, "Wrong alignment on UK38SurvivorAnimInstance");
static_assert(sizeof(UK38SurvivorAnimInstance) == 0x000630, "Wrong size on UK38SurvivorAnimInstance");
static_assert(offsetof(UK38SurvivorAnimInstance, _isPerformingRescueAnimation) == 0x0005E0, "Member 'UK38SurvivorAnimInstance::_isPerformingRescueAnimation' has a wrong offset!");
static_assert(offsetof(UK38SurvivorAnimInstance, _isHeldByDog) == 0x0005E1, "Member 'UK38SurvivorAnimInstance::_isHeldByDog' has a wrong offset!");
static_assert(offsetof(UK38SurvivorAnimInstance, _isMale) == 0x0005E2, "Member 'UK38SurvivorAnimInstance::_isMale' has a wrong offset!");
static_assert(offsetof(UK38SurvivorAnimInstance, _dogJawLocation) == 0x0005E8, "Member 'UK38SurvivorAnimInstance::_dogJawLocation' has a wrong offset!");
static_assert(offsetof(UK38SurvivorAnimInstance, _animSpeed) == 0x000600, "Member 'UK38SurvivorAnimInstance::_animSpeed' has a wrong offset!");
static_assert(offsetof(UK38SurvivorAnimInstance, _forwardVelocity) == 0x000604, "Member 'UK38SurvivorAnimInstance::_forwardVelocity' has a wrong offset!");
static_assert(offsetof(UK38SurvivorAnimInstance, _lateralVelocity) == 0x000608, "Member 'UK38SurvivorAnimInstance::_lateralVelocity' has a wrong offset!");
static_assert(offsetof(UK38SurvivorAnimInstance, _dogJawSocket) == 0x00060C, "Member 'UK38SurvivorAnimInstance::_dogJawSocket' has a wrong offset!");

// Class TheK38.K38SurvivorCosmeticHelperActor
// 0x0020 (0x0378 - 0x0358)
class AK38SurvivorCosmeticHelperActor final : public ASurvivorCosmeticHelperActor
{
public:
	uint8                                         Pad_358[0x20];                                     // 0x0358(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnDetectedStatusEffectActiveChanged(bool IsActive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38SurvivorCosmeticHelperActor">();
	}
	static class AK38SurvivorCosmeticHelperActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK38SurvivorCosmeticHelperActor>();
	}
};
static_assert(alignof(AK38SurvivorCosmeticHelperActor) == 0x000008, "Wrong alignment on AK38SurvivorCosmeticHelperActor");
static_assert(sizeof(AK38SurvivorCosmeticHelperActor) == 0x000378, "Wrong size on AK38SurvivorCosmeticHelperActor");

// Class TheK38.K38SurvivorHeldByDogComponent
// 0x0138 (0x01F0 - 0x00B8)
class UK38SurvivorHeldByDogComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x68];                                      // 0x00B8(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _audioIsFightingBack;                              // 0x0120(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _audioIsPulling;                                   // 0x0121(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_122[0x2];                                      // 0x0122(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _survivorFightBacksCooldown;                       // 0x0124(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _timeWithNoMoveInputConsideredAsStoppedFightingBack; // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _targetLocationDogOffset;                          // 0x012C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _raycastOffsetFromSurvivorForCenterOfDog;          // 0x0130(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _raycastOffsetFromCenterFrontLegs;                 // 0x0134(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _raycastOffsetFromCenterBackLegs;                  // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _deltaDegreesRotationPerRaycast;                   // 0x013C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _raycastLength;                                    // 0x0140(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UK38SurvivorHeldByDogRotationStrategy> _survivorRotationStrategyClass;         // 0x0148(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK38SurvivorHeldByDogVelocityCalculationStrategy> _survivorVelocityCalculationStrategyClass; // 0x0150(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK38SurvivorHeldByDogRotationStrategy*  _rotationStrategy;                                 // 0x0158(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK38SurvivorHeldByDogVelocityCalculationStrategy* _velocityCalculationStrategy;            // 0x0160(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _heldByDogStatusEffectClass;                       // 0x0168(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGateBlockerEffect>         _gateBlockingEffectClass;                          // 0x0170(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStatusEffect*                          _heldStatusEffectImposed;                          // 0x0178(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_180[0x8];                                      // 0x0180(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AK38Dog*                                _dogHoldingSurvivor;                               // 0x0188(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   _dogHoldingSurvivorChargeProgressDescriptionText;  // 0x0190(0x0018)(Edit, NativeAccessSpecifierPrivate)
	float                                         _accelerationMultiplier;                           // 0x01A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1AC[0x4];                                      // 0x01AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    _targetLocation;                                   // 0x01B0(0x0018)(Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C8[0x28];                                     // 0x01C8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_DogStartsPullingSurvivor();
	void Cosmetic_DogStopsPullingSurvivor();
	void Cosmetic_OnStruggleEnded(class AK38Dog* previouslyAttachedDog);
	void Cosmetic_OnStruggleStarted();
	void Cosmetic_OnSurvivorFightBack();
	void Cosmetic_OnSurvivorStopFightingBack();
	void OnRep_AudioIsFightingBack(bool OldValue);
	void OnRep_AudioIsPulling(bool OldValue);
	void OnRep_DogHoldingSurvivor(class AK38Dog* OldValue);
	void Server_SetFightingBack(bool isFightingBack);

	class AK38Dog* GetDogHoldingSurvivor() const;
	class ASurvivor* GetSurvivor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38SurvivorHeldByDogComponent">();
	}
	static class UK38SurvivorHeldByDogComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38SurvivorHeldByDogComponent>();
	}
};
static_assert(alignof(UK38SurvivorHeldByDogComponent) == 0x000008, "Wrong alignment on UK38SurvivorHeldByDogComponent");
static_assert(sizeof(UK38SurvivorHeldByDogComponent) == 0x0001F0, "Wrong size on UK38SurvivorHeldByDogComponent");
static_assert(offsetof(UK38SurvivorHeldByDogComponent, _audioIsFightingBack) == 0x000120, "Member 'UK38SurvivorHeldByDogComponent::_audioIsFightingBack' has a wrong offset!");
static_assert(offsetof(UK38SurvivorHeldByDogComponent, _audioIsPulling) == 0x000121, "Member 'UK38SurvivorHeldByDogComponent::_audioIsPulling' has a wrong offset!");
static_assert(offsetof(UK38SurvivorHeldByDogComponent, _survivorFightBacksCooldown) == 0x000124, "Member 'UK38SurvivorHeldByDogComponent::_survivorFightBacksCooldown' has a wrong offset!");
static_assert(offsetof(UK38SurvivorHeldByDogComponent, _timeWithNoMoveInputConsideredAsStoppedFightingBack) == 0x000128, "Member 'UK38SurvivorHeldByDogComponent::_timeWithNoMoveInputConsideredAsStoppedFightingBack' has a wrong offset!");
static_assert(offsetof(UK38SurvivorHeldByDogComponent, _targetLocationDogOffset) == 0x00012C, "Member 'UK38SurvivorHeldByDogComponent::_targetLocationDogOffset' has a wrong offset!");
static_assert(offsetof(UK38SurvivorHeldByDogComponent, _raycastOffsetFromSurvivorForCenterOfDog) == 0x000130, "Member 'UK38SurvivorHeldByDogComponent::_raycastOffsetFromSurvivorForCenterOfDog' has a wrong offset!");
static_assert(offsetof(UK38SurvivorHeldByDogComponent, _raycastOffsetFromCenterFrontLegs) == 0x000134, "Member 'UK38SurvivorHeldByDogComponent::_raycastOffsetFromCenterFrontLegs' has a wrong offset!");
static_assert(offsetof(UK38SurvivorHeldByDogComponent, _raycastOffsetFromCenterBackLegs) == 0x000138, "Member 'UK38SurvivorHeldByDogComponent::_raycastOffsetFromCenterBackLegs' has a wrong offset!");
static_assert(offsetof(UK38SurvivorHeldByDogComponent, _deltaDegreesRotationPerRaycast) == 0x00013C, "Member 'UK38SurvivorHeldByDogComponent::_deltaDegreesRotationPerRaycast' has a wrong offset!");
static_assert(offsetof(UK38SurvivorHeldByDogComponent, _raycastLength) == 0x000140, "Member 'UK38SurvivorHeldByDogComponent::_raycastLength' has a wrong offset!");
static_assert(offsetof(UK38SurvivorHeldByDogComponent, _survivorRotationStrategyClass) == 0x000148, "Member 'UK38SurvivorHeldByDogComponent::_survivorRotationStrategyClass' has a wrong offset!");
static_assert(offsetof(UK38SurvivorHeldByDogComponent, _survivorVelocityCalculationStrategyClass) == 0x000150, "Member 'UK38SurvivorHeldByDogComponent::_survivorVelocityCalculationStrategyClass' has a wrong offset!");
static_assert(offsetof(UK38SurvivorHeldByDogComponent, _rotationStrategy) == 0x000158, "Member 'UK38SurvivorHeldByDogComponent::_rotationStrategy' has a wrong offset!");
static_assert(offsetof(UK38SurvivorHeldByDogComponent, _velocityCalculationStrategy) == 0x000160, "Member 'UK38SurvivorHeldByDogComponent::_velocityCalculationStrategy' has a wrong offset!");
static_assert(offsetof(UK38SurvivorHeldByDogComponent, _heldByDogStatusEffectClass) == 0x000168, "Member 'UK38SurvivorHeldByDogComponent::_heldByDogStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK38SurvivorHeldByDogComponent, _gateBlockingEffectClass) == 0x000170, "Member 'UK38SurvivorHeldByDogComponent::_gateBlockingEffectClass' has a wrong offset!");
static_assert(offsetof(UK38SurvivorHeldByDogComponent, _heldStatusEffectImposed) == 0x000178, "Member 'UK38SurvivorHeldByDogComponent::_heldStatusEffectImposed' has a wrong offset!");
static_assert(offsetof(UK38SurvivorHeldByDogComponent, _dogHoldingSurvivor) == 0x000188, "Member 'UK38SurvivorHeldByDogComponent::_dogHoldingSurvivor' has a wrong offset!");
static_assert(offsetof(UK38SurvivorHeldByDogComponent, _dogHoldingSurvivorChargeProgressDescriptionText) == 0x000190, "Member 'UK38SurvivorHeldByDogComponent::_dogHoldingSurvivorChargeProgressDescriptionText' has a wrong offset!");
static_assert(offsetof(UK38SurvivorHeldByDogComponent, _accelerationMultiplier) == 0x0001A8, "Member 'UK38SurvivorHeldByDogComponent::_accelerationMultiplier' has a wrong offset!");
static_assert(offsetof(UK38SurvivorHeldByDogComponent, _targetLocation) == 0x0001B0, "Member 'UK38SurvivorHeldByDogComponent::_targetLocation' has a wrong offset!");

// Class TheK38.K38SurvivorHeldByDogRotationStrategy
// 0x0020 (0x00D8 - 0x00B8)
class UK38SurvivorHeldByDogRotationStrategy final : public UBaseCharacterRotationStrategy
{
public:
	uint8                                         Pad_B8[0x1C];                                      // 0x00B8(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _rotationLerpSpeed;                                // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38SurvivorHeldByDogRotationStrategy">();
	}
	static class UK38SurvivorHeldByDogRotationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38SurvivorHeldByDogRotationStrategy>();
	}
};
static_assert(alignof(UK38SurvivorHeldByDogRotationStrategy) == 0x000008, "Wrong alignment on UK38SurvivorHeldByDogRotationStrategy");
static_assert(sizeof(UK38SurvivorHeldByDogRotationStrategy) == 0x0000D8, "Wrong size on UK38SurvivorHeldByDogRotationStrategy");
static_assert(offsetof(UK38SurvivorHeldByDogRotationStrategy, _rotationLerpSpeed) == 0x0000D4, "Member 'UK38SurvivorHeldByDogRotationStrategy::_rotationLerpSpeed' has a wrong offset!");

// Class TheK38.K38SurvivorHeldByDogVelocityCalculationStrategy
// 0x0078 (0x0130 - 0x00B8)
class UK38SurvivorHeldByDogVelocityCalculationStrategy final : public UBaseCharacterVelocityCalculationStrategy
{
public:
	class UCurveFloat*                            _dogPullSpeedCurve;                                // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _pullPulsationDuration;                            // 0x00C0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _pulsationPercentageCurve;                         // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minDistanceToTargetForMovement;                   // 0x00F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F4[0x3C];                                      // 0x00F4(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38SurvivorHeldByDogVelocityCalculationStrategy">();
	}
	static class UK38SurvivorHeldByDogVelocityCalculationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38SurvivorHeldByDogVelocityCalculationStrategy>();
	}
};
static_assert(alignof(UK38SurvivorHeldByDogVelocityCalculationStrategy) == 0x000008, "Wrong alignment on UK38SurvivorHeldByDogVelocityCalculationStrategy");
static_assert(sizeof(UK38SurvivorHeldByDogVelocityCalculationStrategy) == 0x000130, "Wrong size on UK38SurvivorHeldByDogVelocityCalculationStrategy");
static_assert(offsetof(UK38SurvivorHeldByDogVelocityCalculationStrategy, _dogPullSpeedCurve) == 0x0000B8, "Member 'UK38SurvivorHeldByDogVelocityCalculationStrategy::_dogPullSpeedCurve' has a wrong offset!");
static_assert(offsetof(UK38SurvivorHeldByDogVelocityCalculationStrategy, _pullPulsationDuration) == 0x0000C0, "Member 'UK38SurvivorHeldByDogVelocityCalculationStrategy::_pullPulsationDuration' has a wrong offset!");
static_assert(offsetof(UK38SurvivorHeldByDogVelocityCalculationStrategy, _pulsationPercentageCurve) == 0x0000E8, "Member 'UK38SurvivorHeldByDogVelocityCalculationStrategy::_pulsationPercentageCurve' has a wrong offset!");
static_assert(offsetof(UK38SurvivorHeldByDogVelocityCalculationStrategy, _minDistanceToTargetForMovement) == 0x0000F0, "Member 'UK38SurvivorHeldByDogVelocityCalculationStrategy::_minDistanceToTargetForMovement' has a wrong offset!");

// Class TheK38.K38SurvivorStatusComponent
// 0x0100 (0x01B8 - 0x00B8)
class UK38SurvivorStatusComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTunableStat                           _detectionKillerEffectDuration;                    // 0x00C0(0x0080)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _timeAddedOnEnduranceHit;                          // 0x0140(0x0028)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _k38SurvivorKOWithKillerEffectClass;               // 0x0168(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_170[0x48];                                     // 0x0170(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnK38DetectionKillerEffectEnd(class ASurvivor* Survivor);
	void Cosmetic_OnK38DetectionKillerEffectStart(class ASurvivor* Survivor);
	void Multicast_ApplyKillerEffectToSurvivor(class AKiller* Killer, bool applyEffect, float Duration, bool keepCosmeticEffectActive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38SurvivorStatusComponent">();
	}
	static class UK38SurvivorStatusComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38SurvivorStatusComponent>();
	}
};
static_assert(alignof(UK38SurvivorStatusComponent) == 0x000008, "Wrong alignment on UK38SurvivorStatusComponent");
static_assert(sizeof(UK38SurvivorStatusComponent) == 0x0001B8, "Wrong size on UK38SurvivorStatusComponent");
static_assert(offsetof(UK38SurvivorStatusComponent, _detectionKillerEffectDuration) == 0x0000C0, "Member 'UK38SurvivorStatusComponent::_detectionKillerEffectDuration' has a wrong offset!");
static_assert(offsetof(UK38SurvivorStatusComponent, _timeAddedOnEnduranceHit) == 0x000140, "Member 'UK38SurvivorStatusComponent::_timeAddedOnEnduranceHit' has a wrong offset!");
static_assert(offsetof(UK38SurvivorStatusComponent, _k38SurvivorKOWithKillerEffectClass) == 0x000168, "Member 'UK38SurvivorStatusComponent::_k38SurvivorKOWithKillerEffectClass' has a wrong offset!");

// Class TheK38.K38SwapCommand
// 0x0020 (0x0790 - 0x0770)
class UK38SwapCommand final : public UInteractionDefinition
{
public:
	uint8                                         Pad_768[0x28];                                     // 0x0768(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38SwapCommand">();
	}
	static class UK38SwapCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38SwapCommand>();
	}
};
static_assert(alignof(UK38SwapCommand) == 0x000010, "Wrong alignment on UK38SwapCommand");
static_assert(sizeof(UK38SwapCommand) == 0x000790, "Wrong size on UK38SwapCommand");

// Class TheK38.K38SwapCommandWidgetComponent
// 0x0000 (0x00E8 - 0x00E8)
class UK38SwapCommandWidgetComponent final : public UK38PowerWidgetPresentationComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38SwapCommandWidgetComponent">();
	}
	static class UK38SwapCommandWidgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38SwapCommandWidgetComponent>();
	}
};
static_assert(alignof(UK38SwapCommandWidgetComponent) == 0x000008, "Wrong alignment on UK38SwapCommandWidgetComponent");
static_assert(sizeof(UK38SwapCommandWidgetComponent) == 0x0000E8, "Wrong size on UK38SwapCommandWidgetComponent");

// Class TheK38.K38Utilities
// 0x0000 (0x0030 - 0x0030)
class UK38Utilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38Utilities">();
	}
	static class UK38Utilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38Utilities>();
	}
};
static_assert(alignof(UK38Utilities) == 0x000008, "Wrong alignment on UK38Utilities");
static_assert(sizeof(UK38Utilities) == 0x000030, "Wrong size on UK38Utilities");

// Class TheK38.K38VaultingDogState
// 0x01C8 (0x0220 - 0x0058)
class UK38VaultingDogState final : public UK38DogBaseState
{
public:
	struct FDBDTunableRowHandle                   _dogTurnToVaultSeconds;                            // 0x0058(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _dogDashTurnToVaultSeconds;                        // 0x0080(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _dogVaultSeconds;                                  // 0x00A8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _dogDashVaultSeconds;                              // 0x00D0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FAnimationMontageDescriptor            _vaultMontage;                                     // 0x00F8(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FAnimationMontageDescriptor            _vaultPalletMontage;                               // 0x0118(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_138[0xE8];                                     // 0x0138(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38VaultingDogState">();
	}
	static class UK38VaultingDogState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38VaultingDogState>();
	}
};
static_assert(alignof(UK38VaultingDogState) == 0x000008, "Wrong alignment on UK38VaultingDogState");
static_assert(sizeof(UK38VaultingDogState) == 0x000220, "Wrong size on UK38VaultingDogState");
static_assert(offsetof(UK38VaultingDogState, _dogTurnToVaultSeconds) == 0x000058, "Member 'UK38VaultingDogState::_dogTurnToVaultSeconds' has a wrong offset!");
static_assert(offsetof(UK38VaultingDogState, _dogDashTurnToVaultSeconds) == 0x000080, "Member 'UK38VaultingDogState::_dogDashTurnToVaultSeconds' has a wrong offset!");
static_assert(offsetof(UK38VaultingDogState, _dogVaultSeconds) == 0x0000A8, "Member 'UK38VaultingDogState::_dogVaultSeconds' has a wrong offset!");
static_assert(offsetof(UK38VaultingDogState, _dogDashVaultSeconds) == 0x0000D0, "Member 'UK38VaultingDogState::_dogDashVaultSeconds' has a wrong offset!");
static_assert(offsetof(UK38VaultingDogState, _vaultMontage) == 0x0000F8, "Member 'UK38VaultingDogState::_vaultMontage' has a wrong offset!");
static_assert(offsetof(UK38VaultingDogState, _vaultPalletMontage) == 0x000118, "Member 'UK38VaultingDogState::_vaultPalletMontage' has a wrong offset!");

// Class TheK38.K38WaitRedirectDogState
// 0x0000 (0x0058 - 0x0058)
class UK38WaitRedirectDogState final : public UK38DogBaseState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K38WaitRedirectDogState">();
	}
	static class UK38WaitRedirectDogState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK38WaitRedirectDogState>();
	}
};
static_assert(alignof(UK38WaitRedirectDogState) == 0x000008, "Wrong alignment on UK38WaitRedirectDogState");
static_assert(sizeof(UK38WaitRedirectDogState) == 0x000058, "Wrong size on UK38WaitRedirectDogState");

}

