#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Competence

#include "Basic.hpp"

#include "Competence_classes.hpp"
#include "Competence_parameters.hpp"


namespace SDK
{

// Function Competence.BaseModifierContainer.Authority_OnInstantiateModifierConditions
// (BlueprintAuthorityOnly, Event, Protected, BlueprintEvent)

void UBaseModifierContainer::Authority_OnInstantiateModifierConditions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseModifierContainer", "Authority_OnInstantiateModifierConditions");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Competence.BaseModifierContainer.CreateAndSetEventDrivenCondition
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UEventDrivenModifierCondition>conditionType                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEventDrivenModifierCondition*    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEventDrivenModifierCondition* UBaseModifierContainer::CreateAndSetEventDrivenCondition(TSubclassOf<class UEventDrivenModifierCondition> conditionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseModifierContainer", "CreateAndSetEventDrivenCondition");

	Params::BaseModifierContainer_CreateAndSetEventDrivenCondition Parms{};

	Parms.conditionType = conditionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Competence.BaseModifierContainer.OnRep_EventDrivenConditionData_Internal
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FModifierReplicatedEventConditionData&oldReplicatedCondition                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UBaseModifierContainer::OnRep_EventDrivenConditionData_Internal(const struct FModifierReplicatedEventConditionData& oldReplicatedCondition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseModifierContainer", "OnRep_EventDrivenConditionData_Internal");

	Params::BaseModifierContainer_OnRep_EventDrivenConditionData_Internal Parms{};

	Parms.oldReplicatedCondition = std::move(oldReplicatedCondition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Competence.BaseModifierContainer.OnRep_ID
// (Final, Native, Private)

void UBaseModifierContainer::OnRep_ID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseModifierContainer", "OnRep_ID");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Competence.BaseModifierContainer.IsApplicable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBaseModifierContainer::IsApplicable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseModifierContainer", "IsApplicable");

	Params::BaseModifierContainer_IsApplicable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Competence.BaseModifierCondition.Authority_OnInstantiateModifierConditions
// (BlueprintAuthorityOnly, Event, Protected, BlueprintEvent)

void UBaseModifierCondition::Authority_OnInstantiateModifierConditions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseModifierCondition", "Authority_OnInstantiateModifierConditions");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Competence.BaseModifierCondition.InitializeSubjectProviderClass
// (Native, Event, Protected, BlueprintEvent)

void UBaseModifierCondition::InitializeSubjectProviderClass()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseModifierCondition", "InitializeSubjectProviderClass");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Competence.BaseModifierCondition.OnRep_OwningModifier
// (Final, Native, Private)

void UBaseModifierCondition::OnRep_OwningModifier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseModifierCondition", "OnRep_OwningModifier");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Competence.BaseModifierCondition.OnRep_SubjectProviderClass
// (Final, Native, Private)

void UBaseModifierCondition::OnRep_SubjectProviderClass()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseModifierCondition", "OnRep_SubjectProviderClass");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Competence.BaseModifierCondition.SetSubjectProviderClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                           subjectProviderClass                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseModifierCondition::SetSubjectProviderClass(class UClass* subjectProviderClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseModifierCondition", "SetSubjectProviderClass");

	Params::BaseModifierCondition_SetSubjectProviderClass Parms{};

	Parms.subjectProviderClass = subjectProviderClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Competence.BaseModifierCondition.GetOwningActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UBaseModifierCondition::GetOwningActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseModifierCondition", "GetOwningActor");

	Params::BaseModifierCondition_GetOwningActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Competence.BaseModifierCondition.GetOwningModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBaseModifierContainer*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBaseModifierContainer* UBaseModifierCondition::GetOwningModifier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseModifierCondition", "GetOwningModifier");

	Params::BaseModifierCondition_GetOwningModifier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Competence.RangeBasedCondition.OnRep_Range
// (Final, Native, Private)

void URangeBasedCondition::OnRep_Range()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangeBasedCondition", "OnRep_Range");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Competence.RangeBasedCondition.SetRange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   newRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URangeBasedCondition::SetRange(float newRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangeBasedCondition", "SetRange");

	Params::RangeBasedCondition_SetRange Parms{};

	Parms.newRange = newRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Competence.HasObjectState.SetState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              State                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHasObjectState::SetState(const struct FGameplayTag& State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HasObjectState", "SetState");

	Params::HasObjectState_SetState Parms{};

	Parms.State = std::move(State);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Competence.HasObjectStateWithMaxDuration.SetMaxDuration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHasObjectStateWithMaxDuration::SetMaxDuration(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HasObjectStateWithMaxDuration", "SetMaxDuration");

	Params::HasObjectStateWithMaxDuration_SetMaxDuration Parms{};

	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Competence.CompositeModifierCondition.OnRep_Conditions
// (Final, Native, Private)

void UCompositeModifierCondition::OnRep_Conditions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompositeModifierCondition", "OnRep_Conditions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Competence.SingleModifierCondition.OnRep_Condition
// (Final, Native, Protected)

void USingleModifierCondition::OnRep_Condition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SingleModifierCondition", "OnRep_Condition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Competence.ConditionFactory.AND
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IConditionReceiver>ConditionReceiver                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAndModifierCondition*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAndModifierCondition* UConditionFactory::AND(TScriptInterface<class IConditionReceiver> ConditionReceiver)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConditionFactory", "AND");

	Params::ConditionFactory_AND Parms{};

	Parms.ConditionReceiver = ConditionReceiver;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Competence.ConditionFactory.CreateAndReceiveConditionForBP
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IConditionReceiver>ConditionReceiver                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UEventDrivenModifierCondition>conditionType                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEventDrivenModifierCondition*    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEventDrivenModifierCondition* UConditionFactory::CreateAndReceiveConditionForBP(TScriptInterface<class IConditionReceiver> ConditionReceiver, TSubclassOf<class UEventDrivenModifierCondition> conditionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConditionFactory", "CreateAndReceiveConditionForBP");

	Params::ConditionFactory_CreateAndReceiveConditionForBP Parms{};

	Parms.ConditionReceiver = ConditionReceiver;
	Parms.conditionType = conditionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Competence.ConditionFactory.CreateAndReceiveConditionWithSubjectForBP
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IConditionReceiver>ConditionReceiver                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UEventDrivenModifierCondition>conditionType                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           subjectProviderClass                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEventDrivenModifierCondition*    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEventDrivenModifierCondition* UConditionFactory::CreateAndReceiveConditionWithSubjectForBP(TScriptInterface<class IConditionReceiver> ConditionReceiver, TSubclassOf<class UEventDrivenModifierCondition> conditionType, class UClass* subjectProviderClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConditionFactory", "CreateAndReceiveConditionWithSubjectForBP");

	Params::ConditionFactory_CreateAndReceiveConditionWithSubjectForBP Parms{};

	Parms.ConditionReceiver = ConditionReceiver;
	Parms.conditionType = conditionType;
	Parms.subjectProviderClass = subjectProviderClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Competence.ConditionFactory.CreateNumericalConstraintCondition_Double
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IConditionReceiver>ConditionReceiver                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UNumericalConstraintsCondition_Double>conditionType                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TMap<ENumericalConstraintComparisonMethod, double>&numericalConstraints                                   (Parm, NativeAccessSpecifierPublic)
// class UNumericalConstraintsCondition_Double*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNumericalConstraintsCondition_Double* UConditionFactory::CreateNumericalConstraintCondition_Double(TScriptInterface<class IConditionReceiver> ConditionReceiver, TSubclassOf<class UNumericalConstraintsCondition_Double> conditionType, const TMap<ENumericalConstraintComparisonMethod, double>& numericalConstraints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConditionFactory", "CreateNumericalConstraintCondition_Double");

	Params::ConditionFactory_CreateNumericalConstraintCondition_Double Parms{};

	Parms.ConditionReceiver = ConditionReceiver;
	Parms.conditionType = conditionType;
	Parms.numericalConstraints = std::move(numericalConstraints);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Competence.ConditionFactory.CreateNumericalConstraintCondition_Float
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IConditionReceiver>ConditionReceiver                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UNumericalConstraintsCondition_Float>conditionType                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TMap<ENumericalConstraintComparisonMethod, float>&numericalConstraints                                   (Parm, NativeAccessSpecifierPublic)
// class UNumericalConstraintsCondition_Float*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNumericalConstraintsCondition_Float* UConditionFactory::CreateNumericalConstraintCondition_Float(TScriptInterface<class IConditionReceiver> ConditionReceiver, TSubclassOf<class UNumericalConstraintsCondition_Float> conditionType, const TMap<ENumericalConstraintComparisonMethod, float>& numericalConstraints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConditionFactory", "CreateNumericalConstraintCondition_Float");

	Params::ConditionFactory_CreateNumericalConstraintCondition_Float Parms{};

	Parms.ConditionReceiver = ConditionReceiver;
	Parms.conditionType = conditionType;
	Parms.numericalConstraints = std::move(numericalConstraints);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Competence.ConditionFactory.CreateNumericalConstraintCondition_Int
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IConditionReceiver>ConditionReceiver                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UNumericalConstraintsCondition_Int>conditionType                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TMap<ENumericalConstraintComparisonMethod, int32>&numericalConstraints                                   (Parm, NativeAccessSpecifierPublic)
// class UNumericalConstraintsCondition_Int*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNumericalConstraintsCondition_Int* UConditionFactory::CreateNumericalConstraintCondition_Int(TScriptInterface<class IConditionReceiver> ConditionReceiver, TSubclassOf<class UNumericalConstraintsCondition_Int> conditionType, const TMap<ENumericalConstraintComparisonMethod, int32>& numericalConstraints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConditionFactory", "CreateNumericalConstraintCondition_Int");

	Params::ConditionFactory_CreateNumericalConstraintCondition_Int Parms{};

	Parms.ConditionReceiver = ConditionReceiver;
	Parms.conditionType = conditionType;
	Parms.numericalConstraints = std::move(numericalConstraints);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Competence.ConditionFactory.CreateNumericalConstraintConditionWithSubject_Double
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IConditionReceiver>ConditionReceiver                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UNumericalConstraintsCondition_Double>conditionType                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TMap<ENumericalConstraintComparisonMethod, double>&numericalConstraints                                   (Parm, NativeAccessSpecifierPublic)
// class UClass*                           subjectProviderClass                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNumericalConstraintsCondition_Double*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNumericalConstraintsCondition_Double* UConditionFactory::CreateNumericalConstraintConditionWithSubject_Double(TScriptInterface<class IConditionReceiver> ConditionReceiver, TSubclassOf<class UNumericalConstraintsCondition_Double> conditionType, const TMap<ENumericalConstraintComparisonMethod, double>& numericalConstraints, class UClass* subjectProviderClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConditionFactory", "CreateNumericalConstraintConditionWithSubject_Double");

	Params::ConditionFactory_CreateNumericalConstraintConditionWithSubject_Double Parms{};

	Parms.ConditionReceiver = ConditionReceiver;
	Parms.conditionType = conditionType;
	Parms.numericalConstraints = std::move(numericalConstraints);
	Parms.subjectProviderClass = subjectProviderClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Competence.ConditionFactory.CreateNumericalConstraintConditionWithSubject_Float
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IConditionReceiver>ConditionReceiver                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UNumericalConstraintsCondition_Float>conditionType                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TMap<ENumericalConstraintComparisonMethod, float>&numericalConstraints                                   (Parm, NativeAccessSpecifierPublic)
// class UClass*                           subjectProviderClass                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNumericalConstraintsCondition_Float*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNumericalConstraintsCondition_Float* UConditionFactory::CreateNumericalConstraintConditionWithSubject_Float(TScriptInterface<class IConditionReceiver> ConditionReceiver, TSubclassOf<class UNumericalConstraintsCondition_Float> conditionType, const TMap<ENumericalConstraintComparisonMethod, float>& numericalConstraints, class UClass* subjectProviderClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConditionFactory", "CreateNumericalConstraintConditionWithSubject_Float");

	Params::ConditionFactory_CreateNumericalConstraintConditionWithSubject_Float Parms{};

	Parms.ConditionReceiver = ConditionReceiver;
	Parms.conditionType = conditionType;
	Parms.numericalConstraints = std::move(numericalConstraints);
	Parms.subjectProviderClass = subjectProviderClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Competence.ConditionFactory.CreateNumericalConstraintConditionWithSubject_Int
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IConditionReceiver>ConditionReceiver                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UNumericalConstraintsCondition_Int>conditionType                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TMap<ENumericalConstraintComparisonMethod, int32>&numericalConstraints                                   (Parm, NativeAccessSpecifierPublic)
// class UClass*                           subjectProviderClass                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNumericalConstraintsCondition_Int*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNumericalConstraintsCondition_Int* UConditionFactory::CreateNumericalConstraintConditionWithSubject_Int(TScriptInterface<class IConditionReceiver> ConditionReceiver, TSubclassOf<class UNumericalConstraintsCondition_Int> conditionType, const TMap<ENumericalConstraintComparisonMethod, int32>& numericalConstraints, class UClass* subjectProviderClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConditionFactory", "CreateNumericalConstraintConditionWithSubject_Int");

	Params::ConditionFactory_CreateNumericalConstraintConditionWithSubject_Int Parms{};

	Parms.ConditionReceiver = ConditionReceiver;
	Parms.conditionType = conditionType;
	Parms.numericalConstraints = std::move(numericalConstraints);
	Parms.subjectProviderClass = subjectProviderClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Competence.ConditionFactory.CreateRangeBasedCondition
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IConditionReceiver>ConditionReceiver                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class URangeBasedCondition> conditionType                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Range                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URangeBasedCondition*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URangeBasedCondition* UConditionFactory::CreateRangeBasedCondition(TScriptInterface<class IConditionReceiver> ConditionReceiver, TSubclassOf<class URangeBasedCondition> conditionType, float Range)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConditionFactory", "CreateRangeBasedCondition");

	Params::ConditionFactory_CreateRangeBasedCondition Parms{};

	Parms.ConditionReceiver = ConditionReceiver;
	Parms.conditionType = conditionType;
	Parms.Range = Range;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Competence.ConditionFactory.CreateRangeBasedConditionWithSubject
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IConditionReceiver>ConditionReceiver                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class URangeBasedCondition> conditionType                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Range                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           subjectProviderClass                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URangeBasedCondition*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URangeBasedCondition* UConditionFactory::CreateRangeBasedConditionWithSubject(TScriptInterface<class IConditionReceiver> ConditionReceiver, TSubclassOf<class URangeBasedCondition> conditionType, float Range, class UClass* subjectProviderClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConditionFactory", "CreateRangeBasedConditionWithSubject");

	Params::ConditionFactory_CreateRangeBasedConditionWithSubject Parms{};

	Parms.ConditionReceiver = ConditionReceiver;
	Parms.conditionType = conditionType;
	Parms.Range = Range;
	Parms.subjectProviderClass = subjectProviderClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Competence.ConditionFactory.IsTimerDone
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IConditionReceiver>ConditionReceiver                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTimerObject*                     Timer                                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UIsTimerDoneCondition*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UIsTimerDoneCondition* UConditionFactory::IsTimerDone(TScriptInterface<class IConditionReceiver> ConditionReceiver, class UTimerObject* Timer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConditionFactory", "IsTimerDone");

	Params::ConditionFactory_IsTimerDone Parms{};

	Parms.ConditionReceiver = ConditionReceiver;
	Parms.Timer = Timer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Competence.ConditionFactory.Lingering
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IConditionReceiver>ConditionReceiver                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   timeToTrack                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULingeringModifierCondition*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULingeringModifierCondition* UConditionFactory::Lingering(TScriptInterface<class IConditionReceiver> ConditionReceiver, float timeToTrack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConditionFactory", "Lingering");

	Params::ConditionFactory_Lingering Parms{};

	Parms.ConditionReceiver = ConditionReceiver;
	Parms.timeToTrack = timeToTrack;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Competence.ConditionFactory.Not
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IConditionReceiver>ConditionReceiver                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNotModifierCondition*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNotModifierCondition* UConditionFactory::Not(TScriptInterface<class IConditionReceiver> ConditionReceiver)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConditionFactory", "Not");

	Params::ConditionFactory_Not Parms{};

	Parms.ConditionReceiver = ConditionReceiver;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Competence.ConditionFactory.OR
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IConditionReceiver>ConditionReceiver                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrModifierCondition*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrModifierCondition* UConditionFactory::OR(TScriptInterface<class IConditionReceiver> ConditionReceiver)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConditionFactory", "OR");

	Params::ConditionFactory_OR Parms{};

	Parms.ConditionReceiver = ConditionReceiver;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Competence.IsTimerDoneCondition.OnRep_Timer
// (Final, Native, Private)

void UIsTimerDoneCondition::OnRep_Timer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IsTimerDoneCondition", "OnRep_Timer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Competence.IsTimerDoneCondition.SetTimer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTimerObject*                     Timer                                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIsTimerDoneCondition::SetTimer(class UTimerObject* Timer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IsTimerDoneCondition", "SetTimer");

	Params::IsTimerDoneCondition_SetTimer Parms{};

	Parms.Timer = Timer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Competence.LingeringModifierCondition.OnTimerEnd
// (Final, Native, Private)

void ULingeringModifierCondition::OnTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LingeringModifierCondition", "OnTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}

}

