#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheK23

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "DataTableUtilities_structs.hpp"
#include "AnimationUtilities_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "StatSystem_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "DBDCompetence_classes.hpp"
#include "DBDCosmetic_classes.hpp"
#include "GameplayUtilities_classes.hpp"
#include "Competence_classes.hpp"
#include "DBDInteraction_classes.hpp"
#include "DBDAnimation_classes.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class TheK23.ActivateSuperMode
// 0x0070 (0x07E0 - 0x0770)
class UActivateSuperMode final : public UInteractionDefinition
{
public:
	uint8                                         Pad_768[0x8];                                      // 0x0768(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimationMontageDescriptor            _activationMontage;                                // 0x0770(0x0020)(Edit, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _activationDuration;                               // 0x0790(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _confirmationChargeDuration;                       // 0x07B8(0x0028)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivateSuperMode">();
	}
	static class UActivateSuperMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivateSuperMode>();
	}
};
static_assert(alignof(UActivateSuperMode) == 0x000010, "Wrong alignment on UActivateSuperMode");
static_assert(sizeof(UActivateSuperMode) == 0x0007E0, "Wrong size on UActivateSuperMode");
static_assert(offsetof(UActivateSuperMode, _activationMontage) == 0x000770, "Member 'UActivateSuperMode::_activationMontage' has a wrong offset!");
static_assert(offsetof(UActivateSuperMode, _activationDuration) == 0x000790, "Member 'UActivateSuperMode::_activationDuration' has a wrong offset!");
static_assert(offsetof(UActivateSuperMode, _confirmationChargeDuration) == 0x0007B8, "Member 'UActivateSuperMode::_confirmationChargeDuration' has a wrong offset!");

// Class TheK23.FlurryComboScoreComponent
// 0x0168 (0x0220 - 0x00B8)
class UFlurryComboScoreComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x1C];                                      // 0x00B8(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _comboScore;                                       // 0x00D4(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _timeAddedByComboRank;                             // 0x00D8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _timeForCombo;                                     // 0x0100(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _consecutiveHitsRequiredScore;                     // 0x0180(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<float>                                 _thresholds;                                       // 0x01A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<float>                                 _thresholdsScoreForAudio;                          // 0x01B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                   _comboScoreEvents;                                 // 0x01C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D8[0x40];                                     // 0x01D8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _comboExtendSuperModeStatusEffectClass;            // 0x0218(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_ComboScore() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlurryComboScoreComponent">();
	}
	static class UFlurryComboScoreComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlurryComboScoreComponent>();
	}
};
static_assert(alignof(UFlurryComboScoreComponent) == 0x000008, "Wrong alignment on UFlurryComboScoreComponent");
static_assert(sizeof(UFlurryComboScoreComponent) == 0x000220, "Wrong size on UFlurryComboScoreComponent");
static_assert(offsetof(UFlurryComboScoreComponent, _comboScore) == 0x0000D4, "Member 'UFlurryComboScoreComponent::_comboScore' has a wrong offset!");
static_assert(offsetof(UFlurryComboScoreComponent, _timeAddedByComboRank) == 0x0000D8, "Member 'UFlurryComboScoreComponent::_timeAddedByComboRank' has a wrong offset!");
static_assert(offsetof(UFlurryComboScoreComponent, _timeForCombo) == 0x000100, "Member 'UFlurryComboScoreComponent::_timeForCombo' has a wrong offset!");
static_assert(offsetof(UFlurryComboScoreComponent, _consecutiveHitsRequiredScore) == 0x000180, "Member 'UFlurryComboScoreComponent::_consecutiveHitsRequiredScore' has a wrong offset!");
static_assert(offsetof(UFlurryComboScoreComponent, _thresholds) == 0x0001A8, "Member 'UFlurryComboScoreComponent::_thresholds' has a wrong offset!");
static_assert(offsetof(UFlurryComboScoreComponent, _thresholdsScoreForAudio) == 0x0001B8, "Member 'UFlurryComboScoreComponent::_thresholdsScoreForAudio' has a wrong offset!");
static_assert(offsetof(UFlurryComboScoreComponent, _comboScoreEvents) == 0x0001C8, "Member 'UFlurryComboScoreComponent::_comboScoreEvents' has a wrong offset!");
static_assert(offsetof(UFlurryComboScoreComponent, _comboExtendSuperModeStatusEffectClass) == 0x000218, "Member 'UFlurryComboScoreComponent::_comboExtendSuperModeStatusEffectClass' has a wrong offset!");

// Class TheK23.FlurryOfKnives
// 0x0550 (0x0E10 - 0x08C0)
class UFlurryOfKnives final : public UChargeableInteractionDefinition
{
public:
	uint8                                         Pad_8C0[0x48];                                     // 0x08C0(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _replicatedNumOfStacksReduction;                   // 0x0908(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isSuperModeThrow;                                 // 0x090C(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90D[0x8B];                                     // 0x090D(0x008B)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffect*                          _selfSlowEffect;                                   // 0x0998(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _selfSlowStatusEffectClass;                        // 0x09A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _flurryOfKnivesEnterDuration;                      // 0x09A8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _flurryOfKnivesExitDuration;                       // 0x09D0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _chargeTime;                                       // 0x09F8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _baseTimeBetweenThrows;                            // 0x0A20(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _throwRateModifierByKnivesThrown;                  // 0x0AA0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _superModeDeactivationBuffer;                      // 0x0AA8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _superModeThrowRateModifier;                       // 0x0AD0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _knivesLaunchSpeed;                                // 0x0AF8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _convergencePointDistance;                         // 0x0B20(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _coneOfFireAngleCurve;                             // 0x0B48(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _consecutiveKnivesStacksDecayTime;                 // 0x0B50(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _maxConsecutiveKnivesStacks;                       // 0x0B78(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _movementSpeedByKnivesThrown;                      // 0x0BA0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _superModeBaseMovementSpeed;                       // 0x0BA8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _baseWalkSpeed;                                    // 0x0BD0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _recoilIntensityByKnivesThrown;                    // 0x0BF8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _recoilDuration;                                   // 0x0C00(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _recoilAngle;                                      // 0x0C28(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _maximumRecoilAngleVariation;                      // 0x0C50(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _rotationSpeedAdjustmentTime;                      // 0x0C78(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _aimingStanceRotationYawScaleAdjustment;           // 0x0CA0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _aimingStanceRotationPitchScaleAdjustment;         // 0x0CC8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _throwingRotationYawScaleAdjustment;               // 0x0CF0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _throwingRotationPitchScaleAdjustment;             // 0x0D18(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _aimingStanceGamepadRotationYawScaleAdjustment;    // 0x0D40(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _aimingStanceGamepadRotationPitchScaleAdjustment;  // 0x0D68(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _throwingGamepadRotationYawScaleAdjustment;        // 0x0D90(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _throwingGamepadRotationPitchScaleAdjustment;      // 0x0DB8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _aimingGamepadPitchCurve;                          // 0x0DE0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _aimingGamepadYawCurve;                            // 0x0DE8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _throwingGamepadPitchCurve;                        // 0x0DF0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _throwingGamepadYawCurve;                          // 0x0DF8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E00[0x10];                                     // 0x0E00(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_StartThrowing();
	void OnRep_NumOfStacksReduction();
	void Server_DecreaseConsecutiveKnivesStacks();
	void Server_StartThrowing();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlurryOfKnives">();
	}
	static class UFlurryOfKnives* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlurryOfKnives>();
	}
};
static_assert(alignof(UFlurryOfKnives) == 0x000010, "Wrong alignment on UFlurryOfKnives");
static_assert(sizeof(UFlurryOfKnives) == 0x000E10, "Wrong size on UFlurryOfKnives");
static_assert(offsetof(UFlurryOfKnives, _replicatedNumOfStacksReduction) == 0x000908, "Member 'UFlurryOfKnives::_replicatedNumOfStacksReduction' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _isSuperModeThrow) == 0x00090C, "Member 'UFlurryOfKnives::_isSuperModeThrow' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _selfSlowEffect) == 0x000998, "Member 'UFlurryOfKnives::_selfSlowEffect' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _selfSlowStatusEffectClass) == 0x0009A0, "Member 'UFlurryOfKnives::_selfSlowStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _flurryOfKnivesEnterDuration) == 0x0009A8, "Member 'UFlurryOfKnives::_flurryOfKnivesEnterDuration' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _flurryOfKnivesExitDuration) == 0x0009D0, "Member 'UFlurryOfKnives::_flurryOfKnivesExitDuration' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _chargeTime) == 0x0009F8, "Member 'UFlurryOfKnives::_chargeTime' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _baseTimeBetweenThrows) == 0x000A20, "Member 'UFlurryOfKnives::_baseTimeBetweenThrows' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _throwRateModifierByKnivesThrown) == 0x000AA0, "Member 'UFlurryOfKnives::_throwRateModifierByKnivesThrown' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _superModeDeactivationBuffer) == 0x000AA8, "Member 'UFlurryOfKnives::_superModeDeactivationBuffer' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _superModeThrowRateModifier) == 0x000AD0, "Member 'UFlurryOfKnives::_superModeThrowRateModifier' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _knivesLaunchSpeed) == 0x000AF8, "Member 'UFlurryOfKnives::_knivesLaunchSpeed' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _convergencePointDistance) == 0x000B20, "Member 'UFlurryOfKnives::_convergencePointDistance' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _coneOfFireAngleCurve) == 0x000B48, "Member 'UFlurryOfKnives::_coneOfFireAngleCurve' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _consecutiveKnivesStacksDecayTime) == 0x000B50, "Member 'UFlurryOfKnives::_consecutiveKnivesStacksDecayTime' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _maxConsecutiveKnivesStacks) == 0x000B78, "Member 'UFlurryOfKnives::_maxConsecutiveKnivesStacks' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _movementSpeedByKnivesThrown) == 0x000BA0, "Member 'UFlurryOfKnives::_movementSpeedByKnivesThrown' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _superModeBaseMovementSpeed) == 0x000BA8, "Member 'UFlurryOfKnives::_superModeBaseMovementSpeed' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _baseWalkSpeed) == 0x000BD0, "Member 'UFlurryOfKnives::_baseWalkSpeed' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _recoilIntensityByKnivesThrown) == 0x000BF8, "Member 'UFlurryOfKnives::_recoilIntensityByKnivesThrown' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _recoilDuration) == 0x000C00, "Member 'UFlurryOfKnives::_recoilDuration' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _recoilAngle) == 0x000C28, "Member 'UFlurryOfKnives::_recoilAngle' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _maximumRecoilAngleVariation) == 0x000C50, "Member 'UFlurryOfKnives::_maximumRecoilAngleVariation' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _rotationSpeedAdjustmentTime) == 0x000C78, "Member 'UFlurryOfKnives::_rotationSpeedAdjustmentTime' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _aimingStanceRotationYawScaleAdjustment) == 0x000CA0, "Member 'UFlurryOfKnives::_aimingStanceRotationYawScaleAdjustment' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _aimingStanceRotationPitchScaleAdjustment) == 0x000CC8, "Member 'UFlurryOfKnives::_aimingStanceRotationPitchScaleAdjustment' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _throwingRotationYawScaleAdjustment) == 0x000CF0, "Member 'UFlurryOfKnives::_throwingRotationYawScaleAdjustment' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _throwingRotationPitchScaleAdjustment) == 0x000D18, "Member 'UFlurryOfKnives::_throwingRotationPitchScaleAdjustment' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _aimingStanceGamepadRotationYawScaleAdjustment) == 0x000D40, "Member 'UFlurryOfKnives::_aimingStanceGamepadRotationYawScaleAdjustment' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _aimingStanceGamepadRotationPitchScaleAdjustment) == 0x000D68, "Member 'UFlurryOfKnives::_aimingStanceGamepadRotationPitchScaleAdjustment' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _throwingGamepadRotationYawScaleAdjustment) == 0x000D90, "Member 'UFlurryOfKnives::_throwingGamepadRotationYawScaleAdjustment' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _throwingGamepadRotationPitchScaleAdjustment) == 0x000DB8, "Member 'UFlurryOfKnives::_throwingGamepadRotationPitchScaleAdjustment' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _aimingGamepadPitchCurve) == 0x000DE0, "Member 'UFlurryOfKnives::_aimingGamepadPitchCurve' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _aimingGamepadYawCurve) == 0x000DE8, "Member 'UFlurryOfKnives::_aimingGamepadYawCurve' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _throwingGamepadPitchCurve) == 0x000DF0, "Member 'UFlurryOfKnives::_throwingGamepadPitchCurve' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _throwingGamepadYawCurve) == 0x000DF8, "Member 'UFlurryOfKnives::_throwingGamepadYawCurve' has a wrong offset!");

// Class TheK23.HexCrowdControl
// 0x0020 (0x0500 - 0x04E0)
class UHexCrowdControl final : public UHexPerk
{
public:
	int32                                         _maxNumVaultsBlocked[0x3];                         // 0x04E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4EC[0x4];                                      // 0x04EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AWindow>>         _authority_blockedVaults;                          // 0x04F0(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HexCrowdControl">();
	}
	static class UHexCrowdControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHexCrowdControl>();
	}
};
static_assert(alignof(UHexCrowdControl) == 0x000008, "Wrong alignment on UHexCrowdControl");
static_assert(sizeof(UHexCrowdControl) == 0x000500, "Wrong size on UHexCrowdControl");
static_assert(offsetof(UHexCrowdControl, _maxNumVaultsBlocked) == 0x0004E0, "Member 'UHexCrowdControl::_maxNumVaultsBlocked' has a wrong offset!");
static_assert(offsetof(UHexCrowdControl, _authority_blockedVaults) == 0x0004F0, "Member 'UHexCrowdControl::_authority_blockedVaults' has a wrong offset!");

// Class TheK23.TricksterChainedThrowsAddon
// 0x0008 (0x0308 - 0x0300)
class UTricksterChainedThrowsAddon : public UItemAddon
{
public:
	int32                                         _consecutiveHits;                                  // 0x0300(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _resetOnEnteringFlurryInteraction;                 // 0x0304(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_305[0x3];                                      // 0x0305(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ConsecutiveHits();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TricksterChainedThrowsAddon">();
	}
	static class UTricksterChainedThrowsAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTricksterChainedThrowsAddon>();
	}
};
static_assert(alignof(UTricksterChainedThrowsAddon) == 0x000008, "Wrong alignment on UTricksterChainedThrowsAddon");
static_assert(sizeof(UTricksterChainedThrowsAddon) == 0x000308, "Wrong size on UTricksterChainedThrowsAddon");
static_assert(offsetof(UTricksterChainedThrowsAddon, _consecutiveHits) == 0x000300, "Member 'UTricksterChainedThrowsAddon::_consecutiveHits' has a wrong offset!");
static_assert(offsetof(UTricksterChainedThrowsAddon, _resetOnEnteringFlurryInteraction) == 0x000304, "Member 'UTricksterChainedThrowsAddon::_resetOnEnteringFlurryInteraction' has a wrong offset!");

// Class TheK23.IridescentPhotocardAddon
// 0x0008 (0x0310 - 0x0308)
class UIridescentPhotocardAddon final : public UTricksterChainedThrowsAddon
{
public:
	float                                         _percentageGainedOnHit;                            // 0x0308(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _maxConsecutiveHits;                               // 0x030C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IridescentPhotocardAddon">();
	}
	static class UIridescentPhotocardAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIridescentPhotocardAddon>();
	}
};
static_assert(alignof(UIridescentPhotocardAddon) == 0x000008, "Wrong alignment on UIridescentPhotocardAddon");
static_assert(sizeof(UIridescentPhotocardAddon) == 0x000310, "Wrong size on UIridescentPhotocardAddon");
static_assert(offsetof(UIridescentPhotocardAddon, _percentageGainedOnHit) == 0x000308, "Member 'UIridescentPhotocardAddon::_percentageGainedOnHit' has a wrong offset!");
static_assert(offsetof(UIridescentPhotocardAddon, _maxConsecutiveHits) == 0x00030C, "Member 'UIridescentPhotocardAddon::_maxConsecutiveHits' has a wrong offset!");

// Class TheK23.K23PowerProgressPresentationComponent
// 0x0000 (0x00C0 - 0x00C0)
class UK23PowerProgressPresentationComponent final : public UPresentationItemProgressComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K23PowerProgressPresentationComponent">();
	}
	static class UK23PowerProgressPresentationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK23PowerProgressPresentationComponent>();
	}
};
static_assert(alignof(UK23PowerProgressPresentationComponent) == 0x000008, "Wrong alignment on UK23PowerProgressPresentationComponent");
static_assert(sizeof(UK23PowerProgressPresentationComponent) == 0x0000C0, "Wrong size on UK23PowerProgressPresentationComponent");

// Class TheK23.K23SurvivorCosmeticHelperActor
// 0x0018 (0x0370 - 0x0358)
class AK23SurvivorCosmeticHelperActor final : public ASurvivorCosmeticHelperActor
{
public:
	uint8                                         Pad_358[0x18];                                     // 0x0358(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_K23CamperHitByKnife(float lacerationPercentage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K23SurvivorCosmeticHelperActor">();
	}
	static class AK23SurvivorCosmeticHelperActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK23SurvivorCosmeticHelperActor>();
	}
};
static_assert(alignof(AK23SurvivorCosmeticHelperActor) == 0x000008, "Wrong alignment on AK23SurvivorCosmeticHelperActor");
static_assert(sizeof(AK23SurvivorCosmeticHelperActor) == 0x000370, "Wrong size on AK23SurvivorCosmeticHelperActor");

// Class TheK23.KnifeProjectile
// 0x00F0 (0x04C8 - 0x03D8)
class AKnifeProjectile final : public AKillerProjectile
{
public:
	class UPrimitiveComponent*                    _worldCollider;                                    // 0x03D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    _camperDetector;                                   // 0x03E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E8[0x10];                                     // 0x03E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class ADBDPlayer*>                       _playersAffectedThisThrow;                         // 0x03F8(0x0050)(NativeAccessSpecifierPrivate)
	class UPoolableProjectileComponent*           _poolableActorComponent;                           // 0x0448(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _knifeMaxRange;                                    // 0x0450(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _addonExplosionRadius;                             // 0x0478(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _numberOfAddonBounces;                             // 0x04A0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void BP_CosmeticOnAddonExplosion(const struct FVector& Location, const struct FVector& Normal);
	void BP_OnLaunchCosmetic(const struct FLaunchInfo& LaunchInfo, bool hasImpactOnLaunch);
	void BP_SetKnifeActive(bool Active);
	void OnProjectileBounce(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity);
	void OnWorldColliderHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void SetKnifeAcquired(bool acquired);

	float GetAddonExplosionRadius() const;
	bool KnifeCanPierceCampers() const;
	bool ShouldPlayRicochetSound() const;
	bool WasLaunchedDuringSuperMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KnifeProjectile">();
	}
	static class AKnifeProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKnifeProjectile>();
	}
};
static_assert(alignof(AKnifeProjectile) == 0x000008, "Wrong alignment on AKnifeProjectile");
static_assert(sizeof(AKnifeProjectile) == 0x0004C8, "Wrong size on AKnifeProjectile");
static_assert(offsetof(AKnifeProjectile, _worldCollider) == 0x0003D8, "Member 'AKnifeProjectile::_worldCollider' has a wrong offset!");
static_assert(offsetof(AKnifeProjectile, _camperDetector) == 0x0003E0, "Member 'AKnifeProjectile::_camperDetector' has a wrong offset!");
static_assert(offsetof(AKnifeProjectile, _playersAffectedThisThrow) == 0x0003F8, "Member 'AKnifeProjectile::_playersAffectedThisThrow' has a wrong offset!");
static_assert(offsetof(AKnifeProjectile, _poolableActorComponent) == 0x000448, "Member 'AKnifeProjectile::_poolableActorComponent' has a wrong offset!");
static_assert(offsetof(AKnifeProjectile, _knifeMaxRange) == 0x000450, "Member 'AKnifeProjectile::_knifeMaxRange' has a wrong offset!");
static_assert(offsetof(AKnifeProjectile, _addonExplosionRadius) == 0x000478, "Member 'AKnifeProjectile::_addonExplosionRadius' has a wrong offset!");
static_assert(offsetof(AKnifeProjectile, _numberOfAddonBounces) == 0x0004A0, "Member 'AKnifeProjectile::_numberOfAddonBounces' has a wrong offset!");

// Class TheK23.KnifeRack
// 0x0000 (0x02C8 - 0x02C8)
class AKnifeRack final : public ABaseLockerItem
{
public:
	void OnReloadEnded(class ADBDPlayer* Player);
	void OnReloadMontageStarted(float actionSpeedMultiplier, class ADBDPlayer* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KnifeRack">();
	}
	static class AKnifeRack* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKnifeRack>();
	}
};
static_assert(alignof(AKnifeRack) == 0x000008, "Wrong alignment on AKnifeRack");
static_assert(sizeof(AKnifeRack) == 0x0002C8, "Wrong size on AKnifeRack");

// Class TheK23.KnivesLauncher
// 0x0108 (0x02B0 - 0x01A8)
class UKnivesLauncher final : public UKillerProjectileLauncher
{
public:
	struct FDBDTunableRowHandle                   _knifeSpawnOffset;                                 // 0x01A8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _knifeSpawnForwardOffset;                          // 0x01D0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _launchSpeed;                                      // 0x01F8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _maxAmmoTunable;                                   // 0x0220(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isInSuperModeThrow;                               // 0x02A8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A9[0x7];                                      // 0x02A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetLocallyPredictedAmmo() const;
	class AThrowingKnives* GetPower() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KnivesLauncher">();
	}
	static class UKnivesLauncher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKnivesLauncher>();
	}
};
static_assert(alignof(UKnivesLauncher) == 0x000008, "Wrong alignment on UKnivesLauncher");
static_assert(sizeof(UKnivesLauncher) == 0x0002B0, "Wrong size on UKnivesLauncher");
static_assert(offsetof(UKnivesLauncher, _knifeSpawnOffset) == 0x0001A8, "Member 'UKnivesLauncher::_knifeSpawnOffset' has a wrong offset!");
static_assert(offsetof(UKnivesLauncher, _knifeSpawnForwardOffset) == 0x0001D0, "Member 'UKnivesLauncher::_knifeSpawnForwardOffset' has a wrong offset!");
static_assert(offsetof(UKnivesLauncher, _launchSpeed) == 0x0001F8, "Member 'UKnivesLauncher::_launchSpeed' has a wrong offset!");
static_assert(offsetof(UKnivesLauncher, _maxAmmoTunable) == 0x000220, "Member 'UKnivesLauncher::_maxAmmoTunable' has a wrong offset!");
static_assert(offsetof(UKnivesLauncher, _isInSuperModeThrow) == 0x0002A8, "Member 'UKnivesLauncher::_isInSuperModeThrow' has a wrong offset!");

// Class TheK23.KnivesProvider
// 0x0008 (0x0120 - 0x0118)
class UKnivesProvider final : public UAuthoritativeActorPoolComponent
{
public:
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KnivesProvider">();
	}
	static class UKnivesProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKnivesProvider>();
	}
};
static_assert(alignof(UKnivesProvider) == 0x000008, "Wrong alignment on UKnivesProvider");
static_assert(sizeof(UKnivesProvider) == 0x000120, "Wrong size on UKnivesProvider");

// Class TheK23.LacerationComponent
// 0x0428 (0x04E0 - 0x00B8)
class ULacerationComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x38];                                      // 0x00B8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _laceration;                                       // 0x00F0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F4[0xC];                                       // 0x00F4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffect*                          _onHitSpeedBoost;                                  // 0x0100(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _lacerationOnHitSpeedBoostStatusEffectClass;       // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x18];                                     // 0x0110(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTunableStat                           _maxLaceration;                                    // 0x0128(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _lacerationExplosionDamage;                        // 0x01A8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _lacerationRegressionPerSecond;                    // 0x01D0(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _lacerationRegressionPerSecondWhileRunning;        // 0x0250(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _speedBoostIntensity;                              // 0x02D0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _speedBoostDuration;                               // 0x02F8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _stopTickingRegressionWhileInjured;                // 0x0320(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _stopTickingRegressionWhileInChase;                // 0x0348(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _stopTickingRegressionWithinTerrorRadius;          // 0x0370(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _timeBeforeLacerationDecayStarts;                  // 0x0398(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _regressionBufferTimerAlwaysTicks;                 // 0x0418(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _lacerationToRemoveOnBasicAttack;                  // 0x0440(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _thresholdForGraceTimerScoreEvent;                 // 0x0468(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _minThresholdForLowLacerationScoreEvent;           // 0x0490(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _maxThresholdForLowLacerationScoreEvent;           // 0x04B8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void Cosmetic_OnKnifeHit(float lacerationPercent, class AKiller* owningKiller, bool isDangerous, bool causedDamage, bool CausedKO, const struct FVector& ImpactNormal);
	void Multicast_KnifeHit(float newLaceration, class AKiller* owningKiller, bool causedDamage, bool CausedKO, const struct FVector& impactLocation, const struct FVector& ImpactNormal);
	void OnRepLaceration(float oldLaceration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LacerationComponent">();
	}
	static class ULacerationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULacerationComponent>();
	}
};
static_assert(alignof(ULacerationComponent) == 0x000008, "Wrong alignment on ULacerationComponent");
static_assert(sizeof(ULacerationComponent) == 0x0004E0, "Wrong size on ULacerationComponent");
static_assert(offsetof(ULacerationComponent, _laceration) == 0x0000F0, "Member 'ULacerationComponent::_laceration' has a wrong offset!");
static_assert(offsetof(ULacerationComponent, _onHitSpeedBoost) == 0x000100, "Member 'ULacerationComponent::_onHitSpeedBoost' has a wrong offset!");
static_assert(offsetof(ULacerationComponent, _lacerationOnHitSpeedBoostStatusEffectClass) == 0x000108, "Member 'ULacerationComponent::_lacerationOnHitSpeedBoostStatusEffectClass' has a wrong offset!");
static_assert(offsetof(ULacerationComponent, _maxLaceration) == 0x000128, "Member 'ULacerationComponent::_maxLaceration' has a wrong offset!");
static_assert(offsetof(ULacerationComponent, _lacerationExplosionDamage) == 0x0001A8, "Member 'ULacerationComponent::_lacerationExplosionDamage' has a wrong offset!");
static_assert(offsetof(ULacerationComponent, _lacerationRegressionPerSecond) == 0x0001D0, "Member 'ULacerationComponent::_lacerationRegressionPerSecond' has a wrong offset!");
static_assert(offsetof(ULacerationComponent, _lacerationRegressionPerSecondWhileRunning) == 0x000250, "Member 'ULacerationComponent::_lacerationRegressionPerSecondWhileRunning' has a wrong offset!");
static_assert(offsetof(ULacerationComponent, _speedBoostIntensity) == 0x0002D0, "Member 'ULacerationComponent::_speedBoostIntensity' has a wrong offset!");
static_assert(offsetof(ULacerationComponent, _speedBoostDuration) == 0x0002F8, "Member 'ULacerationComponent::_speedBoostDuration' has a wrong offset!");
static_assert(offsetof(ULacerationComponent, _stopTickingRegressionWhileInjured) == 0x000320, "Member 'ULacerationComponent::_stopTickingRegressionWhileInjured' has a wrong offset!");
static_assert(offsetof(ULacerationComponent, _stopTickingRegressionWhileInChase) == 0x000348, "Member 'ULacerationComponent::_stopTickingRegressionWhileInChase' has a wrong offset!");
static_assert(offsetof(ULacerationComponent, _stopTickingRegressionWithinTerrorRadius) == 0x000370, "Member 'ULacerationComponent::_stopTickingRegressionWithinTerrorRadius' has a wrong offset!");
static_assert(offsetof(ULacerationComponent, _timeBeforeLacerationDecayStarts) == 0x000398, "Member 'ULacerationComponent::_timeBeforeLacerationDecayStarts' has a wrong offset!");
static_assert(offsetof(ULacerationComponent, _regressionBufferTimerAlwaysTicks) == 0x000418, "Member 'ULacerationComponent::_regressionBufferTimerAlwaysTicks' has a wrong offset!");
static_assert(offsetof(ULacerationComponent, _lacerationToRemoveOnBasicAttack) == 0x000440, "Member 'ULacerationComponent::_lacerationToRemoveOnBasicAttack' has a wrong offset!");
static_assert(offsetof(ULacerationComponent, _thresholdForGraceTimerScoreEvent) == 0x000468, "Member 'ULacerationComponent::_thresholdForGraceTimerScoreEvent' has a wrong offset!");
static_assert(offsetof(ULacerationComponent, _minThresholdForLowLacerationScoreEvent) == 0x000490, "Member 'ULacerationComponent::_minThresholdForLowLacerationScoreEvent' has a wrong offset!");
static_assert(offsetof(ULacerationComponent, _maxThresholdForLowLacerationScoreEvent) == 0x0004B8, "Member 'ULacerationComponent::_maxThresholdForLowLacerationScoreEvent' has a wrong offset!");

// Class TheK23.BaseLacerationLevelCondition
// 0x0000 (0x00F0 - 0x00F0)
class UBaseLacerationLevelCondition : public UEventDrivenModifierCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseLacerationLevelCondition">();
	}
	static class UBaseLacerationLevelCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseLacerationLevelCondition>();
	}
};
static_assert(alignof(UBaseLacerationLevelCondition) == 0x000008, "Wrong alignment on UBaseLacerationLevelCondition");
static_assert(sizeof(UBaseLacerationLevelCondition) == 0x0000F0, "Wrong size on UBaseLacerationLevelCondition");

// Class TheK23.LacerationLevelCondition
// 0x0008 (0x00F8 - 0x00F0)
class ULacerationLevelCondition final : public UBaseLacerationLevelCondition
{
public:
	float                                         _lacerationLevelRequired;                          // 0x00F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LacerationLevelCondition">();
	}
	static class ULacerationLevelCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULacerationLevelCondition>();
	}
};
static_assert(alignof(ULacerationLevelCondition) == 0x000008, "Wrong alignment on ULacerationLevelCondition");
static_assert(sizeof(ULacerationLevelCondition) == 0x0000F8, "Wrong size on ULacerationLevelCondition");
static_assert(offsetof(ULacerationLevelCondition, _lacerationLevelRequired) == 0x0000F0, "Member 'ULacerationLevelCondition::_lacerationLevelRequired' has a wrong offset!");

// Class TheK23.LacerationAlmostFullCondition
// 0x0008 (0x00F8 - 0x00F0)
class ULacerationAlmostFullCondition final : public UBaseLacerationLevelCondition
{
public:
	float                                         _missingLacerationThreshold;                       // 0x00F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LacerationAlmostFullCondition">();
	}
	static class ULacerationAlmostFullCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULacerationAlmostFullCondition>();
	}
};
static_assert(alignof(ULacerationAlmostFullCondition) == 0x000008, "Wrong alignment on ULacerationAlmostFullCondition");
static_assert(sizeof(ULacerationAlmostFullCondition) == 0x0000F8, "Wrong size on ULacerationAlmostFullCondition");
static_assert(offsetof(ULacerationAlmostFullCondition, _missingLacerationThreshold) == 0x0000F0, "Member 'ULacerationAlmostFullCondition::_missingLacerationThreshold' has a wrong offset!");

// Class TheK23.NoWayOut
// 0x0030 (0x0490 - 0x0460)
class UNoWayOut final : public UPerk
{
public:
	float                                         _exitGatePanelBlockBaseDuration[0x3];              // 0x0460(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _exitGatePanelBlockDurationPerToken[0x3];          // 0x046C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ASurvivor*>                      _hookedSurvivors;                                  // 0x0478(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_488[0x8];                                      // 0x0488(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_TriggerLoudNoise(class ADBDPlayer* Instigator, class AEscapeDoor* EscapeDoor);

	float GetExitGatePanelBlockBaseDurationAtLevel() const;
	float GetExitGatePanelBlockDurationPerTokenAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NoWayOut">();
	}
	static class UNoWayOut* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNoWayOut>();
	}
};
static_assert(alignof(UNoWayOut) == 0x000008, "Wrong alignment on UNoWayOut");
static_assert(sizeof(UNoWayOut) == 0x000490, "Wrong size on UNoWayOut");
static_assert(offsetof(UNoWayOut, _exitGatePanelBlockBaseDuration) == 0x000460, "Member 'UNoWayOut::_exitGatePanelBlockBaseDuration' has a wrong offset!");
static_assert(offsetof(UNoWayOut, _exitGatePanelBlockDurationPerToken) == 0x00046C, "Member 'UNoWayOut::_exitGatePanelBlockDurationPerToken' has a wrong offset!");
static_assert(offsetof(UNoWayOut, _hookedSurvivors) == 0x000478, "Member 'UNoWayOut::_hookedSurvivors' has a wrong offset!");

// Class TheK23.ReloadKnives
// 0x0000 (0x07A0 - 0x07A0)
class UReloadKnives final : public UBaseLockerInteraction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReloadKnives">();
	}
	static class UReloadKnives* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReloadKnives>();
	}
};
static_assert(alignof(UReloadKnives) == 0x000010, "Wrong alignment on UReloadKnives");
static_assert(sizeof(UReloadKnives) == 0x0007A0, "Wrong size on UReloadKnives");

// Class TheK23.Starstruck
// 0x0128 (0x0588 - 0x0460)
class UStarstruck final : public UPerk
{
public:
	float                                         _exposedEffectDuration[0x3];                       // 0x0460(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _perkCooldownDuration[0x3];                        // 0x046C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<TWeakObjectPtr<class ASurvivor>, TWeakObjectPtr<class UStatusEffect>> _survivorExposedEffects; // 0x0478(0x0050)(ExportObject, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C8[0xB8];                                     // 0x04C8(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _exposedEffectClass;                               // 0x0580(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	float GetExposedEffectDurationAtLevel() const;
	float GetPerkCooldownDurationAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Starstruck">();
	}
	static class UStarstruck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStarstruck>();
	}
};
static_assert(alignof(UStarstruck) == 0x000008, "Wrong alignment on UStarstruck");
static_assert(sizeof(UStarstruck) == 0x000588, "Wrong size on UStarstruck");
static_assert(offsetof(UStarstruck, _exposedEffectDuration) == 0x000460, "Member 'UStarstruck::_exposedEffectDuration' has a wrong offset!");
static_assert(offsetof(UStarstruck, _perkCooldownDuration) == 0x00046C, "Member 'UStarstruck::_perkCooldownDuration' has a wrong offset!");
static_assert(offsetof(UStarstruck, _survivorExposedEffects) == 0x000478, "Member 'UStarstruck::_survivorExposedEffects' has a wrong offset!");
static_assert(offsetof(UStarstruck, _exposedEffectClass) == 0x000580, "Member 'UStarstruck::_exposedEffectClass' has a wrong offset!");

// Class TheK23.SuperModeDeactivation
// 0x0020 (0x0790 - 0x0770)
class USuperModeDeactivation final : public UInteractionDefinition
{
public:
	struct FDBDTunableRowHandle                   _deactivationDuration;                             // 0x0768(0x0028)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SuperModeDeactivation">();
	}
	static class USuperModeDeactivation* GetDefaultObj()
	{
		return GetDefaultObjImpl<USuperModeDeactivation>();
	}
};
static_assert(alignof(USuperModeDeactivation) == 0x000010, "Wrong alignment on USuperModeDeactivation");
static_assert(sizeof(USuperModeDeactivation) == 0x000790, "Wrong size on USuperModeDeactivation");
static_assert(offsetof(USuperModeDeactivation, _deactivationDuration) == 0x000768, "Member 'USuperModeDeactivation::_deactivationDuration' has a wrong offset!");

// Class TheK23.ThrowingKnives
// 0x00A8 (0x0600 - 0x0558)
class AThrowingKnives final : public ACollectable
{
public:
	uint8                                         Pad_558[0x40];                                     // 0x0558(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UFlurryComboScoreComponent*             _flurryScoreComponent;                             // 0x0598(0x0008)(Edit, ExportObject, Net, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTricksterSuperModeComponent*           _superModeComponent;                               // 0x05A0(0x0008)(Edit, ExportObject, Net, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK23PowerProgressPresentationComponent* _superModeChargePresentationComponent;             // 0x05A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPowerChargeComponent*                  _superModeChargeComponent;                         // 0x05B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _tricksterOutOfAmmoStatusEffectClass;              // 0x05B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UKnivesProvider*                        _knivesProvider;                                   // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UKnivesLauncher*                        _knivesLauncher;                                   // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ULacerationComponent>       _lacerationComponentClass;                         // 0x05D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UReloadKnives>              _reloadInteractionClass;                           // 0x05D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minimumTimeBetweenBroadcast;                      // 0x05E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E4[0x1C];                                     // 0x05E4(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_SpawnReloadInteractionOnLockers();
	void Cosmetic_OnComboFinished(bool isSRankCombo);
	void Cosmetic_OnComboScoreChanged(float scoreNormalizedForAudio);
	void Cosmetic_OnLaunch();
	void Cosmetic_OnUsePowerWhenInCooldown();
	void Cosmetic_OnUsePowerWhenOutOfAmmo();
	void Multicast_OnUsePowerWhenInCooldown();
	void Multicast_OnUsePowerWhenOutOfAmmo();
	void OnItemUsedStateChanged(bool Pressed);

	class UKnivesLauncher* GetLauncher() const;
	class AKiller* GetSlasher() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThrowingKnives">();
	}
	static class AThrowingKnives* GetDefaultObj()
	{
		return GetDefaultObjImpl<AThrowingKnives>();
	}
};
static_assert(alignof(AThrowingKnives) == 0x000008, "Wrong alignment on AThrowingKnives");
static_assert(sizeof(AThrowingKnives) == 0x000600, "Wrong size on AThrowingKnives");
static_assert(offsetof(AThrowingKnives, _flurryScoreComponent) == 0x000598, "Member 'AThrowingKnives::_flurryScoreComponent' has a wrong offset!");
static_assert(offsetof(AThrowingKnives, _superModeComponent) == 0x0005A0, "Member 'AThrowingKnives::_superModeComponent' has a wrong offset!");
static_assert(offsetof(AThrowingKnives, _superModeChargePresentationComponent) == 0x0005A8, "Member 'AThrowingKnives::_superModeChargePresentationComponent' has a wrong offset!");
static_assert(offsetof(AThrowingKnives, _superModeChargeComponent) == 0x0005B0, "Member 'AThrowingKnives::_superModeChargeComponent' has a wrong offset!");
static_assert(offsetof(AThrowingKnives, _tricksterOutOfAmmoStatusEffectClass) == 0x0005B8, "Member 'AThrowingKnives::_tricksterOutOfAmmoStatusEffectClass' has a wrong offset!");
static_assert(offsetof(AThrowingKnives, _knivesProvider) == 0x0005C0, "Member 'AThrowingKnives::_knivesProvider' has a wrong offset!");
static_assert(offsetof(AThrowingKnives, _knivesLauncher) == 0x0005C8, "Member 'AThrowingKnives::_knivesLauncher' has a wrong offset!");
static_assert(offsetof(AThrowingKnives, _lacerationComponentClass) == 0x0005D0, "Member 'AThrowingKnives::_lacerationComponentClass' has a wrong offset!");
static_assert(offsetof(AThrowingKnives, _reloadInteractionClass) == 0x0005D8, "Member 'AThrowingKnives::_reloadInteractionClass' has a wrong offset!");
static_assert(offsetof(AThrowingKnives, _minimumTimeBetweenBroadcast) == 0x0005E0, "Member 'AThrowingKnives::_minimumTimeBetweenBroadcast' has a wrong offset!");

// Class TheK23.ThrowingKnivesHitSubAnimInstance
// 0x0050 (0x0630 - 0x05E0)
class UThrowingKnivesHitSubAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	uint8                                         Pad_5E0[0x8];                                      // 0x05E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _hitByKnifeTrigger;                                // 0x05E8(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _knifeHitCausedKOTrigger;                          // 0x05E9(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _knifeHitCausedDamageTrigger;                      // 0x05EA(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _useAlternateHitReactionState;                     // 0x05EB(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _knifeHitStateHitAngle;                            // 0x05EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _alternateKnifeHitStateHitAngle;                   // 0x05F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrawling;                                       // 0x05F4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hitByKnifeTriggerEventDriven;                     // 0x05F5(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _knifeHitCausedDamageTriggerEventDriven;           // 0x05F6(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _knifeHitCausedKOTriggerEventDriven;               // 0x05F7(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F8[0x38];                                     // 0x05F8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThrowingKnivesHitSubAnimInstance">();
	}
	static class UThrowingKnivesHitSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThrowingKnivesHitSubAnimInstance>();
	}
};
static_assert(alignof(UThrowingKnivesHitSubAnimInstance) == 0x000010, "Wrong alignment on UThrowingKnivesHitSubAnimInstance");
static_assert(sizeof(UThrowingKnivesHitSubAnimInstance) == 0x000630, "Wrong size on UThrowingKnivesHitSubAnimInstance");
static_assert(offsetof(UThrowingKnivesHitSubAnimInstance, _hitByKnifeTrigger) == 0x0005E8, "Member 'UThrowingKnivesHitSubAnimInstance::_hitByKnifeTrigger' has a wrong offset!");
static_assert(offsetof(UThrowingKnivesHitSubAnimInstance, _knifeHitCausedKOTrigger) == 0x0005E9, "Member 'UThrowingKnivesHitSubAnimInstance::_knifeHitCausedKOTrigger' has a wrong offset!");
static_assert(offsetof(UThrowingKnivesHitSubAnimInstance, _knifeHitCausedDamageTrigger) == 0x0005EA, "Member 'UThrowingKnivesHitSubAnimInstance::_knifeHitCausedDamageTrigger' has a wrong offset!");
static_assert(offsetof(UThrowingKnivesHitSubAnimInstance, _useAlternateHitReactionState) == 0x0005EB, "Member 'UThrowingKnivesHitSubAnimInstance::_useAlternateHitReactionState' has a wrong offset!");
static_assert(offsetof(UThrowingKnivesHitSubAnimInstance, _knifeHitStateHitAngle) == 0x0005EC, "Member 'UThrowingKnivesHitSubAnimInstance::_knifeHitStateHitAngle' has a wrong offset!");
static_assert(offsetof(UThrowingKnivesHitSubAnimInstance, _alternateKnifeHitStateHitAngle) == 0x0005F0, "Member 'UThrowingKnivesHitSubAnimInstance::_alternateKnifeHitStateHitAngle' has a wrong offset!");
static_assert(offsetof(UThrowingKnivesHitSubAnimInstance, _isCrawling) == 0x0005F4, "Member 'UThrowingKnivesHitSubAnimInstance::_isCrawling' has a wrong offset!");
static_assert(offsetof(UThrowingKnivesHitSubAnimInstance, _hitByKnifeTriggerEventDriven) == 0x0005F5, "Member 'UThrowingKnivesHitSubAnimInstance::_hitByKnifeTriggerEventDriven' has a wrong offset!");
static_assert(offsetof(UThrowingKnivesHitSubAnimInstance, _knifeHitCausedDamageTriggerEventDriven) == 0x0005F6, "Member 'UThrowingKnivesHitSubAnimInstance::_knifeHitCausedDamageTriggerEventDriven' has a wrong offset!");
static_assert(offsetof(UThrowingKnivesHitSubAnimInstance, _knifeHitCausedKOTriggerEventDriven) == 0x0005F7, "Member 'UThrowingKnivesHitSubAnimInstance::_knifeHitCausedKOTriggerEventDriven' has a wrong offset!");

// Class TheK23.TricksterAnimInstance
// 0x0080 (0x07A0 - 0x0720)
class UTricksterAnimInstance final : public UKillerAnimInstance
{
public:
	bool                                          _isAiming;                                         // 0x0720(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_721[0x3];                                      // 0x0721(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _isThrowInputPressed;                              // 0x0724(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isThrowingWithLeftArm;                            // 0x0728(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isThrowingWithRightArm;                           // 0x0729(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_72A[0x2];                                      // 0x072A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _throwPlayRate;                                    // 0x072C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _baseThrowDuration;                                // 0x0730(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _consecutiveKnivesThrownStacks;                    // 0x0734(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _timeSinceLastKnifeLaunched;                       // 0x0738(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _currentAmmoCount;                                 // 0x073C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInSuperMode;                                    // 0x0740(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInActivation;                                   // 0x0741(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_742[0x2];                                      // 0x0742(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _activationDuration;                               // 0x0744(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInDeactivation;                                 // 0x0748(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_749[0x3];                                      // 0x0749(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _deactivationDuration;                             // 0x074C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isSwappingInteraction;                            // 0x0750(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInAimingInteraction;                            // 0x0751(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_752[0x46];                                     // 0x0752(0x0046)(Fixing Size After Last Property [ Dumper-7 ])
	class AThrowingKnives*                        _throwingKnives;                                   // 0x0798(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TricksterAnimInstance">();
	}
	static class UTricksterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTricksterAnimInstance>();
	}
};
static_assert(alignof(UTricksterAnimInstance) == 0x000010, "Wrong alignment on UTricksterAnimInstance");
static_assert(sizeof(UTricksterAnimInstance) == 0x0007A0, "Wrong size on UTricksterAnimInstance");
static_assert(offsetof(UTricksterAnimInstance, _isAiming) == 0x000720, "Member 'UTricksterAnimInstance::_isAiming' has a wrong offset!");
static_assert(offsetof(UTricksterAnimInstance, _isThrowInputPressed) == 0x000724, "Member 'UTricksterAnimInstance::_isThrowInputPressed' has a wrong offset!");
static_assert(offsetof(UTricksterAnimInstance, _isThrowingWithLeftArm) == 0x000728, "Member 'UTricksterAnimInstance::_isThrowingWithLeftArm' has a wrong offset!");
static_assert(offsetof(UTricksterAnimInstance, _isThrowingWithRightArm) == 0x000729, "Member 'UTricksterAnimInstance::_isThrowingWithRightArm' has a wrong offset!");
static_assert(offsetof(UTricksterAnimInstance, _throwPlayRate) == 0x00072C, "Member 'UTricksterAnimInstance::_throwPlayRate' has a wrong offset!");
static_assert(offsetof(UTricksterAnimInstance, _baseThrowDuration) == 0x000730, "Member 'UTricksterAnimInstance::_baseThrowDuration' has a wrong offset!");
static_assert(offsetof(UTricksterAnimInstance, _consecutiveKnivesThrownStacks) == 0x000734, "Member 'UTricksterAnimInstance::_consecutiveKnivesThrownStacks' has a wrong offset!");
static_assert(offsetof(UTricksterAnimInstance, _timeSinceLastKnifeLaunched) == 0x000738, "Member 'UTricksterAnimInstance::_timeSinceLastKnifeLaunched' has a wrong offset!");
static_assert(offsetof(UTricksterAnimInstance, _currentAmmoCount) == 0x00073C, "Member 'UTricksterAnimInstance::_currentAmmoCount' has a wrong offset!");
static_assert(offsetof(UTricksterAnimInstance, _isInSuperMode) == 0x000740, "Member 'UTricksterAnimInstance::_isInSuperMode' has a wrong offset!");
static_assert(offsetof(UTricksterAnimInstance, _isInActivation) == 0x000741, "Member 'UTricksterAnimInstance::_isInActivation' has a wrong offset!");
static_assert(offsetof(UTricksterAnimInstance, _activationDuration) == 0x000744, "Member 'UTricksterAnimInstance::_activationDuration' has a wrong offset!");
static_assert(offsetof(UTricksterAnimInstance, _isInDeactivation) == 0x000748, "Member 'UTricksterAnimInstance::_isInDeactivation' has a wrong offset!");
static_assert(offsetof(UTricksterAnimInstance, _deactivationDuration) == 0x00074C, "Member 'UTricksterAnimInstance::_deactivationDuration' has a wrong offset!");
static_assert(offsetof(UTricksterAnimInstance, _isSwappingInteraction) == 0x000750, "Member 'UTricksterAnimInstance::_isSwappingInteraction' has a wrong offset!");
static_assert(offsetof(UTricksterAnimInstance, _isInAimingInteraction) == 0x000751, "Member 'UTricksterAnimInstance::_isInAimingInteraction' has a wrong offset!");
static_assert(offsetof(UTricksterAnimInstance, _throwingKnives) == 0x000798, "Member 'UTricksterAnimInstance::_throwingKnives' has a wrong offset!");

// Class TheK23.TricksterCharacterVFXInterface
// 0x0000 (0x0000 - 0x0000)
class ITricksterCharacterVFXInterface final
{
public:
	void HideWeapon();
	void SetIsInCooldown(bool isInCooldown);
	void SetIsSuperModeReady(bool isSuperModeReady);
	void SetKnivesVisibility(bool leftKnife, bool rightKnife);
	void SetSuperModeActive(bool Active);
	void ShowWeapon();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TricksterCharacterVFXInterface">();
	}
	static class ITricksterCharacterVFXInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITricksterCharacterVFXInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITricksterCharacterVFXInterface) == 0x000001, "Wrong alignment on ITricksterCharacterVFXInterface");
static_assert(sizeof(ITricksterCharacterVFXInterface) == 0x000001, "Wrong size on ITricksterCharacterVFXInterface");

// Class TheK23.TricksterSuperModeComponent
// 0x0228 (0x02E0 - 0x00B8)
class UTricksterSuperModeComponent final : public UActorComponent
{
public:
	bool                                          _isInSuperMode;                                    // 0x00B8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isSuperModeReady;                                 // 0x00B9(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isInCooldown;                                     // 0x00BA(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BB[0xD];                                       // 0x00BB(0x000D)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _chargesToAddOnKnifeHit;                           // 0x00C8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _superModeMaxCharge;                               // 0x00F0(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _superModeReadyDepletionPerSecond;                 // 0x0170(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _superModeActiveDuration;                          // 0x0198(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_218[0x60];                                     // 0x0218(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _superModeCooldown;                                // 0x0278(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _shouldDisableFlurryDuringCooldown;                // 0x02A0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C8[0x10];                                     // 0x02C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _comboExtendSuperModeStatusEffectClass;            // 0x02D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void InitSuperModeMaxCharge();
	void OnRepIsInCooldown();
	void OnRepIsInSuperMode();
	void OnRepIsSuperModeReady();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TricksterSuperModeComponent">();
	}
	static class UTricksterSuperModeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTricksterSuperModeComponent>();
	}
};
static_assert(alignof(UTricksterSuperModeComponent) == 0x000008, "Wrong alignment on UTricksterSuperModeComponent");
static_assert(sizeof(UTricksterSuperModeComponent) == 0x0002E0, "Wrong size on UTricksterSuperModeComponent");
static_assert(offsetof(UTricksterSuperModeComponent, _isInSuperMode) == 0x0000B8, "Member 'UTricksterSuperModeComponent::_isInSuperMode' has a wrong offset!");
static_assert(offsetof(UTricksterSuperModeComponent, _isSuperModeReady) == 0x0000B9, "Member 'UTricksterSuperModeComponent::_isSuperModeReady' has a wrong offset!");
static_assert(offsetof(UTricksterSuperModeComponent, _isInCooldown) == 0x0000BA, "Member 'UTricksterSuperModeComponent::_isInCooldown' has a wrong offset!");
static_assert(offsetof(UTricksterSuperModeComponent, _chargesToAddOnKnifeHit) == 0x0000C8, "Member 'UTricksterSuperModeComponent::_chargesToAddOnKnifeHit' has a wrong offset!");
static_assert(offsetof(UTricksterSuperModeComponent, _superModeMaxCharge) == 0x0000F0, "Member 'UTricksterSuperModeComponent::_superModeMaxCharge' has a wrong offset!");
static_assert(offsetof(UTricksterSuperModeComponent, _superModeReadyDepletionPerSecond) == 0x000170, "Member 'UTricksterSuperModeComponent::_superModeReadyDepletionPerSecond' has a wrong offset!");
static_assert(offsetof(UTricksterSuperModeComponent, _superModeActiveDuration) == 0x000198, "Member 'UTricksterSuperModeComponent::_superModeActiveDuration' has a wrong offset!");
static_assert(offsetof(UTricksterSuperModeComponent, _superModeCooldown) == 0x000278, "Member 'UTricksterSuperModeComponent::_superModeCooldown' has a wrong offset!");
static_assert(offsetof(UTricksterSuperModeComponent, _shouldDisableFlurryDuringCooldown) == 0x0002A0, "Member 'UTricksterSuperModeComponent::_shouldDisableFlurryDuringCooldown' has a wrong offset!");
static_assert(offsetof(UTricksterSuperModeComponent, _comboExtendSuperModeStatusEffectClass) == 0x0002D8, "Member 'UTricksterSuperModeComponent::_comboExtendSuperModeStatusEffectClass' has a wrong offset!");

// Class TheK23.TriggerTimerOnLacerationAlmostFullEffect
// 0x0010 (0x03A8 - 0x0398)
class UTriggerTimerOnLacerationAlmostFullEffect final : public UStatusEffect
{
public:
	class ULacerationComponent*                   _lacerationComponent;                              // 0x0398(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _duration;                                         // 0x03A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A4[0x4];                                      // 0x03A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TriggerTimerOnLacerationAlmostFullEffect">();
	}
	static class UTriggerTimerOnLacerationAlmostFullEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTriggerTimerOnLacerationAlmostFullEffect>();
	}
};
static_assert(alignof(UTriggerTimerOnLacerationAlmostFullEffect) == 0x000008, "Wrong alignment on UTriggerTimerOnLacerationAlmostFullEffect");
static_assert(sizeof(UTriggerTimerOnLacerationAlmostFullEffect) == 0x0003A8, "Wrong size on UTriggerTimerOnLacerationAlmostFullEffect");
static_assert(offsetof(UTriggerTimerOnLacerationAlmostFullEffect, _lacerationComponent) == 0x000398, "Member 'UTriggerTimerOnLacerationAlmostFullEffect::_lacerationComponent' has a wrong offset!");
static_assert(offsetof(UTriggerTimerOnLacerationAlmostFullEffect, _duration) == 0x0003A0, "Member 'UTriggerTimerOnLacerationAlmostFullEffect::_duration' has a wrong offset!");

}

