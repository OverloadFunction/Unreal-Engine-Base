#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DBDCompetence

#include "Basic.hpp"

#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "DBDSharedTypes_structs.hpp"
#include "DBDSharedTypes_classes.hpp"
#include "DBDCompetence_structs.hpp"
#include "StatSystem_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "NetworkUtilities_structs.hpp"
#include "Competence_classes.hpp"
#include "DataTableUtilities_structs.hpp"
#include "DBDGameplay_structs.hpp"
#include "Engine_classes.hpp"
#include "SystemUtilities_structs.hpp"
#include "GameplayUtilities_structs.hpp"


namespace SDK
{

// Class DBDCompetence.DBDConditionFactory
// 0x0000 (0x0030 - 0x0030)
class UDBDConditionFactory final : public UBlueprintFunctionLibrary
{
public:
	static class UImposedStatusEffectCondition* CreateImposedStatusEffectCondition(TScriptInterface<class IConditionReceiver> ConditionReceiver, TSubclassOf<class UImposedStatusEffectCondition> conditionType, TSubclassOf<class UStatusEffect> classType);
	static class UDoesPerkHaveToken* DoesPerkHaveToken(TScriptInterface<class IConditionReceiver> ConditionReceiver, class UPerk* Perk);
	static class UTimerElapsedCondition* HasTimerElapsedWhileConditionWasTrue(TScriptInterface<class IConditionReceiver> ConditionReceiver, class UTimerObject* Timer);
	static class UIsPlayerPerformingInteraction* IsPlayerPerformingInteraction(TScriptInterface<class IConditionReceiver> ConditionReceiver, const struct FGameplayTagContainer& interactionSemantics);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDConditionFactory">();
	}
	static class UDBDConditionFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDConditionFactory>();
	}
};
static_assert(alignof(UDBDConditionFactory) == 0x000008, "Wrong alignment on UDBDConditionFactory");
static_assert(sizeof(UDBDConditionFactory) == 0x000030, "Wrong size on UDBDConditionFactory");

// Class DBDCompetence.ActivateStatusEffectOnEventBaseStrategy
// 0x0000 (0x0030 - 0x0030)
class UActivateStatusEffectOnEventBaseStrategy : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivateStatusEffectOnEventBaseStrategy">();
	}
	static class UActivateStatusEffectOnEventBaseStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivateStatusEffectOnEventBaseStrategy>();
	}
};
static_assert(alignof(UActivateStatusEffectOnEventBaseStrategy) == 0x000008, "Wrong alignment on UActivateStatusEffectOnEventBaseStrategy");
static_assert(sizeof(UActivateStatusEffectOnEventBaseStrategy) == 0x000030, "Wrong size on UActivateStatusEffectOnEventBaseStrategy");

// Class DBDCompetence.ActivateStatusEffectOnEventInstigatorOutsideRangeOfOwningPlayerStrategy
// 0x0030 (0x0060 - 0x0030)
class UActivateStatusEffectOnEventInstigatorOutsideRangeOfOwningPlayerStrategy final : public UActivateStatusEffectOnEventBaseStrategy
{
public:
	float                                         _range;                                            // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _tunableRange;                                     // 0x0038(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivateStatusEffectOnEventInstigatorOutsideRangeOfOwningPlayerStrategy">();
	}
	static class UActivateStatusEffectOnEventInstigatorOutsideRangeOfOwningPlayerStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivateStatusEffectOnEventInstigatorOutsideRangeOfOwningPlayerStrategy>();
	}
};
static_assert(alignof(UActivateStatusEffectOnEventInstigatorOutsideRangeOfOwningPlayerStrategy) == 0x000008, "Wrong alignment on UActivateStatusEffectOnEventInstigatorOutsideRangeOfOwningPlayerStrategy");
static_assert(sizeof(UActivateStatusEffectOnEventInstigatorOutsideRangeOfOwningPlayerStrategy) == 0x000060, "Wrong size on UActivateStatusEffectOnEventInstigatorOutsideRangeOfOwningPlayerStrategy");
static_assert(offsetof(UActivateStatusEffectOnEventInstigatorOutsideRangeOfOwningPlayerStrategy, _range) == 0x000030, "Member 'UActivateStatusEffectOnEventInstigatorOutsideRangeOfOwningPlayerStrategy::_range' has a wrong offset!");
static_assert(offsetof(UActivateStatusEffectOnEventInstigatorOutsideRangeOfOwningPlayerStrategy, _tunableRange) == 0x000038, "Member 'UActivateStatusEffectOnEventInstigatorOutsideRangeOfOwningPlayerStrategy::_tunableRange' has a wrong offset!");

// Class DBDCompetence.SpawningEffectPerk
// 0x0080 (0x04E0 - 0x0460)
class USpawningEffectPerk : public UPerk
{
public:
	struct FPerkLevelEffectArray                  _perkLevelEffects[0x3];                            // 0x0460(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FPlayerStatusEffectSpawnerHelper       _effectSpawnerHelper;                              // 0x0490(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawningEffectPerk">();
	}
	static class USpawningEffectPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawningEffectPerk>();
	}
};
static_assert(alignof(USpawningEffectPerk) == 0x000008, "Wrong alignment on USpawningEffectPerk");
static_assert(sizeof(USpawningEffectPerk) == 0x0004E0, "Wrong size on USpawningEffectPerk");
static_assert(offsetof(USpawningEffectPerk, _perkLevelEffects) == 0x000460, "Member 'USpawningEffectPerk::_perkLevelEffects' has a wrong offset!");
static_assert(offsetof(USpawningEffectPerk, _effectSpawnerHelper) == 0x000490, "Member 'USpawningEffectPerk::_effectSpawnerHelper' has a wrong offset!");

// Class DBDCompetence.BaseLingeringStatusEffect
// 0x0070 (0x0408 - 0x0398)
class UBaseLingeringStatusEffect : public UStatusEffect
{
public:
	float                                         _lingerDuration;                                   // 0x0398(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39C[0x4];                                      // 0x039C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNonTunableStat                        _lingerDurationModifier;                           // 0x03A0(0x0060)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UFloatValueStrategy*                    _lingerDurationStrategy;                           // 0x0400(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Authority_ActivateEffect();
	void Authority_DeactivateEffect();
	void SetLingerDuration(float lingerDuration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseLingeringStatusEffect">();
	}
	static class UBaseLingeringStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseLingeringStatusEffect>();
	}
};
static_assert(alignof(UBaseLingeringStatusEffect) == 0x000008, "Wrong alignment on UBaseLingeringStatusEffect");
static_assert(sizeof(UBaseLingeringStatusEffect) == 0x000408, "Wrong size on UBaseLingeringStatusEffect");
static_assert(offsetof(UBaseLingeringStatusEffect, _lingerDuration) == 0x000398, "Member 'UBaseLingeringStatusEffect::_lingerDuration' has a wrong offset!");
static_assert(offsetof(UBaseLingeringStatusEffect, _lingerDurationModifier) == 0x0003A0, "Member 'UBaseLingeringStatusEffect::_lingerDurationModifier' has a wrong offset!");
static_assert(offsetof(UBaseLingeringStatusEffect, _lingerDurationStrategy) == 0x000400, "Member 'UBaseLingeringStatusEffect::_lingerDurationStrategy' has a wrong offset!");

// Class DBDCompetence.LingeringMultiStateTagStatusEffect
// 0x0078 (0x0480 - 0x0408)
class ULingeringMultiStateTagStatusEffect : public UBaseLingeringStatusEffect
{
public:
	TArray<struct FGameplayTag>                   _ownerStateTag;                                    // 0x0408(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	EMultiLingeringStateTagStrategy               _strategy;                                         // 0x0418(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_419[0x67];                                     // 0x0419(0x0067)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LingeringMultiStateTagStatusEffect">();
	}
	static class ULingeringMultiStateTagStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULingeringMultiStateTagStatusEffect>();
	}
};
static_assert(alignof(ULingeringMultiStateTagStatusEffect) == 0x000008, "Wrong alignment on ULingeringMultiStateTagStatusEffect");
static_assert(sizeof(ULingeringMultiStateTagStatusEffect) == 0x000480, "Wrong size on ULingeringMultiStateTagStatusEffect");
static_assert(offsetof(ULingeringMultiStateTagStatusEffect, _ownerStateTag) == 0x000408, "Member 'ULingeringMultiStateTagStatusEffect::_ownerStateTag' has a wrong offset!");
static_assert(offsetof(ULingeringMultiStateTagStatusEffect, _strategy) == 0x000418, "Member 'ULingeringMultiStateTagStatusEffect::_strategy' has a wrong offset!");

// Class DBDCompetence.IsPlayerBeingHealedBySubjectProviderOriginator
// 0x0050 (0x0140 - 0x00F0)
class UIsPlayerBeingHealedBySubjectProviderOriginator final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_F0[0x50];                                      // 0x00F0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsPlayerBeingHealedBySubjectProviderOriginator">();
	}
	static class UIsPlayerBeingHealedBySubjectProviderOriginator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsPlayerBeingHealedBySubjectProviderOriginator>();
	}
};
static_assert(alignof(UIsPlayerBeingHealedBySubjectProviderOriginator) == 0x000008, "Wrong alignment on UIsPlayerBeingHealedBySubjectProviderOriginator");
static_assert(sizeof(UIsPlayerBeingHealedBySubjectProviderOriginator) == 0x000140, "Wrong size on UIsPlayerBeingHealedBySubjectProviderOriginator");

// Class DBDCompetence.PlayersInRangePerk
// 0x0080 (0x04E0 - 0x0460)
class UPlayersInRangePerk : public UPerk
{
public:
	uint8                                         Pad_460[0x60];                                     // 0x0460(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _perkRange[0x3];                                   // 0x04C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4CC[0x4];                                      // 0x04CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EPlayerRole>                           _trackedPlayerRoles;                               // 0x04D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	float GetPerkRange() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayersInRangePerk">();
	}
	static class UPlayersInRangePerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayersInRangePerk>();
	}
};
static_assert(alignof(UPlayersInRangePerk) == 0x000008, "Wrong alignment on UPlayersInRangePerk");
static_assert(sizeof(UPlayersInRangePerk) == 0x0004E0, "Wrong size on UPlayersInRangePerk");
static_assert(offsetof(UPlayersInRangePerk, _perkRange) == 0x0004C0, "Member 'UPlayersInRangePerk::_perkRange' has a wrong offset!");
static_assert(offsetof(UPlayersInRangePerk, _trackedPlayerRoles) == 0x0004D0, "Member 'UPlayersInRangePerk::_trackedPlayerRoles' has a wrong offset!");

// Class DBDCompetence.OnEventBaseAddon
// 0x0010 (0x0310 - 0x0300)
class UOnEventBaseAddon : public UItemAddon
{
public:
	struct FGameplayTag                           _eventToListenTo;                                  // 0x0300(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEventFired(const struct FGameEventData& GameEventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnEventBaseAddon">();
	}
	static class UOnEventBaseAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnEventBaseAddon>();
	}
};
static_assert(alignof(UOnEventBaseAddon) == 0x000008, "Wrong alignment on UOnEventBaseAddon");
static_assert(sizeof(UOnEventBaseAddon) == 0x000310, "Wrong size on UOnEventBaseAddon");
static_assert(offsetof(UOnEventBaseAddon, _eventToListenTo) == 0x000300, "Member 'UOnEventBaseAddon::_eventToListenTo' has a wrong offset!");

// Class DBDCompetence.HeadOn
// 0x0080 (0x04E0 - 0x0460)
class UHeadOn final : public UPerk
{
public:
	bool                                          IsPerformingHeadOn;                                // 0x0460(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ExhaustOnlyOnSuccessfulStun;                       // 0x0461(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StunKillersEnteringStunZone;                       // 0x0462(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_463[0x1];                                      // 0x0463(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _hideDuration[0x3];                                // 0x0464(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _exhaustedStatusEffect;                            // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _allowWhenPositionExposed;                         // 0x0478(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_479[0x7];                                      // 0x0479(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ALocker*                                _locker;                                           // 0x0480(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_488[0x30];                                     // 0x0488(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         _stunnableActorsInZone;                            // 0x04B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C8[0x18];                                     // 0x04C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_ActivatePerk();
	void Multicast_TriggerStunOnActor(class UObject* stunnableInterfaceUObject, class ADBDPlayer* stunner);
	void OnHeadOnAnimationComplete();
	void OnPawnOverlapEnter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnPawnOverlapExit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

	bool CanApplyHeadOnInteraction() const;
	float GetHideDuration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeadOn">();
	}
	static class UHeadOn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeadOn>();
	}
};
static_assert(alignof(UHeadOn) == 0x000008, "Wrong alignment on UHeadOn");
static_assert(sizeof(UHeadOn) == 0x0004E0, "Wrong size on UHeadOn");
static_assert(offsetof(UHeadOn, IsPerformingHeadOn) == 0x000460, "Member 'UHeadOn::IsPerformingHeadOn' has a wrong offset!");
static_assert(offsetof(UHeadOn, ExhaustOnlyOnSuccessfulStun) == 0x000461, "Member 'UHeadOn::ExhaustOnlyOnSuccessfulStun' has a wrong offset!");
static_assert(offsetof(UHeadOn, StunKillersEnteringStunZone) == 0x000462, "Member 'UHeadOn::StunKillersEnteringStunZone' has a wrong offset!");
static_assert(offsetof(UHeadOn, _hideDuration) == 0x000464, "Member 'UHeadOn::_hideDuration' has a wrong offset!");
static_assert(offsetof(UHeadOn, _exhaustedStatusEffect) == 0x000470, "Member 'UHeadOn::_exhaustedStatusEffect' has a wrong offset!");
static_assert(offsetof(UHeadOn, _allowWhenPositionExposed) == 0x000478, "Member 'UHeadOn::_allowWhenPositionExposed' has a wrong offset!");
static_assert(offsetof(UHeadOn, _locker) == 0x000480, "Member 'UHeadOn::_locker' has a wrong offset!");
static_assert(offsetof(UHeadOn, _stunnableActorsInZone) == 0x0004B8, "Member 'UHeadOn::_stunnableActorsInZone' has a wrong offset!");

// Class DBDCompetence.UndetectableEffect
// 0x0000 (0x0398 - 0x0398)
class UUndetectableEffect : public UStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UndetectableEffect">();
	}
	static class UUndetectableEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUndetectableEffect>();
	}
};
static_assert(alignof(UUndetectableEffect) == 0x000008, "Wrong alignment on UUndetectableEffect");
static_assert(sizeof(UUndetectableEffect) == 0x000398, "Wrong size on UUndetectableEffect");

// Class DBDCompetence.ActivateOnEventBaseActivationStrategy
// 0x0000 (0x0030 - 0x0030)
class UActivateOnEventBaseActivationStrategy : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivateOnEventBaseActivationStrategy">();
	}
	static class UActivateOnEventBaseActivationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivateOnEventBaseActivationStrategy>();
	}
};
static_assert(alignof(UActivateOnEventBaseActivationStrategy) == 0x000008, "Wrong alignment on UActivateOnEventBaseActivationStrategy");
static_assert(sizeof(UActivateOnEventBaseActivationStrategy) == 0x000030, "Wrong size on UActivateOnEventBaseActivationStrategy");

// Class DBDCompetence.ActivateOnEventAlwaysActivationStrategy
// 0x0000 (0x0030 - 0x0030)
class UActivateOnEventAlwaysActivationStrategy final : public UActivateOnEventBaseActivationStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivateOnEventAlwaysActivationStrategy">();
	}
	static class UActivateOnEventAlwaysActivationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivateOnEventAlwaysActivationStrategy>();
	}
};
static_assert(alignof(UActivateOnEventAlwaysActivationStrategy) == 0x000008, "Wrong alignment on UActivateOnEventAlwaysActivationStrategy");
static_assert(sizeof(UActivateOnEventAlwaysActivationStrategy) == 0x000030, "Wrong size on UActivateOnEventAlwaysActivationStrategy");

// Class DBDCompetence.BaseIsCooldownTimerActive
// 0x0018 (0x0108 - 0x00F0)
class UBaseIsCooldownTimerActive : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_F0[0x18];                                      // 0x00F0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseIsCooldownTimerActive">();
	}
	static class UBaseIsCooldownTimerActive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseIsCooldownTimerActive>();
	}
};
static_assert(alignof(UBaseIsCooldownTimerActive) == 0x000008, "Wrong alignment on UBaseIsCooldownTimerActive");
static_assert(sizeof(UBaseIsCooldownTimerActive) == 0x000108, "Wrong size on UBaseIsCooldownTimerActive");

// Class DBDCompetence.IsCooldownTimerActive
// 0x0000 (0x0108 - 0x0108)
class UIsCooldownTimerActive final : public UBaseIsCooldownTimerActive
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsCooldownTimerActive">();
	}
	static class UIsCooldownTimerActive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsCooldownTimerActive>();
	}
};
static_assert(alignof(UIsCooldownTimerActive) == 0x000008, "Wrong alignment on UIsCooldownTimerActive");
static_assert(sizeof(UIsCooldownTimerActive) == 0x000108, "Wrong size on UIsCooldownTimerActive");

// Class DBDCompetence.ActivateStatusEffectOnOwningSurvivorNoHookStage
// 0x0008 (0x0038 - 0x0030)
class UActivateStatusEffectOnOwningSurvivorNoHookStage final : public UActivateStatusEffectOnEventBaseStrategy
{
public:
	EHookDrainStage                               _hookStage;                                        // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivateStatusEffectOnOwningSurvivorNoHookStage">();
	}
	static class UActivateStatusEffectOnOwningSurvivorNoHookStage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivateStatusEffectOnOwningSurvivorNoHookStage>();
	}
};
static_assert(alignof(UActivateStatusEffectOnOwningSurvivorNoHookStage) == 0x000008, "Wrong alignment on UActivateStatusEffectOnOwningSurvivorNoHookStage");
static_assert(sizeof(UActivateStatusEffectOnOwningSurvivorNoHookStage) == 0x000038, "Wrong size on UActivateStatusEffectOnOwningSurvivorNoHookStage");
static_assert(offsetof(UActivateStatusEffectOnOwningSurvivorNoHookStage, _hookStage) == 0x000030, "Member 'UActivateStatusEffectOnOwningSurvivorNoHookStage::_hookStage' has a wrong offset!");

// Class DBDCompetence.TimedStatusEffect
// 0x0000 (0x0398 - 0x0398)
class UTimedStatusEffect : public UStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimedStatusEffect">();
	}
	static class UTimedStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimedStatusEffect>();
	}
};
static_assert(alignof(UTimedStatusEffect) == 0x000008, "Wrong alignment on UTimedStatusEffect");
static_assert(sizeof(UTimedStatusEffect) == 0x000398, "Wrong size on UTimedStatusEffect");

// Class DBDCompetence.UndetectableTimedEffect
// 0x0000 (0x0398 - 0x0398)
class UUndetectableTimedEffect final : public UTimedStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UndetectableTimedEffect">();
	}
	static class UUndetectableTimedEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUndetectableTimedEffect>();
	}
};
static_assert(alignof(UUndetectableTimedEffect) == 0x000008, "Wrong alignment on UUndetectableTimedEffect");
static_assert(sizeof(UUndetectableTimedEffect) == 0x000398, "Wrong size on UUndetectableTimedEffect");

// Class DBDCompetence.ImposeStatusEffectOnEventAddon
// 0x0018 (0x0328 - 0x0310)
class UImposeStatusEffectOnEventAddon : public UOnEventBaseAddon
{
public:
	bool                                          _requireEventInstigatorToMatchAddonOwnerToImposeStatusEffects; // 0x0310(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _requireEventTargetToMatchAddonOwnerToImposeStatusEffects; // 0x0311(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_312[0x6];                                      // 0x0312(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDataDrivenStatusEffectInfo>    _statusEffectsToImposeOnEvent;                     // 0x0318(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImposeStatusEffectOnEventAddon">();
	}
	static class UImposeStatusEffectOnEventAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImposeStatusEffectOnEventAddon>();
	}
};
static_assert(alignof(UImposeStatusEffectOnEventAddon) == 0x000008, "Wrong alignment on UImposeStatusEffectOnEventAddon");
static_assert(sizeof(UImposeStatusEffectOnEventAddon) == 0x000328, "Wrong size on UImposeStatusEffectOnEventAddon");
static_assert(offsetof(UImposeStatusEffectOnEventAddon, _requireEventInstigatorToMatchAddonOwnerToImposeStatusEffects) == 0x000310, "Member 'UImposeStatusEffectOnEventAddon::_requireEventInstigatorToMatchAddonOwnerToImposeStatusEffects' has a wrong offset!");
static_assert(offsetof(UImposeStatusEffectOnEventAddon, _requireEventTargetToMatchAddonOwnerToImposeStatusEffects) == 0x000311, "Member 'UImposeStatusEffectOnEventAddon::_requireEventTargetToMatchAddonOwnerToImposeStatusEffects' has a wrong offset!");
static_assert(offsetof(UImposeStatusEffectOnEventAddon, _statusEffectsToImposeOnEvent) == 0x000318, "Member 'UImposeStatusEffectOnEventAddon::_statusEffectsToImposeOnEvent' has a wrong offset!");

// Class DBDCompetence.IsSubjectInteractingWithOriginatingPlayer
// 0x0018 (0x0108 - 0x00F0)
class UIsSubjectInteractingWithOriginatingPlayer final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_F0[0x18];                                      // 0x00F0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsSubjectInteractingWithOriginatingPlayer">();
	}
	static class UIsSubjectInteractingWithOriginatingPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsSubjectInteractingWithOriginatingPlayer>();
	}
};
static_assert(alignof(UIsSubjectInteractingWithOriginatingPlayer) == 0x000008, "Wrong alignment on UIsSubjectInteractingWithOriginatingPlayer");
static_assert(sizeof(UIsSubjectInteractingWithOriginatingPlayer) == 0x000108, "Wrong size on UIsSubjectInteractingWithOriginatingPlayer");

// Class DBDCompetence.AdjustableCooldownStatusEffect
// 0x0010 (0x03A8 - 0x0398)
class UAdjustableCooldownStatusEffect : public UStatusEffect
{
public:
	struct FGameplayTag                           CooldownModifierType;                              // 0x0398(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A4[0x4];                                      // 0x03A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AdjustableCooldownStatusEffect">();
	}
	static class UAdjustableCooldownStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAdjustableCooldownStatusEffect>();
	}
};
static_assert(alignof(UAdjustableCooldownStatusEffect) == 0x000008, "Wrong alignment on UAdjustableCooldownStatusEffect");
static_assert(sizeof(UAdjustableCooldownStatusEffect) == 0x0003A8, "Wrong size on UAdjustableCooldownStatusEffect");
static_assert(offsetof(UAdjustableCooldownStatusEffect, CooldownModifierType) == 0x000398, "Member 'UAdjustableCooldownStatusEffect::CooldownModifierType' has a wrong offset!");

// Class DBDCompetence.ExhaustedEffect
// 0x0008 (0x03B0 - 0x03A8)
class UExhaustedEffect : public UAdjustableCooldownStatusEffect
{
public:
	float                                         CooldownModifier;                                  // 0x03A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3AC[0x4];                                      // 0x03AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExhaustedEffect">();
	}
	static class UExhaustedEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExhaustedEffect>();
	}
};
static_assert(alignof(UExhaustedEffect) == 0x000008, "Wrong alignment on UExhaustedEffect");
static_assert(sizeof(UExhaustedEffect) == 0x0003B0, "Wrong size on UExhaustedEffect");
static_assert(offsetof(UExhaustedEffect, CooldownModifier) == 0x0003A8, "Member 'UExhaustedEffect::CooldownModifier' has a wrong offset!");

// Class DBDCompetence.HexPerk
// 0x0028 (0x04E0 - 0x04B8)
class UHexPerk : public UTotemBoundPerk
{
public:
	TArray<class ADBDPlayer*>                     _playersWhoKnowCurse;                              // 0x04B8(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<class ADBDPlayer*>                     _oldPlayersWhoKnowCurse;                           // 0x04C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D8[0x8];                                      // 0x04D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_RevealCurseToAllSurvivors(bool revealed);
	void Authority_SetCurseRevealedToPlayer(class ADBDPlayer* Player, const bool revealed);
	void OnRep_PlayersWhoKnowCurse();
	void UpdateCursedStatusViewOnLocalPlayer();

	bool IsCurseRevealedToPlayer(const class ADBDPlayer* Player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HexPerk">();
	}
	static class UHexPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHexPerk>();
	}
};
static_assert(alignof(UHexPerk) == 0x000008, "Wrong alignment on UHexPerk");
static_assert(sizeof(UHexPerk) == 0x0004E0, "Wrong size on UHexPerk");
static_assert(offsetof(UHexPerk, _playersWhoKnowCurse) == 0x0004B8, "Member 'UHexPerk::_playersWhoKnowCurse' has a wrong offset!");
static_assert(offsetof(UHexPerk, _oldPlayersWhoKnowCurse) == 0x0004C8, "Member 'UHexPerk::_oldPlayersWhoKnowCurse' has a wrong offset!");

// Class DBDCompetence.SpawnEffectsOnAllSurvivorsBaseAddon
// 0x0010 (0x0310 - 0x0300)
class USpawnEffectsOnAllSurvivorsBaseAddon : public UItemAddon
{
public:
	bool                                          _canCreateMultipleInstances;                       // 0x0300(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_301[0xF];                                      // 0x0301(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnEffectsOnAllSurvivorsBaseAddon">();
	}
	static class USpawnEffectsOnAllSurvivorsBaseAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnEffectsOnAllSurvivorsBaseAddon>();
	}
};
static_assert(alignof(USpawnEffectsOnAllSurvivorsBaseAddon) == 0x000008, "Wrong alignment on USpawnEffectsOnAllSurvivorsBaseAddon");
static_assert(sizeof(USpawnEffectsOnAllSurvivorsBaseAddon) == 0x000310, "Wrong size on USpawnEffectsOnAllSurvivorsBaseAddon");
static_assert(offsetof(USpawnEffectsOnAllSurvivorsBaseAddon, _canCreateMultipleInstances) == 0x000300, "Member 'USpawnEffectsOnAllSurvivorsBaseAddon::_canCreateMultipleInstances' has a wrong offset!");

// Class DBDCompetence.AddDiminishingReturnEffectAction
// 0x0020 (0x0060 - 0x0040)
class UAddDiminishingReturnEffectAction final : public UCompetenceAction
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDiminishingReturnBaseEffect> _diminishingReturnEffect;                        // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _activateOnApplyBegin;                             // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _activationTime;                                   // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddDiminishingReturnEffectAction">();
	}
	static class UAddDiminishingReturnEffectAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddDiminishingReturnEffectAction>();
	}
};
static_assert(alignof(UAddDiminishingReturnEffectAction) == 0x000008, "Wrong alignment on UAddDiminishingReturnEffectAction");
static_assert(sizeof(UAddDiminishingReturnEffectAction) == 0x000060, "Wrong size on UAddDiminishingReturnEffectAction");
static_assert(offsetof(UAddDiminishingReturnEffectAction, _diminishingReturnEffect) == 0x000048, "Member 'UAddDiminishingReturnEffectAction::_diminishingReturnEffect' has a wrong offset!");
static_assert(offsetof(UAddDiminishingReturnEffectAction, _activateOnApplyBegin) == 0x000050, "Member 'UAddDiminishingReturnEffectAction::_activateOnApplyBegin' has a wrong offset!");
static_assert(offsetof(UAddDiminishingReturnEffectAction, _activationTime) == 0x000054, "Member 'UAddDiminishingReturnEffectAction::_activationTime' has a wrong offset!");

// Class DBDCompetence.HookedSurvivorRangeBaseCondition
// 0x00F0 (0x01E8 - 0x00F8)
class UHookedSurvivorRangeBaseCondition : public URangeBasedCondition
{
public:
	uint8                                         Pad_F8[0xF0];                                      // 0x00F8(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HookedSurvivorRangeBaseCondition">();
	}
	static class UHookedSurvivorRangeBaseCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHookedSurvivorRangeBaseCondition>();
	}
};
static_assert(alignof(UHookedSurvivorRangeBaseCondition) == 0x000008, "Wrong alignment on UHookedSurvivorRangeBaseCondition");
static_assert(sizeof(UHookedSurvivorRangeBaseCondition) == 0x0001E8, "Wrong size on UHookedSurvivorRangeBaseCondition");

// Class DBDCompetence.ExecuteActionOnEventBaseStrategy
// 0x0000 (0x0030 - 0x0030)
class UExecuteActionOnEventBaseStrategy : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExecuteActionOnEventBaseStrategy">();
	}
	static class UExecuteActionOnEventBaseStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExecuteActionOnEventBaseStrategy>();
	}
};
static_assert(alignof(UExecuteActionOnEventBaseStrategy) == 0x000008, "Wrong alignment on UExecuteActionOnEventBaseStrategy");
static_assert(sizeof(UExecuteActionOnEventBaseStrategy) == 0x000030, "Wrong size on UExecuteActionOnEventBaseStrategy");

// Class DBDCompetence.ExecuteActionOnEventInstigatorHasStateTag
// 0x0010 (0x0040 - 0x0030)
class UExecuteActionOnEventInstigatorHasStateTag final : public UExecuteActionOnEventBaseStrategy
{
public:
	struct FGameplayTag                           _stateTag;                                         // 0x0030(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExecuteActionOnEventInstigatorHasStateTag">();
	}
	static class UExecuteActionOnEventInstigatorHasStateTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExecuteActionOnEventInstigatorHasStateTag>();
	}
};
static_assert(alignof(UExecuteActionOnEventInstigatorHasStateTag) == 0x000008, "Wrong alignment on UExecuteActionOnEventInstigatorHasStateTag");
static_assert(sizeof(UExecuteActionOnEventInstigatorHasStateTag) == 0x000040, "Wrong size on UExecuteActionOnEventInstigatorHasStateTag");
static_assert(offsetof(UExecuteActionOnEventInstigatorHasStateTag, _stateTag) == 0x000030, "Member 'UExecuteActionOnEventInstigatorHasStateTag::_stateTag' has a wrong offset!");

// Class DBDCompetence.SimpleSpawnEffectsOnAllSurvivorsAddon
// 0x0010 (0x0320 - 0x0310)
class USimpleSpawnEffectsOnAllSurvivorsAddon : public USpawnEffectsOnAllSurvivorsBaseAddon
{
public:
	TArray<struct FSimpleSpawnEffectsOnAllSurvivorsAddonParams> _statusEffectsSpawnParams;           // 0x0310(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleSpawnEffectsOnAllSurvivorsAddon">();
	}
	static class USimpleSpawnEffectsOnAllSurvivorsAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimpleSpawnEffectsOnAllSurvivorsAddon>();
	}
};
static_assert(alignof(USimpleSpawnEffectsOnAllSurvivorsAddon) == 0x000008, "Wrong alignment on USimpleSpawnEffectsOnAllSurvivorsAddon");
static_assert(sizeof(USimpleSpawnEffectsOnAllSurvivorsAddon) == 0x000320, "Wrong size on USimpleSpawnEffectsOnAllSurvivorsAddon");
static_assert(offsetof(USimpleSpawnEffectsOnAllSurvivorsAddon, _statusEffectsSpawnParams) == 0x000310, "Member 'USimpleSpawnEffectsOnAllSurvivorsAddon::_statusEffectsSpawnParams' has a wrong offset!");

// Class DBDCompetence.ActivateOnEventTimedStatusEffect
// 0x0030 (0x03C8 - 0x0398)
class UActivateOnEventTimedStatusEffect : public UStatusEffect
{
public:
	TSubclassOf<class UActivateOnEventBaseActivationStrategy> _activationStrategyClass;              // 0x0398(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UActivateOnEventBaseActivationStrategy* _activationStrategy;                               // 0x03A0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  _eventsToActivateOn;                               // 0x03A8(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivateOnEventTimedStatusEffect">();
	}
	static class UActivateOnEventTimedStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivateOnEventTimedStatusEffect>();
	}
};
static_assert(alignof(UActivateOnEventTimedStatusEffect) == 0x000008, "Wrong alignment on UActivateOnEventTimedStatusEffect");
static_assert(sizeof(UActivateOnEventTimedStatusEffect) == 0x0003C8, "Wrong size on UActivateOnEventTimedStatusEffect");
static_assert(offsetof(UActivateOnEventTimedStatusEffect, _activationStrategyClass) == 0x000398, "Member 'UActivateOnEventTimedStatusEffect::_activationStrategyClass' has a wrong offset!");
static_assert(offsetof(UActivateOnEventTimedStatusEffect, _activationStrategy) == 0x0003A0, "Member 'UActivateOnEventTimedStatusEffect::_activationStrategy' has a wrong offset!");
static_assert(offsetof(UActivateOnEventTimedStatusEffect, _eventsToActivateOn) == 0x0003A8, "Member 'UActivateOnEventTimedStatusEffect::_eventsToActivateOn' has a wrong offset!");

// Class DBDCompetence.ActivateStatusEffectOnEventInstigatorStrategy
// 0x0000 (0x0030 - 0x0030)
class UActivateStatusEffectOnEventInstigatorStrategy final : public UActivateStatusEffectOnEventBaseStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivateStatusEffectOnEventInstigatorStrategy">();
	}
	static class UActivateStatusEffectOnEventInstigatorStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivateStatusEffectOnEventInstigatorStrategy>();
	}
};
static_assert(alignof(UActivateStatusEffectOnEventInstigatorStrategy) == 0x000008, "Wrong alignment on UActivateStatusEffectOnEventInstigatorStrategy");
static_assert(sizeof(UActivateStatusEffectOnEventInstigatorStrategy) == 0x000030, "Wrong size on UActivateStatusEffectOnEventInstigatorStrategy");

// Class DBDCompetence.HighestLevelAndClosestEffectCondition
// 0x0048 (0x0118 - 0x00D0)
class UHighestLevelAndClosestEffectCondition final : public UGameplayModifierCondition
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UStatusEffect*>                  _effectsLevel1;                                    // 0x00D8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UStatusEffect*>                  _effectsLevel2;                                    // 0x00E8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UStatusEffect*>                  _effectsLevel3;                                    // 0x00F8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x10];                                     // 0x0108(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitEffectArrays(class FName effectIDLevel1, class FName effectIDLevel2, class FName effectIDLevel3);
	void SetCurrentEffectLevel(int32 Level);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HighestLevelAndClosestEffectCondition">();
	}
	static class UHighestLevelAndClosestEffectCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHighestLevelAndClosestEffectCondition>();
	}
};
static_assert(alignof(UHighestLevelAndClosestEffectCondition) == 0x000008, "Wrong alignment on UHighestLevelAndClosestEffectCondition");
static_assert(sizeof(UHighestLevelAndClosestEffectCondition) == 0x000118, "Wrong size on UHighestLevelAndClosestEffectCondition");
static_assert(offsetof(UHighestLevelAndClosestEffectCondition, _effectsLevel1) == 0x0000D8, "Member 'UHighestLevelAndClosestEffectCondition::_effectsLevel1' has a wrong offset!");
static_assert(offsetof(UHighestLevelAndClosestEffectCondition, _effectsLevel2) == 0x0000E8, "Member 'UHighestLevelAndClosestEffectCondition::_effectsLevel2' has a wrong offset!");
static_assert(offsetof(UHighestLevelAndClosestEffectCondition, _effectsLevel3) == 0x0000F8, "Member 'UHighestLevelAndClosestEffectCondition::_effectsLevel3' has a wrong offset!");

// Class DBDCompetence.ActivateStatusEffectOnEventInRangeOfOriginatingPlayerStrategy
// 0x0088 (0x00B8 - 0x0030)
class UActivateStatusEffectOnEventInRangeOfOriginatingPlayerStrategy : public UActivateStatusEffectOnEventBaseStrategy
{
public:
	float                                         _range;                                            // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTunableStat                           _tunableStat;                                      // 0x0038(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivateStatusEffectOnEventInRangeOfOriginatingPlayerStrategy">();
	}
	static class UActivateStatusEffectOnEventInRangeOfOriginatingPlayerStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivateStatusEffectOnEventInRangeOfOriginatingPlayerStrategy>();
	}
};
static_assert(alignof(UActivateStatusEffectOnEventInRangeOfOriginatingPlayerStrategy) == 0x000008, "Wrong alignment on UActivateStatusEffectOnEventInRangeOfOriginatingPlayerStrategy");
static_assert(sizeof(UActivateStatusEffectOnEventInRangeOfOriginatingPlayerStrategy) == 0x0000B8, "Wrong size on UActivateStatusEffectOnEventInRangeOfOriginatingPlayerStrategy");
static_assert(offsetof(UActivateStatusEffectOnEventInRangeOfOriginatingPlayerStrategy, _range) == 0x000030, "Member 'UActivateStatusEffectOnEventInRangeOfOriginatingPlayerStrategy::_range' has a wrong offset!");
static_assert(offsetof(UActivateStatusEffectOnEventInRangeOfOriginatingPlayerStrategy, _tunableStat) == 0x000038, "Member 'UActivateStatusEffectOnEventInRangeOfOriginatingPlayerStrategy::_tunableStat' has a wrong offset!");

// Class DBDCompetence.ActivateStatusEffectOnEventInRangeOfOriginatingPlayerInstigatorStrategy
// 0x0000 (0x00B8 - 0x00B8)
class UActivateStatusEffectOnEventInRangeOfOriginatingPlayerInstigatorStrategy final : public UActivateStatusEffectOnEventInRangeOfOriginatingPlayerStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivateStatusEffectOnEventInRangeOfOriginatingPlayerInstigatorStrategy">();
	}
	static class UActivateStatusEffectOnEventInRangeOfOriginatingPlayerInstigatorStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivateStatusEffectOnEventInRangeOfOriginatingPlayerInstigatorStrategy>();
	}
};
static_assert(alignof(UActivateStatusEffectOnEventInRangeOfOriginatingPlayerInstigatorStrategy) == 0x000008, "Wrong alignment on UActivateStatusEffectOnEventInRangeOfOriginatingPlayerInstigatorStrategy");
static_assert(sizeof(UActivateStatusEffectOnEventInRangeOfOriginatingPlayerInstigatorStrategy) == 0x0000B8, "Wrong size on UActivateStatusEffectOnEventInRangeOfOriginatingPlayerInstigatorStrategy");

// Class DBDCompetence.GateBlockerEffect
// 0x0038 (0x03D0 - 0x0398)
class UGateBlockerEffect : public UStatusEffect
{
public:
	float                                         _blockGateLingeringTime;                           // 0x0398(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _onlyLingerIfActivationTimerIsActive;              // 0x039C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39D[0x33];                                     // 0x039D(0x0033)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RemoveCantEscapeFlag();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GateBlockerEffect">();
	}
	static class UGateBlockerEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGateBlockerEffect>();
	}
};
static_assert(alignof(UGateBlockerEffect) == 0x000008, "Wrong alignment on UGateBlockerEffect");
static_assert(sizeof(UGateBlockerEffect) == 0x0003D0, "Wrong size on UGateBlockerEffect");
static_assert(offsetof(UGateBlockerEffect, _blockGateLingeringTime) == 0x000398, "Member 'UGateBlockerEffect::_blockGateLingeringTime' has a wrong offset!");
static_assert(offsetof(UGateBlockerEffect, _onlyLingerIfActivationTimerIsActive) == 0x00039C, "Member 'UGateBlockerEffect::_onlyLingerIfActivationTimerIsActive' has a wrong offset!");

// Class DBDCompetence.ActivateStatusEffectOnEventInRangeOfInstigatingPlayerStrategy
// 0x0080 (0x00B0 - 0x0030)
class UActivateStatusEffectOnEventInRangeOfInstigatingPlayerStrategy final : public UActivateStatusEffectOnEventBaseStrategy
{
public:
	struct FTunableStat                           _range;                                            // 0x0030(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivateStatusEffectOnEventInRangeOfInstigatingPlayerStrategy">();
	}
	static class UActivateStatusEffectOnEventInRangeOfInstigatingPlayerStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivateStatusEffectOnEventInRangeOfInstigatingPlayerStrategy>();
	}
};
static_assert(alignof(UActivateStatusEffectOnEventInRangeOfInstigatingPlayerStrategy) == 0x000008, "Wrong alignment on UActivateStatusEffectOnEventInRangeOfInstigatingPlayerStrategy");
static_assert(sizeof(UActivateStatusEffectOnEventInRangeOfInstigatingPlayerStrategy) == 0x0000B0, "Wrong size on UActivateStatusEffectOnEventInRangeOfInstigatingPlayerStrategy");
static_assert(offsetof(UActivateStatusEffectOnEventInRangeOfInstigatingPlayerStrategy, _range) == 0x000030, "Member 'UActivateStatusEffectOnEventInRangeOfInstigatingPlayerStrategy::_range' has a wrong offset!");

// Class DBDCompetence.ThrillingTremors
// 0x0060 (0x04C0 - 0x0460)
class UThrillingTremors final : public UPerk
{
public:
	int32                                         _cooldownByLevel[0x3];                             // 0x0460(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _durationByLevel[0x3];                             // 0x046C(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _disableWhenSurvivorPutDownOrUnhooked;             // 0x0478(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_479[0x3];                                      // 0x0479(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           _generatorAuraColorForKiller;                      // 0x047C(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48C[0x4];                                      // 0x048C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGenerator*>                     _blockedGenerators;                                // 0x0490(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class AGenerator*>                     _revealedGenerators;                               // 0x04A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B0[0x10];                                     // 0x04B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_BlockedGenerators();

	int32 GetCooldownAtLevel() const;
	float GetDurationAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThrillingTremors">();
	}
	static class UThrillingTremors* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThrillingTremors>();
	}
};
static_assert(alignof(UThrillingTremors) == 0x000008, "Wrong alignment on UThrillingTremors");
static_assert(sizeof(UThrillingTremors) == 0x0004C0, "Wrong size on UThrillingTremors");
static_assert(offsetof(UThrillingTremors, _cooldownByLevel) == 0x000460, "Member 'UThrillingTremors::_cooldownByLevel' has a wrong offset!");
static_assert(offsetof(UThrillingTremors, _durationByLevel) == 0x00046C, "Member 'UThrillingTremors::_durationByLevel' has a wrong offset!");
static_assert(offsetof(UThrillingTremors, _disableWhenSurvivorPutDownOrUnhooked) == 0x000478, "Member 'UThrillingTremors::_disableWhenSurvivorPutDownOrUnhooked' has a wrong offset!");
static_assert(offsetof(UThrillingTremors, _generatorAuraColorForKiller) == 0x00047C, "Member 'UThrillingTremors::_generatorAuraColorForKiller' has a wrong offset!");
static_assert(offsetof(UThrillingTremors, _blockedGenerators) == 0x000490, "Member 'UThrillingTremors::_blockedGenerators' has a wrong offset!");
static_assert(offsetof(UThrillingTremors, _revealedGenerators) == 0x0004A0, "Member 'UThrillingTremors::_revealedGenerators' has a wrong offset!");

// Class DBDCompetence.SingleGateBlockerEffect
// 0x0058 (0x0428 - 0x03D0)
class USingleGateBlockerEffect : public UGateBlockerEffect
{
public:
	float                                         _distanceThreshold;                                // 0x03D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isInRange;                                        // 0x03D4(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D5[0x53];                                     // 0x03D5(0x0053)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SingleGateBlockerEffect">();
	}
	static class USingleGateBlockerEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<USingleGateBlockerEffect>();
	}
};
static_assert(alignof(USingleGateBlockerEffect) == 0x000008, "Wrong alignment on USingleGateBlockerEffect");
static_assert(sizeof(USingleGateBlockerEffect) == 0x000428, "Wrong size on USingleGateBlockerEffect");
static_assert(offsetof(USingleGateBlockerEffect, _distanceThreshold) == 0x0003D0, "Member 'USingleGateBlockerEffect::_distanceThreshold' has a wrong offset!");
static_assert(offsetof(USingleGateBlockerEffect, _isInRange) == 0x0003D4, "Member 'USingleGateBlockerEffect::_isInRange' has a wrong offset!");

// Class DBDCompetence.AddStatusEffectAction
// 0x00B0 (0x00F0 - 0x0040)
class UAddStatusEffectAction : public UCompetenceAction
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EStatusEffectTarget                           _statusEffectTarget;                               // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffect*                          _statusEffectClass;                                // 0x0050(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UActivateStatusEffectBaseCondition*> _activateStatusEffectConditions;               // 0x0058(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UActivateStatusEffectOnEventBaseStrategy* _activateStatusEffectOnEventStrategy;            // 0x0068(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFloatValueStrategy*                    _customParamStrategy;                              // 0x0070(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFloatValueStrategy*                    _initialStatusEffectLifetimeStrategy;              // 0x0078(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFloatValueStrategy*                    _effectDurationStrategy;                           // 0x0080(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TWeakObjectPtr<class ADBDPlayer>, TWeakObjectPtr<class UStatusEffect>> _spawnedStatusEffects; // 0x0090(0x0050)(ExportObject, Transient, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UCompetenceAction*>              _actionsToExecuteOnSuccess;                        // 0x00E0(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void Multicast_ExecuteSubActions(const struct FGameEventData& GameEventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddStatusEffectAction">();
	}
	static class UAddStatusEffectAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddStatusEffectAction>();
	}
};
static_assert(alignof(UAddStatusEffectAction) == 0x000008, "Wrong alignment on UAddStatusEffectAction");
static_assert(sizeof(UAddStatusEffectAction) == 0x0000F0, "Wrong size on UAddStatusEffectAction");
static_assert(offsetof(UAddStatusEffectAction, _statusEffectTarget) == 0x000048, "Member 'UAddStatusEffectAction::_statusEffectTarget' has a wrong offset!");
static_assert(offsetof(UAddStatusEffectAction, _statusEffectClass) == 0x000050, "Member 'UAddStatusEffectAction::_statusEffectClass' has a wrong offset!");
static_assert(offsetof(UAddStatusEffectAction, _activateStatusEffectConditions) == 0x000058, "Member 'UAddStatusEffectAction::_activateStatusEffectConditions' has a wrong offset!");
static_assert(offsetof(UAddStatusEffectAction, _activateStatusEffectOnEventStrategy) == 0x000068, "Member 'UAddStatusEffectAction::_activateStatusEffectOnEventStrategy' has a wrong offset!");
static_assert(offsetof(UAddStatusEffectAction, _customParamStrategy) == 0x000070, "Member 'UAddStatusEffectAction::_customParamStrategy' has a wrong offset!");
static_assert(offsetof(UAddStatusEffectAction, _initialStatusEffectLifetimeStrategy) == 0x000078, "Member 'UAddStatusEffectAction::_initialStatusEffectLifetimeStrategy' has a wrong offset!");
static_assert(offsetof(UAddStatusEffectAction, _effectDurationStrategy) == 0x000080, "Member 'UAddStatusEffectAction::_effectDurationStrategy' has a wrong offset!");
static_assert(offsetof(UAddStatusEffectAction, _spawnedStatusEffects) == 0x000090, "Member 'UAddStatusEffectAction::_spawnedStatusEffects' has a wrong offset!");
static_assert(offsetof(UAddStatusEffectAction, _actionsToExecuteOnSuccess) == 0x0000E0, "Member 'UAddStatusEffectAction::_actionsToExecuteOnSuccess' has a wrong offset!");

// Class DBDCompetence.AddStatusEffectToFurthestTargetAction
// 0x0000 (0x00F0 - 0x00F0)
class UAddStatusEffectToFurthestTargetAction final : public UAddStatusEffectAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddStatusEffectToFurthestTargetAction">();
	}
	static class UAddStatusEffectToFurthestTargetAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddStatusEffectToFurthestTargetAction>();
	}
};
static_assert(alignof(UAddStatusEffectToFurthestTargetAction) == 0x000008, "Wrong alignment on UAddStatusEffectToFurthestTargetAction");
static_assert(sizeof(UAddStatusEffectToFurthestTargetAction) == 0x0000F0, "Wrong size on UAddStatusEffectToFurthestTargetAction");

// Class DBDCompetence.AnyActorPairQueryRangeIsTrue
// 0x0010 (0x0108 - 0x00F8)
class UAnyActorPairQueryRangeIsTrue : public URangeBasedCondition
{
public:
	uint8                                         Pad_F8[0x10];                                      // 0x00F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInRangeChanged(const bool inRange);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnyActorPairQueryRangeIsTrue">();
	}
	static class UAnyActorPairQueryRangeIsTrue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnyActorPairQueryRangeIsTrue>();
	}
};
static_assert(alignof(UAnyActorPairQueryRangeIsTrue) == 0x000008, "Wrong alignment on UAnyActorPairQueryRangeIsTrue");
static_assert(sizeof(UAnyActorPairQueryRangeIsTrue) == 0x000108, "Wrong size on UAnyActorPairQueryRangeIsTrue");

// Class DBDCompetence.ActivatableTimedRevealToOriginatingPlayer
// 0x0008 (0x03A0 - 0x0398)
class UActivatableTimedRevealToOriginatingPlayer final : public UStatusEffect
{
public:
	class UAkAudioEvent*                          _soundEventWhenRevealed;                           // 0x0398(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivatableTimedRevealToOriginatingPlayer">();
	}
	static class UActivatableTimedRevealToOriginatingPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivatableTimedRevealToOriginatingPlayer>();
	}
};
static_assert(alignof(UActivatableTimedRevealToOriginatingPlayer) == 0x000008, "Wrong alignment on UActivatableTimedRevealToOriginatingPlayer");
static_assert(sizeof(UActivatableTimedRevealToOriginatingPlayer) == 0x0003A0, "Wrong size on UActivatableTimedRevealToOriginatingPlayer");
static_assert(offsetof(UActivatableTimedRevealToOriginatingPlayer, _soundEventWhenRevealed) == 0x000398, "Member 'UActivatableTimedRevealToOriginatingPlayer::_soundEventWhenRevealed' has a wrong offset!");

// Class DBDCompetence.DejaVu
// 0x0040 (0x04A0 - 0x0460)
class UDejaVu final : public UPerk
{
public:
	int32                                         _generatorsToRevealCount;                          // 0x0460(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _actionSpeeds[0x3];                                // 0x0464(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _generatorAuraColor;                               // 0x0470(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AGenerator*>                     _revealedGenerators;                               // 0x0480(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_SetNewGeneratorsToReveal();
	void OnRep_RevealedGenerators();

	float GetActionSpeedsAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DejaVu">();
	}
	static class UDejaVu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDejaVu>();
	}
};
static_assert(alignof(UDejaVu) == 0x000008, "Wrong alignment on UDejaVu");
static_assert(sizeof(UDejaVu) == 0x0004A0, "Wrong size on UDejaVu");
static_assert(offsetof(UDejaVu, _generatorsToRevealCount) == 0x000460, "Member 'UDejaVu::_generatorsToRevealCount' has a wrong offset!");
static_assert(offsetof(UDejaVu, _actionSpeeds) == 0x000464, "Member 'UDejaVu::_actionSpeeds' has a wrong offset!");
static_assert(offsetof(UDejaVu, _generatorAuraColor) == 0x000470, "Member 'UDejaVu::_generatorAuraColor' has a wrong offset!");
static_assert(offsetof(UDejaVu, _revealedGenerators) == 0x000480, "Member 'UDejaVu::_revealedGenerators' has a wrong offset!");

// Class DBDCompetence.KillerInstinctStatusEffect
// 0x0000 (0x0398 - 0x0398)
class UKillerInstinctStatusEffect : public UStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerInstinctStatusEffect">();
	}
	static class UKillerInstinctStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerInstinctStatusEffect>();
	}
};
static_assert(alignof(UKillerInstinctStatusEffect) == 0x000008, "Wrong alignment on UKillerInstinctStatusEffect");
static_assert(sizeof(UKillerInstinctStatusEffect) == 0x000398, "Wrong size on UKillerInstinctStatusEffect");

// Class DBDCompetence.OwningPlayerInTotemRange
// 0x0020 (0x0128 - 0x0108)
class UOwningPlayerInTotemRange : public UAnyActorPairQueryRangeIsTrue
{
public:
	uint8                                         Pad_108[0x20];                                     // 0x0108(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OwningPlayerInTotemRange">();
	}
	static class UOwningPlayerInTotemRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOwningPlayerInTotemRange>();
	}
};
static_assert(alignof(UOwningPlayerInTotemRange) == 0x000008, "Wrong alignment on UOwningPlayerInTotemRange");
static_assert(sizeof(UOwningPlayerInTotemRange) == 0x000128, "Wrong size on UOwningPlayerInTotemRange");

// Class DBDCompetence.IsPlayerPerformingInteraction
// 0x0040 (0x0130 - 0x00F0)
class UIsPlayerPerformingInteraction : public UEventDrivenModifierCondition
{
public:
	struct FGameplayTagContainer                  _interactionSemantics;                             // 0x00F0(0x0020)(Edit, BlueprintVisible, Net, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_110[0x20];                                     // 0x0110(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetInteractionSemantics(const struct FGameplayTagContainer& interactionSemantics);
	void UpdateIsTrue(class UInteractionDefinition* InteractionDefinition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsPlayerPerformingInteraction">();
	}
	static class UIsPlayerPerformingInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsPlayerPerformingInteraction>();
	}
};
static_assert(alignof(UIsPlayerPerformingInteraction) == 0x000008, "Wrong alignment on UIsPlayerPerformingInteraction");
static_assert(sizeof(UIsPlayerPerformingInteraction) == 0x000130, "Wrong size on UIsPlayerPerformingInteraction");
static_assert(offsetof(UIsPlayerPerformingInteraction, _interactionSemantics) == 0x0000F0, "Member 'UIsPlayerPerformingInteraction::_interactionSemantics' has a wrong offset!");

// Class DBDCompetence.IsOwningPlayerInRangeFromHook
// 0x0050 (0x0158 - 0x0108)
class UIsOwningPlayerInRangeFromHook : public UAnyActorPairQueryRangeIsTrue
{
public:
	struct FGameplayTagQuery                      _tagQueryFromHook;                                 // 0x0108(0x0048)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_150[0x8];                                      // 0x0150(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsOwningPlayerInRangeFromHook">();
	}
	static class UIsOwningPlayerInRangeFromHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsOwningPlayerInRangeFromHook>();
	}
};
static_assert(alignof(UIsOwningPlayerInRangeFromHook) == 0x000008, "Wrong alignment on UIsOwningPlayerInRangeFromHook");
static_assert(sizeof(UIsOwningPlayerInRangeFromHook) == 0x000158, "Wrong size on UIsOwningPlayerInRangeFromHook");
static_assert(offsetof(UIsOwningPlayerInRangeFromHook, _tagQueryFromHook) == 0x000108, "Member 'UIsOwningPlayerInRangeFromHook::_tagQueryFromHook' has a wrong offset!");

// Class DBDCompetence.IsOwningPlayerInHookRangeWhenKillerCarry
// 0x0018 (0x0170 - 0x0158)
class UIsOwningPlayerInHookRangeWhenKillerCarry : public UIsOwningPlayerInRangeFromHook
{
public:
	uint8                                         Pad_158[0x18];                                     // 0x0158(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsOwningPlayerInHookRangeWhenKillerCarry">();
	}
	static class UIsOwningPlayerInHookRangeWhenKillerCarry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsOwningPlayerInHookRangeWhenKillerCarry>();
	}
};
static_assert(alignof(UIsOwningPlayerInHookRangeWhenKillerCarry) == 0x000008, "Wrong alignment on UIsOwningPlayerInHookRangeWhenKillerCarry");
static_assert(sizeof(UIsOwningPlayerInHookRangeWhenKillerCarry) == 0x000170, "Wrong size on UIsOwningPlayerInHookRangeWhenKillerCarry");

// Class DBDCompetence.ObliviousEffect
// 0x0000 (0x03A8 - 0x03A8)
class UObliviousEffect : public UAdjustableCooldownStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObliviousEffect">();
	}
	static class UObliviousEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObliviousEffect>();
	}
};
static_assert(alignof(UObliviousEffect) == 0x000008, "Wrong alignment on UObliviousEffect");
static_assert(sizeof(UObliviousEffect) == 0x0003A8, "Wrong size on UObliviousEffect");

// Class DBDCompetence.AddTokenAction
// 0x0010 (0x0050 - 0x0040)
class UAddTokenAction final : public UCompetenceAction
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _tokenCount;                                       // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddTokenAction">();
	}
	static class UAddTokenAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddTokenAction>();
	}
};
static_assert(alignof(UAddTokenAction) == 0x000008, "Wrong alignment on UAddTokenAction");
static_assert(sizeof(UAddTokenAction) == 0x000050, "Wrong size on UAddTokenAction");
static_assert(offsetof(UAddTokenAction, _tokenCount) == 0x000048, "Member 'UAddTokenAction::_tokenCount' has a wrong offset!");

// Class DBDCompetence.ExposedEffect
// 0x0000 (0x03A8 - 0x03A8)
class UExposedEffect : public UAdjustableCooldownStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExposedEffect">();
	}
	static class UExposedEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExposedEffect>();
	}
};
static_assert(alignof(UExposedEffect) == 0x000008, "Wrong alignment on UExposedEffect");
static_assert(sizeof(UExposedEffect) == 0x0003A8, "Wrong size on UExposedEffect");

// Class DBDCompetence.LingeringStateTagStatusEffect
// 0x0038 (0x0440 - 0x0408)
class ULingeringStateTagStatusEffect : public UBaseLingeringStatusEffect
{
public:
	struct FGameplayTag                           _ownerStateTag;                                    // 0x0408(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_414[0x2C];                                     // 0x0414(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LingeringStateTagStatusEffect">();
	}
	static class ULingeringStateTagStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULingeringStateTagStatusEffect>();
	}
};
static_assert(alignof(ULingeringStateTagStatusEffect) == 0x000008, "Wrong alignment on ULingeringStateTagStatusEffect");
static_assert(sizeof(ULingeringStateTagStatusEffect) == 0x000440, "Wrong size on ULingeringStateTagStatusEffect");
static_assert(offsetof(ULingeringStateTagStatusEffect, _ownerStateTag) == 0x000408, "Member 'ULingeringStateTagStatusEffect::_ownerStateTag' has a wrong offset!");

// Class DBDCompetence.IsOnHitSprintEffectActive
// 0x0000 (0x00F0 - 0x00F0)
class UIsOnHitSprintEffectActive final : public UEventDrivenModifierCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsOnHitSprintEffectActive">();
	}
	static class UIsOnHitSprintEffectActive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsOnHitSprintEffectActive>();
	}
};
static_assert(alignof(UIsOnHitSprintEffectActive) == 0x000008, "Wrong alignment on UIsOnHitSprintEffectActive");
static_assert(sizeof(UIsOnHitSprintEffectActive) == 0x0000F0, "Wrong size on UIsOnHitSprintEffectActive");

// Class DBDCompetence.Adrenaline
// 0x0028 (0x0488 - 0x0460)
class UAdrenaline final : public UPerk
{
public:
	float                                         _exhaustionDuration[0x3];                          // 0x0460(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_46C[0x4];                                      // 0x046C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _speedEffect;                                      // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _exhaustionEffect;                                 // 0x0478(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _movementSpeedDuration;                            // 0x0480(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _movementSpeedPercentage;                          // 0x0484(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Multicast_DispatchAdrenalineEvents(const bool IsHealthy, const float HealAmount);

	float GetExhaustionDuration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Adrenaline">();
	}
	static class UAdrenaline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAdrenaline>();
	}
};
static_assert(alignof(UAdrenaline) == 0x000008, "Wrong alignment on UAdrenaline");
static_assert(sizeof(UAdrenaline) == 0x000488, "Wrong size on UAdrenaline");
static_assert(offsetof(UAdrenaline, _exhaustionDuration) == 0x000460, "Member 'UAdrenaline::_exhaustionDuration' has a wrong offset!");
static_assert(offsetof(UAdrenaline, _speedEffect) == 0x000470, "Member 'UAdrenaline::_speedEffect' has a wrong offset!");
static_assert(offsetof(UAdrenaline, _exhaustionEffect) == 0x000478, "Member 'UAdrenaline::_exhaustionEffect' has a wrong offset!");
static_assert(offsetof(UAdrenaline, _movementSpeedDuration) == 0x000480, "Member 'UAdrenaline::_movementSpeedDuration' has a wrong offset!");
static_assert(offsetof(UAdrenaline, _movementSpeedPercentage) == 0x000484, "Member 'UAdrenaline::_movementSpeedPercentage' has a wrong offset!");

// Class DBDCompetence.CompromiseGeneratorPerk
// 0x0018 (0x0478 - 0x0460)
class UCompromiseGeneratorPerk : public UPerk
{
public:
	TSubclassOf<class UCompromiseGeneratorManager> _compromiseGeneratorManagerClass;                 // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGenerator*                             _compromisedGenerator;                             // 0x0468(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCompromiseGeneratorManager*            _compromiseGeneratorManager;                       // 0x0470(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CompromiseGeneratorPerk">();
	}
	static class UCompromiseGeneratorPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCompromiseGeneratorPerk>();
	}
};
static_assert(alignof(UCompromiseGeneratorPerk) == 0x000008, "Wrong alignment on UCompromiseGeneratorPerk");
static_assert(sizeof(UCompromiseGeneratorPerk) == 0x000478, "Wrong size on UCompromiseGeneratorPerk");
static_assert(offsetof(UCompromiseGeneratorPerk, _compromiseGeneratorManagerClass) == 0x000460, "Member 'UCompromiseGeneratorPerk::_compromiseGeneratorManagerClass' has a wrong offset!");
static_assert(offsetof(UCompromiseGeneratorPerk, _compromisedGenerator) == 0x000468, "Member 'UCompromiseGeneratorPerk::_compromisedGenerator' has a wrong offset!");
static_assert(offsetof(UCompromiseGeneratorPerk, _compromiseGeneratorManager) == 0x000470, "Member 'UCompromiseGeneratorPerk::_compromiseGeneratorManager' has a wrong offset!");

// Class DBDCompetence.BetterTogether
// 0x0060 (0x04C0 - 0x0460)
class UBetterTogether final : public UPerk
{
public:
	bool                                          ShouldRevealKiller;                                // 0x0460(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShouldRevealSurvivors;                             // 0x0461(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_462[0x2];                                      // 0x0462(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RevealDistance;                                    // 0x0464(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ADBDPlayer*>                     _affectedCampers;                                  // 0x0468(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_478[0x8];                                      // 0x0478(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _genToReveal;                                      // 0x0480(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _durationByLevel[0x3];                             // 0x0488(0x0004)(Edit, EditFixedSize, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_494[0x1C];                                     // 0x0494(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _timedSurvivorRevealEffect;                        // 0x04B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _timedKillerRevealEffect;                          // 0x04B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	float GetRevealDistance();
	void OnStartedGeneratorRepair(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BetterTogether">();
	}
	static class UBetterTogether* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBetterTogether>();
	}
};
static_assert(alignof(UBetterTogether) == 0x000008, "Wrong alignment on UBetterTogether");
static_assert(sizeof(UBetterTogether) == 0x0004C0, "Wrong size on UBetterTogether");
static_assert(offsetof(UBetterTogether, ShouldRevealKiller) == 0x000460, "Member 'UBetterTogether::ShouldRevealKiller' has a wrong offset!");
static_assert(offsetof(UBetterTogether, ShouldRevealSurvivors) == 0x000461, "Member 'UBetterTogether::ShouldRevealSurvivors' has a wrong offset!");
static_assert(offsetof(UBetterTogether, RevealDistance) == 0x000464, "Member 'UBetterTogether::RevealDistance' has a wrong offset!");
static_assert(offsetof(UBetterTogether, _affectedCampers) == 0x000468, "Member 'UBetterTogether::_affectedCampers' has a wrong offset!");
static_assert(offsetof(UBetterTogether, _genToReveal) == 0x000480, "Member 'UBetterTogether::_genToReveal' has a wrong offset!");
static_assert(offsetof(UBetterTogether, _durationByLevel) == 0x000488, "Member 'UBetterTogether::_durationByLevel' has a wrong offset!");
static_assert(offsetof(UBetterTogether, _timedSurvivorRevealEffect) == 0x0004B0, "Member 'UBetterTogether::_timedSurvivorRevealEffect' has a wrong offset!");
static_assert(offsetof(UBetterTogether, _timedKillerRevealEffect) == 0x0004B8, "Member 'UBetterTogether::_timedKillerRevealEffect' has a wrong offset!");

// Class DBDCompetence.BoonPerk
// 0x0060 (0x0518 - 0x04B8)
class UBoonPerk : public UTotemBoundPerk
{
public:
	TSubclassOf<class UBlessedStatusEffect>       _blessedStatusEffectClass;                         // 0x04B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlessedStatusEffect*                   _blessedStatusEffect;                              // 0x04C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C8[0x50];                                     // 0x04C8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnSurvivorRemoved(class ASurvivor* Survivor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoonPerk">();
	}
	static class UBoonPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBoonPerk>();
	}
};
static_assert(alignof(UBoonPerk) == 0x000008, "Wrong alignment on UBoonPerk");
static_assert(sizeof(UBoonPerk) == 0x000518, "Wrong size on UBoonPerk");
static_assert(offsetof(UBoonPerk, _blessedStatusEffectClass) == 0x0004B8, "Member 'UBoonPerk::_blessedStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UBoonPerk, _blessedStatusEffect) == 0x0004C0, "Member 'UBoonPerk::_blessedStatusEffect' has a wrong offset!");

// Class DBDCompetence.IsOriginatingPerkBoundToTotems
// 0x0010 (0x0100 - 0x00F0)
class UIsOriginatingPerkBoundToTotems final : public UEventDrivenModifierCondition
{
public:
	EComparisonOperation                          _comparisonOperator;                               // 0x00F0(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _totemCount;                                       // 0x00F4(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(EComparisonOperation comparisonOperator, int32 totemCount);
	void OnRep_TotemCount();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsOriginatingPerkBoundToTotems">();
	}
	static class UIsOriginatingPerkBoundToTotems* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsOriginatingPerkBoundToTotems>();
	}
};
static_assert(alignof(UIsOriginatingPerkBoundToTotems) == 0x000008, "Wrong alignment on UIsOriginatingPerkBoundToTotems");
static_assert(sizeof(UIsOriginatingPerkBoundToTotems) == 0x000100, "Wrong size on UIsOriginatingPerkBoundToTotems");
static_assert(offsetof(UIsOriginatingPerkBoundToTotems, _comparisonOperator) == 0x0000F0, "Member 'UIsOriginatingPerkBoundToTotems::_comparisonOperator' has a wrong offset!");
static_assert(offsetof(UIsOriginatingPerkBoundToTotems, _totemCount) == 0x0000F4, "Member 'UIsOriginatingPerkBoundToTotems::_totemCount' has a wrong offset!");

// Class DBDCompetence.Babysitter
// 0x0038 (0x0498 - 0x0460)
class UBabysitter final : public UPerk
{
public:
	float                                         _scratchMarkHidingTime[0x3];                       // 0x0460(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _hasteEffect[0x3];                                 // 0x046C(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _showAuraTime[0x3];                                // 0x0478(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _cooldownTime[0x3];                                // 0x0484(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _perkEffect;                                       // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	float GetCooldownTimeAtLevel() const;
	float GetHasteEffectAtLevel() const;
	float GetScratchMarkHidingTimeAtLevel() const;
	float GetShowAuraTimeAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Babysitter">();
	}
	static class UBabysitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBabysitter>();
	}
};
static_assert(alignof(UBabysitter) == 0x000008, "Wrong alignment on UBabysitter");
static_assert(sizeof(UBabysitter) == 0x000498, "Wrong size on UBabysitter");
static_assert(offsetof(UBabysitter, _scratchMarkHidingTime) == 0x000460, "Member 'UBabysitter::_scratchMarkHidingTime' has a wrong offset!");
static_assert(offsetof(UBabysitter, _hasteEffect) == 0x00046C, "Member 'UBabysitter::_hasteEffect' has a wrong offset!");
static_assert(offsetof(UBabysitter, _showAuraTime) == 0x000478, "Member 'UBabysitter::_showAuraTime' has a wrong offset!");
static_assert(offsetof(UBabysitter, _cooldownTime) == 0x000484, "Member 'UBabysitter::_cooldownTime' has a wrong offset!");
static_assert(offsetof(UBabysitter, _perkEffect) == 0x000490, "Member 'UBabysitter::_perkEffect' has a wrong offset!");

// Class DBDCompetence.IsInRangeOfHookedSurvivor
// 0x0000 (0x01E8 - 0x01E8)
class UIsInRangeOfHookedSurvivor : public UHookedSurvivorRangeBaseCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsInRangeOfHookedSurvivor">();
	}
	static class UIsInRangeOfHookedSurvivor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsInRangeOfHookedSurvivor>();
	}
};
static_assert(alignof(UIsInRangeOfHookedSurvivor) == 0x000008, "Wrong alignment on UIsInRangeOfHookedSurvivor");
static_assert(sizeof(UIsInRangeOfHookedSurvivor) == 0x0001E8, "Wrong size on UIsInRangeOfHookedSurvivor");

// Class DBDCompetence.ActivateStatusEffectOnEventOriginatingPlayerInstigatorStrategy
// 0x0000 (0x0030 - 0x0030)
class UActivateStatusEffectOnEventOriginatingPlayerInstigatorStrategy final : public UActivateStatusEffectOnEventBaseStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivateStatusEffectOnEventOriginatingPlayerInstigatorStrategy">();
	}
	static class UActivateStatusEffectOnEventOriginatingPlayerInstigatorStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivateStatusEffectOnEventOriginatingPlayerInstigatorStrategy>();
	}
};
static_assert(alignof(UActivateStatusEffectOnEventOriginatingPlayerInstigatorStrategy) == 0x000008, "Wrong alignment on UActivateStatusEffectOnEventOriginatingPlayerInstigatorStrategy");
static_assert(sizeof(UActivateStatusEffectOnEventOriginatingPlayerInstigatorStrategy) == 0x000030, "Wrong size on UActivateStatusEffectOnEventOriginatingPlayerInstigatorStrategy");

// Class DBDCompetence.IsInAnyHookedSurvivorOriginatorAuraReadingRange
// 0x00B0 (0x01A8 - 0x00F8)
class UIsInAnyHookedSurvivorOriginatorAuraReadingRange final : public URangeBasedCondition
{
public:
	uint8                                         Pad_F8[0xB0];                                      // 0x00F8(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsInAnyHookedSurvivorOriginatorAuraReadingRange">();
	}
	static class UIsInAnyHookedSurvivorOriginatorAuraReadingRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsInAnyHookedSurvivorOriginatorAuraReadingRange>();
	}
};
static_assert(alignof(UIsInAnyHookedSurvivorOriginatorAuraReadingRange) == 0x000008, "Wrong alignment on UIsInAnyHookedSurvivorOriginatorAuraReadingRange");
static_assert(sizeof(UIsInAnyHookedSurvivorOriginatorAuraReadingRange) == 0x0001A8, "Wrong size on UIsInAnyHookedSurvivorOriginatorAuraReadingRange");

// Class DBDCompetence.ActivateOnEventTargetActivationStrategy
// 0x0000 (0x0030 - 0x0030)
class UActivateOnEventTargetActivationStrategy final : public UActivateOnEventBaseActivationStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivateOnEventTargetActivationStrategy">();
	}
	static class UActivateOnEventTargetActivationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivateOnEventTargetActivationStrategy>();
	}
};
static_assert(alignof(UActivateOnEventTargetActivationStrategy) == 0x000008, "Wrong alignment on UActivateOnEventTargetActivationStrategy");
static_assert(sizeof(UActivateOnEventTargetActivationStrategy) == 0x000030, "Wrong size on UActivateOnEventTargetActivationStrategy");

// Class DBDCompetence.HideSurvivorVFXForKillerEffect
// 0x0000 (0x0398 - 0x0398)
class UHideSurvivorVFXForKillerEffect final : public UStatusEffect
{
public:
	void HideVFX(bool Hide);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HideSurvivorVFXForKillerEffect">();
	}
	static class UHideSurvivorVFXForKillerEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHideSurvivorVFXForKillerEffect>();
	}
};
static_assert(alignof(UHideSurvivorVFXForKillerEffect) == 0x000008, "Wrong alignment on UHideSurvivorVFXForKillerEffect");
static_assert(sizeof(UHideSurvivorVFXForKillerEffect) == 0x000398, "Wrong size on UHideSurvivorVFXForKillerEffect");

// Class DBDCompetence.ActivateOnEventInstigatorActivationStrategy
// 0x0000 (0x0030 - 0x0030)
class UActivateOnEventInstigatorActivationStrategy final : public UActivateOnEventBaseActivationStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivateOnEventInstigatorActivationStrategy">();
	}
	static class UActivateOnEventInstigatorActivationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivateOnEventInstigatorActivationStrategy>();
	}
};
static_assert(alignof(UActivateOnEventInstigatorActivationStrategy) == 0x000008, "Wrong alignment on UActivateOnEventInstigatorActivationStrategy");
static_assert(sizeof(UActivateOnEventInstigatorActivationStrategy) == 0x000030, "Wrong size on UActivateOnEventInstigatorActivationStrategy");

// Class DBDCompetence.ActivateStatusEffectBaseCondition
// 0x0000 (0x0030 - 0x0030)
class UActivateStatusEffectBaseCondition : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivateStatusEffectBaseCondition">();
	}
	static class UActivateStatusEffectBaseCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivateStatusEffectBaseCondition>();
	}
};
static_assert(alignof(UActivateStatusEffectBaseCondition) == 0x000008, "Wrong alignment on UActivateStatusEffectBaseCondition");
static_assert(sizeof(UActivateStatusEffectBaseCondition) == 0x000030, "Wrong size on UActivateStatusEffectBaseCondition");

// Class DBDCompetence.HexHauntedGround
// 0x0028 (0x0508 - 0x04E0)
class UHexHauntedGround final : public UHexPerk
{
public:
	float                                         _exposedStatusEffectDuration[0x3];                 // 0x04E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4EC[0x4];                                      // 0x04EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _exposedStatusEffectClass;                         // 0x04F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F8[0x10];                                     // 0x04F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetExposedDurationAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HexHauntedGround">();
	}
	static class UHexHauntedGround* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHexHauntedGround>();
	}
};
static_assert(alignof(UHexHauntedGround) == 0x000008, "Wrong alignment on UHexHauntedGround");
static_assert(sizeof(UHexHauntedGround) == 0x000508, "Wrong size on UHexHauntedGround");
static_assert(offsetof(UHexHauntedGround, _exposedStatusEffectDuration) == 0x0004E0, "Member 'UHexHauntedGround::_exposedStatusEffectDuration' has a wrong offset!");
static_assert(offsetof(UHexHauntedGround, _exposedStatusEffectClass) == 0x0004F0, "Member 'UHexHauntedGround::_exposedStatusEffectClass' has a wrong offset!");

// Class DBDCompetence.ActivateStatusEffectCooldownIsDoneCondition
// 0x0000 (0x0030 - 0x0030)
class UActivateStatusEffectCooldownIsDoneCondition final : public UActivateStatusEffectBaseCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivateStatusEffectCooldownIsDoneCondition">();
	}
	static class UActivateStatusEffectCooldownIsDoneCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivateStatusEffectCooldownIsDoneCondition>();
	}
};
static_assert(alignof(UActivateStatusEffectCooldownIsDoneCondition) == 0x000008, "Wrong alignment on UActivateStatusEffectCooldownIsDoneCondition");
static_assert(sizeof(UActivateStatusEffectCooldownIsDoneCondition) == 0x000030, "Wrong size on UActivateStatusEffectCooldownIsDoneCondition");

// Class DBDCompetence.HasPlayerReachedWiggleFillPercentCondition
// 0x0008 (0x00F8 - 0x00F0)
class UHasPlayerReachedWiggleFillPercentCondition final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_F0[0x4];                                       // 0x00F0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isWigglePercentReached;                           // 0x00F4(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F5[0x3];                                       // 0x00F5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnOwnerWiggleChargePercentChanged(class UChargeableComponent* ChargeableComponent, float PercentCompletionChange, float TotalPercentComplete);
	void OnRep_IsWigglePercentReached();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HasPlayerReachedWiggleFillPercentCondition">();
	}
	static class UHasPlayerReachedWiggleFillPercentCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHasPlayerReachedWiggleFillPercentCondition>();
	}
};
static_assert(alignof(UHasPlayerReachedWiggleFillPercentCondition) == 0x000008, "Wrong alignment on UHasPlayerReachedWiggleFillPercentCondition");
static_assert(sizeof(UHasPlayerReachedWiggleFillPercentCondition) == 0x0000F8, "Wrong size on UHasPlayerReachedWiggleFillPercentCondition");
static_assert(offsetof(UHasPlayerReachedWiggleFillPercentCondition, _isWigglePercentReached) == 0x0000F4, "Member 'UHasPlayerReachedWiggleFillPercentCondition::_isWigglePercentReached' has a wrong offset!");

// Class DBDCompetence.ActivateStatusEffectOnEventAlwaysStrategy
// 0x0000 (0x0030 - 0x0030)
class UActivateStatusEffectOnEventAlwaysStrategy final : public UActivateStatusEffectOnEventBaseStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivateStatusEffectOnEventAlwaysStrategy">();
	}
	static class UActivateStatusEffectOnEventAlwaysStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivateStatusEffectOnEventAlwaysStrategy>();
	}
};
static_assert(alignof(UActivateStatusEffectOnEventAlwaysStrategy) == 0x000008, "Wrong alignment on UActivateStatusEffectOnEventAlwaysStrategy");
static_assert(sizeof(UActivateStatusEffectOnEventAlwaysStrategy) == 0x000030, "Wrong size on UActivateStatusEffectOnEventAlwaysStrategy");

// Class DBDCompetence.HexThrillOfTheHunt
// 0x0020 (0x0500 - 0x04E0)
class UHexThrillOfTheHunt final : public UHexPerk
{
public:
	TSubclassOf<class UStatusEffect>              _thrillOfTheHuntStatusEffect;                      // 0x04E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _hunterPointsBonusPercent;                         // 0x04E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4EC[0x4];                                      // 0x04EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UStatusEffect*>                  _survivorThrillOfTheHuntEffects;                   // 0x04F0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HexThrillOfTheHunt">();
	}
	static class UHexThrillOfTheHunt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHexThrillOfTheHunt>();
	}
};
static_assert(alignof(UHexThrillOfTheHunt) == 0x000008, "Wrong alignment on UHexThrillOfTheHunt");
static_assert(sizeof(UHexThrillOfTheHunt) == 0x000500, "Wrong size on UHexThrillOfTheHunt");
static_assert(offsetof(UHexThrillOfTheHunt, _thrillOfTheHuntStatusEffect) == 0x0004E0, "Member 'UHexThrillOfTheHunt::_thrillOfTheHuntStatusEffect' has a wrong offset!");
static_assert(offsetof(UHexThrillOfTheHunt, _hunterPointsBonusPercent) == 0x0004E8, "Member 'UHexThrillOfTheHunt::_hunterPointsBonusPercent' has a wrong offset!");
static_assert(offsetof(UHexThrillOfTheHunt, _survivorThrillOfTheHuntEffects) == 0x0004F0, "Member 'UHexThrillOfTheHunt::_survivorThrillOfTheHuntEffects' has a wrong offset!");

// Class DBDCompetence.ActivateStatusEffectOnEventTargetStrategy
// 0x0000 (0x0030 - 0x0030)
class UActivateStatusEffectOnEventTargetStrategy final : public UActivateStatusEffectOnEventBaseStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivateStatusEffectOnEventTargetStrategy">();
	}
	static class UActivateStatusEffectOnEventTargetStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivateStatusEffectOnEventTargetStrategy>();
	}
};
static_assert(alignof(UActivateStatusEffectOnEventTargetStrategy) == 0x000008, "Wrong alignment on UActivateStatusEffectOnEventTargetStrategy");
static_assert(sizeof(UActivateStatusEffectOnEventTargetStrategy) == 0x000030, "Wrong size on UActivateStatusEffectOnEventTargetStrategy");

// Class DBDCompetence.ActivateStatusEffectOnEventInRangeOfTargetStrategy
// 0x0030 (0x0060 - 0x0030)
class UActivateStatusEffectOnEventInRangeOfTargetStrategy final : public UActivateStatusEffectOnEventBaseStrategy
{
public:
	float                                         _range;                                            // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _tunableRange;                                     // 0x0038(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivateStatusEffectOnEventInRangeOfTargetStrategy">();
	}
	static class UActivateStatusEffectOnEventInRangeOfTargetStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivateStatusEffectOnEventInRangeOfTargetStrategy>();
	}
};
static_assert(alignof(UActivateStatusEffectOnEventInRangeOfTargetStrategy) == 0x000008, "Wrong alignment on UActivateStatusEffectOnEventInRangeOfTargetStrategy");
static_assert(sizeof(UActivateStatusEffectOnEventInRangeOfTargetStrategy) == 0x000060, "Wrong size on UActivateStatusEffectOnEventInRangeOfTargetStrategy");
static_assert(offsetof(UActivateStatusEffectOnEventInRangeOfTargetStrategy, _range) == 0x000030, "Member 'UActivateStatusEffectOnEventInRangeOfTargetStrategy::_range' has a wrong offset!");
static_assert(offsetof(UActivateStatusEffectOnEventInRangeOfTargetStrategy, _tunableRange) == 0x000038, "Member 'UActivateStatusEffectOnEventInRangeOfTargetStrategy::_tunableRange' has a wrong offset!");

// Class DBDCompetence.Insidious
// 0x0018 (0x0478 - 0x0460)
class UInsidious final : public UPerk
{
public:
	float                                         _stillnessRequired[0x3];                           // 0x0460(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_46C[0x4];                                      // 0x046C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _insidiousEffect;                                  // 0x0470(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	float GetStillnessRequiredAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Insidious">();
	}
	static class UInsidious* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInsidious>();
	}
};
static_assert(alignof(UInsidious) == 0x000008, "Wrong alignment on UInsidious");
static_assert(sizeof(UInsidious) == 0x000478, "Wrong size on UInsidious");
static_assert(offsetof(UInsidious, _stillnessRequired) == 0x000460, "Member 'UInsidious::_stillnessRequired' has a wrong offset!");
static_assert(offsetof(UInsidious, _insidiousEffect) == 0x000470, "Member 'UInsidious::_insidiousEffect' has a wrong offset!");

// Class DBDCompetence.ActivateStatusEffectOnOwnerEventTargetInsideRangeOfOriginatingPlayerStrategy
// 0x0028 (0x0058 - 0x0030)
class UActivateStatusEffectOnOwnerEventTargetInsideRangeOfOriginatingPlayerStrategy final : public UActivateStatusEffectOnEventBaseStrategy
{
public:
	struct FDBDTunableRowHandle                   _range;                                            // 0x0030(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivateStatusEffectOnOwnerEventTargetInsideRangeOfOriginatingPlayerStrategy">();
	}
	static class UActivateStatusEffectOnOwnerEventTargetInsideRangeOfOriginatingPlayerStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivateStatusEffectOnOwnerEventTargetInsideRangeOfOriginatingPlayerStrategy>();
	}
};
static_assert(alignof(UActivateStatusEffectOnOwnerEventTargetInsideRangeOfOriginatingPlayerStrategy) == 0x000008, "Wrong alignment on UActivateStatusEffectOnOwnerEventTargetInsideRangeOfOriginatingPlayerStrategy");
static_assert(sizeof(UActivateStatusEffectOnOwnerEventTargetInsideRangeOfOriginatingPlayerStrategy) == 0x000058, "Wrong size on UActivateStatusEffectOnOwnerEventTargetInsideRangeOfOriginatingPlayerStrategy");
static_assert(offsetof(UActivateStatusEffectOnOwnerEventTargetInsideRangeOfOriginatingPlayerStrategy, _range) == 0x000030, "Member 'UActivateStatusEffectOnOwnerEventTargetInsideRangeOfOriginatingPlayerStrategy::_range' has a wrong offset!");

// Class DBDCompetence.HexRuin
// 0x00E0 (0x05C0 - 0x04E0)
class UHexRuin final : public UHexPerk
{
public:
	uint8                                         Pad_4E0[0x10];                                     // 0x04E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AGenerator*, struct FFastTimer>    _curseActivationTimers;                            // 0x04F0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class AGenerator*>                     _authority_blockedGeneratorsToStartRegression;     // 0x0540(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	float                                         _regressionModifier[0x3];                          // 0x0550(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_55C[0x4];                                      // 0x055C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _ruinStatusEffectClass;                            // 0x0560(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class AGenerator*, uint64>               _gameplayModifierHandles;                          // 0x0568(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class UStatusEffect*                          _ruinStatusEffect;                                 // 0x05B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_SetupCurseOnAllGenerators();

	const float GetRegressionModifierByLevel(int32 PerkLevel) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HexRuin">();
	}
	static class UHexRuin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHexRuin>();
	}
};
static_assert(alignof(UHexRuin) == 0x000008, "Wrong alignment on UHexRuin");
static_assert(sizeof(UHexRuin) == 0x0005C0, "Wrong size on UHexRuin");
static_assert(offsetof(UHexRuin, _curseActivationTimers) == 0x0004F0, "Member 'UHexRuin::_curseActivationTimers' has a wrong offset!");
static_assert(offsetof(UHexRuin, _authority_blockedGeneratorsToStartRegression) == 0x000540, "Member 'UHexRuin::_authority_blockedGeneratorsToStartRegression' has a wrong offset!");
static_assert(offsetof(UHexRuin, _regressionModifier) == 0x000550, "Member 'UHexRuin::_regressionModifier' has a wrong offset!");
static_assert(offsetof(UHexRuin, _ruinStatusEffectClass) == 0x000560, "Member 'UHexRuin::_ruinStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UHexRuin, _gameplayModifierHandles) == 0x000568, "Member 'UHexRuin::_gameplayModifierHandles' has a wrong offset!");
static_assert(offsetof(UHexRuin, _ruinStatusEffect) == 0x0005B8, "Member 'UHexRuin::_ruinStatusEffect' has a wrong offset!");

// Class DBDCompetence.ActivateStatusEffectOnOwnerEventTargetOutsideRangeOfOriginatingPlayerStrategy
// 0x0030 (0x0060 - 0x0030)
class UActivateStatusEffectOnOwnerEventTargetOutsideRangeOfOriginatingPlayerStrategy final : public UActivateStatusEffectOnEventBaseStrategy
{
public:
	float                                         _range;                                            // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _tunableRange;                                     // 0x0038(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivateStatusEffectOnOwnerEventTargetOutsideRangeOfOriginatingPlayerStrategy">();
	}
	static class UActivateStatusEffectOnOwnerEventTargetOutsideRangeOfOriginatingPlayerStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivateStatusEffectOnOwnerEventTargetOutsideRangeOfOriginatingPlayerStrategy>();
	}
};
static_assert(alignof(UActivateStatusEffectOnOwnerEventTargetOutsideRangeOfOriginatingPlayerStrategy) == 0x000008, "Wrong alignment on UActivateStatusEffectOnOwnerEventTargetOutsideRangeOfOriginatingPlayerStrategy");
static_assert(sizeof(UActivateStatusEffectOnOwnerEventTargetOutsideRangeOfOriginatingPlayerStrategy) == 0x000060, "Wrong size on UActivateStatusEffectOnOwnerEventTargetOutsideRangeOfOriginatingPlayerStrategy");
static_assert(offsetof(UActivateStatusEffectOnOwnerEventTargetOutsideRangeOfOriginatingPlayerStrategy, _range) == 0x000030, "Member 'UActivateStatusEffectOnOwnerEventTargetOutsideRangeOfOriginatingPlayerStrategy::_range' has a wrong offset!");
static_assert(offsetof(UActivateStatusEffectOnOwnerEventTargetOutsideRangeOfOriginatingPlayerStrategy, _tunableRange) == 0x000038, "Member 'UActivateStatusEffectOnOwnerEventTargetOutsideRangeOfOriginatingPlayerStrategy::_tunableRange' has a wrong offset!");

// Class DBDCompetence.ActivateStatusEffectOnEventInstigatorInsideRangeOfOriginatingPlayerStrategy
// 0x0030 (0x0060 - 0x0030)
class UActivateStatusEffectOnEventInstigatorInsideRangeOfOriginatingPlayerStrategy final : public UActivateStatusEffectOnEventBaseStrategy
{
public:
	float                                         _range;                                            // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _tunableRange;                                     // 0x0038(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivateStatusEffectOnEventInstigatorInsideRangeOfOriginatingPlayerStrategy">();
	}
	static class UActivateStatusEffectOnEventInstigatorInsideRangeOfOriginatingPlayerStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivateStatusEffectOnEventInstigatorInsideRangeOfOriginatingPlayerStrategy>();
	}
};
static_assert(alignof(UActivateStatusEffectOnEventInstigatorInsideRangeOfOriginatingPlayerStrategy) == 0x000008, "Wrong alignment on UActivateStatusEffectOnEventInstigatorInsideRangeOfOriginatingPlayerStrategy");
static_assert(sizeof(UActivateStatusEffectOnEventInstigatorInsideRangeOfOriginatingPlayerStrategy) == 0x000060, "Wrong size on UActivateStatusEffectOnEventInstigatorInsideRangeOfOriginatingPlayerStrategy");
static_assert(offsetof(UActivateStatusEffectOnEventInstigatorInsideRangeOfOriginatingPlayerStrategy, _range) == 0x000030, "Member 'UActivateStatusEffectOnEventInstigatorInsideRangeOfOriginatingPlayerStrategy::_range' has a wrong offset!");
static_assert(offsetof(UActivateStatusEffectOnEventInstigatorInsideRangeOfOriginatingPlayerStrategy, _tunableRange) == 0x000038, "Member 'UActivateStatusEffectOnEventInstigatorInsideRangeOfOriginatingPlayerStrategy::_tunableRange' has a wrong offset!");

// Class DBDCompetence.ActivationTimerSkill
// 0x0000 (0x0388 - 0x0388)
class UActivationTimerSkill final : public USkill
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivationTimerSkill">();
	}
	static class UActivationTimerSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivationTimerSkill>();
	}
};
static_assert(alignof(UActivationTimerSkill) == 0x000008, "Wrong alignment on UActivationTimerSkill");
static_assert(sizeof(UActivationTimerSkill) == 0x000388, "Wrong size on UActivationTimerSkill");

// Class DBDCompetence.DecisiveStrikePerkIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UDecisiveStrikePerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DecisiveStrikePerkIconStrategy">();
	}
	static class UDecisiveStrikePerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDecisiveStrikePerkIconStrategy>();
	}
};
static_assert(alignof(UDecisiveStrikePerkIconStrategy) == 0x000008, "Wrong alignment on UDecisiveStrikePerkIconStrategy");
static_assert(sizeof(UDecisiveStrikePerkIconStrategy) == 0x000038, "Wrong size on UDecisiveStrikePerkIconStrategy");

// Class DBDCompetence.AddComponentToPlayerAction
// 0x0008 (0x0048 - 0x0040)
class UAddComponentToPlayerAction final : public UCompetenceAction
{
public:
	TSubclassOf<class UActorComponent>            _componentClass;                                   // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddComponentToPlayerAction">();
	}
	static class UAddComponentToPlayerAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddComponentToPlayerAction>();
	}
};
static_assert(alignof(UAddComponentToPlayerAction) == 0x000008, "Wrong alignment on UAddComponentToPlayerAction");
static_assert(sizeof(UAddComponentToPlayerAction) == 0x000048, "Wrong size on UAddComponentToPlayerAction");
static_assert(offsetof(UAddComponentToPlayerAction, _componentClass) == 0x000040, "Member 'UAddComponentToPlayerAction::_componentClass' has a wrong offset!");

// Class DBDCompetence.DarkDevotion
// 0x0018 (0x0478 - 0x0460)
class UDarkDevotion final : public UPerk
{
public:
	class UTerrorRadiusEmitterComponent*          _obsessionTerrorRadiusEmitter;                     // 0x0460(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _obsessionTerrorRadius;                            // 0x0468(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _simulatedFixedDistance;                           // 0x046C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_470[0x8];                                      // 0x0470(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarkDevotion">();
	}
	static class UDarkDevotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarkDevotion>();
	}
};
static_assert(alignof(UDarkDevotion) == 0x000008, "Wrong alignment on UDarkDevotion");
static_assert(sizeof(UDarkDevotion) == 0x000478, "Wrong size on UDarkDevotion");
static_assert(offsetof(UDarkDevotion, _obsessionTerrorRadiusEmitter) == 0x000460, "Member 'UDarkDevotion::_obsessionTerrorRadiusEmitter' has a wrong offset!");
static_assert(offsetof(UDarkDevotion, _obsessionTerrorRadius) == 0x000468, "Member 'UDarkDevotion::_obsessionTerrorRadius' has a wrong offset!");
static_assert(offsetof(UDarkDevotion, _simulatedFixedDistance) == 0x00046C, "Member 'UDarkDevotion::_simulatedFixedDistance' has a wrong offset!");

// Class DBDCompetence.AddInteractionOnInteractableAction
// 0x0018 (0x0058 - 0x0040)
class UAddInteractionOnInteractableAction final : public UCompetenceAction
{
public:
	TSubclassOf<class AInteractable>              _interactableType;                                 // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UInteractionDefinition>     _interactionClass;                                 // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _skipInteractionIfAlreadyExisting;                 // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddInteractionOnInteractableAction">();
	}
	static class UAddInteractionOnInteractableAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddInteractionOnInteractableAction>();
	}
};
static_assert(alignof(UAddInteractionOnInteractableAction) == 0x000008, "Wrong alignment on UAddInteractionOnInteractableAction");
static_assert(sizeof(UAddInteractionOnInteractableAction) == 0x000058, "Wrong size on UAddInteractionOnInteractableAction");
static_assert(offsetof(UAddInteractionOnInteractableAction, _interactableType) == 0x000040, "Member 'UAddInteractionOnInteractableAction::_interactableType' has a wrong offset!");
static_assert(offsetof(UAddInteractionOnInteractableAction, _interactionClass) == 0x000048, "Member 'UAddInteractionOnInteractableAction::_interactionClass' has a wrong offset!");
static_assert(offsetof(UAddInteractionOnInteractableAction, _skipInteractionIfAlreadyExisting) == 0x000050, "Member 'UAddInteractionOnInteractableAction::_skipInteractionIfAlreadyExisting' has a wrong offset!");

// Class DBDCompetence.AddInteractionOnPlayerAction
// 0x0018 (0x0058 - 0x0040)
class UAddInteractionOnPlayerAction final : public UCompetenceAction
{
public:
	TSubclassOf<class UInteractionDefinition>     _interactionClass;                                 // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EInteractionOwnerType                         _interactionOwnerType;                             // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionAttacherComponent*          _interactionAttacherComponent;                     // 0x0050(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddInteractionOnPlayerAction">();
	}
	static class UAddInteractionOnPlayerAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddInteractionOnPlayerAction>();
	}
};
static_assert(alignof(UAddInteractionOnPlayerAction) == 0x000008, "Wrong alignment on UAddInteractionOnPlayerAction");
static_assert(sizeof(UAddInteractionOnPlayerAction) == 0x000058, "Wrong size on UAddInteractionOnPlayerAction");
static_assert(offsetof(UAddInteractionOnPlayerAction, _interactionClass) == 0x000040, "Member 'UAddInteractionOnPlayerAction::_interactionClass' has a wrong offset!");
static_assert(offsetof(UAddInteractionOnPlayerAction, _interactionOwnerType) == 0x000048, "Member 'UAddInteractionOnPlayerAction::_interactionOwnerType' has a wrong offset!");
static_assert(offsetof(UAddInteractionOnPlayerAction, _interactionAttacherComponent) == 0x000050, "Member 'UAddInteractionOnPlayerAction::_interactionAttacherComponent' has a wrong offset!");

// Class DBDCompetence.IsBoonBlessed
// 0x0010 (0x0100 - 0x00F0)
class UIsBoonBlessed final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_F0[0x10];                                      // 0x00F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsBoonBlessed">();
	}
	static class UIsBoonBlessed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsBoonBlessed>();
	}
};
static_assert(alignof(UIsBoonBlessed) == 0x000008, "Wrong alignment on UIsBoonBlessed");
static_assert(sizeof(UIsBoonBlessed) == 0x000100, "Wrong size on UIsBoonBlessed");

// Class DBDCompetence.AddMaxAmmoAction
// 0x0008 (0x0048 - 0x0040)
class UAddMaxAmmoAction final : public UCompetenceAction
{
public:
	int32                                         _countModifier;                                    // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddMaxAmmoAction">();
	}
	static class UAddMaxAmmoAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddMaxAmmoAction>();
	}
};
static_assert(alignof(UAddMaxAmmoAction) == 0x000008, "Wrong alignment on UAddMaxAmmoAction");
static_assert(sizeof(UAddMaxAmmoAction) == 0x000048, "Wrong size on UAddMaxAmmoAction");
static_assert(offsetof(UAddMaxAmmoAction, _countModifier) == 0x000040, "Member 'UAddMaxAmmoAction::_countModifier' has a wrong offset!");

// Class DBDCompetence.GameplayModifierContainerWrapperSkill
// 0x0018 (0x03A0 - 0x0388)
class UGameplayModifierContainerWrapperSkill : public USkill
{
public:
	class FName                                   _gameplayModifierContainerId;                      // 0x0388(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayModifierContainer*             _spawnedGameplayModifierContainer;                 // 0x0398(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_SpawnedGameplayModifierContainer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayModifierContainerWrapperSkill">();
	}
	static class UGameplayModifierContainerWrapperSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayModifierContainerWrapperSkill>();
	}
};
static_assert(alignof(UGameplayModifierContainerWrapperSkill) == 0x000008, "Wrong alignment on UGameplayModifierContainerWrapperSkill");
static_assert(sizeof(UGameplayModifierContainerWrapperSkill) == 0x0003A0, "Wrong size on UGameplayModifierContainerWrapperSkill");
static_assert(offsetof(UGameplayModifierContainerWrapperSkill, _gameplayModifierContainerId) == 0x000388, "Member 'UGameplayModifierContainerWrapperSkill::_gameplayModifierContainerId' has a wrong offset!");
static_assert(offsetof(UGameplayModifierContainerWrapperSkill, _spawnedGameplayModifierContainer) == 0x000398, "Member 'UGameplayModifierContainerWrapperSkill::_spawnedGameplayModifierContainer' has a wrong offset!");

// Class DBDCompetence.IsLifetimeActive
// 0x0010 (0x0100 - 0x00F0)
class UIsLifetimeActive final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_F0[0x10];                                      // 0x00F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsLifetimeActive">();
	}
	static class UIsLifetimeActive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsLifetimeActive>();
	}
};
static_assert(alignof(UIsLifetimeActive) == 0x000008, "Wrong alignment on UIsLifetimeActive");
static_assert(sizeof(UIsLifetimeActive) == 0x000100, "Wrong size on UIsLifetimeActive");

// Class DBDCompetence.AddonWrapperSkill
// 0x0000 (0x03A0 - 0x03A0)
class UAddonWrapperSkill final : public UGameplayModifierContainerWrapperSkill
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddonWrapperSkill">();
	}
	static class UAddonWrapperSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddonWrapperSkill>();
	}
};
static_assert(alignof(UAddonWrapperSkill) == 0x000008, "Wrong alignment on UAddonWrapperSkill");
static_assert(sizeof(UAddonWrapperSkill) == 0x0003A0, "Wrong size on UAddonWrapperSkill");

// Class DBDCompetence.AddStateTagsAction
// 0x0030 (0x0070 - 0x0040)
class UAddStateTagsAction final : public UCompetenceAction
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _stateTags;                                        // 0x0048(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          _applyOnInitialized;                               // 0x0068(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _applyToEventInstigator;                           // 0x0069(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _applyToEventTarget;                               // 0x006A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6B[0x5];                                       // 0x006B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddStateTagsAction">();
	}
	static class UAddStateTagsAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddStateTagsAction>();
	}
};
static_assert(alignof(UAddStateTagsAction) == 0x000008, "Wrong alignment on UAddStateTagsAction");
static_assert(sizeof(UAddStateTagsAction) == 0x000070, "Wrong size on UAddStateTagsAction");
static_assert(offsetof(UAddStateTagsAction, _stateTags) == 0x000048, "Member 'UAddStateTagsAction::_stateTags' has a wrong offset!");
static_assert(offsetof(UAddStateTagsAction, _applyOnInitialized) == 0x000068, "Member 'UAddStateTagsAction::_applyOnInitialized' has a wrong offset!");
static_assert(offsetof(UAddStateTagsAction, _applyToEventInstigator) == 0x000069, "Member 'UAddStateTagsAction::_applyToEventInstigator' has a wrong offset!");
static_assert(offsetof(UAddStateTagsAction, _applyToEventTarget) == 0x00006A, "Member 'UAddStateTagsAction::_applyToEventTarget' has a wrong offset!");

// Class DBDCompetence.IsHexCursed
// 0x0010 (0x0100 - 0x00F0)
class UIsHexCursed final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_F0[0x10];                                      // 0x00F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsHexCursed">();
	}
	static class UIsHexCursed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsHexCursed>();
	}
};
static_assert(alignof(UIsHexCursed) == 0x000008, "Wrong alignment on UIsHexCursed");
static_assert(sizeof(UIsHexCursed) == 0x000100, "Wrong size on UIsHexCursed");

// Class DBDCompetence.AddStateTagsToSurvivorsAction
// 0x0030 (0x0070 - 0x0040)
class UAddStateTagsToSurvivorsAction final : public UCompetenceAction
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _stateTags;                                        // 0x0048(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          _applyOnInitialized;                               // 0x0068(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddStateTagsToSurvivorsAction">();
	}
	static class UAddStateTagsToSurvivorsAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddStateTagsToSurvivorsAction>();
	}
};
static_assert(alignof(UAddStateTagsToSurvivorsAction) == 0x000008, "Wrong alignment on UAddStateTagsToSurvivorsAction");
static_assert(sizeof(UAddStateTagsToSurvivorsAction) == 0x000070, "Wrong size on UAddStateTagsToSurvivorsAction");
static_assert(offsetof(UAddStateTagsToSurvivorsAction, _stateTags) == 0x000048, "Member 'UAddStateTagsToSurvivorsAction::_stateTags' has a wrong offset!");
static_assert(offsetof(UAddStateTagsToSurvivorsAction, _applyOnInitialized) == 0x000068, "Member 'UAddStateTagsToSurvivorsAction::_applyOnInitialized' has a wrong offset!");

// Class DBDCompetence.IsActivationTimerDone
// 0x0018 (0x0108 - 0x00F0)
class UIsActivationTimerDone final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_F0[0x18];                                      // 0x00F0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsActivationTimerDone">();
	}
	static class UIsActivationTimerDone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsActivationTimerDone>();
	}
};
static_assert(alignof(UIsActivationTimerDone) == 0x000008, "Wrong alignment on UIsActivationTimerDone");
static_assert(sizeof(UIsActivationTimerDone) == 0x000108, "Wrong size on UIsActivationTimerDone");

// Class DBDCompetence.AddStatusEffectToClosestTargetAction
// 0x0000 (0x00F0 - 0x00F0)
class UAddStatusEffectToClosestTargetAction final : public UAddStatusEffectAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddStatusEffectToClosestTargetAction">();
	}
	static class UAddStatusEffectToClosestTargetAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddStatusEffectToClosestTargetAction>();
	}
};
static_assert(alignof(UAddStatusEffectToClosestTargetAction) == 0x000008, "Wrong alignment on UAddStatusEffectToClosestTargetAction");
static_assert(sizeof(UAddStatusEffectToClosestTargetAction) == 0x0000F0, "Wrong size on UAddStatusEffectToClosestTargetAction");

// Class DBDCompetence.IsInRangeOfAnyOtherKiller
// 0x0008 (0x0110 - 0x0108)
class UIsInRangeOfAnyOtherKiller final : public UAnyActorPairQueryRangeIsTrue
{
public:
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsInRangeOfAnyOtherKiller">();
	}
	static class UIsInRangeOfAnyOtherKiller* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsInRangeOfAnyOtherKiller>();
	}
};
static_assert(alignof(UIsInRangeOfAnyOtherKiller) == 0x000008, "Wrong alignment on UIsInRangeOfAnyOtherKiller");
static_assert(sizeof(UIsInRangeOfAnyOtherKiller) == 0x000110, "Wrong size on UIsInRangeOfAnyOtherKiller");

// Class DBDCompetence.AddStatusEffectToLastGameEventObjectAction
// 0x0030 (0x0120 - 0x00F0)
class UAddStatusEffectToLastGameEventObjectAction final : public UAddStatusEffectAction
{
public:
	struct FGameplayTag                           _gameEvent;                                        // 0x00F0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGameEventObjectType                          _gameEventObjectType;                              // 0x00FC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _withinTime;                                       // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_104[0x1C];                                     // 0x0104(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddStatusEffectToLastGameEventObjectAction">();
	}
	static class UAddStatusEffectToLastGameEventObjectAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddStatusEffectToLastGameEventObjectAction>();
	}
};
static_assert(alignof(UAddStatusEffectToLastGameEventObjectAction) == 0x000008, "Wrong alignment on UAddStatusEffectToLastGameEventObjectAction");
static_assert(sizeof(UAddStatusEffectToLastGameEventObjectAction) == 0x000120, "Wrong size on UAddStatusEffectToLastGameEventObjectAction");
static_assert(offsetof(UAddStatusEffectToLastGameEventObjectAction, _gameEvent) == 0x0000F0, "Member 'UAddStatusEffectToLastGameEventObjectAction::_gameEvent' has a wrong offset!");
static_assert(offsetof(UAddStatusEffectToLastGameEventObjectAction, _gameEventObjectType) == 0x0000FC, "Member 'UAddStatusEffectToLastGameEventObjectAction::_gameEventObjectType' has a wrong offset!");
static_assert(offsetof(UAddStatusEffectToLastGameEventObjectAction, _withinTime) == 0x000100, "Member 'UAddStatusEffectToLastGameEventObjectAction::_withinTime' has a wrong offset!");

// Class DBDCompetence.AddSurvivorCosmeticHelperActorAction
// 0x0010 (0x0050 - 0x0040)
class UAddSurvivorCosmeticHelperActorAction final : public UCompetenceAction
{
public:
	TSubclassOf<class ASurvivorCosmeticHelperActor> _actorClass;                                     // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _addToOwningSurvivor;                              // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddSurvivorCosmeticHelperActorAction">();
	}
	static class UAddSurvivorCosmeticHelperActorAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddSurvivorCosmeticHelperActorAction>();
	}
};
static_assert(alignof(UAddSurvivorCosmeticHelperActorAction) == 0x000008, "Wrong alignment on UAddSurvivorCosmeticHelperActorAction");
static_assert(sizeof(UAddSurvivorCosmeticHelperActorAction) == 0x000050, "Wrong size on UAddSurvivorCosmeticHelperActorAction");
static_assert(offsetof(UAddSurvivorCosmeticHelperActorAction, _actorClass) == 0x000040, "Member 'UAddSurvivorCosmeticHelperActorAction::_actorClass' has a wrong offset!");
static_assert(offsetof(UAddSurvivorCosmeticHelperActorAction, _addToOwningSurvivor) == 0x000048, "Member 'UAddSurvivorCosmeticHelperActorAction::_addToOwningSurvivor' has a wrong offset!");

// Class DBDCompetence.AddUniqueComponentToSurvivorsAction
// 0x0008 (0x0048 - 0x0040)
class UAddUniqueComponentToSurvivorsAction final : public UCompetenceAction
{
public:
	TSubclassOf<class UActorComponent>            _componentClass;                                   // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddUniqueComponentToSurvivorsAction">();
	}
	static class UAddUniqueComponentToSurvivorsAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddUniqueComponentToSurvivorsAction>();
	}
};
static_assert(alignof(UAddUniqueComponentToSurvivorsAction) == 0x000008, "Wrong alignment on UAddUniqueComponentToSurvivorsAction");
static_assert(sizeof(UAddUniqueComponentToSurvivorsAction) == 0x000048, "Wrong size on UAddUniqueComponentToSurvivorsAction");
static_assert(offsetof(UAddUniqueComponentToSurvivorsAction, _componentClass) == 0x000040, "Member 'UAddUniqueComponentToSurvivorsAction::_componentClass' has a wrong offset!");

// Class DBDCompetence.AlertKillerRevealEffect
// 0x0000 (0x0398 - 0x0398)
class UAlertKillerRevealEffect final : public UStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AlertKillerRevealEffect">();
	}
	static class UAlertKillerRevealEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAlertKillerRevealEffect>();
	}
};
static_assert(alignof(UAlertKillerRevealEffect) == 0x000008, "Wrong alignment on UAlertKillerRevealEffect");
static_assert(sizeof(UAlertKillerRevealEffect) == 0x000398, "Wrong size on UAlertKillerRevealEffect");

// Class DBDCompetence.IsHighestTierOriginatingPerk
// 0x0018 (0x0108 - 0x00F0)
class UIsHighestTierOriginatingPerk final : public UEventDrivenModifierCondition
{
public:
	TArray<class UStatusEffect*>                  _applicableEffects;                                // 0x00F0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameplayModifierContainerInitialized();
	void OnStatusEffectAddedOrRemoved(class UStatusEffect* effect, bool Valid);
	void OnStatusEffectApplicableChanged(class UGameplayModifierContainer* GameplayModifierContainer, bool IsApplicable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsHighestTierOriginatingPerk">();
	}
	static class UIsHighestTierOriginatingPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsHighestTierOriginatingPerk>();
	}
};
static_assert(alignof(UIsHighestTierOriginatingPerk) == 0x000008, "Wrong alignment on UIsHighestTierOriginatingPerk");
static_assert(sizeof(UIsHighestTierOriginatingPerk) == 0x000108, "Wrong size on UIsHighestTierOriginatingPerk");
static_assert(offsetof(UIsHighestTierOriginatingPerk, _applicableEffects) == 0x0000F0, "Member 'UIsHighestTierOriginatingPerk::_applicableEffects' has a wrong offset!");

// Class DBDCompetence.AllHexTotemsAreActive
// 0x0010 (0x0100 - 0x00F0)
class UAllHexTotemsAreActive final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_F0[0x10];                                      // 0x00F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AllHexTotemsAreActive">();
	}
	static class UAllHexTotemsAreActive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAllHexTotemsAreActive>();
	}
};
static_assert(alignof(UAllHexTotemsAreActive) == 0x000008, "Wrong alignment on UAllHexTotemsAreActive");
static_assert(sizeof(UAllHexTotemsAreActive) == 0x000100, "Wrong size on UAllHexTotemsAreActive");

// Class DBDCompetence.AllowSelfRecoverAction
// 0x0030 (0x0070 - 0x0040)
class UAllowSelfRecoverAction final : public UCompetenceAction
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _enduranceStatusEffect;                            // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _hasteStatusEffect;                                // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _enduranceDuration;                                // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _hasteDuration;                                    // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _hasteAmount;                                      // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _soloRecoveryBonusThreshold;                       // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnHealProgress(float IndividualChargeAmount, float TotalChargeAmount, class AActor* ChargeInstigator, bool WasCoop, float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AllowSelfRecoverAction">();
	}
	static class UAllowSelfRecoverAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAllowSelfRecoverAction>();
	}
};
static_assert(alignof(UAllowSelfRecoverAction) == 0x000008, "Wrong alignment on UAllowSelfRecoverAction");
static_assert(sizeof(UAllowSelfRecoverAction) == 0x000070, "Wrong size on UAllowSelfRecoverAction");
static_assert(offsetof(UAllowSelfRecoverAction, _enduranceStatusEffect) == 0x000050, "Member 'UAllowSelfRecoverAction::_enduranceStatusEffect' has a wrong offset!");
static_assert(offsetof(UAllowSelfRecoverAction, _hasteStatusEffect) == 0x000058, "Member 'UAllowSelfRecoverAction::_hasteStatusEffect' has a wrong offset!");
static_assert(offsetof(UAllowSelfRecoverAction, _enduranceDuration) == 0x000060, "Member 'UAllowSelfRecoverAction::_enduranceDuration' has a wrong offset!");
static_assert(offsetof(UAllowSelfRecoverAction, _hasteDuration) == 0x000064, "Member 'UAllowSelfRecoverAction::_hasteDuration' has a wrong offset!");
static_assert(offsetof(UAllowSelfRecoverAction, _hasteAmount) == 0x000068, "Member 'UAllowSelfRecoverAction::_hasteAmount' has a wrong offset!");
static_assert(offsetof(UAllowSelfRecoverAction, _soloRecoveryBonusThreshold) == 0x00006C, "Member 'UAllowSelfRecoverAction::_soloRecoveryBonusThreshold' has a wrong offset!");

// Class DBDCompetence.IsOutsideOfAnyHookedSurvivorRange
// 0x0000 (0x01E8 - 0x01E8)
class UIsOutsideOfAnyHookedSurvivorRange final : public UHookedSurvivorRangeBaseCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsOutsideOfAnyHookedSurvivorRange">();
	}
	static class UIsOutsideOfAnyHookedSurvivorRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsOutsideOfAnyHookedSurvivorRange>();
	}
};
static_assert(alignof(UIsOutsideOfAnyHookedSurvivorRange) == 0x000008, "Wrong alignment on UIsOutsideOfAnyHookedSurvivorRange");
static_assert(sizeof(UIsOutsideOfAnyHookedSurvivorRange) == 0x0001E8, "Wrong size on UIsOutsideOfAnyHookedSurvivorRange");

// Class DBDCompetence.ImposedStatusEffectCondition
// 0x0028 (0x0118 - 0x00F0)
class UImposedStatusEffectCondition : public UEventDrivenModifierCondition
{
public:
	TSubclassOf<class UStatusEffect>              _classTypeToMatch;                                 // 0x00F0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x18];                                      // 0x00F8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isApplicable;                                     // 0x0110(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_IsApplicable();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImposedStatusEffectCondition">();
	}
	static class UImposedStatusEffectCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImposedStatusEffectCondition>();
	}
};
static_assert(alignof(UImposedStatusEffectCondition) == 0x000008, "Wrong alignment on UImposedStatusEffectCondition");
static_assert(sizeof(UImposedStatusEffectCondition) == 0x000118, "Wrong size on UImposedStatusEffectCondition");
static_assert(offsetof(UImposedStatusEffectCondition, _classTypeToMatch) == 0x0000F0, "Member 'UImposedStatusEffectCondition::_classTypeToMatch' has a wrong offset!");
static_assert(offsetof(UImposedStatusEffectCondition, _isApplicable) == 0x000110, "Member 'UImposedStatusEffectCondition::_isApplicable' has a wrong offset!");

// Class DBDCompetence.AnyImposedStatusEffectIsApplicable
// 0x0000 (0x0118 - 0x0118)
class UAnyImposedStatusEffectIsApplicable final : public UImposedStatusEffectCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnyImposedStatusEffectIsApplicable">();
	}
	static class UAnyImposedStatusEffectIsApplicable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnyImposedStatusEffectIsApplicable>();
	}
};
static_assert(alignof(UAnyImposedStatusEffectIsApplicable) == 0x000008, "Wrong alignment on UAnyImposedStatusEffectIsApplicable");
static_assert(sizeof(UAnyImposedStatusEffectIsApplicable) == 0x000118, "Wrong size on UAnyImposedStatusEffectIsApplicable");

// Class DBDCompetence.IsPlayerHealingSurvivorDrainStageCondition
// 0x0050 (0x0198 - 0x0148)
class UIsPlayerHealingSurvivorDrainStageCondition final : public UNumericalConstraintsCondition_Int
{
public:
	uint8                                         Pad_148[0x50];                                     // 0x0148(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsPlayerHealingSurvivorDrainStageCondition">();
	}
	static class UIsPlayerHealingSurvivorDrainStageCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsPlayerHealingSurvivorDrainStageCondition>();
	}
};
static_assert(alignof(UIsPlayerHealingSurvivorDrainStageCondition) == 0x000008, "Wrong alignment on UIsPlayerHealingSurvivorDrainStageCondition");
static_assert(sizeof(UIsPlayerHealingSurvivorDrainStageCondition) == 0x000198, "Wrong size on UIsPlayerHealingSurvivorDrainStageCondition");

// Class DBDCompetence.AnyMeansNecessary
// 0x0018 (0x0478 - 0x0460)
class UAnyMeansNecessary final : public UPerk
{
public:
	float                                         _actionSpeedBonus[0x3];                            // 0x0460(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_46C[0x4];                                      // 0x046C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _anyMeansNecessaryActionSpeedEffect;               // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnPalletPulledUp(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnyMeansNecessary">();
	}
	static class UAnyMeansNecessary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnyMeansNecessary>();
	}
};
static_assert(alignof(UAnyMeansNecessary) == 0x000008, "Wrong alignment on UAnyMeansNecessary");
static_assert(sizeof(UAnyMeansNecessary) == 0x000478, "Wrong size on UAnyMeansNecessary");
static_assert(offsetof(UAnyMeansNecessary, _actionSpeedBonus) == 0x000460, "Member 'UAnyMeansNecessary::_actionSpeedBonus' has a wrong offset!");
static_assert(offsetof(UAnyMeansNecessary, _anyMeansNecessaryActionSpeedEffect) == 0x000470, "Member 'UAnyMeansNecessary::_anyMeansNecessaryActionSpeedEffect' has a wrong offset!");

// Class DBDCompetence.AnySurvivorHasObjectState
// 0x0070 (0x0160 - 0x00F0)
class UAnySurvivorHasObjectState final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_F0[0x50];                                      // 0x00F0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _stateTag;                                         // 0x0140(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14C[0x14];                                     // 0x014C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSurvivorAdded(class ASurvivor* Survivor);
	void OnSurvivorRemoved(class ASurvivor* Survivor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnySurvivorHasObjectState">();
	}
	static class UAnySurvivorHasObjectState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnySurvivorHasObjectState>();
	}
};
static_assert(alignof(UAnySurvivorHasObjectState) == 0x000008, "Wrong alignment on UAnySurvivorHasObjectState");
static_assert(sizeof(UAnySurvivorHasObjectState) == 0x000160, "Wrong size on UAnySurvivorHasObjectState");
static_assert(offsetof(UAnySurvivorHasObjectState, _stateTag) == 0x000140, "Member 'UAnySurvivorHasObjectState::_stateTag' has a wrong offset!");

// Class DBDCompetence.IsOwningPlayerNearScourgeHookWhenKillerCarry
// 0x0000 (0x0170 - 0x0170)
class UIsOwningPlayerNearScourgeHookWhenKillerCarry final : public UIsOwningPlayerInHookRangeWhenKillerCarry
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsOwningPlayerNearScourgeHookWhenKillerCarry">();
	}
	static class UIsOwningPlayerNearScourgeHookWhenKillerCarry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsOwningPlayerNearScourgeHookWhenKillerCarry>();
	}
};
static_assert(alignof(UIsOwningPlayerNearScourgeHookWhenKillerCarry) == 0x000008, "Wrong alignment on UIsOwningPlayerNearScourgeHookWhenKillerCarry");
static_assert(sizeof(UIsOwningPlayerNearScourgeHookWhenKillerCarry) == 0x000170, "Wrong size on UIsOwningPlayerNearScourgeHookWhenKillerCarry");

// Class DBDCompetence.ApplicableOnIntervalsStatusEffect
// 0x0038 (0x03D0 - 0x0398)
class UApplicableOnIntervalsStatusEffect final : public UStatusEffect
{
public:
	bool                                          _startAsApplicable;                                // 0x0398(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_399[0x3];                                      // 0x0399(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _intervalTime;                                     // 0x039C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A0[0x30];                                     // 0x03A0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ApplicableOnIntervalsStatusEffect">();
	}
	static class UApplicableOnIntervalsStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UApplicableOnIntervalsStatusEffect>();
	}
};
static_assert(alignof(UApplicableOnIntervalsStatusEffect) == 0x000008, "Wrong alignment on UApplicableOnIntervalsStatusEffect");
static_assert(sizeof(UApplicableOnIntervalsStatusEffect) == 0x0003D0, "Wrong size on UApplicableOnIntervalsStatusEffect");
static_assert(offsetof(UApplicableOnIntervalsStatusEffect, _startAsApplicable) == 0x000398, "Member 'UApplicableOnIntervalsStatusEffect::_startAsApplicable' has a wrong offset!");
static_assert(offsetof(UApplicableOnIntervalsStatusEffect, _intervalTime) == 0x00039C, "Member 'UApplicableOnIntervalsStatusEffect::_intervalTime' has a wrong offset!");

// Class DBDCompetence.AreExitGatesPowered
// 0x0000 (0x00F0 - 0x00F0)
class UAreExitGatesPowered final : public UEventDrivenModifierCondition
{
public:
	void OnExitGatesActivated();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AreExitGatesPowered">();
	}
	static class UAreExitGatesPowered* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAreExitGatesPowered>();
	}
};
static_assert(alignof(UAreExitGatesPowered) == 0x000008, "Wrong alignment on UAreExitGatesPowered");
static_assert(sizeof(UAreExitGatesPowered) == 0x0000F0, "Wrong size on UAreExitGatesPowered");

// Class DBDCompetence.BabysitterEffect
// 0x0000 (0x0398 - 0x0398)
class UBabysitterEffect final : public UStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BabysitterEffect">();
	}
	static class UBabysitterEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBabysitterEffect>();
	}
};
static_assert(alignof(UBabysitterEffect) == 0x000008, "Wrong alignment on UBabysitterEffect");
static_assert(sizeof(UBabysitterEffect) == 0x000398, "Wrong size on UBabysitterEffect");

// Class DBDCompetence.BaseIsPerkUsableCondition
// 0x0008 (0x00F8 - 0x00F0)
class UBaseIsPerkUsableCondition : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_F0[0x8];                                       // 0x00F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseIsPerkUsableCondition">();
	}
	static class UBaseIsPerkUsableCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseIsPerkUsableCondition>();
	}
};
static_assert(alignof(UBaseIsPerkUsableCondition) == 0x000008, "Wrong alignment on UBaseIsPerkUsableCondition");
static_assert(sizeof(UBaseIsPerkUsableCondition) == 0x0000F8, "Wrong size on UBaseIsPerkUsableCondition");

// Class DBDCompetence.BaseIsPlayerPerformingInteraction
// 0x0030 (0x0120 - 0x00F0)
class UBaseIsPlayerPerformingInteraction : public UEventDrivenModifierCondition
{
public:
	struct FGameplayTagContainer                  _interactionSemantics;                             // 0x00F0(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x10];                                     // 0x0110(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetInteractionSemantics(const struct FGameplayTagContainer& interactionSemantics);
	void UpdateIsTrue(class UInteractionDefinition* InteractionDefinition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseIsPlayerPerformingInteraction">();
	}
	static class UBaseIsPlayerPerformingInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseIsPlayerPerformingInteraction>();
	}
};
static_assert(alignof(UBaseIsPlayerPerformingInteraction) == 0x000008, "Wrong alignment on UBaseIsPlayerPerformingInteraction");
static_assert(sizeof(UBaseIsPlayerPerformingInteraction) == 0x000120, "Wrong size on UBaseIsPlayerPerformingInteraction");
static_assert(offsetof(UBaseIsPlayerPerformingInteraction, _interactionSemantics) == 0x0000F0, "Member 'UBaseIsPlayerPerformingInteraction::_interactionSemantics' has a wrong offset!");

// Class DBDCompetence.BitterMurmur
// 0x0028 (0x0488 - 0x0460)
class UBitterMurmur final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _revealAuraStatusEffect;                           // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFloatValueStrategy*                    _onGeneratorFixedAuraRevealTime;                   // 0x0468(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPerkTierValueStrategy*                 _onFinalGeneratorRevealTimes;                      // 0x0470(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFloatValueStrategy*                    _maxDistanceFromGenerator;                         // 0x0478(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_480[0x8];                                      // 0x0480(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetFixedRevealTime() const;
	float GetMaxDistanceFromGenerator() const;
	float GetRevealTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BitterMurmur">();
	}
	static class UBitterMurmur* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBitterMurmur>();
	}
};
static_assert(alignof(UBitterMurmur) == 0x000008, "Wrong alignment on UBitterMurmur");
static_assert(sizeof(UBitterMurmur) == 0x000488, "Wrong size on UBitterMurmur");
static_assert(offsetof(UBitterMurmur, _revealAuraStatusEffect) == 0x000460, "Member 'UBitterMurmur::_revealAuraStatusEffect' has a wrong offset!");
static_assert(offsetof(UBitterMurmur, _onGeneratorFixedAuraRevealTime) == 0x000468, "Member 'UBitterMurmur::_onGeneratorFixedAuraRevealTime' has a wrong offset!");
static_assert(offsetof(UBitterMurmur, _onFinalGeneratorRevealTimes) == 0x000470, "Member 'UBitterMurmur::_onFinalGeneratorRevealTimes' has a wrong offset!");
static_assert(offsetof(UBitterMurmur, _maxDistanceFromGenerator) == 0x000478, "Member 'UBitterMurmur::_maxDistanceFromGenerator' has a wrong offset!");

// Class DBDCompetence.BlessedStatusEffect
// 0x0010 (0x03A8 - 0x0398)
class UBlessedStatusEffect : public UStatusEffect
{
public:
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UBlessedVignetteController> _vignetteControllerBlueprint;                      // 0x03A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnSurvivorRemovedFromGame(class ASurvivor* Survivor);
	void OnEnterBoonRange();
	void OnExitBoonRange();

	float GetBoonTotemBlessingRange() const;
	class ATotem* GetBoundTotem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlessedStatusEffect">();
	}
	static class UBlessedStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlessedStatusEffect>();
	}
};
static_assert(alignof(UBlessedStatusEffect) == 0x000008, "Wrong alignment on UBlessedStatusEffect");
static_assert(sizeof(UBlessedStatusEffect) == 0x0003A8, "Wrong size on UBlessedStatusEffect");
static_assert(offsetof(UBlessedStatusEffect, _vignetteControllerBlueprint) == 0x0003A0, "Member 'UBlessedStatusEffect::_vignetteControllerBlueprint' has a wrong offset!");

// Class DBDCompetence.BlockPalletsAction
// 0x0020 (0x0060 - 0x0040)
class UBlockPalletsAction final : public UCompetenceAction
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EGameEventActionTarget                        _actorDistanceTarget;                              // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGameEventActionTarget                        _sourceTarget;                                     // 0x0049(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UFloatValueStrategy*                    _blockDuration;                                    // 0x0050(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFloatValueStrategy*                    _blockDistance;                                    // 0x0058(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlockPalletsAction">();
	}
	static class UBlockPalletsAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlockPalletsAction>();
	}
};
static_assert(alignof(UBlockPalletsAction) == 0x000008, "Wrong alignment on UBlockPalletsAction");
static_assert(sizeof(UBlockPalletsAction) == 0x000060, "Wrong size on UBlockPalletsAction");
static_assert(offsetof(UBlockPalletsAction, _actorDistanceTarget) == 0x000048, "Member 'UBlockPalletsAction::_actorDistanceTarget' has a wrong offset!");
static_assert(offsetof(UBlockPalletsAction, _sourceTarget) == 0x000049, "Member 'UBlockPalletsAction::_sourceTarget' has a wrong offset!");
static_assert(offsetof(UBlockPalletsAction, _blockDuration) == 0x000050, "Member 'UBlockPalletsAction::_blockDuration' has a wrong offset!");
static_assert(offsetof(UBlockPalletsAction, _blockDistance) == 0x000058, "Member 'UBlockPalletsAction::_blockDistance' has a wrong offset!");

// Class DBDCompetence.BlockWindowsAction
// 0x0020 (0x0060 - 0x0040)
class UBlockWindowsAction final : public UCompetenceAction
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EGameEventActionTarget                        _actorDistanceTarget;                              // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGameEventActionTarget                        _sourceTarget;                                     // 0x0049(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EBlockWindowTargets                           _blockingTargets;                                  // 0x004A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B[0x5];                                       // 0x004B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UFloatValueStrategy*                    _blockDuration;                                    // 0x0050(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFloatValueStrategy*                    _blockDistance;                                    // 0x0058(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlockWindowsAction">();
	}
	static class UBlockWindowsAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlockWindowsAction>();
	}
};
static_assert(alignof(UBlockWindowsAction) == 0x000008, "Wrong alignment on UBlockWindowsAction");
static_assert(sizeof(UBlockWindowsAction) == 0x000060, "Wrong size on UBlockWindowsAction");
static_assert(offsetof(UBlockWindowsAction, _actorDistanceTarget) == 0x000048, "Member 'UBlockWindowsAction::_actorDistanceTarget' has a wrong offset!");
static_assert(offsetof(UBlockWindowsAction, _sourceTarget) == 0x000049, "Member 'UBlockWindowsAction::_sourceTarget' has a wrong offset!");
static_assert(offsetof(UBlockWindowsAction, _blockingTargets) == 0x00004A, "Member 'UBlockWindowsAction::_blockingTargets' has a wrong offset!");
static_assert(offsetof(UBlockWindowsAction, _blockDuration) == 0x000050, "Member 'UBlockWindowsAction::_blockDuration' has a wrong offset!");
static_assert(offsetof(UBlockWindowsAction, _blockDistance) == 0x000058, "Member 'UBlockWindowsAction::_blockDistance' has a wrong offset!");

// Class DBDCompetence.BloodEcho
// 0x0028 (0x0488 - 0x0460)
class UBloodEcho final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _hemorrhageStatusEffectClass;                      // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _exhaustedStatusEffectClass;                       // 0x0468(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _externalPerkIconEffectClass;                      // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _statusEffectDuration[0x3];                        // 0x0478(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_484[0x4];                                      // 0x0484(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetStatusEffectDurationAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodEcho">();
	}
	static class UBloodEcho* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodEcho>();
	}
};
static_assert(alignof(UBloodEcho) == 0x000008, "Wrong alignment on UBloodEcho");
static_assert(sizeof(UBloodEcho) == 0x000488, "Wrong size on UBloodEcho");
static_assert(offsetof(UBloodEcho, _hemorrhageStatusEffectClass) == 0x000460, "Member 'UBloodEcho::_hemorrhageStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UBloodEcho, _exhaustedStatusEffectClass) == 0x000468, "Member 'UBloodEcho::_exhaustedStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UBloodEcho, _externalPerkIconEffectClass) == 0x000470, "Member 'UBloodEcho::_externalPerkIconEffectClass' has a wrong offset!");
static_assert(offsetof(UBloodEcho, _statusEffectDuration) == 0x000478, "Member 'UBloodEcho::_statusEffectDuration' has a wrong offset!");

// Class DBDCompetence.BoonDestroyer
// 0x0018 (0x0478 - 0x0460)
class UBoonDestroyer final : public UPerk
{
public:
	float                                         _survivorAuraRevealDuration[0x3];                  // 0x0460(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_46C[0x4];                                      // 0x046C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _survivorRevealEffect;                             // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoonDestroyer">();
	}
	static class UBoonDestroyer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBoonDestroyer>();
	}
};
static_assert(alignof(UBoonDestroyer) == 0x000008, "Wrong alignment on UBoonDestroyer");
static_assert(sizeof(UBoonDestroyer) == 0x000478, "Wrong size on UBoonDestroyer");
static_assert(offsetof(UBoonDestroyer, _survivorAuraRevealDuration) == 0x000460, "Member 'UBoonDestroyer::_survivorAuraRevealDuration' has a wrong offset!");
static_assert(offsetof(UBoonDestroyer, _survivorRevealEffect) == 0x000470, "Member 'UBoonDestroyer::_survivorRevealEffect' has a wrong offset!");

// Class DBDCompetence.BoonTotemIsActive
// 0x0010 (0x0100 - 0x00F0)
class UBoonTotemIsActive final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_F0[0x10];                                      // 0x00F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoonTotemIsActive">();
	}
	static class UBoonTotemIsActive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBoonTotemIsActive>();
	}
};
static_assert(alignof(UBoonTotemIsActive) == 0x000008, "Wrong alignment on UBoonTotemIsActive");
static_assert(sizeof(UBoonTotemIsActive) == 0x000100, "Wrong size on UBoonTotemIsActive");

// Class DBDCompetence.Breakout
// 0x0088 (0x04E8 - 0x0460)
class UBreakout final : public UPerk
{
public:
	class AKiller*                                _killer;                                           // 0x0460(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDPlayer*                             _playerOwner;                                      // 0x0468(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _hasteStatusEffect;                                // 0x0470(0x0008)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _wiggleStatusEffect;                               // 0x0478(0x0008)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _hasteEffect[0x3];                                 // 0x0480(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _wiggleEffect;                                     // 0x048C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _survivorDistanceMax;                              // 0x0490(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isPerkActive;                                     // 0x0494(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_495[0x53];                                     // 0x0495(0x0053)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_ImposeWiggleStatusEffect(class ASurvivor* Survivor);
	void Authority_OnRangeChanged(const bool inRange);
	void OnKillerSet(class AKiller* Killer);
	void OnRep_IsPerkActive();

	float GetHasteEffectAtLevel() const;
	float GetSurvivorDistanceMax() const;
	float GetWiggleEffect() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Breakout">();
	}
	static class UBreakout* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBreakout>();
	}
};
static_assert(alignof(UBreakout) == 0x000008, "Wrong alignment on UBreakout");
static_assert(sizeof(UBreakout) == 0x0004E8, "Wrong size on UBreakout");
static_assert(offsetof(UBreakout, _killer) == 0x000460, "Member 'UBreakout::_killer' has a wrong offset!");
static_assert(offsetof(UBreakout, _playerOwner) == 0x000468, "Member 'UBreakout::_playerOwner' has a wrong offset!");
static_assert(offsetof(UBreakout, _hasteStatusEffect) == 0x000470, "Member 'UBreakout::_hasteStatusEffect' has a wrong offset!");
static_assert(offsetof(UBreakout, _wiggleStatusEffect) == 0x000478, "Member 'UBreakout::_wiggleStatusEffect' has a wrong offset!");
static_assert(offsetof(UBreakout, _hasteEffect) == 0x000480, "Member 'UBreakout::_hasteEffect' has a wrong offset!");
static_assert(offsetof(UBreakout, _wiggleEffect) == 0x00048C, "Member 'UBreakout::_wiggleEffect' has a wrong offset!");
static_assert(offsetof(UBreakout, _survivorDistanceMax) == 0x000490, "Member 'UBreakout::_survivorDistanceMax' has a wrong offset!");
static_assert(offsetof(UBreakout, _isPerkActive) == 0x000494, "Member 'UBreakout::_isPerkActive' has a wrong offset!");

// Class DBDCompetence.BuckleUp
// 0x0038 (0x0498 - 0x0460)
class UBuckleUp final : public UPerk
{
public:
	float                                         _perkDuration[0x3];                                // 0x0460(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_46C[0x4];                                      // 0x046C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _revealKillerStatusEffectClass;                    // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _buckleUpStatusEffectClass;                        // 0x0478(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _hasteValue;                                       // 0x0480(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_484[0x14];                                     // 0x0484(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetHasteValue() const;
	float GetPerkDurationAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuckleUp">();
	}
	static class UBuckleUp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuckleUp>();
	}
};
static_assert(alignof(UBuckleUp) == 0x000008, "Wrong alignment on UBuckleUp");
static_assert(sizeof(UBuckleUp) == 0x000498, "Wrong size on UBuckleUp");
static_assert(offsetof(UBuckleUp, _perkDuration) == 0x000460, "Member 'UBuckleUp::_perkDuration' has a wrong offset!");
static_assert(offsetof(UBuckleUp, _revealKillerStatusEffectClass) == 0x000470, "Member 'UBuckleUp::_revealKillerStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UBuckleUp, _buckleUpStatusEffectClass) == 0x000478, "Member 'UBuckleUp::_buckleUpStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UBuckleUp, _hasteValue) == 0x000480, "Member 'UBuckleUp::_hasteValue' has a wrong offset!");

// Class DBDCompetence.BuckleUpStatusEffect
// 0x0000 (0x0398 - 0x0398)
class UBuckleUpStatusEffect final : public UStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuckleUpStatusEffect">();
	}
	static class UBuckleUpStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuckleUpStatusEffect>();
	}
};
static_assert(alignof(UBuckleUpStatusEffect) == 0x000008, "Wrong alignment on UBuckleUpStatusEffect");
static_assert(sizeof(UBuckleUpStatusEffect) == 0x000398, "Wrong size on UBuckleUpStatusEffect");

// Class DBDCompetence.CalmSpirit
// 0x0018 (0x0478 - 0x0460)
class UCalmSpirit final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _calmSpiritEffectClass;                            // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _actionSpeed[0x3];                                 // 0x0468(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_474[0x4];                                      // 0x0474(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CalmSpirit">();
	}
	static class UCalmSpirit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCalmSpirit>();
	}
};
static_assert(alignof(UCalmSpirit) == 0x000008, "Wrong alignment on UCalmSpirit");
static_assert(sizeof(UCalmSpirit) == 0x000478, "Wrong size on UCalmSpirit");
static_assert(offsetof(UCalmSpirit, _calmSpiritEffectClass) == 0x000460, "Member 'UCalmSpirit::_calmSpiritEffectClass' has a wrong offset!");
static_assert(offsetof(UCalmSpirit, _actionSpeed) == 0x000468, "Member 'UCalmSpirit::_actionSpeed' has a wrong offset!");

// Class DBDCompetence.Camaraderie
// 0x0058 (0x04B8 - 0x0460)
class UCamaraderie final : public UPerk
{
public:
	float                                         _percentUseItem[0x3];                              // 0x0460(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _pauseTimer[0x3];                                  // 0x046C(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _camaraderieNotificationEffectClass;               // 0x0478(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_480[0x38];                                     // 0x0480(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Camaraderie">();
	}
	static class UCamaraderie* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCamaraderie>();
	}
};
static_assert(alignof(UCamaraderie) == 0x000008, "Wrong alignment on UCamaraderie");
static_assert(sizeof(UCamaraderie) == 0x0004B8, "Wrong size on UCamaraderie");
static_assert(offsetof(UCamaraderie, _percentUseItem) == 0x000460, "Member 'UCamaraderie::_percentUseItem' has a wrong offset!");
static_assert(offsetof(UCamaraderie, _pauseTimer) == 0x00046C, "Member 'UCamaraderie::_pauseTimer' has a wrong offset!");
static_assert(offsetof(UCamaraderie, _camaraderieNotificationEffectClass) == 0x000478, "Member 'UCamaraderie::_camaraderieNotificationEffectClass' has a wrong offset!");

// Class DBDCompetence.ClearActivationTimerAction
// 0x0008 (0x0048 - 0x0040)
class UClearActivationTimerAction final : public UCompetenceAction
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClearActivationTimerAction">();
	}
	static class UClearActivationTimerAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClearActivationTimerAction>();
	}
};
static_assert(alignof(UClearActivationTimerAction) == 0x000008, "Wrong alignment on UClearActivationTimerAction");
static_assert(sizeof(UClearActivationTimerAction) == 0x000048, "Wrong size on UClearActivationTimerAction");

// Class DBDCompetence.CollectableOwnerSubjectProvider
// 0x0018 (0x0060 - 0x0048)
class UCollectableOwnerSubjectProvider final : public UModifierSubjectProvider
{
public:
	uint8                                         Pad_48[0x18];                                      // 0x0048(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectableOwnerSubjectProvider">();
	}
	static class UCollectableOwnerSubjectProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollectableOwnerSubjectProvider>();
	}
};
static_assert(alignof(UCollectableOwnerSubjectProvider) == 0x000008, "Wrong alignment on UCollectableOwnerSubjectProvider");
static_assert(sizeof(UCollectableOwnerSubjectProvider) == 0x000060, "Wrong size on UCollectableOwnerSubjectProvider");

// Class DBDCompetence.CompetenceUtilities
// 0x0000 (0x0030 - 0x0030)
class UCompetenceUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CompetenceUtilities">();
	}
	static class UCompetenceUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCompetenceUtilities>();
	}
};
static_assert(alignof(UCompetenceUtilities) == 0x000008, "Wrong alignment on UCompetenceUtilities");
static_assert(sizeof(UCompetenceUtilities) == 0x000030, "Wrong size on UCompetenceUtilities");

// Class DBDCompetence.CompromiseGeneratorManager
// 0x0038 (0x00F0 - 0x00B8)
class UCompromiseGeneratorManager final : public UActorComponent
{
public:
	class AGenerator*                             _compromisedGenerator;                             // 0x00B8(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGenerator*                             _lastCompromisedGenerator;                         // 0x00C0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x10];                                      // 0x00C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _owningPlayer;                                     // 0x00D8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UCompromiseGeneratorPerk*>       _compromiseGeneratorPerks;                         // 0x00E0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void Cosmetic_OnCompromiseCompletedVFX(const class AGenerator* compromisedGenerator);
	void Cosmetic_OnTriggerCompromiseVFX(const class AGenerator* compromisedGenerator);
	class ADBDPlayer* GetOwningPlayer();
	void OnRep_CompromisedGenerator();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CompromiseGeneratorManager">();
	}
	static class UCompromiseGeneratorManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCompromiseGeneratorManager>();
	}
};
static_assert(alignof(UCompromiseGeneratorManager) == 0x000008, "Wrong alignment on UCompromiseGeneratorManager");
static_assert(sizeof(UCompromiseGeneratorManager) == 0x0000F0, "Wrong size on UCompromiseGeneratorManager");
static_assert(offsetof(UCompromiseGeneratorManager, _compromisedGenerator) == 0x0000B8, "Member 'UCompromiseGeneratorManager::_compromisedGenerator' has a wrong offset!");
static_assert(offsetof(UCompromiseGeneratorManager, _lastCompromisedGenerator) == 0x0000C0, "Member 'UCompromiseGeneratorManager::_lastCompromisedGenerator' has a wrong offset!");
static_assert(offsetof(UCompromiseGeneratorManager, _owningPlayer) == 0x0000D8, "Member 'UCompromiseGeneratorManager::_owningPlayer' has a wrong offset!");
static_assert(offsetof(UCompromiseGeneratorManager, _compromiseGeneratorPerks) == 0x0000E0, "Member 'UCompromiseGeneratorManager::_compromiseGeneratorPerks' has a wrong offset!");

// Class DBDCompetence.CorruptIntervention
// 0x0070 (0x04D0 - 0x0460)
class UCorruptIntervention final : public UPerk
{
public:
	uint8                                         _blockedGeneratorCount[0x3];                       // 0x0460(0x0001)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_463[0x1];                                      // 0x0463(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _generatorBlockDuration[0x3];                      // 0x0464(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _generatorAuraColorForKiller;                      // 0x0470(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AGenerator*>                     _blockedGenerators;                                // 0x0480(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_490[0x40];                                     // 0x0490(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnLevelReadyToPlay();
	void Authority_TryActivatePerk();
	void LevelReadyToBlockedGenerators();
	void Multicast_DispatchBlockedEvent();
	void OnRep_BlockedGenerators();

	float GetGeneratorBlockDuration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CorruptIntervention">();
	}
	static class UCorruptIntervention* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCorruptIntervention>();
	}
};
static_assert(alignof(UCorruptIntervention) == 0x000008, "Wrong alignment on UCorruptIntervention");
static_assert(sizeof(UCorruptIntervention) == 0x0004D0, "Wrong size on UCorruptIntervention");
static_assert(offsetof(UCorruptIntervention, _blockedGeneratorCount) == 0x000460, "Member 'UCorruptIntervention::_blockedGeneratorCount' has a wrong offset!");
static_assert(offsetof(UCorruptIntervention, _generatorBlockDuration) == 0x000464, "Member 'UCorruptIntervention::_generatorBlockDuration' has a wrong offset!");
static_assert(offsetof(UCorruptIntervention, _generatorAuraColorForKiller) == 0x000470, "Member 'UCorruptIntervention::_generatorAuraColorForKiller' has a wrong offset!");
static_assert(offsetof(UCorruptIntervention, _blockedGenerators) == 0x000480, "Member 'UCorruptIntervention::_blockedGenerators' has a wrong offset!");

// Class DBDCompetence.Coulrophobia
// 0x0018 (0x0478 - 0x0460)
class UCoulrophobia final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _coulrophobiaEffect;                               // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _healPenalty[0x3];                                 // 0x0468(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_474[0x4];                                      // 0x0474(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetHealPenaltyAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Coulrophobia">();
	}
	static class UCoulrophobia* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoulrophobia>();
	}
};
static_assert(alignof(UCoulrophobia) == 0x000008, "Wrong alignment on UCoulrophobia");
static_assert(sizeof(UCoulrophobia) == 0x000478, "Wrong size on UCoulrophobia");
static_assert(offsetof(UCoulrophobia, _coulrophobiaEffect) == 0x000460, "Member 'UCoulrophobia::_coulrophobiaEffect' has a wrong offset!");
static_assert(offsetof(UCoulrophobia, _healPenalty) == 0x000468, "Member 'UCoulrophobia::_healPenalty' has a wrong offset!");

// Class DBDCompetence.CruelConfinement
// 0x0040 (0x04A0 - 0x0460)
class UCruelConfinement final : public UPerk
{
public:
	float                                         _blockDuration[0x3];                               // 0x0460(0x0004)(Edit, EditFixedSize, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _windowAuraColor;                                  // 0x046C(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_47C[0x4];                                      // 0x047C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class UBlockableComponent>> _blockables;                                   // 0x0480(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetBlockDurationAtLevel();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CruelConfinement">();
	}
	static class UCruelConfinement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCruelConfinement>();
	}
};
static_assert(alignof(UCruelConfinement) == 0x000008, "Wrong alignment on UCruelConfinement");
static_assert(sizeof(UCruelConfinement) == 0x0004A0, "Wrong size on UCruelConfinement");
static_assert(offsetof(UCruelConfinement, _blockDuration) == 0x000460, "Member 'UCruelConfinement::_blockDuration' has a wrong offset!");
static_assert(offsetof(UCruelConfinement, _windowAuraColor) == 0x00046C, "Member 'UCruelConfinement::_windowAuraColor' has a wrong offset!");
static_assert(offsetof(UCruelConfinement, _blockables) == 0x000480, "Member 'UCruelConfinement::_blockables' has a wrong offset!");

// Class DBDCompetence.DarkSense
// 0x0040 (0x04A0 - 0x0460)
class UDarkSense final : public UPerk
{
public:
	float                                         _killerRevealDuration[0x3];                        // 0x0460(0x0004)(Edit, EditFixedSize, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _darkSenseRevealRange;                             // 0x046C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _timedRevealEffect;                                // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_478[0x28];                                     // 0x0478(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnInRangeChanged(const bool inRange);

	float GetDarkSenseRevealRange() const;
	float GetKillerRevealDurationAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarkSense">();
	}
	static class UDarkSense* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarkSense>();
	}
};
static_assert(alignof(UDarkSense) == 0x000008, "Wrong alignment on UDarkSense");
static_assert(sizeof(UDarkSense) == 0x0004A0, "Wrong size on UDarkSense");
static_assert(offsetof(UDarkSense, _killerRevealDuration) == 0x000460, "Member 'UDarkSense::_killerRevealDuration' has a wrong offset!");
static_assert(offsetof(UDarkSense, _darkSenseRevealRange) == 0x00046C, "Member 'UDarkSense::_darkSenseRevealRange' has a wrong offset!");
static_assert(offsetof(UDarkSense, _timedRevealEffect) == 0x000470, "Member 'UDarkSense::_timedRevealEffect' has a wrong offset!");

// Class DBDCompetence.DeadMansSwitchEffect
// 0x0000 (0x0398 - 0x0398)
class UDeadMansSwitchEffect final : public UStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeadMansSwitchEffect">();
	}
	static class UDeadMansSwitchEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeadMansSwitchEffect>();
	}
};
static_assert(alignof(UDeadMansSwitchEffect) == 0x000008, "Wrong alignment on UDeadMansSwitchEffect");
static_assert(sizeof(UDeadMansSwitchEffect) == 0x000398, "Wrong size on UDeadMansSwitchEffect");

// Class DBDCompetence.DeceptionEffect
// 0x0008 (0x03A0 - 0x0398)
class UDeceptionEffect final : public UStatusEffect
{
public:
	bool                                          _hideBloodTrailsWhenCamperFakeEnterLocker;         // 0x0398(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_399[0x7];                                      // 0x0399(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeceptionEffect">();
	}
	static class UDeceptionEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeceptionEffect>();
	}
};
static_assert(alignof(UDeceptionEffect) == 0x000008, "Wrong alignment on UDeceptionEffect");
static_assert(sizeof(UDeceptionEffect) == 0x0003A0, "Wrong size on UDeceptionEffect");
static_assert(offsetof(UDeceptionEffect, _hideBloodTrailsWhenCamperFakeEnterLocker) == 0x000398, "Member 'UDeceptionEffect::_hideBloodTrailsWhenCamperFakeEnterLocker' has a wrong offset!");

// Class DBDCompetence.DecisiveStrike
// 0x00A0 (0x0500 - 0x0460)
class UDecisiveStrike final : public UPerk
{
public:
	float                                         _timeAfterUnhook[0x3];                             // 0x0460(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _skillCheckDelay;                                  // 0x046C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _skillCheckBuffer;                                 // 0x0470(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _stunDropDuration;                                 // 0x0474(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_478[0x78];                                     // 0x0478(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _increaseObsessionChanceEffect;                    // 0x04F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasBeenAttempted;                                 // 0x04F8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F9[0x7];                                      // 0x04F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_SetTriggerOnNextPickup(bool triggerOnNextPickup);
	void OnOwnerPickedUp(class ADBDPlayer* picker);
	void OnPickUpEnded(class ADBDPlayer* picker);
	void OnRep_HasBeenAttempted();
	void OnSkillCheck(bool hadInput, bool Success, bool Bonus, ESkillCheckCustomType Type, class ADBDPlayer* Player);
	void Server_SetTriggerOnNextPickup(bool triggerOnNextPickup);

	float GetDurationAfterUnhook() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DecisiveStrike">();
	}
	static class UDecisiveStrike* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDecisiveStrike>();
	}
};
static_assert(alignof(UDecisiveStrike) == 0x000008, "Wrong alignment on UDecisiveStrike");
static_assert(sizeof(UDecisiveStrike) == 0x000500, "Wrong size on UDecisiveStrike");
static_assert(offsetof(UDecisiveStrike, _timeAfterUnhook) == 0x000460, "Member 'UDecisiveStrike::_timeAfterUnhook' has a wrong offset!");
static_assert(offsetof(UDecisiveStrike, _skillCheckDelay) == 0x00046C, "Member 'UDecisiveStrike::_skillCheckDelay' has a wrong offset!");
static_assert(offsetof(UDecisiveStrike, _skillCheckBuffer) == 0x000470, "Member 'UDecisiveStrike::_skillCheckBuffer' has a wrong offset!");
static_assert(offsetof(UDecisiveStrike, _stunDropDuration) == 0x000474, "Member 'UDecisiveStrike::_stunDropDuration' has a wrong offset!");
static_assert(offsetof(UDecisiveStrike, _increaseObsessionChanceEffect) == 0x0004F0, "Member 'UDecisiveStrike::_increaseObsessionChanceEffect' has a wrong offset!");
static_assert(offsetof(UDecisiveStrike, _hasBeenAttempted) == 0x0004F8, "Member 'UDecisiveStrike::_hasBeenAttempted' has a wrong offset!");

// Class DBDCompetence.DelayedHealEffect
// 0x0008 (0x03A0 - 0x0398)
class UDelayedHealEffect final : public UStatusEffect
{
public:
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnActivationTimerComplete();
	void Authority_OnOwningCamperHealthChanged(EHealthState before, EHealthState after);
	void Authority_OnOwningCamperPickedUp(class ADBDPlayer* picker);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelayedHealEffect">();
	}
	static class UDelayedHealEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelayedHealEffect>();
	}
};
static_assert(alignof(UDelayedHealEffect) == 0x000008, "Wrong alignment on UDelayedHealEffect");
static_assert(sizeof(UDelayedHealEffect) == 0x0003A0, "Wrong size on UDelayedHealEffect");

// Class DBDCompetence.DiminishingReturnBaseEffect
// 0x0140 (0x04D8 - 0x0398)
class UDiminishingReturnBaseEffect final : public UStatusEffect
{
public:
	uint8                                         Pad_398[0x18];                                     // 0x0398(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          CheckOriginatingEffectsApplicable;                 // 0x03B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B1[0x7];                                      // 0x03B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _effectRange;                                      // 0x03B8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<float>                                 _capRatioPerStack;                                 // 0x03E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F0[0x60];                                     // 0x03F0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADBDPlayer*>                     _originatingPlayersInRange;                        // 0x0450(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<class ADBDPlayer*, struct FFastTimer>    _originatingPlayersActivatedLifetimeInRange;       // 0x0460(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class UGameplayModifierContainer*>     _originatingEffectsApplicable;                     // 0x04B0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class ADBDPlayer*>                     _originatingPlayersApplyingEffect;                 // 0x04C0(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D0[0x8];                                      // 0x04D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnOriginatingEffectApplicableChanged(class UGameplayModifierContainer* GameplayModifierContainer, bool IsApplicable_0);
	void Cosmetic_OnInRangeChanged(bool IsInRange);
	void OnRep_OriginatingPlayersApplyingEffect(const TArray<class ADBDPlayer*>& previousOriginatingPlayersApplyingEffect);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiminishingReturnBaseEffect">();
	}
	static class UDiminishingReturnBaseEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDiminishingReturnBaseEffect>();
	}
};
static_assert(alignof(UDiminishingReturnBaseEffect) == 0x000008, "Wrong alignment on UDiminishingReturnBaseEffect");
static_assert(sizeof(UDiminishingReturnBaseEffect) == 0x0004D8, "Wrong size on UDiminishingReturnBaseEffect");
static_assert(offsetof(UDiminishingReturnBaseEffect, CheckOriginatingEffectsApplicable) == 0x0003B0, "Member 'UDiminishingReturnBaseEffect::CheckOriginatingEffectsApplicable' has a wrong offset!");
static_assert(offsetof(UDiminishingReturnBaseEffect, _effectRange) == 0x0003B8, "Member 'UDiminishingReturnBaseEffect::_effectRange' has a wrong offset!");
static_assert(offsetof(UDiminishingReturnBaseEffect, _capRatioPerStack) == 0x0003E0, "Member 'UDiminishingReturnBaseEffect::_capRatioPerStack' has a wrong offset!");
static_assert(offsetof(UDiminishingReturnBaseEffect, _originatingPlayersInRange) == 0x000450, "Member 'UDiminishingReturnBaseEffect::_originatingPlayersInRange' has a wrong offset!");
static_assert(offsetof(UDiminishingReturnBaseEffect, _originatingPlayersActivatedLifetimeInRange) == 0x000460, "Member 'UDiminishingReturnBaseEffect::_originatingPlayersActivatedLifetimeInRange' has a wrong offset!");
static_assert(offsetof(UDiminishingReturnBaseEffect, _originatingEffectsApplicable) == 0x0004B0, "Member 'UDiminishingReturnBaseEffect::_originatingEffectsApplicable' has a wrong offset!");
static_assert(offsetof(UDiminishingReturnBaseEffect, _originatingPlayersApplyingEffect) == 0x0004C0, "Member 'UDiminishingReturnBaseEffect::_originatingPlayersApplyingEffect' has a wrong offset!");

// Class DBDCompetence.DiminishingReturnEffectHasAnyEffect
// 0x0000 (0x00F0 - 0x00F0)
class UDiminishingReturnEffectHasAnyEffect final : public UEventDrivenModifierCondition
{
public:
	void OnOriginatingPlayersApplyingEffectChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiminishingReturnEffectHasAnyEffect">();
	}
	static class UDiminishingReturnEffectHasAnyEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDiminishingReturnEffectHasAnyEffect>();
	}
};
static_assert(alignof(UDiminishingReturnEffectHasAnyEffect) == 0x000008, "Wrong alignment on UDiminishingReturnEffectHasAnyEffect");
static_assert(sizeof(UDiminishingReturnEffectHasAnyEffect) == 0x0000F0, "Wrong size on UDiminishingReturnEffectHasAnyEffect");

// Class DBDCompetence.DispatchGameEventAction
// 0x0028 (0x0068 - 0x0040)
class UDispatchGameEventAction final : public UCompetenceAction
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _gameEvent;                                        // 0x0048(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDispatchType                                 _dispatchType;                                     // 0x0054(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _reuseInstigator;                                  // 0x0055(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _reuseTarget;                                      // 0x0056(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_57[0x1];                                       // 0x0057(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameEventObjectBaseStrategy*           _instigatorStrategy;                               // 0x0058(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameEventObjectBaseStrategy*           _targetStrategy;                                   // 0x0060(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DispatchGameEventAction">();
	}
	static class UDispatchGameEventAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDispatchGameEventAction>();
	}
};
static_assert(alignof(UDispatchGameEventAction) == 0x000008, "Wrong alignment on UDispatchGameEventAction");
static_assert(sizeof(UDispatchGameEventAction) == 0x000068, "Wrong size on UDispatchGameEventAction");
static_assert(offsetof(UDispatchGameEventAction, _gameEvent) == 0x000048, "Member 'UDispatchGameEventAction::_gameEvent' has a wrong offset!");
static_assert(offsetof(UDispatchGameEventAction, _dispatchType) == 0x000054, "Member 'UDispatchGameEventAction::_dispatchType' has a wrong offset!");
static_assert(offsetof(UDispatchGameEventAction, _reuseInstigator) == 0x000055, "Member 'UDispatchGameEventAction::_reuseInstigator' has a wrong offset!");
static_assert(offsetof(UDispatchGameEventAction, _reuseTarget) == 0x000056, "Member 'UDispatchGameEventAction::_reuseTarget' has a wrong offset!");
static_assert(offsetof(UDispatchGameEventAction, _instigatorStrategy) == 0x000058, "Member 'UDispatchGameEventAction::_instigatorStrategy' has a wrong offset!");
static_assert(offsetof(UDispatchGameEventAction, _targetStrategy) == 0x000060, "Member 'UDispatchGameEventAction::_targetStrategy' has a wrong offset!");

// Class DBDCompetence.Distortion
// 0x0030 (0x0490 - 0x0460)
class UDistortion final : public UPerk
{
public:
	float                                         _activationDurations[0x3];                         // 0x0460(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _auraBlockIsActive;                                // 0x046C(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_46D[0x3];                                      // 0x046D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _regainTokenTimerDuration;                         // 0x0470(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _startingTokenAmount;                              // 0x0474(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_478[0x18];                                     // 0x0478(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAuraBlockedCosmetic();
	void OnRep_AuraBlockIsActive();

	bool AuraBlockCanBeActive() const;
	float GetActivationDurationAtLevel() const;
	float GetRegainTokenDurationTimer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Distortion">();
	}
	static class UDistortion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDistortion>();
	}
};
static_assert(alignof(UDistortion) == 0x000008, "Wrong alignment on UDistortion");
static_assert(sizeof(UDistortion) == 0x000490, "Wrong size on UDistortion");
static_assert(offsetof(UDistortion, _activationDurations) == 0x000460, "Member 'UDistortion::_activationDurations' has a wrong offset!");
static_assert(offsetof(UDistortion, _auraBlockIsActive) == 0x00046C, "Member 'UDistortion::_auraBlockIsActive' has a wrong offset!");
static_assert(offsetof(UDistortion, _regainTokenTimerDuration) == 0x000470, "Member 'UDistortion::_regainTokenTimerDuration' has a wrong offset!");
static_assert(offsetof(UDistortion, _startingTokenAmount) == 0x000474, "Member 'UDistortion::_startingTokenAmount' has a wrong offset!");

// Class DBDCompetence.DoesCompetenceHaveToken
// 0x0000 (0x00F0 - 0x00F0)
class UDoesCompetenceHaveToken final : public UEventDrivenModifierCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoesCompetenceHaveToken">();
	}
	static class UDoesCompetenceHaveToken* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDoesCompetenceHaveToken>();
	}
};
static_assert(alignof(UDoesCompetenceHaveToken) == 0x000008, "Wrong alignment on UDoesCompetenceHaveToken");
static_assert(sizeof(UDoesCompetenceHaveToken) == 0x0000F0, "Wrong size on UDoesCompetenceHaveToken");

// Class DBDCompetence.DoesPerkHaveToken
// 0x0010 (0x0100 - 0x00F0)
class UDoesPerkHaveToken final : public UEventDrivenModifierCondition
{
public:
	TWeakObjectPtr<class UPerk>                   _perk;                                             // 0x00F0(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Perk();
	void SetPerk(class UPerk* Perk);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoesPerkHaveToken">();
	}
	static class UDoesPerkHaveToken* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDoesPerkHaveToken>();
	}
};
static_assert(alignof(UDoesPerkHaveToken) == 0x000008, "Wrong alignment on UDoesPerkHaveToken");
static_assert(sizeof(UDoesPerkHaveToken) == 0x000100, "Wrong size on UDoesPerkHaveToken");
static_assert(offsetof(UDoesPerkHaveToken, _perk) == 0x0000F0, "Member 'UDoesPerkHaveToken::_perk' has a wrong offset!");

// Class DBDCompetence.DownedByBasicAttack
// 0x0058 (0x0148 - 0x00F0)
class UDownedByBasicAttack final : public UEventDrivenModifierCondition
{
public:
	bool                                          _replicatedIsTrue;                                 // 0x00F0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F1[0x57];                                      // 0x00F1(0x0057)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ReplicatedIsTrue();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DownedByBasicAttack">();
	}
	static class UDownedByBasicAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDownedByBasicAttack>();
	}
};
static_assert(alignof(UDownedByBasicAttack) == 0x000008, "Wrong alignment on UDownedByBasicAttack");
static_assert(sizeof(UDownedByBasicAttack) == 0x000148, "Wrong size on UDownedByBasicAttack");
static_assert(offsetof(UDownedByBasicAttack, _replicatedIsTrue) == 0x0000F0, "Member 'UDownedByBasicAttack::_replicatedIsTrue' has a wrong offset!");

// Class DBDCompetence.DyingLight
// 0x0038 (0x0498 - 0x0460)
class UDyingLight final : public UPerk
{
public:
	TArray<float>                                 _actionSpeedPenaltyPerToken;                       // 0x0460(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         _obsessionActionSpeedBonus;                        // 0x0470(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_474[0x4];                                      // 0x0474(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _obsessionStatusEffect;                            // 0x0478(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _nonObsessionStatusEffect;                         // 0x0480(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UStatusEffect*>                  _survivorDebuffs;                                  // 0x0488(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void OnObsessionChanged(class ASurvivor* newObsession, class ASurvivor* previousObsession);

	float GetActionSpeedPenaltyPerTokenAtLevel() const;
	float GetObsessionActionSpeedBonus() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DyingLight">();
	}
	static class UDyingLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDyingLight>();
	}
};
static_assert(alignof(UDyingLight) == 0x000008, "Wrong alignment on UDyingLight");
static_assert(sizeof(UDyingLight) == 0x000498, "Wrong size on UDyingLight");
static_assert(offsetof(UDyingLight, _actionSpeedPenaltyPerToken) == 0x000460, "Member 'UDyingLight::_actionSpeedPenaltyPerToken' has a wrong offset!");
static_assert(offsetof(UDyingLight, _obsessionActionSpeedBonus) == 0x000470, "Member 'UDyingLight::_obsessionActionSpeedBonus' has a wrong offset!");
static_assert(offsetof(UDyingLight, _obsessionStatusEffect) == 0x000478, "Member 'UDyingLight::_obsessionStatusEffect' has a wrong offset!");
static_assert(offsetof(UDyingLight, _nonObsessionStatusEffect) == 0x000480, "Member 'UDyingLight::_nonObsessionStatusEffect' has a wrong offset!");
static_assert(offsetof(UDyingLight, _survivorDebuffs) == 0x000488, "Member 'UDyingLight::_survivorDebuffs' has a wrong offset!");

// Class DBDCompetence.EndStatusEffectAction
// 0x0010 (0x0050 - 0x0040)
class UEndStatusEffectAction final : public UCompetenceAction
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _resetActivationTimerOnEnd;                        // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndStatusEffectAction">();
	}
	static class UEndStatusEffectAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndStatusEffectAction>();
	}
};
static_assert(alignof(UEndStatusEffectAction) == 0x000008, "Wrong alignment on UEndStatusEffectAction");
static_assert(sizeof(UEndStatusEffectAction) == 0x000050, "Wrong size on UEndStatusEffectAction");
static_assert(offsetof(UEndStatusEffectAction, _resetActivationTimerOnEnd) == 0x000048, "Member 'UEndStatusEffectAction::_resetActivationTimerOnEnd' has a wrong offset!");

// Class DBDCompetence.EnduranceEffect
// 0x0010 (0x03A8 - 0x0398)
class UEnduranceEffect : public UStatusEffect
{
public:
	TSubclassOf<class UStatusEffect>              _enduranceHighlightEffectClass;                    // 0x0398(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A0[0x8];                                      // 0x03A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnduranceEffect">();
	}
	static class UEnduranceEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnduranceEffect>();
	}
};
static_assert(alignof(UEnduranceEffect) == 0x000008, "Wrong alignment on UEnduranceEffect");
static_assert(sizeof(UEnduranceEffect) == 0x0003A8, "Wrong size on UEnduranceEffect");
static_assert(offsetof(UEnduranceEffect, _enduranceHighlightEffectClass) == 0x000398, "Member 'UEnduranceEffect::_enduranceHighlightEffectClass' has a wrong offset!");

// Class DBDCompetence.EnduranceHighlightEffect
// 0x0008 (0x03A0 - 0x0398)
class UEnduranceHighlightEffect final : public UStatusEffect
{
public:
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnduranceHighlightEffect">();
	}
	static class UEnduranceHighlightEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnduranceHighlightEffect>();
	}
};
static_assert(alignof(UEnduranceHighlightEffect) == 0x000008, "Wrong alignment on UEnduranceHighlightEffect");
static_assert(sizeof(UEnduranceHighlightEffect) == 0x0003A0, "Wrong size on UEnduranceHighlightEffect");

// Class DBDCompetence.ExecuteActionOnEventTargetHasGameplayTag
// 0x0010 (0x0040 - 0x0030)
class UExecuteActionOnEventTargetHasGameplayTag final : public UExecuteActionOnEventBaseStrategy
{
public:
	struct FGameplayTag                           _gameplayModifierFlag;                             // 0x0030(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExecuteActionOnEventTargetHasGameplayTag">();
	}
	static class UExecuteActionOnEventTargetHasGameplayTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExecuteActionOnEventTargetHasGameplayTag>();
	}
};
static_assert(alignof(UExecuteActionOnEventTargetHasGameplayTag) == 0x000008, "Wrong alignment on UExecuteActionOnEventTargetHasGameplayTag");
static_assert(sizeof(UExecuteActionOnEventTargetHasGameplayTag) == 0x000040, "Wrong size on UExecuteActionOnEventTargetHasGameplayTag");
static_assert(offsetof(UExecuteActionOnEventTargetHasGameplayTag, _gameplayModifierFlag) == 0x000030, "Member 'UExecuteActionOnEventTargetHasGameplayTag::_gameplayModifierFlag' has a wrong offset!");

// Class DBDCompetence.ExecuteActionOnEventTargetHasStateTag
// 0x0010 (0x0040 - 0x0030)
class UExecuteActionOnEventTargetHasStateTag final : public UExecuteActionOnEventBaseStrategy
{
public:
	struct FGameplayTag                           _stateTag;                                         // 0x0030(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExecuteActionOnEventTargetHasStateTag">();
	}
	static class UExecuteActionOnEventTargetHasStateTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExecuteActionOnEventTargetHasStateTag>();
	}
};
static_assert(alignof(UExecuteActionOnEventTargetHasStateTag) == 0x000008, "Wrong alignment on UExecuteActionOnEventTargetHasStateTag");
static_assert(sizeof(UExecuteActionOnEventTargetHasStateTag) == 0x000040, "Wrong size on UExecuteActionOnEventTargetHasStateTag");
static_assert(offsetof(UExecuteActionOnEventTargetHasStateTag, _stateTag) == 0x000030, "Member 'UExecuteActionOnEventTargetHasStateTag::_stateTag' has a wrong offset!");

// Class DBDCompetence.ExecuteActionOnEventInRangeOfOwningPlayerStrategy
// 0x0008 (0x0038 - 0x0030)
class UExecuteActionOnEventInRangeOfOwningPlayerStrategy final : public UExecuteActionOnEventBaseStrategy
{
public:
	float                                         _range;                                            // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExecuteActionOnEventInRangeOfOwningPlayerStrategy">();
	}
	static class UExecuteActionOnEventInRangeOfOwningPlayerStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExecuteActionOnEventInRangeOfOwningPlayerStrategy>();
	}
};
static_assert(alignof(UExecuteActionOnEventInRangeOfOwningPlayerStrategy) == 0x000008, "Wrong alignment on UExecuteActionOnEventInRangeOfOwningPlayerStrategy");
static_assert(sizeof(UExecuteActionOnEventInRangeOfOwningPlayerStrategy) == 0x000038, "Wrong size on UExecuteActionOnEventInRangeOfOwningPlayerStrategy");
static_assert(offsetof(UExecuteActionOnEventInRangeOfOwningPlayerStrategy, _range) == 0x000030, "Member 'UExecuteActionOnEventInRangeOfOwningPlayerStrategy::_range' has a wrong offset!");

// Class DBDCompetence.ExecuteActionIfCooldownTimerDone
// 0x0000 (0x0030 - 0x0030)
class UExecuteActionIfCooldownTimerDone final : public UExecuteActionOnEventBaseStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExecuteActionIfCooldownTimerDone">();
	}
	static class UExecuteActionIfCooldownTimerDone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExecuteActionIfCooldownTimerDone>();
	}
};
static_assert(alignof(UExecuteActionIfCooldownTimerDone) == 0x000008, "Wrong alignment on UExecuteActionIfCooldownTimerDone");
static_assert(sizeof(UExecuteActionIfCooldownTimerDone) == 0x000030, "Wrong size on UExecuteActionIfCooldownTimerDone");

// Class DBDCompetence.ExecuteActionIfActivationTimerDone
// 0x0000 (0x0030 - 0x0030)
class UExecuteActionIfActivationTimerDone final : public UExecuteActionOnEventBaseStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExecuteActionIfActivationTimerDone">();
	}
	static class UExecuteActionIfActivationTimerDone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExecuteActionIfActivationTimerDone>();
	}
};
static_assert(alignof(UExecuteActionIfActivationTimerDone) == 0x000008, "Wrong alignment on UExecuteActionIfActivationTimerDone");
static_assert(sizeof(UExecuteActionIfActivationTimerDone) == 0x000030, "Wrong size on UExecuteActionIfActivationTimerDone");

// Class DBDCompetence.ExecuteActionIfEventTargetIsOwningPlayer
// 0x0000 (0x0030 - 0x0030)
class UExecuteActionIfEventTargetIsOwningPlayer final : public UExecuteActionOnEventBaseStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExecuteActionIfEventTargetIsOwningPlayer">();
	}
	static class UExecuteActionIfEventTargetIsOwningPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExecuteActionIfEventTargetIsOwningPlayer>();
	}
};
static_assert(alignof(UExecuteActionIfEventTargetIsOwningPlayer) == 0x000008, "Wrong alignment on UExecuteActionIfEventTargetIsOwningPlayer");
static_assert(sizeof(UExecuteActionIfEventTargetIsOwningPlayer) == 0x000030, "Wrong size on UExecuteActionIfEventTargetIsOwningPlayer");

// Class DBDCompetence.ExecuteActionIfEventInstigatorIsOwningPlayer
// 0x0000 (0x0030 - 0x0030)
class UExecuteActionIfEventInstigatorIsOwningPlayer final : public UExecuteActionOnEventBaseStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExecuteActionIfEventInstigatorIsOwningPlayer">();
	}
	static class UExecuteActionIfEventInstigatorIsOwningPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExecuteActionIfEventInstigatorIsOwningPlayer>();
	}
};
static_assert(alignof(UExecuteActionIfEventInstigatorIsOwningPlayer) == 0x000008, "Wrong alignment on UExecuteActionIfEventInstigatorIsOwningPlayer");
static_assert(sizeof(UExecuteActionIfEventInstigatorIsOwningPlayer) == 0x000030, "Wrong size on UExecuteActionIfEventInstigatorIsOwningPlayer");

// Class DBDCompetence.ExecuteActionsBaseAction
// 0x0010 (0x0050 - 0x0040)
class UExecuteActionsBaseAction : public UCompetenceAction
{
public:
	TArray<class UCompetenceAction*>              _actionsToExecute;                                 // 0x0040(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExecuteActionsBaseAction">();
	}
	static class UExecuteActionsBaseAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExecuteActionsBaseAction>();
	}
};
static_assert(alignof(UExecuteActionsBaseAction) == 0x000008, "Wrong alignment on UExecuteActionsBaseAction");
static_assert(sizeof(UExecuteActionsBaseAction) == 0x000050, "Wrong size on UExecuteActionsBaseAction");
static_assert(offsetof(UExecuteActionsBaseAction, _actionsToExecute) == 0x000040, "Member 'UExecuteActionsBaseAction::_actionsToExecute' has a wrong offset!");

// Class DBDCompetence.ExecuteActionsOnCooldownTimerDoneAction
// 0x0048 (0x0098 - 0x0050)
class UExecuteActionsOnCooldownTimerDoneAction final : public UExecuteActionsBaseAction
{
public:
	struct FGameplayTagQuery                      _stateTagQueryCondition;                           // 0x0050(0x0048)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExecuteActionsOnCooldownTimerDoneAction">();
	}
	static class UExecuteActionsOnCooldownTimerDoneAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExecuteActionsOnCooldownTimerDoneAction>();
	}
};
static_assert(alignof(UExecuteActionsOnCooldownTimerDoneAction) == 0x000008, "Wrong alignment on UExecuteActionsOnCooldownTimerDoneAction");
static_assert(sizeof(UExecuteActionsOnCooldownTimerDoneAction) == 0x000098, "Wrong size on UExecuteActionsOnCooldownTimerDoneAction");
static_assert(offsetof(UExecuteActionsOnCooldownTimerDoneAction, _stateTagQueryCondition) == 0x000050, "Member 'UExecuteActionsOnCooldownTimerDoneAction::_stateTagQueryCondition' has a wrong offset!");

// Class DBDCompetence.ExecuteActionsOnGameEventAction
// 0x0040 (0x0090 - 0x0050)
class UExecuteActionsOnGameEventAction : public UExecuteActionsBaseAction
{
public:
	TArray<class UExecuteActionOnEventBaseStrategy*> _executeActionOnEventStrategies;                // 0x0050(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  _eventTypes;                                       // 0x0060(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x10];                                      // 0x0080(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExecuteActionsOnGameEventAction">();
	}
	static class UExecuteActionsOnGameEventAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExecuteActionsOnGameEventAction>();
	}
};
static_assert(alignof(UExecuteActionsOnGameEventAction) == 0x000008, "Wrong alignment on UExecuteActionsOnGameEventAction");
static_assert(sizeof(UExecuteActionsOnGameEventAction) == 0x000090, "Wrong size on UExecuteActionsOnGameEventAction");
static_assert(offsetof(UExecuteActionsOnGameEventAction, _executeActionOnEventStrategies) == 0x000050, "Member 'UExecuteActionsOnGameEventAction::_executeActionOnEventStrategies' has a wrong offset!");
static_assert(offsetof(UExecuteActionsOnGameEventAction, _eventTypes) == 0x000060, "Member 'UExecuteActionsOnGameEventAction::_eventTypes' has a wrong offset!");

// Class DBDCompetence.ExecuteActionsOnStateTagQueryAction
// 0x0048 (0x0098 - 0x0050)
class UExecuteActionsOnStateTagQueryAction final : public UExecuteActionsBaseAction
{
public:
	struct FGameplayTagQuery                      _stateTagQuery;                                    // 0x0050(0x0048)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExecuteActionsOnStateTagQueryAction">();
	}
	static class UExecuteActionsOnStateTagQueryAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExecuteActionsOnStateTagQueryAction>();
	}
};
static_assert(alignof(UExecuteActionsOnStateTagQueryAction) == 0x000008, "Wrong alignment on UExecuteActionsOnStateTagQueryAction");
static_assert(sizeof(UExecuteActionsOnStateTagQueryAction) == 0x000098, "Wrong size on UExecuteActionsOnStateTagQueryAction");
static_assert(offsetof(UExecuteActionsOnStateTagQueryAction, _stateTagQuery) == 0x000050, "Member 'UExecuteActionsOnStateTagQueryAction::_stateTagQuery' has a wrong offset!");

// Class DBDCompetence.ExecuteStatusEffectActionOnGameEventAction
// 0x0008 (0x0098 - 0x0090)
class UExecuteStatusEffectActionOnGameEventAction final : public UExecuteActionsOnGameEventAction
{
public:
	class UActivateStatusEffectOnEventBaseStrategy* _executeActionOnEventStrategy;                   // 0x0090(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExecuteStatusEffectActionOnGameEventAction">();
	}
	static class UExecuteStatusEffectActionOnGameEventAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExecuteStatusEffectActionOnGameEventAction>();
	}
};
static_assert(alignof(UExecuteStatusEffectActionOnGameEventAction) == 0x000008, "Wrong alignment on UExecuteStatusEffectActionOnGameEventAction");
static_assert(sizeof(UExecuteStatusEffectActionOnGameEventAction) == 0x000098, "Wrong size on UExecuteStatusEffectActionOnGameEventAction");
static_assert(offsetof(UExecuteStatusEffectActionOnGameEventAction, _executeActionOnEventStrategy) == 0x000090, "Member 'UExecuteStatusEffectActionOnGameEventAction::_executeActionOnEventStrategy' has a wrong offset!");

// Class DBDCompetence.Fixated
// 0x0008 (0x0468 - 0x0460)
class UFixated final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _fixatedStatusEffect;                              // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Fixated">();
	}
	static class UFixated* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFixated>();
	}
};
static_assert(alignof(UFixated) == 0x000008, "Wrong alignment on UFixated");
static_assert(sizeof(UFixated) == 0x000468, "Wrong size on UFixated");
static_assert(offsetof(UFixated, _fixatedStatusEffect) == 0x000460, "Member 'UFixated::_fixatedStatusEffect' has a wrong offset!");

// Class DBDCompetence.FlipFlop
// 0x0018 (0x0478 - 0x0460)
class UFlipFlop final : public UPerk
{
public:
	float                                         _recoveryProgressionConversionRatio[0x3];          // 0x0460(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxWiggleProgression[0x3];                        // 0x046C(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Authority_OnPickedUp(class ADBDPlayer* picker);

	float GetMaxWiggleProgressionAtLevel() const;
	float GetRecoveryProgressionAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlipFlop">();
	}
	static class UFlipFlop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlipFlop>();
	}
};
static_assert(alignof(UFlipFlop) == 0x000008, "Wrong alignment on UFlipFlop");
static_assert(sizeof(UFlipFlop) == 0x000478, "Wrong size on UFlipFlop");
static_assert(offsetof(UFlipFlop, _recoveryProgressionConversionRatio) == 0x000460, "Member 'UFlipFlop::_recoveryProgressionConversionRatio' has a wrong offset!");
static_assert(offsetof(UFlipFlop, _maxWiggleProgression) == 0x00046C, "Member 'UFlipFlop::_maxWiggleProgression' has a wrong offset!");

// Class DBDCompetence.FurtiveChase
// 0x0028 (0x0488 - 0x0460)
class UFurtiveChase final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _undetectableStatusEffectClass;                    // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _hasteStatusEffectClass;                           // 0x0468(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _undetectableAndHasteStatusEffectDuration[0x3];    // 0x0470(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _hasteStatusEffectPercent;                         // 0x047C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStatusEffect*                          _hasteEffect;                                      // 0x0480(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	float GetHasteStatusEffectPercent() const;
	float GetUndetectableAndHasteStatusEffectDurationAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FurtiveChase">();
	}
	static class UFurtiveChase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFurtiveChase>();
	}
};
static_assert(alignof(UFurtiveChase) == 0x000008, "Wrong alignment on UFurtiveChase");
static_assert(sizeof(UFurtiveChase) == 0x000488, "Wrong size on UFurtiveChase");
static_assert(offsetof(UFurtiveChase, _undetectableStatusEffectClass) == 0x000460, "Member 'UFurtiveChase::_undetectableStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UFurtiveChase, _hasteStatusEffectClass) == 0x000468, "Member 'UFurtiveChase::_hasteStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UFurtiveChase, _undetectableAndHasteStatusEffectDuration) == 0x000470, "Member 'UFurtiveChase::_undetectableAndHasteStatusEffectDuration' has a wrong offset!");
static_assert(offsetof(UFurtiveChase, _hasteStatusEffectPercent) == 0x00047C, "Member 'UFurtiveChase::_hasteStatusEffectPercent' has a wrong offset!");
static_assert(offsetof(UFurtiveChase, _hasteEffect) == 0x000480, "Member 'UFurtiveChase::_hasteEffect' has a wrong offset!");

// Class DBDCompetence.GameEventObjectBaseStrategy
// 0x0000 (0x0030 - 0x0030)
class UGameEventObjectBaseStrategy : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameEventObjectBaseStrategy">();
	}
	static class UGameEventObjectBaseStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameEventObjectBaseStrategy>();
	}
};
static_assert(alignof(UGameEventObjectBaseStrategy) == 0x000008, "Wrong alignment on UGameEventObjectBaseStrategy");
static_assert(sizeof(UGameEventObjectBaseStrategy) == 0x000030, "Wrong size on UGameEventObjectBaseStrategy");

// Class DBDCompetence.GameEventObjectOwningPlayerStrategy
// 0x0000 (0x0030 - 0x0030)
class UGameEventObjectOwningPlayerStrategy final : public UGameEventObjectBaseStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameEventObjectOwningPlayerStrategy">();
	}
	static class UGameEventObjectOwningPlayerStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameEventObjectOwningPlayerStrategy>();
	}
};
static_assert(alignof(UGameEventObjectOwningPlayerStrategy) == 0x000008, "Wrong alignment on UGameEventObjectOwningPlayerStrategy");
static_assert(sizeof(UGameEventObjectOwningPlayerStrategy) == 0x000030, "Wrong size on UGameEventObjectOwningPlayerStrategy");

// Class DBDCompetence.GameEventObjectOriginatingPlayerStrategy
// 0x0000 (0x0030 - 0x0030)
class UGameEventObjectOriginatingPlayerStrategy final : public UGameEventObjectBaseStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameEventObjectOriginatingPlayerStrategy">();
	}
	static class UGameEventObjectOriginatingPlayerStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameEventObjectOriginatingPlayerStrategy>();
	}
};
static_assert(alignof(UGameEventObjectOriginatingPlayerStrategy) == 0x000008, "Wrong alignment on UGameEventObjectOriginatingPlayerStrategy");
static_assert(sizeof(UGameEventObjectOriginatingPlayerStrategy) == 0x000030, "Wrong size on UGameEventObjectOriginatingPlayerStrategy");

// Class DBDCompetence.HangmansTrick
// 0x0000 (0x04E0 - 0x04E0)
class UHangmansTrick final : public USpawningEffectPerk
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HangmansTrick">();
	}
	static class UHangmansTrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHangmansTrick>();
	}
};
static_assert(alignof(UHangmansTrick) == 0x000008, "Wrong alignment on UHangmansTrick");
static_assert(sizeof(UHangmansTrick) == 0x0004E0, "Wrong size on UHangmansTrick");

// Class DBDCompetence.HasCleansedTotemInnerStrength
// 0x0010 (0x0100 - 0x00F0)
class UHasCleansedTotemInnerStrength final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_F0[0x10];                                      // 0x00F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HasCleansedTotemInnerStrength">();
	}
	static class UHasCleansedTotemInnerStrength* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHasCleansedTotemInnerStrength>();
	}
};
static_assert(alignof(UHasCleansedTotemInnerStrength) == 0x000008, "Wrong alignment on UHasCleansedTotemInnerStrength");
static_assert(sizeof(UHasCleansedTotemInnerStrength) == 0x000100, "Wrong size on UHasCleansedTotemInnerStrength");

// Class DBDCompetence.HasFlag
// 0x0048 (0x0138 - 0x00F0)
class UHasFlag final : public UEventDrivenModifierCondition
{
public:
	struct FGameplayTag                           _flag;                                             // 0x00F0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FC[0x3C];                                      // 0x00FC(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HasFlag">();
	}
	static class UHasFlag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHasFlag>();
	}
};
static_assert(alignof(UHasFlag) == 0x000008, "Wrong alignment on UHasFlag");
static_assert(sizeof(UHasFlag) == 0x000138, "Wrong size on UHasFlag");
static_assert(offsetof(UHasFlag, _flag) == 0x0000F0, "Member 'UHasFlag::_flag' has a wrong offset!");

// Class DBDCompetence.HasItemOfTypeEquipped
// 0x0018 (0x0108 - 0x00F0)
class UHasItemOfTypeEquipped : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_F0[0x10];                                      // 0x00F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	ELoadoutItemType                              _itemType;                                         // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HasItemOfTypeEquipped">();
	}
	static class UHasItemOfTypeEquipped* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHasItemOfTypeEquipped>();
	}
};
static_assert(alignof(UHasItemOfTypeEquipped) == 0x000008, "Wrong alignment on UHasItemOfTypeEquipped");
static_assert(sizeof(UHasItemOfTypeEquipped) == 0x000108, "Wrong size on UHasItemOfTypeEquipped");
static_assert(offsetof(UHasItemOfTypeEquipped, _itemType) == 0x000100, "Member 'UHasItemOfTypeEquipped::_itemType' has a wrong offset!");

// Class DBDCompetence.HasItemOfTypeEquippedNoCharge
// 0x0010 (0x0118 - 0x0108)
class UHasItemOfTypeEquippedNoCharge final : public UHasItemOfTypeEquipped
{
public:
	uint8                                         Pad_108[0x10];                                     // 0x0108(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnItemChargeStateChanged(bool IsEmpty);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HasItemOfTypeEquippedNoCharge">();
	}
	static class UHasItemOfTypeEquippedNoCharge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHasItemOfTypeEquippedNoCharge>();
	}
};
static_assert(alignof(UHasItemOfTypeEquippedNoCharge) == 0x000008, "Wrong alignment on UHasItemOfTypeEquippedNoCharge");
static_assert(sizeof(UHasItemOfTypeEquippedNoCharge) == 0x000118, "Wrong size on UHasItemOfTypeEquippedNoCharge");

// Class DBDCompetence.HasItemOfTypeInInventory
// 0x0000 (0x0108 - 0x0108)
class UHasItemOfTypeInInventory : public UHasItemOfTypeEquipped
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HasItemOfTypeInInventory">();
	}
	static class UHasItemOfTypeInInventory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHasItemOfTypeInInventory>();
	}
};
static_assert(alignof(UHasItemOfTypeInInventory) == 0x000008, "Wrong alignment on UHasItemOfTypeInInventory");
static_assert(sizeof(UHasItemOfTypeInInventory) == 0x000108, "Wrong size on UHasItemOfTypeInInventory");

// Class DBDCompetence.HasItemOfTypeInInventoryNoCharge
// 0x0010 (0x0118 - 0x0108)
class UHasItemOfTypeInInventoryNoCharge final : public UHasItemOfTypeInInventory
{
public:
	uint8                                         Pad_108[0x10];                                     // 0x0108(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnItemChargeStateChanged(bool IsEmpty);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HasItemOfTypeInInventoryNoCharge">();
	}
	static class UHasItemOfTypeInInventoryNoCharge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHasItemOfTypeInInventoryNoCharge>();
	}
};
static_assert(alignof(UHasItemOfTypeInInventoryNoCharge) == 0x000008, "Wrong alignment on UHasItemOfTypeInInventoryNoCharge");
static_assert(sizeof(UHasItemOfTypeInInventoryNoCharge) == 0x000118, "Wrong size on UHasItemOfTypeInInventoryNoCharge");

// Class DBDCompetence.HasLineOfSightQueryComponent
// 0x0010 (0x00C8 - 0x00B8)
class UHasLineOfSightQueryComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HasLineOfSightQueryComponent">();
	}
	static class UHasLineOfSightQueryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHasLineOfSightQueryComponent>();
	}
};
static_assert(alignof(UHasLineOfSightQueryComponent) == 0x000008, "Wrong alignment on UHasLineOfSightQueryComponent");
static_assert(sizeof(UHasLineOfSightQueryComponent) == 0x0000C8, "Wrong size on UHasLineOfSightQueryComponent");

// Class DBDCompetence.HasRemainingGenerators
// 0x0030 (0x0120 - 0x00F0)
class UHasRemainingGenerators final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_F0[0x30];                                      // 0x00F0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HasRemainingGenerators">();
	}
	static class UHasRemainingGenerators* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHasRemainingGenerators>();
	}
};
static_assert(alignof(UHasRemainingGenerators) == 0x000008, "Wrong alignment on UHasRemainingGenerators");
static_assert(sizeof(UHasRemainingGenerators) == 0x000120, "Wrong size on UHasRemainingGenerators");

// Class DBDCompetence.HealHealthStateAction
// 0x0010 (0x0050 - 0x0040)
class UHealHealthStateAction final : public UCompetenceAction
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _healthToAdd;                                      // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _applyToEventInstigator;                           // 0x004C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _applyToEventTarget;                               // 0x004D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4E[0x2];                                       // 0x004E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HealHealthStateAction">();
	}
	static class UHealHealthStateAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHealHealthStateAction>();
	}
};
static_assert(alignof(UHealHealthStateAction) == 0x000008, "Wrong alignment on UHealHealthStateAction");
static_assert(sizeof(UHealHealthStateAction) == 0x000050, "Wrong size on UHealHealthStateAction");
static_assert(offsetof(UHealHealthStateAction, _healthToAdd) == 0x000048, "Member 'UHealHealthStateAction::_healthToAdd' has a wrong offset!");
static_assert(offsetof(UHealHealthStateAction, _applyToEventInstigator) == 0x00004C, "Member 'UHealHealthStateAction::_applyToEventInstigator' has a wrong offset!");
static_assert(offsetof(UHealHealthStateAction, _applyToEventTarget) == 0x00004D, "Member 'UHealHealthStateAction::_applyToEventTarget' has a wrong offset!");

// Class DBDCompetence.HemorrhageStatusEffect
// 0x0068 (0x0410 - 0x03A8)
class UHemorrhageStatusEffect final : public UAdjustableCooldownStatusEffect
{
public:
	float                                         _cooldownFXTime;                                   // 0x03A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _removeEffectWhenFullyHealed;                      // 0x03AC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3AD[0x63];                                     // 0x03AD(0x0063)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnSurvivorHealed(const struct FHealResult& HealResult);
	void OnStoppedHealing(const class ADBDPlayer* Instigator, const class ADBDPlayer* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HemorrhageStatusEffect">();
	}
	static class UHemorrhageStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHemorrhageStatusEffect>();
	}
};
static_assert(alignof(UHemorrhageStatusEffect) == 0x000008, "Wrong alignment on UHemorrhageStatusEffect");
static_assert(sizeof(UHemorrhageStatusEffect) == 0x000410, "Wrong size on UHemorrhageStatusEffect");
static_assert(offsetof(UHemorrhageStatusEffect, _cooldownFXTime) == 0x0003A8, "Member 'UHemorrhageStatusEffect::_cooldownFXTime' has a wrong offset!");
static_assert(offsetof(UHemorrhageStatusEffect, _removeEffectWhenFullyHealed) == 0x0003AC, "Member 'UHemorrhageStatusEffect::_removeEffectWhenFullyHealed' has a wrong offset!");

// Class DBDCompetence.HexDevourHope
// 0x0078 (0x0558 - 0x04E0)
class UHexDevourHope final : public UHexPerk
{
public:
	TSubclassOf<class UStatusEffect>              _devourHopeSpeedStatusEffect;                      // 0x04E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _exposedStatusEffect;                              // 0x04E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _rangeFromUnhookedSurvivorNeeded;                  // 0x04F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F4[0x4];                                      // 0x04F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _tokenThresholdToImposeSpeedBoost;                 // 0x04F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _tokenThresholdToImposeExposeEffect;               // 0x04FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _tokenThresholdToImposeAbilityToKill;              // 0x0500(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_504[0x4];                                      // 0x0504(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _attackGameEvents;                                 // 0x0508(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _moveSpeedIncrement[0x3];                          // 0x0528(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_534[0x24];                                     // 0x0534(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetMoveSpeedIncrement(int32 PerkLevel) const;
	float GetRangeFromUnhookedSurvivorNeeded(int32 PerkLevel) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HexDevourHope">();
	}
	static class UHexDevourHope* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHexDevourHope>();
	}
};
static_assert(alignof(UHexDevourHope) == 0x000008, "Wrong alignment on UHexDevourHope");
static_assert(sizeof(UHexDevourHope) == 0x000558, "Wrong size on UHexDevourHope");
static_assert(offsetof(UHexDevourHope, _devourHopeSpeedStatusEffect) == 0x0004E0, "Member 'UHexDevourHope::_devourHopeSpeedStatusEffect' has a wrong offset!");
static_assert(offsetof(UHexDevourHope, _exposedStatusEffect) == 0x0004E8, "Member 'UHexDevourHope::_exposedStatusEffect' has a wrong offset!");
static_assert(offsetof(UHexDevourHope, _rangeFromUnhookedSurvivorNeeded) == 0x0004F0, "Member 'UHexDevourHope::_rangeFromUnhookedSurvivorNeeded' has a wrong offset!");
static_assert(offsetof(UHexDevourHope, _tokenThresholdToImposeSpeedBoost) == 0x0004F8, "Member 'UHexDevourHope::_tokenThresholdToImposeSpeedBoost' has a wrong offset!");
static_assert(offsetof(UHexDevourHope, _tokenThresholdToImposeExposeEffect) == 0x0004FC, "Member 'UHexDevourHope::_tokenThresholdToImposeExposeEffect' has a wrong offset!");
static_assert(offsetof(UHexDevourHope, _tokenThresholdToImposeAbilityToKill) == 0x000500, "Member 'UHexDevourHope::_tokenThresholdToImposeAbilityToKill' has a wrong offset!");
static_assert(offsetof(UHexDevourHope, _attackGameEvents) == 0x000508, "Member 'UHexDevourHope::_attackGameEvents' has a wrong offset!");
static_assert(offsetof(UHexDevourHope, _moveSpeedIncrement) == 0x000528, "Member 'UHexDevourHope::_moveSpeedIncrement' has a wrong offset!");

// Class DBDCompetence.HexNoOneEscapesDeath
// 0x0070 (0x0550 - 0x04E0)
class UHexNoOneEscapesDeath final : public UHexPerk
{
public:
	TSubclassOf<class UStatusEffect>              _hasteImposedEffectClass;                          // 0x04E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _exposedEffectClass;                               // 0x04E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _revealCurseWhenTotemShownToSurvivor;              // 0x04F0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _revealCurseWhenSurvivorGetHits;                   // 0x04F1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F2[0x2];                                      // 0x04F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _auraRevealStartDistance;                          // 0x04F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _auraRevealEndDistance;                            // 0x04F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _auraRevealDuration;                               // 0x04FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _hastePerLevel[0x3];                               // 0x0500(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _shouldActivateTotemOutline;                       // 0x050C(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50D[0x43];                                     // 0x050D(0x0043)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const float GetHasteAtLevel();
	void OnRep_SetShouldActivateTotemOutline();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HexNoOneEscapesDeath">();
	}
	static class UHexNoOneEscapesDeath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHexNoOneEscapesDeath>();
	}
};
static_assert(alignof(UHexNoOneEscapesDeath) == 0x000008, "Wrong alignment on UHexNoOneEscapesDeath");
static_assert(sizeof(UHexNoOneEscapesDeath) == 0x000550, "Wrong size on UHexNoOneEscapesDeath");
static_assert(offsetof(UHexNoOneEscapesDeath, _hasteImposedEffectClass) == 0x0004E0, "Member 'UHexNoOneEscapesDeath::_hasteImposedEffectClass' has a wrong offset!");
static_assert(offsetof(UHexNoOneEscapesDeath, _exposedEffectClass) == 0x0004E8, "Member 'UHexNoOneEscapesDeath::_exposedEffectClass' has a wrong offset!");
static_assert(offsetof(UHexNoOneEscapesDeath, _revealCurseWhenTotemShownToSurvivor) == 0x0004F0, "Member 'UHexNoOneEscapesDeath::_revealCurseWhenTotemShownToSurvivor' has a wrong offset!");
static_assert(offsetof(UHexNoOneEscapesDeath, _revealCurseWhenSurvivorGetHits) == 0x0004F1, "Member 'UHexNoOneEscapesDeath::_revealCurseWhenSurvivorGetHits' has a wrong offset!");
static_assert(offsetof(UHexNoOneEscapesDeath, _auraRevealStartDistance) == 0x0004F4, "Member 'UHexNoOneEscapesDeath::_auraRevealStartDistance' has a wrong offset!");
static_assert(offsetof(UHexNoOneEscapesDeath, _auraRevealEndDistance) == 0x0004F8, "Member 'UHexNoOneEscapesDeath::_auraRevealEndDistance' has a wrong offset!");
static_assert(offsetof(UHexNoOneEscapesDeath, _auraRevealDuration) == 0x0004FC, "Member 'UHexNoOneEscapesDeath::_auraRevealDuration' has a wrong offset!");
static_assert(offsetof(UHexNoOneEscapesDeath, _hastePerLevel) == 0x000500, "Member 'UHexNoOneEscapesDeath::_hastePerLevel' has a wrong offset!");
static_assert(offsetof(UHexNoOneEscapesDeath, _shouldActivateTotemOutline) == 0x00050C, "Member 'UHexNoOneEscapesDeath::_shouldActivateTotemOutline' has a wrong offset!");

// Class DBDCompetence.HexThirdSeal
// 0x0030 (0x0510 - 0x04E0)
class UHexThirdSeal final : public UHexPerk
{
public:
	uint8                                         Pad_4E0[0x18];                                     // 0x04E0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _thirdSealBlindnessEffect;                         // 0x04F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _maximumBlindableSurvivors[0x3];                   // 0x0500(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50C[0x4];                                      // 0x050C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HexThirdSeal">();
	}
	static class UHexThirdSeal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHexThirdSeal>();
	}
};
static_assert(alignof(UHexThirdSeal) == 0x000008, "Wrong alignment on UHexThirdSeal");
static_assert(sizeof(UHexThirdSeal) == 0x000510, "Wrong size on UHexThirdSeal");
static_assert(offsetof(UHexThirdSeal, _thirdSealBlindnessEffect) == 0x0004F8, "Member 'UHexThirdSeal::_thirdSealBlindnessEffect' has a wrong offset!");
static_assert(offsetof(UHexThirdSeal, _maximumBlindableSurvivors) == 0x000500, "Member 'UHexThirdSeal::_maximumBlindableSurvivors' has a wrong offset!");

// Class DBDCompetence.HexThrillOfTheHuntStatusEffect
// 0x0010 (0x03A8 - 0x0398)
class UHexThrillOfTheHuntStatusEffect final : public UStatusEffect
{
public:
	float                                         _speedPenaltyPercents[0x3];                        // 0x0398(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A4[0x4];                                      // 0x03A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetSpeedPenaltyPercents(int32 tierLevel) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HexThrillOfTheHuntStatusEffect">();
	}
	static class UHexThrillOfTheHuntStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHexThrillOfTheHuntStatusEffect>();
	}
};
static_assert(alignof(UHexThrillOfTheHuntStatusEffect) == 0x000008, "Wrong alignment on UHexThrillOfTheHuntStatusEffect");
static_assert(sizeof(UHexThrillOfTheHuntStatusEffect) == 0x0003A8, "Wrong size on UHexThrillOfTheHuntStatusEffect");
static_assert(offsetof(UHexThrillOfTheHuntStatusEffect, _speedPenaltyPercents) == 0x000398, "Member 'UHexThrillOfTheHuntStatusEffect::_speedPenaltyPercents' has a wrong offset!");

// Class DBDCompetence.HopePerk
// 0x0018 (0x0478 - 0x0460)
class UHopePerk final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _hopePerkEffect;                                   // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _hasteEffect[0x3];                                 // 0x0468(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_474[0x4];                                      // 0x0474(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetHasteEffectAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HopePerk">();
	}
	static class UHopePerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHopePerk>();
	}
};
static_assert(alignof(UHopePerk) == 0x000008, "Wrong alignment on UHopePerk");
static_assert(sizeof(UHopePerk) == 0x000478, "Wrong size on UHopePerk");
static_assert(offsetof(UHopePerk, _hopePerkEffect) == 0x000460, "Member 'UHopePerk::_hopePerkEffect' has a wrong offset!");
static_assert(offsetof(UHopePerk, _hasteEffect) == 0x000468, "Member 'UHopePerk::_hasteEffect' has a wrong offset!");

// Class DBDCompetence.ImAllEars
// 0x0030 (0x0490 - 0x0460)
class UImAllEars final : public UPerk
{
public:
	int32                                         _cooldownByLevel[0x3];                             // 0x0460(0x0004)(Edit, EditFixedSize, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _durationByLevel[0x3];                             // 0x046C(0x0004)(Edit, EditFixedSize, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _useTerrorRadius;                                  // 0x0478(0x0001)(Edit, EditFixedSize, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_479[0x3];                                      // 0x0479(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _triggerOutsideRadius;                             // 0x047C(0x0004)(Edit, EditFixedSize, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _timedRevealToKillerEffect;                        // 0x0480(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_488[0x8];                                      // 0x0488(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetCooldownAtLevel();
	float GetDurationAtLevel();
	void Server_OnCamperLoudNoise(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImAllEars">();
	}
	static class UImAllEars* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImAllEars>();
	}
};
static_assert(alignof(UImAllEars) == 0x000008, "Wrong alignment on UImAllEars");
static_assert(sizeof(UImAllEars) == 0x000490, "Wrong size on UImAllEars");
static_assert(offsetof(UImAllEars, _cooldownByLevel) == 0x000460, "Member 'UImAllEars::_cooldownByLevel' has a wrong offset!");
static_assert(offsetof(UImAllEars, _durationByLevel) == 0x00046C, "Member 'UImAllEars::_durationByLevel' has a wrong offset!");
static_assert(offsetof(UImAllEars, _useTerrorRadius) == 0x000478, "Member 'UImAllEars::_useTerrorRadius' has a wrong offset!");
static_assert(offsetof(UImAllEars, _triggerOutsideRadius) == 0x00047C, "Member 'UImAllEars::_triggerOutsideRadius' has a wrong offset!");
static_assert(offsetof(UImAllEars, _timedRevealToKillerEffect) == 0x000480, "Member 'UImAllEars::_timedRevealToKillerEffect' has a wrong offset!");

// Class DBDCompetence.ImposeStatusEffectOnMultiEventAddon
// 0x0010 (0x0310 - 0x0300)
class UImposeStatusEffectOnMultiEventAddon final : public UItemAddon
{
public:
	TArray<struct FMultiStatusEffectInfo>         _statusEffectInfo;                                 // 0x0300(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void Authority_OnEventFired(const struct FGameplayTag& GameEventTag, const struct FGameEventData& GameEventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImposeStatusEffectOnMultiEventAddon">();
	}
	static class UImposeStatusEffectOnMultiEventAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImposeStatusEffectOnMultiEventAddon>();
	}
};
static_assert(alignof(UImposeStatusEffectOnMultiEventAddon) == 0x000008, "Wrong alignment on UImposeStatusEffectOnMultiEventAddon");
static_assert(sizeof(UImposeStatusEffectOnMultiEventAddon) == 0x000310, "Wrong size on UImposeStatusEffectOnMultiEventAddon");
static_assert(offsetof(UImposeStatusEffectOnMultiEventAddon, _statusEffectInfo) == 0x000300, "Member 'UImposeStatusEffectOnMultiEventAddon::_statusEffectInfo' has a wrong offset!");

// Class DBDCompetence.InfectiousFright
// 0x0048 (0x04A8 - 0x0460)
class UInfectiousFright final : public UPerk
{
public:
	bool                                          _revealPlayerInTerrorRadius;                       // 0x0460(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         _perkActivationCount;                              // 0x0461(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_462[0x6];                                      // 0x0462(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ASurvivor*>                      _revealedSurvivors;                                // 0x0468(0x0010)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class ASurvivor*                              _targetSurvivor;                                   // 0x0478(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_480[0x28];                                     // 0x0480(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_PerkActivationCount();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InfectiousFright">();
	}
	static class UInfectiousFright* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInfectiousFright>();
	}
};
static_assert(alignof(UInfectiousFright) == 0x000008, "Wrong alignment on UInfectiousFright");
static_assert(sizeof(UInfectiousFright) == 0x0004A8, "Wrong size on UInfectiousFright");
static_assert(offsetof(UInfectiousFright, _revealPlayerInTerrorRadius) == 0x000460, "Member 'UInfectiousFright::_revealPlayerInTerrorRadius' has a wrong offset!");
static_assert(offsetof(UInfectiousFright, _perkActivationCount) == 0x000461, "Member 'UInfectiousFright::_perkActivationCount' has a wrong offset!");
static_assert(offsetof(UInfectiousFright, _revealedSurvivors) == 0x000468, "Member 'UInfectiousFright::_revealedSurvivors' has a wrong offset!");
static_assert(offsetof(UInfectiousFright, _targetSurvivor) == 0x000478, "Member 'UInfectiousFright::_targetSurvivor' has a wrong offset!");

// Class DBDCompetence.InnerStrength
// 0x0030 (0x0490 - 0x0460)
class UInnerStrength final : public UPerk
{
public:
	uint8                                         Pad_460[0x8];                                      // 0x0460(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _hideDuration[0x3];                                // 0x0468(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_474[0x1C];                                     // 0x0474(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnPlayerImmobilizeStateChanged(const EImmobilizedState oldImmobilizeState, const EImmobilizedState newImmobilizeState);

	float GetHideDuration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InnerStrength">();
	}
	static class UInnerStrength* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInnerStrength>();
	}
};
static_assert(alignof(UInnerStrength) == 0x000008, "Wrong alignment on UInnerStrength");
static_assert(sizeof(UInnerStrength) == 0x000490, "Wrong size on UInnerStrength");
static_assert(offsetof(UInnerStrength, _hideDuration) == 0x000468, "Member 'UInnerStrength::_hideDuration' has a wrong offset!");

// Class DBDCompetence.InsidiousEffect
// 0x0000 (0x0398 - 0x0398)
class UInsidiousEffect final : public UStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InsidiousEffect">();
	}
	static class UInsidiousEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInsidiousEffect>();
	}
};
static_assert(alignof(UInsidiousEffect) == 0x000008, "Wrong alignment on UInsidiousEffect");
static_assert(sizeof(UInsidiousEffect) == 0x000398, "Wrong size on UInsidiousEffect");

// Class DBDCompetence.IsActivationTimerActive
// 0x0018 (0x0108 - 0x00F0)
class UIsActivationTimerActive final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_F0[0x18];                                      // 0x00F0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsActivationTimerActive">();
	}
	static class UIsActivationTimerActive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsActivationTimerActive>();
	}
};
static_assert(alignof(UIsActivationTimerActive) == 0x000008, "Wrong alignment on UIsActivationTimerActive");
static_assert(sizeof(UIsActivationTimerActive) == 0x000108, "Wrong size on UIsActivationTimerActive");

// Class DBDCompetence.IsActivationTimerActiveAndNotPaused
// 0x0020 (0x0110 - 0x00F0)
class UIsActivationTimerActiveAndNotPaused final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_F0[0x20];                                      // 0x00F0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsActivationTimerActiveAndNotPaused">();
	}
	static class UIsActivationTimerActiveAndNotPaused* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsActivationTimerActiveAndNotPaused>();
	}
};
static_assert(alignof(UIsActivationTimerActiveAndNotPaused) == 0x000008, "Wrong alignment on UIsActivationTimerActiveAndNotPaused");
static_assert(sizeof(UIsActivationTimerActiveAndNotPaused) == 0x000110, "Wrong size on UIsActivationTimerActiveAndNotPaused");

// Class DBDCompetence.IsBestProveThyselfEffectInRange
// 0x0028 (0x0118 - 0x00F0)
class UIsBestProveThyselfEffectInRange final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_F0[0x28];                                      // 0x00F0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInRangeChanged(const bool inRange, class UProveThyselfEffect* ProveThyselfEffect);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsBestProveThyselfEffectInRange">();
	}
	static class UIsBestProveThyselfEffectInRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsBestProveThyselfEffectInRange>();
	}
};
static_assert(alignof(UIsBestProveThyselfEffectInRange) == 0x000008, "Wrong alignment on UIsBestProveThyselfEffectInRange");
static_assert(sizeof(UIsBestProveThyselfEffectInRange) == 0x000118, "Wrong size on UIsBestProveThyselfEffectInRange");

// Class DBDCompetence.IsChasingInjuredSurvivor
// 0x0000 (0x00F0 - 0x00F0)
class UIsChasingInjuredSurvivor final : public UEventDrivenModifierCondition
{
public:
	void OnChasedSurvivorDamageStateChanged(const EHealthState oldState, const EHealthState newState);
	void OnChaseEnd(class ADBDPlayer* chasedSurvivor, float chaseTime);
	void OnChaseStart(class ADBDPlayer* chasedSurvivor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsChasingInjuredSurvivor">();
	}
	static class UIsChasingInjuredSurvivor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsChasingInjuredSurvivor>();
	}
};
static_assert(alignof(UIsChasingInjuredSurvivor) == 0x000008, "Wrong alignment on UIsChasingInjuredSurvivor");
static_assert(sizeof(UIsChasingInjuredSurvivor) == 0x0000F0, "Wrong size on UIsChasingInjuredSurvivor");

// Class DBDCompetence.IsCooldownTimerDone
// 0x0018 (0x0108 - 0x00F0)
class UIsCooldownTimerDone final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_F0[0x18];                                      // 0x00F0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsCooldownTimerDone">();
	}
	static class UIsCooldownTimerDone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsCooldownTimerDone>();
	}
};
static_assert(alignof(UIsCooldownTimerDone) == 0x000008, "Wrong alignment on UIsCooldownTimerDone");
static_assert(sizeof(UIsCooldownTimerDone) == 0x000108, "Wrong size on UIsCooldownTimerDone");

// Class DBDCompetence.IsHighestLevelAndClosestOriginatingEffect
// 0x0028 (0x00F8 - 0x00D0)
class UIsHighestLevelAndClosestOriginatingEffect final : public UGameplayModifierCondition
{
public:
	TArray<class UStatusEffect*>                  _applicableEffects;                                // 0x00D0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x18];                                      // 0x00E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnStatusEffectAddedOrRemoved(class UStatusEffect* effect, bool Valid);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsHighestLevelAndClosestOriginatingEffect">();
	}
	static class UIsHighestLevelAndClosestOriginatingEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsHighestLevelAndClosestOriginatingEffect>();
	}
};
static_assert(alignof(UIsHighestLevelAndClosestOriginatingEffect) == 0x000008, "Wrong alignment on UIsHighestLevelAndClosestOriginatingEffect");
static_assert(sizeof(UIsHighestLevelAndClosestOriginatingEffect) == 0x0000F8, "Wrong size on UIsHighestLevelAndClosestOriginatingEffect");
static_assert(offsetof(UIsHighestLevelAndClosestOriginatingEffect, _applicableEffects) == 0x0000D0, "Member 'UIsHighestLevelAndClosestOriginatingEffect::_applicableEffects' has a wrong offset!");

// Class DBDCompetence.IsInRangeOfOriginatingPlayer
// 0x0028 (0x0120 - 0x00F8)
class UIsInRangeOfOriginatingPlayer final : public URangeBasedCondition
{
public:
	uint8                                         Pad_F8[0x28];                                      // 0x00F8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInRangeChanged(const bool inRange);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsInRangeOfOriginatingPlayer">();
	}
	static class UIsInRangeOfOriginatingPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsInRangeOfOriginatingPlayer>();
	}
};
static_assert(alignof(UIsInRangeOfOriginatingPlayer) == 0x000008, "Wrong alignment on UIsInRangeOfOriginatingPlayer");
static_assert(sizeof(UIsInRangeOfOriginatingPlayer) == 0x000120, "Wrong size on UIsInRangeOfOriginatingPlayer");

// Class DBDCompetence.IsMovingFasterThanBaseMaxSpeed
// 0x0048 (0x0138 - 0x00F0)
class UIsMovingFasterThanBaseMaxSpeed final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_F0[0x48];                                      // 0x00F0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsMovingFasterThanBaseMaxSpeed">();
	}
	static class UIsMovingFasterThanBaseMaxSpeed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsMovingFasterThanBaseMaxSpeed>();
	}
};
static_assert(alignof(UIsMovingFasterThanBaseMaxSpeed) == 0x000008, "Wrong alignment on UIsMovingFasterThanBaseMaxSpeed");
static_assert(sizeof(UIsMovingFasterThanBaseMaxSpeed) == 0x000138, "Wrong size on UIsMovingFasterThanBaseMaxSpeed");

// Class DBDCompetence.IsOriginatingEffectCooldownTimerActive
// 0x0000 (0x0108 - 0x0108)
class UIsOriginatingEffectCooldownTimerActive final : public UBaseIsCooldownTimerActive
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsOriginatingEffectCooldownTimerActive">();
	}
	static class UIsOriginatingEffectCooldownTimerActive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsOriginatingEffectCooldownTimerActive>();
	}
};
static_assert(alignof(UIsOriginatingEffectCooldownTimerActive) == 0x000008, "Wrong alignment on UIsOriginatingEffectCooldownTimerActive");
static_assert(sizeof(UIsOriginatingEffectCooldownTimerActive) == 0x000108, "Wrong size on UIsOriginatingEffectCooldownTimerActive");

// Class DBDCompetence.IsOriginatingPerkUsableCondition
// 0x0000 (0x00F8 - 0x00F8)
class UIsOriginatingPerkUsableCondition final : public UBaseIsPerkUsableCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsOriginatingPerkUsableCondition">();
	}
	static class UIsOriginatingPerkUsableCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsOriginatingPerkUsableCondition>();
	}
};
static_assert(alignof(UIsOriginatingPerkUsableCondition) == 0x000008, "Wrong alignment on UIsOriginatingPerkUsableCondition");
static_assert(sizeof(UIsOriginatingPerkUsableCondition) == 0x0000F8, "Wrong size on UIsOriginatingPerkUsableCondition");

// Class DBDCompetence.IsOwningPlayerLastSurvivor
// 0x0008 (0x00F8 - 0x00F0)
class UIsOwningPlayerLastSurvivor final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_F0[0x8];                                       // 0x00F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsOwningPlayerLastSurvivor">();
	}
	static class UIsOwningPlayerLastSurvivor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsOwningPlayerLastSurvivor>();
	}
};
static_assert(alignof(UIsOwningPlayerLastSurvivor) == 0x000008, "Wrong alignment on UIsOwningPlayerLastSurvivor");
static_assert(sizeof(UIsOwningPlayerLastSurvivor) == 0x0000F8, "Wrong size on UIsOwningPlayerLastSurvivor");

// Class DBDCompetence.IsOwningSurvivorAuraRevealedToKiller
// 0x0000 (0x00D0 - 0x00D0)
class UIsOwningSurvivorAuraRevealedToKiller final : public UGameplayModifierCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsOwningSurvivorAuraRevealedToKiller">();
	}
	static class UIsOwningSurvivorAuraRevealedToKiller* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsOwningSurvivorAuraRevealedToKiller>();
	}
};
static_assert(alignof(UIsOwningSurvivorAuraRevealedToKiller) == 0x000008, "Wrong alignment on UIsOwningSurvivorAuraRevealedToKiller");
static_assert(sizeof(UIsOwningSurvivorAuraRevealedToKiller) == 0x0000D0, "Wrong size on UIsOwningSurvivorAuraRevealedToKiller");

// Class DBDCompetence.IsPawnType
// 0x0008 (0x00F8 - 0x00F0)
class UIsPawnType final : public UEventDrivenModifierCondition
{
public:
	EPawnType                                     _pawnType;                                         // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsPawnType">();
	}
	static class UIsPawnType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsPawnType>();
	}
};
static_assert(alignof(UIsPawnType) == 0x000008, "Wrong alignment on UIsPawnType");
static_assert(sizeof(UIsPawnType) == 0x0000F8, "Wrong size on UIsPawnType");
static_assert(offsetof(UIsPawnType, _pawnType) == 0x0000F0, "Member 'UIsPawnType::_pawnType' has a wrong offset!");

// Class DBDCompetence.IsPerkUsableCondition
// 0x0000 (0x00F8 - 0x00F8)
class UIsPerkUsableCondition final : public UBaseIsPerkUsableCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsPerkUsableCondition">();
	}
	static class UIsPerkUsableCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsPerkUsableCondition>();
	}
};
static_assert(alignof(UIsPerkUsableCondition) == 0x000008, "Wrong alignment on UIsPerkUsableCondition");
static_assert(sizeof(UIsPerkUsableCondition) == 0x0000F8, "Wrong size on UIsPerkUsableCondition");

// Class DBDCompetence.IsPlayerLookingAtKillerCondition
// 0x0018 (0x0108 - 0x00F0)
class UIsPlayerLookingAtKillerCondition final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_F0[0x10];                                      // 0x00F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _precisionAngleDegrees;                            // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isLookingTowards;                                 // 0x0104(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_105[0x3];                                      // 0x0105(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPawnControllerChanged(class APawn* Pawn, class AController* Controller);
	void OnRep_IsLookingTowards(const bool IsLookingTowards);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsPlayerLookingAtKillerCondition">();
	}
	static class UIsPlayerLookingAtKillerCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsPlayerLookingAtKillerCondition>();
	}
};
static_assert(alignof(UIsPlayerLookingAtKillerCondition) == 0x000008, "Wrong alignment on UIsPlayerLookingAtKillerCondition");
static_assert(sizeof(UIsPlayerLookingAtKillerCondition) == 0x000108, "Wrong size on UIsPlayerLookingAtKillerCondition");
static_assert(offsetof(UIsPlayerLookingAtKillerCondition, _precisionAngleDegrees) == 0x000100, "Member 'UIsPlayerLookingAtKillerCondition::_precisionAngleDegrees' has a wrong offset!");
static_assert(offsetof(UIsPlayerLookingAtKillerCondition, _isLookingTowards) == 0x000104, "Member 'UIsPlayerLookingAtKillerCondition::_isLookingTowards' has a wrong offset!");

// Class DBDCompetence.IsPlayerPerfInteractionWithNoItem
// 0x0040 (0x0160 - 0x0120)
class UIsPlayerPerfInteractionWithNoItem final : public UBaseIsPlayerPerformingInteraction
{
public:
	uint8                                         Pad_120[0x10];                                     // 0x0120(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _useItemInteractionSemantics;                      // 0x0130(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_150[0x8];                                      // 0x0150(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ELoadoutItemType                              _itemType;                                         // 0x0158(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCollectableChargeStateChange(bool Empty);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsPlayerPerfInteractionWithNoItem">();
	}
	static class UIsPlayerPerfInteractionWithNoItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsPlayerPerfInteractionWithNoItem>();
	}
};
static_assert(alignof(UIsPlayerPerfInteractionWithNoItem) == 0x000008, "Wrong alignment on UIsPlayerPerfInteractionWithNoItem");
static_assert(sizeof(UIsPlayerPerfInteractionWithNoItem) == 0x000160, "Wrong size on UIsPlayerPerfInteractionWithNoItem");
static_assert(offsetof(UIsPlayerPerfInteractionWithNoItem, _useItemInteractionSemantics) == 0x000130, "Member 'UIsPlayerPerfInteractionWithNoItem::_useItemInteractionSemantics' has a wrong offset!");
static_assert(offsetof(UIsPlayerPerfInteractionWithNoItem, _itemType) == 0x000158, "Member 'UIsPlayerPerfInteractionWithNoItem::_itemType' has a wrong offset!");

// Class DBDCompetence.IsPlayerPerformingItemInteraction
// 0x0020 (0x0140 - 0x0120)
class UIsPlayerPerformingItemInteraction final : public UBaseIsPlayerPerformingInteraction
{
public:
	uint8                                         Pad_120[0x20];                                     // 0x0120(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCollectableChargeStateChange(bool Empty);
	void OnCollectableDropped(EItemDropType dropType);
	void OnCollectablePickedUp(class ADBDPlayer* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsPlayerPerformingItemInteraction">();
	}
	static class UIsPlayerPerformingItemInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsPlayerPerformingItemInteraction>();
	}
};
static_assert(alignof(UIsPlayerPerformingItemInteraction) == 0x000008, "Wrong alignment on UIsPlayerPerformingItemInteraction");
static_assert(sizeof(UIsPlayerPerformingItemInteraction) == 0x000140, "Wrong size on UIsPlayerPerformingItemInteraction");

// Class DBDCompetence.IsPlayerRunningAndMoving
// 0x0000 (0x00F0 - 0x00F0)
class UIsPlayerRunningAndMoving final : public UEventDrivenModifierCondition
{
public:
	void OnRunningAndMovingChanged(bool isRunningAndMoving);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsPlayerRunningAndMoving">();
	}
	static class UIsPlayerRunningAndMoving* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsPlayerRunningAndMoving>();
	}
};
static_assert(alignof(UIsPlayerRunningAndMoving) == 0x000008, "Wrong alignment on UIsPlayerRunningAndMoving");
static_assert(sizeof(UIsPlayerRunningAndMoving) == 0x0000F0, "Wrong size on UIsPlayerRunningAndMoving");

// Class DBDCompetence.KillerConditionalSpeedCurveEffect
// 0x0008 (0x03A0 - 0x0398)
class UKillerConditionalSpeedCurveEffect final : public UStatusEffect
{
public:
	class UCurveFloat*                            _speedCurve;                                       // 0x0398(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerConditionalSpeedCurveEffect">();
	}
	static class UKillerConditionalSpeedCurveEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerConditionalSpeedCurveEffect>();
	}
};
static_assert(alignof(UKillerConditionalSpeedCurveEffect) == 0x000008, "Wrong alignment on UKillerConditionalSpeedCurveEffect");
static_assert(sizeof(UKillerConditionalSpeedCurveEffect) == 0x0003A0, "Wrong size on UKillerConditionalSpeedCurveEffect");
static_assert(offsetof(UKillerConditionalSpeedCurveEffect, _speedCurve) == 0x000398, "Member 'UKillerConditionalSpeedCurveEffect::_speedCurve' has a wrong offset!");

// Class DBDCompetence.KillerIsLowOnAmmo
// 0x0018 (0x0108 - 0x00F0)
class UKillerIsLowOnAmmo final : public UEventDrivenModifierCondition
{
public:
	int32                                         _ammoThreshold;                                    // 0x00F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F4[0x14];                                      // 0x00F4(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerIsLowOnAmmo">();
	}
	static class UKillerIsLowOnAmmo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerIsLowOnAmmo>();
	}
};
static_assert(alignof(UKillerIsLowOnAmmo) == 0x000008, "Wrong alignment on UKillerIsLowOnAmmo");
static_assert(sizeof(UKillerIsLowOnAmmo) == 0x000108, "Wrong size on UKillerIsLowOnAmmo");
static_assert(offsetof(UKillerIsLowOnAmmo, _ammoThreshold) == 0x0000F0, "Member 'UKillerIsLowOnAmmo::_ammoThreshold' has a wrong offset!");

// Class DBDCompetence.KillerSubjectProvider
// 0x0008 (0x0050 - 0x0048)
class UKillerSubjectProvider final : public UModifierSubjectProvider
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterWhenKillerSet(class AKiller* Killer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerSubjectProvider">();
	}
	static class UKillerSubjectProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerSubjectProvider>();
	}
};
static_assert(alignof(UKillerSubjectProvider) == 0x000008, "Wrong alignment on UKillerSubjectProvider");
static_assert(sizeof(UKillerSubjectProvider) == 0x000050, "Wrong size on UKillerSubjectProvider");

// Class DBDCompetence.KindredPerk
// 0x0030 (0x0490 - 0x0460)
class UKindredPerk final : public UPerk
{
public:
	TArray<float>                                 _killerAuraRevealRange;                            // 0x0460(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _kindredRevealKillerOther;                         // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _kindredRevealKillerOwner;                         // 0x0478(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _kindredRevealSurvivors;                           // 0x0480(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_488[0x8];                                      // 0x0488(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetKillerAuraRevealRangeAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KindredPerk">();
	}
	static class UKindredPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKindredPerk>();
	}
};
static_assert(alignof(UKindredPerk) == 0x000008, "Wrong alignment on UKindredPerk");
static_assert(sizeof(UKindredPerk) == 0x000490, "Wrong size on UKindredPerk");
static_assert(offsetof(UKindredPerk, _killerAuraRevealRange) == 0x000460, "Member 'UKindredPerk::_killerAuraRevealRange' has a wrong offset!");
static_assert(offsetof(UKindredPerk, _kindredRevealKillerOther) == 0x000470, "Member 'UKindredPerk::_kindredRevealKillerOther' has a wrong offset!");
static_assert(offsetof(UKindredPerk, _kindredRevealKillerOwner) == 0x000478, "Member 'UKindredPerk::_kindredRevealKillerOwner' has a wrong offset!");
static_assert(offsetof(UKindredPerk, _kindredRevealSurvivors) == 0x000480, "Member 'UKindredPerk::_kindredRevealSurvivors' has a wrong offset!");

// Class DBDCompetence.Leader
// 0x0018 (0x0478 - 0x0460)
class ULeader final : public UPerk
{
public:
	float                                         _actionSpeedModifier[0x3];                         // 0x0460(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_46C[0x4];                                      // 0x046C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ULeaderEffect>              _leaderStatusEffect;                               // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Leader">();
	}
	static class ULeader* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeader>();
	}
};
static_assert(alignof(ULeader) == 0x000008, "Wrong alignment on ULeader");
static_assert(sizeof(ULeader) == 0x000478, "Wrong size on ULeader");
static_assert(offsetof(ULeader, _actionSpeedModifier) == 0x000460, "Member 'ULeader::_actionSpeedModifier' has a wrong offset!");
static_assert(offsetof(ULeader, _leaderStatusEffect) == 0x000470, "Member 'ULeader::_leaderStatusEffect' has a wrong offset!");

// Class DBDCompetence.LeaderEffect
// 0x0000 (0x0398 - 0x0398)
class ULeaderEffect final : public UStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderEffect">();
	}
	static class ULeaderEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderEffect>();
	}
};
static_assert(alignof(ULeaderEffect) == 0x000008, "Wrong alignment on ULeaderEffect");
static_assert(sizeof(ULeaderEffect) == 0x000398, "Wrong size on ULeaderEffect");

// Class DBDCompetence.LingeringBlessedStatusEffect
// 0x0028 (0x03D0 - 0x03A8)
class ULingeringBlessedStatusEffect final : public UBlessedStatusEffect
{
public:
	uint8                                         Pad_3A8[0x4];                                      // 0x03A8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _lingerDuration;                                   // 0x03AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B0[0x20];                                     // 0x03B0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnInRangeChanged(const bool inRange);
	void SetLingerDuration(const float lingerDuration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LingeringBlessedStatusEffect">();
	}
	static class ULingeringBlessedStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULingeringBlessedStatusEffect>();
	}
};
static_assert(alignof(ULingeringBlessedStatusEffect) == 0x000008, "Wrong alignment on ULingeringBlessedStatusEffect");
static_assert(sizeof(ULingeringBlessedStatusEffect) == 0x0003D0, "Wrong size on ULingeringBlessedStatusEffect");
static_assert(offsetof(ULingeringBlessedStatusEffect, _lingerDuration) == 0x0003AC, "Member 'ULingeringBlessedStatusEffect::_lingerDuration' has a wrong offset!");

// Class DBDCompetence.LingeringBlindnessEffect
// 0x0060 (0x0408 - 0x03A8)
class ULingeringBlindnessEffect final : public UAdjustableCooldownStatusEffect
{
public:
	struct FGameplayTag                           startBlindnessEventTag;                            // 0x03A8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           endBlindnessEventTag;                              // 0x03B4(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           _state;                                            // 0x03C0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3CC[0x3C];                                     // 0x03CC(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LingeringBlindnessEffect">();
	}
	static class ULingeringBlindnessEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULingeringBlindnessEffect>();
	}
};
static_assert(alignof(ULingeringBlindnessEffect) == 0x000008, "Wrong alignment on ULingeringBlindnessEffect");
static_assert(sizeof(ULingeringBlindnessEffect) == 0x000408, "Wrong size on ULingeringBlindnessEffect");
static_assert(offsetof(ULingeringBlindnessEffect, startBlindnessEventTag) == 0x0003A8, "Member 'ULingeringBlindnessEffect::startBlindnessEventTag' has a wrong offset!");
static_assert(offsetof(ULingeringBlindnessEffect, endBlindnessEventTag) == 0x0003B4, "Member 'ULingeringBlindnessEffect::endBlindnessEventTag' has a wrong offset!");
static_assert(offsetof(ULingeringBlindnessEffect, _state) == 0x0003C0, "Member 'ULingeringBlindnessEffect::_state' has a wrong offset!");

// Class DBDCompetence.LingeringExhaustedEffect
// 0x0060 (0x0410 - 0x03B0)
class ULingeringExhaustedEffect final : public UExhaustedEffect
{
public:
	struct FGameplayTag                           startExhaustedEventTag;                            // 0x03B0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           endExhaustedEventTag;                              // 0x03BC(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           _state;                                            // 0x03C8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D4[0x3C];                                     // 0x03D4(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LingeringExhaustedEffect">();
	}
	static class ULingeringExhaustedEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULingeringExhaustedEffect>();
	}
};
static_assert(alignof(ULingeringExhaustedEffect) == 0x000008, "Wrong alignment on ULingeringExhaustedEffect");
static_assert(sizeof(ULingeringExhaustedEffect) == 0x000410, "Wrong size on ULingeringExhaustedEffect");
static_assert(offsetof(ULingeringExhaustedEffect, startExhaustedEventTag) == 0x0003B0, "Member 'ULingeringExhaustedEffect::startExhaustedEventTag' has a wrong offset!");
static_assert(offsetof(ULingeringExhaustedEffect, endExhaustedEventTag) == 0x0003BC, "Member 'ULingeringExhaustedEffect::endExhaustedEventTag' has a wrong offset!");
static_assert(offsetof(ULingeringExhaustedEffect, _state) == 0x0003C8, "Member 'ULingeringExhaustedEffect::_state' has a wrong offset!");

// Class DBDCompetence.LocallyObservedPlayerSubjectProvider
// 0x0000 (0x0048 - 0x0048)
class ULocallyObservedPlayerSubjectProvider final : public UModifierSubjectProvider
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocallyObservedPlayerSubjectProvider">();
	}
	static class ULocallyObservedPlayerSubjectProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocallyObservedPlayerSubjectProvider>();
	}
};
static_assert(alignof(ULocallyObservedPlayerSubjectProvider) == 0x000008, "Wrong alignment on ULocallyObservedPlayerSubjectProvider");
static_assert(sizeof(ULocallyObservedPlayerSubjectProvider) == 0x000048, "Wrong size on ULocallyObservedPlayerSubjectProvider");

// Class DBDCompetence.LuckyBreak
// 0x0058 (0x04B8 - 0x0460)
class ULuckyBreak final : public UPerk
{
public:
	float                                         _maxActivationTime[0x3];                           // 0x0460(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minActivationTime;                                // 0x046C(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _healingTimeToActivationTimeRatio;                 // 0x0470(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isRecharging;                                     // 0x0474(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_475[0x3];                                      // 0x0475(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpeedBasedNetSyncedValue              _activationTime;                                   // 0x0478(0x0038)(Net, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B0[0x8];                                      // 0x04B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivationTimerEnded();
	void Authority_OnDamageStateChanged(EHealthState oldDamageState, EHealthState currentDamageState);
	void Authority_TryActivatePerk();

	float GetHealingTimeToActivationTimeRatio() const;
	float GetMaxActivationTimeAtLevel() const;
	float GetMinActivationTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LuckyBreak">();
	}
	static class ULuckyBreak* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULuckyBreak>();
	}
};
static_assert(alignof(ULuckyBreak) == 0x000008, "Wrong alignment on ULuckyBreak");
static_assert(sizeof(ULuckyBreak) == 0x0004B8, "Wrong size on ULuckyBreak");
static_assert(offsetof(ULuckyBreak, _maxActivationTime) == 0x000460, "Member 'ULuckyBreak::_maxActivationTime' has a wrong offset!");
static_assert(offsetof(ULuckyBreak, _minActivationTime) == 0x00046C, "Member 'ULuckyBreak::_minActivationTime' has a wrong offset!");
static_assert(offsetof(ULuckyBreak, _healingTimeToActivationTimeRatio) == 0x000470, "Member 'ULuckyBreak::_healingTimeToActivationTimeRatio' has a wrong offset!");
static_assert(offsetof(ULuckyBreak, _isRecharging) == 0x000474, "Member 'ULuckyBreak::_isRecharging' has a wrong offset!");
static_assert(offsetof(ULuckyBreak, _activationTime) == 0x000478, "Member 'ULuckyBreak::_activationTime' has a wrong offset!");

// Class DBDCompetence.MakeYourChoice
// 0x0018 (0x0478 - 0x0460)
class UMakeYourChoice final : public UPerk
{
public:
	float                                         _minimumHookedSurvivorDistance;                    // 0x0460(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_464[0x4];                                      // 0x0464(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _exposedEffect;                                    // 0x0468(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_470[0x8];                                      // 0x0470(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnTriggerEffectVFX(const class ASurvivor* Player);
	void Multicast_TriggerEffectAppliedVFX(const class ASurvivor* Player);

	float GetMinimumHookedSurvivorDistance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MakeYourChoice">();
	}
	static class UMakeYourChoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMakeYourChoice>();
	}
};
static_assert(alignof(UMakeYourChoice) == 0x000008, "Wrong alignment on UMakeYourChoice");
static_assert(sizeof(UMakeYourChoice) == 0x000478, "Wrong size on UMakeYourChoice");
static_assert(offsetof(UMakeYourChoice, _minimumHookedSurvivorDistance) == 0x000460, "Member 'UMakeYourChoice::_minimumHookedSurvivorDistance' has a wrong offset!");
static_assert(offsetof(UMakeYourChoice, _exposedEffect) == 0x000468, "Member 'UMakeYourChoice::_exposedEffect' has a wrong offset!");

// Class DBDCompetence.MangledEffect
// 0x0008 (0x03B0 - 0x03A8)
class UMangledEffect final : public UAdjustableCooldownStatusEffect
{
public:
	bool                                          _removeEffectWhenFullyHealed;                      // 0x03A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A9[0x7];                                      // 0x03A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MangledEffect">();
	}
	static class UMangledEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMangledEffect>();
	}
};
static_assert(alignof(UMangledEffect) == 0x000008, "Wrong alignment on UMangledEffect");
static_assert(sizeof(UMangledEffect) == 0x0003B0, "Wrong size on UMangledEffect");
static_assert(offsetof(UMangledEffect, _removeEffectWhenFullyHealed) == 0x0003A8, "Member 'UMangledEffect::_removeEffectWhenFullyHealed' has a wrong offset!");

// Class DBDCompetence.ManifestationPerk
// 0x0000 (0x0460 - 0x0460)
class UManifestationPerk final : public UPerk
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ManifestationPerk">();
	}
	static class UManifestationPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UManifestationPerk>();
	}
};
static_assert(alignof(UManifestationPerk) == 0x000008, "Wrong alignment on UManifestationPerk");
static_assert(sizeof(UManifestationPerk) == 0x000460, "Wrong size on UManifestationPerk");

// Class DBDCompetence.MindBreaker
// 0x0028 (0x0488 - 0x0460)
class UMindBreaker final : public UPerk
{
public:
	float                                         _effectDurationAfterRepair[0x3];                   // 0x0460(0x0004)(Edit, EditFixedSize, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_46C[0x4];                                      // 0x046C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _blindessEffect;                                   // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _exhaustedEffect;                                  // 0x0478(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_480[0x8];                                      // 0x0480(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetEffectDurationAfterRepairAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MindBreaker">();
	}
	static class UMindBreaker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMindBreaker>();
	}
};
static_assert(alignof(UMindBreaker) == 0x000008, "Wrong alignment on UMindBreaker");
static_assert(sizeof(UMindBreaker) == 0x000488, "Wrong size on UMindBreaker");
static_assert(offsetof(UMindBreaker, _effectDurationAfterRepair) == 0x000460, "Member 'UMindBreaker::_effectDurationAfterRepair' has a wrong offset!");
static_assert(offsetof(UMindBreaker, _blindessEffect) == 0x000470, "Member 'UMindBreaker::_blindessEffect' has a wrong offset!");
static_assert(offsetof(UMindBreaker, _exhaustedEffect) == 0x000478, "Member 'UMindBreaker::_exhaustedEffect' has a wrong offset!");

// Class DBDCompetence.MonstrousShrine
// 0x0030 (0x0490 - 0x0460)
class UMonstrousShrine final : public UPerk
{
public:
	uint8                                         Pad_460[0x18];                                     // 0x0460(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _fasterDrainPercentage[0x3];                       // 0x0478(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_484[0x4];                                      // 0x0484(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _fasterDrainOnScourgeHookEffect;                   // 0x0488(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnSurvivorHookedOnScourgeHook(const struct FGameEventData& GameEventData);
	void Authority_OnSurvivorUnhookedOnScourgeHook(const struct FGameEventData& GameEventData);

	float GetFasterDrainPercentageAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonstrousShrine">();
	}
	static class UMonstrousShrine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonstrousShrine>();
	}
};
static_assert(alignof(UMonstrousShrine) == 0x000008, "Wrong alignment on UMonstrousShrine");
static_assert(sizeof(UMonstrousShrine) == 0x000490, "Wrong size on UMonstrousShrine");
static_assert(offsetof(UMonstrousShrine, _fasterDrainPercentage) == 0x000478, "Member 'UMonstrousShrine::_fasterDrainPercentage' has a wrong offset!");
static_assert(offsetof(UMonstrousShrine, _fasterDrainOnScourgeHookEffect) == 0x000488, "Member 'UMonstrousShrine::_fasterDrainOnScourgeHookEffect' has a wrong offset!");

// Class DBDCompetence.Nemesis
// 0x0038 (0x0498 - 0x0460)
class UNemesis final : public UPerk
{
public:
	uint8                                         Pad_460[0x8];                                      // 0x0460(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _revealToKillerTime[0x3];                          // 0x0468(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _obliviousTime[0x3];                               // 0x0474(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _timedObliviousEffectClass;                        // 0x0480(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _timedRevealStatusEffect;                          // 0x0488(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStatusEffect*                          _obliviousStatusEffect;                            // 0x0490(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Nemesis">();
	}
	static class UNemesis* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNemesis>();
	}
};
static_assert(alignof(UNemesis) == 0x000008, "Wrong alignment on UNemesis");
static_assert(sizeof(UNemesis) == 0x000498, "Wrong size on UNemesis");
static_assert(offsetof(UNemesis, _revealToKillerTime) == 0x000468, "Member 'UNemesis::_revealToKillerTime' has a wrong offset!");
static_assert(offsetof(UNemesis, _obliviousTime) == 0x000474, "Member 'UNemesis::_obliviousTime' has a wrong offset!");
static_assert(offsetof(UNemesis, _timedObliviousEffectClass) == 0x000480, "Member 'UNemesis::_timedObliviousEffectClass' has a wrong offset!");
static_assert(offsetof(UNemesis, _timedRevealStatusEffect) == 0x000488, "Member 'UNemesis::_timedRevealStatusEffect' has a wrong offset!");
static_assert(offsetof(UNemesis, _obliviousStatusEffect) == 0x000490, "Member 'UNemesis::_obliviousStatusEffect' has a wrong offset!");

// Class DBDCompetence.NoOneLeftBehind
// 0x0030 (0x0490 - 0x0460)
class UNoOneLeftBehind final : public UPerk
{
public:
	float                                         _unhookHasteSpeedAdditive;                         // 0x0460(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_464[0x4];                                      // 0x0464(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _modifyHealOtherSpeedEffect;                       // 0x0468(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _modifyUnhookOtherSpeedEffect;                     // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _modifyUnhookHasteSpeedEffectClass;                // 0x0478(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _actionSpeedModifierValuePerLevel[0x3];            // 0x0480(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48C[0x4];                                      // 0x048C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnExitGatePoweredApplicableChanged(class UGameplayModifierContainer* container, bool Active);

	float GetActionSpeedModifierValueAtLevel() const;
	float GetUnhookHasteSpeedAdditive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NoOneLeftBehind">();
	}
	static class UNoOneLeftBehind* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNoOneLeftBehind>();
	}
};
static_assert(alignof(UNoOneLeftBehind) == 0x000008, "Wrong alignment on UNoOneLeftBehind");
static_assert(sizeof(UNoOneLeftBehind) == 0x000490, "Wrong size on UNoOneLeftBehind");
static_assert(offsetof(UNoOneLeftBehind, _unhookHasteSpeedAdditive) == 0x000460, "Member 'UNoOneLeftBehind::_unhookHasteSpeedAdditive' has a wrong offset!");
static_assert(offsetof(UNoOneLeftBehind, _modifyHealOtherSpeedEffect) == 0x000468, "Member 'UNoOneLeftBehind::_modifyHealOtherSpeedEffect' has a wrong offset!");
static_assert(offsetof(UNoOneLeftBehind, _modifyUnhookOtherSpeedEffect) == 0x000470, "Member 'UNoOneLeftBehind::_modifyUnhookOtherSpeedEffect' has a wrong offset!");
static_assert(offsetof(UNoOneLeftBehind, _modifyUnhookHasteSpeedEffectClass) == 0x000478, "Member 'UNoOneLeftBehind::_modifyUnhookHasteSpeedEffectClass' has a wrong offset!");
static_assert(offsetof(UNoOneLeftBehind, _actionSpeedModifierValuePerLevel) == 0x000480, "Member 'UNoOneLeftBehind::_actionSpeedModifierValuePerLevel' has a wrong offset!");

// Class DBDCompetence.NurseCallingEffect
// 0x0000 (0x0398 - 0x0398)
class UNurseCallingEffect final : public UStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NurseCallingEffect">();
	}
	static class UNurseCallingEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNurseCallingEffect>();
	}
};
static_assert(alignof(UNurseCallingEffect) == 0x000008, "Wrong alignment on UNurseCallingEffect");
static_assert(sizeof(UNurseCallingEffect) == 0x000398, "Wrong size on UNurseCallingEffect");

// Class DBDCompetence.ObsessionTargetSubjectProvider
// 0x0010 (0x0058 - 0x0048)
class UObsessionTargetSubjectProvider final : public UModifierSubjectProvider
{
public:
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObsessionTargetSubjectProvider">();
	}
	static class UObsessionTargetSubjectProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObsessionTargetSubjectProvider>();
	}
};
static_assert(alignof(UObsessionTargetSubjectProvider) == 0x000008, "Wrong alignment on UObsessionTargetSubjectProvider");
static_assert(sizeof(UObsessionTargetSubjectProvider) == 0x000058, "Wrong size on UObsessionTargetSubjectProvider");

// Class DBDCompetence.OnEventSetTimerAddon
// 0x0008 (0x0318 - 0x0310)
class UOnEventSetTimerAddon final : public UOnEventBaseAddon
{
public:
	float                                         _addonEffectTime;                                  // 0x0310(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_314[0x4];                                      // 0x0314(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnEventSetTimerAddon">();
	}
	static class UOnEventSetTimerAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnEventSetTimerAddon>();
	}
};
static_assert(alignof(UOnEventSetTimerAddon) == 0x000008, "Wrong alignment on UOnEventSetTimerAddon");
static_assert(sizeof(UOnEventSetTimerAddon) == 0x000318, "Wrong size on UOnEventSetTimerAddon");
static_assert(offsetof(UOnEventSetTimerAddon, _addonEffectTime) == 0x000310, "Member 'UOnEventSetTimerAddon::_addonEffectTime' has a wrong offset!");

// Class DBDCompetence.OnGameEventActionInterface
// 0x0000 (0x0000 - 0x0000)
class IOnGameEventActionInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnGameEventActionInterface">();
	}
	static class IOnGameEventActionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOnGameEventActionInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOnGameEventActionInterface) == 0x000001, "Wrong alignment on IOnGameEventActionInterface");
static_assert(sizeof(IOnGameEventActionInterface) == 0x000001, "Wrong size on IOnGameEventActionInterface");

// Class DBDCompetence.OnGameEventTriggered
// 0x0038 (0x0128 - 0x00F0)
class UOnGameEventTriggered final : public UEventDrivenModifierCondition
{
public:
	struct FGameplayTag                           eventTag;                                          // 0x00F0(0x000C)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FC[0x2C];                                      // 0x00FC(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnGameEventTriggered">();
	}
	static class UOnGameEventTriggered* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnGameEventTriggered>();
	}
};
static_assert(alignof(UOnGameEventTriggered) == 0x000008, "Wrong alignment on UOnGameEventTriggered");
static_assert(sizeof(UOnGameEventTriggered) == 0x000128, "Wrong size on UOnGameEventTriggered");
static_assert(offsetof(UOnGameEventTriggered, eventTag) == 0x0000F0, "Member 'UOnGameEventTriggered::eventTag' has a wrong offset!");

// Class DBDCompetence.OriginatingEffectIsApplicable
// 0x0008 (0x00F8 - 0x00F0)
class UOriginatingEffectIsApplicable final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_F0[0x8];                                       // 0x00F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OriginatingEffectIsApplicable">();
	}
	static class UOriginatingEffectIsApplicable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOriginatingEffectIsApplicable>();
	}
};
static_assert(alignof(UOriginatingEffectIsApplicable) == 0x000008, "Wrong alignment on UOriginatingEffectIsApplicable");
static_assert(sizeof(UOriginatingEffectIsApplicable) == 0x0000F8, "Wrong size on UOriginatingEffectIsApplicable");

// Class DBDCompetence.OriginatingPlayerHasLineOfSight
// 0x0010 (0x0100 - 0x00F0)
class UOriginatingPlayerHasLineOfSight final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_F0[0x8];                                       // 0x00F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _inLineOfSight;                                    // 0x00F8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_InLineOfSight();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OriginatingPlayerHasLineOfSight">();
	}
	static class UOriginatingPlayerHasLineOfSight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOriginatingPlayerHasLineOfSight>();
	}
};
static_assert(alignof(UOriginatingPlayerHasLineOfSight) == 0x000008, "Wrong alignment on UOriginatingPlayerHasLineOfSight");
static_assert(sizeof(UOriginatingPlayerHasLineOfSight) == 0x000100, "Wrong size on UOriginatingPlayerHasLineOfSight");
static_assert(offsetof(UOriginatingPlayerHasLineOfSight, _inLineOfSight) == 0x0000F8, "Member 'UOriginatingPlayerHasLineOfSight::_inLineOfSight' has a wrong offset!");

// Class DBDCompetence.OwningModifierIsApplicable
// 0x0000 (0x00F0 - 0x00F0)
class UOwningModifierIsApplicable final : public UEventDrivenModifierCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OwningModifierIsApplicable">();
	}
	static class UOwningModifierIsApplicable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOwningModifierIsApplicable>();
	}
};
static_assert(alignof(UOwningModifierIsApplicable) == 0x000008, "Wrong alignment on UOwningModifierIsApplicable");
static_assert(sizeof(UOwningModifierIsApplicable) == 0x0000F0, "Wrong size on UOwningModifierIsApplicable");

// Class DBDCompetence.OwningPlayerHasStatusEffectOfClass
// 0x0030 (0x0120 - 0x00F0)
class UOwningPlayerHasStatusEffectOfClass : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_F0[0x18];                                      // 0x00F0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isConditionMet;                                   // 0x0108(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_109[0x17];                                     // 0x0109(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_IsConditionMet();
	void SetClassTypeToMatch(TSubclassOf<class UStatusEffect> classType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OwningPlayerHasStatusEffectOfClass">();
	}
	static class UOwningPlayerHasStatusEffectOfClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOwningPlayerHasStatusEffectOfClass>();
	}
};
static_assert(alignof(UOwningPlayerHasStatusEffectOfClass) == 0x000008, "Wrong alignment on UOwningPlayerHasStatusEffectOfClass");
static_assert(sizeof(UOwningPlayerHasStatusEffectOfClass) == 0x000120, "Wrong size on UOwningPlayerHasStatusEffectOfClass");
static_assert(offsetof(UOwningPlayerHasStatusEffectOfClass, _isConditionMet) == 0x000108, "Member 'UOwningPlayerHasStatusEffectOfClass::_isConditionMet' has a wrong offset!");

// Class DBDCompetence.OwningPlayerHasApplicableStatusEffectOfClass
// 0x0000 (0x0120 - 0x0120)
class UOwningPlayerHasApplicableStatusEffectOfClass final : public UOwningPlayerHasStatusEffectOfClass
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OwningPlayerHasApplicableStatusEffectOfClass">();
	}
	static class UOwningPlayerHasApplicableStatusEffectOfClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOwningPlayerHasApplicableStatusEffectOfClass>();
	}
};
static_assert(alignof(UOwningPlayerHasApplicableStatusEffectOfClass) == 0x000008, "Wrong alignment on UOwningPlayerHasApplicableStatusEffectOfClass");
static_assert(sizeof(UOwningPlayerHasApplicableStatusEffectOfClass) == 0x000120, "Wrong size on UOwningPlayerHasApplicableStatusEffectOfClass");

// Class DBDCompetence.OwningPlayerInBoonBlessingRange
// 0x0008 (0x0110 - 0x0108)
class UOwningPlayerInBoonBlessingRange final : public UAnyActorPairQueryRangeIsTrue
{
public:
	class ATotem*                                 _boundTotem;                                       // 0x0108(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OwningPlayerInBoonBlessingRange">();
	}
	static class UOwningPlayerInBoonBlessingRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOwningPlayerInBoonBlessingRange>();
	}
};
static_assert(alignof(UOwningPlayerInBoonBlessingRange) == 0x000008, "Wrong alignment on UOwningPlayerInBoonBlessingRange");
static_assert(sizeof(UOwningPlayerInBoonBlessingRange) == 0x000110, "Wrong size on UOwningPlayerInBoonBlessingRange");
static_assert(offsetof(UOwningPlayerInBoonBlessingRange, _boundTotem) == 0x000108, "Member 'UOwningPlayerInBoonBlessingRange::_boundTotem' has a wrong offset!");

// Class DBDCompetence.OwningPlayerInDullTotemRange
// 0x0000 (0x0128 - 0x0128)
class UOwningPlayerInDullTotemRange final : public UOwningPlayerInTotemRange
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OwningPlayerInDullTotemRange">();
	}
	static class UOwningPlayerInDullTotemRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOwningPlayerInDullTotemRange>();
	}
};
static_assert(alignof(UOwningPlayerInDullTotemRange) == 0x000008, "Wrong alignment on UOwningPlayerInDullTotemRange");
static_assert(sizeof(UOwningPlayerInDullTotemRange) == 0x000128, "Wrong size on UOwningPlayerInDullTotemRange");

// Class DBDCompetence.PerkTierValueStrategy
// 0x0018 (0x00A8 - 0x0090)
class UPerkTierValueStrategy final : public UFloatValueStrategy
{
public:
	class UFloatValueStrategy*                    _value[0x3];                                       // 0x0090(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkTierValueStrategy">();
	}
	static class UPerkTierValueStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerkTierValueStrategy>();
	}
};
static_assert(alignof(UPerkTierValueStrategy) == 0x000008, "Wrong alignment on UPerkTierValueStrategy");
static_assert(sizeof(UPerkTierValueStrategy) == 0x0000A8, "Wrong size on UPerkTierValueStrategy");
static_assert(offsetof(UPerkTierValueStrategy, _value) == 0x000090, "Member 'UPerkTierValueStrategy::_value' has a wrong offset!");

// Class DBDCompetence.PerkWrapperSkill
// 0x0008 (0x03A8 - 0x03A0)
class UPerkWrapperSkill final : public UGameplayModifierContainerWrapperSkill
{
public:
	int32                                         _perkLevel;                                        // 0x03A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A4[0x4];                                      // 0x03A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkWrapperSkill">();
	}
	static class UPerkWrapperSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerkWrapperSkill>();
	}
};
static_assert(alignof(UPerkWrapperSkill) == 0x000008, "Wrong alignment on UPerkWrapperSkill");
static_assert(sizeof(UPerkWrapperSkill) == 0x0003A8, "Wrong size on UPerkWrapperSkill");
static_assert(offsetof(UPerkWrapperSkill, _perkLevel) == 0x0003A0, "Member 'UPerkWrapperSkill::_perkLevel' has a wrong offset!");

// Class DBDCompetence.PharmacyPerk
// 0x0018 (0x0478 - 0x0460)
class UPharmacyPerk final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _pharmacyEffectClass;                              // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _searchSpeeds[0x3];                                // 0x0468(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_474[0x4];                                      // 0x0474(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetSearchSpeedAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PharmacyPerk">();
	}
	static class UPharmacyPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPharmacyPerk>();
	}
};
static_assert(alignof(UPharmacyPerk) == 0x000008, "Wrong alignment on UPharmacyPerk");
static_assert(sizeof(UPharmacyPerk) == 0x000478, "Wrong size on UPharmacyPerk");
static_assert(offsetof(UPharmacyPerk, _pharmacyEffectClass) == 0x000460, "Member 'UPharmacyPerk::_pharmacyEffectClass' has a wrong offset!");
static_assert(offsetof(UPharmacyPerk, _searchSpeeds) == 0x000468, "Member 'UPharmacyPerk::_searchSpeeds' has a wrong offset!");

// Class DBDCompetence.PlayerIsInExitArea
// 0x0000 (0x00F0 - 0x00F0)
class UPlayerIsInExitArea final : public UEventDrivenModifierCondition
{
public:
	void PlayerEnterExitArea();
	void PlayerExitExitArea();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerIsInExitArea">();
	}
	static class UPlayerIsInExitArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerIsInExitArea>();
	}
};
static_assert(alignof(UPlayerIsInExitArea) == 0x000008, "Wrong alignment on UPlayerIsInExitArea");
static_assert(sizeof(UPlayerIsInExitArea) == 0x0000F0, "Wrong size on UPlayerIsInExitArea");

// Class DBDCompetence.PlayWithYourFood
// 0x0028 (0x0488 - 0x0460)
class UPlayWithYourFood final : public UPerk
{
public:
	float                                         _movementSpeedPercentBuff[0x3];                    // 0x0460(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_46C[0x4];                                      // 0x046C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   _basicAndSpecialAttackTags;                        // 0x0470(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _chargeGainedCooldown;                             // 0x0480(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_484[0x4];                                      // 0x0484(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnChaseEnded(class ADBDPlayer* Player, float chaseTime);

	float GetChargeGainedCooldown() const;
	float GetMovementSpeedPercentBuffAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayWithYourFood">();
	}
	static class UPlayWithYourFood* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayWithYourFood>();
	}
};
static_assert(alignof(UPlayWithYourFood) == 0x000008, "Wrong alignment on UPlayWithYourFood");
static_assert(sizeof(UPlayWithYourFood) == 0x000488, "Wrong size on UPlayWithYourFood");
static_assert(offsetof(UPlayWithYourFood, _movementSpeedPercentBuff) == 0x000460, "Member 'UPlayWithYourFood::_movementSpeedPercentBuff' has a wrong offset!");
static_assert(offsetof(UPlayWithYourFood, _basicAndSpecialAttackTags) == 0x000470, "Member 'UPlayWithYourFood::_basicAndSpecialAttackTags' has a wrong offset!");
static_assert(offsetof(UPlayWithYourFood, _chargeGainedCooldown) == 0x000480, "Member 'UPlayWithYourFood::_chargeGainedCooldown' has a wrong offset!");

// Class DBDCompetence.Poised
// 0x0050 (0x04B0 - 0x0460)
class UPoised final : public UPerk
{
public:
	float                                         _suppressFootstepsTime[0x3];                       // 0x0460(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _revealKillerAuraTime[0x3];                        // 0x046C(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _suppressFootstepsStatusEffectClass;               // 0x0478(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _revealKillerStatusEffectClass;                    // 0x0480(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_488[0x18];                                     // 0x0488(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AGenerator>>      _authority_generatorsWorkedOn;                     // 0x04A0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	float GetRevealKillerAuraDuration() const;
	float GetSuppressFootstepsDuration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Poised">();
	}
	static class UPoised* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPoised>();
	}
};
static_assert(alignof(UPoised) == 0x000008, "Wrong alignment on UPoised");
static_assert(sizeof(UPoised) == 0x0004B0, "Wrong size on UPoised");
static_assert(offsetof(UPoised, _suppressFootstepsTime) == 0x000460, "Member 'UPoised::_suppressFootstepsTime' has a wrong offset!");
static_assert(offsetof(UPoised, _revealKillerAuraTime) == 0x00046C, "Member 'UPoised::_revealKillerAuraTime' has a wrong offset!");
static_assert(offsetof(UPoised, _suppressFootstepsStatusEffectClass) == 0x000478, "Member 'UPoised::_suppressFootstepsStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UPoised, _revealKillerStatusEffectClass) == 0x000480, "Member 'UPoised::_revealKillerStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UPoised, _authority_generatorsWorkedOn) == 0x0004A0, "Member 'UPoised::_authority_generatorsWorkedOn' has a wrong offset!");

// Class DBDCompetence.Premonition
// 0x0038 (0x0498 - 0x0460)
class UPremonition final : public UPerk
{
public:
	float                                         _perkFrequency[0x3];                               // 0x0460(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _perkEffectRange;                                  // 0x046C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_470[0x28];                                     // 0x0470(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnPerkActivate();
	void Multicast_OnPerkActivate();

	float GetPerkEffectRange() const;
	float GetPerkFrequencyAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Premonition">();
	}
	static class UPremonition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPremonition>();
	}
};
static_assert(alignof(UPremonition) == 0x000008, "Wrong alignment on UPremonition");
static_assert(sizeof(UPremonition) == 0x000498, "Wrong size on UPremonition");
static_assert(offsetof(UPremonition, _perkFrequency) == 0x000460, "Member 'UPremonition::_perkFrequency' has a wrong offset!");
static_assert(offsetof(UPremonition, _perkEffectRange) == 0x00046C, "Member 'UPremonition::_perkEffectRange' has a wrong offset!");

// Class DBDCompetence.ProveThyself
// 0x00B8 (0x0518 - 0x0460)
class UProveThyself final : public UPerk
{
public:
	struct FDBDTunableRowHandle                   _proveThyselfRange;                                // 0x0460(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _speedPercentageAddedPerSurvivorRepairingInRange[0x3]; // 0x0488(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_494[0x64];                                     // 0x0494(0x0064)(Fixing Size After Last Property [ Dumper-7 ])
	struct FForAllSurvivorsStatusEffectImposer    _proveThyselfEffectImposer;                        // 0x04F8(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_510[0x8];                                      // 0x0510(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSurvivorInOwnerRangeChanged(const bool inRange);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProveThyself">();
	}
	static class UProveThyself* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProveThyself>();
	}
};
static_assert(alignof(UProveThyself) == 0x000008, "Wrong alignment on UProveThyself");
static_assert(sizeof(UProveThyself) == 0x000518, "Wrong size on UProveThyself");
static_assert(offsetof(UProveThyself, _proveThyselfRange) == 0x000460, "Member 'UProveThyself::_proveThyselfRange' has a wrong offset!");
static_assert(offsetof(UProveThyself, _speedPercentageAddedPerSurvivorRepairingInRange) == 0x000488, "Member 'UProveThyself::_speedPercentageAddedPerSurvivorRepairingInRange' has a wrong offset!");
static_assert(offsetof(UProveThyself, _proveThyselfEffectImposer) == 0x0004F8, "Member 'UProveThyself::_proveThyselfEffectImposer' has a wrong offset!");

// Class DBDCompetence.RemoveOnOriginatingSurvivorGoneStatusEffect
// 0x0008 (0x03A0 - 0x0398)
class URemoveOnOriginatingSurvivorGoneStatusEffect : public UStatusEffect
{
public:
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnSurvivorRemoved(class ASurvivor* Survivor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RemoveOnOriginatingSurvivorGoneStatusEffect">();
	}
	static class URemoveOnOriginatingSurvivorGoneStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<URemoveOnOriginatingSurvivorGoneStatusEffect>();
	}
};
static_assert(alignof(URemoveOnOriginatingSurvivorGoneStatusEffect) == 0x000008, "Wrong alignment on URemoveOnOriginatingSurvivorGoneStatusEffect");
static_assert(sizeof(URemoveOnOriginatingSurvivorGoneStatusEffect) == 0x0003A0, "Wrong size on URemoveOnOriginatingSurvivorGoneStatusEffect");

// Class DBDCompetence.ProveThyselfEffect
// 0x00E0 (0x0480 - 0x03A0)
class UProveThyselfEffect final : public URemoveOnOriginatingSurvivorGoneStatusEffect
{
public:
	uint8                                         Pad_3A0[0x20];                                     // 0x03A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _proveThyselfRange;                                // 0x03C0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E8[0x98];                                     // 0x03E8(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInRangeOfOriginatorChanged(const bool inRange, class ASurvivor* Survivor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProveThyselfEffect">();
	}
	static class UProveThyselfEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProveThyselfEffect>();
	}
};
static_assert(alignof(UProveThyselfEffect) == 0x000008, "Wrong alignment on UProveThyselfEffect");
static_assert(sizeof(UProveThyselfEffect) == 0x000480, "Wrong size on UProveThyselfEffect");
static_assert(offsetof(UProveThyselfEffect, _proveThyselfRange) == 0x0003C0, "Member 'UProveThyselfEffect::_proveThyselfRange' has a wrong offset!");

// Class DBDCompetence.QuickAndQuiet
// 0x0038 (0x0498 - 0x0460)
class UQuickAndQuiet final : public UPerk
{
public:
	struct FGameplayTagContainer                  _rushedActions;                                    // 0x0460(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _silentRushedActionStatusEffect;                   // 0x0480(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _cooldownDurationSeconds[0x3];                     // 0x0488(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_494[0x4];                                      // 0x0494(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnPlayerRushedActionFinished();

	float GetCooldownDurationSecondsAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuickAndQuiet">();
	}
	static class UQuickAndQuiet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuickAndQuiet>();
	}
};
static_assert(alignof(UQuickAndQuiet) == 0x000008, "Wrong alignment on UQuickAndQuiet");
static_assert(sizeof(UQuickAndQuiet) == 0x000498, "Wrong size on UQuickAndQuiet");
static_assert(offsetof(UQuickAndQuiet, _rushedActions) == 0x000460, "Member 'UQuickAndQuiet::_rushedActions' has a wrong offset!");
static_assert(offsetof(UQuickAndQuiet, _silentRushedActionStatusEffect) == 0x000480, "Member 'UQuickAndQuiet::_silentRushedActionStatusEffect' has a wrong offset!");
static_assert(offsetof(UQuickAndQuiet, _cooldownDurationSeconds) == 0x000488, "Member 'UQuickAndQuiet::_cooldownDurationSeconds' has a wrong offset!");

// Class DBDCompetence.RampingBlindEffect
// 0x0010 (0x03A8 - 0x0398)
class URampingBlindEffect final : public UStatusEffect
{
public:
	class UBlindableComponent*                    _ownerBlindable;                                   // 0x0398(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A0[0x8];                                      // 0x03A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RampingBlindEffect">();
	}
	static class URampingBlindEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<URampingBlindEffect>();
	}
};
static_assert(alignof(URampingBlindEffect) == 0x000008, "Wrong alignment on URampingBlindEffect");
static_assert(sizeof(URampingBlindEffect) == 0x0003A8, "Wrong size on URampingBlindEffect");
static_assert(offsetof(URampingBlindEffect, _ownerBlindable) == 0x000398, "Member 'URampingBlindEffect::_ownerBlindable' has a wrong offset!");

// Class DBDCompetence.RemoveFlagsAction
// 0x0028 (0x0068 - 0x0040)
class URemoveFlagsAction final : public UCompetenceAction
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _gameplayTags;                                     // 0x0048(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RemoveFlagsAction">();
	}
	static class URemoveFlagsAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<URemoveFlagsAction>();
	}
};
static_assert(alignof(URemoveFlagsAction) == 0x000008, "Wrong alignment on URemoveFlagsAction");
static_assert(sizeof(URemoveFlagsAction) == 0x000068, "Wrong size on URemoveFlagsAction");
static_assert(offsetof(URemoveFlagsAction, _gameplayTags) == 0x000048, "Member 'URemoveFlagsAction::_gameplayTags' has a wrong offset!");

// Class DBDCompetence.RemoveHookStageAction
// 0x0000 (0x0040 - 0x0040)
class URemoveHookStageAction final : public UCompetenceAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RemoveHookStageAction">();
	}
	static class URemoveHookStageAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<URemoveHookStageAction>();
	}
};
static_assert(alignof(URemoveHookStageAction) == 0x000008, "Wrong alignment on URemoveHookStageAction");
static_assert(sizeof(URemoveHookStageAction) == 0x000040, "Wrong size on URemoveHookStageAction");

// Class DBDCompetence.RemoveStateTagsAction
// 0x0030 (0x0070 - 0x0040)
class URemoveStateTagsAction final : public UCompetenceAction
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _stateTags;                                        // 0x0048(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          _applyOnInitialized;                               // 0x0068(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _applyToEventInstigator;                           // 0x0069(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _applyToEventTarget;                               // 0x006A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6B[0x5];                                       // 0x006B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RemoveStateTagsAction">();
	}
	static class URemoveStateTagsAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<URemoveStateTagsAction>();
	}
};
static_assert(alignof(URemoveStateTagsAction) == 0x000008, "Wrong alignment on URemoveStateTagsAction");
static_assert(sizeof(URemoveStateTagsAction) == 0x000070, "Wrong size on URemoveStateTagsAction");
static_assert(offsetof(URemoveStateTagsAction, _stateTags) == 0x000048, "Member 'URemoveStateTagsAction::_stateTags' has a wrong offset!");
static_assert(offsetof(URemoveStateTagsAction, _applyOnInitialized) == 0x000068, "Member 'URemoveStateTagsAction::_applyOnInitialized' has a wrong offset!");
static_assert(offsetof(URemoveStateTagsAction, _applyToEventInstigator) == 0x000069, "Member 'URemoveStateTagsAction::_applyToEventInstigator' has a wrong offset!");
static_assert(offsetof(URemoveStateTagsAction, _applyToEventTarget) == 0x00006A, "Member 'URemoveStateTagsAction::_applyToEventTarget' has a wrong offset!");

// Class DBDCompetence.RemoveThisStatusEffectAction
// 0x0008 (0x0048 - 0x0040)
class URemoveThisStatusEffectAction final : public UCompetenceAction
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RemoveThisStatusEffectAction">();
	}
	static class URemoveThisStatusEffectAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<URemoveThisStatusEffectAction>();
	}
};
static_assert(alignof(URemoveThisStatusEffectAction) == 0x000008, "Wrong alignment on URemoveThisStatusEffectAction");
static_assert(sizeof(URemoveThisStatusEffectAction) == 0x000048, "Wrong size on URemoveThisStatusEffectAction");

// Class DBDCompetence.ResiliencePerk
// 0x0018 (0x0478 - 0x0460)
class UResiliencePerk final : public UPerk
{
public:
	float                                         _actionSpeed[0x3];                                 // 0x0460(0x0004)(Edit, EditFixedSize, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_46C[0x4];                                      // 0x046C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _actionSpeedStatusEffectClass;                     // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResiliencePerk">();
	}
	static class UResiliencePerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResiliencePerk>();
	}
};
static_assert(alignof(UResiliencePerk) == 0x000008, "Wrong alignment on UResiliencePerk");
static_assert(sizeof(UResiliencePerk) == 0x000478, "Wrong size on UResiliencePerk");
static_assert(offsetof(UResiliencePerk, _actionSpeed) == 0x000460, "Member 'UResiliencePerk::_actionSpeed' has a wrong offset!");
static_assert(offsetof(UResiliencePerk, _actionSpeedStatusEffectClass) == 0x000470, "Member 'UResiliencePerk::_actionSpeedStatusEffectClass' has a wrong offset!");

// Class DBDCompetence.RevealClosestPalletWithinRangeSkill
// 0x0030 (0x03B8 - 0x0388)
class URevealClosestPalletWithinRangeSkill final : public USkill
{
public:
	struct FDBDTunableRowHandle                   _withinRange;                                      // 0x0388(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class APallet*                                _currentlyRevealedPallet;                          // 0x03B0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RevealClosestPalletWithinRangeSkill">();
	}
	static class URevealClosestPalletWithinRangeSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<URevealClosestPalletWithinRangeSkill>();
	}
};
static_assert(alignof(URevealClosestPalletWithinRangeSkill) == 0x000008, "Wrong alignment on URevealClosestPalletWithinRangeSkill");
static_assert(sizeof(URevealClosestPalletWithinRangeSkill) == 0x0003B8, "Wrong size on URevealClosestPalletWithinRangeSkill");
static_assert(offsetof(URevealClosestPalletWithinRangeSkill, _withinRange) == 0x000388, "Member 'URevealClosestPalletWithinRangeSkill::_withinRange' has a wrong offset!");
static_assert(offsetof(URevealClosestPalletWithinRangeSkill, _currentlyRevealedPallet) == 0x0003B0, "Member 'URevealClosestPalletWithinRangeSkill::_currentlyRevealedPallet' has a wrong offset!");

// Class DBDCompetence.RevealInteractableToSurvivorsAction
// 0x0018 (0x0058 - 0x0040)
class URevealInteractableToSurvivorsAction final : public UCompetenceAction
{
public:
	struct FLinearColor                           _revealColor;                                      // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RevealInteractableToSurvivorsAction">();
	}
	static class URevealInteractableToSurvivorsAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<URevealInteractableToSurvivorsAction>();
	}
};
static_assert(alignof(URevealInteractableToSurvivorsAction) == 0x000008, "Wrong alignment on URevealInteractableToSurvivorsAction");
static_assert(sizeof(URevealInteractableToSurvivorsAction) == 0x000058, "Wrong size on URevealInteractableToSurvivorsAction");
static_assert(offsetof(URevealInteractableToSurvivorsAction, _revealColor) == 0x000040, "Member 'URevealInteractableToSurvivorsAction::_revealColor' has a wrong offset!");

// Class DBDCompetence.RevealSurvivorAuraOnChaseStartedAction
// 0x00C0 (0x0100 - 0x0040)
class URevealSurvivorAuraOnChaseStartedAction final : public UCompetenceAction
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFloatValueStrategy*                    _revealToKillerDurationStrategy;                   // 0x0048(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFloatValueStrategy*                    _revealToKillerMinimumRangeStrategy;               // 0x0050(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _revealToKillerEffectClass;                        // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0xA0];                                      // 0x0060(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RevealSurvivorAuraOnChaseStartedAction">();
	}
	static class URevealSurvivorAuraOnChaseStartedAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<URevealSurvivorAuraOnChaseStartedAction>();
	}
};
static_assert(alignof(URevealSurvivorAuraOnChaseStartedAction) == 0x000008, "Wrong alignment on URevealSurvivorAuraOnChaseStartedAction");
static_assert(sizeof(URevealSurvivorAuraOnChaseStartedAction) == 0x000100, "Wrong size on URevealSurvivorAuraOnChaseStartedAction");
static_assert(offsetof(URevealSurvivorAuraOnChaseStartedAction, _revealToKillerDurationStrategy) == 0x000048, "Member 'URevealSurvivorAuraOnChaseStartedAction::_revealToKillerDurationStrategy' has a wrong offset!");
static_assert(offsetof(URevealSurvivorAuraOnChaseStartedAction, _revealToKillerMinimumRangeStrategy) == 0x000050, "Member 'URevealSurvivorAuraOnChaseStartedAction::_revealToKillerMinimumRangeStrategy' has a wrong offset!");
static_assert(offsetof(URevealSurvivorAuraOnChaseStartedAction, _revealToKillerEffectClass) == 0x000058, "Member 'URevealSurvivorAuraOnChaseStartedAction::_revealToKillerEffectClass' has a wrong offset!");

// Class DBDCompetence.Saboteur
// 0x0058 (0x04B8 - 0x0460)
class USaboteur final : public UPerk
{
public:
	float                                         _cooldownDuration[0x3];                            // 0x0460(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _revealHookDistance[0x3];                          // 0x046C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _scourgeHooksAuraColour;                           // 0x0478(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _saboteurEffect;                                   // 0x0488(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMeatHookOutlineUpdateStrategy*> _revealedMeatHooksOultineStrategy;                 // 0x0490(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A0[0x18];                                     // 0x04A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetCooldownDurationAtLevel() const;
	float GetRevealHookDistanceAtLevel() const;
	struct FLinearColor GetScourgeHooksAuraColour() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Saboteur">();
	}
	static class USaboteur* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaboteur>();
	}
};
static_assert(alignof(USaboteur) == 0x000008, "Wrong alignment on USaboteur");
static_assert(sizeof(USaboteur) == 0x0004B8, "Wrong size on USaboteur");
static_assert(offsetof(USaboteur, _cooldownDuration) == 0x000460, "Member 'USaboteur::_cooldownDuration' has a wrong offset!");
static_assert(offsetof(USaboteur, _revealHookDistance) == 0x00046C, "Member 'USaboteur::_revealHookDistance' has a wrong offset!");
static_assert(offsetof(USaboteur, _scourgeHooksAuraColour) == 0x000478, "Member 'USaboteur::_scourgeHooksAuraColour' has a wrong offset!");
static_assert(offsetof(USaboteur, _saboteurEffect) == 0x000488, "Member 'USaboteur::_saboteurEffect' has a wrong offset!");
static_assert(offsetof(USaboteur, _revealedMeatHooksOultineStrategy) == 0x000490, "Member 'USaboteur::_revealedMeatHooksOultineStrategy' has a wrong offset!");

// Class DBDCompetence.SecondsToRateModifierBaseAddon
// 0x0110 (0x0410 - 0x0300)
class USecondsToRateModifierBaseAddon final : public UItemAddon
{
public:
	struct FTunableStat                           _chargeRate;                                       // 0x0300(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _maxCharge;                                        // 0x0380(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _secondsToAdd;                                     // 0x0400(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _rateModifierTagToCompute;                         // 0x0404(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SecondsToRateModifierBaseAddon">();
	}
	static class USecondsToRateModifierBaseAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<USecondsToRateModifierBaseAddon>();
	}
};
static_assert(alignof(USecondsToRateModifierBaseAddon) == 0x000008, "Wrong alignment on USecondsToRateModifierBaseAddon");
static_assert(sizeof(USecondsToRateModifierBaseAddon) == 0x000410, "Wrong size on USecondsToRateModifierBaseAddon");
static_assert(offsetof(USecondsToRateModifierBaseAddon, _chargeRate) == 0x000300, "Member 'USecondsToRateModifierBaseAddon::_chargeRate' has a wrong offset!");
static_assert(offsetof(USecondsToRateModifierBaseAddon, _maxCharge) == 0x000380, "Member 'USecondsToRateModifierBaseAddon::_maxCharge' has a wrong offset!");
static_assert(offsetof(USecondsToRateModifierBaseAddon, _secondsToAdd) == 0x000400, "Member 'USecondsToRateModifierBaseAddon::_secondsToAdd' has a wrong offset!");
static_assert(offsetof(USecondsToRateModifierBaseAddon, _rateModifierTagToCompute) == 0x000404, "Member 'USecondsToRateModifierBaseAddon::_rateModifierTagToCompute' has a wrong offset!");

// Class DBDCompetence.SecondWind
// 0x0050 (0x04B0 - 0x0460)
class USecondWind final : public UPerk
{
public:
	uint8                                         Pad_460[0x8];                                      // 0x0460(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ESecondWindState                              _currentState;                                     // 0x0468(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_469[0x3];                                      // 0x0469(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _amountHealed;                                     // 0x046C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_470[0x8];                                      // 0x0470(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _numberOfHealStateToHealToActivate[0x3];           // 0x0478(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _durationOfHeal[0x3];                              // 0x0484(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _brokenStatusEffectClass;                          // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _applyBrokenEffect;                                // 0x0498(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_499[0xF];                                      // 0x0499(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffect*                          _brokenStatusEffect;                               // 0x04A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnHealProgress(float IndividualChargeAmount, float TotalChargeAmount, class AActor* ChargeInstigator, bool WasCoop, float DeltaTime);

	float GetDurationOfHealAtLevel() const;
	float GetNumberOfHealStateToHealToActivateAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SecondWind">();
	}
	static class USecondWind* GetDefaultObj()
	{
		return GetDefaultObjImpl<USecondWind>();
	}
};
static_assert(alignof(USecondWind) == 0x000008, "Wrong alignment on USecondWind");
static_assert(sizeof(USecondWind) == 0x0004B0, "Wrong size on USecondWind");
static_assert(offsetof(USecondWind, _currentState) == 0x000468, "Member 'USecondWind::_currentState' has a wrong offset!");
static_assert(offsetof(USecondWind, _amountHealed) == 0x00046C, "Member 'USecondWind::_amountHealed' has a wrong offset!");
static_assert(offsetof(USecondWind, _numberOfHealStateToHealToActivate) == 0x000478, "Member 'USecondWind::_numberOfHealStateToHealToActivate' has a wrong offset!");
static_assert(offsetof(USecondWind, _durationOfHeal) == 0x000484, "Member 'USecondWind::_durationOfHeal' has a wrong offset!");
static_assert(offsetof(USecondWind, _brokenStatusEffectClass) == 0x000490, "Member 'USecondWind::_brokenStatusEffectClass' has a wrong offset!");
static_assert(offsetof(USecondWind, _applyBrokenEffect) == 0x000498, "Member 'USecondWind::_applyBrokenEffect' has a wrong offset!");
static_assert(offsetof(USecondWind, _brokenStatusEffect) == 0x0004A8, "Member 'USecondWind::_brokenStatusEffect' has a wrong offset!");

// Class DBDCompetence.SelfCare
// 0x0028 (0x0488 - 0x0460)
class USelfCare final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _selfHealNoMedkitSpeedPenaltyEffectClass;          // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _selfHealSpeedPenalty[0x3];                        // 0x0468(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_474[0x4];                                      // 0x0474(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UInteractionDefinition>     _selfCareInteraction;                              // 0x0478(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractionAttacherComponent*          _interactionAttacherComponent;                     // 0x0480(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SelfCare">();
	}
	static class USelfCare* GetDefaultObj()
	{
		return GetDefaultObjImpl<USelfCare>();
	}
};
static_assert(alignof(USelfCare) == 0x000008, "Wrong alignment on USelfCare");
static_assert(sizeof(USelfCare) == 0x000488, "Wrong size on USelfCare");
static_assert(offsetof(USelfCare, _selfHealNoMedkitSpeedPenaltyEffectClass) == 0x000460, "Member 'USelfCare::_selfHealNoMedkitSpeedPenaltyEffectClass' has a wrong offset!");
static_assert(offsetof(USelfCare, _selfHealSpeedPenalty) == 0x000468, "Member 'USelfCare::_selfHealSpeedPenalty' has a wrong offset!");
static_assert(offsetof(USelfCare, _selfCareInteraction) == 0x000478, "Member 'USelfCare::_selfCareInteraction' has a wrong offset!");
static_assert(offsetof(USelfCare, _interactionAttacherComponent) == 0x000480, "Member 'USelfCare::_interactionAttacherComponent' has a wrong offset!");

// Class DBDCompetence.SelfRecoverSkill
// 0x0028 (0x03B0 - 0x0388)
class USelfRecoverSkill final : public USkill
{
public:
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _enduranceStatusEffect;                            // 0x0390(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _hasteStatusEffect;                                // 0x0398(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _enduranceDuration;                                // 0x03A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _hasteDuration;                                    // 0x03A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _hasteAmount;                                      // 0x03A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _soloRecoveryBonusThreshold;                       // 0x03AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnHealProgress(float IndividualChargeAmount, float TotalChargeAmount, class AActor* ChargeInstigator, bool WasCoop, float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SelfRecoverSkill">();
	}
	static class USelfRecoverSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<USelfRecoverSkill>();
	}
};
static_assert(alignof(USelfRecoverSkill) == 0x000008, "Wrong alignment on USelfRecoverSkill");
static_assert(sizeof(USelfRecoverSkill) == 0x0003B0, "Wrong size on USelfRecoverSkill");
static_assert(offsetof(USelfRecoverSkill, _enduranceStatusEffect) == 0x000390, "Member 'USelfRecoverSkill::_enduranceStatusEffect' has a wrong offset!");
static_assert(offsetof(USelfRecoverSkill, _hasteStatusEffect) == 0x000398, "Member 'USelfRecoverSkill::_hasteStatusEffect' has a wrong offset!");
static_assert(offsetof(USelfRecoverSkill, _enduranceDuration) == 0x0003A0, "Member 'USelfRecoverSkill::_enduranceDuration' has a wrong offset!");
static_assert(offsetof(USelfRecoverSkill, _hasteDuration) == 0x0003A4, "Member 'USelfRecoverSkill::_hasteDuration' has a wrong offset!");
static_assert(offsetof(USelfRecoverSkill, _hasteAmount) == 0x0003A8, "Member 'USelfRecoverSkill::_hasteAmount' has a wrong offset!");
static_assert(offsetof(USelfRecoverSkill, _soloRecoveryBonusThreshold) == 0x0003AC, "Member 'USelfRecoverSkill::_soloRecoveryBonusThreshold' has a wrong offset!");

// Class DBDCompetence.SetItemCountAction
// 0x0010 (0x0050 - 0x0040)
class USetItemCountAction final : public UCompetenceAction
{
public:
	class FName                                   _itemID;                                           // 0x0040(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _countModifier;                                    // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SetItemCountAction">();
	}
	static class USetItemCountAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USetItemCountAction>();
	}
};
static_assert(alignof(USetItemCountAction) == 0x000008, "Wrong alignment on USetItemCountAction");
static_assert(sizeof(USetItemCountAction) == 0x000050, "Wrong size on USetItemCountAction");
static_assert(offsetof(USetItemCountAction, _itemID) == 0x000040, "Member 'USetItemCountAction::_itemID' has a wrong offset!");
static_assert(offsetof(USetItemCountAction, _countModifier) == 0x00004C, "Member 'USetItemCountAction::_countModifier' has a wrong offset!");

// Class DBDCompetence.SetKillerInstinctReveal
// 0x0000 (0x0040 - 0x0040)
class USetKillerInstinctReveal final : public UCompetenceAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SetKillerInstinctReveal">();
	}
	static class USetKillerInstinctReveal* GetDefaultObj()
	{
		return GetDefaultObjImpl<USetKillerInstinctReveal>();
	}
};
static_assert(alignof(USetKillerInstinctReveal) == 0x000008, "Wrong alignment on USetKillerInstinctReveal");
static_assert(sizeof(USetKillerInstinctReveal) == 0x000040, "Wrong size on USetKillerInstinctReveal");

// Class DBDCompetence.SetModifierFlagAction
// 0x0018 (0x0058 - 0x0040)
class USetModifierFlagAction final : public UCompetenceAction
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _gameplayModifierFlag;                             // 0x0048(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _applyOnInitialized;                               // 0x0054(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _removeFlagOnApplyEnd;                             // 0x0055(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_56[0x2];                                       // 0x0056(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SetModifierFlagAction">();
	}
	static class USetModifierFlagAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USetModifierFlagAction>();
	}
};
static_assert(alignof(USetModifierFlagAction) == 0x000008, "Wrong alignment on USetModifierFlagAction");
static_assert(sizeof(USetModifierFlagAction) == 0x000058, "Wrong size on USetModifierFlagAction");
static_assert(offsetof(USetModifierFlagAction, _gameplayModifierFlag) == 0x000048, "Member 'USetModifierFlagAction::_gameplayModifierFlag' has a wrong offset!");
static_assert(offsetof(USetModifierFlagAction, _applyOnInitialized) == 0x000054, "Member 'USetModifierFlagAction::_applyOnInitialized' has a wrong offset!");
static_assert(offsetof(USetModifierFlagAction, _removeFlagOnApplyEnd) == 0x000055, "Member 'USetModifierFlagAction::_removeFlagOnApplyEnd' has a wrong offset!");

// Class DBDCompetence.SetModifierValueAction
// 0x0018 (0x0058 - 0x0040)
class USetModifierValueAction final : public UCompetenceAction
{
public:
	struct FGameplayTag                           _gameplayModifierType;                             // 0x0040(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFloatValueStrategy*                    _modifierValueStrategy;                            // 0x0050(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SetModifierValueAction">();
	}
	static class USetModifierValueAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USetModifierValueAction>();
	}
};
static_assert(alignof(USetModifierValueAction) == 0x000008, "Wrong alignment on USetModifierValueAction");
static_assert(sizeof(USetModifierValueAction) == 0x000058, "Wrong size on USetModifierValueAction");
static_assert(offsetof(USetModifierValueAction, _gameplayModifierType) == 0x000040, "Member 'USetModifierValueAction::_gameplayModifierType' has a wrong offset!");
static_assert(offsetof(USetModifierValueAction, _modifierValueStrategy) == 0x000050, "Member 'USetModifierValueAction::_modifierValueStrategy' has a wrong offset!");

// Class DBDCompetence.SetRemainingLifetimeAction
// 0x0010 (0x0050 - 0x0040)
class USetRemainingLifetimeAction final : public UCompetenceAction
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFloatValueStrategy*                    _valueStrategy;                                    // 0x0048(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SetRemainingLifetimeAction">();
	}
	static class USetRemainingLifetimeAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USetRemainingLifetimeAction>();
	}
};
static_assert(alignof(USetRemainingLifetimeAction) == 0x000008, "Wrong alignment on USetRemainingLifetimeAction");
static_assert(sizeof(USetRemainingLifetimeAction) == 0x000050, "Wrong size on USetRemainingLifetimeAction");
static_assert(offsetof(USetRemainingLifetimeAction, _valueStrategy) == 0x000048, "Member 'USetRemainingLifetimeAction::_valueStrategy' has a wrong offset!");

// Class DBDCompetence.SetStackingModifierValueAction
// 0x0020 (0x0060 - 0x0040)
class USetStackingModifierValueAction final : public UCompetenceAction
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _gameplayModifierType;                             // 0x0048(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _gameplayModifierValue;                            // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _maxStacks;                                        // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SetStackingModifierValueAction">();
	}
	static class USetStackingModifierValueAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USetStackingModifierValueAction>();
	}
};
static_assert(alignof(USetStackingModifierValueAction) == 0x000008, "Wrong alignment on USetStackingModifierValueAction");
static_assert(sizeof(USetStackingModifierValueAction) == 0x000060, "Wrong size on USetStackingModifierValueAction");
static_assert(offsetof(USetStackingModifierValueAction, _gameplayModifierType) == 0x000048, "Member 'USetStackingModifierValueAction::_gameplayModifierType' has a wrong offset!");
static_assert(offsetof(USetStackingModifierValueAction, _gameplayModifierValue) == 0x000054, "Member 'USetStackingModifierValueAction::_gameplayModifierValue' has a wrong offset!");
static_assert(offsetof(USetStackingModifierValueAction, _maxStacks) == 0x000058, "Member 'USetStackingModifierValueAction::_maxStacks' has a wrong offset!");

// Class DBDCompetence.SetStateTagAction
// 0x0010 (0x0050 - 0x0040)
class USetStateTagAction final : public UCompetenceAction
{
public:
	struct FGameplayTag                           _stateTag;                                         // 0x0040(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _applyOnInitialized;                               // 0x004C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _removeOnApplyEnd;                                 // 0x004D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4E[0x2];                                       // 0x004E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SetStateTagAction">();
	}
	static class USetStateTagAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USetStateTagAction>();
	}
};
static_assert(alignof(USetStateTagAction) == 0x000008, "Wrong alignment on USetStateTagAction");
static_assert(sizeof(USetStateTagAction) == 0x000050, "Wrong size on USetStateTagAction");
static_assert(offsetof(USetStateTagAction, _stateTag) == 0x000040, "Member 'USetStateTagAction::_stateTag' has a wrong offset!");
static_assert(offsetof(USetStateTagAction, _applyOnInitialized) == 0x00004C, "Member 'USetStateTagAction::_applyOnInitialized' has a wrong offset!");
static_assert(offsetof(USetStateTagAction, _removeOnApplyEnd) == 0x00004D, "Member 'USetStateTagAction::_removeOnApplyEnd' has a wrong offset!");

// Class DBDCompetence.SetStatusEffectIconActiveWhenApplicableAction
// 0x0000 (0x0040 - 0x0040)
class USetStatusEffectIconActiveWhenApplicableAction final : public UCompetenceAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SetStatusEffectIconActiveWhenApplicableAction">();
	}
	static class USetStatusEffectIconActiveWhenApplicableAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USetStatusEffectIconActiveWhenApplicableAction>();
	}
};
static_assert(alignof(USetStatusEffectIconActiveWhenApplicableAction) == 0x000008, "Wrong alignment on USetStatusEffectIconActiveWhenApplicableAction");
static_assert(sizeof(USetStatusEffectIconActiveWhenApplicableAction) == 0x000040, "Wrong size on USetStatusEffectIconActiveWhenApplicableAction");

// Class DBDCompetence.SmallGame
// 0x0028 (0x0488 - 0x0460)
class USmallGame final : public UPerk
{
public:
	float                                         _detectionConeAngle[0x3];                          // 0x0460(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _detectionConeAngleReductionRate[0x3];             // 0x046C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _totemDetected;                                    // 0x0478(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_479[0xF];                                      // 0x0479(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_SetTotemDetected(bool Value);
	void Multicast_TotemFound();
	void SearchForTotems();
	void VFXTotemFound();

	float GetDetectionConeAngle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmallGame">();
	}
	static class USmallGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<USmallGame>();
	}
};
static_assert(alignof(USmallGame) == 0x000008, "Wrong alignment on USmallGame");
static_assert(sizeof(USmallGame) == 0x000488, "Wrong size on USmallGame");
static_assert(offsetof(USmallGame, _detectionConeAngle) == 0x000460, "Member 'USmallGame::_detectionConeAngle' has a wrong offset!");
static_assert(offsetof(USmallGame, _detectionConeAngleReductionRate) == 0x00046C, "Member 'USmallGame::_detectionConeAngleReductionRate' has a wrong offset!");
static_assert(offsetof(USmallGame, _totemDetected) == 0x000478, "Member 'USmallGame::_totemDetected' has a wrong offset!");

// Class DBDCompetence.SoleSurvivor
// 0x0068 (0x04C8 - 0x0460)
class USoleSurvivor final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _modifyActionSpeedWhenRepairingEffect;             // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _modifyActionSpeedWhenOpeningGateOrHatchEffect;    // 0x0468(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _obsessionChanceStatusEffectClass;                 // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _actionSpeedsRepairing[0x3];                       // 0x0478(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _actionSpeedsOpeningGateOrHatch[0x3];              // 0x0484(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _auraHideDistancePerDeadOrDisconnectedSurvivor[0x3]; // 0x0490(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49C[0x4];                                      // 0x049C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ASurvivor*>                      _otherSurvivors;                                   // 0x04A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B0[0x18];                                     // 0x04B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnSurvivorAdded(const class ASurvivor* Survivor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoleSurvivor">();
	}
	static class USoleSurvivor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoleSurvivor>();
	}
};
static_assert(alignof(USoleSurvivor) == 0x000008, "Wrong alignment on USoleSurvivor");
static_assert(sizeof(USoleSurvivor) == 0x0004C8, "Wrong size on USoleSurvivor");
static_assert(offsetof(USoleSurvivor, _modifyActionSpeedWhenRepairingEffect) == 0x000460, "Member 'USoleSurvivor::_modifyActionSpeedWhenRepairingEffect' has a wrong offset!");
static_assert(offsetof(USoleSurvivor, _modifyActionSpeedWhenOpeningGateOrHatchEffect) == 0x000468, "Member 'USoleSurvivor::_modifyActionSpeedWhenOpeningGateOrHatchEffect' has a wrong offset!");
static_assert(offsetof(USoleSurvivor, _obsessionChanceStatusEffectClass) == 0x000470, "Member 'USoleSurvivor::_obsessionChanceStatusEffectClass' has a wrong offset!");
static_assert(offsetof(USoleSurvivor, _actionSpeedsRepairing) == 0x000478, "Member 'USoleSurvivor::_actionSpeedsRepairing' has a wrong offset!");
static_assert(offsetof(USoleSurvivor, _actionSpeedsOpeningGateOrHatch) == 0x000484, "Member 'USoleSurvivor::_actionSpeedsOpeningGateOrHatch' has a wrong offset!");
static_assert(offsetof(USoleSurvivor, _auraHideDistancePerDeadOrDisconnectedSurvivor) == 0x000490, "Member 'USoleSurvivor::_auraHideDistancePerDeadOrDisconnectedSurvivor' has a wrong offset!");
static_assert(offsetof(USoleSurvivor, _otherSurvivors) == 0x0004A0, "Member 'USoleSurvivor::_otherSurvivors' has a wrong offset!");

// Class DBDCompetence.Solidarity
// 0x0038 (0x0498 - 0x0460)
class USolidarity final : public UPerk
{
public:
	bool                                          _allowMedkit;                                      // 0x0460(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_461[0xF];                                      // 0x0461(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargeableComponent*                   _healerHPSlot;                                     // 0x0470(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _targetHPSlot;                                     // 0x0478(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableInteractionDefinition*       _healOtherInteraction;                             // 0x0480(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_488[0x10];                                     // 0x0488(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnHealthChargeApplied(float IndividualChargeAmount, float TotalChargeAmount, class AActor* ChargeInstigator, bool WasCoop, float DeltaTime);
	void Authority_OnSkillCheckResponse(bool Success, bool Bonus, class ADBDPlayer* Player, bool TriggerLoudNoise, bool hadInput, ESkillCheckCustomType Type, float ChargeChange);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Solidarity">();
	}
	static class USolidarity* GetDefaultObj()
	{
		return GetDefaultObjImpl<USolidarity>();
	}
};
static_assert(alignof(USolidarity) == 0x000008, "Wrong alignment on USolidarity");
static_assert(sizeof(USolidarity) == 0x000498, "Wrong size on USolidarity");
static_assert(offsetof(USolidarity, _allowMedkit) == 0x000460, "Member 'USolidarity::_allowMedkit' has a wrong offset!");
static_assert(offsetof(USolidarity, _healerHPSlot) == 0x000470, "Member 'USolidarity::_healerHPSlot' has a wrong offset!");
static_assert(offsetof(USolidarity, _targetHPSlot) == 0x000478, "Member 'USolidarity::_targetHPSlot' has a wrong offset!");
static_assert(offsetof(USolidarity, _healOtherInteraction) == 0x000480, "Member 'USolidarity::_healOtherInteraction' has a wrong offset!");

// Class DBDCompetence.SpawningEffectOnGameEventPerk
// 0x0070 (0x04D0 - 0x0460)
class USpawningEffectOnGameEventPerk final : public UPerk
{
public:
	bool                                          _shouldStartActivationTimerOnGameEventWithLifetime; // 0x0460(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _shouldCheckIfOwnerIsInstigatorOrTarget;           // 0x0461(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_462[0x6];                                      // 0x0462(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _gameEvents;                                       // 0x0468(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	ESpawningEffectGameEventSubject               _subjectType;                                      // 0x0488(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_489[0x7];                                      // 0x0489(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpawningEffectOnGameEventData         _statusEffects[0x3];                               // 0x0490(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C0[0x10];                                     // 0x04C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetCustomParameterOfStatusEffectAtLevel();
	float GetLifetimeOfStatusEffectAtLevel();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawningEffectOnGameEventPerk">();
	}
	static class USpawningEffectOnGameEventPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawningEffectOnGameEventPerk>();
	}
};
static_assert(alignof(USpawningEffectOnGameEventPerk) == 0x000008, "Wrong alignment on USpawningEffectOnGameEventPerk");
static_assert(sizeof(USpawningEffectOnGameEventPerk) == 0x0004D0, "Wrong size on USpawningEffectOnGameEventPerk");
static_assert(offsetof(USpawningEffectOnGameEventPerk, _shouldStartActivationTimerOnGameEventWithLifetime) == 0x000460, "Member 'USpawningEffectOnGameEventPerk::_shouldStartActivationTimerOnGameEventWithLifetime' has a wrong offset!");
static_assert(offsetof(USpawningEffectOnGameEventPerk, _shouldCheckIfOwnerIsInstigatorOrTarget) == 0x000461, "Member 'USpawningEffectOnGameEventPerk::_shouldCheckIfOwnerIsInstigatorOrTarget' has a wrong offset!");
static_assert(offsetof(USpawningEffectOnGameEventPerk, _gameEvents) == 0x000468, "Member 'USpawningEffectOnGameEventPerk::_gameEvents' has a wrong offset!");
static_assert(offsetof(USpawningEffectOnGameEventPerk, _subjectType) == 0x000488, "Member 'USpawningEffectOnGameEventPerk::_subjectType' has a wrong offset!");
static_assert(offsetof(USpawningEffectOnGameEventPerk, _statusEffects) == 0x000490, "Member 'USpawningEffectOnGameEventPerk::_statusEffects' has a wrong offset!");

// Class DBDCompetence.SpawnStatusEffectsOnKillerAddon
// 0x0020 (0x0320 - 0x0300)
class USpawnStatusEffectsOnKillerAddon final : public UItemAddon
{
public:
	TArray<struct FStatusEffectsProperties>       _statusEffectsToSpawn;                             // 0x0300(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class UStatusEffect>>   _imposedStatusEffects;                             // 0x0310(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnStatusEffectsOnKillerAddon">();
	}
	static class USpawnStatusEffectsOnKillerAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnStatusEffectsOnKillerAddon>();
	}
};
static_assert(alignof(USpawnStatusEffectsOnKillerAddon) == 0x000008, "Wrong alignment on USpawnStatusEffectsOnKillerAddon");
static_assert(sizeof(USpawnStatusEffectsOnKillerAddon) == 0x000320, "Wrong size on USpawnStatusEffectsOnKillerAddon");
static_assert(offsetof(USpawnStatusEffectsOnKillerAddon, _statusEffectsToSpawn) == 0x000300, "Member 'USpawnStatusEffectsOnKillerAddon::_statusEffectsToSpawn' has a wrong offset!");
static_assert(offsetof(USpawnStatusEffectsOnKillerAddon, _imposedStatusEffects) == 0x000310, "Member 'USpawnStatusEffectsOnKillerAddon::_imposedStatusEffects' has a wrong offset!");

// Class DBDCompetence.SpiesFromTheShadows
// 0x0008 (0x0468 - 0x0460)
class USpiesFromTheShadows final : public UPerk
{
public:
	float                                         _cooldownDurationSecs;                             // 0x0460(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_464[0x4];                                      // 0x0464(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetCooldownDuration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpiesFromTheShadows">();
	}
	static class USpiesFromTheShadows* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpiesFromTheShadows>();
	}
};
static_assert(alignof(USpiesFromTheShadows) == 0x000008, "Wrong alignment on USpiesFromTheShadows");
static_assert(sizeof(USpiesFromTheShadows) == 0x000468, "Wrong size on USpiesFromTheShadows");
static_assert(offsetof(USpiesFromTheShadows, _cooldownDurationSecs) == 0x000460, "Member 'USpiesFromTheShadows::_cooldownDurationSecs' has a wrong offset!");

// Class DBDCompetence.SpineChillPerk
// 0x0080 (0x04E0 - 0x0460)
class USpineChillPerk final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _spineChillEffectClass;                            // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _actionSpeed[0x3];                                 // 0x0468(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _lingerDuration;                                   // 0x0474(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _range;                                            // 0x0478(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _precisionAngleDegrees;                            // 0x047C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isInRange;                                        // 0x0480(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_481[0x5F];                                     // 0x0481(0x005F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnInRangeChanged(const bool inRange);
	void Authority_OnIsInLineOfSightChanged(const bool isInLineOfSight);
	void Authority_OnIsLookingTowardsChanged(const bool IsLookingTowards_0);

	float GetLingerDuration() const;
	float GetRange() const;
	bool HasLineOfSight() const;
	bool IsInRange() const;
	bool IsLookingTowards() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpineChillPerk">();
	}
	static class USpineChillPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpineChillPerk>();
	}
};
static_assert(alignof(USpineChillPerk) == 0x000008, "Wrong alignment on USpineChillPerk");
static_assert(sizeof(USpineChillPerk) == 0x0004E0, "Wrong size on USpineChillPerk");
static_assert(offsetof(USpineChillPerk, _spineChillEffectClass) == 0x000460, "Member 'USpineChillPerk::_spineChillEffectClass' has a wrong offset!");
static_assert(offsetof(USpineChillPerk, _actionSpeed) == 0x000468, "Member 'USpineChillPerk::_actionSpeed' has a wrong offset!");
static_assert(offsetof(USpineChillPerk, _lingerDuration) == 0x000474, "Member 'USpineChillPerk::_lingerDuration' has a wrong offset!");
static_assert(offsetof(USpineChillPerk, _range) == 0x000478, "Member 'USpineChillPerk::_range' has a wrong offset!");
static_assert(offsetof(USpineChillPerk, _precisionAngleDegrees) == 0x00047C, "Member 'USpineChillPerk::_precisionAngleDegrees' has a wrong offset!");
static_assert(offsetof(USpineChillPerk, _isInRange) == 0x000480, "Member 'USpineChillPerk::_isInRange' has a wrong offset!");

// Class DBDCompetence.SprintBurst
// 0x0028 (0x0488 - 0x0460)
class USprintBurst final : public UPerk
{
public:
	float                                         _exhaustionDuration[0x3];                          // 0x0460(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _sprintDuration;                                   // 0x046C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _exhaustedEffectClass;                             // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStatusEffect*                          _exhaustedEffect;                                  // 0x0478(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_480[0x8];                                      // 0x0480(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnIsRunningAndMovingChanged(const bool isRunningAndMoving);
	void Authority_OnPerkFlagsChanged(const struct FGameplayTag& GameplayTag, bool isAdded);

	float GetExhaustedDuration() const;
	float GetSprintDuration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SprintBurst">();
	}
	static class USprintBurst* GetDefaultObj()
	{
		return GetDefaultObjImpl<USprintBurst>();
	}
};
static_assert(alignof(USprintBurst) == 0x000008, "Wrong alignment on USprintBurst");
static_assert(sizeof(USprintBurst) == 0x000488, "Wrong size on USprintBurst");
static_assert(offsetof(USprintBurst, _exhaustionDuration) == 0x000460, "Member 'USprintBurst::_exhaustionDuration' has a wrong offset!");
static_assert(offsetof(USprintBurst, _sprintDuration) == 0x00046C, "Member 'USprintBurst::_sprintDuration' has a wrong offset!");
static_assert(offsetof(USprintBurst, _exhaustedEffectClass) == 0x000470, "Member 'USprintBurst::_exhaustedEffectClass' has a wrong offset!");
static_assert(offsetof(USprintBurst, _exhaustedEffect) == 0x000478, "Member 'USprintBurst::_exhaustedEffect' has a wrong offset!");

// Class DBDCompetence.StakeOutPerk
// 0x0048 (0x04A8 - 0x0460)
class UStakeOutPerk final : public UPerk
{
public:
	uint8                                         Pad_460[0x18];                                     // 0x0460(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _stakeOutStatusEffectClass;                        // 0x0478(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStatusEffect*                          _stakeOutStatusEffect;                             // 0x0480(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _maxTokensByLevel[0x3];                            // 0x0488(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _tokenChargeTime;                                  // 0x0494(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_498[0x10];                                     // 0x0498(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Local_BroadcastConsumeToken();
	void Server_ConsumeToken();

	float GetMaxTokensAtLevel() const;
	float GetTokenChargeTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StakeOutPerk">();
	}
	static class UStakeOutPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStakeOutPerk>();
	}
};
static_assert(alignof(UStakeOutPerk) == 0x000008, "Wrong alignment on UStakeOutPerk");
static_assert(sizeof(UStakeOutPerk) == 0x0004A8, "Wrong size on UStakeOutPerk");
static_assert(offsetof(UStakeOutPerk, _stakeOutStatusEffectClass) == 0x000478, "Member 'UStakeOutPerk::_stakeOutStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UStakeOutPerk, _stakeOutStatusEffect) == 0x000480, "Member 'UStakeOutPerk::_stakeOutStatusEffect' has a wrong offset!");
static_assert(offsetof(UStakeOutPerk, _maxTokensByLevel) == 0x000488, "Member 'UStakeOutPerk::_maxTokensByLevel' has a wrong offset!");
static_assert(offsetof(UStakeOutPerk, _tokenChargeTime) == 0x000494, "Member 'UStakeOutPerk::_tokenChargeTime' has a wrong offset!");

// Class DBDCompetence.StatsSystemUtilities
// 0x0000 (0x0030 - 0x0030)
class UStatsSystemUtilities final : public UBlueprintFunctionLibrary
{
public:
	static float GetStatValueBP(const struct FTunableStat& theStat);
	static void InitStatBP(struct FTunableStat& theStat, TScriptInterface<class IModifierProvider> ModifierProvider);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatsSystemUtilities">();
	}
	static class UStatsSystemUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatsSystemUtilities>();
	}
};
static_assert(alignof(UStatsSystemUtilities) == 0x000008, "Wrong alignment on UStatsSystemUtilities");
static_assert(sizeof(UStatsSystemUtilities) == 0x000030, "Wrong size on UStatsSystemUtilities");

// Class DBDCompetence.StatusEffectCustomParamValueStrategy
// 0x0000 (0x0090 - 0x0090)
class UStatusEffectCustomParamValueStrategy final : public UFloatValueStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusEffectCustomParamValueStrategy">();
	}
	static class UStatusEffectCustomParamValueStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatusEffectCustomParamValueStrategy>();
	}
};
static_assert(alignof(UStatusEffectCustomParamValueStrategy) == 0x000008, "Wrong alignment on UStatusEffectCustomParamValueStrategy");
static_assert(sizeof(UStatusEffectCustomParamValueStrategy) == 0x000090, "Wrong size on UStatusEffectCustomParamValueStrategy");

// Class DBDCompetence.StatusEffectOriginatorSubjectProvider
// 0x0000 (0x0048 - 0x0048)
class UStatusEffectOriginatorSubjectProvider final : public UModifierSubjectProvider
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusEffectOriginatorSubjectProvider">();
	}
	static class UStatusEffectOriginatorSubjectProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatusEffectOriginatorSubjectProvider>();
	}
};
static_assert(alignof(UStatusEffectOriginatorSubjectProvider) == 0x000008, "Wrong alignment on UStatusEffectOriginatorSubjectProvider");
static_assert(sizeof(UStatusEffectOriginatorSubjectProvider) == 0x000048, "Wrong size on UStatusEffectOriginatorSubjectProvider");

// Class DBDCompetence.Surge
// 0x0038 (0x0498 - 0x0460)
class USurge final : public UPerk
{
public:
	float                                         _zoneRadius[0x3];                                  // 0x0460(0x0004)(Edit, EditFixedSize, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _instantRegression[0x3];                           // 0x046C(0x0004)(Edit, EditFixedSize, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _cooldownDuration[0x3];                            // 0x0478(0x0004)(Edit, EditFixedSize, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasCooldown;                                      // 0x0484(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _useTerrorRadiusInsteadOfFixedDistance;            // 0x0485(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_486[0x12];                                     // 0x0486(0x0012)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const float GetCooldownDurationAtLevel() const;
	const bool GetHasCooldown() const;
	const float GetInstantRegressionAtLevel() const;
	float GetZoneRadius() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Surge">();
	}
	static class USurge* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurge>();
	}
};
static_assert(alignof(USurge) == 0x000008, "Wrong alignment on USurge");
static_assert(sizeof(USurge) == 0x000498, "Wrong size on USurge");
static_assert(offsetof(USurge, _zoneRadius) == 0x000460, "Member 'USurge::_zoneRadius' has a wrong offset!");
static_assert(offsetof(USurge, _instantRegression) == 0x00046C, "Member 'USurge::_instantRegression' has a wrong offset!");
static_assert(offsetof(USurge, _cooldownDuration) == 0x000478, "Member 'USurge::_cooldownDuration' has a wrong offset!");
static_assert(offsetof(USurge, _hasCooldown) == 0x000484, "Member 'USurge::_hasCooldown' has a wrong offset!");
static_assert(offsetof(USurge, _useTerrorRadiusInsteadOfFixedDistance) == 0x000485, "Member 'USurge::_useTerrorRadiusInsteadOfFixedDistance' has a wrong offset!");

// Class DBDCompetence.SurvivorIsAtHookStage
// 0x0008 (0x00F8 - 0x00F0)
class USurvivorIsAtHookStage final : public UEventDrivenModifierCondition
{
public:
	EHookDrainStage                               _hookStage;                                        // 0x00F0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorIsAtHookStage">();
	}
	static class USurvivorIsAtHookStage* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorIsAtHookStage>();
	}
};
static_assert(alignof(USurvivorIsAtHookStage) == 0x000008, "Wrong alignment on USurvivorIsAtHookStage");
static_assert(sizeof(USurvivorIsAtHookStage) == 0x0000F8, "Wrong size on USurvivorIsAtHookStage");
static_assert(offsetof(USurvivorIsAtHookStage, _hookStage) == 0x0000F0, "Member 'USurvivorIsAtHookStage::_hookStage' has a wrong offset!");

// Class DBDCompetence.SurvivorScreamAction
// 0x0018 (0x0058 - 0x0040)
class USurvivorScreamAction final : public UCompetenceAction
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _makeInstigatorScream;                             // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _makeTargetScream;                                 // 0x0049(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A[0x2];                                       // 0x004A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _screamDuration;                                   // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _spawnBubbleIndicator;                             // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorScreamAction">();
	}
	static class USurvivorScreamAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorScreamAction>();
	}
};
static_assert(alignof(USurvivorScreamAction) == 0x000008, "Wrong alignment on USurvivorScreamAction");
static_assert(sizeof(USurvivorScreamAction) == 0x000058, "Wrong size on USurvivorScreamAction");
static_assert(offsetof(USurvivorScreamAction, _makeInstigatorScream) == 0x000048, "Member 'USurvivorScreamAction::_makeInstigatorScream' has a wrong offset!");
static_assert(offsetof(USurvivorScreamAction, _makeTargetScream) == 0x000049, "Member 'USurvivorScreamAction::_makeTargetScream' has a wrong offset!");
static_assert(offsetof(USurvivorScreamAction, _screamDuration) == 0x00004C, "Member 'USurvivorScreamAction::_screamDuration' has a wrong offset!");
static_assert(offsetof(USurvivorScreamAction, _spawnBubbleIndicator) == 0x000050, "Member 'USurvivorScreamAction::_spawnBubbleIndicator' has a wrong offset!");

// Class DBDCompetence.SurvivorWasRecentlyUnhookedEffect
// 0x0028 (0x03C0 - 0x0398)
class USurvivorWasRecentlyUnhookedEffect final : public UStatusEffect
{
public:
	struct FDBDTunableRowHandle                   _survivorWasRecentlyUnhookedDuration;              // 0x0398(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorWasRecentlyUnhookedEffect">();
	}
	static class USurvivorWasRecentlyUnhookedEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorWasRecentlyUnhookedEffect>();
	}
};
static_assert(alignof(USurvivorWasRecentlyUnhookedEffect) == 0x000008, "Wrong alignment on USurvivorWasRecentlyUnhookedEffect");
static_assert(sizeof(USurvivorWasRecentlyUnhookedEffect) == 0x0003C0, "Wrong size on USurvivorWasRecentlyUnhookedEffect");
static_assert(offsetof(USurvivorWasRecentlyUnhookedEffect, _survivorWasRecentlyUnhookedDuration) == 0x000398, "Member 'USurvivorWasRecentlyUnhookedEffect::_survivorWasRecentlyUnhookedDuration' has a wrong offset!");

// Class DBDCompetence.TestAnyActorPairQueryRangeIsTrue
// 0x0008 (0x0110 - 0x0108)
class UTestAnyActorPairQueryRangeIsTrue final : public UAnyActorPairQueryRangeIsTrue
{
public:
	class UActorPairQueryEvaluatorComponent*      _actorPairQueryEvaluatorComponent;                 // 0x0108(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestAnyActorPairQueryRangeIsTrue">();
	}
	static class UTestAnyActorPairQueryRangeIsTrue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestAnyActorPairQueryRangeIsTrue>();
	}
};
static_assert(alignof(UTestAnyActorPairQueryRangeIsTrue) == 0x000008, "Wrong alignment on UTestAnyActorPairQueryRangeIsTrue");
static_assert(sizeof(UTestAnyActorPairQueryRangeIsTrue) == 0x000110, "Wrong size on UTestAnyActorPairQueryRangeIsTrue");
static_assert(offsetof(UTestAnyActorPairQueryRangeIsTrue, _actorPairQueryEvaluatorComponent) == 0x000108, "Member 'UTestAnyActorPairQueryRangeIsTrue::_actorPairQueryEvaluatorComponent' has a wrong offset!");

// Class DBDCompetence.TestCollectable
// 0x0000 (0x0558 - 0x0558)
class ATestCollectable final : public ACollectable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestCollectable">();
	}
	static class ATestCollectable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATestCollectable>();
	}
};
static_assert(alignof(ATestCollectable) == 0x000008, "Wrong alignment on ATestCollectable");
static_assert(sizeof(ATestCollectable) == 0x000558, "Wrong size on ATestCollectable");

// Class DBDCompetence.TestDBDGameState
// 0x0000 (0x0A90 - 0x0A90)
class ATestDBDGameState final : public ADBDGameState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestDBDGameState">();
	}
	static class ATestDBDGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATestDBDGameState>();
	}
};
static_assert(alignof(ATestDBDGameState) == 0x000008, "Wrong alignment on ATestDBDGameState");
static_assert(sizeof(ATestDBDGameState) == 0x000A90, "Wrong size on ATestDBDGameState");

// Class DBDCompetence.TheMettleOfMan
// 0x0058 (0x04B8 - 0x0460)
class UTheMettleOfMan final : public UPerk
{
public:
	int32                                         _tokenNeededToActivate[0x3];                       // 0x0460(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _revealOutsideRange[0x3];                          // 0x046C(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _mustBeInjured;                                    // 0x0478(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_479[0x7];                                      // 0x0479(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _enduranceHighlightEffectClass;                    // 0x0480(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _revealToKillerEffectClass;                        // 0x0488(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _numTokenSoFar;                                    // 0x0490(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETheMettleOfManPhase                          _currentPhase;                                     // 0x0494(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_495[0xB];                                      // 0x0495(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffect*                          _revealToKillerEffect;                             // 0x04A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A8[0x10];                                     // 0x04A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_CurrentPhase();
	void OnRep_NumTokenSoFar();

	float GetRevealOutsideRangeAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TheMettleOfMan">();
	}
	static class UTheMettleOfMan* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTheMettleOfMan>();
	}
};
static_assert(alignof(UTheMettleOfMan) == 0x000008, "Wrong alignment on UTheMettleOfMan");
static_assert(sizeof(UTheMettleOfMan) == 0x0004B8, "Wrong size on UTheMettleOfMan");
static_assert(offsetof(UTheMettleOfMan, _tokenNeededToActivate) == 0x000460, "Member 'UTheMettleOfMan::_tokenNeededToActivate' has a wrong offset!");
static_assert(offsetof(UTheMettleOfMan, _revealOutsideRange) == 0x00046C, "Member 'UTheMettleOfMan::_revealOutsideRange' has a wrong offset!");
static_assert(offsetof(UTheMettleOfMan, _mustBeInjured) == 0x000478, "Member 'UTheMettleOfMan::_mustBeInjured' has a wrong offset!");
static_assert(offsetof(UTheMettleOfMan, _enduranceHighlightEffectClass) == 0x000480, "Member 'UTheMettleOfMan::_enduranceHighlightEffectClass' has a wrong offset!");
static_assert(offsetof(UTheMettleOfMan, _revealToKillerEffectClass) == 0x000488, "Member 'UTheMettleOfMan::_revealToKillerEffectClass' has a wrong offset!");
static_assert(offsetof(UTheMettleOfMan, _numTokenSoFar) == 0x000490, "Member 'UTheMettleOfMan::_numTokenSoFar' has a wrong offset!");
static_assert(offsetof(UTheMettleOfMan, _currentPhase) == 0x000494, "Member 'UTheMettleOfMan::_currentPhase' has a wrong offset!");
static_assert(offsetof(UTheMettleOfMan, _revealToKillerEffect) == 0x0004A0, "Member 'UTheMettleOfMan::_revealToKillerEffect' has a wrong offset!");

// Class DBDCompetence.TimedObliviousEffect
// 0x0000 (0x03A8 - 0x03A8)
class UTimedObliviousEffect final : public UObliviousEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimedObliviousEffect">();
	}
	static class UTimedObliviousEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimedObliviousEffect>();
	}
};
static_assert(alignof(UTimedObliviousEffect) == 0x000008, "Wrong alignment on UTimedObliviousEffect");
static_assert(sizeof(UTimedObliviousEffect) == 0x0003A8, "Wrong size on UTimedObliviousEffect");

// Class DBDCompetence.TimerElapsedCondition
// 0x0018 (0x0118 - 0x0100)
class UTimerElapsedCondition final : public USingleModifierCondition
{
public:
	class UTimerObject*                           _timer;                                            // 0x0100(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x10];                                     // 0x0108(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimerElapsedCondition">();
	}
	static class UTimerElapsedCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimerElapsedCondition>();
	}
};
static_assert(alignof(UTimerElapsedCondition) == 0x000008, "Wrong alignment on UTimerElapsedCondition");
static_assert(sizeof(UTimerElapsedCondition) == 0x000118, "Wrong size on UTimerElapsedCondition");
static_assert(offsetof(UTimerElapsedCondition, _timer) == 0x000100, "Member 'UTimerElapsedCondition::_timer' has a wrong offset!");

// Class DBDCompetence.Tinkerer
// 0x0078 (0x04D8 - 0x0460)
class UTinkerer final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _undetectableEffectClass;                          // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _triggerThreshold;                                 // 0x0468(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _distanceThreshold;                                // 0x046C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _activationTime[0x3];                              // 0x0470(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_47C[0x4];                                      // 0x047C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AActor*, float>                    _generatorActivationTimes;                         // 0x0480(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D0[0x8];                                      // 0x04D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnGeneratorChargePercentChanged(class UChargeableComponent* ChargeableComponent, float PercentCompletionChange, float TotalPercentComplete);
	void Authority_OnGeneratorReachedThreshold(class AGenerator* Generator);
	void Authority_OnLevelReadyToPlay();
	void Authority_OnUndetectableAttackSuccessNearActiveGenerator(class ADBDPlayer* Instigator, class ADBDPlayer* Target);
	void Authority_OnUndetectableGeneratorInterrupt(class ADBDPlayer* Instigator, class ADBDPlayer* Target);

	float GetActivationTimeAtLevel() const;
	float GetTriggerThreshold() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Tinkerer">();
	}
	static class UTinkerer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTinkerer>();
	}
};
static_assert(alignof(UTinkerer) == 0x000008, "Wrong alignment on UTinkerer");
static_assert(sizeof(UTinkerer) == 0x0004D8, "Wrong size on UTinkerer");
static_assert(offsetof(UTinkerer, _undetectableEffectClass) == 0x000460, "Member 'UTinkerer::_undetectableEffectClass' has a wrong offset!");
static_assert(offsetof(UTinkerer, _triggerThreshold) == 0x000468, "Member 'UTinkerer::_triggerThreshold' has a wrong offset!");
static_assert(offsetof(UTinkerer, _distanceThreshold) == 0x00046C, "Member 'UTinkerer::_distanceThreshold' has a wrong offset!");
static_assert(offsetof(UTinkerer, _activationTime) == 0x000470, "Member 'UTinkerer::_activationTime' has a wrong offset!");
static_assert(offsetof(UTinkerer, _generatorActivationTimes) == 0x000480, "Member 'UTinkerer::_generatorActivationTimes' has a wrong offset!");

// Class DBDCompetence.TriggerActivationTimerAction
// 0x0018 (0x0058 - 0x0040)
class UTriggerActivationTimerAction final : public UCompetenceAction
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _shouldReactivateIfActive;                         // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFloatValueStrategy*                    _valueStrategy;                                    // 0x0050(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TriggerActivationTimerAction">();
	}
	static class UTriggerActivationTimerAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTriggerActivationTimerAction>();
	}
};
static_assert(alignof(UTriggerActivationTimerAction) == 0x000008, "Wrong alignment on UTriggerActivationTimerAction");
static_assert(sizeof(UTriggerActivationTimerAction) == 0x000058, "Wrong size on UTriggerActivationTimerAction");
static_assert(offsetof(UTriggerActivationTimerAction, _shouldReactivateIfActive) == 0x000048, "Member 'UTriggerActivationTimerAction::_shouldReactivateIfActive' has a wrong offset!");
static_assert(offsetof(UTriggerActivationTimerAction, _valueStrategy) == 0x000050, "Member 'UTriggerActivationTimerAction::_valueStrategy' has a wrong offset!");

// Class DBDCompetence.TriggerCooldownTimerAction
// 0x0010 (0x0050 - 0x0040)
class UTriggerCooldownTimerAction final : public UCompetenceAction
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFloatValueStrategy*                    _valueStrategy;                                    // 0x0048(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TriggerCooldownTimerAction">();
	}
	static class UTriggerCooldownTimerAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTriggerCooldownTimerAction>();
	}
};
static_assert(alignof(UTriggerCooldownTimerAction) == 0x000008, "Wrong alignment on UTriggerCooldownTimerAction");
static_assert(sizeof(UTriggerCooldownTimerAction) == 0x000050, "Wrong size on UTriggerCooldownTimerAction");
static_assert(offsetof(UTriggerCooldownTimerAction, _valueStrategy) == 0x000048, "Member 'UTriggerCooldownTimerAction::_valueStrategy' has a wrong offset!");

// Class DBDCompetence.TriggerLingeringActivationAction
// 0x0008 (0x0048 - 0x0040)
class UTriggerLingeringActivationAction final : public UCompetenceAction
{
public:
	class UFloatValueStrategy*                    _valueStrategy;                                    // 0x0040(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TriggerLingeringActivationAction">();
	}
	static class UTriggerLingeringActivationAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTriggerLingeringActivationAction>();
	}
};
static_assert(alignof(UTriggerLingeringActivationAction) == 0x000008, "Wrong alignment on UTriggerLingeringActivationAction");
static_assert(sizeof(UTriggerLingeringActivationAction) == 0x000048, "Wrong size on UTriggerLingeringActivationAction");
static_assert(offsetof(UTriggerLingeringActivationAction, _valueStrategy) == 0x000040, "Member 'UTriggerLingeringActivationAction::_valueStrategy' has a wrong offset!");

// Class DBDCompetence.UnhookedMovementSpeedBonusEffect
// 0x0088 (0x0420 - 0x0398)
class UUnhookedMovementSpeedBonusEffect final : public UStatusEffect
{
public:
	struct FTunableStat                           _unhookHasteSpeedStat;                             // 0x0398(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_418[0x8];                                      // 0x0418(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnhookedMovementSpeedBonusEffect">();
	}
	static class UUnhookedMovementSpeedBonusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnhookedMovementSpeedBonusEffect>();
	}
};
static_assert(alignof(UUnhookedMovementSpeedBonusEffect) == 0x000008, "Wrong alignment on UUnhookedMovementSpeedBonusEffect");
static_assert(sizeof(UUnhookedMovementSpeedBonusEffect) == 0x000420, "Wrong size on UUnhookedMovementSpeedBonusEffect");
static_assert(offsetof(UUnhookedMovementSpeedBonusEffect, _unhookHasteSpeedStat) == 0x000398, "Member 'UUnhookedMovementSpeedBonusEffect::_unhookHasteSpeedStat' has a wrong offset!");

// Class DBDCompetence.UnhookEnduranceEffect
// 0x0000 (0x03A8 - 0x03A8)
class UUnhookEnduranceEffect final : public UEnduranceEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnhookEnduranceEffect">();
	}
	static class UUnhookEnduranceEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnhookEnduranceEffect>();
	}
};
static_assert(alignof(UUnhookEnduranceEffect) == 0x000008, "Wrong alignment on UUnhookEnduranceEffect");
static_assert(sizeof(UUnhookEnduranceEffect) == 0x0003A8, "Wrong size on UUnhookEnduranceEffect");

// Class DBDCompetence.WakeUpOpenExitGateEffect
// 0x0030 (0x03C8 - 0x0398)
class UWakeUpOpenExitGateEffect final : public UStatusEffect
{
public:
	uint8                                         Pad_398[0x30];                                     // 0x0398(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WakeUpOpenExitGateEffect">();
	}
	static class UWakeUpOpenExitGateEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWakeUpOpenExitGateEffect>();
	}
};
static_assert(alignof(UWakeUpOpenExitGateEffect) == 0x000008, "Wrong alignment on UWakeUpOpenExitGateEffect");
static_assert(sizeof(UWakeUpOpenExitGateEffect) == 0x0003C8, "Wrong size on UWakeUpOpenExitGateEffect");

// Class DBDCompetence.WakeUpPerk
// 0x0028 (0x0488 - 0x0460)
class UWakeUpPerk final : public UPerk
{
public:
	float                                         _gateOpenSpeed[0x3];                               // 0x0460(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_46C[0x4];                                      // 0x046C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _wakeUpShowExitGateAuraEffectClass;                // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _wakeUpShowPlayerOnGateAuraEffectClass;            // 0x0478(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _wakeUpOpenGateEffectClass;                        // 0x0480(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WakeUpPerk">();
	}
	static class UWakeUpPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWakeUpPerk>();
	}
};
static_assert(alignof(UWakeUpPerk) == 0x000008, "Wrong alignment on UWakeUpPerk");
static_assert(sizeof(UWakeUpPerk) == 0x000488, "Wrong size on UWakeUpPerk");
static_assert(offsetof(UWakeUpPerk, _gateOpenSpeed) == 0x000460, "Member 'UWakeUpPerk::_gateOpenSpeed' has a wrong offset!");
static_assert(offsetof(UWakeUpPerk, _wakeUpShowExitGateAuraEffectClass) == 0x000470, "Member 'UWakeUpPerk::_wakeUpShowExitGateAuraEffectClass' has a wrong offset!");
static_assert(offsetof(UWakeUpPerk, _wakeUpShowPlayerOnGateAuraEffectClass) == 0x000478, "Member 'UWakeUpPerk::_wakeUpShowPlayerOnGateAuraEffectClass' has a wrong offset!");
static_assert(offsetof(UWakeUpPerk, _wakeUpOpenGateEffectClass) == 0x000480, "Member 'UWakeUpPerk::_wakeUpOpenGateEffectClass' has a wrong offset!");

// Class DBDCompetence.WeddingRing
// 0x0010 (0x0310 - 0x0300)
class UWeddingRing final : public UItemAddon
{
public:
	TSubclassOf<class UStatusEffect>              _increaseObsessionChanceStatusEffect;              // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeddingRing">();
	}
	static class UWeddingRing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeddingRing>();
	}
};
static_assert(alignof(UWeddingRing) == 0x000008, "Wrong alignment on UWeddingRing");
static_assert(sizeof(UWeddingRing) == 0x000310, "Wrong size on UWeddingRing");
static_assert(offsetof(UWeddingRing, _increaseObsessionChanceStatusEffect) == 0x000300, "Member 'UWeddingRing::_increaseObsessionChanceStatusEffect' has a wrong offset!");

// Class DBDCompetence.WellMakeIt
// 0x0020 (0x0480 - 0x0460)
class UWellMakeIt final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _wellMakeItNotificationEffectClass;                // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _wellMakeItEffectClass;                            // 0x0468(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _healingSpeed;                                     // 0x0470(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _perkDuration[0x3];                                // 0x0474(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnUnHook(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData);

	float GetHealingSpeed() const;
	float GetPerkDurationAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WellMakeIt">();
	}
	static class UWellMakeIt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWellMakeIt>();
	}
};
static_assert(alignof(UWellMakeIt) == 0x000008, "Wrong alignment on UWellMakeIt");
static_assert(sizeof(UWellMakeIt) == 0x000480, "Wrong size on UWellMakeIt");
static_assert(offsetof(UWellMakeIt, _wellMakeItNotificationEffectClass) == 0x000460, "Member 'UWellMakeIt::_wellMakeItNotificationEffectClass' has a wrong offset!");
static_assert(offsetof(UWellMakeIt, _wellMakeItEffectClass) == 0x000468, "Member 'UWellMakeIt::_wellMakeItEffectClass' has a wrong offset!");
static_assert(offsetof(UWellMakeIt, _healingSpeed) == 0x000470, "Member 'UWellMakeIt::_healingSpeed' has a wrong offset!");
static_assert(offsetof(UWellMakeIt, _perkDuration) == 0x000474, "Member 'UWellMakeIt::_perkDuration' has a wrong offset!");

// Class DBDCompetence.WereGonnaLiveForever
// 0x0040 (0x04A0 - 0x0460)
class UWereGonnaLiveForever final : public UPerk
{
public:
	float                                         _healSpeedIncrease;                                // 0x0460(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _enduranceEffectDuration[0x3];                     // 0x0464(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _enduranceCooldownDuration[0x3];                   // 0x0470(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_47C[0x4];                                      // 0x047C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _healSpeedFromDyingStatusEffectClass;              // 0x0480(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _enduranceEffectClass;                             // 0x0488(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _playerBeingHealedIndicatorEffectClass;            // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_498[0x8];                                      // 0x0498(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WereGonnaLiveForever">();
	}
	static class UWereGonnaLiveForever* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWereGonnaLiveForever>();
	}
};
static_assert(alignof(UWereGonnaLiveForever) == 0x000008, "Wrong alignment on UWereGonnaLiveForever");
static_assert(sizeof(UWereGonnaLiveForever) == 0x0004A0, "Wrong size on UWereGonnaLiveForever");
static_assert(offsetof(UWereGonnaLiveForever, _healSpeedIncrease) == 0x000460, "Member 'UWereGonnaLiveForever::_healSpeedIncrease' has a wrong offset!");
static_assert(offsetof(UWereGonnaLiveForever, _enduranceEffectDuration) == 0x000464, "Member 'UWereGonnaLiveForever::_enduranceEffectDuration' has a wrong offset!");
static_assert(offsetof(UWereGonnaLiveForever, _enduranceCooldownDuration) == 0x000470, "Member 'UWereGonnaLiveForever::_enduranceCooldownDuration' has a wrong offset!");
static_assert(offsetof(UWereGonnaLiveForever, _healSpeedFromDyingStatusEffectClass) == 0x000480, "Member 'UWereGonnaLiveForever::_healSpeedFromDyingStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UWereGonnaLiveForever, _enduranceEffectClass) == 0x000488, "Member 'UWereGonnaLiveForever::_enduranceEffectClass' has a wrong offset!");
static_assert(offsetof(UWereGonnaLiveForever, _playerBeingHealedIndicatorEffectClass) == 0x000490, "Member 'UWereGonnaLiveForever::_playerBeingHealedIndicatorEffectClass' has a wrong offset!");

// Class DBDCompetence.Whispers
// 0x0090 (0x04F0 - 0x0460)
class UWhispers final : public UPerk
{
public:
	float                                         _timeBetweenAudio;                                 // 0x0460(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_464[0x34];                                     // 0x0464(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _survivorsInRange;                                 // 0x0498(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49C[0x54];                                     // 0x049C(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_FireAudioEvent(const int32 survivorsInRange);
	void OnRep_SurvivorsInRange();
	void OnWhispersAudio();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Whispers">();
	}
	static class UWhispers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWhispers>();
	}
};
static_assert(alignof(UWhispers) == 0x000008, "Wrong alignment on UWhispers");
static_assert(sizeof(UWhispers) == 0x0004F0, "Wrong size on UWhispers");
static_assert(offsetof(UWhispers, _timeBetweenAudio) == 0x000460, "Member 'UWhispers::_timeBetweenAudio' has a wrong offset!");
static_assert(offsetof(UWhispers, _survivorsInRange) == 0x000498, "Member 'UWhispers::_survivorsInRange' has a wrong offset!");

// Class DBDCompetence.YamaokaFamilyCrest
// 0x0038 (0x0338 - 0x0300)
class UYamaokaFamilyCrest final : public UItemAddon
{
public:
	float                                         _revealDuration;                                   // 0x0300(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _revealRange;                                      // 0x0304(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _revealAuraToKillerEffectClass;                    // 0x0308(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ASurvivor*>                      _survivorsToReveal;                                // 0x0310(0x0010)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         _addonActivationCount;                             // 0x0320(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_321[0x17];                                     // 0x0321(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_AddonActivationCount();
	void RevealSurvivor(class ASurvivor* survivorToReveal);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"YamaokaFamilyCrest">();
	}
	static class UYamaokaFamilyCrest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UYamaokaFamilyCrest>();
	}
};
static_assert(alignof(UYamaokaFamilyCrest) == 0x000008, "Wrong alignment on UYamaokaFamilyCrest");
static_assert(sizeof(UYamaokaFamilyCrest) == 0x000338, "Wrong size on UYamaokaFamilyCrest");
static_assert(offsetof(UYamaokaFamilyCrest, _revealDuration) == 0x000300, "Member 'UYamaokaFamilyCrest::_revealDuration' has a wrong offset!");
static_assert(offsetof(UYamaokaFamilyCrest, _revealRange) == 0x000304, "Member 'UYamaokaFamilyCrest::_revealRange' has a wrong offset!");
static_assert(offsetof(UYamaokaFamilyCrest, _revealAuraToKillerEffectClass) == 0x000308, "Member 'UYamaokaFamilyCrest::_revealAuraToKillerEffectClass' has a wrong offset!");
static_assert(offsetof(UYamaokaFamilyCrest, _survivorsToReveal) == 0x000310, "Member 'UYamaokaFamilyCrest::_survivorsToReveal' has a wrong offset!");
static_assert(offsetof(UYamaokaFamilyCrest, _addonActivationCount) == 0x000320, "Member 'UYamaokaFamilyCrest::_addonActivationCount' has a wrong offset!");

// Class DBDCompetence.ZanshinTactics
// 0x0018 (0x0478 - 0x0460)
class UZanshinTactics final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _revealSurvivorToKillerTimedStatusEffectClass;     // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _survivorAuraRevealDuration[0x3];                  // 0x0468(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_474[0x4];                                      // 0x0474(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetSurvivorAuraRevealDuration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZanshinTactics">();
	}
	static class UZanshinTactics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZanshinTactics>();
	}
};
static_assert(alignof(UZanshinTactics) == 0x000008, "Wrong alignment on UZanshinTactics");
static_assert(sizeof(UZanshinTactics) == 0x000478, "Wrong size on UZanshinTactics");
static_assert(offsetof(UZanshinTactics, _revealSurvivorToKillerTimedStatusEffectClass) == 0x000460, "Member 'UZanshinTactics::_revealSurvivorToKillerTimedStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UZanshinTactics, _survivorAuraRevealDuration) == 0x000468, "Member 'UZanshinTactics::_survivorAuraRevealDuration' has a wrong offset!");

}

