#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheHag

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Competence_classes.hpp"
#include "DBDAnimation_classes.hpp"
#include "DBDInteraction_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "DataTableUtilities_structs.hpp"
#include "DBDGameplay_classes.hpp"
#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"


namespace SDK
{

// Class TheHag.PhantomTrap
// 0x00F8 (0x04A0 - 0x03A8)
class APhantomTrap final : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x18];                                     // 0x03A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _phantomHasCollision;                              // 0x03C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _silentTrapTrigger;                                // 0x03C1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDeactivating;                                   // 0x03C2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C3[0x5];                                      // 0x03C3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _slowdownInTrapZoneEffect;                         // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTerrorRadiusEmitterComponent*          _terrorRadiusEmitter;                              // 0x03D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _camperOutlineDuration;                            // 0x03D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _lineOfSightTraceMinInterval;                      // 0x03DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _speedTolerance;                                   // 0x03E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E4[0x4];                                      // 0x03E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        _trapLocation;                                     // 0x03E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       _triggerZone;                                      // 0x03F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UStatusEffect*>                  _survivorSlowdownEffects;                          // 0x03F8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _wipeAwayInteractionChargeable;                    // 0x0408(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWipeAwayPhantomTrapInteraction*        _wipeAwayInteraction;                              // 0x0410(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractor*                            _wipeAwayInteractor;                               // 0x0418(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPrimitiveComponent*                    _wipeAwayInteractionZone;                          // 0x0420(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _wipeAwayTimeDuration;                             // 0x0428(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_450[0xD];                                      // 0x0450(0x000D)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _hasTrapBeenSetOff;                                // 0x045D(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasTrapBeenDestroyed;                             // 0x045E(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isInUse;                                          // 0x045F(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTimer                              _activeTimer;                                      // 0x0460(0x0028)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPrivate)
	bool                                          _isSlasherHere;                                    // 0x0488(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_489[0x17];                                     // 0x0489(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateSlasher(class AKiller* Slasher);
	void Authority_OnTriggerZoneBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void Authority_OnTriggerZoneEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void BP_OnTrapActivate(class ASurvivor* triggerer);
	void BP_OnTrapDestroyed(class ASurvivor* playerDestroyingTrap, bool wipedAway);
	bool CanActivateTrap(class ASurvivor* Survivor, bool IsInUse);
	void InitializeTerrorRadiusEmitter(class AKiller* owningSlasher);
	void Multicast_DestroyTrap(class ASurvivor* playerDestroyingTrap, bool wipedAway);
	void OnTrapActivated();
	void OnTrapPlaced();
	void OnTrapReset();
	void RetrievePerkFlags(const struct FGameplayTag& silentTrapTag, const struct FGameplayTag& phantomCollisionTag);
	void SetIsInUse(bool InUse);

	class USkeletalMeshComponent* GetMesh() const;
	class USceneComponent* GetPhantomTransform() const;
	bool HasKillerTeleported() const;
	bool IsSilentTrigger() const;
	bool IsTrapActive() const;
	bool IsTrapDeactivating() const;
	bool IsTrapSet() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhantomTrap">();
	}
	static class APhantomTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<APhantomTrap>();
	}
};
static_assert(alignof(APhantomTrap) == 0x000008, "Wrong alignment on APhantomTrap");
static_assert(sizeof(APhantomTrap) == 0x0004A0, "Wrong size on APhantomTrap");
static_assert(offsetof(APhantomTrap, _phantomHasCollision) == 0x0003C0, "Member 'APhantomTrap::_phantomHasCollision' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _silentTrapTrigger) == 0x0003C1, "Member 'APhantomTrap::_silentTrapTrigger' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _isDeactivating) == 0x0003C2, "Member 'APhantomTrap::_isDeactivating' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _slowdownInTrapZoneEffect) == 0x0003C8, "Member 'APhantomTrap::_slowdownInTrapZoneEffect' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _terrorRadiusEmitter) == 0x0003D0, "Member 'APhantomTrap::_terrorRadiusEmitter' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _camperOutlineDuration) == 0x0003D8, "Member 'APhantomTrap::_camperOutlineDuration' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _lineOfSightTraceMinInterval) == 0x0003DC, "Member 'APhantomTrap::_lineOfSightTraceMinInterval' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _speedTolerance) == 0x0003E0, "Member 'APhantomTrap::_speedTolerance' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _trapLocation) == 0x0003E8, "Member 'APhantomTrap::_trapLocation' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _triggerZone) == 0x0003F0, "Member 'APhantomTrap::_triggerZone' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _survivorSlowdownEffects) == 0x0003F8, "Member 'APhantomTrap::_survivorSlowdownEffects' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _wipeAwayInteractionChargeable) == 0x000408, "Member 'APhantomTrap::_wipeAwayInteractionChargeable' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _wipeAwayInteraction) == 0x000410, "Member 'APhantomTrap::_wipeAwayInteraction' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _wipeAwayInteractor) == 0x000418, "Member 'APhantomTrap::_wipeAwayInteractor' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _wipeAwayInteractionZone) == 0x000420, "Member 'APhantomTrap::_wipeAwayInteractionZone' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _wipeAwayTimeDuration) == 0x000428, "Member 'APhantomTrap::_wipeAwayTimeDuration' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _hasTrapBeenSetOff) == 0x00045D, "Member 'APhantomTrap::_hasTrapBeenSetOff' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _hasTrapBeenDestroyed) == 0x00045E, "Member 'APhantomTrap::_hasTrapBeenDestroyed' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _isInUse) == 0x00045F, "Member 'APhantomTrap::_isInUse' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _activeTimer) == 0x000460, "Member 'APhantomTrap::_activeTimer' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _isSlasherHere) == 0x000488, "Member 'APhantomTrap::_isSlasherHere' has a wrong offset!");

// Class TheHag.HagAnimInstance
// 0x0000 (0x0720 - 0x0720)
class UHagAnimInstance final : public UKillerAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HagAnimInstance">();
	}
	static class UHagAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHagAnimInstance>();
	}
};
static_assert(alignof(UHagAnimInstance) == 0x000010, "Wrong alignment on UHagAnimInstance");
static_assert(sizeof(UHagAnimInstance) == 0x000720, "Wrong size on UHagAnimInstance");

// Class TheHag.HagDynamicAccessoryAnimInstance
// 0x0000 (0x0370 - 0x0370)
class UHagDynamicAccessoryAnimInstance final : public UDynamicAccessoryAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HagDynamicAccessoryAnimInstance">();
	}
	static class UHagDynamicAccessoryAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHagDynamicAccessoryAnimInstance>();
	}
};
static_assert(alignof(UHagDynamicAccessoryAnimInstance) == 0x000010, "Wrong alignment on UHagDynamicAccessoryAnimInstance");
static_assert(sizeof(UHagDynamicAccessoryAnimInstance) == 0x000370, "Wrong size on UHagDynamicAccessoryAnimInstance");

// Class TheHag.HagScoreComponent
// 0x00A8 (0x0160 - 0x00B8)
class UHagScoreComponent final : public UActorComponent
{
public:
	struct FDBDTunableRowHandle                   _trapAttackDuration;                               // 0x00B8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x80];                                      // 0x00E0(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnActorEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HagScoreComponent">();
	}
	static class UHagScoreComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHagScoreComponent>();
	}
};
static_assert(alignof(UHagScoreComponent) == 0x000008, "Wrong alignment on UHagScoreComponent");
static_assert(sizeof(UHagScoreComponent) == 0x000160, "Wrong size on UHagScoreComponent");
static_assert(offsetof(UHagScoreComponent, _trapAttackDuration) == 0x0000B8, "Member 'UHagScoreComponent::_trapAttackDuration' has a wrong offset!");

// Class TheHag.HasActivePhantomTrap
// 0x0018 (0x0108 - 0x00F0)
class UHasActivePhantomTrap final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_F0[0x18];                                      // 0x00F0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HasActivePhantomTrap">();
	}
	static class UHasActivePhantomTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHasActivePhantomTrap>();
	}
};
static_assert(alignof(UHasActivePhantomTrap) == 0x000008, "Wrong alignment on UHasActivePhantomTrap");
static_assert(sizeof(UHasActivePhantomTrap) == 0x000108, "Wrong size on UHasActivePhantomTrap");

// Class TheHag.K05AnimInstance
// 0x0000 (0x0720 - 0x0720)
class UK05AnimInstance final : public UKillerAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K05AnimInstance">();
	}
	static class UK05AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK05AnimInstance>();
	}
};
static_assert(alignof(UK05AnimInstance) == 0x000010, "Wrong alignment on UK05AnimInstance");
static_assert(sizeof(UK05AnimInstance) == 0x000720, "Wrong size on UK05AnimInstance");

// Class TheHag.K05Power
// 0x0060 (0x0670 - 0x0610)
class AK05Power final : public AKillerPower
{
public:
	struct FDBDTunableRowHandle                   _slowdownTimeAfterTeleport;                        // 0x0610(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _speedCurve;                                       // 0x0638(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_640[0x30];                                     // 0x0640(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTeleportInteractionFinished(class ADBDPlayer* Player, bool hasInteractionStarted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K05Power">();
	}
	static class AK05Power* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK05Power>();
	}
};
static_assert(alignof(AK05Power) == 0x000008, "Wrong alignment on AK05Power");
static_assert(sizeof(AK05Power) == 0x000670, "Wrong size on AK05Power");
static_assert(offsetof(AK05Power, _slowdownTimeAfterTeleport) == 0x000610, "Member 'AK05Power::_slowdownTimeAfterTeleport' has a wrong offset!");
static_assert(offsetof(AK05Power, _speedCurve) == 0x000638, "Member 'AK05Power::_speedCurve' has a wrong offset!");

// Class TheHag.PhantomTrapOutlineStrategy
// 0x0020 (0x0180 - 0x0160)
class UPhantomTrapOutlineStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	TWeakObjectPtr<class APhantomTrap>            _cachedOwningPhantomTrap;                          // 0x0160(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _colorWhenTeleportationIsAvailable;                // 0x0168(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _colorAlphaBasedOnDistance;                        // 0x0178(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhantomTrapOutlineStrategy">();
	}
	static class UPhantomTrapOutlineStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhantomTrapOutlineStrategy>();
	}
};
static_assert(alignof(UPhantomTrapOutlineStrategy) == 0x000008, "Wrong alignment on UPhantomTrapOutlineStrategy");
static_assert(sizeof(UPhantomTrapOutlineStrategy) == 0x000180, "Wrong size on UPhantomTrapOutlineStrategy");
static_assert(offsetof(UPhantomTrapOutlineStrategy, _cachedOwningPhantomTrap) == 0x000160, "Member 'UPhantomTrapOutlineStrategy::_cachedOwningPhantomTrap' has a wrong offset!");
static_assert(offsetof(UPhantomTrapOutlineStrategy, _colorWhenTeleportationIsAvailable) == 0x000168, "Member 'UPhantomTrapOutlineStrategy::_colorWhenTeleportationIsAvailable' has a wrong offset!");
static_assert(offsetof(UPhantomTrapOutlineStrategy, _colorAlphaBasedOnDistance) == 0x000178, "Member 'UPhantomTrapOutlineStrategy::_colorAlphaBasedOnDistance' has a wrong offset!");

// Class TheHag.PhantomTrapStunnableComponent
// 0x0008 (0x00C0 - 0x00B8)
class UPhantomTrapStunnableComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhantomTrapStunnableComponent">();
	}
	static class UPhantomTrapStunnableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhantomTrapStunnableComponent>();
	}
};
static_assert(alignof(UPhantomTrapStunnableComponent) == 0x000008, "Wrong alignment on UPhantomTrapStunnableComponent");
static_assert(sizeof(UPhantomTrapStunnableComponent) == 0x0000C0, "Wrong size on UPhantomTrapStunnableComponent");

// Class TheHag.TeleportToPhantomTrap
// 0x0020 (0x0790 - 0x0770)
class UTeleportToPhantomTrap final : public UInteractionDefinition
{
public:
	struct FDBDTunableRowHandle                   _teleportMaxDistance;                              // 0x0768(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void BP_OnTeleport(class AKiller* Slasher, class APhantomTrap* trap);
	void Cosmetic_OnInteractionFinished(class ADBDPlayer* Slasher, bool hasInteractionStarted);
	void Cosmetic_OnTeleport(class AKiller* Slasher, class APhantomTrap* trap);

	class APhantomTrap* GetPhantomTrap() const;
	float GetTeleportMaxDistance(class AKiller* Slasher) const;
	bool IsTeleportationPossible(const class ADBDPlayer* Player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeleportToPhantomTrap">();
	}
	static class UTeleportToPhantomTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeleportToPhantomTrap>();
	}
};
static_assert(alignof(UTeleportToPhantomTrap) == 0x000010, "Wrong alignment on UTeleportToPhantomTrap");
static_assert(sizeof(UTeleportToPhantomTrap) == 0x000790, "Wrong size on UTeleportToPhantomTrap");
static_assert(offsetof(UTeleportToPhantomTrap, _teleportMaxDistance) == 0x000768, "Member 'UTeleportToPhantomTrap::_teleportMaxDistance' has a wrong offset!");

// Class TheHag.WipeAwayPhantomTrapInteraction
// 0x0000 (0x0920 - 0x0920)
class UWipeAwayPhantomTrapInteraction final : public UBasicChargeableInteraction
{
public:
	void CancelInteraction(class ADBDPlayer* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WipeAwayPhantomTrapInteraction">();
	}
	static class UWipeAwayPhantomTrapInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWipeAwayPhantomTrapInteraction>();
	}
};
static_assert(alignof(UWipeAwayPhantomTrapInteraction) == 0x000010, "Wrong alignment on UWipeAwayPhantomTrapInteraction");
static_assert(sizeof(UWipeAwayPhantomTrapInteraction) == 0x000920, "Wrong size on UWipeAwayPhantomTrapInteraction");

}

