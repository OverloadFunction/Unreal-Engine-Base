#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DBDGameplay

#include "Basic.hpp"

#include "PhysicsCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "DBDGameplay_structs.hpp"
#include "DeadByDaylight_structs.hpp"
#include "DBDSharedTypes_structs.hpp"


namespace SDK::Params
{

// Function DBDGameplay.CageHook.Cosmetic_DisplayCage
// 0x0001 (0x0001 - 0x0000)
struct CageHook_Cosmetic_DisplayCage final
{
public:
	bool                                          Display;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CageHook_Cosmetic_DisplayCage) == 0x000001, "Wrong alignment on CageHook_Cosmetic_DisplayCage");
static_assert(sizeof(CageHook_Cosmetic_DisplayCage) == 0x000001, "Wrong size on CageHook_Cosmetic_DisplayCage");
static_assert(offsetof(CageHook_Cosmetic_DisplayCage, Display) == 0x000000, "Member 'CageHook_Cosmetic_DisplayCage::Display' has a wrong offset!");

// Function DBDGameplay.CageHook.Cosmetic_OnGoingUpStarted
// 0x0010 (0x0010 - 0x0000)
struct CageHook_Cosmetic_OnGoingUpStarted final
{
public:
	bool                                          isAnticampRelocation;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ASurvivor*                              cagedSurvivor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CageHook_Cosmetic_OnGoingUpStarted) == 0x000008, "Wrong alignment on CageHook_Cosmetic_OnGoingUpStarted");
static_assert(sizeof(CageHook_Cosmetic_OnGoingUpStarted) == 0x000010, "Wrong size on CageHook_Cosmetic_OnGoingUpStarted");
static_assert(offsetof(CageHook_Cosmetic_OnGoingUpStarted, isAnticampRelocation) == 0x000000, "Member 'CageHook_Cosmetic_OnGoingUpStarted::isAnticampRelocation' has a wrong offset!");
static_assert(offsetof(CageHook_Cosmetic_OnGoingUpStarted, cagedSurvivor) == 0x000008, "Member 'CageHook_Cosmetic_OnGoingUpStarted::cagedSurvivor' has a wrong offset!");

// Function DBDGameplay.CageHook.Multicast_Relocate
// 0x0038 (0x0038 - 0x0000)
struct CageHook_Multicast_Relocate final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0018(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          isAnticampRelocation;                              // 0x0030(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CageHook_Multicast_Relocate) == 0x000008, "Wrong alignment on CageHook_Multicast_Relocate");
static_assert(sizeof(CageHook_Multicast_Relocate) == 0x000038, "Wrong size on CageHook_Multicast_Relocate");
static_assert(offsetof(CageHook_Multicast_Relocate, Location) == 0x000000, "Member 'CageHook_Multicast_Relocate::Location' has a wrong offset!");
static_assert(offsetof(CageHook_Multicast_Relocate, Rotation) == 0x000018, "Member 'CageHook_Multicast_Relocate::Rotation' has a wrong offset!");
static_assert(offsetof(CageHook_Multicast_Relocate, isAnticampRelocation) == 0x000030, "Member 'CageHook_Multicast_Relocate::isAnticampRelocation' has a wrong offset!");

// Function DBDGameplay.CageHook.Multicast_SendSurvivorToCage
// 0x0010 (0x0010 - 0x0000)
struct CageHook_Multicast_SendSurvivorToCage final
{
public:
	class ASurvivor*                              Survivor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AKiller*                                killerInstigator;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CageHook_Multicast_SendSurvivorToCage) == 0x000008, "Wrong alignment on CageHook_Multicast_SendSurvivorToCage");
static_assert(sizeof(CageHook_Multicast_SendSurvivorToCage) == 0x000010, "Wrong size on CageHook_Multicast_SendSurvivorToCage");
static_assert(offsetof(CageHook_Multicast_SendSurvivorToCage, Survivor) == 0x000000, "Member 'CageHook_Multicast_SendSurvivorToCage::Survivor' has a wrong offset!");
static_assert(offsetof(CageHook_Multicast_SendSurvivorToCage, killerInstigator) == 0x000008, "Member 'CageHook_Multicast_SendSurvivorToCage::killerInstigator' has a wrong offset!");

// Function DBDGameplay.CageHook.Multicast_SendSurvivorToCageImmediately
// 0x0040 (0x0040 - 0x0000)
struct CageHook_Multicast_SendSurvivorToCageImmediately final
{
public:
	class ASurvivor*                              Survivor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AKiller*                                killerInstigator;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0028(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(CageHook_Multicast_SendSurvivorToCageImmediately) == 0x000008, "Wrong alignment on CageHook_Multicast_SendSurvivorToCageImmediately");
static_assert(sizeof(CageHook_Multicast_SendSurvivorToCageImmediately) == 0x000040, "Wrong size on CageHook_Multicast_SendSurvivorToCageImmediately");
static_assert(offsetof(CageHook_Multicast_SendSurvivorToCageImmediately, Survivor) == 0x000000, "Member 'CageHook_Multicast_SendSurvivorToCageImmediately::Survivor' has a wrong offset!");
static_assert(offsetof(CageHook_Multicast_SendSurvivorToCageImmediately, killerInstigator) == 0x000008, "Member 'CageHook_Multicast_SendSurvivorToCageImmediately::killerInstigator' has a wrong offset!");
static_assert(offsetof(CageHook_Multicast_SendSurvivorToCageImmediately, Location) == 0x000010, "Member 'CageHook_Multicast_SendSurvivorToCageImmediately::Location' has a wrong offset!");
static_assert(offsetof(CageHook_Multicast_SendSurvivorToCageImmediately, Rotation) == 0x000028, "Member 'CageHook_Multicast_SendSurvivorToCageImmediately::Rotation' has a wrong offset!");

// Function DBDGameplay.CageHook.GetCagedSurvivor
// 0x0008 (0x0008 - 0x0000)
struct CageHook_GetCagedSurvivor final
{
public:
	class ASurvivor*                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CageHook_GetCagedSurvivor) == 0x000008, "Wrong alignment on CageHook_GetCagedSurvivor");
static_assert(sizeof(CageHook_GetCagedSurvivor) == 0x000008, "Wrong size on CageHook_GetCagedSurvivor");
static_assert(offsetof(CageHook_GetCagedSurvivor, ReturnValue) == 0x000000, "Member 'CageHook_GetCagedSurvivor::ReturnValue' has a wrong offset!");

// Function DBDGameplay.CageHook.GetMontagePlayer
// 0x0008 (0x0008 - 0x0000)
struct CageHook_GetMontagePlayer final
{
public:
	class UMontagePlayer*                         ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CageHook_GetMontagePlayer) == 0x000008, "Wrong alignment on CageHook_GetMontagePlayer");
static_assert(sizeof(CageHook_GetMontagePlayer) == 0x000008, "Wrong size on CageHook_GetMontagePlayer");
static_assert(offsetof(CageHook_GetMontagePlayer, ReturnValue) == 0x000000, "Member 'CageHook_GetMontagePlayer::ReturnValue' has a wrong offset!");

// Function DBDGameplay.CageHook.GetRescuerSnapPosition
// 0x0018 (0x0018 - 0x0000)
struct CageHook_GetRescuerSnapPosition final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CageHook_GetRescuerSnapPosition) == 0x000008, "Wrong alignment on CageHook_GetRescuerSnapPosition");
static_assert(sizeof(CageHook_GetRescuerSnapPosition) == 0x000018, "Wrong size on CageHook_GetRescuerSnapPosition");
static_assert(offsetof(CageHook_GetRescuerSnapPosition, ReturnValue) == 0x000000, "Member 'CageHook_GetRescuerSnapPosition::ReturnValue' has a wrong offset!");

// Function DBDGameplay.FlashlightComponent.Server_SetAndUpdateAutonomousLitFlashlightables
// 0x0010 (0x0010 - 0x0000)
struct FlashlightComponent_Server_SetAndUpdateAutonomousLitFlashlightables final
{
public:
	TArray<class UFlashlightableComponent*>       newLitFlashlightables;                             // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightComponent_Server_SetAndUpdateAutonomousLitFlashlightables) == 0x000008, "Wrong alignment on FlashlightComponent_Server_SetAndUpdateAutonomousLitFlashlightables");
static_assert(sizeof(FlashlightComponent_Server_SetAndUpdateAutonomousLitFlashlightables) == 0x000010, "Wrong size on FlashlightComponent_Server_SetAndUpdateAutonomousLitFlashlightables");
static_assert(offsetof(FlashlightComponent_Server_SetAndUpdateAutonomousLitFlashlightables, newLitFlashlightables) == 0x000000, "Member 'FlashlightComponent_Server_SetAndUpdateAutonomousLitFlashlightables::newLitFlashlightables' has a wrong offset!");

// Function DBDGameplay.FlashlightComponent.GetEffectiveBlindnessDuration
// 0x0004 (0x0004 - 0x0000)
struct FlashlightComponent_GetEffectiveBlindnessDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightComponent_GetEffectiveBlindnessDuration) == 0x000004, "Wrong alignment on FlashlightComponent_GetEffectiveBlindnessDuration");
static_assert(sizeof(FlashlightComponent_GetEffectiveBlindnessDuration) == 0x000004, "Wrong size on FlashlightComponent_GetEffectiveBlindnessDuration");
static_assert(offsetof(FlashlightComponent_GetEffectiveBlindnessDuration, ReturnValue) == 0x000000, "Member 'FlashlightComponent_GetEffectiveBlindnessDuration::ReturnValue' has a wrong offset!");

// Function DBDGameplay.FlashlightComponent.GetEffectiveTimeToBlindModifier
// 0x0004 (0x0004 - 0x0000)
struct FlashlightComponent_GetEffectiveTimeToBlindModifier final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightComponent_GetEffectiveTimeToBlindModifier) == 0x000004, "Wrong alignment on FlashlightComponent_GetEffectiveTimeToBlindModifier");
static_assert(sizeof(FlashlightComponent_GetEffectiveTimeToBlindModifier) == 0x000004, "Wrong size on FlashlightComponent_GetEffectiveTimeToBlindModifier");
static_assert(offsetof(FlashlightComponent_GetEffectiveTimeToBlindModifier, ReturnValue) == 0x000000, "Member 'FlashlightComponent_GetEffectiveTimeToBlindModifier::ReturnValue' has a wrong offset!");

// Function DBDGameplay.FlashlightComponent.IsOn
// 0x0001 (0x0001 - 0x0000)
struct FlashlightComponent_IsOn final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightComponent_IsOn) == 0x000001, "Wrong alignment on FlashlightComponent_IsOn");
static_assert(sizeof(FlashlightComponent_IsOn) == 0x000001, "Wrong size on FlashlightComponent_IsOn");
static_assert(offsetof(FlashlightComponent_IsOn, ReturnValue) == 0x000000, "Member 'FlashlightComponent_IsOn::ReturnValue' has a wrong offset!");

// Function DBDGameplay.CageRescueInteraction.GetRescuerSnapPosition
// 0x0018 (0x0018 - 0x0000)
struct CageRescueInteraction_GetRescuerSnapPosition final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CageRescueInteraction_GetRescuerSnapPosition) == 0x000008, "Wrong alignment on CageRescueInteraction_GetRescuerSnapPosition");
static_assert(sizeof(CageRescueInteraction_GetRescuerSnapPosition) == 0x000018, "Wrong size on CageRescueInteraction_GetRescuerSnapPosition");
static_assert(offsetof(CageRescueInteraction_GetRescuerSnapPosition, ReturnValue) == 0x000000, "Member 'CageRescueInteraction_GetRescuerSnapPosition::ReturnValue' has a wrong offset!");

// Function DBDGameplay.SendToCageInteraction.FX_InteractionChargeCompleted
// 0x0008 (0x0008 - 0x0000)
struct SendToCageInteraction_FX_InteractionChargeCompleted final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SendToCageInteraction_FX_InteractionChargeCompleted) == 0x000008, "Wrong alignment on SendToCageInteraction_FX_InteractionChargeCompleted");
static_assert(sizeof(SendToCageInteraction_FX_InteractionChargeCompleted) == 0x000008, "Wrong size on SendToCageInteraction_FX_InteractionChargeCompleted");
static_assert(offsetof(SendToCageInteraction_FX_InteractionChargeCompleted, Player) == 0x000000, "Member 'SendToCageInteraction_FX_InteractionChargeCompleted::Player' has a wrong offset!");

// Function DBDGameplay.SendToCageInteraction.GetOwningSurvivor
// 0x0008 (0x0008 - 0x0000)
struct SendToCageInteraction_GetOwningSurvivor final
{
public:
	const class ASurvivor*                        ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SendToCageInteraction_GetOwningSurvivor) == 0x000008, "Wrong alignment on SendToCageInteraction_GetOwningSurvivor");
static_assert(sizeof(SendToCageInteraction_GetOwningSurvivor) == 0x000008, "Wrong size on SendToCageInteraction_GetOwningSurvivor");
static_assert(offsetof(SendToCageInteraction_GetOwningSurvivor, ReturnValue) == 0x000000, "Member 'SendToCageInteraction_GetOwningSurvivor::ReturnValue' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusEmitterFunctionLibrary.GetActiveFakeTerrorRadiusEmittersCount
// 0x0010 (0x0010 - 0x0000)
struct TerrorRadiusEmitterFunctionLibrary_GetActiveFakeTerrorRadiusEmittersCount final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TerrorRadiusEmitterFunctionLibrary_GetActiveFakeTerrorRadiusEmittersCount) == 0x000008, "Wrong alignment on TerrorRadiusEmitterFunctionLibrary_GetActiveFakeTerrorRadiusEmittersCount");
static_assert(sizeof(TerrorRadiusEmitterFunctionLibrary_GetActiveFakeTerrorRadiusEmittersCount) == 0x000010, "Wrong size on TerrorRadiusEmitterFunctionLibrary_GetActiveFakeTerrorRadiusEmittersCount");
static_assert(offsetof(TerrorRadiusEmitterFunctionLibrary_GetActiveFakeTerrorRadiusEmittersCount, WorldContextObject) == 0x000000, "Member 'TerrorRadiusEmitterFunctionLibrary_GetActiveFakeTerrorRadiusEmittersCount::WorldContextObject' has a wrong offset!");
static_assert(offsetof(TerrorRadiusEmitterFunctionLibrary_GetActiveFakeTerrorRadiusEmittersCount, ReturnValue) == 0x000008, "Member 'TerrorRadiusEmitterFunctionLibrary_GetActiveFakeTerrorRadiusEmittersCount::ReturnValue' has a wrong offset!");

// Function DBDGameplay.BaseSightManagerComponent.Authority_OnCharacterSightChanged
// 0x0010 (0x0010 - 0x0000)
struct BaseSightManagerComponent_Authority_OnCharacterSightChanged final
{
public:
	class ACharacter*                             sightedCharacter;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCharacterSightComponent*               sightComponent;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSightManagerComponent_Authority_OnCharacterSightChanged) == 0x000008, "Wrong alignment on BaseSightManagerComponent_Authority_OnCharacterSightChanged");
static_assert(sizeof(BaseSightManagerComponent_Authority_OnCharacterSightChanged) == 0x000010, "Wrong size on BaseSightManagerComponent_Authority_OnCharacterSightChanged");
static_assert(offsetof(BaseSightManagerComponent_Authority_OnCharacterSightChanged, sightedCharacter) == 0x000000, "Member 'BaseSightManagerComponent_Authority_OnCharacterSightChanged::sightedCharacter' has a wrong offset!");
static_assert(offsetof(BaseSightManagerComponent_Authority_OnCharacterSightChanged, sightComponent) == 0x000008, "Member 'BaseSightManagerComponent_Authority_OnCharacterSightChanged::sightComponent' has a wrong offset!");

// Function DBDGameplay.FlashlightTargetFXComponent.OnIsLitChanged
// 0x0001 (0x0001 - 0x0000)
struct FlashlightTargetFXComponent_OnIsLitChanged final
{
public:
	bool                                          IsLit;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightTargetFXComponent_OnIsLitChanged) == 0x000001, "Wrong alignment on FlashlightTargetFXComponent_OnIsLitChanged");
static_assert(sizeof(FlashlightTargetFXComponent_OnIsLitChanged) == 0x000001, "Wrong size on FlashlightTargetFXComponent_OnIsLitChanged");
static_assert(offsetof(FlashlightTargetFXComponent_OnIsLitChanged, IsLit) == 0x000000, "Member 'FlashlightTargetFXComponent_OnIsLitChanged::IsLit' has a wrong offset!");

// Function DBDGameplay.SurvivorFootstepCreatorComponent.OnLoudNoiseTriggered
// 0x0038 (0x0038 - 0x0000)
struct SurvivorFootstepCreatorComponent_OnLoudNoiseTriggered final
{
public:
	class AActor*                                 originator;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 instigatingActor;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          shouldTrack;                                       // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         audibleRange;                                      // 0x002C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isQuickAction;                                     // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isDeceivingNoise;                                  // 0x0031(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SurvivorFootstepCreatorComponent_OnLoudNoiseTriggered) == 0x000008, "Wrong alignment on SurvivorFootstepCreatorComponent_OnLoudNoiseTriggered");
static_assert(sizeof(SurvivorFootstepCreatorComponent_OnLoudNoiseTriggered) == 0x000038, "Wrong size on SurvivorFootstepCreatorComponent_OnLoudNoiseTriggered");
static_assert(offsetof(SurvivorFootstepCreatorComponent_OnLoudNoiseTriggered, originator) == 0x000000, "Member 'SurvivorFootstepCreatorComponent_OnLoudNoiseTriggered::originator' has a wrong offset!");
static_assert(offsetof(SurvivorFootstepCreatorComponent_OnLoudNoiseTriggered, instigatingActor) == 0x000008, "Member 'SurvivorFootstepCreatorComponent_OnLoudNoiseTriggered::instigatingActor' has a wrong offset!");
static_assert(offsetof(SurvivorFootstepCreatorComponent_OnLoudNoiseTriggered, Location) == 0x000010, "Member 'SurvivorFootstepCreatorComponent_OnLoudNoiseTriggered::Location' has a wrong offset!");
static_assert(offsetof(SurvivorFootstepCreatorComponent_OnLoudNoiseTriggered, shouldTrack) == 0x000028, "Member 'SurvivorFootstepCreatorComponent_OnLoudNoiseTriggered::shouldTrack' has a wrong offset!");
static_assert(offsetof(SurvivorFootstepCreatorComponent_OnLoudNoiseTriggered, audibleRange) == 0x00002C, "Member 'SurvivorFootstepCreatorComponent_OnLoudNoiseTriggered::audibleRange' has a wrong offset!");
static_assert(offsetof(SurvivorFootstepCreatorComponent_OnLoudNoiseTriggered, isQuickAction) == 0x000030, "Member 'SurvivorFootstepCreatorComponent_OnLoudNoiseTriggered::isQuickAction' has a wrong offset!");
static_assert(offsetof(SurvivorFootstepCreatorComponent_OnLoudNoiseTriggered, isDeceivingNoise) == 0x000031, "Member 'SurvivorFootstepCreatorComponent_OnLoudNoiseTriggered::isDeceivingNoise' has a wrong offset!");

// Function DBDGameplay.UseContaminationAntidoteInteraction.GetInteractionTarget
// 0x0008 (0x0008 - 0x0000)
struct UseContaminationAntidoteInteraction_GetInteractionTarget final
{
public:
	class ASurvivor*                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UseContaminationAntidoteInteraction_GetInteractionTarget) == 0x000008, "Wrong alignment on UseContaminationAntidoteInteraction_GetInteractionTarget");
static_assert(sizeof(UseContaminationAntidoteInteraction_GetInteractionTarget) == 0x000008, "Wrong size on UseContaminationAntidoteInteraction_GetInteractionTarget");
static_assert(offsetof(UseContaminationAntidoteInteraction_GetInteractionTarget, ReturnValue) == 0x000000, "Member 'UseContaminationAntidoteInteraction_GetInteractionTarget::ReturnValue' has a wrong offset!");

// Function DBDGameplay.GlassBeadMapAddon.Authority_OnSecondaryInputPressed
// 0x0018 (0x0018 - 0x0000)
struct GlassBeadMapAddon_Authority_OnSecondaryInputPressed final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractionDefinition*                 Interaction;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          fromCancelRequest;                                 // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GlassBeadMapAddon_Authority_OnSecondaryInputPressed) == 0x000008, "Wrong alignment on GlassBeadMapAddon_Authority_OnSecondaryInputPressed");
static_assert(sizeof(GlassBeadMapAddon_Authority_OnSecondaryInputPressed) == 0x000018, "Wrong size on GlassBeadMapAddon_Authority_OnSecondaryInputPressed");
static_assert(offsetof(GlassBeadMapAddon_Authority_OnSecondaryInputPressed, Player) == 0x000000, "Member 'GlassBeadMapAddon_Authority_OnSecondaryInputPressed::Player' has a wrong offset!");
static_assert(offsetof(GlassBeadMapAddon_Authority_OnSecondaryInputPressed, Interaction) == 0x000008, "Member 'GlassBeadMapAddon_Authority_OnSecondaryInputPressed::Interaction' has a wrong offset!");
static_assert(offsetof(GlassBeadMapAddon_Authority_OnSecondaryInputPressed, fromCancelRequest) == 0x000010, "Member 'GlassBeadMapAddon_Authority_OnSecondaryInputPressed::fromCancelRequest' has a wrong offset!");

// Function DBDGameplay.BaseHusk.Cosmetic_InitializeSkeletalMesh
// 0x0008 (0x0008 - 0x0000)
struct BaseHusk_Cosmetic_InitializeSkeletalMesh final
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseHusk_Cosmetic_InitializeSkeletalMesh) == 0x000008, "Wrong alignment on BaseHusk_Cosmetic_InitializeSkeletalMesh");
static_assert(sizeof(BaseHusk_Cosmetic_InitializeSkeletalMesh) == 0x000008, "Wrong size on BaseHusk_Cosmetic_InitializeSkeletalMesh");
static_assert(offsetof(BaseHusk_Cosmetic_InitializeSkeletalMesh, Mesh) == 0x000000, "Member 'BaseHusk_Cosmetic_InitializeSkeletalMesh::Mesh' has a wrong offset!");

// Function DBDGameplay.BaseHusk.InitializeHusk
// 0x0018 (0x0018 - 0x0000)
struct BaseHusk_InitializeHusk final
{
public:
	class UCustomizedSkeletalMesh*                customizedSkeletalMeshToCopy;                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 skeletalMeshToCopy;                                // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         characterIdOverride;                               // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BaseHusk_InitializeHusk) == 0x000008, "Wrong alignment on BaseHusk_InitializeHusk");
static_assert(sizeof(BaseHusk_InitializeHusk) == 0x000018, "Wrong size on BaseHusk_InitializeHusk");
static_assert(offsetof(BaseHusk_InitializeHusk, customizedSkeletalMeshToCopy) == 0x000000, "Member 'BaseHusk_InitializeHusk::customizedSkeletalMeshToCopy' has a wrong offset!");
static_assert(offsetof(BaseHusk_InitializeHusk, skeletalMeshToCopy) == 0x000008, "Member 'BaseHusk_InitializeHusk::skeletalMeshToCopy' has a wrong offset!");
static_assert(offsetof(BaseHusk_InitializeHusk, characterIdOverride) == 0x000010, "Member 'BaseHusk_InitializeHusk::characterIdOverride' has a wrong offset!");

// Function DBDGameplay.BaseHusk.SetHuskVisibility
// 0x0001 (0x0001 - 0x0000)
struct BaseHusk_SetHuskVisibility final
{
public:
	bool                                          Visible;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseHusk_SetHuskVisibility) == 0x000001, "Wrong alignment on BaseHusk_SetHuskVisibility");
static_assert(sizeof(BaseHusk_SetHuskVisibility) == 0x000001, "Wrong size on BaseHusk_SetHuskVisibility");
static_assert(offsetof(BaseHusk_SetHuskVisibility, Visible) == 0x000000, "Member 'BaseHusk_SetHuskVisibility::Visible' has a wrong offset!");

// Function DBDGameplay.BaseHusk.SetScalarParameterOnAllChildrenMeshes
// 0x0018 (0x0018 - 0x0000)
struct BaseHusk_SetScalarParameterOnAllChildrenMeshes final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseHusk_SetScalarParameterOnAllChildrenMeshes) == 0x000008, "Wrong alignment on BaseHusk_SetScalarParameterOnAllChildrenMeshes");
static_assert(sizeof(BaseHusk_SetScalarParameterOnAllChildrenMeshes) == 0x000018, "Wrong size on BaseHusk_SetScalarParameterOnAllChildrenMeshes");
static_assert(offsetof(BaseHusk_SetScalarParameterOnAllChildrenMeshes, ParameterName) == 0x000000, "Member 'BaseHusk_SetScalarParameterOnAllChildrenMeshes::ParameterName' has a wrong offset!");
static_assert(offsetof(BaseHusk_SetScalarParameterOnAllChildrenMeshes, Value) == 0x00000C, "Member 'BaseHusk_SetScalarParameterOnAllChildrenMeshes::Value' has a wrong offset!");
static_assert(offsetof(BaseHusk_SetScalarParameterOnAllChildrenMeshes, Mesh) == 0x000010, "Member 'BaseHusk_SetScalarParameterOnAllChildrenMeshes::Mesh' has a wrong offset!");

// Function DBDGameplay.BaseHusk.GetCopiedCustomizedSkeletalMesh
// 0x0008 (0x0008 - 0x0000)
struct BaseHusk_GetCopiedCustomizedSkeletalMesh final
{
public:
	const class UCustomizedSkeletalMesh*          ReturnValue;                                       // 0x0000(0x0008)(ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseHusk_GetCopiedCustomizedSkeletalMesh) == 0x000008, "Wrong alignment on BaseHusk_GetCopiedCustomizedSkeletalMesh");
static_assert(sizeof(BaseHusk_GetCopiedCustomizedSkeletalMesh) == 0x000008, "Wrong size on BaseHusk_GetCopiedCustomizedSkeletalMesh");
static_assert(offsetof(BaseHusk_GetCopiedCustomizedSkeletalMesh, ReturnValue) == 0x000000, "Member 'BaseHusk_GetCopiedCustomizedSkeletalMesh::ReturnValue' has a wrong offset!");

// Function DBDGameplay.BaseHusk.GetMesh
// 0x0008 (0x0008 - 0x0000)
struct BaseHusk_GetMesh final
{
public:
	class USkeletalMeshComponent*                 ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseHusk_GetMesh) == 0x000008, "Wrong alignment on BaseHusk_GetMesh");
static_assert(sizeof(BaseHusk_GetMesh) == 0x000008, "Wrong size on BaseHusk_GetMesh");
static_assert(offsetof(BaseHusk_GetMesh, ReturnValue) == 0x000000, "Member 'BaseHusk_GetMesh::ReturnValue' has a wrong offset!");

// Function DBDGameplay.KillerAbilityComponent.OnRep_TokenCount
// 0x0004 (0x0004 - 0x0000)
struct KillerAbilityComponent_OnRep_TokenCount final
{
public:
	int32                                         oldCount;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerAbilityComponent_OnRep_TokenCount) == 0x000004, "Wrong alignment on KillerAbilityComponent_OnRep_TokenCount");
static_assert(sizeof(KillerAbilityComponent_OnRep_TokenCount) == 0x000004, "Wrong size on KillerAbilityComponent_OnRep_TokenCount");
static_assert(offsetof(KillerAbilityComponent_OnRep_TokenCount, oldCount) == 0x000000, "Member 'KillerAbilityComponent_OnRep_TokenCount::oldCount' has a wrong offset!");

// Function DBDGameplay.KillerAbilityComponent.GetCooldown
// 0x0004 (0x0004 - 0x0000)
struct KillerAbilityComponent_GetCooldown final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerAbilityComponent_GetCooldown) == 0x000004, "Wrong alignment on KillerAbilityComponent_GetCooldown");
static_assert(sizeof(KillerAbilityComponent_GetCooldown) == 0x000004, "Wrong size on KillerAbilityComponent_GetCooldown");
static_assert(offsetof(KillerAbilityComponent_GetCooldown, ReturnValue) == 0x000000, "Member 'KillerAbilityComponent_GetCooldown::ReturnValue' has a wrong offset!");

// Function DBDGameplay.KillerAbilityComponent.GetDuration
// 0x0004 (0x0004 - 0x0000)
struct KillerAbilityComponent_GetDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerAbilityComponent_GetDuration) == 0x000004, "Wrong alignment on KillerAbilityComponent_GetDuration");
static_assert(sizeof(KillerAbilityComponent_GetDuration) == 0x000004, "Wrong size on KillerAbilityComponent_GetDuration");
static_assert(offsetof(KillerAbilityComponent_GetDuration, ReturnValue) == 0x000000, "Member 'KillerAbilityComponent_GetDuration::ReturnValue' has a wrong offset!");

// Function DBDGameplay.KillerAbilityComponent.GetOwningKiller
// 0x0008 (0x0008 - 0x0000)
struct KillerAbilityComponent_GetOwningKiller final
{
public:
	class AKiller*                                ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerAbilityComponent_GetOwningKiller) == 0x000008, "Wrong alignment on KillerAbilityComponent_GetOwningKiller");
static_assert(sizeof(KillerAbilityComponent_GetOwningKiller) == 0x000008, "Wrong size on KillerAbilityComponent_GetOwningKiller");
static_assert(offsetof(KillerAbilityComponent_GetOwningKiller, ReturnValue) == 0x000000, "Member 'KillerAbilityComponent_GetOwningKiller::ReturnValue' has a wrong offset!");

// Function DBDGameplay.KillerAbilityComponent.GetOwningPower
// 0x0008 (0x0008 - 0x0000)
struct KillerAbilityComponent_GetOwningPower final
{
public:
	class AKillerPower*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerAbilityComponent_GetOwningPower) == 0x000008, "Wrong alignment on KillerAbilityComponent_GetOwningPower");
static_assert(sizeof(KillerAbilityComponent_GetOwningPower) == 0x000008, "Wrong size on KillerAbilityComponent_GetOwningPower");
static_assert(offsetof(KillerAbilityComponent_GetOwningPower, ReturnValue) == 0x000000, "Member 'KillerAbilityComponent_GetOwningPower::ReturnValue' has a wrong offset!");

// Function DBDGameplay.KillerAbilityComponent.GetRemainingCooldown
// 0x0004 (0x0004 - 0x0000)
struct KillerAbilityComponent_GetRemainingCooldown final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerAbilityComponent_GetRemainingCooldown) == 0x000004, "Wrong alignment on KillerAbilityComponent_GetRemainingCooldown");
static_assert(sizeof(KillerAbilityComponent_GetRemainingCooldown) == 0x000004, "Wrong size on KillerAbilityComponent_GetRemainingCooldown");
static_assert(offsetof(KillerAbilityComponent_GetRemainingCooldown, ReturnValue) == 0x000000, "Member 'KillerAbilityComponent_GetRemainingCooldown::ReturnValue' has a wrong offset!");

// Function DBDGameplay.KillerAbilityComponent.GetRemainingCooldownPercent
// 0x0004 (0x0004 - 0x0000)
struct KillerAbilityComponent_GetRemainingCooldownPercent final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerAbilityComponent_GetRemainingCooldownPercent) == 0x000004, "Wrong alignment on KillerAbilityComponent_GetRemainingCooldownPercent");
static_assert(sizeof(KillerAbilityComponent_GetRemainingCooldownPercent) == 0x000004, "Wrong size on KillerAbilityComponent_GetRemainingCooldownPercent");
static_assert(offsetof(KillerAbilityComponent_GetRemainingCooldownPercent, ReturnValue) == 0x000000, "Member 'KillerAbilityComponent_GetRemainingCooldownPercent::ReturnValue' has a wrong offset!");

// Function DBDGameplay.KillerAbilityComponent.GetRemainingDurationPercent
// 0x0004 (0x0004 - 0x0000)
struct KillerAbilityComponent_GetRemainingDurationPercent final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerAbilityComponent_GetRemainingDurationPercent) == 0x000004, "Wrong alignment on KillerAbilityComponent_GetRemainingDurationPercent");
static_assert(sizeof(KillerAbilityComponent_GetRemainingDurationPercent) == 0x000004, "Wrong size on KillerAbilityComponent_GetRemainingDurationPercent");
static_assert(offsetof(KillerAbilityComponent_GetRemainingDurationPercent, ReturnValue) == 0x000000, "Member 'KillerAbilityComponent_GetRemainingDurationPercent::ReturnValue' has a wrong offset!");

// Function DBDGameplay.KillerAbilityComponent.IsApplicable
// 0x0001 (0x0001 - 0x0000)
struct KillerAbilityComponent_IsApplicable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerAbilityComponent_IsApplicable) == 0x000001, "Wrong alignment on KillerAbilityComponent_IsApplicable");
static_assert(sizeof(KillerAbilityComponent_IsApplicable) == 0x000001, "Wrong size on KillerAbilityComponent_IsApplicable");
static_assert(offsetof(KillerAbilityComponent_IsApplicable, ReturnValue) == 0x000000, "Member 'KillerAbilityComponent_IsApplicable::ReturnValue' has a wrong offset!");

// Function DBDGameplay.KillerAbilityComponent.IsAvailable
// 0x0001 (0x0001 - 0x0000)
struct KillerAbilityComponent_IsAvailable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerAbilityComponent_IsAvailable) == 0x000001, "Wrong alignment on KillerAbilityComponent_IsAvailable");
static_assert(sizeof(KillerAbilityComponent_IsAvailable) == 0x000001, "Wrong size on KillerAbilityComponent_IsAvailable");
static_assert(offsetof(KillerAbilityComponent_IsAvailable, ReturnValue) == 0x000000, "Member 'KillerAbilityComponent_IsAvailable::ReturnValue' has a wrong offset!");

// Function DBDGameplay.KillerAbilityComponent.IsDurationTimerActive
// 0x0001 (0x0001 - 0x0000)
struct KillerAbilityComponent_IsDurationTimerActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerAbilityComponent_IsDurationTimerActive) == 0x000001, "Wrong alignment on KillerAbilityComponent_IsDurationTimerActive");
static_assert(sizeof(KillerAbilityComponent_IsDurationTimerActive) == 0x000001, "Wrong size on KillerAbilityComponent_IsDurationTimerActive");
static_assert(offsetof(KillerAbilityComponent_IsDurationTimerActive, ReturnValue) == 0x000000, "Member 'KillerAbilityComponent_IsDurationTimerActive::ReturnValue' has a wrong offset!");

// Function DBDGameplay.KillerAbilityComponent.IsOnCooldown
// 0x0001 (0x0001 - 0x0000)
struct KillerAbilityComponent_IsOnCooldown final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerAbilityComponent_IsOnCooldown) == 0x000001, "Wrong alignment on KillerAbilityComponent_IsOnCooldown");
static_assert(sizeof(KillerAbilityComponent_IsOnCooldown) == 0x000001, "Wrong size on KillerAbilityComponent_IsOnCooldown");
static_assert(offsetof(KillerAbilityComponent_IsOnCooldown, ReturnValue) == 0x000000, "Member 'KillerAbilityComponent_IsOnCooldown::ReturnValue' has a wrong offset!");

// Function DBDGameplay.KillerAbilityComponent.PlayAudioOnOwningKiller
// 0x0010 (0x0010 - 0x0000)
struct KillerAbilityComponent_PlayAudioOnOwningKiller final
{
public:
	class UAkAudioEvent*                          AudioEvent;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OnlyPlayIfLocallyObserved;                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KillerAbilityComponent_PlayAudioOnOwningKiller) == 0x000008, "Wrong alignment on KillerAbilityComponent_PlayAudioOnOwningKiller");
static_assert(sizeof(KillerAbilityComponent_PlayAudioOnOwningKiller) == 0x000010, "Wrong size on KillerAbilityComponent_PlayAudioOnOwningKiller");
static_assert(offsetof(KillerAbilityComponent_PlayAudioOnOwningKiller, AudioEvent) == 0x000000, "Member 'KillerAbilityComponent_PlayAudioOnOwningKiller::AudioEvent' has a wrong offset!");
static_assert(offsetof(KillerAbilityComponent_PlayAudioOnOwningKiller, OnlyPlayIfLocallyObserved) == 0x000008, "Member 'KillerAbilityComponent_PlayAudioOnOwningKiller::OnlyPlayIfLocallyObserved' has a wrong offset!");

// Function DBDGameplay.KillerAbilityData.GetCooldown
// 0x0004 (0x0004 - 0x0000)
struct KillerAbilityData_GetCooldown final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerAbilityData_GetCooldown) == 0x000004, "Wrong alignment on KillerAbilityData_GetCooldown");
static_assert(sizeof(KillerAbilityData_GetCooldown) == 0x000004, "Wrong size on KillerAbilityData_GetCooldown");
static_assert(offsetof(KillerAbilityData_GetCooldown, ReturnValue) == 0x000000, "Member 'KillerAbilityData_GetCooldown::ReturnValue' has a wrong offset!");

// Function DBDGameplay.KillerAbilityData.GetDuration
// 0x0004 (0x0004 - 0x0000)
struct KillerAbilityData_GetDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerAbilityData_GetDuration) == 0x000004, "Wrong alignment on KillerAbilityData_GetDuration");
static_assert(sizeof(KillerAbilityData_GetDuration) == 0x000004, "Wrong size on KillerAbilityData_GetDuration");
static_assert(offsetof(KillerAbilityData_GetDuration, ReturnValue) == 0x000000, "Member 'KillerAbilityData_GetDuration::ReturnValue' has a wrong offset!");

// Function DBDGameplay.AuraOverriderComponent.ForceShowAura
// 0x0028 (0x0028 - 0x0000)
struct AuraOverriderComponent_ForceShowAura final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAlwaysVisible;                                   // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumOutlineDistanceVisible;                     // 0x001C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumOutlineDistance;                            // 0x0020(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AuraOverriderComponent_ForceShowAura) == 0x000008, "Wrong alignment on AuraOverriderComponent_ForceShowAura");
static_assert(sizeof(AuraOverriderComponent_ForceShowAura) == 0x000028, "Wrong size on AuraOverriderComponent_ForceShowAura");
static_assert(offsetof(AuraOverriderComponent_ForceShowAura, Actor) == 0x000000, "Member 'AuraOverriderComponent_ForceShowAura::Actor' has a wrong offset!");
static_assert(offsetof(AuraOverriderComponent_ForceShowAura, Color) == 0x000008, "Member 'AuraOverriderComponent_ForceShowAura::Color' has a wrong offset!");
static_assert(offsetof(AuraOverriderComponent_ForceShowAura, IsAlwaysVisible) == 0x000018, "Member 'AuraOverriderComponent_ForceShowAura::IsAlwaysVisible' has a wrong offset!");
static_assert(offsetof(AuraOverriderComponent_ForceShowAura, MinimumOutlineDistanceVisible) == 0x00001C, "Member 'AuraOverriderComponent_ForceShowAura::MinimumOutlineDistanceVisible' has a wrong offset!");
static_assert(offsetof(AuraOverriderComponent_ForceShowAura, MinimumOutlineDistance) == 0x000020, "Member 'AuraOverriderComponent_ForceShowAura::MinimumOutlineDistance' has a wrong offset!");

// Function DBDGameplay.AuraOverriderComponent.ResetAura
// 0x0008 (0x0008 - 0x0000)
struct AuraOverriderComponent_ResetAura final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AuraOverriderComponent_ResetAura) == 0x000008, "Wrong alignment on AuraOverriderComponent_ResetAura");
static_assert(sizeof(AuraOverriderComponent_ResetAura) == 0x000008, "Wrong size on AuraOverriderComponent_ResetAura");
static_assert(offsetof(AuraOverriderComponent_ResetAura, Actor) == 0x000000, "Member 'AuraOverriderComponent_ResetAura::Actor' has a wrong offset!");

// Function DBDGameplay.FadeComponent.GetFadePercent
// 0x0004 (0x0004 - 0x0000)
struct FadeComponent_GetFadePercent final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FadeComponent_GetFadePercent) == 0x000004, "Wrong alignment on FadeComponent_GetFadePercent");
static_assert(sizeof(FadeComponent_GetFadePercent) == 0x000004, "Wrong size on FadeComponent_GetFadePercent");
static_assert(offsetof(FadeComponent_GetFadePercent, ReturnValue) == 0x000000, "Member 'FadeComponent_GetFadePercent::ReturnValue' has a wrong offset!");

// Function DBDGameplay.PoseableHusk.OnActiveStateChanged
// 0x0001 (0x0001 - 0x0000)
struct PoseableHusk_OnActiveStateChanged final
{
public:
	bool                                          IsActive;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PoseableHusk_OnActiveStateChanged) == 0x000001, "Wrong alignment on PoseableHusk_OnActiveStateChanged");
static_assert(sizeof(PoseableHusk_OnActiveStateChanged) == 0x000001, "Wrong size on PoseableHusk_OnActiveStateChanged");
static_assert(offsetof(PoseableHusk_OnActiveStateChanged, IsActive) == 0x000000, "Member 'PoseableHusk_OnActiveStateChanged::IsActive' has a wrong offset!");

// Function DBDGameplay.PoseableHusk.SetIsActive
// 0x0001 (0x0001 - 0x0000)
struct PoseableHusk_SetIsActive final
{
public:
	bool                                          IsActive;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PoseableHusk_SetIsActive) == 0x000001, "Wrong alignment on PoseableHusk_SetIsActive");
static_assert(sizeof(PoseableHusk_SetIsActive) == 0x000001, "Wrong size on PoseableHusk_SetIsActive");
static_assert(offsetof(PoseableHusk_SetIsActive, IsActive) == 0x000000, "Member 'PoseableHusk_SetIsActive::IsActive' has a wrong offset!");

// Function DBDGameplay.PoseableHusk.GetIsActive
// 0x0001 (0x0001 - 0x0000)
struct PoseableHusk_GetIsActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PoseableHusk_GetIsActive) == 0x000001, "Wrong alignment on PoseableHusk_GetIsActive");
static_assert(sizeof(PoseableHusk_GetIsActive) == 0x000001, "Wrong size on PoseableHusk_GetIsActive");
static_assert(offsetof(PoseableHusk_GetIsActive, ReturnValue) == 0x000000, "Member 'PoseableHusk_GetIsActive::ReturnValue' has a wrong offset!");

// Function DBDGameplay.ActorNavMovementComponent.SetAcceleration
// 0x0004 (0x0004 - 0x0000)
struct ActorNavMovementComponent_SetAcceleration final
{
public:
	float                                         Acceleration;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorNavMovementComponent_SetAcceleration) == 0x000004, "Wrong alignment on ActorNavMovementComponent_SetAcceleration");
static_assert(sizeof(ActorNavMovementComponent_SetAcceleration) == 0x000004, "Wrong size on ActorNavMovementComponent_SetAcceleration");
static_assert(offsetof(ActorNavMovementComponent_SetAcceleration, Acceleration) == 0x000000, "Member 'ActorNavMovementComponent_SetAcceleration::Acceleration' has a wrong offset!");

// Function DBDGameplay.ActorNavMovementComponent.SetDeceleration
// 0x0004 (0x0004 - 0x0000)
struct ActorNavMovementComponent_SetDeceleration final
{
public:
	float                                         Deceleration;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorNavMovementComponent_SetDeceleration) == 0x000004, "Wrong alignment on ActorNavMovementComponent_SetDeceleration");
static_assert(sizeof(ActorNavMovementComponent_SetDeceleration) == 0x000004, "Wrong size on ActorNavMovementComponent_SetDeceleration");
static_assert(offsetof(ActorNavMovementComponent_SetDeceleration, Deceleration) == 0x000000, "Member 'ActorNavMovementComponent_SetDeceleration::Deceleration' has a wrong offset!");

// Function DBDGameplay.ActorNavMovementComponent.SetMaxSpeed
// 0x0004 (0x0004 - 0x0000)
struct ActorNavMovementComponent_SetMaxSpeed final
{
public:
	float                                         MaxSpeed;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorNavMovementComponent_SetMaxSpeed) == 0x000004, "Wrong alignment on ActorNavMovementComponent_SetMaxSpeed");
static_assert(sizeof(ActorNavMovementComponent_SetMaxSpeed) == 0x000004, "Wrong size on ActorNavMovementComponent_SetMaxSpeed");
static_assert(offsetof(ActorNavMovementComponent_SetMaxSpeed, MaxSpeed) == 0x000000, "Member 'ActorNavMovementComponent_SetMaxSpeed::MaxSpeed' has a wrong offset!");

// Function DBDGameplay.ActorNavMovementComponent.GetOwningActor
// 0x0008 (0x0008 - 0x0000)
struct ActorNavMovementComponent_GetOwningActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorNavMovementComponent_GetOwningActor) == 0x000008, "Wrong alignment on ActorNavMovementComponent_GetOwningActor");
static_assert(sizeof(ActorNavMovementComponent_GetOwningActor) == 0x000008, "Wrong size on ActorNavMovementComponent_GetOwningActor");
static_assert(offsetof(ActorNavMovementComponent_GetOwningActor, ReturnValue) == 0x000000, "Member 'ActorNavMovementComponent_GetOwningActor::ReturnValue' has a wrong offset!");

// Function DBDGameplay.KillerProjectileAbilityProjectile.Cosmetic_OnCollisionDetected
// 0x0001 (0x0001 - 0x0000)
struct KillerProjectileAbilityProjectile_Cosmetic_OnCollisionDetected final
{
public:
	EPhysicalSurface                              SurfaceType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerProjectileAbilityProjectile_Cosmetic_OnCollisionDetected) == 0x000001, "Wrong alignment on KillerProjectileAbilityProjectile_Cosmetic_OnCollisionDetected");
static_assert(sizeof(KillerProjectileAbilityProjectile_Cosmetic_OnCollisionDetected) == 0x000001, "Wrong size on KillerProjectileAbilityProjectile_Cosmetic_OnCollisionDetected");
static_assert(offsetof(KillerProjectileAbilityProjectile_Cosmetic_OnCollisionDetected, SurfaceType) == 0x000000, "Member 'KillerProjectileAbilityProjectile_Cosmetic_OnCollisionDetected::SurfaceType' has a wrong offset!");

// Function DBDGameplay.KillerProjectileAbilityProjectile.OnAcquiredChanged
// 0x0001 (0x0001 - 0x0000)
struct KillerProjectileAbilityProjectile_OnAcquiredChanged final
{
public:
	bool                                          IsAcquired;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerProjectileAbilityProjectile_OnAcquiredChanged) == 0x000001, "Wrong alignment on KillerProjectileAbilityProjectile_OnAcquiredChanged");
static_assert(sizeof(KillerProjectileAbilityProjectile_OnAcquiredChanged) == 0x000001, "Wrong size on KillerProjectileAbilityProjectile_OnAcquiredChanged");
static_assert(offsetof(KillerProjectileAbilityProjectile_OnAcquiredChanged, IsAcquired) == 0x000000, "Member 'KillerProjectileAbilityProjectile_OnAcquiredChanged::IsAcquired' has a wrong offset!");

// Function DBDGameplay.KillerProjectileAbilityProjectile.OnActivationChanged
// 0x0001 (0x0001 - 0x0000)
struct KillerProjectileAbilityProjectile_OnActivationChanged final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerProjectileAbilityProjectile_OnActivationChanged) == 0x000001, "Wrong alignment on KillerProjectileAbilityProjectile_OnActivationChanged");
static_assert(sizeof(KillerProjectileAbilityProjectile_OnActivationChanged) == 0x000001, "Wrong size on KillerProjectileAbilityProjectile_OnActivationChanged");
static_assert(offsetof(KillerProjectileAbilityProjectile_OnActivationChanged, Enabled) == 0x000000, "Member 'KillerProjectileAbilityProjectile_OnActivationChanged::Enabled' has a wrong offset!");

// Function DBDGameplay.KillerProjectileAbilityProjectile.OnComponentHit
// 0x0120 (0x0120 - 0x0000)
struct KillerProjectileAbilityProjectile_OnComponentHit final
{
public:
	class UPrimitiveComponent*                    HitComponent;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComponent;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NormalImpulse;                                     // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0030(0x00F0)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerProjectileAbilityProjectile_OnComponentHit) == 0x000008, "Wrong alignment on KillerProjectileAbilityProjectile_OnComponentHit");
static_assert(sizeof(KillerProjectileAbilityProjectile_OnComponentHit) == 0x000120, "Wrong size on KillerProjectileAbilityProjectile_OnComponentHit");
static_assert(offsetof(KillerProjectileAbilityProjectile_OnComponentHit, HitComponent) == 0x000000, "Member 'KillerProjectileAbilityProjectile_OnComponentHit::HitComponent' has a wrong offset!");
static_assert(offsetof(KillerProjectileAbilityProjectile_OnComponentHit, OtherActor) == 0x000008, "Member 'KillerProjectileAbilityProjectile_OnComponentHit::OtherActor' has a wrong offset!");
static_assert(offsetof(KillerProjectileAbilityProjectile_OnComponentHit, OtherComponent) == 0x000010, "Member 'KillerProjectileAbilityProjectile_OnComponentHit::OtherComponent' has a wrong offset!");
static_assert(offsetof(KillerProjectileAbilityProjectile_OnComponentHit, NormalImpulse) == 0x000018, "Member 'KillerProjectileAbilityProjectile_OnComponentHit::NormalImpulse' has a wrong offset!");
static_assert(offsetof(KillerProjectileAbilityProjectile_OnComponentHit, HitResult) == 0x000030, "Member 'KillerProjectileAbilityProjectile_OnComponentHit::HitResult' has a wrong offset!");

// Function DBDGameplay.TargetingTeleportInteraction.Server_SetTeleportTarget
// 0x0008 (0x0008 - 0x0000)
struct TargetingTeleportInteraction_Server_SetTeleportTarget final
{
public:
	class UTargetableComponent*                   Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetingTeleportInteraction_Server_SetTeleportTarget) == 0x000008, "Wrong alignment on TargetingTeleportInteraction_Server_SetTeleportTarget");
static_assert(sizeof(TargetingTeleportInteraction_Server_SetTeleportTarget) == 0x000008, "Wrong size on TargetingTeleportInteraction_Server_SetTeleportTarget");
static_assert(offsetof(TargetingTeleportInteraction_Server_SetTeleportTarget, Target) == 0x000000, "Member 'TargetingTeleportInteraction_Server_SetTeleportTarget::Target' has a wrong offset!");

// Function DBDGameplay.BlindAndDeafenRangedExplosiveActorEffect.Authority_TryToBlind
// 0x0018 (0x0018 - 0x0000)
struct BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToBlind final
{
public:
	class UBlindableBaseComponent*                BlindableComponent;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 effectorActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToBlind) == 0x000008, "Wrong alignment on BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToBlind");
static_assert(sizeof(BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToBlind) == 0x000018, "Wrong size on BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToBlind");
static_assert(offsetof(BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToBlind, BlindableComponent) == 0x000000, "Member 'BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToBlind::BlindableComponent' has a wrong offset!");
static_assert(offsetof(BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToBlind, effectorActor) == 0x000008, "Member 'BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToBlind::effectorActor' has a wrong offset!");
static_assert(offsetof(BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToBlind, ReturnValue) == 0x000010, "Member 'BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToBlind::ReturnValue' has a wrong offset!");

// Function DBDGameplay.BlindAndDeafenRangedExplosiveActorEffect.Authority_TryToDeafen
// 0x0018 (0x0018 - 0x0000)
struct BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToDeafen final
{
public:
	const class ADBDPlayer*                       Player;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAudioFXComponent*                      AudioFXComponent;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToDeafen) == 0x000008, "Wrong alignment on BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToDeafen");
static_assert(sizeof(BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToDeafen) == 0x000018, "Wrong size on BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToDeafen");
static_assert(offsetof(BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToDeafen, Player) == 0x000000, "Member 'BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToDeafen::Player' has a wrong offset!");
static_assert(offsetof(BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToDeafen, AudioFXComponent) == 0x000008, "Member 'BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToDeafen::AudioFXComponent' has a wrong offset!");
static_assert(offsetof(BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToDeafen, ReturnValue) == 0x000010, "Member 'BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToDeafen::ReturnValue' has a wrong offset!");

// Function DBDGameplay.BlindAndDeafenRangedExplosiveActorEffect.GetBlindnessEffectDuration
// 0x0010 (0x0010 - 0x0000)
struct BlindAndDeafenRangedExplosiveActorEffect_GetBlindnessEffectDuration final
{
public:
	const class AActor*                           Player;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BlindAndDeafenRangedExplosiveActorEffect_GetBlindnessEffectDuration) == 0x000008, "Wrong alignment on BlindAndDeafenRangedExplosiveActorEffect_GetBlindnessEffectDuration");
static_assert(sizeof(BlindAndDeafenRangedExplosiveActorEffect_GetBlindnessEffectDuration) == 0x000010, "Wrong size on BlindAndDeafenRangedExplosiveActorEffect_GetBlindnessEffectDuration");
static_assert(offsetof(BlindAndDeafenRangedExplosiveActorEffect_GetBlindnessEffectDuration, Player) == 0x000000, "Member 'BlindAndDeafenRangedExplosiveActorEffect_GetBlindnessEffectDuration::Player' has a wrong offset!");
static_assert(offsetof(BlindAndDeafenRangedExplosiveActorEffect_GetBlindnessEffectDuration, ReturnValue) == 0x000008, "Member 'BlindAndDeafenRangedExplosiveActorEffect_GetBlindnessEffectDuration::ReturnValue' has a wrong offset!");

// Function DBDGameplay.BlindAndDeafenRangedExplosiveActorEffect.GetDeafnessEffectDuration
// 0x0010 (0x0010 - 0x0000)
struct BlindAndDeafenRangedExplosiveActorEffect_GetDeafnessEffectDuration final
{
public:
	const class AActor*                           Player;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BlindAndDeafenRangedExplosiveActorEffect_GetDeafnessEffectDuration) == 0x000008, "Wrong alignment on BlindAndDeafenRangedExplosiveActorEffect_GetDeafnessEffectDuration");
static_assert(sizeof(BlindAndDeafenRangedExplosiveActorEffect_GetDeafnessEffectDuration) == 0x000010, "Wrong size on BlindAndDeafenRangedExplosiveActorEffect_GetDeafnessEffectDuration");
static_assert(offsetof(BlindAndDeafenRangedExplosiveActorEffect_GetDeafnessEffectDuration, Player) == 0x000000, "Member 'BlindAndDeafenRangedExplosiveActorEffect_GetDeafnessEffectDuration::Player' has a wrong offset!");
static_assert(offsetof(BlindAndDeafenRangedExplosiveActorEffect_GetDeafnessEffectDuration, ReturnValue) == 0x000008, "Member 'BlindAndDeafenRangedExplosiveActorEffect_GetDeafnessEffectDuration::ReturnValue' has a wrong offset!");

// Function DBDGameplay.BubbleIndicatorNotifier.ActivateBubbleIndicator
// 0x0080 (0x0080 - 0x0000)
struct BubbleIndicatorNotifier_ActivateBubbleIndicator final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABubbleIndicator*                       BubbleIndicator;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x0010(0x0060)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TriggerLoudNoise;                                  // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Lifetime;                                          // 0x0074(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         audibleRange;                                      // 0x0078(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BubbleIndicatorNotifier_ActivateBubbleIndicator) == 0x000010, "Wrong alignment on BubbleIndicatorNotifier_ActivateBubbleIndicator");
static_assert(sizeof(BubbleIndicatorNotifier_ActivateBubbleIndicator) == 0x000080, "Wrong size on BubbleIndicatorNotifier_ActivateBubbleIndicator");
static_assert(offsetof(BubbleIndicatorNotifier_ActivateBubbleIndicator, WorldContextObject) == 0x000000, "Member 'BubbleIndicatorNotifier_ActivateBubbleIndicator::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BubbleIndicatorNotifier_ActivateBubbleIndicator, BubbleIndicator) == 0x000008, "Member 'BubbleIndicatorNotifier_ActivateBubbleIndicator::BubbleIndicator' has a wrong offset!");
static_assert(offsetof(BubbleIndicatorNotifier_ActivateBubbleIndicator, Transform) == 0x000010, "Member 'BubbleIndicatorNotifier_ActivateBubbleIndicator::Transform' has a wrong offset!");
static_assert(offsetof(BubbleIndicatorNotifier_ActivateBubbleIndicator, TriggerLoudNoise) == 0x000070, "Member 'BubbleIndicatorNotifier_ActivateBubbleIndicator::TriggerLoudNoise' has a wrong offset!");
static_assert(offsetof(BubbleIndicatorNotifier_ActivateBubbleIndicator, Lifetime) == 0x000074, "Member 'BubbleIndicatorNotifier_ActivateBubbleIndicator::Lifetime' has a wrong offset!");
static_assert(offsetof(BubbleIndicatorNotifier_ActivateBubbleIndicator, audibleRange) == 0x000078, "Member 'BubbleIndicatorNotifier_ActivateBubbleIndicator::audibleRange' has a wrong offset!");

// Function DBDGameplay.BubbleIndicatorNotifier.PreSpawnBubbleIndicator
// 0x0020 (0x0020 - 0x0000)
struct BubbleIndicatorNotifier_PreSpawnBubbleIndicator final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABubbleIndicator>           bubbleIndicatorBP;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            silhouetteStaticMesh;                              // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABubbleIndicator*                       ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BubbleIndicatorNotifier_PreSpawnBubbleIndicator) == 0x000008, "Wrong alignment on BubbleIndicatorNotifier_PreSpawnBubbleIndicator");
static_assert(sizeof(BubbleIndicatorNotifier_PreSpawnBubbleIndicator) == 0x000020, "Wrong size on BubbleIndicatorNotifier_PreSpawnBubbleIndicator");
static_assert(offsetof(BubbleIndicatorNotifier_PreSpawnBubbleIndicator, WorldContextObject) == 0x000000, "Member 'BubbleIndicatorNotifier_PreSpawnBubbleIndicator::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BubbleIndicatorNotifier_PreSpawnBubbleIndicator, bubbleIndicatorBP) == 0x000008, "Member 'BubbleIndicatorNotifier_PreSpawnBubbleIndicator::bubbleIndicatorBP' has a wrong offset!");
static_assert(offsetof(BubbleIndicatorNotifier_PreSpawnBubbleIndicator, silhouetteStaticMesh) == 0x000010, "Member 'BubbleIndicatorNotifier_PreSpawnBubbleIndicator::silhouetteStaticMesh' has a wrong offset!");
static_assert(offsetof(BubbleIndicatorNotifier_PreSpawnBubbleIndicator, ReturnValue) == 0x000018, "Member 'BubbleIndicatorNotifier_PreSpawnBubbleIndicator::ReturnValue' has a wrong offset!");

// Function DBDGameplay.BubbleIndicatorNotifier.SpawnBubbleIndicator
// 0x0090 (0x0090 - 0x0000)
struct BubbleIndicatorNotifier_SpawnBubbleIndicator final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABubbleIndicator>           bubbleIndicatorBP;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x0010(0x0060)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TriggerLoudNoise;                                  // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBubbleShowedPlayerType                       showedPlayerType;                                  // 0x0071(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x2];                                       // 0x0072(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Lifetime;                                          // 0x0074(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            silhouetteStaticMesh;                              // 0x0078(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         audibleRange;                                      // 0x0080(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0xC];                                       // 0x0084(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BubbleIndicatorNotifier_SpawnBubbleIndicator) == 0x000010, "Wrong alignment on BubbleIndicatorNotifier_SpawnBubbleIndicator");
static_assert(sizeof(BubbleIndicatorNotifier_SpawnBubbleIndicator) == 0x000090, "Wrong size on BubbleIndicatorNotifier_SpawnBubbleIndicator");
static_assert(offsetof(BubbleIndicatorNotifier_SpawnBubbleIndicator, WorldContextObject) == 0x000000, "Member 'BubbleIndicatorNotifier_SpawnBubbleIndicator::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BubbleIndicatorNotifier_SpawnBubbleIndicator, bubbleIndicatorBP) == 0x000008, "Member 'BubbleIndicatorNotifier_SpawnBubbleIndicator::bubbleIndicatorBP' has a wrong offset!");
static_assert(offsetof(BubbleIndicatorNotifier_SpawnBubbleIndicator, Transform) == 0x000010, "Member 'BubbleIndicatorNotifier_SpawnBubbleIndicator::Transform' has a wrong offset!");
static_assert(offsetof(BubbleIndicatorNotifier_SpawnBubbleIndicator, TriggerLoudNoise) == 0x000070, "Member 'BubbleIndicatorNotifier_SpawnBubbleIndicator::TriggerLoudNoise' has a wrong offset!");
static_assert(offsetof(BubbleIndicatorNotifier_SpawnBubbleIndicator, showedPlayerType) == 0x000071, "Member 'BubbleIndicatorNotifier_SpawnBubbleIndicator::showedPlayerType' has a wrong offset!");
static_assert(offsetof(BubbleIndicatorNotifier_SpawnBubbleIndicator, Lifetime) == 0x000074, "Member 'BubbleIndicatorNotifier_SpawnBubbleIndicator::Lifetime' has a wrong offset!");
static_assert(offsetof(BubbleIndicatorNotifier_SpawnBubbleIndicator, silhouetteStaticMesh) == 0x000078, "Member 'BubbleIndicatorNotifier_SpawnBubbleIndicator::silhouetteStaticMesh' has a wrong offset!");
static_assert(offsetof(BubbleIndicatorNotifier_SpawnBubbleIndicator, audibleRange) == 0x000080, "Member 'BubbleIndicatorNotifier_SpawnBubbleIndicator::audibleRange' has a wrong offset!");

// Function DBDGameplay.KillerFormSwitchingAbility.Cosmetic_OnCurrentFormChanged
// 0x0001 (0x0001 - 0x0000)
struct KillerFormSwitchingAbility_Cosmetic_OnCurrentFormChanged final
{
public:
	bool                                          isStartingForm;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerFormSwitchingAbility_Cosmetic_OnCurrentFormChanged) == 0x000001, "Wrong alignment on KillerFormSwitchingAbility_Cosmetic_OnCurrentFormChanged");
static_assert(sizeof(KillerFormSwitchingAbility_Cosmetic_OnCurrentFormChanged) == 0x000001, "Wrong size on KillerFormSwitchingAbility_Cosmetic_OnCurrentFormChanged");
static_assert(offsetof(KillerFormSwitchingAbility_Cosmetic_OnCurrentFormChanged, isStartingForm) == 0x000000, "Member 'KillerFormSwitchingAbility_Cosmetic_OnCurrentFormChanged::isStartingForm' has a wrong offset!");

// Function DBDGameplay.KillerFormSwitchingAbility.Cosmetic_OnEnterForm
// 0x0010 (0x0010 - 0x0000)
struct KillerFormSwitchingAbility_Cosmetic_OnEnterForm final
{
public:
	struct FGameplayTag                           formID;                                            // 0x0000(0x000C)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isStartingForm;                                    // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KillerFormSwitchingAbility_Cosmetic_OnEnterForm) == 0x000004, "Wrong alignment on KillerFormSwitchingAbility_Cosmetic_OnEnterForm");
static_assert(sizeof(KillerFormSwitchingAbility_Cosmetic_OnEnterForm) == 0x000010, "Wrong size on KillerFormSwitchingAbility_Cosmetic_OnEnterForm");
static_assert(offsetof(KillerFormSwitchingAbility_Cosmetic_OnEnterForm, formID) == 0x000000, "Member 'KillerFormSwitchingAbility_Cosmetic_OnEnterForm::formID' has a wrong offset!");
static_assert(offsetof(KillerFormSwitchingAbility_Cosmetic_OnEnterForm, isStartingForm) == 0x00000C, "Member 'KillerFormSwitchingAbility_Cosmetic_OnEnterForm::isStartingForm' has a wrong offset!");

// Function DBDGameplay.KillerFormSwitchingAbility.Cosmetic_OnExitForm
// 0x000C (0x000C - 0x0000)
struct KillerFormSwitchingAbility_Cosmetic_OnExitForm final
{
public:
	struct FGameplayTag                           formID;                                            // 0x0000(0x000C)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerFormSwitchingAbility_Cosmetic_OnExitForm) == 0x000004, "Wrong alignment on KillerFormSwitchingAbility_Cosmetic_OnExitForm");
static_assert(sizeof(KillerFormSwitchingAbility_Cosmetic_OnExitForm) == 0x00000C, "Wrong size on KillerFormSwitchingAbility_Cosmetic_OnExitForm");
static_assert(offsetof(KillerFormSwitchingAbility_Cosmetic_OnExitForm, formID) == 0x000000, "Member 'KillerFormSwitchingAbility_Cosmetic_OnExitForm::formID' has a wrong offset!");

// Function DBDGameplay.KillerFormSwitchingAbility.GetTransitionDuration
// 0x0004 (0x0004 - 0x0000)
struct KillerFormSwitchingAbility_GetTransitionDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerFormSwitchingAbility_GetTransitionDuration) == 0x000004, "Wrong alignment on KillerFormSwitchingAbility_GetTransitionDuration");
static_assert(sizeof(KillerFormSwitchingAbility_GetTransitionDuration) == 0x000004, "Wrong size on KillerFormSwitchingAbility_GetTransitionDuration");
static_assert(offsetof(KillerFormSwitchingAbility_GetTransitionDuration, ReturnValue) == 0x000000, "Member 'KillerFormSwitchingAbility_GetTransitionDuration::ReturnValue' has a wrong offset!");

// Function DBDGameplay.KillerFormSwitchingAbility.OnRep_CurrentFormID
// 0x000C (0x000C - 0x0000)
struct KillerFormSwitchingAbility_OnRep_CurrentFormID final
{
public:
	struct FGameplayTag                           oldFormId;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerFormSwitchingAbility_OnRep_CurrentFormID) == 0x000004, "Wrong alignment on KillerFormSwitchingAbility_OnRep_CurrentFormID");
static_assert(sizeof(KillerFormSwitchingAbility_OnRep_CurrentFormID) == 0x00000C, "Wrong size on KillerFormSwitchingAbility_OnRep_CurrentFormID");
static_assert(offsetof(KillerFormSwitchingAbility_OnRep_CurrentFormID, oldFormId) == 0x000000, "Member 'KillerFormSwitchingAbility_OnRep_CurrentFormID::oldFormId' has a wrong offset!");

// Function DBDGameplay.KillerFormSwitchingAbility.GetCurrentFormID
// 0x000C (0x000C - 0x0000)
struct KillerFormSwitchingAbility_GetCurrentFormID final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerFormSwitchingAbility_GetCurrentFormID) == 0x000004, "Wrong alignment on KillerFormSwitchingAbility_GetCurrentFormID");
static_assert(sizeof(KillerFormSwitchingAbility_GetCurrentFormID) == 0x00000C, "Wrong size on KillerFormSwitchingAbility_GetCurrentFormID");
static_assert(offsetof(KillerFormSwitchingAbility_GetCurrentFormID, ReturnValue) == 0x000000, "Member 'KillerFormSwitchingAbility_GetCurrentFormID::ReturnValue' has a wrong offset!");

// Function DBDGameplay.RangedExplosive.Multicast_InitFromSpawningPlayer
// 0x0008 (0x0008 - 0x0000)
struct RangedExplosive_Multicast_InitFromSpawningPlayer final
{
public:
	class ADBDPlayer*                             spawner;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RangedExplosive_Multicast_InitFromSpawningPlayer) == 0x000008, "Wrong alignment on RangedExplosive_Multicast_InitFromSpawningPlayer");
static_assert(sizeof(RangedExplosive_Multicast_InitFromSpawningPlayer) == 0x000008, "Wrong size on RangedExplosive_Multicast_InitFromSpawningPlayer");
static_assert(offsetof(RangedExplosive_Multicast_InitFromSpawningPlayer, spawner) == 0x000000, "Member 'RangedExplosive_Multicast_InitFromSpawningPlayer::spawner' has a wrong offset!");

// Function DBDGameplay.RangedExplosive.OnFuseBurnUpdate
// 0x0008 (0x0008 - 0x0000)
struct RangedExplosive_OnFuseBurnUpdate final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         fuseTimeLeftPercent;                               // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RangedExplosive_OnFuseBurnUpdate) == 0x000004, "Wrong alignment on RangedExplosive_OnFuseBurnUpdate");
static_assert(sizeof(RangedExplosive_OnFuseBurnUpdate) == 0x000008, "Wrong size on RangedExplosive_OnFuseBurnUpdate");
static_assert(offsetof(RangedExplosive_OnFuseBurnUpdate, DeltaSeconds) == 0x000000, "Member 'RangedExplosive_OnFuseBurnUpdate::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(RangedExplosive_OnFuseBurnUpdate, fuseTimeLeftPercent) == 0x000004, "Member 'RangedExplosive_OnFuseBurnUpdate::fuseTimeLeftPercent' has a wrong offset!");

// Function DBDGameplay.RangedExplosive.GetExplosionEffectDuration
// 0x0004 (0x0004 - 0x0000)
struct RangedExplosive_GetExplosionEffectDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RangedExplosive_GetExplosionEffectDuration) == 0x000004, "Wrong alignment on RangedExplosive_GetExplosionEffectDuration");
static_assert(sizeof(RangedExplosive_GetExplosionEffectDuration) == 0x000004, "Wrong size on RangedExplosive_GetExplosionEffectDuration");
static_assert(offsetof(RangedExplosive_GetExplosionEffectDuration, ReturnValue) == 0x000000, "Member 'RangedExplosive_GetExplosionEffectDuration::ReturnValue' has a wrong offset!");

// Function DBDGameplay.RangedExplosive.GetExplosionRange
// 0x0004 (0x0004 - 0x0000)
struct RangedExplosive_GetExplosionRange final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RangedExplosive_GetExplosionRange) == 0x000004, "Wrong alignment on RangedExplosive_GetExplosionRange");
static_assert(sizeof(RangedExplosive_GetExplosionRange) == 0x000004, "Wrong size on RangedExplosive_GetExplosionRange");
static_assert(offsetof(RangedExplosive_GetExplosionRange, ReturnValue) == 0x000000, "Member 'RangedExplosive_GetExplosionRange::ReturnValue' has a wrong offset!");

// Function DBDGameplay.RangedExplosive.GetModifierValue
// 0x0010 (0x0010 - 0x0000)
struct RangedExplosive_GetModifierValue final
{
public:
	struct FGameplayTag                           Type;                                              // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RangedExplosive_GetModifierValue) == 0x000004, "Wrong alignment on RangedExplosive_GetModifierValue");
static_assert(sizeof(RangedExplosive_GetModifierValue) == 0x000010, "Wrong size on RangedExplosive_GetModifierValue");
static_assert(offsetof(RangedExplosive_GetModifierValue, Type) == 0x000000, "Member 'RangedExplosive_GetModifierValue::Type' has a wrong offset!");
static_assert(offsetof(RangedExplosive_GetModifierValue, ReturnValue) == 0x00000C, "Member 'RangedExplosive_GetModifierValue::ReturnValue' has a wrong offset!");

// Function DBDGameplay.RangedExplosive.GetOwningPlayer
// 0x0008 (0x0008 - 0x0000)
struct RangedExplosive_GetOwningPlayer final
{
public:
	class ADBDPlayer*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RangedExplosive_GetOwningPlayer) == 0x000008, "Wrong alignment on RangedExplosive_GetOwningPlayer");
static_assert(sizeof(RangedExplosive_GetOwningPlayer) == 0x000008, "Wrong size on RangedExplosive_GetOwningPlayer");
static_assert(offsetof(RangedExplosive_GetOwningPlayer, ReturnValue) == 0x000000, "Member 'RangedExplosive_GetOwningPlayer::ReturnValue' has a wrong offset!");

// Function DBDGameplay.RangedExplosive.GetRangedExplosiveActorEffect
// 0x0008 (0x0008 - 0x0000)
struct RangedExplosive_GetRangedExplosiveActorEffect final
{
public:
	class UBaseRangedExplosiveActorEffect*        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RangedExplosive_GetRangedExplosiveActorEffect) == 0x000008, "Wrong alignment on RangedExplosive_GetRangedExplosiveActorEffect");
static_assert(sizeof(RangedExplosive_GetRangedExplosiveActorEffect) == 0x000008, "Wrong size on RangedExplosive_GetRangedExplosiveActorEffect");
static_assert(offsetof(RangedExplosive_GetRangedExplosiveActorEffect, ReturnValue) == 0x000000, "Member 'RangedExplosive_GetRangedExplosiveActorEffect::ReturnValue' has a wrong offset!");

// Function DBDGameplay.CageHookPoolComponent.Multicast_SpawnTrapBlocker
// 0x0028 (0x0028 - 0x0000)
struct CageHookPoolComponent_Multicast_SpawnTrapBlocker final
{
public:
	TArray<struct FTransform>                     spawnLocations;                                    // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                BoxExtent;                                         // 0x0010(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CageHookPoolComponent_Multicast_SpawnTrapBlocker) == 0x000008, "Wrong alignment on CageHookPoolComponent_Multicast_SpawnTrapBlocker");
static_assert(sizeof(CageHookPoolComponent_Multicast_SpawnTrapBlocker) == 0x000028, "Wrong size on CageHookPoolComponent_Multicast_SpawnTrapBlocker");
static_assert(offsetof(CageHookPoolComponent_Multicast_SpawnTrapBlocker, spawnLocations) == 0x000000, "Member 'CageHookPoolComponent_Multicast_SpawnTrapBlocker::spawnLocations' has a wrong offset!");
static_assert(offsetof(CageHookPoolComponent_Multicast_SpawnTrapBlocker, BoxExtent) == 0x000010, "Member 'CageHookPoolComponent_Multicast_SpawnTrapBlocker::BoxExtent' has a wrong offset!");

// Function DBDGameplay.LimitGeneratorRegressionEventComponent.OnKillerProximityZoneForRegressionEventsOverlapBegin
// 0x0110 (0x0110 - 0x0000)
struct LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin final
{
public:
	class UPrimitiveComponent*                    HitComponent;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F0)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin) == 0x000008, "Wrong alignment on LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin");
static_assert(sizeof(LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin) == 0x000110, "Wrong size on LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin");
static_assert(offsetof(LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin, HitComponent) == 0x000000, "Member 'LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin::HitComponent' has a wrong offset!");
static_assert(offsetof(LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin, OtherActor) == 0x000008, "Member 'LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin::OtherActor' has a wrong offset!");
static_assert(offsetof(LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin, OtherComp) == 0x000010, "Member 'LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin::OtherComp' has a wrong offset!");
static_assert(offsetof(LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin, OtherBodyIndex) == 0x000018, "Member 'LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin, bFromSweep) == 0x00001C, "Member 'LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin::bFromSweep' has a wrong offset!");
static_assert(offsetof(LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin, SweepResult) == 0x000020, "Member 'LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin::SweepResult' has a wrong offset!");

// Function DBDGameplay.LimitGeneratorRegressionEventComponent.OnKillerProximityZoneForRegressionEventsOverlapEnd
// 0x0020 (0x0020 - 0x0000)
struct LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapEnd final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapEnd) == 0x000008, "Wrong alignment on LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapEnd");
static_assert(sizeof(LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapEnd) == 0x000020, "Wrong size on LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapEnd");
static_assert(offsetof(LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapEnd, OverlappedComponent) == 0x000000, "Member 'LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapEnd::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapEnd, OtherActor) == 0x000008, "Member 'LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapEnd::OtherActor' has a wrong offset!");
static_assert(offsetof(LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapEnd, OtherComp) == 0x000010, "Member 'LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapEnd::OtherComp' has a wrong offset!");
static_assert(offsetof(LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapEnd, OtherBodyIndex) == 0x000018, "Member 'LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapEnd::OtherBodyIndex' has a wrong offset!");

// Function DBDGameplay.LimitGeneratorRegressionEventComponent.GetMaxNumberRegressionEventsAllowed
// 0x0004 (0x0004 - 0x0000)
struct LimitGeneratorRegressionEventComponent_GetMaxNumberRegressionEventsAllowed final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LimitGeneratorRegressionEventComponent_GetMaxNumberRegressionEventsAllowed) == 0x000004, "Wrong alignment on LimitGeneratorRegressionEventComponent_GetMaxNumberRegressionEventsAllowed");
static_assert(sizeof(LimitGeneratorRegressionEventComponent_GetMaxNumberRegressionEventsAllowed) == 0x000004, "Wrong size on LimitGeneratorRegressionEventComponent_GetMaxNumberRegressionEventsAllowed");
static_assert(offsetof(LimitGeneratorRegressionEventComponent_GetMaxNumberRegressionEventsAllowed, ReturnValue) == 0x000000, "Member 'LimitGeneratorRegressionEventComponent_GetMaxNumberRegressionEventsAllowed::ReturnValue' has a wrong offset!");

// Function DBDGameplay.PalletTrackerVisibilityComponent.Cosmetic_OnPalletTrackerSelectedChanged
// 0x0001 (0x0001 - 0x0000)
struct PalletTrackerVisibilityComponent_Cosmetic_OnPalletTrackerSelectedChanged final
{
public:
	bool                                          Selected;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PalletTrackerVisibilityComponent_Cosmetic_OnPalletTrackerSelectedChanged) == 0x000001, "Wrong alignment on PalletTrackerVisibilityComponent_Cosmetic_OnPalletTrackerSelectedChanged");
static_assert(sizeof(PalletTrackerVisibilityComponent_Cosmetic_OnPalletTrackerSelectedChanged) == 0x000001, "Wrong size on PalletTrackerVisibilityComponent_Cosmetic_OnPalletTrackerSelectedChanged");
static_assert(offsetof(PalletTrackerVisibilityComponent_Cosmetic_OnPalletTrackerSelectedChanged, Selected) == 0x000000, "Member 'PalletTrackerVisibilityComponent_Cosmetic_OnPalletTrackerSelectedChanged::Selected' has a wrong offset!");

// Function DBDGameplay.PalletTrackerVisibilityComponent.Cosmetic_OnVisibilityChanged
// 0x0001 (0x0001 - 0x0000)
struct PalletTrackerVisibilityComponent_Cosmetic_OnVisibilityChanged final
{
public:
	bool                                          IsVisible;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PalletTrackerVisibilityComponent_Cosmetic_OnVisibilityChanged) == 0x000001, "Wrong alignment on PalletTrackerVisibilityComponent_Cosmetic_OnVisibilityChanged");
static_assert(sizeof(PalletTrackerVisibilityComponent_Cosmetic_OnVisibilityChanged) == 0x000001, "Wrong size on PalletTrackerVisibilityComponent_Cosmetic_OnVisibilityChanged");
static_assert(offsetof(PalletTrackerVisibilityComponent_Cosmetic_OnVisibilityChanged, IsVisible) == 0x000000, "Member 'PalletTrackerVisibilityComponent_Cosmetic_OnVisibilityChanged::IsVisible' has a wrong offset!");

// Function DBDGameplay.PalletTrackerVisibilityComponent.GetPalletTrackerOwner
// 0x0008 (0x0008 - 0x0000)
struct PalletTrackerVisibilityComponent_GetPalletTrackerOwner final
{
public:
	class APalletTracker*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PalletTrackerVisibilityComponent_GetPalletTrackerOwner) == 0x000008, "Wrong alignment on PalletTrackerVisibilityComponent_GetPalletTrackerOwner");
static_assert(sizeof(PalletTrackerVisibilityComponent_GetPalletTrackerOwner) == 0x000008, "Wrong size on PalletTrackerVisibilityComponent_GetPalletTrackerOwner");
static_assert(offsetof(PalletTrackerVisibilityComponent_GetPalletTrackerOwner, ReturnValue) == 0x000000, "Member 'PalletTrackerVisibilityComponent_GetPalletTrackerOwner::ReturnValue' has a wrong offset!");

// Function DBDGameplay.PowerChargeComponent.OnCurrentChargeChanged
// 0x0004 (0x0004 - 0x0000)
struct PowerChargeComponent_OnCurrentChargeChanged final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PowerChargeComponent_OnCurrentChargeChanged) == 0x000004, "Wrong alignment on PowerChargeComponent_OnCurrentChargeChanged");
static_assert(sizeof(PowerChargeComponent_OnCurrentChargeChanged) == 0x000004, "Wrong size on PowerChargeComponent_OnCurrentChargeChanged");
static_assert(offsetof(PowerChargeComponent_OnCurrentChargeChanged, Value) == 0x000000, "Member 'PowerChargeComponent_OnCurrentChargeChanged::Value' has a wrong offset!");

// Function DBDGameplay.AimableComponent.SetMaxAimDistance
// 0x0004 (0x0004 - 0x0000)
struct AimableComponent_SetMaxAimDistance final
{
public:
	float                                         maxAimDistance;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AimableComponent_SetMaxAimDistance) == 0x000004, "Wrong alignment on AimableComponent_SetMaxAimDistance");
static_assert(sizeof(AimableComponent_SetMaxAimDistance) == 0x000004, "Wrong size on AimableComponent_SetMaxAimDistance");
static_assert(offsetof(AimableComponent_SetMaxAimDistance, maxAimDistance) == 0x000000, "Member 'AimableComponent_SetMaxAimDistance::maxAimDistance' has a wrong offset!");

// Function DBDGameplay.AimableComponent.SetOcclusionIgnoredActors
// 0x0010 (0x0010 - 0x0000)
struct AimableComponent_SetOcclusionIgnoredActors final
{
public:
	TArray<class AActor*>                         IgnoredActors;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AimableComponent_SetOcclusionIgnoredActors) == 0x000008, "Wrong alignment on AimableComponent_SetOcclusionIgnoredActors");
static_assert(sizeof(AimableComponent_SetOcclusionIgnoredActors) == 0x000010, "Wrong size on AimableComponent_SetOcclusionIgnoredActors");
static_assert(offsetof(AimableComponent_SetOcclusionIgnoredActors, IgnoredActors) == 0x000000, "Member 'AimableComponent_SetOcclusionIgnoredActors::IgnoredActors' has a wrong offset!");

// Function DBDGameplay.AimableComponent.SetProcessors
// 0x0010 (0x0010 - 0x0000)
struct AimableComponent_SetProcessors final
{
public:
	TArray<class UAimPointProcessor*>             processors;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(AimableComponent_SetProcessors) == 0x000008, "Wrong alignment on AimableComponent_SetProcessors");
static_assert(sizeof(AimableComponent_SetProcessors) == 0x000010, "Wrong size on AimableComponent_SetProcessors");
static_assert(offsetof(AimableComponent_SetProcessors, processors) == 0x000000, "Member 'AimableComponent_SetProcessors::processors' has a wrong offset!");

// Function DBDGameplay.BubbleIndicator.ActivateBubbleFX
// 0x0004 (0x0004 - 0x0000)
struct BubbleIndicator_ActivateBubbleFX final
{
public:
	float                                         Duration;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BubbleIndicator_ActivateBubbleFX) == 0x000004, "Wrong alignment on BubbleIndicator_ActivateBubbleFX");
static_assert(sizeof(BubbleIndicator_ActivateBubbleFX) == 0x000004, "Wrong size on BubbleIndicator_ActivateBubbleFX");
static_assert(offsetof(BubbleIndicator_ActivateBubbleFX, Duration) == 0x000000, "Member 'BubbleIndicator_ActivateBubbleFX::Duration' has a wrong offset!");

// Function DBDGameplay.BubbleIndicator.RefreshBubbleVisibility
// 0x0001 (0x0001 - 0x0000)
struct BubbleIndicator_RefreshBubbleVisibility final
{
public:
	bool                                          IsVisible;                                         // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BubbleIndicator_RefreshBubbleVisibility) == 0x000001, "Wrong alignment on BubbleIndicator_RefreshBubbleVisibility");
static_assert(sizeof(BubbleIndicator_RefreshBubbleVisibility) == 0x000001, "Wrong size on BubbleIndicator_RefreshBubbleVisibility");
static_assert(offsetof(BubbleIndicator_RefreshBubbleVisibility, IsVisible) == 0x000000, "Member 'BubbleIndicator_RefreshBubbleVisibility::IsVisible' has a wrong offset!");

// Function DBDGameplay.BubbleIndicator.SetSilhouette
// 0x0008 (0x0008 - 0x0000)
struct BubbleIndicator_SetSilhouette final
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BubbleIndicator_SetSilhouette) == 0x000008, "Wrong alignment on BubbleIndicator_SetSilhouette");
static_assert(sizeof(BubbleIndicator_SetSilhouette) == 0x000008, "Wrong size on BubbleIndicator_SetSilhouette");
static_assert(offsetof(BubbleIndicator_SetSilhouette, StaticMesh) == 0x000000, "Member 'BubbleIndicator_SetSilhouette::StaticMesh' has a wrong offset!");

// Function DBDGameplay.KillerProjectileAbilityInterface.Cosmetic_SetProjectileVisibility
// 0x0001 (0x0001 - 0x0000)
struct KillerProjectileAbilityInterface_Cosmetic_SetProjectileVisibility final
{
public:
	bool                                          Visible;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerProjectileAbilityInterface_Cosmetic_SetProjectileVisibility) == 0x000001, "Wrong alignment on KillerProjectileAbilityInterface_Cosmetic_SetProjectileVisibility");
static_assert(sizeof(KillerProjectileAbilityInterface_Cosmetic_SetProjectileVisibility) == 0x000001, "Wrong size on KillerProjectileAbilityInterface_Cosmetic_SetProjectileVisibility");
static_assert(offsetof(KillerProjectileAbilityInterface_Cosmetic_SetProjectileVisibility, Visible) == 0x000000, "Member 'KillerProjectileAbilityInterface_Cosmetic_SetProjectileVisibility::Visible' has a wrong offset!");

// Function DBDGameplay.SteamPipeEffectComponent.Authority_OnHealthStateChanged
// 0x0040 (0x0040 - 0x0000)
struct SteamPipeEffectComponent_Authority_OnHealthStateChanged final
{
public:
	struct FGameplayTag                           GameplayTag;                                       // 0x0000(0x000C)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameEventData                         GameEventData;                                     // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SteamPipeEffectComponent_Authority_OnHealthStateChanged) == 0x000008, "Wrong alignment on SteamPipeEffectComponent_Authority_OnHealthStateChanged");
static_assert(sizeof(SteamPipeEffectComponent_Authority_OnHealthStateChanged) == 0x000040, "Wrong size on SteamPipeEffectComponent_Authority_OnHealthStateChanged");
static_assert(offsetof(SteamPipeEffectComponent_Authority_OnHealthStateChanged, GameplayTag) == 0x000000, "Member 'SteamPipeEffectComponent_Authority_OnHealthStateChanged::GameplayTag' has a wrong offset!");
static_assert(offsetof(SteamPipeEffectComponent_Authority_OnHealthStateChanged, GameEventData) == 0x000010, "Member 'SteamPipeEffectComponent_Authority_OnHealthStateChanged::GameEventData' has a wrong offset!");

// Function DBDGameplay.SteamPipeEffectComponent.Authority_OnStoppedCrouching
// 0x0040 (0x0040 - 0x0000)
struct SteamPipeEffectComponent_Authority_OnStoppedCrouching final
{
public:
	struct FGameplayTag                           GameplayTag;                                       // 0x0000(0x000C)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameEventData                         GameEventData;                                     // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SteamPipeEffectComponent_Authority_OnStoppedCrouching) == 0x000008, "Wrong alignment on SteamPipeEffectComponent_Authority_OnStoppedCrouching");
static_assert(sizeof(SteamPipeEffectComponent_Authority_OnStoppedCrouching) == 0x000040, "Wrong size on SteamPipeEffectComponent_Authority_OnStoppedCrouching");
static_assert(offsetof(SteamPipeEffectComponent_Authority_OnStoppedCrouching, GameplayTag) == 0x000000, "Member 'SteamPipeEffectComponent_Authority_OnStoppedCrouching::GameplayTag' has a wrong offset!");
static_assert(offsetof(SteamPipeEffectComponent_Authority_OnStoppedCrouching, GameEventData) == 0x000010, "Member 'SteamPipeEffectComponent_Authority_OnStoppedCrouching::GameEventData' has a wrong offset!");

// Function DBDGameplay.AimPointPerlinNoise.SetBaseInaccuracyNoiseAmplitude
// 0x0004 (0x0004 - 0x0000)
struct AimPointPerlinNoise_SetBaseInaccuracyNoiseAmplitude final
{
public:
	float                                         Amplitude;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AimPointPerlinNoise_SetBaseInaccuracyNoiseAmplitude) == 0x000004, "Wrong alignment on AimPointPerlinNoise_SetBaseInaccuracyNoiseAmplitude");
static_assert(sizeof(AimPointPerlinNoise_SetBaseInaccuracyNoiseAmplitude) == 0x000004, "Wrong size on AimPointPerlinNoise_SetBaseInaccuracyNoiseAmplitude");
static_assert(offsetof(AimPointPerlinNoise_SetBaseInaccuracyNoiseAmplitude, Amplitude) == 0x000000, "Member 'AimPointPerlinNoise_SetBaseInaccuracyNoiseAmplitude::Amplitude' has a wrong offset!");

// Function DBDGameplay.AimPointPerlinNoise.SetBaseInaccuracyNoiseFrequency
// 0x0004 (0x0004 - 0x0000)
struct AimPointPerlinNoise_SetBaseInaccuracyNoiseFrequency final
{
public:
	float                                         Frequency;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AimPointPerlinNoise_SetBaseInaccuracyNoiseFrequency) == 0x000004, "Wrong alignment on AimPointPerlinNoise_SetBaseInaccuracyNoiseFrequency");
static_assert(sizeof(AimPointPerlinNoise_SetBaseInaccuracyNoiseFrequency) == 0x000004, "Wrong size on AimPointPerlinNoise_SetBaseInaccuracyNoiseFrequency");
static_assert(offsetof(AimPointPerlinNoise_SetBaseInaccuracyNoiseFrequency, Frequency) == 0x000000, "Member 'AimPointPerlinNoise_SetBaseInaccuracyNoiseFrequency::Frequency' has a wrong offset!");

// Function DBDGameplay.AimPointPerlinNoise.SetBaseInaccuracyNoiseOctaveCount
// 0x0004 (0x0004 - 0x0000)
struct AimPointPerlinNoise_SetBaseInaccuracyNoiseOctaveCount final
{
public:
	int32                                         octaveCount;                                       // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AimPointPerlinNoise_SetBaseInaccuracyNoiseOctaveCount) == 0x000004, "Wrong alignment on AimPointPerlinNoise_SetBaseInaccuracyNoiseOctaveCount");
static_assert(sizeof(AimPointPerlinNoise_SetBaseInaccuracyNoiseOctaveCount) == 0x000004, "Wrong size on AimPointPerlinNoise_SetBaseInaccuracyNoiseOctaveCount");
static_assert(offsetof(AimPointPerlinNoise_SetBaseInaccuracyNoiseOctaveCount, octaveCount) == 0x000000, "Member 'AimPointPerlinNoise_SetBaseInaccuracyNoiseOctaveCount::octaveCount' has a wrong offset!");

// Function DBDGameplay.AimPointPerlinNoise.SetBaseInaccuracyNoisePersistence
// 0x0004 (0x0004 - 0x0000)
struct AimPointPerlinNoise_SetBaseInaccuracyNoisePersistence final
{
public:
	float                                         noisePersistence;                                  // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AimPointPerlinNoise_SetBaseInaccuracyNoisePersistence) == 0x000004, "Wrong alignment on AimPointPerlinNoise_SetBaseInaccuracyNoisePersistence");
static_assert(sizeof(AimPointPerlinNoise_SetBaseInaccuracyNoisePersistence) == 0x000004, "Wrong size on AimPointPerlinNoise_SetBaseInaccuracyNoisePersistence");
static_assert(offsetof(AimPointPerlinNoise_SetBaseInaccuracyNoisePersistence, noisePersistence) == 0x000000, "Member 'AimPointPerlinNoise_SetBaseInaccuracyNoisePersistence::noisePersistence' has a wrong offset!");

// Function DBDGameplay.AimPointPerlinNoise.SetNoiseAmplitudeMultiplier
// 0x0004 (0x0004 - 0x0000)
struct AimPointPerlinNoise_SetNoiseAmplitudeMultiplier final
{
public:
	float                                         Multiplier;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AimPointPerlinNoise_SetNoiseAmplitudeMultiplier) == 0x000004, "Wrong alignment on AimPointPerlinNoise_SetNoiseAmplitudeMultiplier");
static_assert(sizeof(AimPointPerlinNoise_SetNoiseAmplitudeMultiplier) == 0x000004, "Wrong size on AimPointPerlinNoise_SetNoiseAmplitudeMultiplier");
static_assert(offsetof(AimPointPerlinNoise_SetNoiseAmplitudeMultiplier, Multiplier) == 0x000000, "Member 'AimPointPerlinNoise_SetNoiseAmplitudeMultiplier::Multiplier' has a wrong offset!");

// Function DBDGameplay.AimPointPerlinNoise.SetNoiseFrequencyMultiplier
// 0x0004 (0x0004 - 0x0000)
struct AimPointPerlinNoise_SetNoiseFrequencyMultiplier final
{
public:
	float                                         Multiplier;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AimPointPerlinNoise_SetNoiseFrequencyMultiplier) == 0x000004, "Wrong alignment on AimPointPerlinNoise_SetNoiseFrequencyMultiplier");
static_assert(sizeof(AimPointPerlinNoise_SetNoiseFrequencyMultiplier) == 0x000004, "Wrong size on AimPointPerlinNoise_SetNoiseFrequencyMultiplier");
static_assert(offsetof(AimPointPerlinNoise_SetNoiseFrequencyMultiplier, Multiplier) == 0x000000, "Member 'AimPointPerlinNoise_SetNoiseFrequencyMultiplier::Multiplier' has a wrong offset!");

// Function DBDGameplay.AISense_Terror.ReportTerrorEvent
// 0x0030 (0x0030 - 0x0000)
struct AISense_Terror_ReportTerrorEvent final
{
public:
	class UObject*                                worldContextObj;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0020(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTerrorRadiusEmitterComponent*          TerrorEmitter;                                     // 0x0028(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AISense_Terror_ReportTerrorEvent) == 0x000008, "Wrong alignment on AISense_Terror_ReportTerrorEvent");
static_assert(sizeof(AISense_Terror_ReportTerrorEvent) == 0x000030, "Wrong size on AISense_Terror_ReportTerrorEvent");
static_assert(offsetof(AISense_Terror_ReportTerrorEvent, worldContextObj) == 0x000000, "Member 'AISense_Terror_ReportTerrorEvent::worldContextObj' has a wrong offset!");
static_assert(offsetof(AISense_Terror_ReportTerrorEvent, Location) == 0x000008, "Member 'AISense_Terror_ReportTerrorEvent::Location' has a wrong offset!");
static_assert(offsetof(AISense_Terror_ReportTerrorEvent, Instigator) == 0x000020, "Member 'AISense_Terror_ReportTerrorEvent::Instigator' has a wrong offset!");
static_assert(offsetof(AISense_Terror_ReportTerrorEvent, TerrorEmitter) == 0x000028, "Member 'AISense_Terror_ReportTerrorEvent::TerrorEmitter' has a wrong offset!");

// Function DBDGameplay.BaseActorAttackableComponent.HitWithProjectile
// 0x0008 (0x0008 - 0x0000)
struct BaseActorAttackableComponent_HitWithProjectile final
{
public:
	class ABaseProjectile*                        Projectile;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseActorAttackableComponent_HitWithProjectile) == 0x000008, "Wrong alignment on BaseActorAttackableComponent_HitWithProjectile");
static_assert(sizeof(BaseActorAttackableComponent_HitWithProjectile) == 0x000008, "Wrong size on BaseActorAttackableComponent_HitWithProjectile");
static_assert(offsetof(BaseActorAttackableComponent_HitWithProjectile, Projectile) == 0x000000, "Member 'BaseActorAttackableComponent_HitWithProjectile::Projectile' has a wrong offset!");

// Function DBDGameplay.CollectableComponentUtilities.GetCollector
// 0x0010 (0x0010 - 0x0000)
struct CollectableComponentUtilities_GetCollector final
{
public:
	const class UActorComponent*                  Component;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADBDPlayer*                             ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CollectableComponentUtilities_GetCollector) == 0x000008, "Wrong alignment on CollectableComponentUtilities_GetCollector");
static_assert(sizeof(CollectableComponentUtilities_GetCollector) == 0x000010, "Wrong size on CollectableComponentUtilities_GetCollector");
static_assert(offsetof(CollectableComponentUtilities_GetCollector, Component) == 0x000000, "Member 'CollectableComponentUtilities_GetCollector::Component' has a wrong offset!");
static_assert(offsetof(CollectableComponentUtilities_GetCollector, ReturnValue) == 0x000008, "Member 'CollectableComponentUtilities_GetCollector::ReturnValue' has a wrong offset!");

// Function DBDGameplay.DBDCustomCheatComponent.OnCustomCheatCalledOnManager
// 0x000C (0x000C - 0x0000)
struct DBDCustomCheatComponent_OnCustomCheatCalledOnManager final
{
public:
	class FName                                   customCheatName;                                   // 0x0000(0x000C)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DBDCustomCheatComponent_OnCustomCheatCalledOnManager) == 0x000004, "Wrong alignment on DBDCustomCheatComponent_OnCustomCheatCalledOnManager");
static_assert(sizeof(DBDCustomCheatComponent_OnCustomCheatCalledOnManager) == 0x00000C, "Wrong size on DBDCustomCheatComponent_OnCustomCheatCalledOnManager");
static_assert(offsetof(DBDCustomCheatComponent_OnCustomCheatCalledOnManager, customCheatName) == 0x000000, "Member 'DBDCustomCheatComponent_OnCustomCheatCalledOnManager::customCheatName' has a wrong offset!");

// Function DBDGameplay.DBDCustomCheatManager.DBD_CallCustomCheat
// 0x000C (0x000C - 0x0000)
struct DBDCustomCheatManager_DBD_CallCustomCheat final
{
public:
	class FName                                   customCheatName;                                   // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DBDCustomCheatManager_DBD_CallCustomCheat) == 0x000004, "Wrong alignment on DBDCustomCheatManager_DBD_CallCustomCheat");
static_assert(sizeof(DBDCustomCheatManager_DBD_CallCustomCheat) == 0x00000C, "Wrong size on DBDCustomCheatManager_DBD_CallCustomCheat");
static_assert(offsetof(DBDCustomCheatManager_DBD_CallCustomCheat, customCheatName) == 0x000000, "Member 'DBDCustomCheatManager_DBD_CallCustomCheat::customCheatName' has a wrong offset!");

// Function DBDGameplay.DebugIndicator.SetColor
// 0x0010 (0x0010 - 0x0000)
struct DebugIndicator_SetColor final
{
public:
	struct FLinearColor                           Color;                                             // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DebugIndicator_SetColor) == 0x000004, "Wrong alignment on DebugIndicator_SetColor");
static_assert(sizeof(DebugIndicator_SetColor) == 0x000010, "Wrong size on DebugIndicator_SetColor");
static_assert(offsetof(DebugIndicator_SetColor, Color) == 0x000000, "Member 'DebugIndicator_SetColor::Color' has a wrong offset!");

// Function DBDGameplay.DebugIndicator.SetVisible
// 0x0001 (0x0001 - 0x0000)
struct DebugIndicator_SetVisible final
{
public:
	bool                                          Visible;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DebugIndicator_SetVisible) == 0x000001, "Wrong alignment on DebugIndicator_SetVisible");
static_assert(sizeof(DebugIndicator_SetVisible) == 0x000001, "Wrong size on DebugIndicator_SetVisible");
static_assert(offsetof(DebugIndicator_SetVisible, Visible) == 0x000000, "Member 'DebugIndicator_SetVisible::Visible' has a wrong offset!");

// Function DBDGameplay.EndGameEffectsComponent.OnLocallyObservedChanged
// 0x0008 (0x0008 - 0x0000)
struct EndGameEffectsComponent_OnLocallyObservedChanged final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EndGameEffectsComponent_OnLocallyObservedChanged) == 0x000008, "Wrong alignment on EndGameEffectsComponent_OnLocallyObservedChanged");
static_assert(sizeof(EndGameEffectsComponent_OnLocallyObservedChanged) == 0x000008, "Wrong size on EndGameEffectsComponent_OnLocallyObservedChanged");
static_assert(offsetof(EndGameEffectsComponent_OnLocallyObservedChanged, Player) == 0x000000, "Member 'EndGameEffectsComponent_OnLocallyObservedChanged::Player' has a wrong offset!");

// Function DBDGameplay.EndGameEffectsComponent.StartUpdateTimer
// 0x0040 (0x0040 - 0x0000)
struct EndGameEffectsComponent_StartUpdateTimer final
{
public:
	struct FGameplayTag                           gameEventType;                                     // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameEventData                         GameEventData;                                     // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(EndGameEffectsComponent_StartUpdateTimer) == 0x000008, "Wrong alignment on EndGameEffectsComponent_StartUpdateTimer");
static_assert(sizeof(EndGameEffectsComponent_StartUpdateTimer) == 0x000040, "Wrong size on EndGameEffectsComponent_StartUpdateTimer");
static_assert(offsetof(EndGameEffectsComponent_StartUpdateTimer, gameEventType) == 0x000000, "Member 'EndGameEffectsComponent_StartUpdateTimer::gameEventType' has a wrong offset!");
static_assert(offsetof(EndGameEffectsComponent_StartUpdateTimer, GameEventData) == 0x000010, "Member 'EndGameEffectsComponent_StartUpdateTimer::GameEventData' has a wrong offset!");

// Function DBDGameplay.EtherealComponent.Server_SetIsEthereal
// 0x0008 (0x0008 - 0x0000)
struct EtherealComponent_Server_SetIsEthereal final
{
public:
	float                                         Timestamp;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Ethereal;                                          // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(EtherealComponent_Server_SetIsEthereal) == 0x000004, "Wrong alignment on EtherealComponent_Server_SetIsEthereal");
static_assert(sizeof(EtherealComponent_Server_SetIsEthereal) == 0x000008, "Wrong size on EtherealComponent_Server_SetIsEthereal");
static_assert(offsetof(EtherealComponent_Server_SetIsEthereal, Timestamp) == 0x000000, "Member 'EtherealComponent_Server_SetIsEthereal::Timestamp' has a wrong offset!");
static_assert(offsetof(EtherealComponent_Server_SetIsEthereal, Ethereal) == 0x000004, "Member 'EtherealComponent_Server_SetIsEthereal::Ethereal' has a wrong offset!");

// Function DBDGameplay.RangeToActorsTrackerStrategy.OnInRangeToTrackedActorsChanged
// 0x0001 (0x0001 - 0x0000)
struct RangeToActorsTrackerStrategy_OnInRangeToTrackedActorsChanged final
{
public:
	bool                                          inRange;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RangeToActorsTrackerStrategy_OnInRangeToTrackedActorsChanged) == 0x000001, "Wrong alignment on RangeToActorsTrackerStrategy_OnInRangeToTrackedActorsChanged");
static_assert(sizeof(RangeToActorsTrackerStrategy_OnInRangeToTrackedActorsChanged) == 0x000001, "Wrong size on RangeToActorsTrackerStrategy_OnInRangeToTrackedActorsChanged");
static_assert(offsetof(RangeToActorsTrackerStrategy_OnInRangeToTrackedActorsChanged, inRange) == 0x000000, "Member 'RangeToActorsTrackerStrategy_OnInRangeToTrackedActorsChanged::inRange' has a wrong offset!");

// Function DBDGameplay.FadingBlockFeedback.OnFadeOutStarted
// 0x0004 (0x0004 - 0x0000)
struct FadingBlockFeedback_OnFadeOutStarted final
{
public:
	float                                         fadeDuration;                                      // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FadingBlockFeedback_OnFadeOutStarted) == 0x000004, "Wrong alignment on FadingBlockFeedback_OnFadeOutStarted");
static_assert(sizeof(FadingBlockFeedback_OnFadeOutStarted) == 0x000004, "Wrong size on FadingBlockFeedback_OnFadeOutStarted");
static_assert(offsetof(FadingBlockFeedback_OnFadeOutStarted, fadeDuration) == 0x000000, "Member 'FadingBlockFeedback_OnFadeOutStarted::fadeDuration' has a wrong offset!");

// Function DBDGameplay.FatherTerminalHackingInteraction.Authority_OnMinigameEnd
// 0x0010 (0x0010 - 0x0000)
struct FatherTerminalHackingInteraction_Authority_OnMinigameEnd final
{
public:
	class ASurvivor*                              Survivor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDirectionalMinigameResult                    Result;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FatherTerminalHackingInteraction_Authority_OnMinigameEnd) == 0x000008, "Wrong alignment on FatherTerminalHackingInteraction_Authority_OnMinigameEnd");
static_assert(sizeof(FatherTerminalHackingInteraction_Authority_OnMinigameEnd) == 0x000010, "Wrong size on FatherTerminalHackingInteraction_Authority_OnMinigameEnd");
static_assert(offsetof(FatherTerminalHackingInteraction_Authority_OnMinigameEnd, Survivor) == 0x000000, "Member 'FatherTerminalHackingInteraction_Authority_OnMinigameEnd::Survivor' has a wrong offset!");
static_assert(offsetof(FatherTerminalHackingInteraction_Authority_OnMinigameEnd, Result) == 0x000008, "Member 'FatherTerminalHackingInteraction_Authority_OnMinigameEnd::Result' has a wrong offset!");

// Function DBDGameplay.Flashlight.GetSpotlightComponent
// 0x0008 (0x0008 - 0x0000)
struct Flashlight_GetSpotlightComponent final
{
public:
	class USpotLightComponent*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Flashlight_GetSpotlightComponent) == 0x000008, "Wrong alignment on Flashlight_GetSpotlightComponent");
static_assert(sizeof(Flashlight_GetSpotlightComponent) == 0x000008, "Wrong size on Flashlight_GetSpotlightComponent");
static_assert(offsetof(Flashlight_GetSpotlightComponent, ReturnValue) == 0x000000, "Member 'Flashlight_GetSpotlightComponent::ReturnValue' has a wrong offset!");

// Function DBDGameplay.FlashlightableComponent.IsLit
// 0x0001 (0x0001 - 0x0000)
struct FlashlightableComponent_IsLit final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightableComponent_IsLit) == 0x000001, "Wrong alignment on FlashlightableComponent_IsLit");
static_assert(sizeof(FlashlightableComponent_IsLit) == 0x000001, "Wrong size on FlashlightableComponent_IsLit");
static_assert(offsetof(FlashlightableComponent_IsLit, ReturnValue) == 0x000000, "Member 'FlashlightableComponent_IsLit::ReturnValue' has a wrong offset!");

// Function DBDGameplay.FlashlightConeComponent.GetEffectiveConeHalfAngle
// 0x0004 (0x0004 - 0x0000)
struct FlashlightConeComponent_GetEffectiveConeHalfAngle final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightConeComponent_GetEffectiveConeHalfAngle) == 0x000004, "Wrong alignment on FlashlightConeComponent_GetEffectiveConeHalfAngle");
static_assert(sizeof(FlashlightConeComponent_GetEffectiveConeHalfAngle) == 0x000004, "Wrong size on FlashlightConeComponent_GetEffectiveConeHalfAngle");
static_assert(offsetof(FlashlightConeComponent_GetEffectiveConeHalfAngle, ReturnValue) == 0x000000, "Member 'FlashlightConeComponent_GetEffectiveConeHalfAngle::ReturnValue' has a wrong offset!");

// Function DBDGameplay.FlashlightConeComponent.GetEffectiveConeLength
// 0x0004 (0x0004 - 0x0000)
struct FlashlightConeComponent_GetEffectiveConeLength final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightConeComponent_GetEffectiveConeLength) == 0x000004, "Wrong alignment on FlashlightConeComponent_GetEffectiveConeLength");
static_assert(sizeof(FlashlightConeComponent_GetEffectiveConeLength) == 0x000004, "Wrong size on FlashlightConeComponent_GetEffectiveConeLength");
static_assert(offsetof(FlashlightConeComponent_GetEffectiveConeLength, ReturnValue) == 0x000000, "Member 'FlashlightConeComponent_GetEffectiveConeLength::ReturnValue' has a wrong offset!");

// Function DBDGameplay.FlashlightConeComponent.GetOcclusionDistance
// 0x0004 (0x0004 - 0x0000)
struct FlashlightConeComponent_GetOcclusionDistance final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightConeComponent_GetOcclusionDistance) == 0x000004, "Wrong alignment on FlashlightConeComponent_GetOcclusionDistance");
static_assert(sizeof(FlashlightConeComponent_GetOcclusionDistance) == 0x000004, "Wrong size on FlashlightConeComponent_GetOcclusionDistance");
static_assert(offsetof(FlashlightConeComponent_GetOcclusionDistance, ReturnValue) == 0x000000, "Member 'FlashlightConeComponent_GetOcclusionDistance::ReturnValue' has a wrong offset!");

// Function DBDGameplay.FlashlightFXComponent.OnCollectedEvent
// 0x0008 (0x0008 - 0x0000)
struct FlashlightFXComponent_OnCollectedEvent final
{
public:
	class ADBDPlayer*                             collector;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightFXComponent_OnCollectedEvent) == 0x000008, "Wrong alignment on FlashlightFXComponent_OnCollectedEvent");
static_assert(sizeof(FlashlightFXComponent_OnCollectedEvent) == 0x000008, "Wrong size on FlashlightFXComponent_OnCollectedEvent");
static_assert(offsetof(FlashlightFXComponent_OnCollectedEvent, collector) == 0x000000, "Member 'FlashlightFXComponent_OnCollectedEvent::collector' has a wrong offset!");

// Function DBDGameplay.FlashlightFXComponent.OnCollectorLocallyObservedChangedEvent
// 0x0001 (0x0001 - 0x0000)
struct FlashlightFXComponent_OnCollectorLocallyObservedChangedEvent final
{
public:
	bool                                          IsLocallyObserved;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightFXComponent_OnCollectorLocallyObservedChangedEvent) == 0x000001, "Wrong alignment on FlashlightFXComponent_OnCollectorLocallyObservedChangedEvent");
static_assert(sizeof(FlashlightFXComponent_OnCollectorLocallyObservedChangedEvent) == 0x000001, "Wrong size on FlashlightFXComponent_OnCollectorLocallyObservedChangedEvent");
static_assert(offsetof(FlashlightFXComponent_OnCollectorLocallyObservedChangedEvent, IsLocallyObserved) == 0x000000, "Member 'FlashlightFXComponent_OnCollectorLocallyObservedChangedEvent::IsLocallyObserved' has a wrong offset!");

// Function DBDGameplay.FlashlightFXComponent.UpdateConeEvent
// 0x0008 (0x0008 - 0x0000)
struct FlashlightFXComponent_UpdateConeEvent final
{
public:
	float                                         Length;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         halfAngle;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightFXComponent_UpdateConeEvent) == 0x000004, "Wrong alignment on FlashlightFXComponent_UpdateConeEvent");
static_assert(sizeof(FlashlightFXComponent_UpdateConeEvent) == 0x000008, "Wrong size on FlashlightFXComponent_UpdateConeEvent");
static_assert(offsetof(FlashlightFXComponent_UpdateConeEvent, Length) == 0x000000, "Member 'FlashlightFXComponent_UpdateConeEvent::Length' has a wrong offset!");
static_assert(offsetof(FlashlightFXComponent_UpdateConeEvent, halfAngle) == 0x000004, "Member 'FlashlightFXComponent_UpdateConeEvent::halfAngle' has a wrong offset!");

// Function DBDGameplay.FlashlightFXComponent.GetBlindingSuccessRatio
// 0x0004 (0x0004 - 0x0000)
struct FlashlightFXComponent_GetBlindingSuccessRatio final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightFXComponent_GetBlindingSuccessRatio) == 0x000004, "Wrong alignment on FlashlightFXComponent_GetBlindingSuccessRatio");
static_assert(sizeof(FlashlightFXComponent_GetBlindingSuccessRatio) == 0x000004, "Wrong size on FlashlightFXComponent_GetBlindingSuccessRatio");
static_assert(offsetof(FlashlightFXComponent_GetBlindingSuccessRatio, ReturnValue) == 0x000000, "Member 'FlashlightFXComponent_GetBlindingSuccessRatio::ReturnValue' has a wrong offset!");

// Function DBDGameplay.FootstepManagerComponent.OnUpdateCreatorFootsteps
// 0x0008 (0x0008 - 0x0000)
struct FootstepManagerComponent_OnUpdateCreatorFootsteps final
{
public:
	class UFootstepCreatorComponent*              creator;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FootstepManagerComponent_OnUpdateCreatorFootsteps) == 0x000008, "Wrong alignment on FootstepManagerComponent_OnUpdateCreatorFootsteps");
static_assert(sizeof(FootstepManagerComponent_OnUpdateCreatorFootsteps) == 0x000008, "Wrong size on FootstepManagerComponent_OnUpdateCreatorFootsteps");
static_assert(offsetof(FootstepManagerComponent_OnUpdateCreatorFootsteps, creator) == 0x000000, "Member 'FootstepManagerComponent_OnUpdateCreatorFootsteps::creator' has a wrong offset!");

// Function DBDGameplay.FootstepManagerComponent.TriggerSpawnFootstep
// 0x0020 (0x0020 - 0x0000)
struct FootstepManagerComponent_TriggerSpawnFootstep final
{
public:
	class UFootstepCreatorComponent*              originatorComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FootstepManagerComponent_TriggerSpawnFootstep) == 0x000008, "Wrong alignment on FootstepManagerComponent_TriggerSpawnFootstep");
static_assert(sizeof(FootstepManagerComponent_TriggerSpawnFootstep) == 0x000020, "Wrong size on FootstepManagerComponent_TriggerSpawnFootstep");
static_assert(offsetof(FootstepManagerComponent_TriggerSpawnFootstep, originatorComponent) == 0x000000, "Member 'FootstepManagerComponent_TriggerSpawnFootstep::originatorComponent' has a wrong offset!");
static_assert(offsetof(FootstepManagerComponent_TriggerSpawnFootstep, Location) == 0x000008, "Member 'FootstepManagerComponent_TriggerSpawnFootstep::Location' has a wrong offset!");

// Function DBDGameplay.GeneratorWithMostProgressTracker.OnGeneratorCompleted
// 0x0001 (0x0001 - 0x0000)
struct GeneratorWithMostProgressTracker_OnGeneratorCompleted final
{
public:
	bool                                          isAutoCompleted;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GeneratorWithMostProgressTracker_OnGeneratorCompleted) == 0x000001, "Wrong alignment on GeneratorWithMostProgressTracker_OnGeneratorCompleted");
static_assert(sizeof(GeneratorWithMostProgressTracker_OnGeneratorCompleted) == 0x000001, "Wrong size on GeneratorWithMostProgressTracker_OnGeneratorCompleted");
static_assert(offsetof(GeneratorWithMostProgressTracker_OnGeneratorCompleted, isAutoCompleted) == 0x000000, "Member 'GeneratorWithMostProgressTracker_OnGeneratorCompleted::isAutoCompleted' has a wrong offset!");

// Function DBDGameplay.KillerInstinctComponent.GetParticleSystem
// 0x0008 (0x0008 - 0x0000)
struct KillerInstinctComponent_GetParticleSystem final
{
public:
	class UNiagaraComponent*                      ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerInstinctComponent_GetParticleSystem) == 0x000008, "Wrong alignment on KillerInstinctComponent_GetParticleSystem");
static_assert(sizeof(KillerInstinctComponent_GetParticleSystem) == 0x000008, "Wrong size on KillerInstinctComponent_GetParticleSystem");
static_assert(offsetof(KillerInstinctComponent_GetParticleSystem, ReturnValue) == 0x000000, "Member 'KillerInstinctComponent_GetParticleSystem::ReturnValue' has a wrong offset!");

// Function DBDGameplay.KillerInstinctComponent.IsRevealedToPlayer
// 0x0010 (0x0010 - 0x0000)
struct KillerInstinctComponent_IsRevealedToPlayer final
{
public:
	const class ADBDPlayer*                       Player;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KillerInstinctComponent_IsRevealedToPlayer) == 0x000008, "Wrong alignment on KillerInstinctComponent_IsRevealedToPlayer");
static_assert(sizeof(KillerInstinctComponent_IsRevealedToPlayer) == 0x000010, "Wrong size on KillerInstinctComponent_IsRevealedToPlayer");
static_assert(offsetof(KillerInstinctComponent_IsRevealedToPlayer, Player) == 0x000000, "Member 'KillerInstinctComponent_IsRevealedToPlayer::Player' has a wrong offset!");
static_assert(offsetof(KillerInstinctComponent_IsRevealedToPlayer, ReturnValue) == 0x000008, "Member 'KillerInstinctComponent_IsRevealedToPlayer::ReturnValue' has a wrong offset!");

// Function DBDGameplay.KillerInstinctComponent.OnKillerLocallyObservedChanged
// 0x0001 (0x0001 - 0x0000)
struct KillerInstinctComponent_OnKillerLocallyObservedChanged final
{
public:
	bool                                          locallyObserved;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerInstinctComponent_OnKillerLocallyObservedChanged) == 0x000001, "Wrong alignment on KillerInstinctComponent_OnKillerLocallyObservedChanged");
static_assert(sizeof(KillerInstinctComponent_OnKillerLocallyObservedChanged) == 0x000001, "Wrong size on KillerInstinctComponent_OnKillerLocallyObservedChanged");
static_assert(offsetof(KillerInstinctComponent_OnKillerLocallyObservedChanged, locallyObserved) == 0x000000, "Member 'KillerInstinctComponent_OnKillerLocallyObservedChanged::locallyObserved' has a wrong offset!");

// Function DBDGameplay.KillerInstinctComponent.SetParticleSystem
// 0x0008 (0x0008 - 0x0000)
struct KillerInstinctComponent_SetParticleSystem final
{
public:
	class UNiagaraComponent*                      ParticleSystemComponent;                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerInstinctComponent_SetParticleSystem) == 0x000008, "Wrong alignment on KillerInstinctComponent_SetParticleSystem");
static_assert(sizeof(KillerInstinctComponent_SetParticleSystem) == 0x000008, "Wrong size on KillerInstinctComponent_SetParticleSystem");
static_assert(offsetof(KillerInstinctComponent_SetParticleSystem, ParticleSystemComponent) == 0x000000, "Member 'KillerInstinctComponent_SetParticleSystem::ParticleSystemComponent' has a wrong offset!");

// Function DBDGameplay.KillerPowerUtilities.GetKillerPowerFromPlayer
// 0x0010 (0x0010 - 0x0000)
struct KillerPowerUtilities_GetKillerPowerFromPlayer final
{
public:
	const class ADBDPlayer*                       Player;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AKillerPower*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerPowerUtilities_GetKillerPowerFromPlayer) == 0x000008, "Wrong alignment on KillerPowerUtilities_GetKillerPowerFromPlayer");
static_assert(sizeof(KillerPowerUtilities_GetKillerPowerFromPlayer) == 0x000010, "Wrong size on KillerPowerUtilities_GetKillerPowerFromPlayer");
static_assert(offsetof(KillerPowerUtilities_GetKillerPowerFromPlayer, Player) == 0x000000, "Member 'KillerPowerUtilities_GetKillerPowerFromPlayer::Player' has a wrong offset!");
static_assert(offsetof(KillerPowerUtilities_GetKillerPowerFromPlayer, ReturnValue) == 0x000008, "Member 'KillerPowerUtilities_GetKillerPowerFromPlayer::ReturnValue' has a wrong offset!");

// Function DBDGameplay.KillerProjectileAbilityChargeThrowInteraction.Cosmetic_MakeArcPreview
// 0x0108 (0x0108 - 0x0000)
struct KillerProjectileAbilityChargeThrowInteraction_Cosmetic_MakeArcPreview final
{
public:
	TArray<struct FVector>                        Points;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0010(0x00F0)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          shouldShowImpactPoint;                             // 0x0100(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x3];                                      // 0x0101(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         arclengthAtImpactPoint;                            // 0x0104(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerProjectileAbilityChargeThrowInteraction_Cosmetic_MakeArcPreview) == 0x000008, "Wrong alignment on KillerProjectileAbilityChargeThrowInteraction_Cosmetic_MakeArcPreview");
static_assert(sizeof(KillerProjectileAbilityChargeThrowInteraction_Cosmetic_MakeArcPreview) == 0x000108, "Wrong size on KillerProjectileAbilityChargeThrowInteraction_Cosmetic_MakeArcPreview");
static_assert(offsetof(KillerProjectileAbilityChargeThrowInteraction_Cosmetic_MakeArcPreview, Points) == 0x000000, "Member 'KillerProjectileAbilityChargeThrowInteraction_Cosmetic_MakeArcPreview::Points' has a wrong offset!");
static_assert(offsetof(KillerProjectileAbilityChargeThrowInteraction_Cosmetic_MakeArcPreview, HitResult) == 0x000010, "Member 'KillerProjectileAbilityChargeThrowInteraction_Cosmetic_MakeArcPreview::HitResult' has a wrong offset!");
static_assert(offsetof(KillerProjectileAbilityChargeThrowInteraction_Cosmetic_MakeArcPreview, shouldShowImpactPoint) == 0x000100, "Member 'KillerProjectileAbilityChargeThrowInteraction_Cosmetic_MakeArcPreview::shouldShowImpactPoint' has a wrong offset!");
static_assert(offsetof(KillerProjectileAbilityChargeThrowInteraction_Cosmetic_MakeArcPreview, arclengthAtImpactPoint) == 0x000104, "Member 'KillerProjectileAbilityChargeThrowInteraction_Cosmetic_MakeArcPreview::arclengthAtImpactPoint' has a wrong offset!");

// Function DBDGameplay.LockerAccessInteraction.FireSoundEventFromInteractor
// 0x0010 (0x0010 - 0x0000)
struct LockerAccessInteraction_FireSoundEventFromInteractor final
{
public:
	class AActor*                                 Instigator;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADBDPlayer*                             instigatingPlayer;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LockerAccessInteraction_FireSoundEventFromInteractor) == 0x000008, "Wrong alignment on LockerAccessInteraction_FireSoundEventFromInteractor");
static_assert(sizeof(LockerAccessInteraction_FireSoundEventFromInteractor) == 0x000010, "Wrong size on LockerAccessInteraction_FireSoundEventFromInteractor");
static_assert(offsetof(LockerAccessInteraction_FireSoundEventFromInteractor, Instigator) == 0x000000, "Member 'LockerAccessInteraction_FireSoundEventFromInteractor::Instigator' has a wrong offset!");
static_assert(offsetof(LockerAccessInteraction_FireSoundEventFromInteractor, instigatingPlayer) == 0x000008, "Member 'LockerAccessInteraction_FireSoundEventFromInteractor::instigatingPlayer' has a wrong offset!");

// Function DBDGameplay.LockerAccessInteraction.SetOtherInteractorsUsable
// 0x0001 (0x0001 - 0x0000)
struct LockerAccessInteraction_SetOtherInteractorsUsable final
{
public:
	bool                                          IsEnabled;                                         // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LockerAccessInteraction_SetOtherInteractorsUsable) == 0x000001, "Wrong alignment on LockerAccessInteraction_SetOtherInteractorsUsable");
static_assert(sizeof(LockerAccessInteraction_SetOtherInteractorsUsable) == 0x000001, "Wrong size on LockerAccessInteraction_SetOtherInteractorsUsable");
static_assert(offsetof(LockerAccessInteraction_SetOtherInteractorsUsable, IsEnabled) == 0x000000, "Member 'LockerAccessInteraction_SetOtherInteractorsUsable::IsEnabled' has a wrong offset!");

// Function DBDGameplay.LockerAccessInteraction.GetInsideInteractor
// 0x0008 (0x0008 - 0x0000)
struct LockerAccessInteraction_GetInsideInteractor final
{
public:
	class UInteractor*                            ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LockerAccessInteraction_GetInsideInteractor) == 0x000008, "Wrong alignment on LockerAccessInteraction_GetInsideInteractor");
static_assert(sizeof(LockerAccessInteraction_GetInsideInteractor) == 0x000008, "Wrong size on LockerAccessInteraction_GetInsideInteractor");
static_assert(offsetof(LockerAccessInteraction_GetInsideInteractor, ReturnValue) == 0x000000, "Member 'LockerAccessInteraction_GetInsideInteractor::ReturnValue' has a wrong offset!");

// Function DBDGameplay.LockerAccessInteraction.GetPlayerInLocker
// 0x0008 (0x0008 - 0x0000)
struct LockerAccessInteraction_GetPlayerInLocker final
{
public:
	class ADBDPlayer*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LockerAccessInteraction_GetPlayerInLocker) == 0x000008, "Wrong alignment on LockerAccessInteraction_GetPlayerInLocker");
static_assert(sizeof(LockerAccessInteraction_GetPlayerInLocker) == 0x000008, "Wrong size on LockerAccessInteraction_GetPlayerInLocker");
static_assert(offsetof(LockerAccessInteraction_GetPlayerInLocker, ReturnValue) == 0x000000, "Member 'LockerAccessInteraction_GetPlayerInLocker::ReturnValue' has a wrong offset!");

// Function DBDGameplay.LockerAccessInteraction.IsInteractingPlayerInsideLocker
// 0x0010 (0x0010 - 0x0000)
struct LockerAccessInteraction_IsInteractingPlayerInsideLocker final
{
public:
	const class ADBDPlayer*                       Player;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LockerAccessInteraction_IsInteractingPlayerInsideLocker) == 0x000008, "Wrong alignment on LockerAccessInteraction_IsInteractingPlayerInsideLocker");
static_assert(sizeof(LockerAccessInteraction_IsInteractingPlayerInsideLocker) == 0x000010, "Wrong size on LockerAccessInteraction_IsInteractingPlayerInsideLocker");
static_assert(offsetof(LockerAccessInteraction_IsInteractingPlayerInsideLocker, Player) == 0x000000, "Member 'LockerAccessInteraction_IsInteractingPlayerInsideLocker::Player' has a wrong offset!");
static_assert(offsetof(LockerAccessInteraction_IsInteractingPlayerInsideLocker, ReturnValue) == 0x000008, "Member 'LockerAccessInteraction_IsInteractingPlayerInsideLocker::ReturnValue' has a wrong offset!");

// Function DBDGameplay.LockerAccessInteraction.IsOccupied
// 0x0001 (0x0001 - 0x0000)
struct LockerAccessInteraction_IsOccupied final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LockerAccessInteraction_IsOccupied) == 0x000001, "Wrong alignment on LockerAccessInteraction_IsOccupied");
static_assert(sizeof(LockerAccessInteraction_IsOccupied) == 0x000001, "Wrong size on LockerAccessInteraction_IsOccupied");
static_assert(offsetof(LockerAccessInteraction_IsOccupied, ReturnValue) == 0x000000, "Member 'LockerAccessInteraction_IsOccupied::ReturnValue' has a wrong offset!");

// Function DBDGameplay.LockerAccessInteraction.IsRushed
// 0x0001 (0x0001 - 0x0000)
struct LockerAccessInteraction_IsRushed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LockerAccessInteraction_IsRushed) == 0x000001, "Wrong alignment on LockerAccessInteraction_IsRushed");
static_assert(sizeof(LockerAccessInteraction_IsRushed) == 0x000001, "Wrong size on LockerAccessInteraction_IsRushed");
static_assert(offsetof(LockerAccessInteraction_IsRushed, ReturnValue) == 0x000000, "Member 'LockerAccessInteraction_IsRushed::ReturnValue' has a wrong offset!");

// Function DBDGameplay.LockerAccessInteraction.SetCollisionWithLocker
// 0x0010 (0x0010 - 0x0000)
struct LockerAccessInteraction_SetCollisionWithLocker final
{
public:
	bool                                          IsEnabled;                                         // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             Player;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LockerAccessInteraction_SetCollisionWithLocker) == 0x000008, "Wrong alignment on LockerAccessInteraction_SetCollisionWithLocker");
static_assert(sizeof(LockerAccessInteraction_SetCollisionWithLocker) == 0x000010, "Wrong size on LockerAccessInteraction_SetCollisionWithLocker");
static_assert(offsetof(LockerAccessInteraction_SetCollisionWithLocker, IsEnabled) == 0x000000, "Member 'LockerAccessInteraction_SetCollisionWithLocker::IsEnabled' has a wrong offset!");
static_assert(offsetof(LockerAccessInteraction_SetCollisionWithLocker, Player) == 0x000008, "Member 'LockerAccessInteraction_SetCollisionWithLocker::Player' has a wrong offset!");

// Function DBDGameplay.LockerEnterInteraction.EjectSurvivorFromLocker
// 0x0010 (0x0010 - 0x0000)
struct LockerEnterInteraction_EjectSurvivorFromLocker final
{
public:
	class ASurvivor*                              Survivor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALocker*                                Locker;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LockerEnterInteraction_EjectSurvivorFromLocker) == 0x000008, "Wrong alignment on LockerEnterInteraction_EjectSurvivorFromLocker");
static_assert(sizeof(LockerEnterInteraction_EjectSurvivorFromLocker) == 0x000010, "Wrong size on LockerEnterInteraction_EjectSurvivorFromLocker");
static_assert(offsetof(LockerEnterInteraction_EjectSurvivorFromLocker, Survivor) == 0x000000, "Member 'LockerEnterInteraction_EjectSurvivorFromLocker::Survivor' has a wrong offset!");
static_assert(offsetof(LockerEnterInteraction_EjectSurvivorFromLocker, Locker) == 0x000008, "Member 'LockerEnterInteraction_EjectSurvivorFromLocker::Locker' has a wrong offset!");

// Function DBDGameplay.LockerJumpScareManagerComponent.Authority_OnLockerInteractorChanged
// 0x0001 (0x0001 - 0x0000)
struct LockerJumpScareManagerComponent_Authority_OnLockerInteractorChanged final
{
public:
	bool                                          IsLocked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LockerJumpScareManagerComponent_Authority_OnLockerInteractorChanged) == 0x000001, "Wrong alignment on LockerJumpScareManagerComponent_Authority_OnLockerInteractorChanged");
static_assert(sizeof(LockerJumpScareManagerComponent_Authority_OnLockerInteractorChanged) == 0x000001, "Wrong size on LockerJumpScareManagerComponent_Authority_OnLockerInteractorChanged");
static_assert(offsetof(LockerJumpScareManagerComponent_Authority_OnLockerInteractorChanged, IsLocked) == 0x000000, "Member 'LockerJumpScareManagerComponent_Authority_OnLockerInteractorChanged::IsLocked' has a wrong offset!");

// Function DBDGameplay.LockerJumpScareManagerComponent.DBD_ShowLockerJumpScare
// 0x0001 (0x0001 - 0x0000)
struct LockerJumpScareManagerComponent_DBD_ShowLockerJumpScare final
{
public:
	bool                                          Enable;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LockerJumpScareManagerComponent_DBD_ShowLockerJumpScare) == 0x000001, "Wrong alignment on LockerJumpScareManagerComponent_DBD_ShowLockerJumpScare");
static_assert(sizeof(LockerJumpScareManagerComponent_DBD_ShowLockerJumpScare) == 0x000001, "Wrong size on LockerJumpScareManagerComponent_DBD_ShowLockerJumpScare");
static_assert(offsetof(LockerJumpScareManagerComponent_DBD_ShowLockerJumpScare, Enable) == 0x000000, "Member 'LockerJumpScareManagerComponent_DBD_ShowLockerJumpScare::Enable' has a wrong offset!");

// Function DBDGameplay.LockerJumpScareManagerComponent.OnRep_JumpScareLocker
// 0x0008 (0x0008 - 0x0000)
struct LockerJumpScareManagerComponent_OnRep_JumpScareLocker final
{
public:
	class ALocker*                                lastLocker;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LockerJumpScareManagerComponent_OnRep_JumpScareLocker) == 0x000008, "Wrong alignment on LockerJumpScareManagerComponent_OnRep_JumpScareLocker");
static_assert(sizeof(LockerJumpScareManagerComponent_OnRep_JumpScareLocker) == 0x000008, "Wrong size on LockerJumpScareManagerComponent_OnRep_JumpScareLocker");
static_assert(offsetof(LockerJumpScareManagerComponent_OnRep_JumpScareLocker, lastLocker) == 0x000000, "Member 'LockerJumpScareManagerComponent_OnRep_JumpScareLocker::lastLocker' has a wrong offset!");

// Function DBDGameplay.LookAtScriptedEventMapTriggerComponent.Authority_OnPlayerEnterTriggerVolume
// 0x0110 (0x0110 - 0x0000)
struct LookAtScriptedEventMapTriggerComponent_Authority_OnPlayerEnterTriggerVolume final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F0)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LookAtScriptedEventMapTriggerComponent_Authority_OnPlayerEnterTriggerVolume) == 0x000008, "Wrong alignment on LookAtScriptedEventMapTriggerComponent_Authority_OnPlayerEnterTriggerVolume");
static_assert(sizeof(LookAtScriptedEventMapTriggerComponent_Authority_OnPlayerEnterTriggerVolume) == 0x000110, "Wrong size on LookAtScriptedEventMapTriggerComponent_Authority_OnPlayerEnterTriggerVolume");
static_assert(offsetof(LookAtScriptedEventMapTriggerComponent_Authority_OnPlayerEnterTriggerVolume, OverlappedComponent) == 0x000000, "Member 'LookAtScriptedEventMapTriggerComponent_Authority_OnPlayerEnterTriggerVolume::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(LookAtScriptedEventMapTriggerComponent_Authority_OnPlayerEnterTriggerVolume, OtherActor) == 0x000008, "Member 'LookAtScriptedEventMapTriggerComponent_Authority_OnPlayerEnterTriggerVolume::OtherActor' has a wrong offset!");
static_assert(offsetof(LookAtScriptedEventMapTriggerComponent_Authority_OnPlayerEnterTriggerVolume, OtherComp) == 0x000010, "Member 'LookAtScriptedEventMapTriggerComponent_Authority_OnPlayerEnterTriggerVolume::OtherComp' has a wrong offset!");
static_assert(offsetof(LookAtScriptedEventMapTriggerComponent_Authority_OnPlayerEnterTriggerVolume, OtherBodyIndex) == 0x000018, "Member 'LookAtScriptedEventMapTriggerComponent_Authority_OnPlayerEnterTriggerVolume::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(LookAtScriptedEventMapTriggerComponent_Authority_OnPlayerEnterTriggerVolume, bFromSweep) == 0x00001C, "Member 'LookAtScriptedEventMapTriggerComponent_Authority_OnPlayerEnterTriggerVolume::bFromSweep' has a wrong offset!");
static_assert(offsetof(LookAtScriptedEventMapTriggerComponent_Authority_OnPlayerEnterTriggerVolume, SweepResult) == 0x000020, "Member 'LookAtScriptedEventMapTriggerComponent_Authority_OnPlayerEnterTriggerVolume::SweepResult' has a wrong offset!");

// Function DBDGameplay.LookAtScriptedEventMapTriggerComponent.Authority_OnPlayerExitTriggerVolume
// 0x0020 (0x0020 - 0x0000)
struct LookAtScriptedEventMapTriggerComponent_Authority_OnPlayerExitTriggerVolume final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LookAtScriptedEventMapTriggerComponent_Authority_OnPlayerExitTriggerVolume) == 0x000008, "Wrong alignment on LookAtScriptedEventMapTriggerComponent_Authority_OnPlayerExitTriggerVolume");
static_assert(sizeof(LookAtScriptedEventMapTriggerComponent_Authority_OnPlayerExitTriggerVolume) == 0x000020, "Wrong size on LookAtScriptedEventMapTriggerComponent_Authority_OnPlayerExitTriggerVolume");
static_assert(offsetof(LookAtScriptedEventMapTriggerComponent_Authority_OnPlayerExitTriggerVolume, OverlappedComponent) == 0x000000, "Member 'LookAtScriptedEventMapTriggerComponent_Authority_OnPlayerExitTriggerVolume::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(LookAtScriptedEventMapTriggerComponent_Authority_OnPlayerExitTriggerVolume, OtherActor) == 0x000008, "Member 'LookAtScriptedEventMapTriggerComponent_Authority_OnPlayerExitTriggerVolume::OtherActor' has a wrong offset!");
static_assert(offsetof(LookAtScriptedEventMapTriggerComponent_Authority_OnPlayerExitTriggerVolume, OtherComp) == 0x000010, "Member 'LookAtScriptedEventMapTriggerComponent_Authority_OnPlayerExitTriggerVolume::OtherComp' has a wrong offset!");
static_assert(offsetof(LookAtScriptedEventMapTriggerComponent_Authority_OnPlayerExitTriggerVolume, OtherBodyIndex) == 0x000018, "Member 'LookAtScriptedEventMapTriggerComponent_Authority_OnPlayerExitTriggerVolume::OtherBodyIndex' has a wrong offset!");

// Function DBDGameplay.MapCollectable.GetActorKnowledgeCollection
// 0x0008 (0x0008 - 0x0000)
struct MapCollectable_GetActorKnowledgeCollection final
{
public:
	class UActorKnowledgeCollection*              ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapCollectable_GetActorKnowledgeCollection) == 0x000008, "Wrong alignment on MapCollectable_GetActorKnowledgeCollection");
static_assert(sizeof(MapCollectable_GetActorKnowledgeCollection) == 0x000008, "Wrong size on MapCollectable_GetActorKnowledgeCollection");
static_assert(offsetof(MapCollectable_GetActorKnowledgeCollection, ReturnValue) == 0x000000, "Member 'MapCollectable_GetActorKnowledgeCollection::ReturnValue' has a wrong offset!");

// Function DBDGameplay.MapCollectable.GetChargeableComponent
// 0x0008 (0x0008 - 0x0000)
struct MapCollectable_GetChargeableComponent final
{
public:
	class UChargeableComponent*                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapCollectable_GetChargeableComponent) == 0x000008, "Wrong alignment on MapCollectable_GetChargeableComponent");
static_assert(sizeof(MapCollectable_GetChargeableComponent) == 0x000008, "Wrong size on MapCollectable_GetChargeableComponent");
static_assert(offsetof(MapCollectable_GetChargeableComponent, ReturnValue) == 0x000000, "Member 'MapCollectable_GetChargeableComponent::ReturnValue' has a wrong offset!");

// Function DBDGameplay.MapCollectable.GetChargerComponent
// 0x0008 (0x0008 - 0x0000)
struct MapCollectable_GetChargerComponent final
{
public:
	class UChargerComponent*                      ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapCollectable_GetChargerComponent) == 0x000008, "Wrong alignment on MapCollectable_GetChargerComponent");
static_assert(sizeof(MapCollectable_GetChargerComponent) == 0x000008, "Wrong size on MapCollectable_GetChargerComponent");
static_assert(offsetof(MapCollectable_GetChargerComponent, ReturnValue) == 0x000000, "Member 'MapCollectable_GetChargerComponent::ReturnValue' has a wrong offset!");

// Function DBDGameplay.Medkit.Authority_OnAnyOngoingInteractionChanged
// 0x0001 (0x0001 - 0x0000)
struct Medkit_Authority_OnAnyOngoingInteractionChanged final
{
public:
	bool                                          IsInteracting;                                     // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Medkit_Authority_OnAnyOngoingInteractionChanged) == 0x000001, "Wrong alignment on Medkit_Authority_OnAnyOngoingInteractionChanged");
static_assert(sizeof(Medkit_Authority_OnAnyOngoingInteractionChanged) == 0x000001, "Wrong size on Medkit_Authority_OnAnyOngoingInteractionChanged");
static_assert(offsetof(Medkit_Authority_OnAnyOngoingInteractionChanged, IsInteracting) == 0x000000, "Member 'Medkit_Authority_OnAnyOngoingInteractionChanged::IsInteracting' has a wrong offset!");

// Function DBDGameplay.Medkit.Authority_OnChargeStateChange
// 0x0001 (0x0001 - 0x0000)
struct Medkit_Authority_OnChargeStateChange final
{
public:
	bool                                          Empty;                                             // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Medkit_Authority_OnChargeStateChange) == 0x000001, "Wrong alignment on Medkit_Authority_OnChargeStateChange");
static_assert(sizeof(Medkit_Authority_OnChargeStateChange) == 0x000001, "Wrong size on Medkit_Authority_OnChargeStateChange");
static_assert(offsetof(Medkit_Authority_OnChargeStateChange, Empty) == 0x000000, "Member 'Medkit_Authority_OnChargeStateChange::Empty' has a wrong offset!");

// Function DBDGameplay.Medkit.OnMedkitHealedCamper
// 0x0008 (0x0008 - 0x0000)
struct Medkit_OnMedkitHealedCamper final
{
public:
	class ADBDPlayer*                             healedPlayer;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Medkit_OnMedkitHealedCamper) == 0x000008, "Wrong alignment on Medkit_OnMedkitHealedCamper");
static_assert(sizeof(Medkit_OnMedkitHealedCamper) == 0x000008, "Wrong size on Medkit_OnMedkitHealedCamper");
static_assert(offsetof(Medkit_OnMedkitHealedCamper, healedPlayer) == 0x000000, "Member 'Medkit_OnMedkitHealedCamper::healedPlayer' has a wrong offset!");

// Function DBDGameplay.Medkit.UseCharge
// 0x0004 (0x0004 - 0x0000)
struct Medkit_UseCharge final
{
public:
	float                                         Seconds;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Medkit_UseCharge) == 0x000004, "Wrong alignment on Medkit_UseCharge");
static_assert(sizeof(Medkit_UseCharge) == 0x000004, "Wrong size on Medkit_UseCharge");
static_assert(offsetof(Medkit_UseCharge, Seconds) == 0x000000, "Member 'Medkit_UseCharge::Seconds' has a wrong offset!");

// Function DBDGameplay.Medkit.GetCharge
// 0x0004 (0x0004 - 0x0000)
struct Medkit_GetCharge final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Medkit_GetCharge) == 0x000004, "Wrong alignment on Medkit_GetCharge");
static_assert(sizeof(Medkit_GetCharge) == 0x000004, "Wrong size on Medkit_GetCharge");
static_assert(offsetof(Medkit_GetCharge, ReturnValue) == 0x000000, "Member 'Medkit_GetCharge::ReturnValue' has a wrong offset!");

// Function DBDGameplay.Medkit.GetChargeMultiplier
// 0x0004 (0x0004 - 0x0000)
struct Medkit_GetChargeMultiplier final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Medkit_GetChargeMultiplier) == 0x000004, "Wrong alignment on Medkit_GetChargeMultiplier");
static_assert(sizeof(Medkit_GetChargeMultiplier) == 0x000004, "Wrong size on Medkit_GetChargeMultiplier");
static_assert(offsetof(Medkit_GetChargeMultiplier, ReturnValue) == 0x000000, "Member 'Medkit_GetChargeMultiplier::ReturnValue' has a wrong offset!");

// Function DBDGameplay.Medkit.HasCharge
// 0x0001 (0x0001 - 0x0000)
struct Medkit_HasCharge final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Medkit_HasCharge) == 0x000001, "Wrong alignment on Medkit_HasCharge");
static_assert(sizeof(Medkit_HasCharge) == 0x000001, "Wrong size on Medkit_HasCharge");
static_assert(offsetof(Medkit_HasCharge, ReturnValue) == 0x000000, "Member 'Medkit_HasCharge::ReturnValue' has a wrong offset!");

// Function DBDGameplay.NearestOutsideMapBoundsLocator.OnGameEnd
// 0x0001 (0x0001 - 0x0000)
struct NearestOutsideMapBoundsLocator_OnGameEnd final
{
public:
	EEndGameReason                                endGameReason;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NearestOutsideMapBoundsLocator_OnGameEnd) == 0x000001, "Wrong alignment on NearestOutsideMapBoundsLocator_OnGameEnd");
static_assert(sizeof(NearestOutsideMapBoundsLocator_OnGameEnd) == 0x000001, "Wrong size on NearestOutsideMapBoundsLocator_OnGameEnd");
static_assert(offsetof(NearestOutsideMapBoundsLocator_OnGameEnd, endGameReason) == 0x000000, "Member 'NearestOutsideMapBoundsLocator_OnGameEnd::endGameReason' has a wrong offset!");

// Function DBDGameplay.Passage.Cosmetic_OnPlayerInRangeChanged
// 0x0010 (0x0010 - 0x0000)
struct Passage_Cosmetic_OnPlayerInRangeChanged final
{
public:
	bool                                          inRange;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class ADBDPlayer*                       Player;                                            // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Passage_Cosmetic_OnPlayerInRangeChanged) == 0x000008, "Wrong alignment on Passage_Cosmetic_OnPlayerInRangeChanged");
static_assert(sizeof(Passage_Cosmetic_OnPlayerInRangeChanged) == 0x000010, "Wrong size on Passage_Cosmetic_OnPlayerInRangeChanged");
static_assert(offsetof(Passage_Cosmetic_OnPlayerInRangeChanged, inRange) == 0x000000, "Member 'Passage_Cosmetic_OnPlayerInRangeChanged::inRange' has a wrong offset!");
static_assert(offsetof(Passage_Cosmetic_OnPlayerInRangeChanged, Player) == 0x000008, "Member 'Passage_Cosmetic_OnPlayerInRangeChanged::Player' has a wrong offset!");

// Function DBDGameplay.Passage.Local_OnPlayerLeftGame
// 0x0040 (0x0040 - 0x0000)
struct Passage_Local_OnPlayerLeftGame final
{
public:
	struct FGameplayTag                           GameplayTag;                                       // 0x0000(0x000C)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameEventData                         GameEventData;                                     // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Passage_Local_OnPlayerLeftGame) == 0x000008, "Wrong alignment on Passage_Local_OnPlayerLeftGame");
static_assert(sizeof(Passage_Local_OnPlayerLeftGame) == 0x000040, "Wrong size on Passage_Local_OnPlayerLeftGame");
static_assert(offsetof(Passage_Local_OnPlayerLeftGame, GameplayTag) == 0x000000, "Member 'Passage_Local_OnPlayerLeftGame::GameplayTag' has a wrong offset!");
static_assert(offsetof(Passage_Local_OnPlayerLeftGame, GameEventData) == 0x000010, "Member 'Passage_Local_OnPlayerLeftGame::GameEventData' has a wrong offset!");

// Function DBDGameplay.Passage.Local_OnPlayerLocallyObservedChanged
// 0x0010 (0x0010 - 0x0000)
struct Passage_Local_OnPlayerLocallyObservedChanged final
{
public:
	bool                                          isObserved;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class ADBDPlayer*                       Player;                                            // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Passage_Local_OnPlayerLocallyObservedChanged) == 0x000008, "Wrong alignment on Passage_Local_OnPlayerLocallyObservedChanged");
static_assert(sizeof(Passage_Local_OnPlayerLocallyObservedChanged) == 0x000010, "Wrong size on Passage_Local_OnPlayerLocallyObservedChanged");
static_assert(offsetof(Passage_Local_OnPlayerLocallyObservedChanged, isObserved) == 0x000000, "Member 'Passage_Local_OnPlayerLocallyObservedChanged::isObserved' has a wrong offset!");
static_assert(offsetof(Passage_Local_OnPlayerLocallyObservedChanged, Player) == 0x000008, "Member 'Passage_Local_OnPlayerLocallyObservedChanged::Player' has a wrong offset!");

// Function DBDGameplay.Passage.OnBeginOverlapRevealExitAuraZone
// 0x0110 (0x0110 - 0x0000)
struct Passage_OnBeginOverlapRevealExitAuraZone final
{
public:
	class UPrimitiveComponent*                    HitComponent;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F0)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(Passage_OnBeginOverlapRevealExitAuraZone) == 0x000008, "Wrong alignment on Passage_OnBeginOverlapRevealExitAuraZone");
static_assert(sizeof(Passage_OnBeginOverlapRevealExitAuraZone) == 0x000110, "Wrong size on Passage_OnBeginOverlapRevealExitAuraZone");
static_assert(offsetof(Passage_OnBeginOverlapRevealExitAuraZone, HitComponent) == 0x000000, "Member 'Passage_OnBeginOverlapRevealExitAuraZone::HitComponent' has a wrong offset!");
static_assert(offsetof(Passage_OnBeginOverlapRevealExitAuraZone, OtherActor) == 0x000008, "Member 'Passage_OnBeginOverlapRevealExitAuraZone::OtherActor' has a wrong offset!");
static_assert(offsetof(Passage_OnBeginOverlapRevealExitAuraZone, OtherComp) == 0x000010, "Member 'Passage_OnBeginOverlapRevealExitAuraZone::OtherComp' has a wrong offset!");
static_assert(offsetof(Passage_OnBeginOverlapRevealExitAuraZone, OtherBodyIndex) == 0x000018, "Member 'Passage_OnBeginOverlapRevealExitAuraZone::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(Passage_OnBeginOverlapRevealExitAuraZone, bFromSweep) == 0x00001C, "Member 'Passage_OnBeginOverlapRevealExitAuraZone::bFromSweep' has a wrong offset!");
static_assert(offsetof(Passage_OnBeginOverlapRevealExitAuraZone, SweepResult) == 0x000020, "Member 'Passage_OnBeginOverlapRevealExitAuraZone::SweepResult' has a wrong offset!");

// Function DBDGameplay.Passage.OnEndOverlapRevealExitAuraZone
// 0x0020 (0x0020 - 0x0000)
struct Passage_OnEndOverlapRevealExitAuraZone final
{
public:
	class UPrimitiveComponent*                    HitComponent;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Passage_OnEndOverlapRevealExitAuraZone) == 0x000008, "Wrong alignment on Passage_OnEndOverlapRevealExitAuraZone");
static_assert(sizeof(Passage_OnEndOverlapRevealExitAuraZone) == 0x000020, "Wrong size on Passage_OnEndOverlapRevealExitAuraZone");
static_assert(offsetof(Passage_OnEndOverlapRevealExitAuraZone, HitComponent) == 0x000000, "Member 'Passage_OnEndOverlapRevealExitAuraZone::HitComponent' has a wrong offset!");
static_assert(offsetof(Passage_OnEndOverlapRevealExitAuraZone, OtherActor) == 0x000008, "Member 'Passage_OnEndOverlapRevealExitAuraZone::OtherActor' has a wrong offset!");
static_assert(offsetof(Passage_OnEndOverlapRevealExitAuraZone, OtherComp) == 0x000010, "Member 'Passage_OnEndOverlapRevealExitAuraZone::OtherComp' has a wrong offset!");
static_assert(offsetof(Passage_OnEndOverlapRevealExitAuraZone, OtherBodyIndex) == 0x000018, "Member 'Passage_OnEndOverlapRevealExitAuraZone::OtherBodyIndex' has a wrong offset!");

// Function DBDGameplay.Passage.GetConnectedPassage
// 0x0008 (0x0008 - 0x0000)
struct Passage_GetConnectedPassage final
{
public:
	class APassage*                               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Passage_GetConnectedPassage) == 0x000008, "Wrong alignment on Passage_GetConnectedPassage");
static_assert(sizeof(Passage_GetConnectedPassage) == 0x000008, "Wrong size on Passage_GetConnectedPassage");
static_assert(offsetof(Passage_GetConnectedPassage, ReturnValue) == 0x000000, "Member 'Passage_GetConnectedPassage::ReturnValue' has a wrong offset!");

// Function DBDGameplay.Passage.GetPassageCosmeticState
// 0x0001 (0x0001 - 0x0000)
struct Passage_GetPassageCosmeticState final
{
public:
	EPassageCosmeticState                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Passage_GetPassageCosmeticState) == 0x000001, "Wrong alignment on Passage_GetPassageCosmeticState");
static_assert(sizeof(Passage_GetPassageCosmeticState) == 0x000001, "Wrong size on Passage_GetPassageCosmeticState");
static_assert(offsetof(Passage_GetPassageCosmeticState, ReturnValue) == 0x000000, "Member 'Passage_GetPassageCosmeticState::ReturnValue' has a wrong offset!");

// Function DBDGameplay.PassageEnterInteraction.GetOwningPassage
// 0x0008 (0x0008 - 0x0000)
struct PassageEnterInteraction_GetOwningPassage final
{
public:
	class APassage*                               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PassageEnterInteraction_GetOwningPassage) == 0x000008, "Wrong alignment on PassageEnterInteraction_GetOwningPassage");
static_assert(sizeof(PassageEnterInteraction_GetOwningPassage) == 0x000008, "Wrong size on PassageEnterInteraction_GetOwningPassage");
static_assert(offsetof(PassageEnterInteraction_GetOwningPassage, ReturnValue) == 0x000000, "Member 'PassageEnterInteraction_GetOwningPassage::ReturnValue' has a wrong offset!");

// Function DBDGameplay.PlayerInteractionListenerComponent.ListenToInteractionEnd
// 0x0028 (0x0028 - 0x0000)
struct PlayerInteractionListenerComponent_ListenToInteractionEnd final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           interactionSemantic;                               // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(class ADBDPlayer* Player, const struct FGameplayTag& interactionSemantic)> interactionDelegate; // 0x0014(0x0014)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerInteractionListenerComponent_ListenToInteractionEnd) == 0x000008, "Wrong alignment on PlayerInteractionListenerComponent_ListenToInteractionEnd");
static_assert(sizeof(PlayerInteractionListenerComponent_ListenToInteractionEnd) == 0x000028, "Wrong size on PlayerInteractionListenerComponent_ListenToInteractionEnd");
static_assert(offsetof(PlayerInteractionListenerComponent_ListenToInteractionEnd, Player) == 0x000000, "Member 'PlayerInteractionListenerComponent_ListenToInteractionEnd::Player' has a wrong offset!");
static_assert(offsetof(PlayerInteractionListenerComponent_ListenToInteractionEnd, interactionSemantic) == 0x000008, "Member 'PlayerInteractionListenerComponent_ListenToInteractionEnd::interactionSemantic' has a wrong offset!");
static_assert(offsetof(PlayerInteractionListenerComponent_ListenToInteractionEnd, interactionDelegate) == 0x000014, "Member 'PlayerInteractionListenerComponent_ListenToInteractionEnd::interactionDelegate' has a wrong offset!");

// Function DBDGameplay.PlayerInteractionListenerComponent.ListenToInteractionStart
// 0x0028 (0x0028 - 0x0000)
struct PlayerInteractionListenerComponent_ListenToInteractionStart final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           interactionSemantic;                               // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(class ADBDPlayer* Player, const struct FGameplayTag& interactionSemantic)> interactionDelegate; // 0x0014(0x0014)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerInteractionListenerComponent_ListenToInteractionStart) == 0x000008, "Wrong alignment on PlayerInteractionListenerComponent_ListenToInteractionStart");
static_assert(sizeof(PlayerInteractionListenerComponent_ListenToInteractionStart) == 0x000028, "Wrong size on PlayerInteractionListenerComponent_ListenToInteractionStart");
static_assert(offsetof(PlayerInteractionListenerComponent_ListenToInteractionStart, Player) == 0x000000, "Member 'PlayerInteractionListenerComponent_ListenToInteractionStart::Player' has a wrong offset!");
static_assert(offsetof(PlayerInteractionListenerComponent_ListenToInteractionStart, interactionSemantic) == 0x000008, "Member 'PlayerInteractionListenerComponent_ListenToInteractionStart::interactionSemantic' has a wrong offset!");
static_assert(offsetof(PlayerInteractionListenerComponent_ListenToInteractionStart, interactionDelegate) == 0x000014, "Member 'PlayerInteractionListenerComponent_ListenToInteractionStart::interactionDelegate' has a wrong offset!");

// Function DBDGameplay.PlayerInteractionListenerComponent.OnActorDestroyed
// 0x0008 (0x0008 - 0x0000)
struct PlayerInteractionListenerComponent_OnActorDestroyed final
{
public:
	class AActor*                                 DestroyedActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerInteractionListenerComponent_OnActorDestroyed) == 0x000008, "Wrong alignment on PlayerInteractionListenerComponent_OnActorDestroyed");
static_assert(sizeof(PlayerInteractionListenerComponent_OnActorDestroyed) == 0x000008, "Wrong size on PlayerInteractionListenerComponent_OnActorDestroyed");
static_assert(offsetof(PlayerInteractionListenerComponent_OnActorDestroyed, DestroyedActor) == 0x000000, "Member 'PlayerInteractionListenerComponent_OnActorDestroyed::DestroyedActor' has a wrong offset!");

// Function DBDGameplay.PlayerInteractionListenerComponent.UnlistenToInteractionEnd
// 0x0018 (0x0018 - 0x0000)
struct PlayerInteractionListenerComponent_UnlistenToInteractionEnd final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           interactionSemantic;                               // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerInteractionListenerComponent_UnlistenToInteractionEnd) == 0x000008, "Wrong alignment on PlayerInteractionListenerComponent_UnlistenToInteractionEnd");
static_assert(sizeof(PlayerInteractionListenerComponent_UnlistenToInteractionEnd) == 0x000018, "Wrong size on PlayerInteractionListenerComponent_UnlistenToInteractionEnd");
static_assert(offsetof(PlayerInteractionListenerComponent_UnlistenToInteractionEnd, Player) == 0x000000, "Member 'PlayerInteractionListenerComponent_UnlistenToInteractionEnd::Player' has a wrong offset!");
static_assert(offsetof(PlayerInteractionListenerComponent_UnlistenToInteractionEnd, interactionSemantic) == 0x000008, "Member 'PlayerInteractionListenerComponent_UnlistenToInteractionEnd::interactionSemantic' has a wrong offset!");

// Function DBDGameplay.PlayerInteractionListenerComponent.UnlistenToInteractionStart
// 0x0018 (0x0018 - 0x0000)
struct PlayerInteractionListenerComponent_UnlistenToInteractionStart final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           interactionSemantic;                               // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerInteractionListenerComponent_UnlistenToInteractionStart) == 0x000008, "Wrong alignment on PlayerInteractionListenerComponent_UnlistenToInteractionStart");
static_assert(sizeof(PlayerInteractionListenerComponent_UnlistenToInteractionStart) == 0x000018, "Wrong size on PlayerInteractionListenerComponent_UnlistenToInteractionStart");
static_assert(offsetof(PlayerInteractionListenerComponent_UnlistenToInteractionStart, Player) == 0x000000, "Member 'PlayerInteractionListenerComponent_UnlistenToInteractionStart::Player' has a wrong offset!");
static_assert(offsetof(PlayerInteractionListenerComponent_UnlistenToInteractionStart, interactionSemantic) == 0x000008, "Member 'PlayerInteractionListenerComponent_UnlistenToInteractionStart::interactionSemantic' has a wrong offset!");

// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyGamepadPitchScaleMultiplier
// 0x0010 (0x0010 - 0x0000)
struct PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Multiplier;                                        // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         adjustmentTime;                                    // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier) == 0x000008, "Wrong alignment on PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier");
static_assert(sizeof(PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier) == 0x000010, "Wrong size on PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier, Player) == 0x000000, "Member 'PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier::Player' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier, Multiplier) == 0x000008, "Member 'PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier::Multiplier' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier, adjustmentTime) == 0x00000C, "Member 'PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier::adjustmentTime' has a wrong offset!");

// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyGamepadYawScaleMultiplier
// 0x0010 (0x0010 - 0x0000)
struct PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Multiplier;                                        // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         adjustmentTime;                                    // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier) == 0x000008, "Wrong alignment on PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier");
static_assert(sizeof(PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier) == 0x000010, "Wrong size on PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier, Player) == 0x000000, "Member 'PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier::Player' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier, Multiplier) == 0x000008, "Member 'PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier::Multiplier' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier, adjustmentTime) == 0x00000C, "Member 'PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier::adjustmentTime' has a wrong offset!");

// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyMousePitchScaleMultiplier
// 0x0010 (0x0010 - 0x0000)
struct PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Multiplier;                                        // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         adjustmentTime;                                    // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier) == 0x000008, "Wrong alignment on PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier");
static_assert(sizeof(PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier) == 0x000010, "Wrong size on PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier, Player) == 0x000000, "Member 'PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier::Player' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier, Multiplier) == 0x000008, "Member 'PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier::Multiplier' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier, adjustmentTime) == 0x00000C, "Member 'PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier::adjustmentTime' has a wrong offset!");

// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyMouseYawScaleMultiplier
// 0x0010 (0x0010 - 0x0000)
struct PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Multiplier;                                        // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         adjustmentTime;                                    // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier) == 0x000008, "Wrong alignment on PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier");
static_assert(sizeof(PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier) == 0x000010, "Wrong size on PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier, Player) == 0x000000, "Member 'PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier::Player' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier, Multiplier) == 0x000008, "Member 'PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier::Multiplier' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier, adjustmentTime) == 0x00000C, "Member 'PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier::adjustmentTime' has a wrong offset!");

// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyPitchScaleMultiplier
// 0x0010 (0x0010 - 0x0000)
struct PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Multiplier;                                        // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         adjustmentTime;                                    // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier) == 0x000008, "Wrong alignment on PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier");
static_assert(sizeof(PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier) == 0x000010, "Wrong size on PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier, Player) == 0x000000, "Member 'PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier::Player' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier, Multiplier) == 0x000008, "Member 'PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier::Multiplier' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier, adjustmentTime) == 0x00000C, "Member 'PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier::adjustmentTime' has a wrong offset!");

// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyRotationScaleMultiplier
// 0x0010 (0x0010 - 0x0000)
struct PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Multiplier;                                        // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         adjustmentTime;                                    // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier) == 0x000008, "Wrong alignment on PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier");
static_assert(sizeof(PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier) == 0x000010, "Wrong size on PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier, Player) == 0x000000, "Member 'PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier::Player' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier, Multiplier) == 0x000008, "Member 'PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier::Multiplier' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier, adjustmentTime) == 0x00000C, "Member 'PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier::adjustmentTime' has a wrong offset!");

// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyYawScaleMultiplier
// 0x0010 (0x0010 - 0x0000)
struct PlayerMovementUtilities_Local_ApplyYawScaleMultiplier final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Multiplier;                                        // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         adjustmentTime;                                    // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerMovementUtilities_Local_ApplyYawScaleMultiplier) == 0x000008, "Wrong alignment on PlayerMovementUtilities_Local_ApplyYawScaleMultiplier");
static_assert(sizeof(PlayerMovementUtilities_Local_ApplyYawScaleMultiplier) == 0x000010, "Wrong size on PlayerMovementUtilities_Local_ApplyYawScaleMultiplier");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyYawScaleMultiplier, Player) == 0x000000, "Member 'PlayerMovementUtilities_Local_ApplyYawScaleMultiplier::Player' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyYawScaleMultiplier, Multiplier) == 0x000008, "Member 'PlayerMovementUtilities_Local_ApplyYawScaleMultiplier::Multiplier' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyYawScaleMultiplier, adjustmentTime) == 0x00000C, "Member 'PlayerMovementUtilities_Local_ApplyYawScaleMultiplier::adjustmentTime' has a wrong offset!");

// Function DBDGameplay.PlayerMovementUtilities.Local_ResetGamepadLookCurves
// 0x0008 (0x0008 - 0x0000)
struct PlayerMovementUtilities_Local_ResetGamepadLookCurves final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerMovementUtilities_Local_ResetGamepadLookCurves) == 0x000008, "Wrong alignment on PlayerMovementUtilities_Local_ResetGamepadLookCurves");
static_assert(sizeof(PlayerMovementUtilities_Local_ResetGamepadLookCurves) == 0x000008, "Wrong size on PlayerMovementUtilities_Local_ResetGamepadLookCurves");
static_assert(offsetof(PlayerMovementUtilities_Local_ResetGamepadLookCurves, Player) == 0x000000, "Member 'PlayerMovementUtilities_Local_ResetGamepadLookCurves::Player' has a wrong offset!");

// Function DBDGameplay.PlayerMovementUtilities.Local_ResetRotationScale
// 0x0010 (0x0010 - 0x0000)
struct PlayerMovementUtilities_Local_ResetRotationScale final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         adjustmentTime;                                    // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerMovementUtilities_Local_ResetRotationScale) == 0x000008, "Wrong alignment on PlayerMovementUtilities_Local_ResetRotationScale");
static_assert(sizeof(PlayerMovementUtilities_Local_ResetRotationScale) == 0x000010, "Wrong size on PlayerMovementUtilities_Local_ResetRotationScale");
static_assert(offsetof(PlayerMovementUtilities_Local_ResetRotationScale, Player) == 0x000000, "Member 'PlayerMovementUtilities_Local_ResetRotationScale::Player' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ResetRotationScale, adjustmentTime) == 0x000008, "Member 'PlayerMovementUtilities_Local_ResetRotationScale::adjustmentTime' has a wrong offset!");

// Function DBDGameplay.PlayerMovementUtilities.Local_SetGamepadPitchCurve
// 0x0010 (0x0010 - 0x0000)
struct PlayerMovementUtilities_Local_SetGamepadPitchCurve final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            Curve;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerMovementUtilities_Local_SetGamepadPitchCurve) == 0x000008, "Wrong alignment on PlayerMovementUtilities_Local_SetGamepadPitchCurve");
static_assert(sizeof(PlayerMovementUtilities_Local_SetGamepadPitchCurve) == 0x000010, "Wrong size on PlayerMovementUtilities_Local_SetGamepadPitchCurve");
static_assert(offsetof(PlayerMovementUtilities_Local_SetGamepadPitchCurve, Player) == 0x000000, "Member 'PlayerMovementUtilities_Local_SetGamepadPitchCurve::Player' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_SetGamepadPitchCurve, Curve) == 0x000008, "Member 'PlayerMovementUtilities_Local_SetGamepadPitchCurve::Curve' has a wrong offset!");

// Function DBDGameplay.PlayerMovementUtilities.Local_SetGamepadYawCurve
// 0x0010 (0x0010 - 0x0000)
struct PlayerMovementUtilities_Local_SetGamepadYawCurve final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            Curve;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerMovementUtilities_Local_SetGamepadYawCurve) == 0x000008, "Wrong alignment on PlayerMovementUtilities_Local_SetGamepadYawCurve");
static_assert(sizeof(PlayerMovementUtilities_Local_SetGamepadYawCurve) == 0x000010, "Wrong size on PlayerMovementUtilities_Local_SetGamepadYawCurve");
static_assert(offsetof(PlayerMovementUtilities_Local_SetGamepadYawCurve, Player) == 0x000000, "Member 'PlayerMovementUtilities_Local_SetGamepadYawCurve::Player' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_SetGamepadYawCurve, Curve) == 0x000008, "Member 'PlayerMovementUtilities_Local_SetGamepadYawCurve::Curve' has a wrong offset!");

// Function DBDGameplay.PlayersInZoneTracker.Authority_OnBeginPlayerOverlap
// 0x0110 (0x0110 - 0x0000)
struct PlayersInZoneTracker_Authority_OnBeginPlayerOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F0)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayersInZoneTracker_Authority_OnBeginPlayerOverlap) == 0x000008, "Wrong alignment on PlayersInZoneTracker_Authority_OnBeginPlayerOverlap");
static_assert(sizeof(PlayersInZoneTracker_Authority_OnBeginPlayerOverlap) == 0x000110, "Wrong size on PlayersInZoneTracker_Authority_OnBeginPlayerOverlap");
static_assert(offsetof(PlayersInZoneTracker_Authority_OnBeginPlayerOverlap, OverlappedComponent) == 0x000000, "Member 'PlayersInZoneTracker_Authority_OnBeginPlayerOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(PlayersInZoneTracker_Authority_OnBeginPlayerOverlap, Other) == 0x000008, "Member 'PlayersInZoneTracker_Authority_OnBeginPlayerOverlap::Other' has a wrong offset!");
static_assert(offsetof(PlayersInZoneTracker_Authority_OnBeginPlayerOverlap, OtherComp) == 0x000010, "Member 'PlayersInZoneTracker_Authority_OnBeginPlayerOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(PlayersInZoneTracker_Authority_OnBeginPlayerOverlap, OtherBodyIndex) == 0x000018, "Member 'PlayersInZoneTracker_Authority_OnBeginPlayerOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(PlayersInZoneTracker_Authority_OnBeginPlayerOverlap, bFromSweep) == 0x00001C, "Member 'PlayersInZoneTracker_Authority_OnBeginPlayerOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(PlayersInZoneTracker_Authority_OnBeginPlayerOverlap, SweepResult) == 0x000020, "Member 'PlayersInZoneTracker_Authority_OnBeginPlayerOverlap::SweepResult' has a wrong offset!");

// Function DBDGameplay.PlayersInZoneTracker.Authority_OnEndPlayerOverlap
// 0x0020 (0x0020 - 0x0000)
struct PlayersInZoneTracker_Authority_OnEndPlayerOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayersInZoneTracker_Authority_OnEndPlayerOverlap) == 0x000008, "Wrong alignment on PlayersInZoneTracker_Authority_OnEndPlayerOverlap");
static_assert(sizeof(PlayersInZoneTracker_Authority_OnEndPlayerOverlap) == 0x000020, "Wrong size on PlayersInZoneTracker_Authority_OnEndPlayerOverlap");
static_assert(offsetof(PlayersInZoneTracker_Authority_OnEndPlayerOverlap, OverlappedComponent) == 0x000000, "Member 'PlayersInZoneTracker_Authority_OnEndPlayerOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(PlayersInZoneTracker_Authority_OnEndPlayerOverlap, OtherActor) == 0x000008, "Member 'PlayersInZoneTracker_Authority_OnEndPlayerOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(PlayersInZoneTracker_Authority_OnEndPlayerOverlap, OtherComp) == 0x000010, "Member 'PlayersInZoneTracker_Authority_OnEndPlayerOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(PlayersInZoneTracker_Authority_OnEndPlayerOverlap, OtherBodyIndex) == 0x000018, "Member 'PlayersInZoneTracker_Authority_OnEndPlayerOverlap::OtherBodyIndex' has a wrong offset!");

// Function DBDGameplay.RacoonDogComponent.Authority_OnPlayerInRangeChanged
// 0x0010 (0x0010 - 0x0000)
struct RacoonDogComponent_Authority_OnPlayerInRangeChanged final
{
public:
	class AActor*                                 playerActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInRange;                                         // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(RacoonDogComponent_Authority_OnPlayerInRangeChanged) == 0x000008, "Wrong alignment on RacoonDogComponent_Authority_OnPlayerInRangeChanged");
static_assert(sizeof(RacoonDogComponent_Authority_OnPlayerInRangeChanged) == 0x000010, "Wrong size on RacoonDogComponent_Authority_OnPlayerInRangeChanged");
static_assert(offsetof(RacoonDogComponent_Authority_OnPlayerInRangeChanged, playerActor) == 0x000000, "Member 'RacoonDogComponent_Authority_OnPlayerInRangeChanged::playerActor' has a wrong offset!");
static_assert(offsetof(RacoonDogComponent_Authority_OnPlayerInRangeChanged, IsInRange) == 0x000008, "Member 'RacoonDogComponent_Authority_OnPlayerInRangeChanged::IsInRange' has a wrong offset!");

// Function DBDGameplay.RacoonDogComponent.Authority_OnPlayerIsLookingTowardsChanged
// 0x0010 (0x0010 - 0x0000)
struct RacoonDogComponent_Authority_OnPlayerIsLookingTowardsChanged final
{
public:
	bool                                          IsLookingTowards;                                  // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class ADBDPlayer*                       Player;                                            // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RacoonDogComponent_Authority_OnPlayerIsLookingTowardsChanged) == 0x000008, "Wrong alignment on RacoonDogComponent_Authority_OnPlayerIsLookingTowardsChanged");
static_assert(sizeof(RacoonDogComponent_Authority_OnPlayerIsLookingTowardsChanged) == 0x000010, "Wrong size on RacoonDogComponent_Authority_OnPlayerIsLookingTowardsChanged");
static_assert(offsetof(RacoonDogComponent_Authority_OnPlayerIsLookingTowardsChanged, IsLookingTowards) == 0x000000, "Member 'RacoonDogComponent_Authority_OnPlayerIsLookingTowardsChanged::IsLookingTowards' has a wrong offset!");
static_assert(offsetof(RacoonDogComponent_Authority_OnPlayerIsLookingTowardsChanged, Player) == 0x000008, "Member 'RacoonDogComponent_Authority_OnPlayerIsLookingTowardsChanged::Player' has a wrong offset!");

// Function DBDGameplay.RacoonDogComponent.Authority_OnPossessedPawnChanged
// 0x0010 (0x0010 - 0x0000)
struct RacoonDogComponent_Authority_OnPossessedPawnChanged final
{
public:
	class APawn*                                  OldPawn;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  NewPawn;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RacoonDogComponent_Authority_OnPossessedPawnChanged) == 0x000008, "Wrong alignment on RacoonDogComponent_Authority_OnPossessedPawnChanged");
static_assert(sizeof(RacoonDogComponent_Authority_OnPossessedPawnChanged) == 0x000010, "Wrong size on RacoonDogComponent_Authority_OnPossessedPawnChanged");
static_assert(offsetof(RacoonDogComponent_Authority_OnPossessedPawnChanged, OldPawn) == 0x000000, "Member 'RacoonDogComponent_Authority_OnPossessedPawnChanged::OldPawn' has a wrong offset!");
static_assert(offsetof(RacoonDogComponent_Authority_OnPossessedPawnChanged, NewPawn) == 0x000008, "Member 'RacoonDogComponent_Authority_OnPossessedPawnChanged::NewPawn' has a wrong offset!");

// Function DBDGameplay.RacoonDogComponent.DBD_SetSelectedRacoonDogAnimIndex
// 0x0001 (0x0001 - 0x0000)
struct RacoonDogComponent_DBD_SetSelectedRacoonDogAnimIndex final
{
public:
	uint8                                         Index_0;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RacoonDogComponent_DBD_SetSelectedRacoonDogAnimIndex) == 0x000001, "Wrong alignment on RacoonDogComponent_DBD_SetSelectedRacoonDogAnimIndex");
static_assert(sizeof(RacoonDogComponent_DBD_SetSelectedRacoonDogAnimIndex) == 0x000001, "Wrong size on RacoonDogComponent_DBD_SetSelectedRacoonDogAnimIndex");
static_assert(offsetof(RacoonDogComponent_DBD_SetSelectedRacoonDogAnimIndex, Index_0) == 0x000000, "Member 'RacoonDogComponent_DBD_SetSelectedRacoonDogAnimIndex::Index_0' has a wrong offset!");

// Function DBDGameplay.RandomScriptedEventMapTriggerComponent.Authority_TryTriggerRandomEvent
// 0x0001 (0x0001 - 0x0000)
struct RandomScriptedEventMapTriggerComponent_Authority_TryTriggerRandomEvent final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RandomScriptedEventMapTriggerComponent_Authority_TryTriggerRandomEvent) == 0x000001, "Wrong alignment on RandomScriptedEventMapTriggerComponent_Authority_TryTriggerRandomEvent");
static_assert(sizeof(RandomScriptedEventMapTriggerComponent_Authority_TryTriggerRandomEvent) == 0x000001, "Wrong size on RandomScriptedEventMapTriggerComponent_Authority_TryTriggerRandomEvent");
static_assert(offsetof(RandomScriptedEventMapTriggerComponent_Authority_TryTriggerRandomEvent, ReturnValue) == 0x000000, "Member 'RandomScriptedEventMapTriggerComponent_Authority_TryTriggerRandomEvent::ReturnValue' has a wrong offset!");

// Function DBDGameplay.RangedExplosiveEffectHandlerComponent.OnRangedExplosiveDestroyed
// 0x0008 (0x0008 - 0x0000)
struct RangedExplosiveEffectHandlerComponent_OnRangedExplosiveDestroyed final
{
public:
	class AActor*                                 DestroyedActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RangedExplosiveEffectHandlerComponent_OnRangedExplosiveDestroyed) == 0x000008, "Wrong alignment on RangedExplosiveEffectHandlerComponent_OnRangedExplosiveDestroyed");
static_assert(sizeof(RangedExplosiveEffectHandlerComponent_OnRangedExplosiveDestroyed) == 0x000008, "Wrong size on RangedExplosiveEffectHandlerComponent_OnRangedExplosiveDestroyed");
static_assert(offsetof(RangedExplosiveEffectHandlerComponent_OnRangedExplosiveDestroyed, DestroyedActor) == 0x000000, "Member 'RangedExplosiveEffectHandlerComponent_OnRangedExplosiveDestroyed::DestroyedActor' has a wrong offset!");

// Function DBDGameplay.RespawnableComponent.Authority_TryTeleport
// 0x0001 (0x0001 - 0x0000)
struct RespawnableComponent_Authority_TryTeleport final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RespawnableComponent_Authority_TryTeleport) == 0x000001, "Wrong alignment on RespawnableComponent_Authority_TryTeleport");
static_assert(sizeof(RespawnableComponent_Authority_TryTeleport) == 0x000001, "Wrong size on RespawnableComponent_Authority_TryTeleport");
static_assert(offsetof(RespawnableComponent_Authority_TryTeleport, ReturnValue) == 0x000000, "Member 'RespawnableComponent_Authority_TryTeleport::ReturnValue' has a wrong offset!");

// Function DBDGameplay.ScreamFunctionLibrary.ScreamRevealSurvivor
// 0x0010 (0x0010 - 0x0000)
struct ScreamFunctionLibrary_ScreamRevealSurvivor final
{
public:
	class ASurvivor*                              Survivor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         screamRevealDuration;                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SpawnBubbleIndicator;                              // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ScreamFunctionLibrary_ScreamRevealSurvivor) == 0x000008, "Wrong alignment on ScreamFunctionLibrary_ScreamRevealSurvivor");
static_assert(sizeof(ScreamFunctionLibrary_ScreamRevealSurvivor) == 0x000010, "Wrong size on ScreamFunctionLibrary_ScreamRevealSurvivor");
static_assert(offsetof(ScreamFunctionLibrary_ScreamRevealSurvivor, Survivor) == 0x000000, "Member 'ScreamFunctionLibrary_ScreamRevealSurvivor::Survivor' has a wrong offset!");
static_assert(offsetof(ScreamFunctionLibrary_ScreamRevealSurvivor, screamRevealDuration) == 0x000008, "Member 'ScreamFunctionLibrary_ScreamRevealSurvivor::screamRevealDuration' has a wrong offset!");
static_assert(offsetof(ScreamFunctionLibrary_ScreamRevealSurvivor, SpawnBubbleIndicator) == 0x00000C, "Member 'ScreamFunctionLibrary_ScreamRevealSurvivor::SpawnBubbleIndicator' has a wrong offset!");

// Function DBDGameplay.SightRevealableComponent.Authority_IsBeingRevealed
// 0x0001 (0x0001 - 0x0000)
struct SightRevealableComponent_Authority_IsBeingRevealed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SightRevealableComponent_Authority_IsBeingRevealed) == 0x000001, "Wrong alignment on SightRevealableComponent_Authority_IsBeingRevealed");
static_assert(sizeof(SightRevealableComponent_Authority_IsBeingRevealed) == 0x000001, "Wrong size on SightRevealableComponent_Authority_IsBeingRevealed");
static_assert(offsetof(SightRevealableComponent_Authority_IsBeingRevealed, ReturnValue) == 0x000000, "Member 'SightRevealableComponent_Authority_IsBeingRevealed::ReturnValue' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusEmitterComponent.SetEmitterActive
// 0x0001 (0x0001 - 0x0000)
struct TerrorRadiusEmitterComponent_SetEmitterActive final
{
public:
	bool                                          Active;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusEmitterComponent_SetEmitterActive) == 0x000001, "Wrong alignment on TerrorRadiusEmitterComponent_SetEmitterActive");
static_assert(sizeof(TerrorRadiusEmitterComponent_SetEmitterActive) == 0x000001, "Wrong size on TerrorRadiusEmitterComponent_SetEmitterActive");
static_assert(offsetof(TerrorRadiusEmitterComponent_SetEmitterActive, Active) == 0x000000, "Member 'TerrorRadiusEmitterComponent_SetEmitterActive::Active' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusEmitterComponent.SetImitatesAudioOnly
// 0x0001 (0x0001 - 0x0000)
struct TerrorRadiusEmitterComponent_SetImitatesAudioOnly final
{
public:
	bool                                          imitatesAudioOnly;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusEmitterComponent_SetImitatesAudioOnly) == 0x000001, "Wrong alignment on TerrorRadiusEmitterComponent_SetImitatesAudioOnly");
static_assert(sizeof(TerrorRadiusEmitterComponent_SetImitatesAudioOnly) == 0x000001, "Wrong size on TerrorRadiusEmitterComponent_SetImitatesAudioOnly");
static_assert(offsetof(TerrorRadiusEmitterComponent_SetImitatesAudioOnly, imitatesAudioOnly) == 0x000000, "Member 'TerrorRadiusEmitterComponent_SetImitatesAudioOnly::imitatesAudioOnly' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusEmitterComponent.SetIsFakeTerrorRadius
// 0x0001 (0x0001 - 0x0000)
struct TerrorRadiusEmitterComponent_SetIsFakeTerrorRadius final
{
public:
	bool                                          Value;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusEmitterComponent_SetIsFakeTerrorRadius) == 0x000001, "Wrong alignment on TerrorRadiusEmitterComponent_SetIsFakeTerrorRadius");
static_assert(sizeof(TerrorRadiusEmitterComponent_SetIsFakeTerrorRadius) == 0x000001, "Wrong size on TerrorRadiusEmitterComponent_SetIsFakeTerrorRadius");
static_assert(offsetof(TerrorRadiusEmitterComponent_SetIsFakeTerrorRadius, Value) == 0x000000, "Member 'TerrorRadiusEmitterComponent_SetIsFakeTerrorRadius::Value' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusEmitterComponent.SetSimulatedFixedDistance
// 0x0004 (0x0004 - 0x0000)
struct TerrorRadiusEmitterComponent_SetSimulatedFixedDistance final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusEmitterComponent_SetSimulatedFixedDistance) == 0x000004, "Wrong alignment on TerrorRadiusEmitterComponent_SetSimulatedFixedDistance");
static_assert(sizeof(TerrorRadiusEmitterComponent_SetSimulatedFixedDistance) == 0x000004, "Wrong size on TerrorRadiusEmitterComponent_SetSimulatedFixedDistance");
static_assert(offsetof(TerrorRadiusEmitterComponent_SetSimulatedFixedDistance, Distance) == 0x000000, "Member 'TerrorRadiusEmitterComponent_SetSimulatedFixedDistance::Distance' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusEmitterComponent.SetTerrorRadius
// 0x0004 (0x0004 - 0x0000)
struct TerrorRadiusEmitterComponent_SetTerrorRadius final
{
public:
	float                                         Radius;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusEmitterComponent_SetTerrorRadius) == 0x000004, "Wrong alignment on TerrorRadiusEmitterComponent_SetTerrorRadius");
static_assert(sizeof(TerrorRadiusEmitterComponent_SetTerrorRadius) == 0x000004, "Wrong size on TerrorRadiusEmitterComponent_SetTerrorRadius");
static_assert(offsetof(TerrorRadiusEmitterComponent_SetTerrorRadius, Radius) == 0x000000, "Member 'TerrorRadiusEmitterComponent_SetTerrorRadius::Radius' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusEmitterComponent.GetImitatesAudioOnly
// 0x0001 (0x0001 - 0x0000)
struct TerrorRadiusEmitterComponent_GetImitatesAudioOnly final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusEmitterComponent_GetImitatesAudioOnly) == 0x000001, "Wrong alignment on TerrorRadiusEmitterComponent_GetImitatesAudioOnly");
static_assert(sizeof(TerrorRadiusEmitterComponent_GetImitatesAudioOnly) == 0x000001, "Wrong size on TerrorRadiusEmitterComponent_GetImitatesAudioOnly");
static_assert(offsetof(TerrorRadiusEmitterComponent_GetImitatesAudioOnly, ReturnValue) == 0x000000, "Member 'TerrorRadiusEmitterComponent_GetImitatesAudioOnly::ReturnValue' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusEmitterComponent.GetIsActive
// 0x0001 (0x0001 - 0x0000)
struct TerrorRadiusEmitterComponent_GetIsActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusEmitterComponent_GetIsActive) == 0x000001, "Wrong alignment on TerrorRadiusEmitterComponent_GetIsActive");
static_assert(sizeof(TerrorRadiusEmitterComponent_GetIsActive) == 0x000001, "Wrong size on TerrorRadiusEmitterComponent_GetIsActive");
static_assert(offsetof(TerrorRadiusEmitterComponent_GetIsActive, ReturnValue) == 0x000000, "Member 'TerrorRadiusEmitterComponent_GetIsActive::ReturnValue' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusEmitterComponent.GetRadius
// 0x0004 (0x0004 - 0x0000)
struct TerrorRadiusEmitterComponent_GetRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusEmitterComponent_GetRadius) == 0x000004, "Wrong alignment on TerrorRadiusEmitterComponent_GetRadius");
static_assert(sizeof(TerrorRadiusEmitterComponent_GetRadius) == 0x000004, "Wrong size on TerrorRadiusEmitterComponent_GetRadius");
static_assert(offsetof(TerrorRadiusEmitterComponent_GetRadius, ReturnValue) == 0x000000, "Member 'TerrorRadiusEmitterComponent_GetRadius::ReturnValue' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusEmitterComponent.GetSimulatedFixedDistance
// 0x0004 (0x0004 - 0x0000)
struct TerrorRadiusEmitterComponent_GetSimulatedFixedDistance final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusEmitterComponent_GetSimulatedFixedDistance) == 0x000004, "Wrong alignment on TerrorRadiusEmitterComponent_GetSimulatedFixedDistance");
static_assert(sizeof(TerrorRadiusEmitterComponent_GetSimulatedFixedDistance) == 0x000004, "Wrong size on TerrorRadiusEmitterComponent_GetSimulatedFixedDistance");
static_assert(offsetof(TerrorRadiusEmitterComponent_GetSimulatedFixedDistance, ReturnValue) == 0x000000, "Member 'TerrorRadiusEmitterComponent_GetSimulatedFixedDistance::ReturnValue' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusEmitterComponent.IsInTerrorRadius
// 0x0010 (0x0010 - 0x0000)
struct TerrorRadiusEmitterComponent_IsInTerrorRadius final
{
public:
	class UTerrorRadiusReceiverComponent*         receiver;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TerrorRadiusEmitterComponent_IsInTerrorRadius) == 0x000008, "Wrong alignment on TerrorRadiusEmitterComponent_IsInTerrorRadius");
static_assert(sizeof(TerrorRadiusEmitterComponent_IsInTerrorRadius) == 0x000010, "Wrong size on TerrorRadiusEmitterComponent_IsInTerrorRadius");
static_assert(offsetof(TerrorRadiusEmitterComponent_IsInTerrorRadius, receiver) == 0x000000, "Member 'TerrorRadiusEmitterComponent_IsInTerrorRadius::receiver' has a wrong offset!");
static_assert(offsetof(TerrorRadiusEmitterComponent_IsInTerrorRadius, ReturnValue) == 0x000008, "Member 'TerrorRadiusEmitterComponent_IsInTerrorRadius::ReturnValue' has a wrong offset!");

// Function DBDGameplay.SlasherTerrorRadiusEmitterComponent.SetBaseTerrorRadius
// 0x0008 (0x0008 - 0x0000)
struct SlasherTerrorRadiusEmitterComponent_SetBaseTerrorRadius final
{
public:
	float                                         baseTerrorRadius;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          progressive;                                       // 0x0004(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SlasherTerrorRadiusEmitterComponent_SetBaseTerrorRadius) == 0x000004, "Wrong alignment on SlasherTerrorRadiusEmitterComponent_SetBaseTerrorRadius");
static_assert(sizeof(SlasherTerrorRadiusEmitterComponent_SetBaseTerrorRadius) == 0x000008, "Wrong size on SlasherTerrorRadiusEmitterComponent_SetBaseTerrorRadius");
static_assert(offsetof(SlasherTerrorRadiusEmitterComponent_SetBaseTerrorRadius, baseTerrorRadius) == 0x000000, "Member 'SlasherTerrorRadiusEmitterComponent_SetBaseTerrorRadius::baseTerrorRadius' has a wrong offset!");
static_assert(offsetof(SlasherTerrorRadiusEmitterComponent_SetBaseTerrorRadius, progressive) == 0x000004, "Member 'SlasherTerrorRadiusEmitterComponent_SetBaseTerrorRadius::progressive' has a wrong offset!");

// Function DBDGameplay.SmokeBombCosmeticHelperActor.Cosmetic_UpdateVisibility
// 0x0001 (0x0001 - 0x0000)
struct SmokeBombCosmeticHelperActor_Cosmetic_UpdateVisibility final
{
public:
	bool                                          IsVisible;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SmokeBombCosmeticHelperActor_Cosmetic_UpdateVisibility) == 0x000001, "Wrong alignment on SmokeBombCosmeticHelperActor_Cosmetic_UpdateVisibility");
static_assert(sizeof(SmokeBombCosmeticHelperActor_Cosmetic_UpdateVisibility) == 0x000001, "Wrong size on SmokeBombCosmeticHelperActor_Cosmetic_UpdateVisibility");
static_assert(offsetof(SmokeBombCosmeticHelperActor_Cosmetic_UpdateVisibility, IsVisible) == 0x000000, "Member 'SmokeBombCosmeticHelperActor_Cosmetic_UpdateVisibility::IsVisible' has a wrong offset!");

// Function DBDGameplay.SmokeBombCosmeticHelperActor.OnFirstPersonChanged
// 0x0001 (0x0001 - 0x0000)
struct SmokeBombCosmeticHelperActor_OnFirstPersonChanged final
{
public:
	bool                                          isFirstPerson;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SmokeBombCosmeticHelperActor_OnFirstPersonChanged) == 0x000001, "Wrong alignment on SmokeBombCosmeticHelperActor_OnFirstPersonChanged");
static_assert(sizeof(SmokeBombCosmeticHelperActor_OnFirstPersonChanged) == 0x000001, "Wrong size on SmokeBombCosmeticHelperActor_OnFirstPersonChanged");
static_assert(offsetof(SmokeBombCosmeticHelperActor_OnFirstPersonChanged, isFirstPerson) == 0x000000, "Member 'SmokeBombCosmeticHelperActor_OnFirstPersonChanged::isFirstPerson' has a wrong offset!");

// Function DBDGameplay.SmokeBombCosmeticHelperActor.GetOwningPlayer
// 0x0008 (0x0008 - 0x0000)
struct SmokeBombCosmeticHelperActor_GetOwningPlayer final
{
public:
	class ADBDPlayer*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SmokeBombCosmeticHelperActor_GetOwningPlayer) == 0x000008, "Wrong alignment on SmokeBombCosmeticHelperActor_GetOwningPlayer");
static_assert(sizeof(SmokeBombCosmeticHelperActor_GetOwningPlayer) == 0x000008, "Wrong size on SmokeBombCosmeticHelperActor_GetOwningPlayer");
static_assert(offsetof(SmokeBombCosmeticHelperActor_GetOwningPlayer, ReturnValue) == 0x000000, "Member 'SmokeBombCosmeticHelperActor_GetOwningPlayer::ReturnValue' has a wrong offset!");

// Function DBDGameplay.SteamPipe.Authority_OnBeginOverlap
// 0x0110 (0x0110 - 0x0000)
struct SteamPipe_Authority_OnBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F0)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(SteamPipe_Authority_OnBeginOverlap) == 0x000008, "Wrong alignment on SteamPipe_Authority_OnBeginOverlap");
static_assert(sizeof(SteamPipe_Authority_OnBeginOverlap) == 0x000110, "Wrong size on SteamPipe_Authority_OnBeginOverlap");
static_assert(offsetof(SteamPipe_Authority_OnBeginOverlap, OverlappedComponent) == 0x000000, "Member 'SteamPipe_Authority_OnBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(SteamPipe_Authority_OnBeginOverlap, OtherActor) == 0x000008, "Member 'SteamPipe_Authority_OnBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(SteamPipe_Authority_OnBeginOverlap, OtherComp) == 0x000010, "Member 'SteamPipe_Authority_OnBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(SteamPipe_Authority_OnBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'SteamPipe_Authority_OnBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(SteamPipe_Authority_OnBeginOverlap, bFromSweep) == 0x00001C, "Member 'SteamPipe_Authority_OnBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(SteamPipe_Authority_OnBeginOverlap, SweepResult) == 0x000020, "Member 'SteamPipe_Authority_OnBeginOverlap::SweepResult' has a wrong offset!");

// Function DBDGameplay.SteamPipe.Authority_OnEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct SteamPipe_Authority_OnEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SteamPipe_Authority_OnEndOverlap) == 0x000008, "Wrong alignment on SteamPipe_Authority_OnEndOverlap");
static_assert(sizeof(SteamPipe_Authority_OnEndOverlap) == 0x000020, "Wrong size on SteamPipe_Authority_OnEndOverlap");
static_assert(offsetof(SteamPipe_Authority_OnEndOverlap, OverlappedComponent) == 0x000000, "Member 'SteamPipe_Authority_OnEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(SteamPipe_Authority_OnEndOverlap, OtherActor) == 0x000008, "Member 'SteamPipe_Authority_OnEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(SteamPipe_Authority_OnEndOverlap, OtherComp) == 0x000010, "Member 'SteamPipe_Authority_OnEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(SteamPipe_Authority_OnEndOverlap, OtherBodyIndex) == 0x000018, "Member 'SteamPipe_Authority_OnEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function DBDGameplay.SteamPipe.Cosmetic_OnSteamPipeStateChanged
// 0x0001 (0x0001 - 0x0000)
struct SteamPipe_Cosmetic_OnSteamPipeStateChanged final
{
public:
	ESteamPipeState                               newState;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SteamPipe_Cosmetic_OnSteamPipeStateChanged) == 0x000001, "Wrong alignment on SteamPipe_Cosmetic_OnSteamPipeStateChanged");
static_assert(sizeof(SteamPipe_Cosmetic_OnSteamPipeStateChanged) == 0x000001, "Wrong size on SteamPipe_Cosmetic_OnSteamPipeStateChanged");
static_assert(offsetof(SteamPipe_Cosmetic_OnSteamPipeStateChanged, newState) == 0x000000, "Member 'SteamPipe_Cosmetic_OnSteamPipeStateChanged::newState' has a wrong offset!");

// Function DBDGameplay.SteamPipe.GetCurrentSteamPipeState
// 0x0001 (0x0001 - 0x0000)
struct SteamPipe_GetCurrentSteamPipeState final
{
public:
	ESteamPipeState                               ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SteamPipe_GetCurrentSteamPipeState) == 0x000001, "Wrong alignment on SteamPipe_GetCurrentSteamPipeState");
static_assert(sizeof(SteamPipe_GetCurrentSteamPipeState) == 0x000001, "Wrong size on SteamPipe_GetCurrentSteamPipeState");
static_assert(offsetof(SteamPipe_GetCurrentSteamPipeState, ReturnValue) == 0x000000, "Member 'SteamPipe_GetCurrentSteamPipeState::ReturnValue' has a wrong offset!");

// Function DBDGameplay.SteamPipeManagerComponent.Authority_OnCharacterAdded
// 0x0008 (0x0008 - 0x0000)
struct SteamPipeManagerComponent_Authority_OnCharacterAdded final
{
public:
	class ADBDPlayer*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SteamPipeManagerComponent_Authority_OnCharacterAdded) == 0x000008, "Wrong alignment on SteamPipeManagerComponent_Authority_OnCharacterAdded");
static_assert(sizeof(SteamPipeManagerComponent_Authority_OnCharacterAdded) == 0x000008, "Wrong size on SteamPipeManagerComponent_Authority_OnCharacterAdded");
static_assert(offsetof(SteamPipeManagerComponent_Authority_OnCharacterAdded, Character) == 0x000000, "Member 'SteamPipeManagerComponent_Authority_OnCharacterAdded::Character' has a wrong offset!");

// Function DBDGameplay.SteamPipeManagerComponent.Authority_OnResetInteractionComplete
// 0x0018 (0x0018 - 0x0000)
struct SteamPipeManagerComponent_Authority_OnResetInteractionComplete final
{
public:
	bool                                          COMPLETED;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         instigatorsForCompletion;                          // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SteamPipeManagerComponent_Authority_OnResetInteractionComplete) == 0x000008, "Wrong alignment on SteamPipeManagerComponent_Authority_OnResetInteractionComplete");
static_assert(sizeof(SteamPipeManagerComponent_Authority_OnResetInteractionComplete) == 0x000018, "Wrong size on SteamPipeManagerComponent_Authority_OnResetInteractionComplete");
static_assert(offsetof(SteamPipeManagerComponent_Authority_OnResetInteractionComplete, COMPLETED) == 0x000000, "Member 'SteamPipeManagerComponent_Authority_OnResetInteractionComplete::COMPLETED' has a wrong offset!");
static_assert(offsetof(SteamPipeManagerComponent_Authority_OnResetInteractionComplete, instigatorsForCompletion) == 0x000008, "Member 'SteamPipeManagerComponent_Authority_OnResetInteractionComplete::instigatorsForCompletion' has a wrong offset!");

// Function DBDGameplay.SteamPipeManagerComponent.Authority_OnSteamPipeStateChanged
// 0x0010 (0x0010 - 0x0000)
struct SteamPipeManagerComponent_Authority_OnSteamPipeStateChanged final
{
public:
	const class ASteamPipe*                       SteamPipe;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESteamPipeState                               newState;                                          // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SteamPipeManagerComponent_Authority_OnSteamPipeStateChanged) == 0x000008, "Wrong alignment on SteamPipeManagerComponent_Authority_OnSteamPipeStateChanged");
static_assert(sizeof(SteamPipeManagerComponent_Authority_OnSteamPipeStateChanged) == 0x000010, "Wrong size on SteamPipeManagerComponent_Authority_OnSteamPipeStateChanged");
static_assert(offsetof(SteamPipeManagerComponent_Authority_OnSteamPipeStateChanged, SteamPipe) == 0x000000, "Member 'SteamPipeManagerComponent_Authority_OnSteamPipeStateChanged::SteamPipe' has a wrong offset!");
static_assert(offsetof(SteamPipeManagerComponent_Authority_OnSteamPipeStateChanged, newState) == 0x000008, "Member 'SteamPipeManagerComponent_Authority_OnSteamPipeStateChanged::newState' has a wrong offset!");

// Function DBDGameplay.SteamPipeResetSwitch.Cosmetic_NumberOfDisabledSteamPipesChanged
// 0x0004 (0x0004 - 0x0000)
struct SteamPipeResetSwitch_Cosmetic_NumberOfDisabledSteamPipesChanged final
{
public:
	int32                                         numberOfDisabledSteamPipes;                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SteamPipeResetSwitch_Cosmetic_NumberOfDisabledSteamPipesChanged) == 0x000004, "Wrong alignment on SteamPipeResetSwitch_Cosmetic_NumberOfDisabledSteamPipesChanged");
static_assert(sizeof(SteamPipeResetSwitch_Cosmetic_NumberOfDisabledSteamPipesChanged) == 0x000004, "Wrong size on SteamPipeResetSwitch_Cosmetic_NumberOfDisabledSteamPipesChanged");
static_assert(offsetof(SteamPipeResetSwitch_Cosmetic_NumberOfDisabledSteamPipesChanged, numberOfDisabledSteamPipes) == 0x000000, "Member 'SteamPipeResetSwitch_Cosmetic_NumberOfDisabledSteamPipesChanged::numberOfDisabledSteamPipes' has a wrong offset!");

// Function DBDGameplay.SteamPipeResetSwitch.Cosmetic_OnSwitchTriggered
// 0x0004 (0x0004 - 0x0000)
struct SteamPipeResetSwitch_Cosmetic_OnSwitchTriggered final
{
public:
	float                                         cooldownTime;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SteamPipeResetSwitch_Cosmetic_OnSwitchTriggered) == 0x000004, "Wrong alignment on SteamPipeResetSwitch_Cosmetic_OnSwitchTriggered");
static_assert(sizeof(SteamPipeResetSwitch_Cosmetic_OnSwitchTriggered) == 0x000004, "Wrong size on SteamPipeResetSwitch_Cosmetic_OnSwitchTriggered");
static_assert(offsetof(SteamPipeResetSwitch_Cosmetic_OnSwitchTriggered, cooldownTime) == 0x000000, "Member 'SteamPipeResetSwitch_Cosmetic_OnSwitchTriggered::cooldownTime' has a wrong offset!");

// Function DBDGameplay.SteamPipeResetSwitch.Cosmetic_OnTotalSteamPipesInLevelChanged
// 0x0004 (0x0004 - 0x0000)
struct SteamPipeResetSwitch_Cosmetic_OnTotalSteamPipesInLevelChanged final
{
public:
	int32                                         totalSteamPipesInLevel;                            // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SteamPipeResetSwitch_Cosmetic_OnTotalSteamPipesInLevelChanged) == 0x000004, "Wrong alignment on SteamPipeResetSwitch_Cosmetic_OnTotalSteamPipesInLevelChanged");
static_assert(sizeof(SteamPipeResetSwitch_Cosmetic_OnTotalSteamPipesInLevelChanged) == 0x000004, "Wrong size on SteamPipeResetSwitch_Cosmetic_OnTotalSteamPipesInLevelChanged");
static_assert(offsetof(SteamPipeResetSwitch_Cosmetic_OnTotalSteamPipesInLevelChanged, totalSteamPipesInLevel) == 0x000000, "Member 'SteamPipeResetSwitch_Cosmetic_OnTotalSteamPipesInLevelChanged::totalSteamPipesInLevel' has a wrong offset!");

// Function DBDGameplay.SteamPipeResetSwitch.GetTotalSteamPipesInLevel
// 0x0004 (0x0004 - 0x0000)
struct SteamPipeResetSwitch_GetTotalSteamPipesInLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SteamPipeResetSwitch_GetTotalSteamPipesInLevel) == 0x000004, "Wrong alignment on SteamPipeResetSwitch_GetTotalSteamPipesInLevel");
static_assert(sizeof(SteamPipeResetSwitch_GetTotalSteamPipesInLevel) == 0x000004, "Wrong size on SteamPipeResetSwitch_GetTotalSteamPipesInLevel");
static_assert(offsetof(SteamPipeResetSwitch_GetTotalSteamPipesInLevel, ReturnValue) == 0x000000, "Member 'SteamPipeResetSwitch_GetTotalSteamPipesInLevel::ReturnValue' has a wrong offset!");

// Function DBDGameplay.StruggleComponent.OnSkillCheckEnd
// 0x0010 (0x0010 - 0x0000)
struct StruggleComponent_OnSkillCheckEnd final
{
public:
	bool                                          hadInput;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Success;                                           // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Bonus;                                             // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillCheckCustomType                         Type;                                              // 0x0003(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             Player;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StruggleComponent_OnSkillCheckEnd) == 0x000008, "Wrong alignment on StruggleComponent_OnSkillCheckEnd");
static_assert(sizeof(StruggleComponent_OnSkillCheckEnd) == 0x000010, "Wrong size on StruggleComponent_OnSkillCheckEnd");
static_assert(offsetof(StruggleComponent_OnSkillCheckEnd, hadInput) == 0x000000, "Member 'StruggleComponent_OnSkillCheckEnd::hadInput' has a wrong offset!");
static_assert(offsetof(StruggleComponent_OnSkillCheckEnd, Success) == 0x000001, "Member 'StruggleComponent_OnSkillCheckEnd::Success' has a wrong offset!");
static_assert(offsetof(StruggleComponent_OnSkillCheckEnd, Bonus) == 0x000002, "Member 'StruggleComponent_OnSkillCheckEnd::Bonus' has a wrong offset!");
static_assert(offsetof(StruggleComponent_OnSkillCheckEnd, Type) == 0x000003, "Member 'StruggleComponent_OnSkillCheckEnd::Type' has a wrong offset!");
static_assert(offsetof(StruggleComponent_OnSkillCheckEnd, Player) == 0x000008, "Member 'StruggleComponent_OnSkillCheckEnd::Player' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusReceiverComponent.IsInTerrorRadius
// 0x0001 (0x0001 - 0x0000)
struct TerrorRadiusReceiverComponent_IsInTerrorRadius final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusReceiverComponent_IsInTerrorRadius) == 0x000001, "Wrong alignment on TerrorRadiusReceiverComponent_IsInTerrorRadius");
static_assert(sizeof(TerrorRadiusReceiverComponent_IsInTerrorRadius) == 0x000001, "Wrong size on TerrorRadiusReceiverComponent_IsInTerrorRadius");
static_assert(offsetof(TerrorRadiusReceiverComponent_IsInTerrorRadius, ReturnValue) == 0x000000, "Member 'TerrorRadiusReceiverComponent_IsInTerrorRadius::ReturnValue' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusReceiverComponent.IsInTerrorRadiusRange
// 0x0001 (0x0001 - 0x0000)
struct TerrorRadiusReceiverComponent_IsInTerrorRadiusRange final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusReceiverComponent_IsInTerrorRadiusRange) == 0x000001, "Wrong alignment on TerrorRadiusReceiverComponent_IsInTerrorRadiusRange");
static_assert(sizeof(TerrorRadiusReceiverComponent_IsInTerrorRadiusRange) == 0x000001, "Wrong size on TerrorRadiusReceiverComponent_IsInTerrorRadiusRange");
static_assert(offsetof(TerrorRadiusReceiverComponent_IsInTerrorRadiusRange, ReturnValue) == 0x000000, "Member 'TerrorRadiusReceiverComponent_IsInTerrorRadiusRange::ReturnValue' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusScreenIndicatorComponent.OnHeartStateChanged
// 0x000C (0x000C - 0x0000)
struct TerrorRadiusScreenIndicatorComponent_OnHeartStateChanged final
{
public:
	struct FGameplayTag                           heartState;                                        // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusScreenIndicatorComponent_OnHeartStateChanged) == 0x000004, "Wrong alignment on TerrorRadiusScreenIndicatorComponent_OnHeartStateChanged");
static_assert(sizeof(TerrorRadiusScreenIndicatorComponent_OnHeartStateChanged) == 0x00000C, "Wrong size on TerrorRadiusScreenIndicatorComponent_OnHeartStateChanged");
static_assert(offsetof(TerrorRadiusScreenIndicatorComponent_OnHeartStateChanged, heartState) == 0x000000, "Member 'TerrorRadiusScreenIndicatorComponent_OnHeartStateChanged::heartState' has a wrong offset!");

// Function DBDGameplay.WiggleComponent.Authority_AddWiggleCharge
// 0x0004 (0x0004 - 0x0000)
struct WiggleComponent_Authority_AddWiggleCharge final
{
public:
	float                                         ChargeAmount;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleComponent_Authority_AddWiggleCharge) == 0x000004, "Wrong alignment on WiggleComponent_Authority_AddWiggleCharge");
static_assert(sizeof(WiggleComponent_Authority_AddWiggleCharge) == 0x000004, "Wrong size on WiggleComponent_Authority_AddWiggleCharge");
static_assert(offsetof(WiggleComponent_Authority_AddWiggleCharge, ChargeAmount) == 0x000000, "Member 'WiggleComponent_Authority_AddWiggleCharge::ChargeAmount' has a wrong offset!");

// Function DBDGameplay.WiggleComponent.OnHideWiggleSkillCheck
// 0x0001 (0x0001 - 0x0000)
struct WiggleComponent_OnHideWiggleSkillCheck final
{
public:
	ESkillCheckCustomType                         Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleComponent_OnHideWiggleSkillCheck) == 0x000001, "Wrong alignment on WiggleComponent_OnHideWiggleSkillCheck");
static_assert(sizeof(WiggleComponent_OnHideWiggleSkillCheck) == 0x000001, "Wrong size on WiggleComponent_OnHideWiggleSkillCheck");
static_assert(offsetof(WiggleComponent_OnHideWiggleSkillCheck, Type) == 0x000000, "Member 'WiggleComponent_OnHideWiggleSkillCheck::Type' has a wrong offset!");

// Function DBDGameplay.WiggleComponent.OnPickedUpSkillCheckEnd
// 0x0010 (0x0010 - 0x0000)
struct WiggleComponent_OnPickedUpSkillCheckEnd final
{
public:
	bool                                          hadInput;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Success;                                           // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Bonus;                                             // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillCheckCustomType                         Type;                                              // 0x0003(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             Player;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleComponent_OnPickedUpSkillCheckEnd) == 0x000008, "Wrong alignment on WiggleComponent_OnPickedUpSkillCheckEnd");
static_assert(sizeof(WiggleComponent_OnPickedUpSkillCheckEnd) == 0x000010, "Wrong size on WiggleComponent_OnPickedUpSkillCheckEnd");
static_assert(offsetof(WiggleComponent_OnPickedUpSkillCheckEnd, hadInput) == 0x000000, "Member 'WiggleComponent_OnPickedUpSkillCheckEnd::hadInput' has a wrong offset!");
static_assert(offsetof(WiggleComponent_OnPickedUpSkillCheckEnd, Success) == 0x000001, "Member 'WiggleComponent_OnPickedUpSkillCheckEnd::Success' has a wrong offset!");
static_assert(offsetof(WiggleComponent_OnPickedUpSkillCheckEnd, Bonus) == 0x000002, "Member 'WiggleComponent_OnPickedUpSkillCheckEnd::Bonus' has a wrong offset!");
static_assert(offsetof(WiggleComponent_OnPickedUpSkillCheckEnd, Type) == 0x000003, "Member 'WiggleComponent_OnPickedUpSkillCheckEnd::Type' has a wrong offset!");
static_assert(offsetof(WiggleComponent_OnPickedUpSkillCheckEnd, Player) == 0x000008, "Member 'WiggleComponent_OnPickedUpSkillCheckEnd::Player' has a wrong offset!");

// Function DBDGameplay.WiggleComponent.OnPlayerPickedUpEnd
// 0x0008 (0x0008 - 0x0000)
struct WiggleComponent_OnPlayerPickedUpEnd final
{
public:
	class ADBDPlayer*                             picker;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleComponent_OnPlayerPickedUpEnd) == 0x000008, "Wrong alignment on WiggleComponent_OnPlayerPickedUpEnd");
static_assert(sizeof(WiggleComponent_OnPlayerPickedUpEnd) == 0x000008, "Wrong size on WiggleComponent_OnPlayerPickedUpEnd");
static_assert(offsetof(WiggleComponent_OnPlayerPickedUpEnd, picker) == 0x000000, "Member 'WiggleComponent_OnPlayerPickedUpEnd::picker' has a wrong offset!");

// Function DBDGameplay.WiggleComponent.OnPlayerPickedUpStart
// 0x0008 (0x0008 - 0x0000)
struct WiggleComponent_OnPlayerPickedUpStart final
{
public:
	class ADBDPlayer*                             picker;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleComponent_OnPlayerPickedUpStart) == 0x000008, "Wrong alignment on WiggleComponent_OnPlayerPickedUpStart");
static_assert(sizeof(WiggleComponent_OnPlayerPickedUpStart) == 0x000008, "Wrong size on WiggleComponent_OnPlayerPickedUpStart");
static_assert(offsetof(WiggleComponent_OnPlayerPickedUpStart, picker) == 0x000000, "Member 'WiggleComponent_OnPlayerPickedUpStart::picker' has a wrong offset!");

// Function DBDGameplay.WiggleComponent.OnWiggleSkillCheckEnd
// 0x0010 (0x0010 - 0x0000)
struct WiggleComponent_OnWiggleSkillCheckEnd final
{
public:
	bool                                          hadInput;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Success;                                           // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Bonus;                                             // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillCheckCustomType                         Type;                                              // 0x0003(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             Player;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleComponent_OnWiggleSkillCheckEnd) == 0x000008, "Wrong alignment on WiggleComponent_OnWiggleSkillCheckEnd");
static_assert(sizeof(WiggleComponent_OnWiggleSkillCheckEnd) == 0x000010, "Wrong size on WiggleComponent_OnWiggleSkillCheckEnd");
static_assert(offsetof(WiggleComponent_OnWiggleSkillCheckEnd, hadInput) == 0x000000, "Member 'WiggleComponent_OnWiggleSkillCheckEnd::hadInput' has a wrong offset!");
static_assert(offsetof(WiggleComponent_OnWiggleSkillCheckEnd, Success) == 0x000001, "Member 'WiggleComponent_OnWiggleSkillCheckEnd::Success' has a wrong offset!");
static_assert(offsetof(WiggleComponent_OnWiggleSkillCheckEnd, Bonus) == 0x000002, "Member 'WiggleComponent_OnWiggleSkillCheckEnd::Bonus' has a wrong offset!");
static_assert(offsetof(WiggleComponent_OnWiggleSkillCheckEnd, Type) == 0x000003, "Member 'WiggleComponent_OnWiggleSkillCheckEnd::Type' has a wrong offset!");
static_assert(offsetof(WiggleComponent_OnWiggleSkillCheckEnd, Player) == 0x000008, "Member 'WiggleComponent_OnWiggleSkillCheckEnd::Player' has a wrong offset!");

// Function DBDGameplay.WiggleComponent.DBD_SetWiggleProgress
// 0x0004 (0x0004 - 0x0000)
struct WiggleComponent_DBD_SetWiggleProgress final
{
public:
	float                                         progressPercent;                                   // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleComponent_DBD_SetWiggleProgress) == 0x000004, "Wrong alignment on WiggleComponent_DBD_SetWiggleProgress");
static_assert(sizeof(WiggleComponent_DBD_SetWiggleProgress) == 0x000004, "Wrong size on WiggleComponent_DBD_SetWiggleProgress");
static_assert(offsetof(WiggleComponent_DBD_SetWiggleProgress, progressPercent) == 0x000000, "Member 'WiggleComponent_DBD_SetWiggleProgress::progressPercent' has a wrong offset!");

// Function DBDGameplay.WiggleComponent.GetWiggleChargeable
// 0x0008 (0x0008 - 0x0000)
struct WiggleComponent_GetWiggleChargeable final
{
public:
	class UChargeableComponent*                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleComponent_GetWiggleChargeable) == 0x000008, "Wrong alignment on WiggleComponent_GetWiggleChargeable");
static_assert(sizeof(WiggleComponent_GetWiggleChargeable) == 0x000008, "Wrong size on WiggleComponent_GetWiggleChargeable");
static_assert(offsetof(WiggleComponent_GetWiggleChargeable, ReturnValue) == 0x000000, "Member 'WiggleComponent_GetWiggleChargeable::ReturnValue' has a wrong offset!");

// Function DBDGameplay.WiggleFreeComponent.Authority_OnChargeableCompleteEvent
// 0x0018 (0x0018 - 0x0000)
struct WiggleFreeComponent_Authority_OnChargeableCompleteEvent final
{
public:
	bool                                          COMPLETED;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         instigatorsForCompletion;                          // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleFreeComponent_Authority_OnChargeableCompleteEvent) == 0x000008, "Wrong alignment on WiggleFreeComponent_Authority_OnChargeableCompleteEvent");
static_assert(sizeof(WiggleFreeComponent_Authority_OnChargeableCompleteEvent) == 0x000018, "Wrong size on WiggleFreeComponent_Authority_OnChargeableCompleteEvent");
static_assert(offsetof(WiggleFreeComponent_Authority_OnChargeableCompleteEvent, COMPLETED) == 0x000000, "Member 'WiggleFreeComponent_Authority_OnChargeableCompleteEvent::COMPLETED' has a wrong offset!");
static_assert(offsetof(WiggleFreeComponent_Authority_OnChargeableCompleteEvent, instigatorsForCompletion) == 0x000008, "Member 'WiggleFreeComponent_Authority_OnChargeableCompleteEvent::instigatorsForCompletion' has a wrong offset!");

// Function DBDGameplay.WiggleFreeComponent.Authority_OnChargeApplied
// 0x0018 (0x0018 - 0x0000)
struct WiggleFreeComponent_Authority_OnChargeApplied final
{
public:
	float                                         IndividualChargeAmount;                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalChargeAmount;                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ChargeInstigator;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WasCoop;                                           // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeltaTime;                                         // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleFreeComponent_Authority_OnChargeApplied) == 0x000008, "Wrong alignment on WiggleFreeComponent_Authority_OnChargeApplied");
static_assert(sizeof(WiggleFreeComponent_Authority_OnChargeApplied) == 0x000018, "Wrong size on WiggleFreeComponent_Authority_OnChargeApplied");
static_assert(offsetof(WiggleFreeComponent_Authority_OnChargeApplied, IndividualChargeAmount) == 0x000000, "Member 'WiggleFreeComponent_Authority_OnChargeApplied::IndividualChargeAmount' has a wrong offset!");
static_assert(offsetof(WiggleFreeComponent_Authority_OnChargeApplied, TotalChargeAmount) == 0x000004, "Member 'WiggleFreeComponent_Authority_OnChargeApplied::TotalChargeAmount' has a wrong offset!");
static_assert(offsetof(WiggleFreeComponent_Authority_OnChargeApplied, ChargeInstigator) == 0x000008, "Member 'WiggleFreeComponent_Authority_OnChargeApplied::ChargeInstigator' has a wrong offset!");
static_assert(offsetof(WiggleFreeComponent_Authority_OnChargeApplied, WasCoop) == 0x000010, "Member 'WiggleFreeComponent_Authority_OnChargeApplied::WasCoop' has a wrong offset!");
static_assert(offsetof(WiggleFreeComponent_Authority_OnChargeApplied, DeltaTime) == 0x000014, "Member 'WiggleFreeComponent_Authority_OnChargeApplied::DeltaTime' has a wrong offset!");

// Function DBDGameplay.WiggleFreeComponent.Authority_OnPlayerPickedUpEnd
// 0x0008 (0x0008 - 0x0000)
struct WiggleFreeComponent_Authority_OnPlayerPickedUpEnd final
{
public:
	class ADBDPlayer*                             picker;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleFreeComponent_Authority_OnPlayerPickedUpEnd) == 0x000008, "Wrong alignment on WiggleFreeComponent_Authority_OnPlayerPickedUpEnd");
static_assert(sizeof(WiggleFreeComponent_Authority_OnPlayerPickedUpEnd) == 0x000008, "Wrong size on WiggleFreeComponent_Authority_OnPlayerPickedUpEnd");
static_assert(offsetof(WiggleFreeComponent_Authority_OnPlayerPickedUpEnd, picker) == 0x000000, "Member 'WiggleFreeComponent_Authority_OnPlayerPickedUpEnd::picker' has a wrong offset!");

// Function DBDGameplay.WiggleMotionComponent.OnHideWiggleSkillCheck
// 0x0001 (0x0001 - 0x0000)
struct WiggleMotionComponent_OnHideWiggleSkillCheck final
{
public:
	ESkillCheckCustomType                         Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleMotionComponent_OnHideWiggleSkillCheck) == 0x000001, "Wrong alignment on WiggleMotionComponent_OnHideWiggleSkillCheck");
static_assert(sizeof(WiggleMotionComponent_OnHideWiggleSkillCheck) == 0x000001, "Wrong size on WiggleMotionComponent_OnHideWiggleSkillCheck");
static_assert(offsetof(WiggleMotionComponent_OnHideWiggleSkillCheck, Type) == 0x000000, "Member 'WiggleMotionComponent_OnHideWiggleSkillCheck::Type' has a wrong offset!");

// Function DBDGameplay.WiggleMotionComponent.OnSurvivorPickedUp
// 0x0010 (0x0010 - 0x0000)
struct WiggleMotionComponent_OnSurvivorPickedUp final
{
public:
	class ADBDPlayer*                             Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         pickupDuration;                                    // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(WiggleMotionComponent_OnSurvivorPickedUp) == 0x000008, "Wrong alignment on WiggleMotionComponent_OnSurvivorPickedUp");
static_assert(sizeof(WiggleMotionComponent_OnSurvivorPickedUp) == 0x000010, "Wrong size on WiggleMotionComponent_OnSurvivorPickedUp");
static_assert(offsetof(WiggleMotionComponent_OnSurvivorPickedUp, Target) == 0x000000, "Member 'WiggleMotionComponent_OnSurvivorPickedUp::Target' has a wrong offset!");
static_assert(offsetof(WiggleMotionComponent_OnSurvivorPickedUp, pickupDuration) == 0x000008, "Member 'WiggleMotionComponent_OnSurvivorPickedUp::pickupDuration' has a wrong offset!");

// Function DBDGameplay.WiggleMotionComponent.OnSurvivorRemoved
// 0x0008 (0x0008 - 0x0000)
struct WiggleMotionComponent_OnSurvivorRemoved final
{
public:
	class ADBDPlayer*                             Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleMotionComponent_OnSurvivorRemoved) == 0x000008, "Wrong alignment on WiggleMotionComponent_OnSurvivorRemoved");
static_assert(sizeof(WiggleMotionComponent_OnSurvivorRemoved) == 0x000008, "Wrong size on WiggleMotionComponent_OnSurvivorRemoved");
static_assert(offsetof(WiggleMotionComponent_OnSurvivorRemoved, Target) == 0x000000, "Member 'WiggleMotionComponent_OnSurvivorRemoved::Target' has a wrong offset!");

// Function DBDGameplay.WiggleMotionComponent.OnWiggleSkillCheckEnd
// 0x0010 (0x0010 - 0x0000)
struct WiggleMotionComponent_OnWiggleSkillCheckEnd final
{
public:
	bool                                          hadInput;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Success;                                           // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Bonus;                                             // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillCheckCustomType                         Type;                                              // 0x0003(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             Player;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleMotionComponent_OnWiggleSkillCheckEnd) == 0x000008, "Wrong alignment on WiggleMotionComponent_OnWiggleSkillCheckEnd");
static_assert(sizeof(WiggleMotionComponent_OnWiggleSkillCheckEnd) == 0x000010, "Wrong size on WiggleMotionComponent_OnWiggleSkillCheckEnd");
static_assert(offsetof(WiggleMotionComponent_OnWiggleSkillCheckEnd, hadInput) == 0x000000, "Member 'WiggleMotionComponent_OnWiggleSkillCheckEnd::hadInput' has a wrong offset!");
static_assert(offsetof(WiggleMotionComponent_OnWiggleSkillCheckEnd, Success) == 0x000001, "Member 'WiggleMotionComponent_OnWiggleSkillCheckEnd::Success' has a wrong offset!");
static_assert(offsetof(WiggleMotionComponent_OnWiggleSkillCheckEnd, Bonus) == 0x000002, "Member 'WiggleMotionComponent_OnWiggleSkillCheckEnd::Bonus' has a wrong offset!");
static_assert(offsetof(WiggleMotionComponent_OnWiggleSkillCheckEnd, Type) == 0x000003, "Member 'WiggleMotionComponent_OnWiggleSkillCheckEnd::Type' has a wrong offset!");
static_assert(offsetof(WiggleMotionComponent_OnWiggleSkillCheckEnd, Player) == 0x000008, "Member 'WiggleMotionComponent_OnWiggleSkillCheckEnd::Player' has a wrong offset!");

// Function DBDGameplay.WiggleMotionComponent.Server_SetIsBeingWiggled
// 0x0001 (0x0001 - 0x0000)
struct WiggleMotionComponent_Server_SetIsBeingWiggled final
{
public:
	bool                                          isBeingWiggled;                                    // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleMotionComponent_Server_SetIsBeingWiggled) == 0x000001, "Wrong alignment on WiggleMotionComponent_Server_SetIsBeingWiggled");
static_assert(sizeof(WiggleMotionComponent_Server_SetIsBeingWiggled) == 0x000001, "Wrong size on WiggleMotionComponent_Server_SetIsBeingWiggled");
static_assert(offsetof(WiggleMotionComponent_Server_SetIsBeingWiggled, isBeingWiggled) == 0x000000, "Member 'WiggleMotionComponent_Server_SetIsBeingWiggled::isBeingWiggled' has a wrong offset!");

// Function DBDGameplay.WiggleMotionComponent.SetIsBeingWiggled
// 0x0001 (0x0001 - 0x0000)
struct WiggleMotionComponent_SetIsBeingWiggled final
{
public:
	bool                                          isBeingWiggled;                                    // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleMotionComponent_SetIsBeingWiggled) == 0x000001, "Wrong alignment on WiggleMotionComponent_SetIsBeingWiggled");
static_assert(sizeof(WiggleMotionComponent_SetIsBeingWiggled) == 0x000001, "Wrong size on WiggleMotionComponent_SetIsBeingWiggled");
static_assert(offsetof(WiggleMotionComponent_SetIsBeingWiggled, isBeingWiggled) == 0x000000, "Member 'WiggleMotionComponent_SetIsBeingWiggled::isBeingWiggled' has a wrong offset!");

// Function DBDGameplay.WormholeFatherDoorAnimInstance.OnStateChanged
// 0x0001 (0x0001 - 0x0000)
struct WormholeFatherDoorAnimInstance_OnStateChanged final
{
public:
	bool                                          HasBeenHacked;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WormholeFatherDoorAnimInstance_OnStateChanged) == 0x000001, "Wrong alignment on WormholeFatherDoorAnimInstance_OnStateChanged");
static_assert(sizeof(WormholeFatherDoorAnimInstance_OnStateChanged) == 0x000001, "Wrong size on WormholeFatherDoorAnimInstance_OnStateChanged");
static_assert(offsetof(WormholeFatherDoorAnimInstance_OnStateChanged, HasBeenHacked) == 0x000000, "Member 'WormholeFatherDoorAnimInstance_OnStateChanged::HasBeenHacked' has a wrong offset!");

// Function DBDGameplay.WormholeFatherHackableActor.OnHackedEvent
// 0x0040 (0x0040 - 0x0000)
struct WormholeFatherHackableActor_OnHackedEvent final
{
public:
	struct FGameplayTag                           GameEvent;                                         // 0x0000(0x000C)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameEventData                         GameEventData;                                     // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(WormholeFatherHackableActor_OnHackedEvent) == 0x000008, "Wrong alignment on WormholeFatherHackableActor_OnHackedEvent");
static_assert(sizeof(WormholeFatherHackableActor_OnHackedEvent) == 0x000040, "Wrong size on WormholeFatherHackableActor_OnHackedEvent");
static_assert(offsetof(WormholeFatherHackableActor_OnHackedEvent, GameEvent) == 0x000000, "Member 'WormholeFatherHackableActor_OnHackedEvent::GameEvent' has a wrong offset!");
static_assert(offsetof(WormholeFatherHackableActor_OnHackedEvent, GameEventData) == 0x000010, "Member 'WormholeFatherHackableActor_OnHackedEvent::GameEventData' has a wrong offset!");

// Function DBDGameplay.WormholeFatherHackingComponent.SetHasBeenHacked
// 0x0001 (0x0001 - 0x0000)
struct WormholeFatherHackingComponent_SetHasBeenHacked final
{
public:
	bool                                          HasBeenHacked;                                     // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WormholeFatherHackingComponent_SetHasBeenHacked) == 0x000001, "Wrong alignment on WormholeFatherHackingComponent_SetHasBeenHacked");
static_assert(sizeof(WormholeFatherHackingComponent_SetHasBeenHacked) == 0x000001, "Wrong size on WormholeFatherHackingComponent_SetHasBeenHacked");
static_assert(offsetof(WormholeFatherHackingComponent_SetHasBeenHacked, HasBeenHacked) == 0x000000, "Member 'WormholeFatherHackingComponent_SetHasBeenHacked::HasBeenHacked' has a wrong offset!");

// Function DBDGameplay.WormholeFatherHackingComponent.HasBeenHacked
// 0x0001 (0x0001 - 0x0000)
struct WormholeFatherHackingComponent_HasBeenHacked final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WormholeFatherHackingComponent_HasBeenHacked) == 0x000001, "Wrong alignment on WormholeFatherHackingComponent_HasBeenHacked");
static_assert(sizeof(WormholeFatherHackingComponent_HasBeenHacked) == 0x000001, "Wrong size on WormholeFatherHackingComponent_HasBeenHacked");
static_assert(offsetof(WormholeFatherHackingComponent_HasBeenHacked, ReturnValue) == 0x000000, "Member 'WormholeFatherHackingComponent_HasBeenHacked::ReturnValue' has a wrong offset!");

// Function DBDGameplay.WormholeFatherKeyCard.ApplyInitialTag
// 0x0008 (0x0008 - 0x0000)
struct WormholeFatherKeyCard_ApplyInitialTag final
{
public:
	class ADBDPlayer*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WormholeFatherKeyCard_ApplyInitialTag) == 0x000008, "Wrong alignment on WormholeFatherKeyCard_ApplyInitialTag");
static_assert(sizeof(WormholeFatherKeyCard_ApplyInitialTag) == 0x000008, "Wrong size on WormholeFatherKeyCard_ApplyInitialTag");
static_assert(offsetof(WormholeFatherKeyCard_ApplyInitialTag, Character) == 0x000000, "Member 'WormholeFatherKeyCard_ApplyInitialTag::Character' has a wrong offset!");

// Function DBDGameplay.WormholeFatherKeyCard.GetKeyCardState
// 0x0001 (0x0001 - 0x0000)
struct WormholeFatherKeyCard_GetKeyCardState final
{
public:
	EFatherKeyCardState                           ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WormholeFatherKeyCard_GetKeyCardState) == 0x000001, "Wrong alignment on WormholeFatherKeyCard_GetKeyCardState");
static_assert(sizeof(WormholeFatherKeyCard_GetKeyCardState) == 0x000001, "Wrong size on WormholeFatherKeyCard_GetKeyCardState");
static_assert(offsetof(WormholeFatherKeyCard_GetKeyCardState, ReturnValue) == 0x000000, "Member 'WormholeFatherKeyCard_GetKeyCardState::ReturnValue' has a wrong offset!");

// Function DBDGameplay.WormholeFatherKeyCard.RemoveInitialTag
// 0x0008 (0x0008 - 0x0000)
struct WormholeFatherKeyCard_RemoveInitialTag final
{
public:
	class ADBDPlayer*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WormholeFatherKeyCard_RemoveInitialTag) == 0x000008, "Wrong alignment on WormholeFatherKeyCard_RemoveInitialTag");
static_assert(sizeof(WormholeFatherKeyCard_RemoveInitialTag) == 0x000008, "Wrong size on WormholeFatherKeyCard_RemoveInitialTag");
static_assert(offsetof(WormholeFatherKeyCard_RemoveInitialTag, Character) == 0x000000, "Member 'WormholeFatherKeyCard_RemoveInitialTag::Character' has a wrong offset!");

// Function DBDGameplay.WormholeFatherRoomZoneOverlap.OnOverlapEnter
// 0x0110 (0x0110 - 0x0000)
struct WormholeFatherRoomZoneOverlap_OnOverlapEnter final
{
public:
	class UPrimitiveComponent*                    HitComponent;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F0)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(WormholeFatherRoomZoneOverlap_OnOverlapEnter) == 0x000008, "Wrong alignment on WormholeFatherRoomZoneOverlap_OnOverlapEnter");
static_assert(sizeof(WormholeFatherRoomZoneOverlap_OnOverlapEnter) == 0x000110, "Wrong size on WormholeFatherRoomZoneOverlap_OnOverlapEnter");
static_assert(offsetof(WormholeFatherRoomZoneOverlap_OnOverlapEnter, HitComponent) == 0x000000, "Member 'WormholeFatherRoomZoneOverlap_OnOverlapEnter::HitComponent' has a wrong offset!");
static_assert(offsetof(WormholeFatherRoomZoneOverlap_OnOverlapEnter, OtherActor) == 0x000008, "Member 'WormholeFatherRoomZoneOverlap_OnOverlapEnter::OtherActor' has a wrong offset!");
static_assert(offsetof(WormholeFatherRoomZoneOverlap_OnOverlapEnter, OtherComp) == 0x000010, "Member 'WormholeFatherRoomZoneOverlap_OnOverlapEnter::OtherComp' has a wrong offset!");
static_assert(offsetof(WormholeFatherRoomZoneOverlap_OnOverlapEnter, OtherBodyIndex) == 0x000018, "Member 'WormholeFatherRoomZoneOverlap_OnOverlapEnter::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(WormholeFatherRoomZoneOverlap_OnOverlapEnter, bFromSweep) == 0x00001C, "Member 'WormholeFatherRoomZoneOverlap_OnOverlapEnter::bFromSweep' has a wrong offset!");
static_assert(offsetof(WormholeFatherRoomZoneOverlap_OnOverlapEnter, SweepResult) == 0x000020, "Member 'WormholeFatherRoomZoneOverlap_OnOverlapEnter::SweepResult' has a wrong offset!");

// Function DBDGameplay.WormholeFatherRoomZoneOverlap.OnOverlapExit
// 0x0020 (0x0020 - 0x0000)
struct WormholeFatherRoomZoneOverlap_OnOverlapExit final
{
public:
	class UPrimitiveComponent*                    HitComponent;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(WormholeFatherRoomZoneOverlap_OnOverlapExit) == 0x000008, "Wrong alignment on WormholeFatherRoomZoneOverlap_OnOverlapExit");
static_assert(sizeof(WormholeFatherRoomZoneOverlap_OnOverlapExit) == 0x000020, "Wrong size on WormholeFatherRoomZoneOverlap_OnOverlapExit");
static_assert(offsetof(WormholeFatherRoomZoneOverlap_OnOverlapExit, HitComponent) == 0x000000, "Member 'WormholeFatherRoomZoneOverlap_OnOverlapExit::HitComponent' has a wrong offset!");
static_assert(offsetof(WormholeFatherRoomZoneOverlap_OnOverlapExit, OtherActor) == 0x000008, "Member 'WormholeFatherRoomZoneOverlap_OnOverlapExit::OtherActor' has a wrong offset!");
static_assert(offsetof(WormholeFatherRoomZoneOverlap_OnOverlapExit, OtherComp) == 0x000010, "Member 'WormholeFatherRoomZoneOverlap_OnOverlapExit::OtherComp' has a wrong offset!");
static_assert(offsetof(WormholeFatherRoomZoneOverlap_OnOverlapExit, OtherBodyIndex) == 0x000018, "Member 'WormholeFatherRoomZoneOverlap_OnOverlapExit::OtherBodyIndex' has a wrong offset!");

}

