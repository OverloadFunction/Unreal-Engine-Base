#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DBDInput

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"
#include "Engine_classes.hpp"
#include "DBDSharedTypes_structs.hpp"
#include "DBDInput_structs.hpp"


namespace SDK
{

// Class DBDInput.ControlModeManager
// 0x0060 (0x0090 - 0x0030)
class UControlModeManager final : public UObject
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameInstance*                          _gameInstance;                                     // 0x0080(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControlModeManager">();
	}
	static class UControlModeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UControlModeManager>();
	}
};
static_assert(alignof(UControlModeManager) == 0x000008, "Wrong alignment on UControlModeManager");
static_assert(sizeof(UControlModeManager) == 0x000090, "Wrong size on UControlModeManager");
static_assert(offsetof(UControlModeManager, _gameInstance) == 0x000080, "Member 'UControlModeManager::_gameInstance' has a wrong offset!");

// Class DBDInput.DBDInputManager
// 0x0140 (0x0178 - 0x0038)
class UDBDInputManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UControlModeManager*                    _controlModeManager;                               // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USwitchDockStateManager*                _switchDockStateManager;                           // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVirtualKeyboardManager*                _virtualKeyboardManager;                           // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             _analogCursorDb;                                   // 0x0070(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x100];                                     // 0x0078(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddPresenterRootWidget(class UUserWidget* presenterRootWidget);
	void RemovePresenterRootWidget(const class UUserWidget* presenterRootWidget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDInputManager">();
	}
	static class UDBDInputManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDInputManager>();
	}
};
static_assert(alignof(UDBDInputManager) == 0x000008, "Wrong alignment on UDBDInputManager");
static_assert(sizeof(UDBDInputManager) == 0x000178, "Wrong size on UDBDInputManager");
static_assert(offsetof(UDBDInputManager, _controlModeManager) == 0x000058, "Member 'UDBDInputManager::_controlModeManager' has a wrong offset!");
static_assert(offsetof(UDBDInputManager, _switchDockStateManager) == 0x000060, "Member 'UDBDInputManager::_switchDockStateManager' has a wrong offset!");
static_assert(offsetof(UDBDInputManager, _virtualKeyboardManager) == 0x000068, "Member 'UDBDInputManager::_virtualKeyboardManager' has a wrong offset!");
static_assert(offsetof(UDBDInputManager, _analogCursorDb) == 0x000070, "Member 'UDBDInputManager::_analogCursorDb' has a wrong offset!");

// Class DBDInput.InteractiveWidgetInterface
// 0x0000 (0x0000 - 0x0000)
class IInteractiveWidgetInterface final
{
public:
	void HandleAnalogInputEvent(const struct FAnalogInputEvent& InAnalogInputEvent);
	void HandleKeyDownEvent(const struct FKeyEvent& InKeyEvent);
	void HandleKeyHoldEvent(const struct FKeyEvent& InKeyEvent);
	void HandleKeyUpEvent(const struct FKeyEvent& InKeyEvent);
	void HandleOnMouseDownEvent(const struct FPointerEvent& InMouseEvent);
	void HandleOnMouseWheelEvent(const struct FPointerEvent& InMouseEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractiveWidgetInterface">();
	}
	static class IInteractiveWidgetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInteractiveWidgetInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IInteractiveWidgetInterface) == 0x000001, "Wrong alignment on IInteractiveWidgetInterface");
static_assert(sizeof(IInteractiveWidgetInterface) == 0x000001, "Wrong size on IInteractiveWidgetInterface");

// Class DBDInput.MultipleGamepadsControlModeInfo
// 0x0018 (0x0050 - 0x0038)
class UMultipleGamepadsControlModeInfo final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MultipleGamepadsControlModeInfo">();
	}
	static class UMultipleGamepadsControlModeInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMultipleGamepadsControlModeInfo>();
	}
};
static_assert(alignof(UMultipleGamepadsControlModeInfo) == 0x000008, "Wrong alignment on UMultipleGamepadsControlModeInfo");
static_assert(sizeof(UMultipleGamepadsControlModeInfo) == 0x000050, "Wrong size on UMultipleGamepadsControlModeInfo");

// Class DBDInput.SwitchDockStateManager
// 0x0020 (0x0050 - 0x0030)
class USwitchDockStateManager final : public UObject
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwitchDockStateManager">();
	}
	static class USwitchDockStateManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USwitchDockStateManager>();
	}
};
static_assert(alignof(USwitchDockStateManager) == 0x000008, "Wrong alignment on USwitchDockStateManager");
static_assert(sizeof(USwitchDockStateManager) == 0x000050, "Wrong size on USwitchDockStateManager");

// Class DBDInput.UIInputUtilities
// 0x0000 (0x0030 - 0x0030)
class UUIInputUtilities final : public UBlueprintFunctionLibrary
{
public:
	static bool AreGamepadButtonsXOSwitched();
	static struct FKey GetKeyFromUIAction(const EUIActionType ActionType, bool isUsingGamepad);
	static bool IsInputKeyControlModePairValid(const struct FKey& InputKey, EControlMode controlMode);
	static bool ShouldUseAtlantaControls(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIInputUtilities">();
	}
	static class UUIInputUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIInputUtilities>();
	}
};
static_assert(alignof(UUIInputUtilities) == 0x000008, "Wrong alignment on UUIInputUtilities");
static_assert(sizeof(UUIInputUtilities) == 0x000030, "Wrong size on UUIInputUtilities");

// Class DBDInput.VirtualKeyboardManager
// 0x0028 (0x0058 - 0x0030)
class UVirtualKeyboardManager final : public UObject
{
public:
	class UVirtualKeyboard*                       _virtualKeyboard;                                  // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VirtualKeyboardManager">();
	}
	static class UVirtualKeyboardManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVirtualKeyboardManager>();
	}
};
static_assert(alignof(UVirtualKeyboardManager) == 0x000008, "Wrong alignment on UVirtualKeyboardManager");
static_assert(sizeof(UVirtualKeyboardManager) == 0x000058, "Wrong size on UVirtualKeyboardManager");
static_assert(offsetof(UVirtualKeyboardManager, _virtualKeyboard) == 0x000030, "Member 'UVirtualKeyboardManager::_virtualKeyboard' has a wrong offset!");

}

