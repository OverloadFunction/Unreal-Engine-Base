#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheNightmare

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "GameplayTagUtilities_structs.hpp"
#include "Engine_classes.hpp"
#include "DBDInteraction_classes.hpp"
#include "DataTableUtilities_structs.hpp"
#include "DBDCompetence_classes.hpp"
#include "StatSystem_structs.hpp"
#include "DBDGameplay_classes.hpp"
#include "DBDAnimation_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "DBDSharedTypes_structs.hpp"
#include "DBDCosmetic_classes.hpp"
#include "SystemUtilities_structs.hpp"


namespace SDK
{

// Class TheNightmare.CharacterDreamworldComponent
// 0x00F8 (0x01B0 - 0x00B8)
class UCharacterDreamworldComponent : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(bool IsInDreamworld, bool locallyObservedChanged)> DreamStateChanged; // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     _mobileDreamworldPostProcessClass;                 // 0x00C8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAmbianceManagerDataAsset*              _dreamWorldAmbiance;                               // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTagStateBool                          _isInDreamworld;                                   // 0x00D8(0x0048)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x48];                                     // 0x0120(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class APostProcessUpdate*                     _mobileDreamworldPostProcess;                      // 0x0168(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_170[0x40];                                     // 0x0170(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ADBDPlayer* GetLocallyObservedOrLocalCharacter(class UObject* WorldContextObject);

	void Authority_SetIsInDreamworld(bool NewValue, bool isScripted);
	void FireWakeUpScoreEvent(class ADBDPlayer* Instigator);
	void OnRep_IsInDreamworld();

	bool IsInDreamworld() const;
	bool ShouldShowVignette() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterDreamworldComponent">();
	}
	static class UCharacterDreamworldComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterDreamworldComponent>();
	}
};
static_assert(alignof(UCharacterDreamworldComponent) == 0x000008, "Wrong alignment on UCharacterDreamworldComponent");
static_assert(sizeof(UCharacterDreamworldComponent) == 0x0001B0, "Wrong size on UCharacterDreamworldComponent");
static_assert(offsetof(UCharacterDreamworldComponent, DreamStateChanged) == 0x0000B8, "Member 'UCharacterDreamworldComponent::DreamStateChanged' has a wrong offset!");
static_assert(offsetof(UCharacterDreamworldComponent, _mobileDreamworldPostProcessClass) == 0x0000C8, "Member 'UCharacterDreamworldComponent::_mobileDreamworldPostProcessClass' has a wrong offset!");
static_assert(offsetof(UCharacterDreamworldComponent, _dreamWorldAmbiance) == 0x0000D0, "Member 'UCharacterDreamworldComponent::_dreamWorldAmbiance' has a wrong offset!");
static_assert(offsetof(UCharacterDreamworldComponent, _isInDreamworld) == 0x0000D8, "Member 'UCharacterDreamworldComponent::_isInDreamworld' has a wrong offset!");
static_assert(offsetof(UCharacterDreamworldComponent, _mobileDreamworldPostProcess) == 0x000168, "Member 'UCharacterDreamworldComponent::_mobileDreamworldPostProcess' has a wrong offset!");

// Class TheNightmare.SurvivorDreamworldComponent
// 0x0320 (0x04D0 - 0x01B0)
class USurvivorDreamworldComponent final : public UCharacterDreamworldComponent
{
public:
	uint8                                         Pad_1B0[0x20];                                     // 0x01B0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class AKiller*                                _linkedKiller;                                     // 0x01D0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _survivorDreamWorldStatusEffect;                   // 0x01D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSurvivorSleepiness                    _survivorSleepiness;                               // 0x01E0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, Transient, NoDestructor, NativeAccessSpecifierPrivate)
	class UTimerObject*                           _sleepinessProtectionTimer;                        // 0x01E8(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _sleepGainPerSecondStat;                           // 0x01F0(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _clockSleepinessProtectionStat;                    // 0x0270(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _sleepThresholdStat;                               // 0x02F0(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FGameplayTagQuery                      _inHealActionInDreamworldQuery;                    // 0x0370(0x0048)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          _isImmuneFromSleepiness;                           // 0x03B8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _showKiller;                                       // 0x03B9(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3BA[0x6];                                      // 0x03BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFastTimer                             _killerGlimpseDurationTimer;                       // 0x03C0(0x0030)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F0[0x10];                                     // 0x03F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFastTimer                             _killerGlimpseCooldownTimer;                       // 0x0400(0x0030)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_430[0x10];                                     // 0x0430(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _glimpseMinDistance;                               // 0x0440(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _glimpseMaxDistance;                               // 0x0444(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _killerGlimpseCooldown;                            // 0x0448(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _killerGlimpseDuration;                            // 0x044C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _useScriptedKillerVisibility;                      // 0x0450(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_451[0x7];                                      // 0x0451(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _showKillerInstantly;                              // 0x0458(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_459[0x77];                                     // 0x0459(0x0077)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_HandleSkillCheckFailure(bool wakeUpEveryoneInteracting, class ADBDPlayer* Instigator);
	void Authority_OnAttacked();
	void Authority_OnHealthStateChanged(EHealthState oldHealthState, EHealthState newHealthState);
	void Authority_PutAsleep();
	void Authority_WakeUpByHookOrDying();
	void Authority_WakeUpByOther(class ADBDPlayer* Instigator);
	void Authority_WakeUpByWakerObject();
	void HandleShowKillerChanged(bool showKiller, bool instantly);
	void InitializeTunableValues(class AKiller* Killer);
	void Local_SetShowKiller(bool showKiller, bool instantly);
	void OnRep_ShowKiller();
	void SetScriptedKillerVisibility(bool useScriptedKillerVisibility);

	class AKiller* GetLinkedKiller() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorDreamworldComponent">();
	}
	static class USurvivorDreamworldComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorDreamworldComponent>();
	}
};
static_assert(alignof(USurvivorDreamworldComponent) == 0x000008, "Wrong alignment on USurvivorDreamworldComponent");
static_assert(sizeof(USurvivorDreamworldComponent) == 0x0004D0, "Wrong size on USurvivorDreamworldComponent");
static_assert(offsetof(USurvivorDreamworldComponent, _linkedKiller) == 0x0001D0, "Member 'USurvivorDreamworldComponent::_linkedKiller' has a wrong offset!");
static_assert(offsetof(USurvivorDreamworldComponent, _survivorDreamWorldStatusEffect) == 0x0001D8, "Member 'USurvivorDreamworldComponent::_survivorDreamWorldStatusEffect' has a wrong offset!");
static_assert(offsetof(USurvivorDreamworldComponent, _survivorSleepiness) == 0x0001E0, "Member 'USurvivorDreamworldComponent::_survivorSleepiness' has a wrong offset!");
static_assert(offsetof(USurvivorDreamworldComponent, _sleepinessProtectionTimer) == 0x0001E8, "Member 'USurvivorDreamworldComponent::_sleepinessProtectionTimer' has a wrong offset!");
static_assert(offsetof(USurvivorDreamworldComponent, _sleepGainPerSecondStat) == 0x0001F0, "Member 'USurvivorDreamworldComponent::_sleepGainPerSecondStat' has a wrong offset!");
static_assert(offsetof(USurvivorDreamworldComponent, _clockSleepinessProtectionStat) == 0x000270, "Member 'USurvivorDreamworldComponent::_clockSleepinessProtectionStat' has a wrong offset!");
static_assert(offsetof(USurvivorDreamworldComponent, _sleepThresholdStat) == 0x0002F0, "Member 'USurvivorDreamworldComponent::_sleepThresholdStat' has a wrong offset!");
static_assert(offsetof(USurvivorDreamworldComponent, _inHealActionInDreamworldQuery) == 0x000370, "Member 'USurvivorDreamworldComponent::_inHealActionInDreamworldQuery' has a wrong offset!");
static_assert(offsetof(USurvivorDreamworldComponent, _isImmuneFromSleepiness) == 0x0003B8, "Member 'USurvivorDreamworldComponent::_isImmuneFromSleepiness' has a wrong offset!");
static_assert(offsetof(USurvivorDreamworldComponent, _showKiller) == 0x0003B9, "Member 'USurvivorDreamworldComponent::_showKiller' has a wrong offset!");
static_assert(offsetof(USurvivorDreamworldComponent, _killerGlimpseDurationTimer) == 0x0003C0, "Member 'USurvivorDreamworldComponent::_killerGlimpseDurationTimer' has a wrong offset!");
static_assert(offsetof(USurvivorDreamworldComponent, _killerGlimpseCooldownTimer) == 0x000400, "Member 'USurvivorDreamworldComponent::_killerGlimpseCooldownTimer' has a wrong offset!");
static_assert(offsetof(USurvivorDreamworldComponent, _glimpseMinDistance) == 0x000440, "Member 'USurvivorDreamworldComponent::_glimpseMinDistance' has a wrong offset!");
static_assert(offsetof(USurvivorDreamworldComponent, _glimpseMaxDistance) == 0x000444, "Member 'USurvivorDreamworldComponent::_glimpseMaxDistance' has a wrong offset!");
static_assert(offsetof(USurvivorDreamworldComponent, _killerGlimpseCooldown) == 0x000448, "Member 'USurvivorDreamworldComponent::_killerGlimpseCooldown' has a wrong offset!");
static_assert(offsetof(USurvivorDreamworldComponent, _killerGlimpseDuration) == 0x00044C, "Member 'USurvivorDreamworldComponent::_killerGlimpseDuration' has a wrong offset!");
static_assert(offsetof(USurvivorDreamworldComponent, _useScriptedKillerVisibility) == 0x000450, "Member 'USurvivorDreamworldComponent::_useScriptedKillerVisibility' has a wrong offset!");
static_assert(offsetof(USurvivorDreamworldComponent, _showKillerInstantly) == 0x000458, "Member 'USurvivorDreamworldComponent::_showKillerInstantly' has a wrong offset!");

// Class TheNightmare.Addon_DreamInducer_ClassPhoto
// 0x0030 (0x0330 - 0x0300)
class UAddon_DreamInducer_ClassPhoto final : public UItemAddon
{
public:
	TSubclassOf<class UTargetableComponent>       _teleportEscapeDoorTargetClass;                    // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _teleportLocationFinderOffset;                     // 0x0308(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_320[0x10];                                     // 0x0320(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_DreamInducer_ClassPhoto">();
	}
	static class UAddon_DreamInducer_ClassPhoto* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_DreamInducer_ClassPhoto>();
	}
};
static_assert(alignof(UAddon_DreamInducer_ClassPhoto) == 0x000008, "Wrong alignment on UAddon_DreamInducer_ClassPhoto");
static_assert(sizeof(UAddon_DreamInducer_ClassPhoto) == 0x000330, "Wrong size on UAddon_DreamInducer_ClassPhoto");
static_assert(offsetof(UAddon_DreamInducer_ClassPhoto, _teleportEscapeDoorTargetClass) == 0x000300, "Member 'UAddon_DreamInducer_ClassPhoto::_teleportEscapeDoorTargetClass' has a wrong offset!");
static_assert(offsetof(UAddon_DreamInducer_ClassPhoto, _teleportLocationFinderOffset) == 0x000308, "Member 'UAddon_DreamInducer_ClassPhoto::_teleportLocationFinderOffset' has a wrong offset!");

// Class TheNightmare.DreamInducerComponent
// 0x0008 (0x00C0 - 0x00B8)
class UDreamInducerComponent final : public UActorComponent
{
public:
	TSubclassOf<class UActorComponent>            _generatorDreamworldClass;                         // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DreamInducerComponent">();
	}
	static class UDreamInducerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDreamInducerComponent>();
	}
};
static_assert(alignof(UDreamInducerComponent) == 0x000008, "Wrong alignment on UDreamInducerComponent");
static_assert(sizeof(UDreamInducerComponent) == 0x0000C0, "Wrong size on UDreamInducerComponent");
static_assert(offsetof(UDreamInducerComponent, _generatorDreamworldClass) == 0x0000B8, "Member 'UDreamInducerComponent::_generatorDreamworldClass' has a wrong offset!");

// Class TheNightmare.TheNightmareUtilities
// 0x0000 (0x0030 - 0x0030)
class UTheNightmareUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TheNightmareUtilities">();
	}
	static class UTheNightmareUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTheNightmareUtilities>();
	}
};
static_assert(alignof(UTheNightmareUtilities) == 0x000008, "Wrong alignment on UTheNightmareUtilities");
static_assert(sizeof(UTheNightmareUtilities) == 0x000030, "Wrong size on UTheNightmareUtilities");

// Class TheNightmare.Addon_DreamInducer_NancysMasterpiece
// 0x0038 (0x0338 - 0x0300)
class UAddon_DreamInducer_NancysMasterpiece final : public UItemAddon
{
public:
	uint8                                         Pad_300[0x10];                                     // 0x0300(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _cooldownReductionPercent;                         // 0x0310(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_DreamInducer_NancysMasterpiece">();
	}
	static class UAddon_DreamInducer_NancysMasterpiece* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_DreamInducer_NancysMasterpiece>();
	}
};
static_assert(alignof(UAddon_DreamInducer_NancysMasterpiece) == 0x000008, "Wrong alignment on UAddon_DreamInducer_NancysMasterpiece");
static_assert(sizeof(UAddon_DreamInducer_NancysMasterpiece) == 0x000338, "Wrong size on UAddon_DreamInducer_NancysMasterpiece");
static_assert(offsetof(UAddon_DreamInducer_NancysMasterpiece, _cooldownReductionPercent) == 0x000310, "Member 'UAddon_DreamInducer_NancysMasterpiece::_cooldownReductionPercent' has a wrong offset!");

// Class TheNightmare.WakerObject
// 0x00F0 (0x0498 - 0x03A8)
class AWakerObject final : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          _wakerObjectInteractionZone;                       // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractor*                            _wakerObjectInteractor;                            // 0x03B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UEscapeDreamInteraction>    _escapeDreamInteractionClass;                      // 0x03C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _cooldownDurationStat;                             // 0x03C8(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UEscapeDreamInteraction*                _escapeDreamInteraction;                           // 0x0448(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTimerObject*                           _cooldownTimer;                                    // 0x0450(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_458[0x40];                                     // 0x0458(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_CooldownTimeElapsed(float timeElapsedPercent);
	void Cosmetic_InteractionCancelled();
	void Cosmetic_OnCooldownFinished();
	void Cosmetic_OnCooldownStarted();
	void Cosmetic_UpdateVisibility(const class ADBDPlayer* locallyObservedPlayer, bool IsInDreamworld);
	void OnInteractionEntered(class ADBDPlayer* Player);
	void OnRep_CooldownTimer();
	void OnRep_EscapeDreamInteraction();

	bool GetChargeComplete() const;
	float GetInteractionPercentComplete() const;
	class UPrimitiveComponent* GetInteractorPrimitiveComponent() const;
	bool GetIsInteracting() const;
	class USkeletalMeshComponent* GetMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WakerObject">();
	}
	static class AWakerObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWakerObject>();
	}
};
static_assert(alignof(AWakerObject) == 0x000008, "Wrong alignment on AWakerObject");
static_assert(sizeof(AWakerObject) == 0x000498, "Wrong size on AWakerObject");
static_assert(offsetof(AWakerObject, _wakerObjectInteractionZone) == 0x0003B0, "Member 'AWakerObject::_wakerObjectInteractionZone' has a wrong offset!");
static_assert(offsetof(AWakerObject, _wakerObjectInteractor) == 0x0003B8, "Member 'AWakerObject::_wakerObjectInteractor' has a wrong offset!");
static_assert(offsetof(AWakerObject, _escapeDreamInteractionClass) == 0x0003C0, "Member 'AWakerObject::_escapeDreamInteractionClass' has a wrong offset!");
static_assert(offsetof(AWakerObject, _cooldownDurationStat) == 0x0003C8, "Member 'AWakerObject::_cooldownDurationStat' has a wrong offset!");
static_assert(offsetof(AWakerObject, _escapeDreamInteraction) == 0x000448, "Member 'AWakerObject::_escapeDreamInteraction' has a wrong offset!");
static_assert(offsetof(AWakerObject, _cooldownTimer) == 0x000450, "Member 'AWakerObject::_cooldownTimer' has a wrong offset!");

// Class TheNightmare.Addon_DreamInducer_SwingChains
// 0x0008 (0x0318 - 0x0310)
class UAddon_DreamInducer_SwingChains final : public UOnEventBaseAddon
{
public:
	float                                         _blockRange;                                       // 0x0310(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _blockDuration;                                    // 0x0314(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_DreamInducer_SwingChains">();
	}
	static class UAddon_DreamInducer_SwingChains* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_DreamInducer_SwingChains>();
	}
};
static_assert(alignof(UAddon_DreamInducer_SwingChains) == 0x000008, "Wrong alignment on UAddon_DreamInducer_SwingChains");
static_assert(sizeof(UAddon_DreamInducer_SwingChains) == 0x000318, "Wrong size on UAddon_DreamInducer_SwingChains");
static_assert(offsetof(UAddon_DreamInducer_SwingChains, _blockRange) == 0x000310, "Member 'UAddon_DreamInducer_SwingChains::_blockRange' has a wrong offset!");
static_assert(offsetof(UAddon_DreamInducer_SwingChains, _blockDuration) == 0x000314, "Member 'UAddon_DreamInducer_SwingChains::_blockDuration' has a wrong offset!");

// Class TheNightmare.WakerObjectAnimInstance
// 0x0040 (0x0390 - 0x0350)
class UWakerObjectAnimInstance final : public UAnimInstance
{
public:
	float                                         _reappearTimerCooldown;                            // 0x0350(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _wakeUpCharge;                                     // 0x0354(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _chargeStarted;                                    // 0x0358(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _interactionComplete;                              // 0x0359(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _outEnd;                                           // 0x035A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _reset;                                            // 0x035B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _inEnd;                                            // 0x035C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _wakerObjectStarted;                               // 0x035D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _respawnEnd;                                       // 0x035E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _cancelEnd;                                        // 0x035F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_360[0x30];                                     // 0x0360(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnReappear();
	void ResetReappearTimer();

	class AWakerObject* GetWakerObject() const;
	float GetWakerObjectCharge() const;
	bool GetWakerObjectChargeComplete() const;
	bool GetWakerObjectStarted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WakerObjectAnimInstance">();
	}
	static class UWakerObjectAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWakerObjectAnimInstance>();
	}
};
static_assert(alignof(UWakerObjectAnimInstance) == 0x000010, "Wrong alignment on UWakerObjectAnimInstance");
static_assert(sizeof(UWakerObjectAnimInstance) == 0x000390, "Wrong size on UWakerObjectAnimInstance");
static_assert(offsetof(UWakerObjectAnimInstance, _reappearTimerCooldown) == 0x000350, "Member 'UWakerObjectAnimInstance::_reappearTimerCooldown' has a wrong offset!");
static_assert(offsetof(UWakerObjectAnimInstance, _wakeUpCharge) == 0x000354, "Member 'UWakerObjectAnimInstance::_wakeUpCharge' has a wrong offset!");
static_assert(offsetof(UWakerObjectAnimInstance, _chargeStarted) == 0x000358, "Member 'UWakerObjectAnimInstance::_chargeStarted' has a wrong offset!");
static_assert(offsetof(UWakerObjectAnimInstance, _interactionComplete) == 0x000359, "Member 'UWakerObjectAnimInstance::_interactionComplete' has a wrong offset!");
static_assert(offsetof(UWakerObjectAnimInstance, _outEnd) == 0x00035A, "Member 'UWakerObjectAnimInstance::_outEnd' has a wrong offset!");
static_assert(offsetof(UWakerObjectAnimInstance, _reset) == 0x00035B, "Member 'UWakerObjectAnimInstance::_reset' has a wrong offset!");
static_assert(offsetof(UWakerObjectAnimInstance, _inEnd) == 0x00035C, "Member 'UWakerObjectAnimInstance::_inEnd' has a wrong offset!");
static_assert(offsetof(UWakerObjectAnimInstance, _wakerObjectStarted) == 0x00035D, "Member 'UWakerObjectAnimInstance::_wakerObjectStarted' has a wrong offset!");
static_assert(offsetof(UWakerObjectAnimInstance, _respawnEnd) == 0x00035E, "Member 'UWakerObjectAnimInstance::_respawnEnd' has a wrong offset!");
static_assert(offsetof(UWakerObjectAnimInstance, _cancelEnd) == 0x00035F, "Member 'UWakerObjectAnimInstance::_cancelEnd' has a wrong offset!");

// Class TheNightmare.AimDreamPalletInteraction
// 0x0080 (0x09A0 - 0x0920)
class UAimDreamPalletInteraction final : public UBasicChargeableInteraction
{
public:
	uint8                                         Pad_920[0x80];                                     // 0x0920(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimDreamPalletInteraction">();
	}
	static class UAimDreamPalletInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimDreamPalletInteraction>();
	}
};
static_assert(alignof(UAimDreamPalletInteraction) == 0x000010, "Wrong alignment on UAimDreamPalletInteraction");
static_assert(sizeof(UAimDreamPalletInteraction) == 0x0009A0, "Wrong size on UAimDreamPalletInteraction");

// Class TheNightmare.BlackBoxSingleGateBlockerStatusEffect
// 0x0048 (0x0470 - 0x0428)
class UBlackBoxSingleGateBlockerStatusEffect final : public USingleGateBlockerEffect
{
public:
	uint8                                         Pad_428[0x48];                                     // 0x0428(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlackBoxSingleGateBlockerStatusEffect">();
	}
	static class UBlackBoxSingleGateBlockerStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlackBoxSingleGateBlockerStatusEffect>();
	}
};
static_assert(alignof(UBlackBoxSingleGateBlockerStatusEffect) == 0x000008, "Wrong alignment on UBlackBoxSingleGateBlockerStatusEffect");
static_assert(sizeof(UBlackBoxSingleGateBlockerStatusEffect) == 0x000470, "Wrong size on UBlackBoxSingleGateBlockerStatusEffect");

// Class TheNightmare.BloodWarden
// 0x0070 (0x04D0 - 0x0460)
class UBloodWarden final : public UPerk
{
public:
	uint8                                         Pad_460[0x50];                                     // 0x0460(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _bloodWardenBlockerStatusEffectClass;              // 0x04B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _revealPlayerStatusEffectClass;                    // 0x04B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _perkLevelSpikeDurations[0x3];                     // 0x04C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4CC[0x4];                                      // 0x04CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetPerkLevelSpikeDurationsAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodWarden">();
	}
	static class UBloodWarden* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodWarden>();
	}
};
static_assert(alignof(UBloodWarden) == 0x000008, "Wrong alignment on UBloodWarden");
static_assert(sizeof(UBloodWarden) == 0x0004D0, "Wrong size on UBloodWarden");
static_assert(offsetof(UBloodWarden, _bloodWardenBlockerStatusEffectClass) == 0x0004B0, "Member 'UBloodWarden::_bloodWardenBlockerStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UBloodWarden, _revealPlayerStatusEffectClass) == 0x0004B8, "Member 'UBloodWarden::_revealPlayerStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UBloodWarden, _perkLevelSpikeDurations) == 0x0004C0, "Member 'UBloodWarden::_perkLevelSpikeDurations' has a wrong offset!");

// Class TheNightmare.DreamPalletAbility
// 0x0298 (0x0478 - 0x01E0)
class UDreamPalletAbility final : public UKillerAbilityComponent
{
public:
	TSubclassOf<class UAimDreamPalletInteraction> _aimDreamPalletInteractionClass;                   // 0x01E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAimDreamPalletInteraction*             _aimDreamPalletInteraction;                        // 0x01E8(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UPlaceDreamPalletInteraction> _placeDreamPalletInteractionClass;               // 0x01F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlaceDreamPalletInteraction*           _placeDreamPalletInteraction;                      // 0x01F8(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UExplodeDreamPalletInteraction> _explodeDreamPalletInteractionClass;           // 0x0200(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UExplodeDreamPalletInteraction*         _explodeDreamPalletInteraction;                    // 0x0208(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UTargetableComponent>       _dreamPalletTargetClass;                           // 0x0210(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UTargetingComponent>        _dreamPalletTargetingComponentClass;               // 0x0218(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UPalletTrackerVisibilityComponent> _visibilityComponentClass;                  // 0x0220(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTargetingComponent*                    _dreamPalletTargetingComponent;                    // 0x0228(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UTargetableComponent*>           _palletTargets;                                    // 0x0230(0x0010)(ExportObject, Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class APalletTracker*>                 _palletTrackers;                                   // 0x0240(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class APallet*>                        _activeDreamPallets;                               // 0x0250(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FNonTunableStat                        _explosionDelayStat;                               // 0x0260(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FNonTunableStat                        _explosionRadiusStat;                              // 0x02C0(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class APalletTracker*                         _lockedTargetTracker;                              // 0x0320(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_328[0x150];                                    // 0x0328(0x0150)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_Authority_RecycleDreamPallet(class APallet* Pallet);
	void OnRep_PalletTargets();
	void OnRep_PalletTrackers();
	void Server_SetTarget(class UTargetableComponent* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DreamPalletAbility">();
	}
	static class UDreamPalletAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDreamPalletAbility>();
	}
};
static_assert(alignof(UDreamPalletAbility) == 0x000008, "Wrong alignment on UDreamPalletAbility");
static_assert(sizeof(UDreamPalletAbility) == 0x000478, "Wrong size on UDreamPalletAbility");
static_assert(offsetof(UDreamPalletAbility, _aimDreamPalletInteractionClass) == 0x0001E0, "Member 'UDreamPalletAbility::_aimDreamPalletInteractionClass' has a wrong offset!");
static_assert(offsetof(UDreamPalletAbility, _aimDreamPalletInteraction) == 0x0001E8, "Member 'UDreamPalletAbility::_aimDreamPalletInteraction' has a wrong offset!");
static_assert(offsetof(UDreamPalletAbility, _placeDreamPalletInteractionClass) == 0x0001F0, "Member 'UDreamPalletAbility::_placeDreamPalletInteractionClass' has a wrong offset!");
static_assert(offsetof(UDreamPalletAbility, _placeDreamPalletInteraction) == 0x0001F8, "Member 'UDreamPalletAbility::_placeDreamPalletInteraction' has a wrong offset!");
static_assert(offsetof(UDreamPalletAbility, _explodeDreamPalletInteractionClass) == 0x000200, "Member 'UDreamPalletAbility::_explodeDreamPalletInteractionClass' has a wrong offset!");
static_assert(offsetof(UDreamPalletAbility, _explodeDreamPalletInteraction) == 0x000208, "Member 'UDreamPalletAbility::_explodeDreamPalletInteraction' has a wrong offset!");
static_assert(offsetof(UDreamPalletAbility, _dreamPalletTargetClass) == 0x000210, "Member 'UDreamPalletAbility::_dreamPalletTargetClass' has a wrong offset!");
static_assert(offsetof(UDreamPalletAbility, _dreamPalletTargetingComponentClass) == 0x000218, "Member 'UDreamPalletAbility::_dreamPalletTargetingComponentClass' has a wrong offset!");
static_assert(offsetof(UDreamPalletAbility, _visibilityComponentClass) == 0x000220, "Member 'UDreamPalletAbility::_visibilityComponentClass' has a wrong offset!");
static_assert(offsetof(UDreamPalletAbility, _dreamPalletTargetingComponent) == 0x000228, "Member 'UDreamPalletAbility::_dreamPalletTargetingComponent' has a wrong offset!");
static_assert(offsetof(UDreamPalletAbility, _palletTargets) == 0x000230, "Member 'UDreamPalletAbility::_palletTargets' has a wrong offset!");
static_assert(offsetof(UDreamPalletAbility, _palletTrackers) == 0x000240, "Member 'UDreamPalletAbility::_palletTrackers' has a wrong offset!");
static_assert(offsetof(UDreamPalletAbility, _activeDreamPallets) == 0x000250, "Member 'UDreamPalletAbility::_activeDreamPallets' has a wrong offset!");
static_assert(offsetof(UDreamPalletAbility, _explosionDelayStat) == 0x000260, "Member 'UDreamPalletAbility::_explosionDelayStat' has a wrong offset!");
static_assert(offsetof(UDreamPalletAbility, _explosionRadiusStat) == 0x0002C0, "Member 'UDreamPalletAbility::_explosionRadiusStat' has a wrong offset!");
static_assert(offsetof(UDreamPalletAbility, _lockedTargetTracker) == 0x000320, "Member 'UDreamPalletAbility::_lockedTargetTracker' has a wrong offset!");

// Class TheNightmare.DreamPalletAbilityData
// 0x0020 (0x0090 - 0x0070)
class UDreamPalletAbilityData final : public UKillerAbilityData
{
public:
	float                                         _maxTargetingDistance;                             // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _explosionDelay;                                   // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _explosionRadius;                                  // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _explosionHalfHeight;                              // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _palletMeshCenterOffset;                           // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sleepinessAddedByExplosion;                       // 0x0084(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _chargeTime;                                       // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetExplosionRadius() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DreamPalletAbilityData">();
	}
	static class UDreamPalletAbilityData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDreamPalletAbilityData>();
	}
};
static_assert(alignof(UDreamPalletAbilityData) == 0x000008, "Wrong alignment on UDreamPalletAbilityData");
static_assert(sizeof(UDreamPalletAbilityData) == 0x000090, "Wrong size on UDreamPalletAbilityData");
static_assert(offsetof(UDreamPalletAbilityData, _maxTargetingDistance) == 0x000070, "Member 'UDreamPalletAbilityData::_maxTargetingDistance' has a wrong offset!");
static_assert(offsetof(UDreamPalletAbilityData, _explosionDelay) == 0x000074, "Member 'UDreamPalletAbilityData::_explosionDelay' has a wrong offset!");
static_assert(offsetof(UDreamPalletAbilityData, _explosionRadius) == 0x000078, "Member 'UDreamPalletAbilityData::_explosionRadius' has a wrong offset!");
static_assert(offsetof(UDreamPalletAbilityData, _explosionHalfHeight) == 0x00007C, "Member 'UDreamPalletAbilityData::_explosionHalfHeight' has a wrong offset!");
static_assert(offsetof(UDreamPalletAbilityData, _palletMeshCenterOffset) == 0x000080, "Member 'UDreamPalletAbilityData::_palletMeshCenterOffset' has a wrong offset!");
static_assert(offsetof(UDreamPalletAbilityData, _sleepinessAddedByExplosion) == 0x000084, "Member 'UDreamPalletAbilityData::_sleepinessAddedByExplosion' has a wrong offset!");
static_assert(offsetof(UDreamPalletAbilityData, _chargeTime) == 0x000088, "Member 'UDreamPalletAbilityData::_chargeTime' has a wrong offset!");

// Class TheNightmare.DreamPalletAnimInstance
// 0x0010 (0x03A0 - 0x0390)
class UDreamPalletAnimInstance final : public UPalletAnimInstance
{
public:
	bool                                          _isExploding;                                      // 0x0388(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_389[0x17];                                     // 0x0389(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DreamPalletAnimInstance">();
	}
	static class UDreamPalletAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDreamPalletAnimInstance>();
	}
};
static_assert(alignof(UDreamPalletAnimInstance) == 0x000010, "Wrong alignment on UDreamPalletAnimInstance");
static_assert(sizeof(UDreamPalletAnimInstance) == 0x0003A0, "Wrong size on UDreamPalletAnimInstance");
static_assert(offsetof(UDreamPalletAnimInstance, _isExploding) == 0x000388, "Member 'UDreamPalletAnimInstance::_isExploding' has a wrong offset!");

// Class TheNightmare.DreamPalletCosmeticComponent
// 0x0058 (0x0110 - 0x00B8)
class UDreamPalletCosmeticComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _maxCosmeticVisibilityDistance;                    // 0x00C0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x28];                                      // 0x00E8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_UpdateSurvivorDistanceToPallet(float Distance);

	float GetMaxCosmeticVisibilityDistance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DreamPalletCosmeticComponent">();
	}
	static class UDreamPalletCosmeticComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDreamPalletCosmeticComponent>();
	}
};
static_assert(alignof(UDreamPalletCosmeticComponent) == 0x000008, "Wrong alignment on UDreamPalletCosmeticComponent");
static_assert(sizeof(UDreamPalletCosmeticComponent) == 0x000110, "Wrong size on UDreamPalletCosmeticComponent");
static_assert(offsetof(UDreamPalletCosmeticComponent, _maxCosmeticVisibilityDistance) == 0x0000C0, "Member 'UDreamPalletCosmeticComponent::_maxCosmeticVisibilityDistance' has a wrong offset!");

// Class TheNightmare.DreamPalletTargetableStrategy
// 0x0008 (0x0050 - 0x0048)
class UDreamPalletTargetableStrategy final : public UTargetableStrategy
{
public:
	float                                         _targetPointVerticalOffset;                        // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DreamPalletTargetableStrategy">();
	}
	static class UDreamPalletTargetableStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDreamPalletTargetableStrategy>();
	}
};
static_assert(alignof(UDreamPalletTargetableStrategy) == 0x000008, "Wrong alignment on UDreamPalletTargetableStrategy");
static_assert(sizeof(UDreamPalletTargetableStrategy) == 0x000050, "Wrong size on UDreamPalletTargetableStrategy");
static_assert(offsetof(UDreamPalletTargetableStrategy, _targetPointVerticalOffset) == 0x000048, "Member 'UDreamPalletTargetableStrategy::_targetPointVerticalOffset' has a wrong offset!");

// Class TheNightmare.DreamProjectionAbility
// 0x01E8 (0x03C8 - 0x01E0)
class UDreamProjectionAbility final : public UKillerAbilityComponent
{
public:
	uint8                                         Pad_1E0[0xC0];                                     // 0x01E0(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagQuery                      _canTargetQuery;                                   // 0x02A0(0x0048)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSubclassOf<class UDreamProjectionInteractionDefinition> _teleportInteractionClass;              // 0x02E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDreamProjectionInteractionDefinition*  _teleportInteraction;                              // 0x02F0(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UDreamProjectionSurvivorTarget> _teleportSurvivorTargetClass;                  // 0x02F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UDreamProjectionGeneratorTarget> _teleportGeneratorTargetClass;                // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UTargetingComponent>        _teleportTargetingComponentClass;                  // 0x0308(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _dreamProjectionKillerInstinctStatusEffectClass;   // 0x0310(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTargetingComponent*                    _teleportTargetingComponent;                       // 0x0318(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UDreamProjectionPositionFinderComponent> _teleportPositionFinderClass;         // 0x0320(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDreamProjectionPositionFinderComponent* _teleportPositionFinder;                          // 0x0328(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UTargetableComponent*>           _teleportTargets;                                  // 0x0330(0x0010)(ExportObject, Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_340[0x88];                                     // 0x0340(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_TeleportTargets();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DreamProjectionAbility">();
	}
	static class UDreamProjectionAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDreamProjectionAbility>();
	}
};
static_assert(alignof(UDreamProjectionAbility) == 0x000008, "Wrong alignment on UDreamProjectionAbility");
static_assert(sizeof(UDreamProjectionAbility) == 0x0003C8, "Wrong size on UDreamProjectionAbility");
static_assert(offsetof(UDreamProjectionAbility, _canTargetQuery) == 0x0002A0, "Member 'UDreamProjectionAbility::_canTargetQuery' has a wrong offset!");
static_assert(offsetof(UDreamProjectionAbility, _teleportInteractionClass) == 0x0002E8, "Member 'UDreamProjectionAbility::_teleportInteractionClass' has a wrong offset!");
static_assert(offsetof(UDreamProjectionAbility, _teleportInteraction) == 0x0002F0, "Member 'UDreamProjectionAbility::_teleportInteraction' has a wrong offset!");
static_assert(offsetof(UDreamProjectionAbility, _teleportSurvivorTargetClass) == 0x0002F8, "Member 'UDreamProjectionAbility::_teleportSurvivorTargetClass' has a wrong offset!");
static_assert(offsetof(UDreamProjectionAbility, _teleportGeneratorTargetClass) == 0x000300, "Member 'UDreamProjectionAbility::_teleportGeneratorTargetClass' has a wrong offset!");
static_assert(offsetof(UDreamProjectionAbility, _teleportTargetingComponentClass) == 0x000308, "Member 'UDreamProjectionAbility::_teleportTargetingComponentClass' has a wrong offset!");
static_assert(offsetof(UDreamProjectionAbility, _dreamProjectionKillerInstinctStatusEffectClass) == 0x000310, "Member 'UDreamProjectionAbility::_dreamProjectionKillerInstinctStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UDreamProjectionAbility, _teleportTargetingComponent) == 0x000318, "Member 'UDreamProjectionAbility::_teleportTargetingComponent' has a wrong offset!");
static_assert(offsetof(UDreamProjectionAbility, _teleportPositionFinderClass) == 0x000320, "Member 'UDreamProjectionAbility::_teleportPositionFinderClass' has a wrong offset!");
static_assert(offsetof(UDreamProjectionAbility, _teleportPositionFinder) == 0x000328, "Member 'UDreamProjectionAbility::_teleportPositionFinder' has a wrong offset!");
static_assert(offsetof(UDreamProjectionAbility, _teleportTargets) == 0x000330, "Member 'UDreamProjectionAbility::_teleportTargets' has a wrong offset!");

// Class TheNightmare.DreamProjectionAbilityData
// 0x0020 (0x0090 - 0x0070)
class UDreamProjectionAbilityData final : public UKillerAbilityData
{
public:
	float                                         _cancelCooldown;                                   // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _failedCooldown;                                   // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _percentCooldownReductionPerSleepingSurvivor;      // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _chargeTime;                                       // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _killerInstinctLingerDuration;                     // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _effectRadius;                                     // 0x0084(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sleepinessAdded;                                  // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DreamProjectionAbilityData">();
	}
	static class UDreamProjectionAbilityData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDreamProjectionAbilityData>();
	}
};
static_assert(alignof(UDreamProjectionAbilityData) == 0x000008, "Wrong alignment on UDreamProjectionAbilityData");
static_assert(sizeof(UDreamProjectionAbilityData) == 0x000090, "Wrong size on UDreamProjectionAbilityData");
static_assert(offsetof(UDreamProjectionAbilityData, _cancelCooldown) == 0x000070, "Member 'UDreamProjectionAbilityData::_cancelCooldown' has a wrong offset!");
static_assert(offsetof(UDreamProjectionAbilityData, _failedCooldown) == 0x000074, "Member 'UDreamProjectionAbilityData::_failedCooldown' has a wrong offset!");
static_assert(offsetof(UDreamProjectionAbilityData, _percentCooldownReductionPerSleepingSurvivor) == 0x000078, "Member 'UDreamProjectionAbilityData::_percentCooldownReductionPerSleepingSurvivor' has a wrong offset!");
static_assert(offsetof(UDreamProjectionAbilityData, _chargeTime) == 0x00007C, "Member 'UDreamProjectionAbilityData::_chargeTime' has a wrong offset!");
static_assert(offsetof(UDreamProjectionAbilityData, _killerInstinctLingerDuration) == 0x000080, "Member 'UDreamProjectionAbilityData::_killerInstinctLingerDuration' has a wrong offset!");
static_assert(offsetof(UDreamProjectionAbilityData, _effectRadius) == 0x000084, "Member 'UDreamProjectionAbilityData::_effectRadius' has a wrong offset!");
static_assert(offsetof(UDreamProjectionAbilityData, _sleepinessAdded) == 0x000088, "Member 'UDreamProjectionAbilityData::_sleepinessAdded' has a wrong offset!");

// Class TheNightmare.DreamProjectionEscapeDoorTarget
// 0x0010 (0x0380 - 0x0370)
class UDreamProjectionEscapeDoorTarget final : public UTargetableComponent
{
public:
	uint8                                         Pad_368[0x18];                                     // 0x0368(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DreamProjectionEscapeDoorTarget">();
	}
	static class UDreamProjectionEscapeDoorTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDreamProjectionEscapeDoorTarget>();
	}
};
static_assert(alignof(UDreamProjectionEscapeDoorTarget) == 0x000010, "Wrong alignment on UDreamProjectionEscapeDoorTarget");
static_assert(sizeof(UDreamProjectionEscapeDoorTarget) == 0x000380, "Wrong size on UDreamProjectionEscapeDoorTarget");

// Class TheNightmare.DreamProjectionGeneratorTargetableStrategy
// 0x0000 (0x0048 - 0x0048)
class UDreamProjectionGeneratorTargetableStrategy final : public UTargetableStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DreamProjectionGeneratorTargetableStrategy">();
	}
	static class UDreamProjectionGeneratorTargetableStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDreamProjectionGeneratorTargetableStrategy>();
	}
};
static_assert(alignof(UDreamProjectionGeneratorTargetableStrategy) == 0x000008, "Wrong alignment on UDreamProjectionGeneratorTargetableStrategy");
static_assert(sizeof(UDreamProjectionGeneratorTargetableStrategy) == 0x000048, "Wrong size on UDreamProjectionGeneratorTargetableStrategy");

// Class TheNightmare.DreamProjectionGeneratorTarget
// 0x0000 (0x0370 - 0x0370)
class UDreamProjectionGeneratorTarget final : public UTargetableComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DreamProjectionGeneratorTarget">();
	}
	static class UDreamProjectionGeneratorTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDreamProjectionGeneratorTarget>();
	}
};
static_assert(alignof(UDreamProjectionGeneratorTarget) == 0x000010, "Wrong alignment on UDreamProjectionGeneratorTarget");
static_assert(sizeof(UDreamProjectionGeneratorTarget) == 0x000370, "Wrong size on UDreamProjectionGeneratorTarget");

// Class TheNightmare.DreamProjectionInteractionDefinition
// 0x00E0 (0x0A70 - 0x0990)
class UDreamProjectionInteractionDefinition final : public UTapOrChargeChargeableInteraction
{
public:
	float                                         OnBloodSpurtsAINoiseEventRange;                    // 0x0988(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_98C[0x3C];                                     // 0x098C(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	class UTargetableComponent*                   _teleportTarget;                                   // 0x09C8(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTransform                             _selectedTeleportLocation;                         // 0x09D0(0x0060)(BlueprintVisible, Net, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isInteractionOngoing;                             // 0x0A30(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _teleportFailed;                                   // 0x0A31(0x0001)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A32[0x2];                                      // 0x0A32(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _bloodSpurtInterval;                               // 0x0A34(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _collisionCheckCapsuleHalfHeight;                  // 0x0A38(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _collisionCheckCapsuleRadius;                      // 0x0A3C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _collisionCheckLocationOffset;                     // 0x0A40(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _capsuleTraceAngleIncrement;                       // 0x0A58(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _downRaycastLength;                                // 0x0A5C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A60[0x10];                                     // 0x0A60(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnTeleportChargeStarted(class ADBDPlayer* Player);
	void Cosmetic_OnTeleported(const struct FTransform& transformBeforeTeleport, const struct FVector& teleportLocation);
	void Cosmetic_OnTeleportLocationChosen(const struct FTransform& Location, const class ASurvivor* TargetSurvivor);
	void Cosmetic_ShowBloodSpurts(const class AGenerator* targetGenerator);
	void Multicast_OnTeleportLocationChosen(const struct FTransform& Location, const class AActor* TargetActor);
	void Multicast_TeleportPlayer(const struct FVector& Location, const struct FRotator& Rotation);
	void OnBloodSpurts(const class AGenerator* targetGenerator);
	void OnRep_TeleportTarget();
	void Server_SetTeleportTarget(class UTargetableComponent* Target);

	class ADBDPlayer* GetOwningPlayer() const;
	bool HasTeleportFailed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DreamProjectionInteractionDefinition">();
	}
	static class UDreamProjectionInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDreamProjectionInteractionDefinition>();
	}
};
static_assert(alignof(UDreamProjectionInteractionDefinition) == 0x000010, "Wrong alignment on UDreamProjectionInteractionDefinition");
static_assert(sizeof(UDreamProjectionInteractionDefinition) == 0x000A70, "Wrong size on UDreamProjectionInteractionDefinition");
static_assert(offsetof(UDreamProjectionInteractionDefinition, OnBloodSpurtsAINoiseEventRange) == 0x000988, "Member 'UDreamProjectionInteractionDefinition::OnBloodSpurtsAINoiseEventRange' has a wrong offset!");
static_assert(offsetof(UDreamProjectionInteractionDefinition, _teleportTarget) == 0x0009C8, "Member 'UDreamProjectionInteractionDefinition::_teleportTarget' has a wrong offset!");
static_assert(offsetof(UDreamProjectionInteractionDefinition, _selectedTeleportLocation) == 0x0009D0, "Member 'UDreamProjectionInteractionDefinition::_selectedTeleportLocation' has a wrong offset!");
static_assert(offsetof(UDreamProjectionInteractionDefinition, _isInteractionOngoing) == 0x000A30, "Member 'UDreamProjectionInteractionDefinition::_isInteractionOngoing' has a wrong offset!");
static_assert(offsetof(UDreamProjectionInteractionDefinition, _teleportFailed) == 0x000A31, "Member 'UDreamProjectionInteractionDefinition::_teleportFailed' has a wrong offset!");
static_assert(offsetof(UDreamProjectionInteractionDefinition, _bloodSpurtInterval) == 0x000A34, "Member 'UDreamProjectionInteractionDefinition::_bloodSpurtInterval' has a wrong offset!");
static_assert(offsetof(UDreamProjectionInteractionDefinition, _collisionCheckCapsuleHalfHeight) == 0x000A38, "Member 'UDreamProjectionInteractionDefinition::_collisionCheckCapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(UDreamProjectionInteractionDefinition, _collisionCheckCapsuleRadius) == 0x000A3C, "Member 'UDreamProjectionInteractionDefinition::_collisionCheckCapsuleRadius' has a wrong offset!");
static_assert(offsetof(UDreamProjectionInteractionDefinition, _collisionCheckLocationOffset) == 0x000A40, "Member 'UDreamProjectionInteractionDefinition::_collisionCheckLocationOffset' has a wrong offset!");
static_assert(offsetof(UDreamProjectionInteractionDefinition, _capsuleTraceAngleIncrement) == 0x000A58, "Member 'UDreamProjectionInteractionDefinition::_capsuleTraceAngleIncrement' has a wrong offset!");
static_assert(offsetof(UDreamProjectionInteractionDefinition, _downRaycastLength) == 0x000A5C, "Member 'UDreamProjectionInteractionDefinition::_downRaycastLength' has a wrong offset!");

// Class TheNightmare.DreamProjectionPositionFinderComponent
// 0x0098 (0x0260 - 0x01C8)
class UDreamProjectionPositionFinderComponent final : public USurvivorTeleportationPositionFinderComponent
{
public:
	struct FGameplayTagQuery                      _canBeTeleportedToQuery;                           // 0x01C8(0x0048)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_210[0x50];                                     // 0x0210(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DreamProjectionPositionFinderComponent">();
	}
	static class UDreamProjectionPositionFinderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDreamProjectionPositionFinderComponent>();
	}
};
static_assert(alignof(UDreamProjectionPositionFinderComponent) == 0x000008, "Wrong alignment on UDreamProjectionPositionFinderComponent");
static_assert(sizeof(UDreamProjectionPositionFinderComponent) == 0x000260, "Wrong size on UDreamProjectionPositionFinderComponent");
static_assert(offsetof(UDreamProjectionPositionFinderComponent, _canBeTeleportedToQuery) == 0x0001C8, "Member 'UDreamProjectionPositionFinderComponent::_canBeTeleportedToQuery' has a wrong offset!");

// Class TheNightmare.DreamProjectionSurvivorTargetableStrategy
// 0x0048 (0x0090 - 0x0048)
class UDreamProjectionSurvivorTargetableStrategy final : public UTargetableStrategy
{
public:
	struct FGameplayTagQuery                      _canBeTargetedTagQuery;                            // 0x0048(0x0048)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DreamProjectionSurvivorTargetableStrategy">();
	}
	static class UDreamProjectionSurvivorTargetableStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDreamProjectionSurvivorTargetableStrategy>();
	}
};
static_assert(alignof(UDreamProjectionSurvivorTargetableStrategy) == 0x000008, "Wrong alignment on UDreamProjectionSurvivorTargetableStrategy");
static_assert(sizeof(UDreamProjectionSurvivorTargetableStrategy) == 0x000090, "Wrong size on UDreamProjectionSurvivorTargetableStrategy");
static_assert(offsetof(UDreamProjectionSurvivorTargetableStrategy, _canBeTargetedTagQuery) == 0x000048, "Member 'UDreamProjectionSurvivorTargetableStrategy::_canBeTargetedTagQuery' has a wrong offset!");

// Class TheNightmare.DreamProjectionSurvivorTarget
// 0x0000 (0x0370 - 0x0370)
class UDreamProjectionSurvivorTarget final : public UTargetableComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DreamProjectionSurvivorTarget">();
	}
	static class UDreamProjectionSurvivorTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDreamProjectionSurvivorTarget>();
	}
};
static_assert(alignof(UDreamProjectionSurvivorTarget) == 0x000010, "Wrong alignment on UDreamProjectionSurvivorTarget");
static_assert(sizeof(UDreamProjectionSurvivorTarget) == 0x000370, "Wrong size on UDreamProjectionSurvivorTarget");

// Class TheNightmare.DreamSnare
// 0x00E0 (0x0380 - 0x02A0)
class ADreamSnare final : public AActor
{
public:
	class UAuthoritativePoolableActorComponent*   _authoritativePoolableActorComponent;              // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isActive;                                         // 0x02A8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isStatic;                                         // 0x02A9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2AA[0x6];                                      // 0x02AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       _dreamSnareCollision;                              // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UDreamSnareAbility>      _linkedAbility;                                    // 0x02B8(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _startPosition;                                    // 0x02C0(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _velocity;                                         // 0x02D8(0x0018)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _slopeDetectionOverGroundVector;                   // 0x02F0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _slopeDetectionEndVector;                          // 0x0308(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _rotationInterpSpeed;                              // 0x0320(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _maxGroundCheckTry;                                // 0x0324(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_328[0x58];                                     // 0x0328(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnAcquiredChanged(const bool acquired);
	void Cosmetic_DespawnSnare();
	void Cosmetic_OnSurvivorTriggerDreamTrap(class ASurvivor* Survivor);
	void Cosmetic_SnareInitialized();
	void Cosmetic_SpawnSnare();
	void InitializeSnare();
	void Multicast_OnSnareTriggered(class ASurvivor* survivorTriggering);
	void OnRep_IsActive();
	void OnRep_Velocity();

	bool IsSnareStatic() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DreamSnare">();
	}
	static class ADreamSnare* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADreamSnare>();
	}
};
static_assert(alignof(ADreamSnare) == 0x000008, "Wrong alignment on ADreamSnare");
static_assert(sizeof(ADreamSnare) == 0x000380, "Wrong size on ADreamSnare");
static_assert(offsetof(ADreamSnare, _authoritativePoolableActorComponent) == 0x0002A0, "Member 'ADreamSnare::_authoritativePoolableActorComponent' has a wrong offset!");
static_assert(offsetof(ADreamSnare, _isActive) == 0x0002A8, "Member 'ADreamSnare::_isActive' has a wrong offset!");
static_assert(offsetof(ADreamSnare, _isStatic) == 0x0002A9, "Member 'ADreamSnare::_isStatic' has a wrong offset!");
static_assert(offsetof(ADreamSnare, _dreamSnareCollision) == 0x0002B0, "Member 'ADreamSnare::_dreamSnareCollision' has a wrong offset!");
static_assert(offsetof(ADreamSnare, _linkedAbility) == 0x0002B8, "Member 'ADreamSnare::_linkedAbility' has a wrong offset!");
static_assert(offsetof(ADreamSnare, _startPosition) == 0x0002C0, "Member 'ADreamSnare::_startPosition' has a wrong offset!");
static_assert(offsetof(ADreamSnare, _velocity) == 0x0002D8, "Member 'ADreamSnare::_velocity' has a wrong offset!");
static_assert(offsetof(ADreamSnare, _slopeDetectionOverGroundVector) == 0x0002F0, "Member 'ADreamSnare::_slopeDetectionOverGroundVector' has a wrong offset!");
static_assert(offsetof(ADreamSnare, _slopeDetectionEndVector) == 0x000308, "Member 'ADreamSnare::_slopeDetectionEndVector' has a wrong offset!");
static_assert(offsetof(ADreamSnare, _rotationInterpSpeed) == 0x000320, "Member 'ADreamSnare::_rotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(ADreamSnare, _maxGroundCheckTry) == 0x000324, "Member 'ADreamSnare::_maxGroundCheckTry' has a wrong offset!");

// Class TheNightmare.DreamSnareAbility
// 0x01D8 (0x03B8 - 0x01E0)
class UDreamSnareAbility final : public UKillerAbilityComponent
{
public:
	class UAuthoritativeActorPoolComponent*       _dreamSnarePool;                                   // 0x01E0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _dreamSnareStatusEffectClass;                      // 0x01E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class USetDreamSnareInteraction>  _setDreamSnareInteractionClass;                    // 0x01F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class USpawnDreamSnareInteraction> _spawnDreamSnareInteractionClass;                 // 0x01F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ADreamSnare>                _dreamSnareClass;                                  // 0x0200(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USetDreamSnareInteraction*              _setDreamSnareInteraction;                         // 0x0208(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpawnDreamSnareInteraction*            _spawnDreamSnareInteraction;                       // 0x0210(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _navmeshBoxSizeForDreamSnareMovement;              // 0x0218(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _navmeshMaxHeightDifference;                       // 0x021C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _collisionCheckRadius;                             // 0x0220(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_224[0x194];                                    // 0x0224(0x0194)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DreamSnareAbility">();
	}
	static class UDreamSnareAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDreamSnareAbility>();
	}
};
static_assert(alignof(UDreamSnareAbility) == 0x000008, "Wrong alignment on UDreamSnareAbility");
static_assert(sizeof(UDreamSnareAbility) == 0x0003B8, "Wrong size on UDreamSnareAbility");
static_assert(offsetof(UDreamSnareAbility, _dreamSnarePool) == 0x0001E0, "Member 'UDreamSnareAbility::_dreamSnarePool' has a wrong offset!");
static_assert(offsetof(UDreamSnareAbility, _dreamSnareStatusEffectClass) == 0x0001E8, "Member 'UDreamSnareAbility::_dreamSnareStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UDreamSnareAbility, _setDreamSnareInteractionClass) == 0x0001F0, "Member 'UDreamSnareAbility::_setDreamSnareInteractionClass' has a wrong offset!");
static_assert(offsetof(UDreamSnareAbility, _spawnDreamSnareInteractionClass) == 0x0001F8, "Member 'UDreamSnareAbility::_spawnDreamSnareInteractionClass' has a wrong offset!");
static_assert(offsetof(UDreamSnareAbility, _dreamSnareClass) == 0x000200, "Member 'UDreamSnareAbility::_dreamSnareClass' has a wrong offset!");
static_assert(offsetof(UDreamSnareAbility, _setDreamSnareInteraction) == 0x000208, "Member 'UDreamSnareAbility::_setDreamSnareInteraction' has a wrong offset!");
static_assert(offsetof(UDreamSnareAbility, _spawnDreamSnareInteraction) == 0x000210, "Member 'UDreamSnareAbility::_spawnDreamSnareInteraction' has a wrong offset!");
static_assert(offsetof(UDreamSnareAbility, _navmeshBoxSizeForDreamSnareMovement) == 0x000218, "Member 'UDreamSnareAbility::_navmeshBoxSizeForDreamSnareMovement' has a wrong offset!");
static_assert(offsetof(UDreamSnareAbility, _navmeshMaxHeightDifference) == 0x00021C, "Member 'UDreamSnareAbility::_navmeshMaxHeightDifference' has a wrong offset!");
static_assert(offsetof(UDreamSnareAbility, _collisionCheckRadius) == 0x000220, "Member 'UDreamSnareAbility::_collisionCheckRadius' has a wrong offset!");

// Class TheNightmare.DreamSnareAbilityData
// 0x0028 (0x0098 - 0x0070)
class UDreamSnareAbilityData final : public UKillerAbilityData
{
public:
	float                                         _chargeTime;                                       // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _launchSpeed;                                      // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _range;                                            // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxHeightDifference;                              // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _snareSpawnForwardOffset;                          // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _groundCheckRaycastHeight;                         // 0x0084(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sleepinessAdded;                                  // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _hinderedStrength;                                 // 0x008C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _hinderedDuration;                                 // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DreamSnareAbilityData">();
	}
	static class UDreamSnareAbilityData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDreamSnareAbilityData>();
	}
};
static_assert(alignof(UDreamSnareAbilityData) == 0x000008, "Wrong alignment on UDreamSnareAbilityData");
static_assert(sizeof(UDreamSnareAbilityData) == 0x000098, "Wrong size on UDreamSnareAbilityData");
static_assert(offsetof(UDreamSnareAbilityData, _chargeTime) == 0x000070, "Member 'UDreamSnareAbilityData::_chargeTime' has a wrong offset!");
static_assert(offsetof(UDreamSnareAbilityData, _launchSpeed) == 0x000074, "Member 'UDreamSnareAbilityData::_launchSpeed' has a wrong offset!");
static_assert(offsetof(UDreamSnareAbilityData, _range) == 0x000078, "Member 'UDreamSnareAbilityData::_range' has a wrong offset!");
static_assert(offsetof(UDreamSnareAbilityData, _maxHeightDifference) == 0x00007C, "Member 'UDreamSnareAbilityData::_maxHeightDifference' has a wrong offset!");
static_assert(offsetof(UDreamSnareAbilityData, _snareSpawnForwardOffset) == 0x000080, "Member 'UDreamSnareAbilityData::_snareSpawnForwardOffset' has a wrong offset!");
static_assert(offsetof(UDreamSnareAbilityData, _groundCheckRaycastHeight) == 0x000084, "Member 'UDreamSnareAbilityData::_groundCheckRaycastHeight' has a wrong offset!");
static_assert(offsetof(UDreamSnareAbilityData, _sleepinessAdded) == 0x000088, "Member 'UDreamSnareAbilityData::_sleepinessAdded' has a wrong offset!");
static_assert(offsetof(UDreamSnareAbilityData, _hinderedStrength) == 0x00008C, "Member 'UDreamSnareAbilityData::_hinderedStrength' has a wrong offset!");
static_assert(offsetof(UDreamSnareAbilityData, _hinderedDuration) == 0x000090, "Member 'UDreamSnareAbilityData::_hinderedDuration' has a wrong offset!");

// Class TheNightmare.DreamSnareOutlineUpdateStrategy
// 0x0000 (0x0100 - 0x0100)
class UDreamSnareOutlineUpdateStrategy final : public UDefaultOutlineUpdateStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DreamSnareOutlineUpdateStrategy">();
	}
	static class UDreamSnareOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDreamSnareOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UDreamSnareOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UDreamSnareOutlineUpdateStrategy");
static_assert(sizeof(UDreamSnareOutlineUpdateStrategy) == 0x000100, "Wrong size on UDreamSnareOutlineUpdateStrategy");

// Class TheNightmare.DreamSnarePlacerComponent
// 0x0010 (0x0350 - 0x0340)
class UDreamSnarePlacerComponent final : public UObjectPlacerComponent
{
public:
	float                                         _minPitch;                                         // 0x0338(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minPlacementDistance;                             // 0x033C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxPlacementDistance;                             // 0x0340(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_344[0xC];                                      // 0x0344(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_ActivateSnarePlacement(bool Activate_0);
	void Cosmetic_UpdateSnareIndicator(const struct FTransform& NewTransform);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DreamSnarePlacerComponent">();
	}
	static class UDreamSnarePlacerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDreamSnarePlacerComponent>();
	}
};
static_assert(alignof(UDreamSnarePlacerComponent) == 0x000010, "Wrong alignment on UDreamSnarePlacerComponent");
static_assert(sizeof(UDreamSnarePlacerComponent) == 0x000350, "Wrong size on UDreamSnarePlacerComponent");
static_assert(offsetof(UDreamSnarePlacerComponent, _minPitch) == 0x000338, "Member 'UDreamSnarePlacerComponent::_minPitch' has a wrong offset!");
static_assert(offsetof(UDreamSnarePlacerComponent, _minPlacementDistance) == 0x00033C, "Member 'UDreamSnarePlacerComponent::_minPlacementDistance' has a wrong offset!");
static_assert(offsetof(UDreamSnarePlacerComponent, _maxPlacementDistance) == 0x000340, "Member 'UDreamSnarePlacerComponent::_maxPlacementDistance' has a wrong offset!");

// Class TheNightmare.DreamSnareTrapPlacementValidationStrategy
// 0x0010 (0x0120 - 0x0110)
class UDreamSnareTrapPlacementValidationStrategy final : public UDefaultObjectPlacementValidationStrategy
{
public:
	float                                         _numberOfGroundTest;                               // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _trapRadius;                                       // 0x0114(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxElevationDifferentialOnTrapEdge;               // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DreamSnareTrapPlacementValidationStrategy">();
	}
	static class UDreamSnareTrapPlacementValidationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDreamSnareTrapPlacementValidationStrategy>();
	}
};
static_assert(alignof(UDreamSnareTrapPlacementValidationStrategy) == 0x000008, "Wrong alignment on UDreamSnareTrapPlacementValidationStrategy");
static_assert(sizeof(UDreamSnareTrapPlacementValidationStrategy) == 0x000120, "Wrong size on UDreamSnareTrapPlacementValidationStrategy");
static_assert(offsetof(UDreamSnareTrapPlacementValidationStrategy, _numberOfGroundTest) == 0x000110, "Member 'UDreamSnareTrapPlacementValidationStrategy::_numberOfGroundTest' has a wrong offset!");
static_assert(offsetof(UDreamSnareTrapPlacementValidationStrategy, _trapRadius) == 0x000114, "Member 'UDreamSnareTrapPlacementValidationStrategy::_trapRadius' has a wrong offset!");
static_assert(offsetof(UDreamSnareTrapPlacementValidationStrategy, _maxElevationDifferentialOnTrapEdge) == 0x000118, "Member 'UDreamSnareTrapPlacementValidationStrategy::_maxElevationDifferentialOnTrapEdge' has a wrong offset!");

// Class TheNightmare.DreamworldOnlyComponent
// 0x0010 (0x02E0 - 0x02D0)
class UDreamworldOnlyComponent final : public USceneComponent
{
public:
	uint8                                         Pad_2D0[0x10];                                     // 0x02D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DreamworldOnlyComponent">();
	}
	static class UDreamworldOnlyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDreamworldOnlyComponent>();
	}
};
static_assert(alignof(UDreamworldOnlyComponent) == 0x000010, "Wrong alignment on UDreamworldOnlyComponent");
static_assert(sizeof(UDreamworldOnlyComponent) == 0x0002E0, "Wrong size on UDreamworldOnlyComponent");

// Class TheNightmare.EscapeDreamInteraction
// 0x0000 (0x0920 - 0x0920)
class UEscapeDreamInteraction final : public UBasicChargeableInteraction
{
public:
	class AWakerObject* GetOwningWakerObject() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EscapeDreamInteraction">();
	}
	static class UEscapeDreamInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEscapeDreamInteraction>();
	}
};
static_assert(alignof(UEscapeDreamInteraction) == 0x000010, "Wrong alignment on UEscapeDreamInteraction");
static_assert(sizeof(UEscapeDreamInteraction) == 0x000920, "Wrong size on UEscapeDreamInteraction");

// Class TheNightmare.ExplodeDreamPalletInteraction
// 0x0010 (0x0780 - 0x0770)
class UExplodeDreamPalletInteraction final : public UInteractionDefinition
{
public:
	class UTimerObject*                           _explosionTimer;                                   // 0x0768(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_770[0x10];                                     // 0x0770(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_BeginExplodeDreamPallet(class APallet* Pallet, const float explosionRadius);
	void Cosmetic_CancelExplosion();
	void Cosmetic_ExplodeDreamPallet(class APallet* Pallet);
	void OnRep_ExplosionTimer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExplodeDreamPalletInteraction">();
	}
	static class UExplodeDreamPalletInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExplodeDreamPalletInteraction>();
	}
};
static_assert(alignof(UExplodeDreamPalletInteraction) == 0x000010, "Wrong alignment on UExplodeDreamPalletInteraction");
static_assert(sizeof(UExplodeDreamPalletInteraction) == 0x000780, "Wrong size on UExplodeDreamPalletInteraction");
static_assert(offsetof(UExplodeDreamPalletInteraction, _explosionTimer) == 0x000768, "Member 'UExplodeDreamPalletInteraction::_explosionTimer' has a wrong offset!");

// Class TheNightmare.FireUp
// 0x0028 (0x0488 - 0x0460)
class UFireUp final : public UPerk
{
public:
	uint8                                         Pad_460[0x10];                                     // 0x0460(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _speedBonuses[0x3];                                // 0x0470(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_47C[0xC];                                      // 0x047C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetSpeedBonusAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FireUp">();
	}
	static class UFireUp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFireUp>();
	}
};
static_assert(alignof(UFireUp) == 0x000008, "Wrong alignment on UFireUp");
static_assert(sizeof(UFireUp) == 0x000488, "Wrong size on UFireUp");
static_assert(offsetof(UFireUp, _speedBonuses) == 0x000470, "Member 'UFireUp::_speedBonuses' has a wrong offset!");

// Class TheNightmare.GeneratorDreamworldComponent
// 0x0018 (0x00D0 - 0x00B8)
class UGeneratorDreamworldComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           _beamSocketsForBloodEffect;                        // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void Cosmetic_OnPlayerFailSkillCheck(class ADBDPlayer* Player);
	void Cosmetic_SpawnBloodOnGenerator(class AGenerator* Generator, const TArray<class FName>& socketNames);
	void OnRepairSkillCheckFailed(bool Success, bool Bonus, class ADBDPlayer* Player, bool TriggerLoudNoise, bool hadInput, ESkillCheckCustomType Type, float ChargeChange);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratorDreamworldComponent">();
	}
	static class UGeneratorDreamworldComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneratorDreamworldComponent>();
	}
};
static_assert(alignof(UGeneratorDreamworldComponent) == 0x000008, "Wrong alignment on UGeneratorDreamworldComponent");
static_assert(sizeof(UGeneratorDreamworldComponent) == 0x0000D0, "Wrong size on UGeneratorDreamworldComponent");
static_assert(offsetof(UGeneratorDreamworldComponent, _beamSocketsForBloodEffect) == 0x0000C0, "Member 'UGeneratorDreamworldComponent::_beamSocketsForBloodEffect' has a wrong offset!");

// Class TheNightmare.InDreamSurvivorSubAnimInstance
// 0x0030 (0x0610 - 0x05E0)
class UInDreamSurvivorSubAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	uint8                                         Pad_5E0[0x8];                                      // 0x05E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _shouldLookSleepy;                                 // 0x05E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrawling;                                       // 0x05E9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingCarried;                                   // 0x05EA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDead;                                           // 0x05EB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHooked;                                         // 0x05EC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrouched;                                       // 0x05ED(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIdle;                                           // 0x05EE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5EF[0x1];                                      // 0x05EF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _walkAnimSpeed;                                    // 0x05F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F4[0x1C];                                     // 0x05F4(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InDreamSurvivorSubAnimInstance">();
	}
	static class UInDreamSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInDreamSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(UInDreamSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on UInDreamSurvivorSubAnimInstance");
static_assert(sizeof(UInDreamSurvivorSubAnimInstance) == 0x000610, "Wrong size on UInDreamSurvivorSubAnimInstance");
static_assert(offsetof(UInDreamSurvivorSubAnimInstance, _shouldLookSleepy) == 0x0005E8, "Member 'UInDreamSurvivorSubAnimInstance::_shouldLookSleepy' has a wrong offset!");
static_assert(offsetof(UInDreamSurvivorSubAnimInstance, _isCrawling) == 0x0005E9, "Member 'UInDreamSurvivorSubAnimInstance::_isCrawling' has a wrong offset!");
static_assert(offsetof(UInDreamSurvivorSubAnimInstance, _isBeingCarried) == 0x0005EA, "Member 'UInDreamSurvivorSubAnimInstance::_isBeingCarried' has a wrong offset!");
static_assert(offsetof(UInDreamSurvivorSubAnimInstance, _isDead) == 0x0005EB, "Member 'UInDreamSurvivorSubAnimInstance::_isDead' has a wrong offset!");
static_assert(offsetof(UInDreamSurvivorSubAnimInstance, _isHooked) == 0x0005EC, "Member 'UInDreamSurvivorSubAnimInstance::_isHooked' has a wrong offset!");
static_assert(offsetof(UInDreamSurvivorSubAnimInstance, _isCrouched) == 0x0005ED, "Member 'UInDreamSurvivorSubAnimInstance::_isCrouched' has a wrong offset!");
static_assert(offsetof(UInDreamSurvivorSubAnimInstance, _isIdle) == 0x0005EE, "Member 'UInDreamSurvivorSubAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(UInDreamSurvivorSubAnimInstance, _walkAnimSpeed) == 0x0005F0, "Member 'UInDreamSurvivorSubAnimInstance::_walkAnimSpeed' has a wrong offset!");

// Class TheNightmare.K10DreamPalletWidgetComponent
// 0x0000 (0x00D0 - 0x00D0)
class UK10DreamPalletWidgetComponent final : public UPowerWidgetPresentationComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K10DreamPalletWidgetComponent">();
	}
	static class UK10DreamPalletWidgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK10DreamPalletWidgetComponent>();
	}
};
static_assert(alignof(UK10DreamPalletWidgetComponent) == 0x000008, "Wrong alignment on UK10DreamPalletWidgetComponent");
static_assert(sizeof(UK10DreamPalletWidgetComponent) == 0x0000D0, "Wrong size on UK10DreamPalletWidgetComponent");

// Class TheNightmare.K10DreamProjectionWidgetComponent
// 0x0000 (0x00D0 - 0x00D0)
class UK10DreamProjectionWidgetComponent final : public UPowerWidgetPresentationComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K10DreamProjectionWidgetComponent">();
	}
	static class UK10DreamProjectionWidgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK10DreamProjectionWidgetComponent>();
	}
};
static_assert(alignof(UK10DreamProjectionWidgetComponent) == 0x000008, "Wrong alignment on UK10DreamProjectionWidgetComponent");
static_assert(sizeof(UK10DreamProjectionWidgetComponent) == 0x0000D0, "Wrong size on UK10DreamProjectionWidgetComponent");

// Class TheNightmare.K10DreamSnareWidgetComponent
// 0x0000 (0x00D0 - 0x00D0)
class UK10DreamSnareWidgetComponent final : public UPowerWidgetPresentationComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K10DreamSnareWidgetComponent">();
	}
	static class UK10DreamSnareWidgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK10DreamSnareWidgetComponent>();
	}
};
static_assert(alignof(UK10DreamSnareWidgetComponent) == 0x000008, "Wrong alignment on UK10DreamSnareWidgetComponent");
static_assert(sizeof(UK10DreamSnareWidgetComponent) == 0x0000D0, "Wrong size on UK10DreamSnareWidgetComponent");

// Class TheNightmare.K10PowerSwitchingWidgetComponent
// 0x0000 (0x00D0 - 0x00D0)
class UK10PowerSwitchingWidgetComponent final : public UPowerWidgetPresentationComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K10PowerSwitchingWidgetComponent">();
	}
	static class UK10PowerSwitchingWidgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK10PowerSwitchingWidgetComponent>();
	}
};
static_assert(alignof(UK10PowerSwitchingWidgetComponent) == 0x000008, "Wrong alignment on UK10PowerSwitchingWidgetComponent");
static_assert(sizeof(UK10PowerSwitchingWidgetComponent) == 0x0000D0, "Wrong size on UK10PowerSwitchingWidgetComponent");

// Class TheNightmare.NightmareAnimInstance
// 0x0000 (0x0720 - 0x0720)
class UNightmareAnimInstance final : public UKillerAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NightmareAnimInstance">();
	}
	static class UNightmareAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNightmareAnimInstance>();
	}
};
static_assert(alignof(UNightmareAnimInstance) == 0x000010, "Wrong alignment on UNightmareAnimInstance");
static_assert(sizeof(UNightmareAnimInstance) == 0x000720, "Wrong size on UNightmareAnimInstance");

// Class TheNightmare.NightmareCheatComponent
// 0x0000 (0x00B8 - 0x00B8)
class UNightmareCheatComponent final : public UDLCCheatComponent
{
public:
	void DBD_PutSurvivorToSleep(const class FString& PlayerId) const;
	void DBD_WakeUpSurvivor(const class FString& PlayerId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NightmareCheatComponent">();
	}
	static class UNightmareCheatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNightmareCheatComponent>();
	}
};
static_assert(alignof(UNightmareCheatComponent) == 0x000008, "Wrong alignment on UNightmareCheatComponent");
static_assert(sizeof(UNightmareCheatComponent) == 0x0000B8, "Wrong size on UNightmareCheatComponent");

// Class TheNightmare.NightmareHuskOutlineUpdateStrategy
// 0x0000 (0x0100 - 0x0100)
class UNightmareHuskOutlineUpdateStrategy final : public UDefaultOutlineUpdateStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NightmareHuskOutlineUpdateStrategy">();
	}
	static class UNightmareHuskOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNightmareHuskOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UNightmareHuskOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UNightmareHuskOutlineUpdateStrategy");
static_assert(sizeof(UNightmareHuskOutlineUpdateStrategy) == 0x000100, "Wrong size on UNightmareHuskOutlineUpdateStrategy");

// Class TheNightmare.NightmarePower
// 0x0000 (0x0610 - 0x0610)
class ANightmarePower final : public AKillerPower
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NightmarePower">();
	}
	static class ANightmarePower* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANightmarePower>();
	}
};
static_assert(alignof(ANightmarePower) == 0x000008, "Wrong alignment on ANightmarePower");
static_assert(sizeof(ANightmarePower) == 0x000610, "Wrong size on ANightmarePower");

// Class TheNightmare.NightmarePowerSwitchingAbility
// 0x0088 (0x0268 - 0x01E0)
class UNightmarePowerSwitchingAbility final : public UKillerAbilityComponent
{
public:
	TSubclassOf<class UNightmarePowerSwitchingInteraction> _powerSwitchingInteractionClass;          // 0x01E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNightmarePowerSwitchingInteraction*    _powerSwitchingInteraction;                        // 0x01E8(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTagStateBool                          _isUsingDreamPallets;                              // 0x01F0(0x0048)(Net, RepNotify, NativeAccessSpecifierPrivate)
	class FText                                   _switchToPalletInteractionDescriptionText;         // 0x0238(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class FText                                   _switchToSnareInteractionDescriptionText;          // 0x0250(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void OnRep_IsUsingDreamPallets() const;
	void OnRep_PowerSwitchingInteraction() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NightmarePowerSwitchingAbility">();
	}
	static class UNightmarePowerSwitchingAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNightmarePowerSwitchingAbility>();
	}
};
static_assert(alignof(UNightmarePowerSwitchingAbility) == 0x000008, "Wrong alignment on UNightmarePowerSwitchingAbility");
static_assert(sizeof(UNightmarePowerSwitchingAbility) == 0x000268, "Wrong size on UNightmarePowerSwitchingAbility");
static_assert(offsetof(UNightmarePowerSwitchingAbility, _powerSwitchingInteractionClass) == 0x0001E0, "Member 'UNightmarePowerSwitchingAbility::_powerSwitchingInteractionClass' has a wrong offset!");
static_assert(offsetof(UNightmarePowerSwitchingAbility, _powerSwitchingInteraction) == 0x0001E8, "Member 'UNightmarePowerSwitchingAbility::_powerSwitchingInteraction' has a wrong offset!");
static_assert(offsetof(UNightmarePowerSwitchingAbility, _isUsingDreamPallets) == 0x0001F0, "Member 'UNightmarePowerSwitchingAbility::_isUsingDreamPallets' has a wrong offset!");
static_assert(offsetof(UNightmarePowerSwitchingAbility, _switchToPalletInteractionDescriptionText) == 0x000238, "Member 'UNightmarePowerSwitchingAbility::_switchToPalletInteractionDescriptionText' has a wrong offset!");
static_assert(offsetof(UNightmarePowerSwitchingAbility, _switchToSnareInteractionDescriptionText) == 0x000250, "Member 'UNightmarePowerSwitchingAbility::_switchToSnareInteractionDescriptionText' has a wrong offset!");

// Class TheNightmare.NightmarePowerSwitchingInteraction
// 0x0000 (0x0770 - 0x0770)
class UNightmarePowerSwitchingInteraction final : public UInteractionDefinition
{
public:
	void Cosmetic_OnPowerSwitch();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NightmarePowerSwitchingInteraction">();
	}
	static class UNightmarePowerSwitchingInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNightmarePowerSwitchingInteraction>();
	}
};
static_assert(alignof(UNightmarePowerSwitchingInteraction) == 0x000010, "Wrong alignment on UNightmarePowerSwitchingInteraction");
static_assert(sizeof(UNightmarePowerSwitchingInteraction) == 0x000770, "Wrong size on UNightmarePowerSwitchingInteraction");

// Class TheNightmare.NightmareSurvivorCosmeticHelperActor
// 0x00A0 (0x03F8 - 0x0358)
class ANightmareSurvivorCosmeticHelperActor final : public ASurvivorCosmeticHelperActor
{
public:
	struct FGameplayTagQuery                      _canBeTeleportedToTagQuery;                        // 0x0358(0x0048)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A0[0x10];                                     // 0x03A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USurvivorDreamworldComponent*           _survivorDreamworldComponent;                      // 0x03B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B8[0x40];                                     // 0x03B8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnPlayerHitWithDreamAttack(class ASurvivor* Survivor, class AKiller* Killer);
	void Cosmetic_OnPlayerHitWithDreamAttackImmune(class ASurvivor* Survivor, class AKiller* Killer);
	void Cosmetic_OnPlayerInducedSleepWithDreamAttack(class ASurvivor* Survivor, class AKiller* Killer);
	void Cosmetic_ShouldShowTeleportWarning(bool ShouldShow);

	class USurvivorDreamworldComponent* GetDreamworldComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NightmareSurvivorCosmeticHelperActor">();
	}
	static class ANightmareSurvivorCosmeticHelperActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANightmareSurvivorCosmeticHelperActor>();
	}
};
static_assert(alignof(ANightmareSurvivorCosmeticHelperActor) == 0x000008, "Wrong alignment on ANightmareSurvivorCosmeticHelperActor");
static_assert(sizeof(ANightmareSurvivorCosmeticHelperActor) == 0x0003F8, "Wrong size on ANightmareSurvivorCosmeticHelperActor");
static_assert(offsetof(ANightmareSurvivorCosmeticHelperActor, _canBeTeleportedToTagQuery) == 0x000358, "Member 'ANightmareSurvivorCosmeticHelperActor::_canBeTeleportedToTagQuery' has a wrong offset!");
static_assert(offsetof(ANightmareSurvivorCosmeticHelperActor, _survivorDreamworldComponent) == 0x0003B0, "Member 'ANightmareSurvivorCosmeticHelperActor::_survivorDreamworldComponent' has a wrong offset!");

// Class TheNightmare.PlaceDreamPalletInteraction
// 0x0040 (0x07B0 - 0x0770)
class UPlaceDreamPalletInteraction final : public UInteractionDefinition
{
public:
	TSubclassOf<class UPalletTrackerVisibilityComponent> _visibilityComponentClass;                  // 0x0768(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_770[0x40];                                     // 0x0770(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_DespawnOldDreamPallet(class APallet* oldDreamPallet);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlaceDreamPalletInteraction">();
	}
	static class UPlaceDreamPalletInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlaceDreamPalletInteraction>();
	}
};
static_assert(alignof(UPlaceDreamPalletInteraction) == 0x000010, "Wrong alignment on UPlaceDreamPalletInteraction");
static_assert(sizeof(UPlaceDreamPalletInteraction) == 0x0007B0, "Wrong size on UPlaceDreamPalletInteraction");
static_assert(offsetof(UPlaceDreamPalletInteraction, _visibilityComponentClass) == 0x000768, "Member 'UPlaceDreamPalletInteraction::_visibilityComponentClass' has a wrong offset!");

// Class TheNightmare.RememberMe
// 0x0000 (0x0460 - 0x0460)
class URememberMe final : public UPerk
{
public:
	bool DidLoseHealthState(const class AActor* DamagedActor, int32 oldHealthStateCount) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RememberMe">();
	}
	static class URememberMe* GetDefaultObj()
	{
		return GetDefaultObjImpl<URememberMe>();
	}
};
static_assert(alignof(URememberMe) == 0x000008, "Wrong alignment on URememberMe");
static_assert(sizeof(URememberMe) == 0x000460, "Wrong size on URememberMe");

// Class TheNightmare.SetDreamSnareInteraction
// 0x0010 (0x0930 - 0x0920)
class USetDreamSnareInteraction final : public UBasicChargeableInteraction
{
public:
	uint8                                         Pad_920[0x10];                                     // 0x0920(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_BeginShowSnareIndicator();
	void Cosmetic_SetSnareCancelled();
	void Cosmetic_SnarePlacementFailed();
	void Cosmetic_StopShowSnareIndicator();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SetDreamSnareInteraction">();
	}
	static class USetDreamSnareInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USetDreamSnareInteraction>();
	}
};
static_assert(alignof(USetDreamSnareInteraction) == 0x000010, "Wrong alignment on USetDreamSnareInteraction");
static_assert(sizeof(USetDreamSnareInteraction) == 0x000930, "Wrong size on USetDreamSnareInteraction");

// Class TheNightmare.SpawnDreamSnareInteraction
// 0x0000 (0x0770 - 0x0770)
class USpawnDreamSnareInteraction final : public UInteractionDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnDreamSnareInteraction">();
	}
	static class USpawnDreamSnareInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnDreamSnareInteraction>();
	}
};
static_assert(alignof(USpawnDreamSnareInteraction) == 0x000010, "Wrong alignment on USpawnDreamSnareInteraction");
static_assert(sizeof(USpawnDreamSnareInteraction) == 0x000770, "Wrong size on USpawnDreamSnareInteraction");

// Class TheNightmare.WakerObjectOutlineStrategy
// 0x0000 (0x0160 - 0x0160)
class UWakerObjectOutlineStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WakerObjectOutlineStrategy">();
	}
	static class UWakerObjectOutlineStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWakerObjectOutlineStrategy>();
	}
};
static_assert(alignof(UWakerObjectOutlineStrategy) == 0x000008, "Wrong alignment on UWakerObjectOutlineStrategy");
static_assert(sizeof(UWakerObjectOutlineStrategy) == 0x000160, "Wrong size on UWakerObjectOutlineStrategy");

// Class TheNightmare.WakeUpOtherInteraction
// 0x0080 (0x0940 - 0x08C0)
class UWakeUpOtherInteraction final : public UChargeableInteractionDefinition
{
public:
	struct FTunableStat                           _wakeUpTimeStat;                                   // 0x08C0(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WakeUpOtherInteraction">();
	}
	static class UWakeUpOtherInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWakeUpOtherInteraction>();
	}
};
static_assert(alignof(UWakeUpOtherInteraction) == 0x000010, "Wrong alignment on UWakeUpOtherInteraction");
static_assert(sizeof(UWakeUpOtherInteraction) == 0x000940, "Wrong size on UWakeUpOtherInteraction");
static_assert(offsetof(UWakeUpOtherInteraction, _wakeUpTimeStat) == 0x0008C0, "Member 'UWakeUpOtherInteraction::_wakeUpTimeStat' has a wrong offset!");

}

