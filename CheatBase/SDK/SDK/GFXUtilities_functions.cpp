#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GFXUtilities

#include "Basic.hpp"

#include "GFXUtilities_classes.hpp"
#include "GFXUtilities_parameters.hpp"


namespace SDK
{

// Function GFXUtilities.ClippableProviderComponent.AddIgnoredPrimitives
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class UPrimitiveComponent*>&ignoredPrimitives                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UClippableProviderComponent::AddIgnoredPrimitives(const TArray<class UPrimitiveComponent*>& ignoredPrimitives)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClippableProviderComponent", "AddIgnoredPrimitives");

	Params::ClippableProviderComponent_AddIgnoredPrimitives Parms{};

	Parms.ignoredPrimitives = std::move(ignoredPrimitives);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.ClippableProviderComponent.SetIgnoredPrimitives
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class UPrimitiveComponent*>&ignoredPrimitives                                      (ConstParm, Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UClippableProviderComponent::SetIgnoredPrimitives(const TArray<class UPrimitiveComponent*>& ignoredPrimitives)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClippableProviderComponent", "SetIgnoredPrimitives");

	Params::ClippableProviderComponent_SetIgnoredPrimitives Parms{};

	Parms.ignoredPrimitives = std::move(ignoredPrimitives);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.AddGroup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FMaterialNamedGroup&       Group                                                  (ConstParm, Parm, NativeAccessSpecifierPublic)

void UBatchMeshCommands::AddGroup(const struct FMaterialNamedGroup& Group)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "AddGroup");

	Params::BatchMeshCommands_AddGroup Parms{};

	Parms.Group = std::move(Group);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.BatchSetComponentTickEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::BatchSetComponentTickEnabled(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "BatchSetComponentTickEnabled");

	Params::BatchMeshCommands_BatchSetComponentTickEnabled Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.BatchSetSkipComponentAndChildrenTransformUpdate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Skip                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::BatchSetSkipComponentAndChildrenTransformUpdate(bool Skip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "BatchSetSkipComponentAndChildrenTransformUpdate");

	Params::BatchMeshCommands_BatchSetSkipComponentAndChildrenTransformUpdate Parms{};

	Parms.Skip = Skip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.BatchSetVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewVisibility                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPropagateToChildren                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::BatchSetVisibility(bool bNewVisibility, bool bPropagateToChildren)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "BatchSetVisibility");

	Params::BatchMeshCommands_BatchSetVisibility Parms{};

	Parms.bNewVisibility = bNewVisibility;
	Parms.bPropagateToChildren = bPropagateToChildren;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.CopyFirstScalarParameter
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName                       ParameterName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBatchMeshCommands::CopyFirstScalarParameter(const class FName ParameterName, float* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "CopyFirstScalarParameter");

	Params::BatchMeshCommands_CopyFirstScalarParameter Parms{};

	Parms.ParameterName = ParameterName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;

	return Parms.ReturnValue;
}


// Function GFXUtilities.BatchMeshCommands.ResetMaterials
// (Final, Native, Public, BlueprintCallable)

void UBatchMeshCommands::ResetMaterials()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "ResetMaterials");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetAllToSameMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               MaterialInterface                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetAllToSameMaterial(class UMaterialInterface* MaterialInterface)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetAllToSameMaterial");

	Params::BatchMeshCommands_SetAllToSameMaterial Parms{};

	Parms.MaterialInterface = MaterialInterface;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetCastCinematicShadows
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    castCinematicShadows                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetCastCinematicShadows(bool castCinematicShadows)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetCastCinematicShadows");

	Params::BatchMeshCommands_SetCastCinematicShadows Parms{};

	Parms.castCinematicShadows = castCinematicShadows;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetColourParameter
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const class FName                       ParameterName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              NewValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetColourParameter(const class FName ParameterName, const struct FLinearColor& NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetColourParameter");

	Params::BatchMeshCommands_SetColourParameter Parms{};

	Parms.ParameterName = ParameterName;
	Parms.NewValue = std::move(NewValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetCustomDepthStencilValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   stencilValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetCustomDepthStencilValue(int32 stencilValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetCustomDepthStencilValue");

	Params::BatchMeshCommands_SetCustomDepthStencilValue Parms{};

	Parms.stencilValue = stencilValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetLightingChannelForAllMeshes
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FLightingChannels&         LightingChannels                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetLightingChannelForAllMeshes(const struct FLightingChannels& LightingChannels)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetLightingChannelForAllMeshes");

	Params::BatchMeshCommands_SetLightingChannelForAllMeshes Parms{};

	Parms.LightingChannels = std::move(LightingChannels);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    GroupName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetMaterial(const class FString& GroupName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetMaterial");

	Params::BatchMeshCommands_SetMaterial Parms{};

	Parms.GroupName = std::move(GroupName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetReceivesDecals
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    receivesDecals                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetReceivesDecals(bool receivesDecals)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetReceivesDecals");

	Params::BatchMeshCommands_SetReceivesDecals Parms{};

	Parms.receivesDecals = receivesDecals;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetRenderInCustomColourNoDepth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    renderInCustomColour                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetRenderInCustomColourNoDepth(bool renderInCustomColour)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetRenderInCustomColourNoDepth");

	Params::BatchMeshCommands_SetRenderInCustomColourNoDepth Parms{};

	Parms.renderInCustomColour = renderInCustomColour;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetRenderInCustomDepth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    renderInCustomDepth                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetRenderInCustomDepth(bool renderInCustomDepth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetRenderInCustomDepth");

	Params::BatchMeshCommands_SetRenderInCustomDepth Parms{};

	Parms.renderInCustomDepth = renderInCustomDepth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetRenderInMainPass
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    inRenderInMainPass                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetRenderInMainPass(bool inRenderInMainPass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetRenderInMainPass");

	Params::BatchMeshCommands_SetRenderInMainPass Parms{};

	Parms.inRenderInMainPass = inRenderInMainPass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetScalarParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       ParameterName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             NewValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetScalarParameter(const class FName ParameterName, const float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetScalarParameter");

	Params::BatchMeshCommands_SetScalarParameter Parms{};

	Parms.ParameterName = ParameterName;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetStencilIntegerScalarParameter
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName                       ParameterName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32&                            NewValue                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetStencilIntegerScalarParameter(const class FName ParameterName, const int32& NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetStencilIntegerScalarParameter");

	Params::BatchMeshCommands_SetStencilIntegerScalarParameter Parms{};

	Parms.ParameterName = ParameterName;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetTextureParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       ParameterName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                         newTexture                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetTextureParameter(const class FName ParameterName, class UTexture* newTexture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetTextureParameter");

	Params::BatchMeshCommands_SetTextureParameter Parms{};

	Parms.ParameterName = ParameterName;
	Parms.newTexture = newTexture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetVectorParameter
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class FName                       ParameterName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NewValue                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetVectorParameter(const class FName ParameterName, const struct FVector& NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetVectorParameter");

	Params::BatchMeshCommands_SetVectorParameter Parms{};

	Parms.ParameterName = ParameterName;
	Parms.NewValue = std::move(NewValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.UpdateMaterials
// (Final, Native, Public, BlueprintCallable)

void UBatchMeshCommands::UpdateMaterials()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "UpdateMaterials");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.DBDReflectionCaptureSpawnerComponent.SetBrightness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Brightness_0                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDReflectionCaptureSpawnerComponent::SetBrightness(float Brightness_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDReflectionCaptureSpawnerComponent", "SetBrightness");

	Params::DBDReflectionCaptureSpawnerComponent_SetBrightness Parms{};

	Parms.Brightness_0 = Brightness_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.DBDReflectionCaptureSpawnerComponent.SetContributionFactor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ContributionFactor_0                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDReflectionCaptureSpawnerComponent::SetContributionFactor(float ContributionFactor_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDReflectionCaptureSpawnerComponent", "SetContributionFactor");

	Params::DBDReflectionCaptureSpawnerComponent_SetContributionFactor Parms{};

	Parms.ContributionFactor_0 = ContributionFactor_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.DBDReflectionCaptureSpawnerComponent.SetIBLMultiplicator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   IBLMultiplicator_0                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDReflectionCaptureSpawnerComponent::SetIBLMultiplicator(float IBLMultiplicator_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDReflectionCaptureSpawnerComponent", "SetIBLMultiplicator");

	Params::DBDReflectionCaptureSpawnerComponent_SetIBLMultiplicator Parms{};

	Parms.IBLMultiplicator_0 = IBLMultiplicator_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.GFXUtilities.ActivateVFX
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           SkeletalMeshComponent                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Active                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGFXUtilities::ActivateVFX(class USkeletalMeshComponent* SkeletalMeshComponent, bool Active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GFXUtilities", "ActivateVFX");

	Params::GFXUtilities_ActivateVFX Parms{};

	Parms.SkeletalMeshComponent = SkeletalMeshComponent;
	Parms.Active = Active;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.LightIntensityTimelineComponent.AddLight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULightComponent*                  Light                                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Multiplier                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightIntensityTimelineComponent::AddLight(class ULightComponent* Light, float Multiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightIntensityTimelineComponent", "AddLight");

	Params::LightIntensityTimelineComponent_AddLight Parms{};

	Parms.Light = Light;
	Parms.Multiplier = Multiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.LightIntensityTimelineComponent.AddMaterialHelper
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialHelper*                  matHelper                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             propName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Multiplier                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightIntensityTimelineComponent::AddMaterialHelper(class UMaterialHelper* matHelper, class FName propName, float Multiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightIntensityTimelineComponent", "AddMaterialHelper");

	Params::LightIntensityTimelineComponent_AddMaterialHelper Parms{};

	Parms.matHelper = matHelper;
	Parms.propName = propName;
	Parms.Multiplier = Multiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.LightIntensityTimelineComponent.DeactivateTick
// (Final, Native, Public, BlueprintCallable)

void ULightIntensityTimelineComponent::DeactivateTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightIntensityTimelineComponent", "DeactivateTick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.LightIntensityTimelineComponent.RegisterForTick
// (Final, Native, Public, BlueprintCallable)

void ULightIntensityTimelineComponent::RegisterForTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightIntensityTimelineComponent", "RegisterForTick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.LightIntensityTimelineComponent.Reset
// (Final, Native, Public, BlueprintCallable)

void ULightIntensityTimelineComponent::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightIntensityTimelineComponent", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.LightIntensityTimelineComponent.SetLightCurve
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCurveFloat*                      lightcurve                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightIntensityTimelineComponent::SetLightCurve(class UCurveFloat* lightcurve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightIntensityTimelineComponent", "SetLightCurve");

	Params::LightIntensityTimelineComponent_SetLightCurve Parms{};

	Parms.lightcurve = lightcurve;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.LightIntensityTimelineComponent.SetLightToMaxValue
// (Final, Native, Public, BlueprintCallable)

void ULightIntensityTimelineComponent::SetLightToMaxValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightIntensityTimelineComponent", "SetLightToMaxValue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.LightIntensityTimelineComponent.SetMaxLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   newMaxValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightIntensityTimelineComponent::SetMaxLength(float newMaxValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightIntensityTimelineComponent", "SetMaxLength");

	Params::LightIntensityTimelineComponent_SetMaxLength Parms{};

	Parms.newMaxValue = newMaxValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.LightIntensityTimelineComponent.SetMinLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   newMinValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightIntensityTimelineComponent::SetMinLength(float newMinValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightIntensityTimelineComponent", "SetMinLength");

	Params::LightIntensityTimelineComponent_SetMinLength Parms{};

	Parms.newMinValue = newMinValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.LightIntensityTimelineComponent.SetRandomizeLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isRandom                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightIntensityTimelineComponent::SetRandomizeLength(bool isRandom)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightIntensityTimelineComponent", "SetRandomizeLength");

	Params::LightIntensityTimelineComponent_SetRandomizeLength Parms{};

	Parms.isRandom = isRandom;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.MaterialHelper.SetSceneComponentVisibility
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  InSceneComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              newVisibility                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              propagateToChildren                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialHelper::SetSceneComponentVisibility(class USceneComponent* InSceneComponent, const bool newVisibility, const bool propagateToChildren)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaterialHelper", "SetSceneComponentVisibility");

	Params::MaterialHelper_SetSceneComponentVisibility Parms{};

	Parms.InSceneComponent = InSceneComponent;
	Parms.newVisibility = newVisibility;
	Parms.propagateToChildren = propagateToChildren;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.MaterialHelper.RefreshMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   mc                                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialHelper::RefreshMesh(class UMeshComponent* mc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaterialHelper", "RefreshMesh");

	Params::MaterialHelper_RefreshMesh Parms{};

	Parms.mc = mc;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.MaterialHelper.RefreshMeshes
// (Final, Native, Public, BlueprintCallable)

void UMaterialHelper::RefreshMeshes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaterialHelper", "RefreshMeshes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.AsyncAction_OverrideMaterial.AsyncOverrideMaterial
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMeshComponent*                   Mesh                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              Group                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMaterialOverridePriority               Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    copyPhysicalMaterial                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncAction_OverrideMaterial*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncAction_OverrideMaterial* UAsyncAction_OverrideMaterial::AsyncOverrideMaterial(class UObject* WorldContextObject, class UMeshComponent* Mesh, const struct FGameplayTag& Group, EMaterialOverridePriority Priority, bool copyPhysicalMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncAction_OverrideMaterial", "AsyncOverrideMaterial");

	Params::AsyncAction_OverrideMaterial_AsyncOverrideMaterial Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Mesh = Mesh;
	Parms.Group = std::move(Group);
	Parms.Priority = Priority;
	Parms.copyPhysicalMaterial = copyPhysicalMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GFXUtilities.MaterialOverrideSubsystem.AddNewVariantPairToLibrary
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              VariantName                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UMaterialInterface>src                                                    (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UMaterialInterface>dst                                                    (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialOverrideSubsystem::AddNewVariantPairToLibrary(const struct FGameplayTag& VariantName, TSoftObjectPtr<class UMaterialInterface> src, TSoftObjectPtr<class UMaterialInterface> dst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaterialOverrideSubsystem", "AddNewVariantPairToLibrary");

	Params::MaterialOverrideSubsystem_AddNewVariantPairToLibrary Parms{};

	Parms.VariantName = std::move(VariantName);
	Parms.src = src;
	Parms.dst = dst;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.MaterialOverrideSubsystem.RemoveMaterialVariantOverride
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   Mesh                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              VariantName                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialOverrideSubsystem::RemoveMaterialVariantOverride(class UMeshComponent* Mesh, const struct FGameplayTag& VariantName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaterialOverrideSubsystem", "RemoveMaterialVariantOverride");

	Params::MaterialOverrideSubsystem_RemoveMaterialVariantOverride Parms{};

	Parms.Mesh = Mesh;
	Parms.VariantName = std::move(VariantName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.MaterialOverrideSubsystem.RemoveVariantsWithNameFromLibrary
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              VariantName                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialOverrideSubsystem::RemoveVariantsWithNameFromLibrary(const struct FGameplayTag& VariantName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaterialOverrideSubsystem", "RemoveVariantsWithNameFromLibrary");

	Params::MaterialOverrideSubsystem_RemoveVariantsWithNameFromLibrary Parms{};

	Parms.VariantName = std::move(VariantName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.MaterialOverrideSubsystem.SetOverrideMaterials
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   Mesh                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              VariantName                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMaterialOverridePriority               Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaterialOverrideSubsystem::SetOverrideMaterials(class UMeshComponent* Mesh, const struct FGameplayTag& VariantName, EMaterialOverridePriority Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaterialOverrideSubsystem", "SetOverrideMaterials");

	Params::MaterialOverrideSubsystem_SetOverrideMaterials Parms{};

	Parms.Mesh = Mesh;
	Parms.VariantName = std::move(VariantName);
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GFXUtilities.MaterialOverrideSubsystem.SetOverrideMaterialsAdvanced
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   Mesh                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              VariantName                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCopyPhysicalMaterial                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMaterialOverridePriority               Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMaterialOverrideParameterCopyType      parameterCopyType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   recursionLimit                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaterialOverrideSubsystem::SetOverrideMaterialsAdvanced(class UMeshComponent* Mesh, const struct FGameplayTag& VariantName, bool bCopyPhysicalMaterial, EMaterialOverridePriority Priority, EMaterialOverrideParameterCopyType parameterCopyType, int32 recursionLimit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaterialOverrideSubsystem", "SetOverrideMaterialsAdvanced");

	Params::MaterialOverrideSubsystem_SetOverrideMaterialsAdvanced Parms{};

	Parms.Mesh = Mesh;
	Parms.VariantName = std::move(VariantName);
	Parms.bCopyPhysicalMaterial = bCopyPhysicalMaterial;
	Parms.Priority = Priority;
	Parms.parameterCopyType = parameterCopyType;
	Parms.recursionLimit = recursionLimit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GFXUtilities.OuterlineComponent.SetIntensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Intensity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOuterlineComponent::SetIntensity(float Intensity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OuterlineComponent", "SetIntensity");

	Params::OuterlineComponent_SetIntensity Parms{};

	Parms.Intensity = Intensity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.StencilOutlineRenderStrategy.EnableCopyStencilToCustomStencil
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStencilOutlineRenderStrategy::EnableCopyStencilToCustomStencil(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StencilOutlineRenderStrategy", "EnableCopyStencilToCustomStencil");

	Params::StencilOutlineRenderStrategy_EnableCopyStencilToCustomStencil Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

