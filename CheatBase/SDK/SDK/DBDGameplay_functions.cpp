#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DBDGameplay

#include "Basic.hpp"

#include "DBDGameplay_classes.hpp"
#include "DBDGameplay_parameters.hpp"


namespace SDK
{

// Function DBDGameplay.CageHook.CheckRescuerSocketPosition
// (Event, Protected, BlueprintEvent)

void ACageHook::CheckRescuerSocketPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHook", "CheckRescuerSocketPosition");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.CageHook.Cosmetic_DisplayCage
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// const bool                              Display                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACageHook::Cosmetic_DisplayCage(const bool Display)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHook", "Cosmetic_DisplayCage");

	Params::CageHook_Cosmetic_DisplayCage Parms{};

	Parms.Display = Display;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.CageHook.Cosmetic_OnGoingUpStarted
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    isAnticampRelocation                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASurvivor*                        cagedSurvivor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACageHook::Cosmetic_OnGoingUpStarted(bool isAnticampRelocation, class ASurvivor* cagedSurvivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHook", "Cosmetic_OnGoingUpStarted");

	Params::CageHook_Cosmetic_OnGoingUpStarted Parms{};

	Parms.isAnticampRelocation = isAnticampRelocation;
	Parms.cagedSurvivor = cagedSurvivor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.CageHook.Cosmetic_OnPlayerAbsorbedByGround
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void ACageHook::Cosmetic_OnPlayerAbsorbedByGround()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHook", "Cosmetic_OnPlayerAbsorbedByGround");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.CageHook.Cosmetic_OnRelocateStart
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void ACageHook::Cosmetic_OnRelocateStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHook", "Cosmetic_OnRelocateStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.CageHook.FX_SurvivorSavedFromCage
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void ACageHook::FX_SurvivorSavedFromCage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHook", "FX_SurvivorSavedFromCage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.CageHook.Multicast_Relocate
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, HasDefaults)
// Parameters:
// const struct FVector&                   Location                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Rotation                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const bool                              isAnticampRelocation                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACageHook::Multicast_Relocate(const struct FVector& Location, const struct FRotator& Rotation, const bool isAnticampRelocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHook", "Multicast_Relocate");

	Params::CageHook_Multicast_Relocate Parms{};

	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.isAnticampRelocation = isAnticampRelocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.CageHook.Multicast_SendSurvivorToCage
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AKiller*                          killerInstigator                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACageHook::Multicast_SendSurvivorToCage(class ASurvivor* Survivor, class AKiller* killerInstigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHook", "Multicast_SendSurvivorToCage");

	Params::CageHook_Multicast_SendSurvivorToCage Parms{};

	Parms.Survivor = Survivor;
	Parms.killerInstigator = killerInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.CageHook.Multicast_SendSurvivorToCageImmediately
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, HasDefaults)
// Parameters:
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AKiller*                          killerInstigator                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Rotation                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ACageHook::Multicast_SendSurvivorToCageImmediately(class ASurvivor* Survivor, class AKiller* killerInstigator, const struct FVector& Location, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHook", "Multicast_SendSurvivorToCageImmediately");

	Params::CageHook_Multicast_SendSurvivorToCageImmediately Parms{};

	Parms.Survivor = Survivor;
	Parms.killerInstigator = killerInstigator;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.CageHook.OnCageDisappear
// (Final, Native, Protected, BlueprintCallable)

void ACageHook::OnCageDisappear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHook", "OnCageDisappear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.CageHook.OnRescueCancelled
// (Event, Protected, BlueprintEvent)

void ACageHook::OnRescueCancelled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHook", "OnRescueCancelled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.CageHook.OnSkillCheckFailed
// (Final, Native, Private)

void ACageHook::OnSkillCheckFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHook", "OnSkillCheckFailed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.CageHook.OnSkillCheckFailed_Cosmetic
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void ACageHook::OnSkillCheckFailed_Cosmetic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHook", "OnSkillCheckFailed_Cosmetic");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.CageHook.GetCagedSurvivor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASurvivor*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASurvivor* ACageHook::GetCagedSurvivor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHook", "GetCagedSurvivor");

	Params::CageHook_GetCagedSurvivor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.CageHook.GetMontagePlayer
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMontagePlayer*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMontagePlayer* ACageHook::GetMontagePlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHook", "GetMontagePlayer");

	Params::CageHook_GetMontagePlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.CageHook.GetRescuerSnapPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ACageHook::GetRescuerSnapPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHook", "GetRescuerSnapPosition");

	Params::CageHook_GetRescuerSnapPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.FlashlightComponent.OnRep_IsOwnerLagging
// (Final, Native, Private)

void UFlashlightComponent::OnRep_IsOwnerLagging()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightComponent", "OnRep_IsOwnerLagging");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FlashlightComponent.OnRep_ReplicatedLitFlashlightables
// (Final, Native, Private)

void UFlashlightComponent::OnRep_ReplicatedLitFlashlightables()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightComponent", "OnRep_ReplicatedLitFlashlightables");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FlashlightComponent.Server_SetAndUpdateAutonomousLitFlashlightables
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const TArray<class UFlashlightableComponent*>&newLitFlashlightables                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UFlashlightComponent::Server_SetAndUpdateAutonomousLitFlashlightables(const TArray<class UFlashlightableComponent*>& newLitFlashlightables)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightComponent", "Server_SetAndUpdateAutonomousLitFlashlightables");

	Params::FlashlightComponent_Server_SetAndUpdateAutonomousLitFlashlightables Parms{};

	Parms.newLitFlashlightables = std::move(newLitFlashlightables);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FlashlightComponent.TurnOff
// (Final, Native, Public, BlueprintCallable)

void UFlashlightComponent::TurnOff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightComponent", "TurnOff");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FlashlightComponent.TurnOn
// (Final, Native, Public, BlueprintCallable)

void UFlashlightComponent::TurnOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightComponent", "TurnOn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FlashlightComponent.GetEffectiveBlindnessDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFlashlightComponent::GetEffectiveBlindnessDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightComponent", "GetEffectiveBlindnessDuration");

	Params::FlashlightComponent_GetEffectiveBlindnessDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.FlashlightComponent.GetEffectiveTimeToBlindModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFlashlightComponent::GetEffectiveTimeToBlindModifier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightComponent", "GetEffectiveTimeToBlindModifier");

	Params::FlashlightComponent_GetEffectiveTimeToBlindModifier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.FlashlightComponent.IsOn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlashlightComponent::IsOn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightComponent", "IsOn");

	Params::FlashlightComponent_IsOn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.CageRescueInteraction.GetRescuerSnapPosition
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCageRescueInteraction::GetRescuerSnapPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageRescueInteraction", "GetRescuerSnapPosition");

	Params::CageRescueInteraction_GetRescuerSnapPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.SendToCageInteraction.FX_InteractionCancel
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void USendToCageInteraction::FX_InteractionCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SendToCageInteraction", "FX_InteractionCancel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.SendToCageInteraction.FX_InteractionChargeCompleted
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USendToCageInteraction::FX_InteractionChargeCompleted(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SendToCageInteraction", "FX_InteractionChargeCompleted");

	Params::SendToCageInteraction_FX_InteractionChargeCompleted Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.SendToCageInteraction.FX_InteractionStart
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void USendToCageInteraction::FX_InteractionStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SendToCageInteraction", "FX_InteractionStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.SendToCageInteraction.GetOwningSurvivor
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ASurvivor*                  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class ASurvivor* USendToCageInteraction::GetOwningSurvivor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SendToCageInteraction", "GetOwningSurvivor");

	Params::SendToCageInteraction_GetOwningSurvivor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.CageHookAntiCampComponent.Multicast_TriggerAntiCamp
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void UCageHookAntiCampComponent::Multicast_TriggerAntiCamp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHookAntiCampComponent", "Multicast_TriggerAntiCamp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.TerrorRadiusEmitterFunctionLibrary.GetActiveFakeTerrorRadiusEmittersCount
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTerrorRadiusEmitterFunctionLibrary::GetActiveFakeTerrorRadiusEmittersCount(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TerrorRadiusEmitterFunctionLibrary", "GetActiveFakeTerrorRadiusEmittersCount");

	Params::TerrorRadiusEmitterFunctionLibrary_GetActiveFakeTerrorRadiusEmittersCount Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.BaseSightManagerComponent.Authority_OnCharacterSightChanged
// (Native, Protected)
// Parameters:
// class ACharacter*                       sightedCharacter                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCharacterSightComponent*         sightComponent                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseSightManagerComponent::Authority_OnCharacterSightChanged(class ACharacter* sightedCharacter, class UCharacterSightComponent* sightComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSightManagerComponent", "Authority_OnCharacterSightChanged");

	Params::BaseSightManagerComponent_Authority_OnCharacterSightChanged Parms{};

	Parms.sightedCharacter = sightedCharacter;
	Parms.sightComponent = sightComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.BaseSightManagerComponent.OnIntroCompleted
// (Native, Protected)

void UBaseSightManagerComponent::OnIntroCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSightManagerComponent", "OnIntroCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FlashlightTargetFXComponent.OnIsLitChanged
// (Final, Native, Private)
// Parameters:
// bool                                    IsLit                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlashlightTargetFXComponent::OnIsLitChanged(bool IsLit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightTargetFXComponent", "OnIsLitChanged");

	Params::FlashlightTargetFXComponent_OnIsLitChanged Parms{};

	Parms.IsLit = IsLit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.SurvivorFootstepCreatorComponent.OnLoudNoiseTriggered
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           originator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           instigatingActor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    shouldTrack                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  audibleRange                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isQuickAction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isDeceivingNoise                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorFootstepCreatorComponent::OnLoudNoiseTriggered(class AActor* originator, class AActor* instigatingActor, const struct FVector& Location, bool shouldTrack, float* audibleRange, bool isQuickAction, bool isDeceivingNoise)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorFootstepCreatorComponent", "OnLoudNoiseTriggered");

	Params::SurvivorFootstepCreatorComponent_OnLoudNoiseTriggered Parms{};

	Parms.originator = originator;
	Parms.instigatingActor = instigatingActor;
	Parms.Location = std::move(Location);
	Parms.shouldTrack = shouldTrack;
	Parms.isQuickAction = isQuickAction;
	Parms.isDeceivingNoise = isDeceivingNoise;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (audibleRange != nullptr)
		*audibleRange = Parms.audibleRange;
}


// Function DBDGameplay.UseContaminationAntidoteInteraction.GetInteractionTarget
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASurvivor*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASurvivor* UUseContaminationAntidoteInteraction::GetInteractionTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UseContaminationAntidoteInteraction", "GetInteractionTarget");

	Params::UseContaminationAntidoteInteraction_GetInteractionTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.GlassBeadMapAddon.Authority_OnSecondaryInputPressed
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractionDefinition*           Interaction                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    fromCancelRequest                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGlassBeadMapAddon::Authority_OnSecondaryInputPressed(class ADBDPlayer* Player, class UInteractionDefinition* Interaction, bool fromCancelRequest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlassBeadMapAddon", "Authority_OnSecondaryInputPressed");

	Params::GlassBeadMapAddon_Authority_OnSecondaryInputPressed Parms{};

	Parms.Player = Player;
	Parms.Interaction = Interaction;
	Parms.fromCancelRequest = fromCancelRequest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.KillerPower.OnRep_OwningKiller
// (Final, Native, Protected)

void AKillerPower::OnRep_OwningKiller()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerPower", "OnRep_OwningKiller");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.BaseHusk.Cosmetic_InitializeSkeletalMesh
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           Mesh                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseHusk::Cosmetic_InitializeSkeletalMesh(class USkeletalMeshComponent* Mesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseHusk", "Cosmetic_InitializeSkeletalMesh");

	Params::BaseHusk_Cosmetic_InitializeSkeletalMesh Parms{};

	Parms.Mesh = Mesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.BaseHusk.InitializeHusk
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCustomizedSkeletalMesh*          customizedSkeletalMeshToCopy                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           skeletalMeshToCopy                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   characterIdOverride                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseHusk::InitializeHusk(class UCustomizedSkeletalMesh* customizedSkeletalMeshToCopy, class USkeletalMeshComponent* skeletalMeshToCopy, int32 characterIdOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseHusk", "InitializeHusk");

	Params::BaseHusk_InitializeHusk Parms{};

	Parms.customizedSkeletalMeshToCopy = customizedSkeletalMeshToCopy;
	Parms.skeletalMeshToCopy = skeletalMeshToCopy;
	Parms.characterIdOverride = characterIdOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.BaseHusk.SetHuskVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Visible                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseHusk::SetHuskVisibility(bool Visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseHusk", "SetHuskVisibility");

	Params::BaseHusk_SetHuskVisibility Parms{};

	Parms.Visible = Visible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.BaseHusk.SetScalarParameterOnAllChildrenMeshes
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           Mesh                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseHusk::SetScalarParameterOnAllChildrenMeshes(class FName ParameterName, float Value, class USkeletalMeshComponent* Mesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseHusk", "SetScalarParameterOnAllChildrenMeshes");

	Params::BaseHusk_SetScalarParameterOnAllChildrenMeshes Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Value = Value;
	Parms.Mesh = Mesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.BaseHusk.GetCopiedCustomizedSkeletalMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UCustomizedSkeletalMesh*    ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UCustomizedSkeletalMesh* ABaseHusk::GetCopiedCustomizedSkeletalMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseHusk", "GetCopiedCustomizedSkeletalMesh");

	Params::BaseHusk_GetCopiedCustomizedSkeletalMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.BaseHusk.GetMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ABaseHusk::GetMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseHusk", "GetMesh");

	Params::BaseHusk_GetMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.KillerAbilityComponent.Authority_OnIntroComplete
// (Native, Protected)

void UKillerAbilityComponent::Authority_OnIntroComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityComponent", "Authority_OnIntroComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.KillerAbilityComponent.OnRep_CooldownTimer
// (Final, Native, Protected)

void UKillerAbilityComponent::OnRep_CooldownTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityComponent", "OnRep_CooldownTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.KillerAbilityComponent.OnRep_DurationTimer
// (Final, Native, Protected)

void UKillerAbilityComponent::OnRep_DurationTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityComponent", "OnRep_DurationTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.KillerAbilityComponent.OnRep_TokenCount
// (Native, Protected)
// Parameters:
// const int32                             oldCount                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerAbilityComponent::OnRep_TokenCount(const int32 oldCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityComponent", "OnRep_TokenCount");

	Params::KillerAbilityComponent_OnRep_TokenCount Parms{};

	Parms.oldCount = oldCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.KillerAbilityComponent.OnRep_TokenRechargeTimer
// (Final, Native, Protected)

void UKillerAbilityComponent::OnRep_TokenRechargeTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityComponent", "OnRep_TokenRechargeTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.KillerAbilityComponent.GetCooldown
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKillerAbilityComponent::GetCooldown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityComponent", "GetCooldown");

	Params::KillerAbilityComponent_GetCooldown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.KillerAbilityComponent.GetDuration
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKillerAbilityComponent::GetDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityComponent", "GetDuration");

	Params::KillerAbilityComponent_GetDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.KillerAbilityComponent.GetOwningKiller
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AKiller*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AKiller* UKillerAbilityComponent::GetOwningKiller() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityComponent", "GetOwningKiller");

	Params::KillerAbilityComponent_GetOwningKiller Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.KillerAbilityComponent.GetOwningPower
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AKillerPower*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AKillerPower* UKillerAbilityComponent::GetOwningPower() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityComponent", "GetOwningPower");

	Params::KillerAbilityComponent_GetOwningPower Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.KillerAbilityComponent.GetRemainingCooldown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKillerAbilityComponent::GetRemainingCooldown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityComponent", "GetRemainingCooldown");

	Params::KillerAbilityComponent_GetRemainingCooldown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.KillerAbilityComponent.GetRemainingCooldownPercent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKillerAbilityComponent::GetRemainingCooldownPercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityComponent", "GetRemainingCooldownPercent");

	Params::KillerAbilityComponent_GetRemainingCooldownPercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.KillerAbilityComponent.GetRemainingDurationPercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKillerAbilityComponent::GetRemainingDurationPercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityComponent", "GetRemainingDurationPercent");

	Params::KillerAbilityComponent_GetRemainingDurationPercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.KillerAbilityComponent.IsApplicable
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKillerAbilityComponent::IsApplicable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityComponent", "IsApplicable");

	Params::KillerAbilityComponent_IsApplicable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.KillerAbilityComponent.IsAvailable
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKillerAbilityComponent::IsAvailable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityComponent", "IsAvailable");

	Params::KillerAbilityComponent_IsAvailable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.KillerAbilityComponent.IsDurationTimerActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKillerAbilityComponent::IsDurationTimerActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityComponent", "IsDurationTimerActive");

	Params::KillerAbilityComponent_IsDurationTimerActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.KillerAbilityComponent.IsOnCooldown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKillerAbilityComponent::IsOnCooldown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityComponent", "IsOnCooldown");

	Params::KillerAbilityComponent_IsOnCooldown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.KillerAbilityComponent.PlayAudioOnOwningKiller
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class UAkAudioEvent*                    AudioEvent                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OnlyPlayIfLocallyObserved                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerAbilityComponent::PlayAudioOnOwningKiller(class UAkAudioEvent* AudioEvent, bool OnlyPlayIfLocallyObserved) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityComponent", "PlayAudioOnOwningKiller");

	Params::KillerAbilityComponent_PlayAudioOnOwningKiller Parms{};

	Parms.AudioEvent = AudioEvent;
	Parms.OnlyPlayIfLocallyObserved = OnlyPlayIfLocallyObserved;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.KillerAbilityData.GetCooldown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKillerAbilityData::GetCooldown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityData", "GetCooldown");

	Params::KillerAbilityData_GetCooldown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.KillerAbilityData.GetDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKillerAbilityData::GetDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityData", "GetDuration");

	Params::KillerAbilityData_GetDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.AuraOverriderComponent.ForceShowAura
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsAlwaysVisible                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             MinimumOutlineDistanceVisible                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             MinimumOutlineDistance                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuraOverriderComponent::ForceShowAura(const class AActor* Actor, const struct FLinearColor& Color, bool IsAlwaysVisible, const float MinimumOutlineDistanceVisible, const float MinimumOutlineDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuraOverriderComponent", "ForceShowAura");

	Params::AuraOverriderComponent_ForceShowAura Parms{};

	Parms.Actor = Actor;
	Parms.Color = std::move(Color);
	Parms.IsAlwaysVisible = IsAlwaysVisible;
	Parms.MinimumOutlineDistanceVisible = MinimumOutlineDistanceVisible;
	Parms.MinimumOutlineDistance = MinimumOutlineDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.AuraOverriderComponent.ResetAura
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuraOverriderComponent::ResetAura(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuraOverriderComponent", "ResetAura");

	Params::AuraOverriderComponent_ResetAura Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FadeComponent.GetFadePercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFadeComponent::GetFadePercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FadeComponent", "GetFadePercent");

	Params::FadeComponent_GetFadePercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.PoseableHusk.CapturePose
// (Final, Native, Public, BlueprintCallable)

void APoseableHusk::CapturePose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PoseableHusk", "CapturePose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PoseableHusk.Cosmetic_OnAnimationPoseCaptured
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void APoseableHusk::Cosmetic_OnAnimationPoseCaptured()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PoseableHusk", "Cosmetic_OnAnimationPoseCaptured");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.PoseableHusk.OnActiveStateChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    IsActive                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APoseableHusk::OnActiveStateChanged(bool IsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PoseableHusk", "OnActiveStateChanged");

	Params::PoseableHusk_OnActiveStateChanged Parms{};

	Parms.IsActive = IsActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.PoseableHusk.SetIsActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsActive                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APoseableHusk::SetIsActive(bool IsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PoseableHusk", "SetIsActive");

	Params::PoseableHusk_SetIsActive Parms{};

	Parms.IsActive = IsActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PoseableHusk.GetIsActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APoseableHusk::GetIsActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PoseableHusk", "GetIsActive");

	Params::PoseableHusk_GetIsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.ActorNavMovementComponent.SetAcceleration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Acceleration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorNavMovementComponent::SetAcceleration(float Acceleration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorNavMovementComponent", "SetAcceleration");

	Params::ActorNavMovementComponent_SetAcceleration Parms{};

	Parms.Acceleration = Acceleration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.ActorNavMovementComponent.SetDeceleration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Deceleration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorNavMovementComponent::SetDeceleration(float Deceleration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorNavMovementComponent", "SetDeceleration");

	Params::ActorNavMovementComponent_SetDeceleration Parms{};

	Parms.Deceleration = Deceleration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.ActorNavMovementComponent.SetMaxSpeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   MaxSpeed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorNavMovementComponent::SetMaxSpeed(float MaxSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorNavMovementComponent", "SetMaxSpeed");

	Params::ActorNavMovementComponent_SetMaxSpeed Parms{};

	Parms.MaxSpeed = MaxSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.ActorNavMovementComponent.GetOwningActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UActorNavMovementComponent::GetOwningActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorNavMovementComponent", "GetOwningActor");

	Params::ActorNavMovementComponent_GetOwningActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.KillerProjectileAbilityProjectile.Cosmetic_OnCollisionDetected
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// EPhysicalSurface                        SurfaceType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKillerProjectileAbilityProjectile::Cosmetic_OnCollisionDetected(EPhysicalSurface SurfaceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerProjectileAbilityProjectile", "Cosmetic_OnCollisionDetected");

	Params::KillerProjectileAbilityProjectile_Cosmetic_OnCollisionDetected Parms{};

	Parms.SurfaceType = SurfaceType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.KillerProjectileAbilityProjectile.Cosmetic_OnLaunchNoImpact
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void AKillerProjectileAbilityProjectile::Cosmetic_OnLaunchNoImpact()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerProjectileAbilityProjectile", "Cosmetic_OnLaunchNoImpact");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.KillerProjectileAbilityProjectile.Cosmetic_OnPlayerDetected
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void AKillerProjectileAbilityProjectile::Cosmetic_OnPlayerDetected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerProjectileAbilityProjectile", "Cosmetic_OnPlayerDetected");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.KillerProjectileAbilityProjectile.Cosmetic_OnSlashableDetected
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void AKillerProjectileAbilityProjectile::Cosmetic_OnSlashableDetected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerProjectileAbilityProjectile", "Cosmetic_OnSlashableDetected");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.KillerProjectileAbilityProjectile.OnAcquiredChanged
// (Final, Native, Private)
// Parameters:
// bool                                    IsAcquired                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKillerProjectileAbilityProjectile::OnAcquiredChanged(bool IsAcquired)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerProjectileAbilityProjectile", "OnAcquiredChanged");

	Params::KillerProjectileAbilityProjectile_OnAcquiredChanged Parms{};

	Parms.IsAcquired = IsAcquired;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.KillerProjectileAbilityProjectile.OnActivationChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKillerProjectileAbilityProjectile::OnActivationChanged(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerProjectileAbilityProjectile", "OnActivationChanged");

	Params::KillerProjectileAbilityProjectile_OnActivationChanged Parms{};

	Parms.Enabled = Enabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.KillerProjectileAbilityProjectile.OnComponentHit
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComponent                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AKillerProjectileAbilityProjectile::OnComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, const struct FVector& NormalImpulse, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerProjectileAbilityProjectile", "OnComponentHit");

	Params::KillerProjectileAbilityProjectile_OnComponentHit Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComponent = OtherComponent;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.KillerProjectileAbility.OnRep_AbilityProjectileLauncher
// (Final, Native, Private)

void UKillerProjectileAbility::OnRep_AbilityProjectileLauncher()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerProjectileAbility", "OnRep_AbilityProjectileLauncher");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.KillerProjectileAbility.OnRep_ProjectilePool
// (Final, Native, Private)

void UKillerProjectileAbility::OnRep_ProjectilePool()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerProjectileAbility", "OnRep_ProjectilePool");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.ProjectileAbilityKillerCosmeticHelperActor.Cosmetic_OnChargeThrowStarted
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void AProjectileAbilityKillerCosmeticHelperActor::Cosmetic_OnChargeThrowStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileAbilityKillerCosmeticHelperActor", "Cosmetic_OnChargeThrowStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.ProjectileAbilityKillerCosmeticHelperActor.Cosmetic_OnThrowCancelled
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void AProjectileAbilityKillerCosmeticHelperActor::Cosmetic_OnThrowCancelled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileAbilityKillerCosmeticHelperActor", "Cosmetic_OnThrowCancelled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.ProjectileAbilityKillerCosmeticHelperActor.Cosmetic_OnThrowSuccess
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void AProjectileAbilityKillerCosmeticHelperActor::Cosmetic_OnThrowSuccess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileAbilityKillerCosmeticHelperActor", "Cosmetic_OnThrowSuccess");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.TargetingTeleportInteraction.Server_SetTeleportTarget
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// class UTargetableComponent*             Target                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTargetingTeleportInteraction::Server_SetTeleportTarget(class UTargetableComponent* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetingTeleportInteraction", "Server_SetTeleportTarget");

	Params::TargetingTeleportInteraction_Server_SetTeleportTarget Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.BlindAndDeafenRangedExplosiveActorEffect.Authority_TryToBlind
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class UBlindableBaseComponent*          BlindableComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           effectorActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlindAndDeafenRangedExplosiveActorEffect::Authority_TryToBlind(class UBlindableBaseComponent* BlindableComponent, class AActor* effectorActor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlindAndDeafenRangedExplosiveActorEffect", "Authority_TryToBlind");

	Params::BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToBlind Parms{};

	Parms.BlindableComponent = BlindableComponent;
	Parms.effectorActor = effectorActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.BlindAndDeafenRangedExplosiveActorEffect.Authority_TryToDeafen
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioFXComponent*                AudioFXComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlindAndDeafenRangedExplosiveActorEffect::Authority_TryToDeafen(const class ADBDPlayer* Player, class UAudioFXComponent* AudioFXComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlindAndDeafenRangedExplosiveActorEffect", "Authority_TryToDeafen");

	Params::BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToDeafen Parms{};

	Parms.Player = Player;
	Parms.AudioFXComponent = AudioFXComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.BlindAndDeafenRangedExplosiveActorEffect.GetBlindnessEffectDuration
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AActor*                     Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBlindAndDeafenRangedExplosiveActorEffect::GetBlindnessEffectDuration(const class AActor* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlindAndDeafenRangedExplosiveActorEffect", "GetBlindnessEffectDuration");

	Params::BlindAndDeafenRangedExplosiveActorEffect_GetBlindnessEffectDuration Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.BlindAndDeafenRangedExplosiveActorEffect.GetDeafnessEffectDuration
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AActor*                     Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBlindAndDeafenRangedExplosiveActorEffect::GetDeafnessEffectDuration(const class AActor* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlindAndDeafenRangedExplosiveActorEffect", "GetDeafnessEffectDuration");

	Params::BlindAndDeafenRangedExplosiveActorEffect_GetDeafnessEffectDuration Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.BubbleIndicatorNotifier.ActivateBubbleIndicator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABubbleIndicator*                 BubbleIndicator                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                Transform                                              (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TriggerLoudNoise                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Lifetime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   audibleRange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBubbleIndicatorNotifier::ActivateBubbleIndicator(class UObject* WorldContextObject, class ABubbleIndicator* BubbleIndicator, const struct FTransform& Transform, bool TriggerLoudNoise, float Lifetime, float audibleRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BubbleIndicatorNotifier", "ActivateBubbleIndicator");

	Params::BubbleIndicatorNotifier_ActivateBubbleIndicator Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.BubbleIndicator = BubbleIndicator;
	Parms.Transform = std::move(Transform);
	Parms.TriggerLoudNoise = TriggerLoudNoise;
	Parms.Lifetime = Lifetime;
	Parms.audibleRange = audibleRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.BubbleIndicatorNotifier.PreSpawnBubbleIndicator
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ABubbleIndicator>     bubbleIndicatorBP                                      (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                      silhouetteStaticMesh                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABubbleIndicator*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABubbleIndicator* UBubbleIndicatorNotifier::PreSpawnBubbleIndicator(class UObject* WorldContextObject, TSubclassOf<class ABubbleIndicator> bubbleIndicatorBP, class UStaticMesh* silhouetteStaticMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BubbleIndicatorNotifier", "PreSpawnBubbleIndicator");

	Params::BubbleIndicatorNotifier_PreSpawnBubbleIndicator Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bubbleIndicatorBP = bubbleIndicatorBP;
	Parms.silhouetteStaticMesh = silhouetteStaticMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.BubbleIndicatorNotifier.SpawnBubbleIndicator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ABubbleIndicator>     bubbleIndicatorBP                                      (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                Transform                                              (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TriggerLoudNoise                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBubbleShowedPlayerType                 showedPlayerType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Lifetime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                      silhouetteStaticMesh                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   audibleRange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBubbleIndicatorNotifier::SpawnBubbleIndicator(class UObject* WorldContextObject, TSubclassOf<class ABubbleIndicator> bubbleIndicatorBP, const struct FTransform& Transform, bool TriggerLoudNoise, EBubbleShowedPlayerType showedPlayerType, float Lifetime, class UStaticMesh* silhouetteStaticMesh, float audibleRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BubbleIndicatorNotifier", "SpawnBubbleIndicator");

	Params::BubbleIndicatorNotifier_SpawnBubbleIndicator Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bubbleIndicatorBP = bubbleIndicatorBP;
	Parms.Transform = std::move(Transform);
	Parms.TriggerLoudNoise = TriggerLoudNoise;
	Parms.showedPlayerType = showedPlayerType;
	Parms.Lifetime = Lifetime;
	Parms.silhouetteStaticMesh = silhouetteStaticMesh;
	Parms.audibleRange = audibleRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.KillerFormSwitchingAbility.Cosmetic_OnCurrentFormChanged
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    isStartingForm                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerFormSwitchingAbility::Cosmetic_OnCurrentFormChanged(bool isStartingForm)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerFormSwitchingAbility", "Cosmetic_OnCurrentFormChanged");

	Params::KillerFormSwitchingAbility_Cosmetic_OnCurrentFormChanged Parms{};

	Parms.isStartingForm = isStartingForm;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.KillerFormSwitchingAbility.Cosmetic_OnEnterForm
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              formID                                                 (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isStartingForm                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerFormSwitchingAbility::Cosmetic_OnEnterForm(const struct FGameplayTag& formID, bool isStartingForm)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerFormSwitchingAbility", "Cosmetic_OnEnterForm");

	Params::KillerFormSwitchingAbility_Cosmetic_OnEnterForm Parms{};

	Parms.formID = std::move(formID);
	Parms.isStartingForm = isStartingForm;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.KillerFormSwitchingAbility.Cosmetic_OnExitForm
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              formID                                                 (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerFormSwitchingAbility::Cosmetic_OnExitForm(const struct FGameplayTag& formID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerFormSwitchingAbility", "Cosmetic_OnExitForm");

	Params::KillerFormSwitchingAbility_Cosmetic_OnExitForm Parms{};

	Parms.formID = std::move(formID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.KillerFormSwitchingAbility.GetTransitionDuration
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKillerFormSwitchingAbility::GetTransitionDuration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerFormSwitchingAbility", "GetTransitionDuration");

	Params::KillerFormSwitchingAbility_GetTransitionDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.KillerFormSwitchingAbility.OnRep_CurrentFormID
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayTag&              oldFormId                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerFormSwitchingAbility::OnRep_CurrentFormID(const struct FGameplayTag& oldFormId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerFormSwitchingAbility", "OnRep_CurrentFormID");

	Params::KillerFormSwitchingAbility_OnRep_CurrentFormID Parms{};

	Parms.oldFormId = std::move(oldFormId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.KillerFormSwitchingAbility.GetCurrentFormID
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UKillerFormSwitchingAbility::GetCurrentFormID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerFormSwitchingAbility", "GetCurrentFormID");

	Params::KillerFormSwitchingAbility_GetCurrentFormID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.RangedExplosive.Multicast_InitFromSpawningPlayer
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ADBDPlayer*                       spawner                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARangedExplosive::Multicast_InitFromSpawningPlayer(class ADBDPlayer* spawner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangedExplosive", "Multicast_InitFromSpawningPlayer");

	Params::RangedExplosive_Multicast_InitFromSpawningPlayer Parms{};

	Parms.spawner = spawner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RangedExplosive.OnExplode_BP
// (Event, Protected, BlueprintEvent)

void ARangedExplosive::OnExplode_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangedExplosive", "OnExplode_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.RangedExplosive.OnFuseBurnEnter
// (Event, Protected, BlueprintEvent)

void ARangedExplosive::OnFuseBurnEnter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangedExplosive", "OnFuseBurnEnter");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.RangedExplosive.OnFuseBurnExit
// (Event, Protected, BlueprintEvent)

void ARangedExplosive::OnFuseBurnExit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangedExplosive", "OnFuseBurnExit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.RangedExplosive.OnFuseBurnUpdate
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   fuseTimeLeftPercent                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARangedExplosive::OnFuseBurnUpdate(float DeltaSeconds, float fuseTimeLeftPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangedExplosive", "OnFuseBurnUpdate");

	Params::RangedExplosive_OnFuseBurnUpdate Parms{};

	Parms.DeltaSeconds = DeltaSeconds;
	Parms.fuseTimeLeftPercent = fuseTimeLeftPercent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.RangedExplosive.GetExplosionEffectDuration
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARangedExplosive::GetExplosionEffectDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangedExplosive", "GetExplosionEffectDuration");

	Params::RangedExplosive_GetExplosionEffectDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.RangedExplosive.GetExplosionRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARangedExplosive::GetExplosionRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangedExplosive", "GetExplosionRange");

	Params::RangedExplosive_GetExplosionRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.RangedExplosive.GetModifierValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              Type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARangedExplosive::GetModifierValue(const struct FGameplayTag& Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangedExplosive", "GetModifierValue");

	Params::RangedExplosive_GetModifierValue Parms{};

	Parms.Type = std::move(Type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.RangedExplosive.GetOwningPlayer
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* ARangedExplosive::GetOwningPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangedExplosive", "GetOwningPlayer");

	Params::RangedExplosive_GetOwningPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.RangedExplosive.GetRangedExplosiveActorEffect
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBaseRangedExplosiveActorEffect*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBaseRangedExplosiveActorEffect* ARangedExplosive::GetRangedExplosiveActorEffect() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangedExplosive", "GetRangedExplosiveActorEffect");

	Params::RangedExplosive_GetRangedExplosiveActorEffect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.CageHookPoolComponent.Multicast_SpawnTrapBlocker
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, HasDefaults)
// Parameters:
// const TArray<struct FTransform>&        spawnLocations                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FVector&                   BoxExtent                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCageHookPoolComponent::Multicast_SpawnTrapBlocker(const TArray<struct FTransform>& spawnLocations, const struct FVector& BoxExtent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHookPoolComponent", "Multicast_SpawnTrapBlocker");

	Params::CageHookPoolComponent_Multicast_SpawnTrapBlocker Parms{};

	Parms.spawnLocations = std::move(spawnLocations);
	Parms.BoxExtent = std::move(BoxExtent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.LimitGeneratorRegressionEventComponent.OnKillerProximityZoneForRegressionEventsOverlapBegin
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULimitGeneratorRegressionEventComponent::OnKillerProximityZoneForRegressionEventsOverlapBegin(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LimitGeneratorRegressionEventComponent", "OnKillerProximityZoneForRegressionEventsOverlapBegin");

	Params::LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.LimitGeneratorRegressionEventComponent.OnKillerProximityZoneForRegressionEventsOverlapEnd
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULimitGeneratorRegressionEventComponent::OnKillerProximityZoneForRegressionEventsOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LimitGeneratorRegressionEventComponent", "OnKillerProximityZoneForRegressionEventsOverlapEnd");

	Params::LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapEnd Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.LimitGeneratorRegressionEventComponent.OnRep_RegressionEventsSuffered
// (Final, Native, Private)

void ULimitGeneratorRegressionEventComponent::OnRep_RegressionEventsSuffered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LimitGeneratorRegressionEventComponent", "OnRep_RegressionEventsSuffered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.LimitGeneratorRegressionEventComponent.GetMaxNumberRegressionEventsAllowed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULimitGeneratorRegressionEventComponent::GetMaxNumberRegressionEventsAllowed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LimitGeneratorRegressionEventComponent", "GetMaxNumberRegressionEventsAllowed");

	Params::LimitGeneratorRegressionEventComponent_GetMaxNumberRegressionEventsAllowed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.PalletTrackerVisibilityComponent.Cosmetic_OnPalletTrackerSelectedChanged
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    Selected                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPalletTrackerVisibilityComponent::Cosmetic_OnPalletTrackerSelectedChanged(bool Selected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PalletTrackerVisibilityComponent", "Cosmetic_OnPalletTrackerSelectedChanged");

	Params::PalletTrackerVisibilityComponent_Cosmetic_OnPalletTrackerSelectedChanged Parms{};

	Parms.Selected = Selected;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.PalletTrackerVisibilityComponent.Cosmetic_OnVisibilityChanged
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    IsVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPalletTrackerVisibilityComponent::Cosmetic_OnVisibilityChanged(bool IsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PalletTrackerVisibilityComponent", "Cosmetic_OnVisibilityChanged");

	Params::PalletTrackerVisibilityComponent_Cosmetic_OnVisibilityChanged Parms{};

	Parms.IsVisible = IsVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.PalletTrackerVisibilityComponent.OnLocallyObservedChanged
// (Final, Native, Private)

void UPalletTrackerVisibilityComponent::OnLocallyObservedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PalletTrackerVisibilityComponent", "OnLocallyObservedChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PalletTrackerVisibilityComponent.GetPalletTrackerOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APalletTracker*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APalletTracker* UPalletTrackerVisibilityComponent::GetPalletTrackerOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PalletTrackerVisibilityComponent", "GetPalletTrackerOwner");

	Params::PalletTrackerVisibilityComponent_GetPalletTrackerOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.PowerChargeComponent.OnCurrentChargeChanged
// (Final, Native, Private)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPowerChargeComponent::OnCurrentChargeChanged(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PowerChargeComponent", "OnCurrentChargeChanged");

	Params::PowerChargeComponent_OnCurrentChargeChanged Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PowerChargeComponent.OnRep_CurrentCharge
// (Final, Native, Private)

void UPowerChargeComponent::OnRep_CurrentCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PowerChargeComponent", "OnRep_CurrentCharge");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.AimableComponent.SetMaxAimDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   maxAimDistance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAimableComponent::SetMaxAimDistance(float maxAimDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimableComponent", "SetMaxAimDistance");

	Params::AimableComponent_SetMaxAimDistance Parms{};

	Parms.maxAimDistance = maxAimDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.AimableComponent.SetOcclusionIgnoredActors
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class AActor*>&            IgnoredActors                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UAimableComponent::SetOcclusionIgnoredActors(const TArray<class AActor*>& IgnoredActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimableComponent", "SetOcclusionIgnoredActors");

	Params::AimableComponent_SetOcclusionIgnoredActors Parms{};

	Parms.IgnoredActors = std::move(IgnoredActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.AimableComponent.SetProcessors
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class UAimPointProcessor*>&processors                                             (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAimableComponent::SetProcessors(const TArray<class UAimPointProcessor*>& processors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimableComponent", "SetProcessors");

	Params::AimableComponent_SetProcessors Parms{};

	Parms.processors = std::move(processors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.BubbleIndicator.ActivateBubbleFX
// (Event, Public, BlueprintEvent)
// Parameters:
// const float                             Duration                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABubbleIndicator::ActivateBubbleFX(const float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BubbleIndicator", "ActivateBubbleFX");

	Params::BubbleIndicator_ActivateBubbleFX Parms{};

	Parms.Duration = Duration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.BubbleIndicator.DeactivateBubble
// (Final, Native, Protected, BlueprintCallable)

void ABubbleIndicator::DeactivateBubble()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BubbleIndicator", "DeactivateBubble");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.BubbleIndicator.RefreshBubbleVisibility
// (Event, Public, BlueprintEvent)
// Parameters:
// const bool                              IsVisible                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABubbleIndicator::RefreshBubbleVisibility(const bool IsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BubbleIndicator", "RefreshBubbleVisibility");

	Params::BubbleIndicator_RefreshBubbleVisibility Parms{};

	Parms.IsVisible = IsVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.BubbleIndicator.SetSilhouette
// (Event, Public, BlueprintEvent)
// Parameters:
// class UStaticMesh*                      StaticMesh                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABubbleIndicator::SetSilhouette(class UStaticMesh* StaticMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BubbleIndicator", "SetSilhouette");

	Params::BubbleIndicator_SetSilhouette Parms{};

	Parms.StaticMesh = StaticMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.KillerProjectileAbilityInterface.Cosmetic_SetProjectileVisibility
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// const bool                              Visible                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IKillerProjectileAbilityInterface::Cosmetic_SetProjectileVisibility(const bool Visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("KillerProjectileAbilityInterface", "Cosmetic_SetProjectileVisibility");

	Params::KillerProjectileAbilityInterface_Cosmetic_SetProjectileVisibility Parms{};

	Parms.Visible = Visible;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.SteamPipeEffectComponent.Authority_OnHealthStateChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              GameplayTag                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void USteamPipeEffectComponent::Authority_OnHealthStateChanged(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipeEffectComponent", "Authority_OnHealthStateChanged");

	Params::SteamPipeEffectComponent_Authority_OnHealthStateChanged Parms{};

	Parms.GameplayTag = std::move(GameplayTag);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.SteamPipeEffectComponent.Authority_OnStoppedCrouching
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              GameplayTag                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void USteamPipeEffectComponent::Authority_OnStoppedCrouching(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipeEffectComponent", "Authority_OnStoppedCrouching");

	Params::SteamPipeEffectComponent_Authority_OnStoppedCrouching Parms{};

	Parms.GameplayTag = std::move(GameplayTag);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.AimPointPerlinNoise.SetBaseInaccuracyNoiseAmplitude
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Amplitude                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAimPointPerlinNoise::SetBaseInaccuracyNoiseAmplitude(const float Amplitude)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimPointPerlinNoise", "SetBaseInaccuracyNoiseAmplitude");

	Params::AimPointPerlinNoise_SetBaseInaccuracyNoiseAmplitude Parms{};

	Parms.Amplitude = Amplitude;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.AimPointPerlinNoise.SetBaseInaccuracyNoiseFrequency
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Frequency                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAimPointPerlinNoise::SetBaseInaccuracyNoiseFrequency(const float Frequency)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimPointPerlinNoise", "SetBaseInaccuracyNoiseFrequency");

	Params::AimPointPerlinNoise_SetBaseInaccuracyNoiseFrequency Parms{};

	Parms.Frequency = Frequency;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.AimPointPerlinNoise.SetBaseInaccuracyNoiseOctaveCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             octaveCount                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAimPointPerlinNoise::SetBaseInaccuracyNoiseOctaveCount(const int32 octaveCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimPointPerlinNoise", "SetBaseInaccuracyNoiseOctaveCount");

	Params::AimPointPerlinNoise_SetBaseInaccuracyNoiseOctaveCount Parms{};

	Parms.octaveCount = octaveCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.AimPointPerlinNoise.SetBaseInaccuracyNoisePersistence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             noisePersistence                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAimPointPerlinNoise::SetBaseInaccuracyNoisePersistence(const float noisePersistence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimPointPerlinNoise", "SetBaseInaccuracyNoisePersistence");

	Params::AimPointPerlinNoise_SetBaseInaccuracyNoisePersistence Parms{};

	Parms.noisePersistence = noisePersistence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.AimPointPerlinNoise.SetNoiseAmplitudeMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Multiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAimPointPerlinNoise::SetNoiseAmplitudeMultiplier(const float Multiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimPointPerlinNoise", "SetNoiseAmplitudeMultiplier");

	Params::AimPointPerlinNoise_SetNoiseAmplitudeMultiplier Parms{};

	Parms.Multiplier = Multiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.AimPointPerlinNoise.SetNoiseFrequencyMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             Multiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAimPointPerlinNoise::SetNoiseFrequencyMultiplier(const float Multiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimPointPerlinNoise", "SetNoiseFrequencyMultiplier");

	Params::AimPointPerlinNoise_SetNoiseFrequencyMultiplier Parms{};

	Parms.Multiplier = Multiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.AISense_Terror.ReportTerrorEvent
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          worldContextObj                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTerrorRadiusEmitterComponent*    TerrorEmitter                                          (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAISense_Terror::ReportTerrorEvent(class UObject* worldContextObj, const struct FVector& Location, class AActor* Instigator, class UTerrorRadiusEmitterComponent* TerrorEmitter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AISense_Terror", "ReportTerrorEvent");

	Params::AISense_Terror_ReportTerrorEvent Parms{};

	Parms.worldContextObj = worldContextObj;
	Parms.Location = std::move(Location);
	Parms.Instigator = Instigator;
	Parms.TerrorEmitter = TerrorEmitter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.AttachKillerSpecificVaultComponent.OnLevelReadyToPlay
// (Final, Native, Private)

void UAttachKillerSpecificVaultComponent::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttachKillerSpecificVaultComponent", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.BaseActorAttackableComponent.HitWithProjectile
// (Native, Public, BlueprintCallable)
// Parameters:
// class ABaseProjectile*                  Projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseActorAttackableComponent::HitWithProjectile(class ABaseProjectile* Projectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseActorAttackableComponent", "HitWithProjectile");

	Params::BaseActorAttackableComponent_HitWithProjectile Parms{};

	Parms.Projectile = Projectile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.BlockFeedbackComponent.OnLocallyObservedChanged
// (Final, Native, Private)

void UBlockFeedbackComponent::OnLocallyObservedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlockFeedbackComponent", "OnLocallyObservedChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.CollectableComponentUtilities.GetCollector
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UActorComponent*            Component                                              (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UCollectableComponentUtilities::GetCollector(const class UActorComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CollectableComponentUtilities", "GetCollector");

	Params::CollectableComponentUtilities_GetCollector Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.DBDCustomCheatComponent.OnCustomCheatCalledOnManager
// (Final, Native, Protected)
// Parameters:
// const class FName                       customCheatName                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDCustomCheatComponent::OnCustomCheatCalledOnManager(const class FName customCheatName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDCustomCheatComponent", "OnCustomCheatCalledOnManager");

	Params::DBDCustomCheatComponent_OnCustomCheatCalledOnManager Parms{};

	Parms.customCheatName = customCheatName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.DBDCustomCheatManager.DBD_CallCustomCheat
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// const class FName&                      customCheatName                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDCustomCheatManager::DBD_CallCustomCheat(const class FName& customCheatName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDCustomCheatManager", "DBD_CallCustomCheat");

	Params::DBDCustomCheatManager_DBD_CallCustomCheat Parms{};

	Parms.customCheatName = customCheatName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.DebugIndicator.SetColor
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FLinearColor&              Color                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADebugIndicator::SetColor(const struct FLinearColor& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugIndicator", "SetColor");

	Params::DebugIndicator_SetColor Parms{};

	Parms.Color = std::move(Color);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.DebugIndicator.SetVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              Visible                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADebugIndicator::SetVisible(const bool Visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugIndicator", "SetVisible");

	Params::DebugIndicator_SetVisible Parms{};

	Parms.Visible = Visible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.DebugTimerLogComponent.OnRep_TimerCountdown
// (Final, Native, Private)

void UDebugTimerLogComponent::OnRep_TimerCountdown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugTimerLogComponent", "OnRep_TimerCountdown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.EndGameEffectsComponent.OnLocallyObservedChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEndGameEffectsComponent::OnLocallyObservedChanged(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameEffectsComponent", "OnLocallyObservedChanged");

	Params::EndGameEffectsComponent_OnLocallyObservedChanged Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.EndGameEffectsComponent.RegisterLocallyObservedEvents
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void UEndGameEffectsComponent::RegisterLocallyObservedEvents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameEffectsComponent", "RegisterLocallyObservedEvents");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.EndGameEffectsComponent.StartUpdateTimer
// (Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UEndGameEffectsComponent::StartUpdateTimer(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameEffectsComponent", "StartUpdateTimer");

	Params::EndGameEffectsComponent_StartUpdateTimer Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.GameEventData = std::move(GameEventData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.EndGameEffectsComponent.UnregisterLocallyObservedEvents
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void UEndGameEffectsComponent::UnregisterLocallyObservedEvents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameEffectsComponent", "UnregisterLocallyObservedEvents");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.EtherealComponent.OnRep_OnIsEtherealChanged
// (Final, Native, Private)

void UEtherealComponent::OnRep_OnIsEtherealChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EtherealComponent", "OnRep_OnIsEtherealChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.EtherealComponent.Server_SetIsEthereal
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// float                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Ethereal                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEtherealComponent::Server_SetIsEthereal(float Timestamp, bool Ethereal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EtherealComponent", "Server_SetIsEthereal");

	Params::EtherealComponent_Server_SetIsEthereal Parms{};

	Parms.Timestamp = Timestamp;
	Parms.Ethereal = Ethereal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RangeToActorsTrackerStrategy.OnInRangeToTrackedActorsChanged
// (Final, Native, Private)
// Parameters:
// const bool                              inRange                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URangeToActorsTrackerStrategy::OnInRangeToTrackedActorsChanged(const bool inRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangeToActorsTrackerStrategy", "OnInRangeToTrackedActorsChanged");

	Params::RangeToActorsTrackerStrategy_OnInRangeToTrackedActorsChanged Parms{};

	Parms.inRange = inRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FadingBlockFeedback.OnFadeOutEnded
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void AFadingBlockFeedback::OnFadeOutEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FadingBlockFeedback", "OnFadeOutEnded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.FadingBlockFeedback.OnFadeOutStarted
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// const float                             fadeDuration                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFadingBlockFeedback::OnFadeOutStarted(const float fadeDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FadingBlockFeedback", "OnFadeOutStarted");

	Params::FadingBlockFeedback_OnFadeOutStarted Parms{};

	Parms.fadeDuration = fadeDuration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.FatherTerminalHackingInteraction.Authority_OnCoolDownTimerDone
// (Final, Native, Private)

void UFatherTerminalHackingInteraction::Authority_OnCoolDownTimerDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FatherTerminalHackingInteraction", "Authority_OnCoolDownTimerDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FatherTerminalHackingInteraction.Authority_OnMinigameEnd
// (Final, Native, Private)
// Parameters:
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDirectionalMinigameResult              Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFatherTerminalHackingInteraction::Authority_OnMinigameEnd(class ASurvivor* Survivor, EDirectionalMinigameResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FatherTerminalHackingInteraction", "Authority_OnMinigameEnd");

	Params::FatherTerminalHackingInteraction_Authority_OnMinigameEnd Parms{};

	Parms.Survivor = Survivor;
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FatherTerminalHackingInteraction.OnRep_IsCooldownTimerRunning
// (Final, Native, Private)

void UFatherTerminalHackingInteraction::OnRep_IsCooldownTimerRunning()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FatherTerminalHackingInteraction", "OnRep_IsCooldownTimerRunning");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.Flashlight.GetSpotlightComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USpotLightComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USpotLightComponent* AFlashlight::GetSpotlightComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Flashlight", "GetSpotlightComponent");

	Params::Flashlight_GetSpotlightComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.FlashlightableComponent.IsLit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlashlightableComponent::IsLit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightableComponent", "IsLit");

	Params::FlashlightableComponent_IsLit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.FlashlightConeComponent.GetEffectiveConeHalfAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFlashlightConeComponent::GetEffectiveConeHalfAngle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightConeComponent", "GetEffectiveConeHalfAngle");

	Params::FlashlightConeComponent_GetEffectiveConeHalfAngle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.FlashlightConeComponent.GetEffectiveConeLength
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFlashlightConeComponent::GetEffectiveConeLength() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightConeComponent", "GetEffectiveConeLength");

	Params::FlashlightConeComponent_GetEffectiveConeLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.FlashlightConeComponent.GetOcclusionDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFlashlightConeComponent::GetOcclusionDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightConeComponent", "GetOcclusionDistance");

	Params::FlashlightConeComponent_GetOcclusionDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.FlashlightFXComponent.OnCollectedEvent
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       collector                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlashlightFXComponent::OnCollectedEvent(class ADBDPlayer* collector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightFXComponent", "OnCollectedEvent");

	Params::FlashlightFXComponent_OnCollectedEvent Parms{};

	Parms.collector = collector;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.FlashlightFXComponent.OnCollectorLocallyObservedChangedEvent
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    IsLocallyObserved                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlashlightFXComponent::OnCollectorLocallyObservedChangedEvent(bool IsLocallyObserved)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightFXComponent", "OnCollectorLocallyObservedChangedEvent");

	Params::FlashlightFXComponent_OnCollectorLocallyObservedChangedEvent Parms{};

	Parms.IsLocallyObserved = IsLocallyObserved;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.FlashlightFXComponent.OnDroppedEvent
// (Event, Protected, BlueprintEvent)

void UFlashlightFXComponent::OnDroppedEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightFXComponent", "OnDroppedEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.FlashlightFXComponent.OnStartEvent
// (Event, Protected, BlueprintEvent)

void UFlashlightFXComponent::OnStartEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightFXComponent", "OnStartEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.FlashlightFXComponent.OnStopEvent
// (Event, Protected, BlueprintEvent)

void UFlashlightFXComponent::OnStopEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightFXComponent", "OnStopEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.FlashlightFXComponent.OnTurnedOff
// (Final, Native, Private)

void UFlashlightFXComponent::OnTurnedOff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightFXComponent", "OnTurnedOff");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FlashlightFXComponent.OnTurnedOn
// (Final, Native, Private)

void UFlashlightFXComponent::OnTurnedOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightFXComponent", "OnTurnedOn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FlashlightFXComponent.PostUpdateEvent
// (Event, Protected, BlueprintEvent)

void UFlashlightFXComponent::PostUpdateEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightFXComponent", "PostUpdateEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.FlashlightFXComponent.UpdateConeEvent
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   Length                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   halfAngle                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlashlightFXComponent::UpdateConeEvent(float Length, float halfAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightFXComponent", "UpdateConeEvent");

	Params::FlashlightFXComponent_UpdateConeEvent Parms{};

	Parms.Length = Length;
	Parms.halfAngle = halfAngle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.FlashlightFXComponent.UpdateFXTargets
// (Final, Native, Private)

void UFlashlightFXComponent::UpdateFXTargets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightFXComponent", "UpdateFXTargets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FlashlightFXComponent.GetBlindingSuccessRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFlashlightFXComponent::GetBlindingSuccessRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightFXComponent", "GetBlindingSuccessRatio");

	Params::FlashlightFXComponent_GetBlindingSuccessRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.FootstepManagerComponent.OnUpdateCreatorFootsteps
// (Final, Native, Public)
// Parameters:
// class UFootstepCreatorComponent*        creator                                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFootstepManagerComponent::OnUpdateCreatorFootsteps(class UFootstepCreatorComponent* creator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FootstepManagerComponent", "OnUpdateCreatorFootsteps");

	Params::FootstepManagerComponent_OnUpdateCreatorFootsteps Parms{};

	Parms.creator = creator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FootstepManagerComponent.OnUpdateObserverFootsteps
// (Final, Native, Public)

void UFootstepManagerComponent::OnUpdateObserverFootsteps()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FootstepManagerComponent", "OnUpdateObserverFootsteps");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FootstepManagerComponent.TriggerSpawnFootstep
// (Final, Native, Public, HasDefaults)
// Parameters:
// class UFootstepCreatorComponent*        originatorComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFootstepManagerComponent::TriggerSpawnFootstep(class UFootstepCreatorComponent* originatorComponent, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FootstepManagerComponent", "TriggerSpawnFootstep");

	Params::FootstepManagerComponent_TriggerSpawnFootstep Parms{};

	Parms.originatorComponent = originatorComponent;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.GeneratorWithMostProgressTracker.OnGeneratorCompleted
// (Final, Native, Private)
// Parameters:
// bool                                    isAutoCompleted                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorWithMostProgressTracker::OnGeneratorCompleted(bool isAutoCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorWithMostProgressTracker", "OnGeneratorCompleted");

	Params::GeneratorWithMostProgressTracker_OnGeneratorCompleted Parms{};

	Parms.isAutoCompleted = isAutoCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.GeneratorWithMostProgressTracker.OnLevelReadyToPlay
// (Final, Native, Private)

void UGeneratorWithMostProgressTracker::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorWithMostProgressTracker", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.IgnorePalletsCollisionsComponent.OnLevelReadyToPlay
// (Final, Native, Private)

void UIgnorePalletsCollisionsComponent::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgnorePalletsCollisionsComponent", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.IgnoreWindowsCollisionsComponent.OnLevelReadyToPlay
// (Final, Native, Private)

void UIgnoreWindowsCollisionsComponent::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgnoreWindowsCollisionsComponent", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.InteractionAttacherComponent.OnRep_ChargeableComponents
// (Final, Native, Private)

void UInteractionAttacherComponent::OnRep_ChargeableComponents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionAttacherComponent", "OnRep_ChargeableComponents");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.InteractionAttacherComponent.OnRep_InteractionDefinitions
// (Final, Native, Private)

void UInteractionAttacherComponent::OnRep_InteractionDefinitions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionAttacherComponent", "OnRep_InteractionDefinitions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.InteractionStarterComponent.OnInteractionStarted
// (Final, Native, Private)

void UInteractionStarterComponent::OnInteractionStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionStarterComponent", "OnInteractionStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.InteractionStarterComponent.OnRep_ShouldStartInteraction
// (Final, Native, Private)

void UInteractionStarterComponent::OnRep_ShouldStartInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionStarterComponent", "OnRep_ShouldStartInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.KillerInstinctComponent.GetParticleSystem
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraComponent* UKillerInstinctComponent::GetParticleSystem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerInstinctComponent", "GetParticleSystem");

	Params::KillerInstinctComponent_GetParticleSystem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.KillerInstinctComponent.IsRevealedToPlayer
// (Native, Public, BlueprintCallable)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKillerInstinctComponent::IsRevealedToPlayer(const class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerInstinctComponent", "IsRevealedToPlayer");

	Params::KillerInstinctComponent_IsRevealedToPlayer Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.KillerInstinctComponent.OnKillerLocallyObservedChanged
// (Final, Native, Private)
// Parameters:
// bool                                    locallyObserved                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerInstinctComponent::OnKillerLocallyObservedChanged(bool locallyObserved)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerInstinctComponent", "OnKillerLocallyObservedChanged");

	Params::KillerInstinctComponent_OnKillerLocallyObservedChanged Parms{};

	Parms.locallyObserved = locallyObserved;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.KillerInstinctComponent.SetParticleSystem
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                ParticleSystemComponent                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerInstinctComponent::SetParticleSystem(class UNiagaraComponent* ParticleSystemComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerInstinctComponent", "SetParticleSystem");

	Params::KillerInstinctComponent_SetParticleSystem Parms{};

	Parms.ParticleSystemComponent = ParticleSystemComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.KillerPowerUtilities.GetKillerPowerFromPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AKillerPower*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AKillerPower* UKillerPowerUtilities::GetKillerPowerFromPlayer(const class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KillerPowerUtilities", "GetKillerPowerFromPlayer");

	Params::KillerPowerUtilities_GetKillerPowerFromPlayer Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.KillerProjectileAbilityChargeThrowInteraction.Cosmetic_MakeArcPreview
// (BlueprintCosmetic, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const TArray<struct FVector>&           Points                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FHitResult&                HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const bool                              shouldShowImpactPoint                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             arclengthAtImpactPoint                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerProjectileAbilityChargeThrowInteraction::Cosmetic_MakeArcPreview(const TArray<struct FVector>& Points, const struct FHitResult& HitResult, const bool shouldShowImpactPoint, const float arclengthAtImpactPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerProjectileAbilityChargeThrowInteraction", "Cosmetic_MakeArcPreview");

	Params::KillerProjectileAbilityChargeThrowInteraction_Cosmetic_MakeArcPreview Parms{};

	Parms.Points = std::move(Points);
	Parms.HitResult = std::move(HitResult);
	Parms.shouldShowImpactPoint = shouldShowImpactPoint;
	Parms.arclengthAtImpactPoint = arclengthAtImpactPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.LockerAccessInteraction.FireSoundEventFromInteractor
// (Final, Native, Public)
// Parameters:
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       instigatingPlayer                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULockerAccessInteraction::FireSoundEventFromInteractor(class AActor* Instigator, class ADBDPlayer* instigatingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LockerAccessInteraction", "FireSoundEventFromInteractor");

	Params::LockerAccessInteraction_FireSoundEventFromInteractor Parms{};

	Parms.Instigator = Instigator;
	Parms.instigatingPlayer = instigatingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.LockerAccessInteraction.SetOtherInteractorsUsable
// (Final, Native, Public)
// Parameters:
// const bool                              IsEnabled                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULockerAccessInteraction::SetOtherInteractorsUsable(const bool IsEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LockerAccessInteraction", "SetOtherInteractorsUsable");

	Params::LockerAccessInteraction_SetOtherInteractorsUsable Parms{};

	Parms.IsEnabled = IsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.LockerAccessInteraction.GetInsideInteractor
// (Final, Native, Public, Const)
// Parameters:
// class UInteractor*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractor* ULockerAccessInteraction::GetInsideInteractor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LockerAccessInteraction", "GetInsideInteractor");

	Params::LockerAccessInteraction_GetInsideInteractor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.LockerAccessInteraction.GetPlayerInLocker
// (Final, Native, Public, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* ULockerAccessInteraction::GetPlayerInLocker() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LockerAccessInteraction", "GetPlayerInLocker");

	Params::LockerAccessInteraction_GetPlayerInLocker Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.LockerAccessInteraction.IsInteractingPlayerInsideLocker
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULockerAccessInteraction::IsInteractingPlayerInsideLocker(const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LockerAccessInteraction", "IsInteractingPlayerInsideLocker");

	Params::LockerAccessInteraction_IsInteractingPlayerInsideLocker Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.LockerAccessInteraction.IsOccupied
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULockerAccessInteraction::IsOccupied() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LockerAccessInteraction", "IsOccupied");

	Params::LockerAccessInteraction_IsOccupied Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.LockerAccessInteraction.IsRushed
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULockerAccessInteraction::IsRushed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LockerAccessInteraction", "IsRushed");

	Params::LockerAccessInteraction_IsRushed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.LockerAccessInteraction.SetCollisionWithLocker
// (Final, Native, Public, Const)
// Parameters:
// const bool                              IsEnabled                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULockerAccessInteraction::SetCollisionWithLocker(const bool IsEnabled, class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LockerAccessInteraction", "SetCollisionWithLocker");

	Params::LockerAccessInteraction_SetCollisionWithLocker Parms{};

	Parms.IsEnabled = IsEnabled;
	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.LockerEnterInteraction.EjectSurvivorFromLocker
// (Final, Native, Protected)
// Parameters:
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALocker*                          Locker                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULockerEnterInteraction::EjectSurvivorFromLocker(class ASurvivor* Survivor, class ALocker* Locker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LockerEnterInteraction", "EjectSurvivorFromLocker");

	Params::LockerEnterInteraction_EjectSurvivorFromLocker Parms{};

	Parms.Survivor = Survivor;
	Parms.Locker = Locker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.LockerJumpScareManagerComponent.Authority_OnLevelReadyToPlay
// (Final, Native, Protected)

void ULockerJumpScareManagerComponent::Authority_OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LockerJumpScareManagerComponent", "Authority_OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.LockerJumpScareManagerComponent.Authority_OnLockerInteractorChanged
// (Final, Native, Private)
// Parameters:
// bool                                    IsLocked                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULockerJumpScareManagerComponent::Authority_OnLockerInteractorChanged(bool IsLocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LockerJumpScareManagerComponent", "Authority_OnLockerInteractorChanged");

	Params::LockerJumpScareManagerComponent_Authority_OnLockerInteractorChanged Parms{};

	Parms.IsLocked = IsLocked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.LockerJumpScareManagerComponent.Authority_OnLockerJumpScareInteractionDone
// (Final, Native, Private)

void ULockerJumpScareManagerComponent::Authority_OnLockerJumpScareInteractionDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LockerJumpScareManagerComponent", "Authority_OnLockerJumpScareInteractionDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.LockerJumpScareManagerComponent.DBD_ShowLockerJumpScare
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULockerJumpScareManagerComponent::DBD_ShowLockerJumpScare(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LockerJumpScareManagerComponent", "DBD_ShowLockerJumpScare");

	Params::LockerJumpScareManagerComponent_DBD_ShowLockerJumpScare Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.LockerJumpScareManagerComponent.OnRep_JumpScareLocker
// (Final, Native, Private)
// Parameters:
// class ALocker*                          lastLocker                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULockerJumpScareManagerComponent::OnRep_JumpScareLocker(class ALocker* lastLocker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LockerJumpScareManagerComponent", "OnRep_JumpScareLocker");

	Params::LockerJumpScareManagerComponent_OnRep_JumpScareLocker Parms{};

	Parms.lastLocker = lastLocker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.LockerJumpScareManagerComponent.OnRep_LockerJumpScareInteraction
// (Final, Native, Private)

void ULockerJumpScareManagerComponent::OnRep_LockerJumpScareInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LockerJumpScareManagerComponent", "OnRep_LockerJumpScareInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.LookAtScriptedEventMapTriggerComponent.Authority_OnPlayerEnterTriggerVolume
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULookAtScriptedEventMapTriggerComponent::Authority_OnPlayerEnterTriggerVolume(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LookAtScriptedEventMapTriggerComponent", "Authority_OnPlayerEnterTriggerVolume");

	Params::LookAtScriptedEventMapTriggerComponent_Authority_OnPlayerEnterTriggerVolume Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.LookAtScriptedEventMapTriggerComponent.Authority_OnPlayerExitTriggerVolume
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULookAtScriptedEventMapTriggerComponent::Authority_OnPlayerExitTriggerVolume(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LookAtScriptedEventMapTriggerComponent", "Authority_OnPlayerExitTriggerVolume");

	Params::LookAtScriptedEventMapTriggerComponent_Authority_OnPlayerExitTriggerVolume Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.LookAtScriptedEventMapTriggerComponent.OnLevelReadyToPlay
// (Final, Native, Protected)

void ULookAtScriptedEventMapTriggerComponent::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LookAtScriptedEventMapTriggerComponent", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.LookAtScriptedEventMapTriggerComponent.OnRep_IsAnyPlayerInTriggerVolume
// (Final, Native, Protected)

void ULookAtScriptedEventMapTriggerComponent::OnRep_IsAnyPlayerInTriggerVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LookAtScriptedEventMapTriggerComponent", "OnRep_IsAnyPlayerInTriggerVolume");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.LookAtScriptedEventMapTriggerComponent.OnRep_IsAnyPlayerLookingAtPoint
// (Final, Native, Protected)

void ULookAtScriptedEventMapTriggerComponent::OnRep_IsAnyPlayerLookingAtPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LookAtScriptedEventMapTriggerComponent", "OnRep_IsAnyPlayerLookingAtPoint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.LookAtScriptedEventMapTriggerComponent.OnRep_WasEventTriggered
// (Final, Native, Protected)

void ULookAtScriptedEventMapTriggerComponent::OnRep_WasEventTriggered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LookAtScriptedEventMapTriggerComponent", "OnRep_WasEventTriggered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.LookAtScriptedEventMapTriggerComponent.ResetTriggerConditions
// (Final, Native, Public, BlueprintCallable)

void ULookAtScriptedEventMapTriggerComponent::ResetTriggerConditions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LookAtScriptedEventMapTriggerComponent", "ResetTriggerConditions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.MapCollectable.OnReadMapInteractionFinished
// (Final, Native, Private)

void AMapCollectable::OnReadMapInteractionFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapCollectable", "OnReadMapInteractionFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.MapCollectable.GetActorKnowledgeCollection
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class UActorKnowledgeCollection*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorKnowledgeCollection* AMapCollectable::GetActorKnowledgeCollection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapCollectable", "GetActorKnowledgeCollection");

	Params::MapCollectable_GetActorKnowledgeCollection Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DBDGameplay.MapCollectable.GetChargeableComponent
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class UChargeableComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChargeableComponent* AMapCollectable::GetChargeableComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapCollectable", "GetChargeableComponent");

	Params::MapCollectable_GetChargeableComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DBDGameplay.MapCollectable.GetChargerComponent
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class UChargerComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChargerComponent* AMapCollectable::GetChargerComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapCollectable", "GetChargerComponent");

	Params::MapCollectable_GetChargerComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DBDGameplay.MapMarkerActor.OnDestroy
// (Event, Protected, BlueprintEvent)

void AMapMarkerActor::OnDestroy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapMarkerActor", "OnDestroy");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.Medkit.Authority_ConsumeIfNotInteracting
// (Final, Native, Protected)

void AMedkit::Authority_ConsumeIfNotInteracting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Medkit", "Authority_ConsumeIfNotInteracting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.Medkit.Authority_OnAnyOngoingInteractionChanged
// (Final, Native, Protected)
// Parameters:
// const bool                              IsInteracting                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMedkit::Authority_OnAnyOngoingInteractionChanged(const bool IsInteracting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Medkit", "Authority_OnAnyOngoingInteractionChanged");

	Params::Medkit_Authority_OnAnyOngoingInteractionChanged Parms{};

	Parms.IsInteracting = IsInteracting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.Medkit.Authority_OnChargeStateChange
// (Final, Native, Protected)
// Parameters:
// const bool                              Empty                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMedkit::Authority_OnChargeStateChange(const bool Empty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Medkit", "Authority_OnChargeStateChange");

	Params::Medkit_Authority_OnChargeStateChange Parms{};

	Parms.Empty = Empty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.Medkit.OnMedkitHealedCamper
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       healedPlayer                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMedkit::OnMedkitHealedCamper(class ADBDPlayer* healedPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Medkit", "OnMedkitHealedCamper");

	Params::Medkit_OnMedkitHealedCamper Parms{};

	Parms.healedPlayer = healedPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.Medkit.UseCharge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMedkit::UseCharge(float Seconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Medkit", "UseCharge");

	Params::Medkit_UseCharge Parms{};

	Parms.Seconds = Seconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.Medkit.GetCharge
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMedkit::GetCharge() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Medkit", "GetCharge");

	Params::Medkit_GetCharge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.Medkit.GetChargeMultiplier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMedkit::GetChargeMultiplier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Medkit", "GetChargeMultiplier");

	Params::Medkit_GetChargeMultiplier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.Medkit.HasCharge
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMedkit::HasCharge() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Medkit", "HasCharge");

	Params::Medkit_HasCharge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.MoveToGroundComponent.MoveOwnerToGround
// (Final, Native, Private)

void UMoveToGroundComponent::MoveOwnerToGround()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoveToGroundComponent", "MoveOwnerToGround");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.NearestOutsideMapBoundsLocator.Client_InitializeAkLimitPointEvent
// (Final, Native, Private)

void UNearestOutsideMapBoundsLocator::Client_InitializeAkLimitPointEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NearestOutsideMapBoundsLocator", "Client_InitializeAkLimitPointEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.NearestOutsideMapBoundsLocator.OnGameBegin
// (Final, Native, Private)

void UNearestOutsideMapBoundsLocator::OnGameBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NearestOutsideMapBoundsLocator", "OnGameBegin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.NearestOutsideMapBoundsLocator.OnGameEnd
// (Final, Native, Private)
// Parameters:
// EEndGameReason                          endGameReason                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNearestOutsideMapBoundsLocator::OnGameEnd(EEndGameReason endGameReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NearestOutsideMapBoundsLocator", "OnGameEnd");

	Params::NearestOutsideMapBoundsLocator_OnGameEnd Parms{};

	Parms.endGameReason = endGameReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.Passage.Cosmetic_OnPlayerInRangeChanged
// (Final, Native, Private)
// Parameters:
// const bool                              inRange                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APassage::Cosmetic_OnPlayerInRangeChanged(const bool inRange, const class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Passage", "Cosmetic_OnPlayerInRangeChanged");

	Params::Passage_Cosmetic_OnPlayerInRangeChanged Parms{};

	Parms.inRange = inRange;
	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.Passage.Local_OnPlayerLeftGame
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              GameplayTag                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void APassage::Local_OnPlayerLeftGame(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Passage", "Local_OnPlayerLeftGame");

	Params::Passage_Local_OnPlayerLeftGame Parms{};

	Parms.GameplayTag = std::move(GameplayTag);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.Passage.Local_OnPlayerLocallyObservedChanged
// (Final, Native, Private)
// Parameters:
// bool                                    isObserved                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APassage::Local_OnPlayerLocallyObservedChanged(bool isObserved, const class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Passage", "Local_OnPlayerLocallyObservedChanged");

	Params::Passage_Local_OnPlayerLocallyObservedChanged Parms{};

	Parms.isObserved = isObserved;
	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.Passage.OnBeginOverlapRevealExitAuraZone
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void APassage::OnBeginOverlapRevealExitAuraZone(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Passage", "OnBeginOverlapRevealExitAuraZone");

	Params::Passage_OnBeginOverlapRevealExitAuraZone Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.Passage.OnEndOverlapRevealExitAuraZone
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APassage::OnEndOverlapRevealExitAuraZone(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Passage", "OnEndOverlapRevealExitAuraZone");

	Params::Passage_OnEndOverlapRevealExitAuraZone Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.Passage.GetConnectedPassage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APassage*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APassage* APassage::GetConnectedPassage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Passage", "GetConnectedPassage");

	Params::Passage_GetConnectedPassage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.Passage.GetPassageCosmeticState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPassageCosmeticState                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPassageCosmeticState APassage::GetPassageCosmeticState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Passage", "GetPassageCosmeticState");

	Params::Passage_GetPassageCosmeticState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.PassageEnterInteraction.GetOwningPassage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APassage*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APassage* UPassageEnterInteraction::GetOwningPassage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PassageEnterInteraction", "GetOwningPassage");

	Params::PassageEnterInteraction_GetOwningPassage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.PlayerInteractionListenerComponent.ListenToInteractionEnd
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              interactionSemantic                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TDelegate<void(class ADBDPlayer* Player, const struct FGameplayTag& interactionSemantic)>&interactionDelegate                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionListenerComponent::ListenToInteractionEnd(class ADBDPlayer* Player, const struct FGameplayTag& interactionSemantic, const TDelegate<void(class ADBDPlayer* Player, const struct FGameplayTag& interactionSemantic)>& interactionDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionListenerComponent", "ListenToInteractionEnd");

	Params::PlayerInteractionListenerComponent_ListenToInteractionEnd Parms{};

	Parms.Player = Player;
	Parms.interactionSemantic = std::move(interactionSemantic);
	Parms.interactionDelegate = interactionDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerInteractionListenerComponent.ListenToInteractionStart
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              interactionSemantic                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TDelegate<void(class ADBDPlayer* Player, const struct FGameplayTag& interactionSemantic)>&interactionDelegate                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionListenerComponent::ListenToInteractionStart(class ADBDPlayer* Player, const struct FGameplayTag& interactionSemantic, const TDelegate<void(class ADBDPlayer* Player, const struct FGameplayTag& interactionSemantic)>& interactionDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionListenerComponent", "ListenToInteractionStart");

	Params::PlayerInteractionListenerComponent_ListenToInteractionStart Parms{};

	Parms.Player = Player;
	Parms.interactionSemantic = std::move(interactionSemantic);
	Parms.interactionDelegate = interactionDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerInteractionListenerComponent.OnActorDestroyed
// (Final, Native, Private)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionListenerComponent::OnActorDestroyed(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionListenerComponent", "OnActorDestroyed");

	Params::PlayerInteractionListenerComponent_OnActorDestroyed Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerInteractionListenerComponent.UnlistenToInteractionEnd
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              interactionSemantic                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionListenerComponent::UnlistenToInteractionEnd(class ADBDPlayer* Player, const struct FGameplayTag& interactionSemantic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionListenerComponent", "UnlistenToInteractionEnd");

	Params::PlayerInteractionListenerComponent_UnlistenToInteractionEnd Parms{};

	Parms.Player = Player;
	Parms.interactionSemantic = std::move(interactionSemantic);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerInteractionListenerComponent.UnlistenToInteractionStart
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              interactionSemantic                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionListenerComponent::UnlistenToInteractionStart(class ADBDPlayer* Player, const struct FGameplayTag& interactionSemantic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionListenerComponent", "UnlistenToInteractionStart");

	Params::PlayerInteractionListenerComponent_UnlistenToInteractionStart Parms{};

	Parms.Player = Player;
	Parms.interactionSemantic = std::move(interactionSemantic);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyGamepadPitchScaleMultiplier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Multiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             adjustmentTime                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementUtilities::Local_ApplyGamepadPitchScaleMultiplier(class ADBDPlayer* Player, const float Multiplier, const float adjustmentTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerMovementUtilities", "Local_ApplyGamepadPitchScaleMultiplier");

	Params::PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier Parms{};

	Parms.Player = Player;
	Parms.Multiplier = Multiplier;
	Parms.adjustmentTime = adjustmentTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyGamepadYawScaleMultiplier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Multiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             adjustmentTime                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementUtilities::Local_ApplyGamepadYawScaleMultiplier(class ADBDPlayer* Player, const float Multiplier, const float adjustmentTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerMovementUtilities", "Local_ApplyGamepadYawScaleMultiplier");

	Params::PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier Parms{};

	Parms.Player = Player;
	Parms.Multiplier = Multiplier;
	Parms.adjustmentTime = adjustmentTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyMousePitchScaleMultiplier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Multiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             adjustmentTime                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementUtilities::Local_ApplyMousePitchScaleMultiplier(class ADBDPlayer* Player, const float Multiplier, const float adjustmentTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerMovementUtilities", "Local_ApplyMousePitchScaleMultiplier");

	Params::PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier Parms{};

	Parms.Player = Player;
	Parms.Multiplier = Multiplier;
	Parms.adjustmentTime = adjustmentTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyMouseYawScaleMultiplier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Multiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             adjustmentTime                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementUtilities::Local_ApplyMouseYawScaleMultiplier(class ADBDPlayer* Player, const float Multiplier, const float adjustmentTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerMovementUtilities", "Local_ApplyMouseYawScaleMultiplier");

	Params::PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier Parms{};

	Parms.Player = Player;
	Parms.Multiplier = Multiplier;
	Parms.adjustmentTime = adjustmentTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyPitchScaleMultiplier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Multiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             adjustmentTime                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementUtilities::Local_ApplyPitchScaleMultiplier(class ADBDPlayer* Player, const float Multiplier, const float adjustmentTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerMovementUtilities", "Local_ApplyPitchScaleMultiplier");

	Params::PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier Parms{};

	Parms.Player = Player;
	Parms.Multiplier = Multiplier;
	Parms.adjustmentTime = adjustmentTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyRotationScaleMultiplier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Multiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             adjustmentTime                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementUtilities::Local_ApplyRotationScaleMultiplier(class ADBDPlayer* Player, const float Multiplier, const float adjustmentTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerMovementUtilities", "Local_ApplyRotationScaleMultiplier");

	Params::PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier Parms{};

	Parms.Player = Player;
	Parms.Multiplier = Multiplier;
	Parms.adjustmentTime = adjustmentTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyYawScaleMultiplier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Multiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             adjustmentTime                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementUtilities::Local_ApplyYawScaleMultiplier(class ADBDPlayer* Player, const float Multiplier, const float adjustmentTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerMovementUtilities", "Local_ApplyYawScaleMultiplier");

	Params::PlayerMovementUtilities_Local_ApplyYawScaleMultiplier Parms{};

	Parms.Player = Player;
	Parms.Multiplier = Multiplier;
	Parms.adjustmentTime = adjustmentTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerMovementUtilities.Local_ResetGamepadLookCurves
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementUtilities::Local_ResetGamepadLookCurves(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerMovementUtilities", "Local_ResetGamepadLookCurves");

	Params::PlayerMovementUtilities_Local_ResetGamepadLookCurves Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerMovementUtilities.Local_ResetRotationScale
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             adjustmentTime                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementUtilities::Local_ResetRotationScale(class ADBDPlayer* Player, const float adjustmentTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerMovementUtilities", "Local_ResetRotationScale");

	Params::PlayerMovementUtilities_Local_ResetRotationScale Parms{};

	Parms.Player = Player;
	Parms.adjustmentTime = adjustmentTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerMovementUtilities.Local_SetGamepadPitchCurve
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      Curve                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementUtilities::Local_SetGamepadPitchCurve(class ADBDPlayer* Player, class UCurveFloat* Curve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerMovementUtilities", "Local_SetGamepadPitchCurve");

	Params::PlayerMovementUtilities_Local_SetGamepadPitchCurve Parms{};

	Parms.Player = Player;
	Parms.Curve = Curve;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerMovementUtilities.Local_SetGamepadYawCurve
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      Curve                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementUtilities::Local_SetGamepadYawCurve(class ADBDPlayer* Player, class UCurveFloat* Curve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerMovementUtilities", "Local_SetGamepadYawCurve");

	Params::PlayerMovementUtilities_Local_SetGamepadYawCurve Parms{};

	Parms.Player = Player;
	Parms.Curve = Curve;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayersInZoneTracker.Authority_OnBeginPlayerOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UPlayersInZoneTracker::Authority_OnBeginPlayerOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayersInZoneTracker", "Authority_OnBeginPlayerOverlap");

	Params::PlayersInZoneTracker_Authority_OnBeginPlayerOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayersInZoneTracker.Authority_OnEndPlayerOverlap
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayersInZoneTracker::Authority_OnEndPlayerOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayersInZoneTracker", "Authority_OnEndPlayerOverlap");

	Params::PlayersInZoneTracker_Authority_OnEndPlayerOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayersInZoneTracker.OnRep_PlayersInRange
// (Final, Native, Private)

void UPlayersInZoneTracker::OnRep_PlayersInRange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayersInZoneTracker", "OnRep_PlayersInRange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.ZoneComponent.OnRep_CurrentZone
// (Final, Native, Protected)

void UZoneComponent::OnRep_CurrentZone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZoneComponent", "OnRep_CurrentZone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PowerToggleComponent.OnRep_IsInPower
// (Final, Native, Private, Const)

void UPowerToggleComponent::OnRep_IsInPower() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PowerToggleComponent", "OnRep_IsInPower");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RacoonDogComponent.Authority_OnDeleteActorTimerCompleted
// (Final, Native, Private)

void URacoonDogComponent::Authority_OnDeleteActorTimerCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RacoonDogComponent", "Authority_OnDeleteActorTimerCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RacoonDogComponent.Authority_OnIsLookingTowardsTimerFinished
// (Final, Native, Private)

void URacoonDogComponent::Authority_OnIsLookingTowardsTimerFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RacoonDogComponent", "Authority_OnIsLookingTowardsTimerFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RacoonDogComponent.Authority_OnPlayerInRangeChanged
// (Final, Native, Private)
// Parameters:
// class AActor*                           playerActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              IsInRange                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URacoonDogComponent::Authority_OnPlayerInRangeChanged(class AActor* playerActor, const bool IsInRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RacoonDogComponent", "Authority_OnPlayerInRangeChanged");

	Params::RacoonDogComponent_Authority_OnPlayerInRangeChanged Parms{};

	Parms.playerActor = playerActor;
	Parms.IsInRange = IsInRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RacoonDogComponent.Authority_OnPlayerIsLookingTowardsChanged
// (Final, Native, Private)
// Parameters:
// const bool                              IsLookingTowards                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ADBDPlayer*                 Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URacoonDogComponent::Authority_OnPlayerIsLookingTowardsChanged(const bool IsLookingTowards, const class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RacoonDogComponent", "Authority_OnPlayerIsLookingTowardsChanged");

	Params::RacoonDogComponent_Authority_OnPlayerIsLookingTowardsChanged Parms{};

	Parms.IsLookingTowards = IsLookingTowards;
	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RacoonDogComponent.Authority_OnPossessedPawnChanged
// (Final, Native, Private)
// Parameters:
// class APawn*                            OldPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            NewPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URacoonDogComponent::Authority_OnPossessedPawnChanged(class APawn* OldPawn, class APawn* NewPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RacoonDogComponent", "Authority_OnPossessedPawnChanged");

	Params::RacoonDogComponent_Authority_OnPossessedPawnChanged Parms{};

	Parms.OldPawn = OldPawn;
	Parms.NewPawn = NewPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RacoonDogComponent.DBD_ResetRacoonDogWasActivated
// (Final, Exec, Native, Private)

void URacoonDogComponent::DBD_ResetRacoonDogWasActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RacoonDogComponent", "DBD_ResetRacoonDogWasActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RacoonDogComponent.DBD_SetSelectedRacoonDogAnimIndex
// (Final, Exec, Native, Private)
// Parameters:
// const uint8                             Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URacoonDogComponent::DBD_SetSelectedRacoonDogAnimIndex(const uint8 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RacoonDogComponent", "DBD_SetSelectedRacoonDogAnimIndex");

	Params::RacoonDogComponent_DBD_SetSelectedRacoonDogAnimIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RacoonDogComponent.OnAnimationMontageCompleted
// (Final, Native, Private)

void URacoonDogComponent::OnAnimationMontageCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RacoonDogComponent", "OnAnimationMontageCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RacoonDogComponent.OnRep_WasActivated
// (Final, Native, Private)

void URacoonDogComponent::OnRep_WasActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RacoonDogComponent", "OnRep_WasActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RandomScriptedEventMapTriggerComponent.Authority_TryTriggerRandomEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URandomScriptedEventMapTriggerComponent::Authority_TryTriggerRandomEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RandomScriptedEventMapTriggerComponent", "Authority_TryTriggerRandomEvent");

	Params::RandomScriptedEventMapTriggerComponent_Authority_TryTriggerRandomEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.RandomScriptedEventMapTriggerComponent.Multicast_RandomEventTriggered
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void URandomScriptedEventMapTriggerComponent::Multicast_RandomEventTriggered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RandomScriptedEventMapTriggerComponent", "Multicast_RandomEventTriggered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RangedExplosiveEffectHandlerComponent.OnRangedExplosiveDestroyed
// (Final, Native, Private)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URangedExplosiveEffectHandlerComponent::OnRangedExplosiveDestroyed(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangedExplosiveEffectHandlerComponent", "OnRangedExplosiveDestroyed");

	Params::RangedExplosiveEffectHandlerComponent_OnRangedExplosiveDestroyed Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RangeToActorsTrackerComponent.OnLevelReadyToPlay
// (Final, Native, Private)

void URangeToActorsTrackerComponent::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangeToActorsTrackerComponent", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RespawnableComponent.Authority_OnMinRespawnTimerDone
// (Final, Native, Private)

void URespawnableComponent::Authority_OnMinRespawnTimerDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RespawnableComponent", "Authority_OnMinRespawnTimerDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RespawnableComponent.Authority_OnTimerDone
// (Final, Native, Private)

void URespawnableComponent::Authority_OnTimerDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RespawnableComponent", "Authority_OnTimerDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RespawnableComponent.Authority_TryTeleport
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URespawnableComponent::Authority_TryTeleport()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RespawnableComponent", "Authority_TryTeleport");

	Params::RespawnableComponent_Authority_TryTeleport Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.RespawnableComponent.OnDespawnCosmeticsComplete
// (Native, Public, BlueprintCallable)

void URespawnableComponent::OnDespawnCosmeticsComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RespawnableComponent", "OnDespawnCosmeticsComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RespawnableComponent.OnLevelReadyToPlay
// (Native, Protected)

void URespawnableComponent::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RespawnableComponent", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RespawnableComponent.OnRep_OnLocationChanged
// (Final, Native, Private)

void URespawnableComponent::OnRep_OnLocationChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RespawnableComponent", "OnRep_OnLocationChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.ScreamFunctionLibrary.ScreamRevealSurvivor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ASurvivor*                        Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   screamRevealDuration                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SpawnBubbleIndicator                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScreamFunctionLibrary::ScreamRevealSurvivor(class ASurvivor* Survivor, float screamRevealDuration, bool SpawnBubbleIndicator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ScreamFunctionLibrary", "ScreamRevealSurvivor");

	Params::ScreamFunctionLibrary_ScreamRevealSurvivor Parms{};

	Parms.Survivor = Survivor;
	Parms.screamRevealDuration = screamRevealDuration;
	Parms.SpawnBubbleIndicator = SpawnBubbleIndicator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.SightRevealableComponent.Authority_IsBeingRevealed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USightRevealableComponent::Authority_IsBeingRevealed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SightRevealableComponent", "Authority_IsBeingRevealed");

	Params::SightRevealableComponent_Authority_IsBeingRevealed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.TerrorRadiusEmitterComponent.SetEmitterActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Active                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTerrorRadiusEmitterComponent::SetEmitterActive(bool Active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusEmitterComponent", "SetEmitterActive");

	Params::TerrorRadiusEmitterComponent_SetEmitterActive Parms{};

	Parms.Active = Active;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.TerrorRadiusEmitterComponent.SetImitatesAudioOnly
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    imitatesAudioOnly                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTerrorRadiusEmitterComponent::SetImitatesAudioOnly(bool imitatesAudioOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusEmitterComponent", "SetImitatesAudioOnly");

	Params::TerrorRadiusEmitterComponent_SetImitatesAudioOnly Parms{};

	Parms.imitatesAudioOnly = imitatesAudioOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.TerrorRadiusEmitterComponent.SetIsFakeTerrorRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTerrorRadiusEmitterComponent::SetIsFakeTerrorRadius(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusEmitterComponent", "SetIsFakeTerrorRadius");

	Params::TerrorRadiusEmitterComponent_SetIsFakeTerrorRadius Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.TerrorRadiusEmitterComponent.SetSimulatedFixedDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTerrorRadiusEmitterComponent::SetSimulatedFixedDistance(float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusEmitterComponent", "SetSimulatedFixedDistance");

	Params::TerrorRadiusEmitterComponent_SetSimulatedFixedDistance Parms{};

	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.TerrorRadiusEmitterComponent.SetTerrorRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTerrorRadiusEmitterComponent::SetTerrorRadius(float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusEmitterComponent", "SetTerrorRadius");

	Params::TerrorRadiusEmitterComponent_SetTerrorRadius Parms{};

	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.TerrorRadiusEmitterComponent.GetImitatesAudioOnly
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTerrorRadiusEmitterComponent::GetImitatesAudioOnly() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusEmitterComponent", "GetImitatesAudioOnly");

	Params::TerrorRadiusEmitterComponent_GetImitatesAudioOnly Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.TerrorRadiusEmitterComponent.GetIsActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTerrorRadiusEmitterComponent::GetIsActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusEmitterComponent", "GetIsActive");

	Params::TerrorRadiusEmitterComponent_GetIsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.TerrorRadiusEmitterComponent.GetRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTerrorRadiusEmitterComponent::GetRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusEmitterComponent", "GetRadius");

	Params::TerrorRadiusEmitterComponent_GetRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.TerrorRadiusEmitterComponent.GetSimulatedFixedDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTerrorRadiusEmitterComponent::GetSimulatedFixedDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusEmitterComponent", "GetSimulatedFixedDistance");

	Params::TerrorRadiusEmitterComponent_GetSimulatedFixedDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.TerrorRadiusEmitterComponent.IsInTerrorRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTerrorRadiusReceiverComponent*   receiver                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTerrorRadiusEmitterComponent::IsInTerrorRadius(class UTerrorRadiusReceiverComponent* receiver) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusEmitterComponent", "IsInTerrorRadius");

	Params::TerrorRadiusEmitterComponent_IsInTerrorRadius Parms{};

	Parms.receiver = receiver;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.SlasherTerrorRadiusEmitterComponent.SetBaseTerrorRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   baseTerrorRadius                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              progressive                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlasherTerrorRadiusEmitterComponent::SetBaseTerrorRadius(float baseTerrorRadius, const bool progressive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherTerrorRadiusEmitterComponent", "SetBaseTerrorRadius");

	Params::SlasherTerrorRadiusEmitterComponent_SetBaseTerrorRadius Parms{};

	Parms.baseTerrorRadius = baseTerrorRadius;
	Parms.progressive = progressive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.SmokeBomb.OnSmokeAreaStartedToShrink
// (Event, Protected, BlueprintEvent)

void ASmokeBomb::OnSmokeAreaStartedToShrink()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmokeBomb", "OnSmokeAreaStartedToShrink");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.SmokeBombCosmeticHelperActor.Cosmetic_OnSmokeEnded
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void ASmokeBombCosmeticHelperActor::Cosmetic_OnSmokeEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmokeBombCosmeticHelperActor", "Cosmetic_OnSmokeEnded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.SmokeBombCosmeticHelperActor.Cosmetic_OnSmokeStarted
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void ASmokeBombCosmeticHelperActor::Cosmetic_OnSmokeStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmokeBombCosmeticHelperActor", "Cosmetic_OnSmokeStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.SmokeBombCosmeticHelperActor.Cosmetic_UpdateVisibility
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    IsVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASmokeBombCosmeticHelperActor::Cosmetic_UpdateVisibility(bool IsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmokeBombCosmeticHelperActor", "Cosmetic_UpdateVisibility");

	Params::SmokeBombCosmeticHelperActor_Cosmetic_UpdateVisibility Parms{};

	Parms.IsVisible = IsVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.SmokeBombCosmeticHelperActor.OnFirstPersonChanged
// (Final, Native, Private)
// Parameters:
// bool                                    isFirstPerson                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASmokeBombCosmeticHelperActor::OnFirstPersonChanged(bool isFirstPerson)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmokeBombCosmeticHelperActor", "OnFirstPersonChanged");

	Params::SmokeBombCosmeticHelperActor_OnFirstPersonChanged Parms{};

	Parms.isFirstPerson = isFirstPerson;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.SmokeBombCosmeticHelperActor.GetOwningPlayer
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* ASmokeBombCosmeticHelperActor::GetOwningPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmokeBombCosmeticHelperActor", "GetOwningPlayer");

	Params::SmokeBombCosmeticHelperActor_GetOwningPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.SmokeBombCosmeticHelperManager.OnLocallyObservedChanged
// (Final, Native, Private)

void USmokeBombCosmeticHelperManager::OnLocallyObservedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmokeBombCosmeticHelperManager", "OnLocallyObservedChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.SteamPipe.Authority_OnBeginOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ASteamPipe::Authority_OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipe", "Authority_OnBeginOverlap");

	Params::SteamPipe_Authority_OnBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.SteamPipe.Authority_OnEndOverlap
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASteamPipe::Authority_OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipe", "Authority_OnEndOverlap");

	Params::SteamPipe_Authority_OnEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.SteamPipe.Cosmetic_OnSteamPipeStateChanged
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// ESteamPipeState                         newState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASteamPipe::Cosmetic_OnSteamPipeStateChanged(ESteamPipeState newState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipe", "Cosmetic_OnSteamPipeStateChanged");

	Params::SteamPipe_Cosmetic_OnSteamPipeStateChanged Parms{};

	Parms.newState = newState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.SteamPipe.OnRep_SteamPipeState
// (Final, Native, Private)

void ASteamPipe::OnRep_SteamPipeState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipe", "OnRep_SteamPipeState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.SteamPipe.GetCurrentSteamPipeState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESteamPipeState                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamPipeState ASteamPipe::GetCurrentSteamPipeState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipe", "GetCurrentSteamPipeState");

	Params::SteamPipe_GetCurrentSteamPipeState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.SteamPipeManagerComponent.Authority_OnCharacterAdded
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamPipeManagerComponent::Authority_OnCharacterAdded(class ADBDPlayer* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipeManagerComponent", "Authority_OnCharacterAdded");

	Params::SteamPipeManagerComponent_Authority_OnCharacterAdded Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.SteamPipeManagerComponent.Authority_OnResetInteractionComplete
// (Final, Native, Private, HasOutParams)
// Parameters:
// bool                                    COMPLETED                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            instigatorsForCompletion                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void USteamPipeManagerComponent::Authority_OnResetInteractionComplete(bool COMPLETED, const TArray<class AActor*>& instigatorsForCompletion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipeManagerComponent", "Authority_OnResetInteractionComplete");

	Params::SteamPipeManagerComponent_Authority_OnResetInteractionComplete Parms{};

	Parms.COMPLETED = COMPLETED;
	Parms.instigatorsForCompletion = std::move(instigatorsForCompletion);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.SteamPipeManagerComponent.Authority_OnSteamPipeStateChanged
// (Final, Native, Private)
// Parameters:
// const class ASteamPipe*                 SteamPipe                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ESteamPipeState                   newState                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamPipeManagerComponent::Authority_OnSteamPipeStateChanged(const class ASteamPipe* SteamPipe, const ESteamPipeState newState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipeManagerComponent", "Authority_OnSteamPipeStateChanged");

	Params::SteamPipeManagerComponent_Authority_OnSteamPipeStateChanged Parms{};

	Parms.SteamPipe = SteamPipe;
	Parms.newState = newState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.SteamPipeManagerComponent.Authority_OnSwitchCooldownComplete
// (Final, Native, Private)

void USteamPipeManagerComponent::Authority_OnSwitchCooldownComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipeManagerComponent", "Authority_OnSwitchCooldownComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.SteamPipeManagerComponent.Authority_UpdateCanUseResetSwitch
// (Final, Native, Private)

void USteamPipeManagerComponent::Authority_UpdateCanUseResetSwitch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipeManagerComponent", "Authority_UpdateCanUseResetSwitch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.SteamPipeManagerComponent.OnLevelReadyToPlay
// (Final, Native, Private)

void USteamPipeManagerComponent::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipeManagerComponent", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.SteamPipeResetSwitch.Cosmetic_NumberOfDisabledSteamPipesChanged
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// const int32                             numberOfDisabledSteamPipes                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASteamPipeResetSwitch::Cosmetic_NumberOfDisabledSteamPipesChanged(const int32 numberOfDisabledSteamPipes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipeResetSwitch", "Cosmetic_NumberOfDisabledSteamPipesChanged");

	Params::SteamPipeResetSwitch_Cosmetic_NumberOfDisabledSteamPipesChanged Parms{};

	Parms.numberOfDisabledSteamPipes = numberOfDisabledSteamPipes;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.SteamPipeResetSwitch.Cosmetic_OnCooldownDone
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void ASteamPipeResetSwitch::Cosmetic_OnCooldownDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipeResetSwitch", "Cosmetic_OnCooldownDone");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.SteamPipeResetSwitch.Cosmetic_OnSwitchTriggered
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// float                                   cooldownTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASteamPipeResetSwitch::Cosmetic_OnSwitchTriggered(float cooldownTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipeResetSwitch", "Cosmetic_OnSwitchTriggered");

	Params::SteamPipeResetSwitch_Cosmetic_OnSwitchTriggered Parms{};

	Parms.cooldownTime = cooldownTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.SteamPipeResetSwitch.Cosmetic_OnTotalSteamPipesInLevelChanged
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// const int32                             totalSteamPipesInLevel                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASteamPipeResetSwitch::Cosmetic_OnTotalSteamPipesInLevelChanged(const int32 totalSteamPipesInLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipeResetSwitch", "Cosmetic_OnTotalSteamPipesInLevelChanged");

	Params::SteamPipeResetSwitch_Cosmetic_OnTotalSteamPipesInLevelChanged Parms{};

	Parms.totalSteamPipesInLevel = totalSteamPipesInLevel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.SteamPipeResetSwitch.OnRep_IsOnCooldown
// (Final, Native, Private)

void ASteamPipeResetSwitch::OnRep_IsOnCooldown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipeResetSwitch", "OnRep_IsOnCooldown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.SteamPipeResetSwitch.OnRep_NumberOfDisabledSteamPipes
// (Final, Native, Private)

void ASteamPipeResetSwitch::OnRep_NumberOfDisabledSteamPipes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipeResetSwitch", "OnRep_NumberOfDisabledSteamPipes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.SteamPipeResetSwitch.OnRep_SharedChargeableComponent
// (Final, Native, Private)

void ASteamPipeResetSwitch::OnRep_SharedChargeableComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipeResetSwitch", "OnRep_SharedChargeableComponent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.SteamPipeResetSwitch.GetTotalSteamPipesInLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ASteamPipeResetSwitch::GetTotalSteamPipesInLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipeResetSwitch", "GetTotalSteamPipesInLevel");

	Params::SteamPipeResetSwitch_GetTotalSteamPipesInLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.StruggleComponent.Authority_TryActivateSkillCheck
// (Final, Native, Private)

void UStruggleComponent::Authority_TryActivateSkillCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StruggleComponent", "Authority_TryActivateSkillCheck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.StruggleComponent.OnSkillCheckEnd
// (Final, Native, Private)
// Parameters:
// bool                                    hadInput                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Bonus                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStruggleComponent::OnSkillCheckEnd(bool hadInput, bool Success, bool Bonus, ESkillCheckCustomType Type, class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StruggleComponent", "OnSkillCheckEnd");

	Params::StruggleComponent_OnSkillCheckEnd Parms{};

	Parms.hadInput = hadInput;
	Parms.Success = Success;
	Parms.Bonus = Bonus;
	Parms.Type = Type;
	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.TerrorRadiusReceiverComponent.IsInTerrorRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTerrorRadiusReceiverComponent::IsInTerrorRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusReceiverComponent", "IsInTerrorRadius");

	Params::TerrorRadiusReceiverComponent_IsInTerrorRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.TerrorRadiusReceiverComponent.IsInTerrorRadiusRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTerrorRadiusReceiverComponent::IsInTerrorRadiusRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusReceiverComponent", "IsInTerrorRadiusRange");

	Params::TerrorRadiusReceiverComponent_IsInTerrorRadiusRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.TerrorRadiusScreenIndicatorComponent.OnHeartStateChanged
// (Final, Native, Private)
// Parameters:
// const struct FGameplayTag&              heartState                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTerrorRadiusScreenIndicatorComponent::OnHeartStateChanged(const struct FGameplayTag& heartState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusScreenIndicatorComponent", "OnHeartStateChanged");

	Params::TerrorRadiusScreenIndicatorComponent_OnHeartStateChanged Parms{};

	Parms.heartState = std::move(heartState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.Authority_AddWiggleCharge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ChargeAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleComponent::Authority_AddWiggleCharge(float ChargeAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "Authority_AddWiggleCharge");

	Params::WiggleComponent_Authority_AddWiggleCharge Parms{};

	Parms.ChargeAmount = ChargeAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.Authority_TutorialEndWiggle
// (Final, Native, Public, BlueprintCallable)

void UWiggleComponent::Authority_TutorialEndWiggle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "Authority_TutorialEndWiggle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.OnHideWiggleSkillCheck
// (Final, Native, Private)
// Parameters:
// ESkillCheckCustomType                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleComponent::OnHideWiggleSkillCheck(ESkillCheckCustomType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "OnHideWiggleSkillCheck");

	Params::WiggleComponent_OnHideWiggleSkillCheck Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.OnKeyBindingsChanged
// (Final, Native, Private)

void UWiggleComponent::OnKeyBindingsChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "OnKeyBindingsChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.OnLevelReadyToPlay
// (Final, Native, Private)

void UWiggleComponent::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.OnPickedUpSkillCheckEnd
// (Final, Native, Private)
// Parameters:
// bool                                    hadInput                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Bonus                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleComponent::OnPickedUpSkillCheckEnd(bool hadInput, bool Success, bool Bonus, ESkillCheckCustomType Type, class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "OnPickedUpSkillCheckEnd");

	Params::WiggleComponent_OnPickedUpSkillCheckEnd Parms{};

	Parms.hadInput = hadInput;
	Parms.Success = Success;
	Parms.Bonus = Bonus;
	Parms.Type = Type;
	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.OnPlayerPickedUpEnd
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       picker                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleComponent::OnPlayerPickedUpEnd(class ADBDPlayer* picker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "OnPlayerPickedUpEnd");

	Params::WiggleComponent_OnPlayerPickedUpEnd Parms{};

	Parms.picker = picker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.OnPlayerPickedUpStart
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       picker                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleComponent::OnPlayerPickedUpStart(class ADBDPlayer* picker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "OnPlayerPickedUpStart");

	Params::WiggleComponent_OnPlayerPickedUpStart Parms{};

	Parms.picker = picker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.OnSurvivorHookedOrUnhookedOrDropped
// (Final, Native, Private)

void UWiggleComponent::OnSurvivorHookedOrUnhookedOrDropped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "OnSurvivorHookedOrUnhookedOrDropped");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.OnWiggleEnd
// (Final, Native, Private)

void UWiggleComponent::OnWiggleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "OnWiggleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.OnWiggleInput
// (Final, Native, Private)

void UWiggleComponent::OnWiggleInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "OnWiggleInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.OnWiggleSkillCheckEnd
// (Final, Native, Private)
// Parameters:
// bool                                    hadInput                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Bonus                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleComponent::OnWiggleSkillCheckEnd(bool hadInput, bool Success, bool Bonus, ESkillCheckCustomType Type, class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "OnWiggleSkillCheckEnd");

	Params::WiggleComponent_OnWiggleSkillCheckEnd Parms{};

	Parms.hadInput = hadInput;
	Parms.Success = Success;
	Parms.Bonus = Bonus;
	Parms.Type = Type;
	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.DBD_SetWiggleProgress
// (Final, Exec, Native, Public, Const)
// Parameters:
// const float                             progressPercent                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleComponent::DBD_SetWiggleProgress(const float progressPercent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "DBD_SetWiggleProgress");

	Params::WiggleComponent_DBD_SetWiggleProgress Parms{};

	Parms.progressPercent = progressPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.GetWiggleChargeable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UChargeableComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChargeableComponent* UWiggleComponent::GetWiggleChargeable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "GetWiggleChargeable");

	Params::WiggleComponent_GetWiggleChargeable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.WiggleFreeComponent.Authority_OnChargeableCompleteEvent
// (Final, Native, Private, HasOutParams)
// Parameters:
// bool                                    COMPLETED                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            instigatorsForCompletion                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UWiggleFreeComponent::Authority_OnChargeableCompleteEvent(bool COMPLETED, const TArray<class AActor*>& instigatorsForCompletion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleFreeComponent", "Authority_OnChargeableCompleteEvent");

	Params::WiggleFreeComponent_Authority_OnChargeableCompleteEvent Parms{};

	Parms.COMPLETED = COMPLETED;
	Parms.instigatorsForCompletion = std::move(instigatorsForCompletion);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleFreeComponent.Authority_OnChargeApplied
// (Final, Native, Private)
// Parameters:
// float                                   IndividualChargeAmount                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TotalChargeAmount                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ChargeInstigator                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    WasCoop                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleFreeComponent::Authority_OnChargeApplied(float IndividualChargeAmount, float TotalChargeAmount, class AActor* ChargeInstigator, bool WasCoop, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleFreeComponent", "Authority_OnChargeApplied");

	Params::WiggleFreeComponent_Authority_OnChargeApplied Parms{};

	Parms.IndividualChargeAmount = IndividualChargeAmount;
	Parms.TotalChargeAmount = TotalChargeAmount;
	Parms.ChargeInstigator = ChargeInstigator;
	Parms.WasCoop = WasCoop;
	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleFreeComponent.Authority_OnPlayerPickedUpEnd
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       picker                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleFreeComponent::Authority_OnPlayerPickedUpEnd(class ADBDPlayer* picker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleFreeComponent", "Authority_OnPlayerPickedUpEnd");

	Params::WiggleFreeComponent_Authority_OnPlayerPickedUpEnd Parms{};

	Parms.picker = picker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleFreeComponent.Authority_OnWiggleEnd
// (Final, Native, Private)

void UWiggleFreeComponent::Authority_OnWiggleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleFreeComponent", "Authority_OnWiggleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleFreeComponent.Authority_RegisterListeners
// (Final, Native, Private)

void UWiggleFreeComponent::Authority_RegisterListeners()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleFreeComponent", "Authority_RegisterListeners");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleMotionComponent.OnHideWiggleSkillCheck
// (Final, Native, Private)
// Parameters:
// ESkillCheckCustomType                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleMotionComponent::OnHideWiggleSkillCheck(ESkillCheckCustomType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleMotionComponent", "OnHideWiggleSkillCheck");

	Params::WiggleMotionComponent_OnHideWiggleSkillCheck Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleMotionComponent.OnSurvivorPickedUp
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   pickupDuration                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleMotionComponent::OnSurvivorPickedUp(class ADBDPlayer* Target, float pickupDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleMotionComponent", "OnSurvivorPickedUp");

	Params::WiggleMotionComponent_OnSurvivorPickedUp Parms{};

	Parms.Target = Target;
	Parms.pickupDuration = pickupDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleMotionComponent.OnSurvivorRemoved
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleMotionComponent::OnSurvivorRemoved(class ADBDPlayer* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleMotionComponent", "OnSurvivorRemoved");

	Params::WiggleMotionComponent_OnSurvivorRemoved Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleMotionComponent.OnWiggleSkillCheckEnd
// (Final, Native, Private)
// Parameters:
// bool                                    hadInput                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Bonus                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleMotionComponent::OnWiggleSkillCheckEnd(bool hadInput, bool Success, bool Bonus, ESkillCheckCustomType Type, class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleMotionComponent", "OnWiggleSkillCheckEnd");

	Params::WiggleMotionComponent_OnWiggleSkillCheckEnd Parms{};

	Parms.hadInput = hadInput;
	Parms.Success = Success;
	Parms.Bonus = Bonus;
	Parms.Type = Type;
	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleMotionComponent.Server_SetIsBeingWiggled
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const bool                              isBeingWiggled                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleMotionComponent::Server_SetIsBeingWiggled(const bool isBeingWiggled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleMotionComponent", "Server_SetIsBeingWiggled");

	Params::WiggleMotionComponent_Server_SetIsBeingWiggled Parms{};

	Parms.isBeingWiggled = isBeingWiggled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleMotionComponent.SetIsBeingWiggled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              isBeingWiggled                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleMotionComponent::SetIsBeingWiggled(const bool isBeingWiggled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleMotionComponent", "SetIsBeingWiggled");

	Params::WiggleMotionComponent_SetIsBeingWiggled Parms{};

	Parms.isBeingWiggled = isBeingWiggled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WormholeFatherDoorAnimInstance.OnStateChanged
// (Final, Native, Private)
// Parameters:
// bool                                    HasBeenHacked                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWormholeFatherDoorAnimInstance::OnStateChanged(bool HasBeenHacked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WormholeFatherDoorAnimInstance", "OnStateChanged");

	Params::WormholeFatherDoorAnimInstance_OnStateChanged Parms{};

	Parms.HasBeenHacked = HasBeenHacked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WormholeFatherHackableActor.OnHackedEvent
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              GameEvent                                              (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AWormholeFatherHackableActor::OnHackedEvent(const struct FGameplayTag& GameEvent, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WormholeFatherHackableActor", "OnHackedEvent");

	Params::WormholeFatherHackableActor_OnHackedEvent Parms{};

	Parms.GameEvent = std::move(GameEvent);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WormholeFatherHackingComponent.SetHasBeenHacked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              HasBeenHacked                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWormholeFatherHackingComponent::SetHasBeenHacked(const bool HasBeenHacked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WormholeFatherHackingComponent", "SetHasBeenHacked");

	Params::WormholeFatherHackingComponent_SetHasBeenHacked Parms{};

	Parms.HasBeenHacked = HasBeenHacked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WormholeFatherHackingComponent.HasBeenHacked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWormholeFatherHackingComponent::HasBeenHacked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WormholeFatherHackingComponent", "HasBeenHacked");

	Params::WormholeFatherHackingComponent_HasBeenHacked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.WormholeFatherHackingComponent.OnRep_HasBeenHacked
// (Final, Native, Protected, Const)

void UWormholeFatherHackingComponent::OnRep_HasBeenHacked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WormholeFatherHackingComponent", "OnRep_HasBeenHacked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WormholeFatherKeyCard.Cosmetic_OnKeyCardCollected
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void AWormholeFatherKeyCard::Cosmetic_OnKeyCardCollected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WormholeFatherKeyCard", "Cosmetic_OnKeyCardCollected");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.WormholeFatherKeyCard.Cosmetic_OnKeyCardDropped
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void AWormholeFatherKeyCard::Cosmetic_OnKeyCardDropped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WormholeFatherKeyCard", "Cosmetic_OnKeyCardDropped");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.WormholeFatherKeyCard.OnRep_KeyCardState
// (Final, Native, Private)

void AWormholeFatherKeyCard::OnRep_KeyCardState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WormholeFatherKeyCard", "OnRep_KeyCardState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WormholeFatherKeyCard.ApplyInitialTag
// (Final, Native, Private, Const)
// Parameters:
// class ADBDPlayer*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWormholeFatherKeyCard::ApplyInitialTag(class ADBDPlayer* Character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WormholeFatherKeyCard", "ApplyInitialTag");

	Params::WormholeFatherKeyCard_ApplyInitialTag Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WormholeFatherKeyCard.GetKeyCardState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EFatherKeyCardState                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFatherKeyCardState AWormholeFatherKeyCard::GetKeyCardState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WormholeFatherKeyCard", "GetKeyCardState");

	Params::WormholeFatherKeyCard_GetKeyCardState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.WormholeFatherKeyCard.RemoveInitialTag
// (Final, Native, Private, Const)
// Parameters:
// class ADBDPlayer*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWormholeFatherKeyCard::RemoveInitialTag(class ADBDPlayer* Character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WormholeFatherKeyCard", "RemoveInitialTag");

	Params::WormholeFatherKeyCard_RemoveInitialTag Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WormholeFatherRoomZoneOverlap.OnOverlapEnter
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AWormholeFatherRoomZoneOverlap::OnOverlapEnter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WormholeFatherRoomZoneOverlap", "OnOverlapEnter");

	Params::WormholeFatherRoomZoneOverlap_OnOverlapEnter Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WormholeFatherRoomZoneOverlap.OnOverlapExit
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWormholeFatherRoomZoneOverlap::OnOverlapExit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WormholeFatherRoomZoneOverlap", "OnOverlapExit");

	Params::WormholeFatherRoomZoneOverlap_OnOverlapExit Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

