#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DBDGameplay

#include "Basic.hpp"

#include "GameplayTagUtilities_structs.hpp"
#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "DBDInteraction_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "DataTableUtilities_structs.hpp"
#include "PhysicsCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "AnimationUtilities_structs.hpp"
#include "VFXUtilities_classes.hpp"
#include "DBDGameplay_structs.hpp"
#include "DBDCosmetic_classes.hpp"
#include "QueryService_structs.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "GameplayUtilities_classes.hpp"
#include "NetworkUtilities_structs.hpp"
#include "DBDSharedTypes_structs.hpp"
#include "StatSystem_structs.hpp"


namespace SDK
{

// Class DBDGameplay.KillerProjectileAbilityLauncher
// 0x0000 (0x01A8 - 0x01A8)
class UKillerProjectileAbilityLauncher : public UKillerProjectileLauncher
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerProjectileAbilityLauncher">();
	}
	static class UKillerProjectileAbilityLauncher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerProjectileAbilityLauncher>();
	}
};
static_assert(alignof(UKillerProjectileAbilityLauncher) == 0x000008, "Wrong alignment on UKillerProjectileAbilityLauncher");
static_assert(sizeof(UKillerProjectileAbilityLauncher) == 0x0001A8, "Wrong size on UKillerProjectileAbilityLauncher");

// Class DBDGameplay.BaseSurvivorCollectable
// 0x0048 (0x05A0 - 0x0558)
class ABaseSurvivorCollectable : public ACollectable
{
public:
	class USpherePlayerOverlapComponent*          _interactable;                                     // 0x0558(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractor*                            _collectableInteractor;                            // 0x0560(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDropItemInteraction*                   _dropInteraction;                                  // 0x0568(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCollectItemInteraction*                _collectInteraction;                               // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       _infectablePrimitive;                              // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDOutlineComponent*                   _outlineComponent;                                 // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialHelper*                        _materialHelper;                                   // 0x0588(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USurvivorCollectableOutlineUpdateStrategy* _survivorCollectableOutlineUpdateStrategy;      // 0x0590(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_598[0x8];                                      // 0x0598(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseSurvivorCollectable">();
	}
	static class ABaseSurvivorCollectable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseSurvivorCollectable>();
	}
};
static_assert(alignof(ABaseSurvivorCollectable) == 0x000008, "Wrong alignment on ABaseSurvivorCollectable");
static_assert(sizeof(ABaseSurvivorCollectable) == 0x0005A0, "Wrong size on ABaseSurvivorCollectable");
static_assert(offsetof(ABaseSurvivorCollectable, _interactable) == 0x000558, "Member 'ABaseSurvivorCollectable::_interactable' has a wrong offset!");
static_assert(offsetof(ABaseSurvivorCollectable, _collectableInteractor) == 0x000560, "Member 'ABaseSurvivorCollectable::_collectableInteractor' has a wrong offset!");
static_assert(offsetof(ABaseSurvivorCollectable, _dropInteraction) == 0x000568, "Member 'ABaseSurvivorCollectable::_dropInteraction' has a wrong offset!");
static_assert(offsetof(ABaseSurvivorCollectable, _collectInteraction) == 0x000570, "Member 'ABaseSurvivorCollectable::_collectInteraction' has a wrong offset!");
static_assert(offsetof(ABaseSurvivorCollectable, _infectablePrimitive) == 0x000578, "Member 'ABaseSurvivorCollectable::_infectablePrimitive' has a wrong offset!");
static_assert(offsetof(ABaseSurvivorCollectable, _outlineComponent) == 0x000580, "Member 'ABaseSurvivorCollectable::_outlineComponent' has a wrong offset!");
static_assert(offsetof(ABaseSurvivorCollectable, _materialHelper) == 0x000588, "Member 'ABaseSurvivorCollectable::_materialHelper' has a wrong offset!");
static_assert(offsetof(ABaseSurvivorCollectable, _survivorCollectableOutlineUpdateStrategy) == 0x000590, "Member 'ABaseSurvivorCollectable::_survivorCollectableOutlineUpdateStrategy' has a wrong offset!");

// Class DBDGameplay.CageHook
// 0x0328 (0x06D0 - 0x03A8)
class ACageHook : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x98];                                     // 0x03A8(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _timeToBlockLocationOnRescue;                      // 0x0440(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _sacrificeScoreEvent;                              // 0x0468(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _inMontageID;                                      // 0x0474(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _idleMontageID;                                    // 0x0480(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _idleToStruggleMontageID;                          // 0x048C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _struggleMontageID;                                // 0x0498(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _struggleHitMontageID;                             // 0x04A4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _deadMontageID;                                    // 0x04B0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _relocateMontageID;                                // 0x04BC(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _goingUnderMontageID;                              // 0x04C8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _survivorSocketID;                                 // 0x04D4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _rescuerSocketID;                                  // 0x04E0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _cameraSocketID;                                   // 0x04EC(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _rescueSocketID;                                   // 0x04F8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _sacrificeAfterMontageSecond;                      // 0x0504(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _goingUnderMontageSecond;                          // 0x0508(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _furthestLocationSelectionCount;                   // 0x050C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASurvivor*                              _cagedSurvivor;                                    // 0x0510(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AKiller*                                _killerInstigator;                                 // 0x0518(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _root;                                             // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _rescueChargeableComponent;                        // 0x0528(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDSkeletalMeshComponentBudgeted*      _cageSkeletalMesh;                                 // 0x0530(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          _interactionZone;                                  // 0x0538(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          _playerOverlapZone;                                // 0x0540(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMontagePlayer*                         _montagePlayer;                                    // 0x0548(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_550[0x10];                                     // 0x0550(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          _cageCollision;                                    // 0x0560(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_568[0x50];                                     // 0x0568(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimationMontageSlave*                 _animationMontageSlave;                            // 0x05B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimMontage*                           _montageToPlay;                                    // 0x05C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C8[0x8];                                      // 0x05C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _rescuerSnapPosition;                              // 0x05D0(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCageHookAntiCampComponent*             _anticampComponent;                                // 0x05E8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F0[0xA0];                                     // 0x05F0(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _anticampDrainCooldownTime;                        // 0x0690(0x0028)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6B8[0x10];                                     // 0x06B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIPerceptionStimuliSourceComponent*    _perceptionStimuliComponent;                       // 0x06C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CheckRescuerSocketPosition();
	void Cosmetic_DisplayCage(const bool Display);
	void Cosmetic_OnGoingUpStarted(bool isAnticampRelocation, class ASurvivor* cagedSurvivor);
	void Cosmetic_OnPlayerAbsorbedByGround();
	void Cosmetic_OnRelocateStart();
	void FX_SurvivorSavedFromCage();
	void Multicast_Relocate(const struct FVector& Location, const struct FRotator& Rotation, const bool isAnticampRelocation);
	void Multicast_SendSurvivorToCage(class ASurvivor* Survivor, class AKiller* killerInstigator);
	void Multicast_SendSurvivorToCageImmediately(class ASurvivor* Survivor, class AKiller* killerInstigator, const struct FVector& Location, const struct FRotator& Rotation);
	void OnCageDisappear();
	void OnRescueCancelled();
	void OnSkillCheckFailed();
	void OnSkillCheckFailed_Cosmetic();

	class ASurvivor* GetCagedSurvivor() const;
	class UMontagePlayer* GetMontagePlayer() const;
	struct FVector GetRescuerSnapPosition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CageHook">();
	}
	static class ACageHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACageHook>();
	}
};
static_assert(alignof(ACageHook) == 0x000008, "Wrong alignment on ACageHook");
static_assert(sizeof(ACageHook) == 0x0006D0, "Wrong size on ACageHook");
static_assert(offsetof(ACageHook, _timeToBlockLocationOnRescue) == 0x000440, "Member 'ACageHook::_timeToBlockLocationOnRescue' has a wrong offset!");
static_assert(offsetof(ACageHook, _sacrificeScoreEvent) == 0x000468, "Member 'ACageHook::_sacrificeScoreEvent' has a wrong offset!");
static_assert(offsetof(ACageHook, _inMontageID) == 0x000474, "Member 'ACageHook::_inMontageID' has a wrong offset!");
static_assert(offsetof(ACageHook, _idleMontageID) == 0x000480, "Member 'ACageHook::_idleMontageID' has a wrong offset!");
static_assert(offsetof(ACageHook, _idleToStruggleMontageID) == 0x00048C, "Member 'ACageHook::_idleToStruggleMontageID' has a wrong offset!");
static_assert(offsetof(ACageHook, _struggleMontageID) == 0x000498, "Member 'ACageHook::_struggleMontageID' has a wrong offset!");
static_assert(offsetof(ACageHook, _struggleHitMontageID) == 0x0004A4, "Member 'ACageHook::_struggleHitMontageID' has a wrong offset!");
static_assert(offsetof(ACageHook, _deadMontageID) == 0x0004B0, "Member 'ACageHook::_deadMontageID' has a wrong offset!");
static_assert(offsetof(ACageHook, _relocateMontageID) == 0x0004BC, "Member 'ACageHook::_relocateMontageID' has a wrong offset!");
static_assert(offsetof(ACageHook, _goingUnderMontageID) == 0x0004C8, "Member 'ACageHook::_goingUnderMontageID' has a wrong offset!");
static_assert(offsetof(ACageHook, _survivorSocketID) == 0x0004D4, "Member 'ACageHook::_survivorSocketID' has a wrong offset!");
static_assert(offsetof(ACageHook, _rescuerSocketID) == 0x0004E0, "Member 'ACageHook::_rescuerSocketID' has a wrong offset!");
static_assert(offsetof(ACageHook, _cameraSocketID) == 0x0004EC, "Member 'ACageHook::_cameraSocketID' has a wrong offset!");
static_assert(offsetof(ACageHook, _rescueSocketID) == 0x0004F8, "Member 'ACageHook::_rescueSocketID' has a wrong offset!");
static_assert(offsetof(ACageHook, _sacrificeAfterMontageSecond) == 0x000504, "Member 'ACageHook::_sacrificeAfterMontageSecond' has a wrong offset!");
static_assert(offsetof(ACageHook, _goingUnderMontageSecond) == 0x000508, "Member 'ACageHook::_goingUnderMontageSecond' has a wrong offset!");
static_assert(offsetof(ACageHook, _furthestLocationSelectionCount) == 0x00050C, "Member 'ACageHook::_furthestLocationSelectionCount' has a wrong offset!");
static_assert(offsetof(ACageHook, _cagedSurvivor) == 0x000510, "Member 'ACageHook::_cagedSurvivor' has a wrong offset!");
static_assert(offsetof(ACageHook, _killerInstigator) == 0x000518, "Member 'ACageHook::_killerInstigator' has a wrong offset!");
static_assert(offsetof(ACageHook, _root) == 0x000520, "Member 'ACageHook::_root' has a wrong offset!");
static_assert(offsetof(ACageHook, _rescueChargeableComponent) == 0x000528, "Member 'ACageHook::_rescueChargeableComponent' has a wrong offset!");
static_assert(offsetof(ACageHook, _cageSkeletalMesh) == 0x000530, "Member 'ACageHook::_cageSkeletalMesh' has a wrong offset!");
static_assert(offsetof(ACageHook, _interactionZone) == 0x000538, "Member 'ACageHook::_interactionZone' has a wrong offset!");
static_assert(offsetof(ACageHook, _playerOverlapZone) == 0x000540, "Member 'ACageHook::_playerOverlapZone' has a wrong offset!");
static_assert(offsetof(ACageHook, _montagePlayer) == 0x000548, "Member 'ACageHook::_montagePlayer' has a wrong offset!");
static_assert(offsetof(ACageHook, _cageCollision) == 0x000560, "Member 'ACageHook::_cageCollision' has a wrong offset!");
static_assert(offsetof(ACageHook, _animationMontageSlave) == 0x0005B8, "Member 'ACageHook::_animationMontageSlave' has a wrong offset!");
static_assert(offsetof(ACageHook, _montageToPlay) == 0x0005C0, "Member 'ACageHook::_montageToPlay' has a wrong offset!");
static_assert(offsetof(ACageHook, _rescuerSnapPosition) == 0x0005D0, "Member 'ACageHook::_rescuerSnapPosition' has a wrong offset!");
static_assert(offsetof(ACageHook, _anticampComponent) == 0x0005E8, "Member 'ACageHook::_anticampComponent' has a wrong offset!");
static_assert(offsetof(ACageHook, _anticampDrainCooldownTime) == 0x000690, "Member 'ACageHook::_anticampDrainCooldownTime' has a wrong offset!");
static_assert(offsetof(ACageHook, _perceptionStimuliComponent) == 0x0006C8, "Member 'ACageHook::_perceptionStimuliComponent' has a wrong offset!");

// Class DBDGameplay.FlashlightComponent
// 0x0150 (0x0208 - 0x00B8)
class UFlashlightComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnFlashlightTurnedOn;                              // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFlashlightTurnedOff;                             // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFlashlightablesUpdated;                          // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FDBDTunableRowHandle                   _baseBlindnessDuration;                            // 0x00F0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	float                                         _baseAccuracy;                                     // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _lagDuration;                                      // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class UFlashlightableComponent*>         _flashlightables;                                  // 0x0120(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSet<class UFlashlightableComponent*>         _autonomousLitFlashlightables;                     // 0x0170(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UFlashlightableComponent*>       _replicatedLitFlashlightables;                     // 0x01C0(0x0010)(ExportObject, Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          _isOwnerLagging;                                   // 0x01D0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D1[0x37];                                     // 0x01D1(0x0037)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_IsOwnerLagging();
	void OnRep_ReplicatedLitFlashlightables();
	void Server_SetAndUpdateAutonomousLitFlashlightables(const TArray<class UFlashlightableComponent*>& newLitFlashlightables);
	void TurnOff();
	void TurnOn();

	float GetEffectiveBlindnessDuration() const;
	float GetEffectiveTimeToBlindModifier() const;
	bool IsOn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlashlightComponent">();
	}
	static class UFlashlightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlashlightComponent>();
	}
};
static_assert(alignof(UFlashlightComponent) == 0x000008, "Wrong alignment on UFlashlightComponent");
static_assert(sizeof(UFlashlightComponent) == 0x000208, "Wrong size on UFlashlightComponent");
static_assert(offsetof(UFlashlightComponent, OnFlashlightTurnedOn) == 0x0000C0, "Member 'UFlashlightComponent::OnFlashlightTurnedOn' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, OnFlashlightTurnedOff) == 0x0000D0, "Member 'UFlashlightComponent::OnFlashlightTurnedOff' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, OnFlashlightablesUpdated) == 0x0000E0, "Member 'UFlashlightComponent::OnFlashlightablesUpdated' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, _baseBlindnessDuration) == 0x0000F0, "Member 'UFlashlightComponent::_baseBlindnessDuration' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, _baseAccuracy) == 0x000118, "Member 'UFlashlightComponent::_baseAccuracy' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, _lagDuration) == 0x00011C, "Member 'UFlashlightComponent::_lagDuration' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, _flashlightables) == 0x000120, "Member 'UFlashlightComponent::_flashlightables' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, _autonomousLitFlashlightables) == 0x000170, "Member 'UFlashlightComponent::_autonomousLitFlashlightables' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, _replicatedLitFlashlightables) == 0x0001C0, "Member 'UFlashlightComponent::_replicatedLitFlashlightables' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, _isOwnerLagging) == 0x0001D0, "Member 'UFlashlightComponent::_isOwnerLagging' has a wrong offset!");

// Class DBDGameplay.FlashlightableLightingStrategy
// 0x0000 (0x0030 - 0x0030)
class UFlashlightableLightingStrategy : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlashlightableLightingStrategy">();
	}
	static class UFlashlightableLightingStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlashlightableLightingStrategy>();
	}
};
static_assert(alignof(UFlashlightableLightingStrategy) == 0x000008, "Wrong alignment on UFlashlightableLightingStrategy");
static_assert(sizeof(UFlashlightableLightingStrategy) == 0x000030, "Wrong size on UFlashlightableLightingStrategy");

// Class DBDGameplay.FlashlightablePointsLightingStrategy
// 0x0010 (0x0040 - 0x0030)
class UFlashlightablePointsLightingStrategy : public UFlashlightableLightingStrategy
{
public:
	class UPointsProvider*                        _pointsProvider;                                   // 0x0030(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoClear, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _impactPointDistanceError;                         // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlashlightablePointsLightingStrategy">();
	}
	static class UFlashlightablePointsLightingStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlashlightablePointsLightingStrategy>();
	}
};
static_assert(alignof(UFlashlightablePointsLightingStrategy) == 0x000008, "Wrong alignment on UFlashlightablePointsLightingStrategy");
static_assert(sizeof(UFlashlightablePointsLightingStrategy) == 0x000040, "Wrong size on UFlashlightablePointsLightingStrategy");
static_assert(offsetof(UFlashlightablePointsLightingStrategy, _pointsProvider) == 0x000030, "Member 'UFlashlightablePointsLightingStrategy::_pointsProvider' has a wrong offset!");
static_assert(offsetof(UFlashlightablePointsLightingStrategy, _impactPointDistanceError) == 0x000038, "Member 'UFlashlightablePointsLightingStrategy::_impactPointDistanceError' has a wrong offset!");

// Class DBDGameplay.CageRescueInteraction
// 0x0040 (0x0900 - 0x08C0)
#pragma pack(push, 0x1)
class alignas(0x10) UCageRescueInteraction : public UChargeableInteractionDefinition
{
public:
	struct FGameplayTag                           _cageRescueScoreEvent;                             // 0x08C0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8CC[0x4];                                      // 0x08CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _loudNoiseRange;                                   // 0x08D0(0x0028)(Edit, NativeAccessSpecifierPrivate)

public:
	struct FVector GetRescuerSnapPosition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CageRescueInteraction">();
	}
	static class UCageRescueInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCageRescueInteraction>();
	}
};
#pragma pack(pop)
static_assert(alignof(UCageRescueInteraction) == 0x000010, "Wrong alignment on UCageRescueInteraction");
static_assert(sizeof(UCageRescueInteraction) == 0x000900, "Wrong size on UCageRescueInteraction");
static_assert(offsetof(UCageRescueInteraction, _cageRescueScoreEvent) == 0x0008C0, "Member 'UCageRescueInteraction::_cageRescueScoreEvent' has a wrong offset!");
static_assert(offsetof(UCageRescueInteraction, _loudNoiseRange) == 0x0008D0, "Member 'UCageRescueInteraction::_loudNoiseRange' has a wrong offset!");

// Class DBDGameplay.BlockFeedbackBase
// 0x0008 (0x02A8 - 0x02A0)
class ABlockFeedbackBase : public AActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlockFeedbackBase">();
	}
	static class ABlockFeedbackBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABlockFeedbackBase>();
	}
};
static_assert(alignof(ABlockFeedbackBase) == 0x000008, "Wrong alignment on ABlockFeedbackBase");
static_assert(sizeof(ABlockFeedbackBase) == 0x0002A8, "Wrong size on ABlockFeedbackBase");

// Class DBDGameplay.SendToCageInteraction
// 0x0020 (0x0940 - 0x0920)
class USendToCageInteraction : public UBasicChargeableInteraction
{
public:
	struct FGameplayTag                           _sendToCageScoreEvent;                             // 0x0920(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_92C[0x4];                                      // 0x092C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACageHook>                  _cageHookClass;                                    // 0x0930(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _useKillerAsMontageLeader;                         // 0x0938(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_939[0x7];                                      // 0x0939(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FX_InteractionCancel();
	void FX_InteractionChargeCompleted(class ADBDPlayer* Player);
	void FX_InteractionStart();

	const class ASurvivor* GetOwningSurvivor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SendToCageInteraction">();
	}
	static class USendToCageInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USendToCageInteraction>();
	}
};
static_assert(alignof(USendToCageInteraction) == 0x000010, "Wrong alignment on USendToCageInteraction");
static_assert(sizeof(USendToCageInteraction) == 0x000940, "Wrong size on USendToCageInteraction");
static_assert(offsetof(USendToCageInteraction, _sendToCageScoreEvent) == 0x000920, "Member 'USendToCageInteraction::_sendToCageScoreEvent' has a wrong offset!");
static_assert(offsetof(USendToCageInteraction, _cageHookClass) == 0x000930, "Member 'USendToCageInteraction::_cageHookClass' has a wrong offset!");
static_assert(offsetof(USendToCageInteraction, _useKillerAsMontageLeader) == 0x000938, "Member 'USendToCageInteraction::_useKillerAsMontageLeader' has a wrong offset!");

// Class DBDGameplay.ContaminationAntidoteCollectable
// 0x0008 (0x05A8 - 0x05A0)
class AContaminationAntidoteCollectable : public ABaseSurvivorCollectable
{
public:
	class UFloatValueStrategy*                    _maxChargesStrategy;                               // 0x05A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContaminationAntidoteCollectable">();
	}
	static class AContaminationAntidoteCollectable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AContaminationAntidoteCollectable>();
	}
};
static_assert(alignof(AContaminationAntidoteCollectable) == 0x000008, "Wrong alignment on AContaminationAntidoteCollectable");
static_assert(sizeof(AContaminationAntidoteCollectable) == 0x0005A8, "Wrong size on AContaminationAntidoteCollectable");
static_assert(offsetof(AContaminationAntidoteCollectable, _maxChargesStrategy) == 0x0005A0, "Member 'AContaminationAntidoteCollectable::_maxChargesStrategy' has a wrong offset!");

// Class DBDGameplay.CageHookAntiCampComponent
// 0x0128 (0x01E0 - 0x00B8)
class UCageHookAntiCampComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x48];                                      // 0x00B8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _anticampZoneDistance;                             // 0x0100(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _anticampZoneTimeToTrigger;                        // 0x0128(0x0028)(Edit, NativeAccessSpecifierPrivate)
	bool                                          _stopAnticampWhenSurvivorInRange;                  // 0x0150(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_151[0x8F];                                     // 0x0151(0x008F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_TriggerAntiCamp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CageHookAntiCampComponent">();
	}
	static class UCageHookAntiCampComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCageHookAntiCampComponent>();
	}
};
static_assert(alignof(UCageHookAntiCampComponent) == 0x000008, "Wrong alignment on UCageHookAntiCampComponent");
static_assert(sizeof(UCageHookAntiCampComponent) == 0x0001E0, "Wrong size on UCageHookAntiCampComponent");
static_assert(offsetof(UCageHookAntiCampComponent, _anticampZoneDistance) == 0x000100, "Member 'UCageHookAntiCampComponent::_anticampZoneDistance' has a wrong offset!");
static_assert(offsetof(UCageHookAntiCampComponent, _anticampZoneTimeToTrigger) == 0x000128, "Member 'UCageHookAntiCampComponent::_anticampZoneTimeToTrigger' has a wrong offset!");
static_assert(offsetof(UCageHookAntiCampComponent, _stopAnticampWhenSurvivorInRange) == 0x000150, "Member 'UCageHookAntiCampComponent::_stopAnticampWhenSurvivorInRange' has a wrong offset!");

// Class DBDGameplay.TerrorRadiusEmitterFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UTerrorRadiusEmitterFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static int32 GetActiveFakeTerrorRadiusEmittersCount(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TerrorRadiusEmitterFunctionLibrary">();
	}
	static class UTerrorRadiusEmitterFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTerrorRadiusEmitterFunctionLibrary>();
	}
};
static_assert(alignof(UTerrorRadiusEmitterFunctionLibrary) == 0x000008, "Wrong alignment on UTerrorRadiusEmitterFunctionLibrary");
static_assert(sizeof(UTerrorRadiusEmitterFunctionLibrary) == 0x000030, "Wrong size on UTerrorRadiusEmitterFunctionLibrary");

// Class DBDGameplay.BaseSightManagerComponent
// 0x00B0 (0x0168 - 0x00B8)
class UBaseSightManagerComponent : public UActorComponent
{
public:
	struct FDBDTunableRowHandle                   _maximumSightDistance;                             // 0x00B8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _sightingDelay;                                    // 0x00E0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _discerningDelay;                                  // 0x0108(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _undiscerningDelay;                                // 0x0130(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSurvivorLookStatus>            _survivorLookStatus;                               // 0x0158(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void Authority_OnCharacterSightChanged(class ACharacter* sightedCharacter, class UCharacterSightComponent* sightComponent);
	void OnIntroCompleted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseSightManagerComponent">();
	}
	static class UBaseSightManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseSightManagerComponent>();
	}
};
static_assert(alignof(UBaseSightManagerComponent) == 0x000008, "Wrong alignment on UBaseSightManagerComponent");
static_assert(sizeof(UBaseSightManagerComponent) == 0x000168, "Wrong size on UBaseSightManagerComponent");
static_assert(offsetof(UBaseSightManagerComponent, _maximumSightDistance) == 0x0000B8, "Member 'UBaseSightManagerComponent::_maximumSightDistance' has a wrong offset!");
static_assert(offsetof(UBaseSightManagerComponent, _sightingDelay) == 0x0000E0, "Member 'UBaseSightManagerComponent::_sightingDelay' has a wrong offset!");
static_assert(offsetof(UBaseSightManagerComponent, _discerningDelay) == 0x000108, "Member 'UBaseSightManagerComponent::_discerningDelay' has a wrong offset!");
static_assert(offsetof(UBaseSightManagerComponent, _undiscerningDelay) == 0x000130, "Member 'UBaseSightManagerComponent::_undiscerningDelay' has a wrong offset!");
static_assert(offsetof(UBaseSightManagerComponent, _survivorLookStatus) == 0x000158, "Member 'UBaseSightManagerComponent::_survivorLookStatus' has a wrong offset!");

// Class DBDGameplay.FlashlightTargetFXComponent
// 0x0048 (0x0100 - 0x00B8)
class UFlashlightTargetFXComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x30];                                      // 0x00B8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _modifiesBeamAngle;                                // 0x00E8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFlashlightableComponent*               _flashlightable;                                   // 0x00F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnIsLitChanged(bool IsLit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlashlightTargetFXComponent">();
	}
	static class UFlashlightTargetFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlashlightTargetFXComponent>();
	}
};
static_assert(alignof(UFlashlightTargetFXComponent) == 0x000008, "Wrong alignment on UFlashlightTargetFXComponent");
static_assert(sizeof(UFlashlightTargetFXComponent) == 0x000100, "Wrong size on UFlashlightTargetFXComponent");
static_assert(offsetof(UFlashlightTargetFXComponent, _modifiesBeamAngle) == 0x0000E8, "Member 'UFlashlightTargetFXComponent::_modifiesBeamAngle' has a wrong offset!");
static_assert(offsetof(UFlashlightTargetFXComponent, _flashlightable) == 0x0000F0, "Member 'UFlashlightTargetFXComponent::_flashlightable' has a wrong offset!");

// Class DBDGameplay.BlindFlashlightTargetFXComponent
// 0x0030 (0x0130 - 0x0100)
class UBlindFlashlightTargetFXComponent final : public UFlashlightTargetFXComponent
{
public:
	uint8                                         Pad_100[0x30];                                     // 0x0100(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlindFlashlightTargetFXComponent">();
	}
	static class UBlindFlashlightTargetFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlindFlashlightTargetFXComponent>();
	}
};
static_assert(alignof(UBlindFlashlightTargetFXComponent) == 0x000008, "Wrong alignment on UBlindFlashlightTargetFXComponent");
static_assert(sizeof(UBlindFlashlightTargetFXComponent) == 0x000130, "Wrong size on UBlindFlashlightTargetFXComponent");

// Class DBDGameplay.FootstepCreatorComponent
// 0x0050 (0x0108 - 0x00B8)
class UFootstepCreatorComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x20];                                      // 0x00B8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _fadeCurve;                                        // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _veinsCurve;                                       // 0x00E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UFootstepManagerComponent>  _footstepManagerComponentClass;                    // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0[0x8];                                       // 0x00F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _secondsUntilFootprintTrigger;                     // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _canSpawnFootstepsDefaultValue;                    // 0x00FC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FD[0xB];                                       // 0x00FD(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootstepCreatorComponent">();
	}
	static class UFootstepCreatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootstepCreatorComponent>();
	}
};
static_assert(alignof(UFootstepCreatorComponent) == 0x000008, "Wrong alignment on UFootstepCreatorComponent");
static_assert(sizeof(UFootstepCreatorComponent) == 0x000108, "Wrong size on UFootstepCreatorComponent");
static_assert(offsetof(UFootstepCreatorComponent, _fadeCurve) == 0x0000D8, "Member 'UFootstepCreatorComponent::_fadeCurve' has a wrong offset!");
static_assert(offsetof(UFootstepCreatorComponent, _veinsCurve) == 0x0000E0, "Member 'UFootstepCreatorComponent::_veinsCurve' has a wrong offset!");
static_assert(offsetof(UFootstepCreatorComponent, _footstepManagerComponentClass) == 0x0000E8, "Member 'UFootstepCreatorComponent::_footstepManagerComponentClass' has a wrong offset!");
static_assert(offsetof(UFootstepCreatorComponent, _secondsUntilFootprintTrigger) == 0x0000F8, "Member 'UFootstepCreatorComponent::_secondsUntilFootprintTrigger' has a wrong offset!");
static_assert(offsetof(UFootstepCreatorComponent, _canSpawnFootstepsDefaultValue) == 0x0000FC, "Member 'UFootstepCreatorComponent::_canSpawnFootstepsDefaultValue' has a wrong offset!");

// Class DBDGameplay.SurvivorFootstepCreatorComponent
// 0x0238 (0x0340 - 0x0108)
class USurvivorFootstepCreatorComponent final : public UFootstepCreatorComponent
{
public:
	TArray<struct FGameplayTag>                   _disallowFootstepsSpawnPerkFlags;                  // 0x0108(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FStatProperty                          _footstepIndicatorAngle;                           // 0x0118(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FStatProperty                          _footstepIndicatorDecalSize;                       // 0x01A0(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FStatProperty                          _footstepIndicatorDurationAdditive;                // 0x0228(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FStatProperty                          _footstepIndicatorDurationMultiplictive;           // 0x02B0(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLoudNoiseTriggered(class AActor* originator, class AActor* instigatingActor, const struct FVector& Location, bool shouldTrack, float* audibleRange, bool isQuickAction, bool isDeceivingNoise);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorFootstepCreatorComponent">();
	}
	static class USurvivorFootstepCreatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorFootstepCreatorComponent>();
	}
};
static_assert(alignof(USurvivorFootstepCreatorComponent) == 0x000008, "Wrong alignment on USurvivorFootstepCreatorComponent");
static_assert(sizeof(USurvivorFootstepCreatorComponent) == 0x000340, "Wrong size on USurvivorFootstepCreatorComponent");
static_assert(offsetof(USurvivorFootstepCreatorComponent, _disallowFootstepsSpawnPerkFlags) == 0x000108, "Member 'USurvivorFootstepCreatorComponent::_disallowFootstepsSpawnPerkFlags' has a wrong offset!");
static_assert(offsetof(USurvivorFootstepCreatorComponent, _footstepIndicatorAngle) == 0x000118, "Member 'USurvivorFootstepCreatorComponent::_footstepIndicatorAngle' has a wrong offset!");
static_assert(offsetof(USurvivorFootstepCreatorComponent, _footstepIndicatorDecalSize) == 0x0001A0, "Member 'USurvivorFootstepCreatorComponent::_footstepIndicatorDecalSize' has a wrong offset!");
static_assert(offsetof(USurvivorFootstepCreatorComponent, _footstepIndicatorDurationAdditive) == 0x000228, "Member 'USurvivorFootstepCreatorComponent::_footstepIndicatorDurationAdditive' has a wrong offset!");
static_assert(offsetof(USurvivorFootstepCreatorComponent, _footstepIndicatorDurationMultiplictive) == 0x0002B0, "Member 'USurvivorFootstepCreatorComponent::_footstepIndicatorDurationMultiplictive' has a wrong offset!");

// Class DBDGameplay.UseContaminationAntidoteInteraction
// 0x0020 (0x08E0 - 0x08C0)
class UUseContaminationAntidoteInteraction : public UChargeableInteractionDefinition
{
public:
	class FName                                   _contaminationAntidoteItemId;                      // 0x08C0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8CC[0x4];                                      // 0x08CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFloatValueStrategy*                    _killerInstinctDurationStrategy;                   // 0x08D0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _killerInstinctClass;                              // 0x08D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class ASurvivor* GetInteractionTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UseContaminationAntidoteInteraction">();
	}
	static class UUseContaminationAntidoteInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUseContaminationAntidoteInteraction>();
	}
};
static_assert(alignof(UUseContaminationAntidoteInteraction) == 0x000010, "Wrong alignment on UUseContaminationAntidoteInteraction");
static_assert(sizeof(UUseContaminationAntidoteInteraction) == 0x0008E0, "Wrong size on UUseContaminationAntidoteInteraction");
static_assert(offsetof(UUseContaminationAntidoteInteraction, _contaminationAntidoteItemId) == 0x0008C0, "Member 'UUseContaminationAntidoteInteraction::_contaminationAntidoteItemId' has a wrong offset!");
static_assert(offsetof(UUseContaminationAntidoteInteraction, _killerInstinctDurationStrategy) == 0x0008D0, "Member 'UUseContaminationAntidoteInteraction::_killerInstinctDurationStrategy' has a wrong offset!");
static_assert(offsetof(UUseContaminationAntidoteInteraction, _killerInstinctClass) == 0x0008D8, "Member 'UUseContaminationAntidoteInteraction::_killerInstinctClass' has a wrong offset!");

// Class DBDGameplay.GlassBeadMapAddon
// 0x0018 (0x0318 - 0x0300)
class UGlassBeadMapAddon final : public UItemAddon
{
public:
	uint8                                         Pad_300[0x4];                                      // 0x0300(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _spawningCooldownTimer;                            // 0x0304(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AMapMarkerActor>            _mapMarkerBPClass;                                 // 0x0308(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AMapMarkerActor*                        _currentMapMarker;                                 // 0x0310(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnSecondaryInputPressed(class ADBDPlayer* Player, class UInteractionDefinition* Interaction, bool fromCancelRequest);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlassBeadMapAddon">();
	}
	static class UGlassBeadMapAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlassBeadMapAddon>();
	}
};
static_assert(alignof(UGlassBeadMapAddon) == 0x000008, "Wrong alignment on UGlassBeadMapAddon");
static_assert(sizeof(UGlassBeadMapAddon) == 0x000318, "Wrong size on UGlassBeadMapAddon");
static_assert(offsetof(UGlassBeadMapAddon, _spawningCooldownTimer) == 0x000304, "Member 'UGlassBeadMapAddon::_spawningCooldownTimer' has a wrong offset!");
static_assert(offsetof(UGlassBeadMapAddon, _mapMarkerBPClass) == 0x000308, "Member 'UGlassBeadMapAddon::_mapMarkerBPClass' has a wrong offset!");
static_assert(offsetof(UGlassBeadMapAddon, _currentMapMarker) == 0x000310, "Member 'UGlassBeadMapAddon::_currentMapMarker' has a wrong offset!");

// Class DBDGameplay.DLCCheatComponent
// 0x0000 (0x00B8 - 0x00B8)
class UDLCCheatComponent : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DLCCheatComponent">();
	}
	static class UDLCCheatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDLCCheatComponent>();
	}
};
static_assert(alignof(UDLCCheatComponent) == 0x000008, "Wrong alignment on UDLCCheatComponent");
static_assert(sizeof(UDLCCheatComponent) == 0x0000B8, "Wrong size on UDLCCheatComponent");

// Class DBDGameplay.KillerPower
// 0x00B8 (0x0610 - 0x0558)
class AKillerPower : public ACollectable
{
public:
	uint8                                         Pad_558[0x8];                                      // 0x0558(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractor*                            _interactor;                                       // 0x0560(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxPlayerOverlapComponent*             _interactionVolume;                                // 0x0568(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FKillerPowerSpawnableStatusEffectData> _survivorStatusEffects;                     // 0x0570(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FKillerPowerSpawnableStatusEffectData> _killerStatusEffects;                       // 0x0580(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FKillerPowerSpawnableComponents> _survivorComponents;                              // 0x0590(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FKillerPowerSpawnableComponents> _killerComponents;                                // 0x05A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UDLCCheatComponent>         _cheatComponentClass;                              // 0x05B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AKiller>                 _owningKiller;                                     // 0x05B8(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UPowerWidgetPresentationComponent*> _powerWidgetPresentationComponents;             // 0x05C0(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D0[0x40];                                     // 0x05D0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_OwningKiller();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerPower">();
	}
	static class AKillerPower* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKillerPower>();
	}
};
static_assert(alignof(AKillerPower) == 0x000008, "Wrong alignment on AKillerPower");
static_assert(sizeof(AKillerPower) == 0x000610, "Wrong size on AKillerPower");
static_assert(offsetof(AKillerPower, _interactor) == 0x000560, "Member 'AKillerPower::_interactor' has a wrong offset!");
static_assert(offsetof(AKillerPower, _interactionVolume) == 0x000568, "Member 'AKillerPower::_interactionVolume' has a wrong offset!");
static_assert(offsetof(AKillerPower, _survivorStatusEffects) == 0x000570, "Member 'AKillerPower::_survivorStatusEffects' has a wrong offset!");
static_assert(offsetof(AKillerPower, _killerStatusEffects) == 0x000580, "Member 'AKillerPower::_killerStatusEffects' has a wrong offset!");
static_assert(offsetof(AKillerPower, _survivorComponents) == 0x000590, "Member 'AKillerPower::_survivorComponents' has a wrong offset!");
static_assert(offsetof(AKillerPower, _killerComponents) == 0x0005A0, "Member 'AKillerPower::_killerComponents' has a wrong offset!");
static_assert(offsetof(AKillerPower, _cheatComponentClass) == 0x0005B0, "Member 'AKillerPower::_cheatComponentClass' has a wrong offset!");
static_assert(offsetof(AKillerPower, _owningKiller) == 0x0005B8, "Member 'AKillerPower::_owningKiller' has a wrong offset!");
static_assert(offsetof(AKillerPower, _powerWidgetPresentationComponents) == 0x0005C0, "Member 'AKillerPower::_powerWidgetPresentationComponents' has a wrong offset!");

// Class DBDGameplay.TargetingComponent
// 0x0048 (0x0100 - 0x00B8)
class UTargetingComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          _onBestTargetChangedAudioEvent;                    // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTargetableComponent*>           _targets;                                          // 0x00D8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UTargetingStrategy*                     _targetingStrategy;                                // 0x00E8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ADBDActorIndicator>         _targetIndicatorClass;                             // 0x00F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDActorIndicator*                     _targetIndicator;                                  // 0x00F8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetingComponent">();
	}
	static class UTargetingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetingComponent>();
	}
};
static_assert(alignof(UTargetingComponent) == 0x000008, "Wrong alignment on UTargetingComponent");
static_assert(sizeof(UTargetingComponent) == 0x000100, "Wrong size on UTargetingComponent");
static_assert(offsetof(UTargetingComponent, _onBestTargetChangedAudioEvent) == 0x0000C8, "Member 'UTargetingComponent::_onBestTargetChangedAudioEvent' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, _targets) == 0x0000D8, "Member 'UTargetingComponent::_targets' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, _targetingStrategy) == 0x0000E8, "Member 'UTargetingComponent::_targetingStrategy' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, _targetIndicatorClass) == 0x0000F0, "Member 'UTargetingComponent::_targetIndicatorClass' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, _targetIndicator) == 0x0000F8, "Member 'UTargetingComponent::_targetIndicator' has a wrong offset!");

// Class DBDGameplay.WormholeFatherTerminal
// 0x0008 (0x03B0 - 0x03A8)
class AWormholeFatherTerminal final : public AInteractable
{
public:
	class USceneComponent*                        _wormholeKeyCardAttachment;                        // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WormholeFatherTerminal">();
	}
	static class AWormholeFatherTerminal* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWormholeFatherTerminal>();
	}
};
static_assert(alignof(AWormholeFatherTerminal) == 0x000008, "Wrong alignment on AWormholeFatherTerminal");
static_assert(sizeof(AWormholeFatherTerminal) == 0x0003B0, "Wrong size on AWormholeFatherTerminal");
static_assert(offsetof(AWormholeFatherTerminal, _wormholeKeyCardAttachment) == 0x0003A8, "Member 'AWormholeFatherTerminal::_wormholeKeyCardAttachment' has a wrong offset!");

// Class DBDGameplay.BaseHusk
// 0x0040 (0x02E8 - 0x02A8)
class ABaseHusk : public ABaseVFX
{
public:
	uint8                                         Pad_2A8[0x18];                                     // 0x02A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        _rootComponent;                                    // 0x02C0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDSkeletalMeshComponentBudgeted*      _huskMesh;                                         // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCustomizedSkeletalMesh*                _huskCustomizedSkeletalMesh;                       // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _shouldDeactivateVFX;                              // 0x02D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D9[0xB];                                      // 0x02D9(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _updateWeaponAccessories;                          // 0x02E4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _shouldWeaponBeVisible;                            // 0x02E5(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E6[0x2];                                      // 0x02E6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_InitializeSkeletalMesh(class USkeletalMeshComponent* Mesh);
	void InitializeHusk(class UCustomizedSkeletalMesh* customizedSkeletalMeshToCopy, class USkeletalMeshComponent* skeletalMeshToCopy, int32 characterIdOverride);
	void SetHuskVisibility(bool Visible);
	void SetScalarParameterOnAllChildrenMeshes(class FName ParameterName, float Value, class USkeletalMeshComponent* Mesh);

	const class UCustomizedSkeletalMesh* GetCopiedCustomizedSkeletalMesh() const;
	class USkeletalMeshComponent* GetMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseHusk">();
	}
	static class ABaseHusk* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseHusk>();
	}
};
static_assert(alignof(ABaseHusk) == 0x000008, "Wrong alignment on ABaseHusk");
static_assert(sizeof(ABaseHusk) == 0x0002E8, "Wrong size on ABaseHusk");
static_assert(offsetof(ABaseHusk, _rootComponent) == 0x0002C0, "Member 'ABaseHusk::_rootComponent' has a wrong offset!");
static_assert(offsetof(ABaseHusk, _huskMesh) == 0x0002C8, "Member 'ABaseHusk::_huskMesh' has a wrong offset!");
static_assert(offsetof(ABaseHusk, _huskCustomizedSkeletalMesh) == 0x0002D0, "Member 'ABaseHusk::_huskCustomizedSkeletalMesh' has a wrong offset!");
static_assert(offsetof(ABaseHusk, _shouldDeactivateVFX) == 0x0002D8, "Member 'ABaseHusk::_shouldDeactivateVFX' has a wrong offset!");
static_assert(offsetof(ABaseHusk, _updateWeaponAccessories) == 0x0002E4, "Member 'ABaseHusk::_updateWeaponAccessories' has a wrong offset!");
static_assert(offsetof(ABaseHusk, _shouldWeaponBeVisible) == 0x0002E5, "Member 'ABaseHusk::_shouldWeaponBeVisible' has a wrong offset!");

// Class DBDGameplay.KillerAbilityComponent
// 0x0128 (0x01E0 - 0x00B8)
class UKillerAbilityComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UKillerAbilityData*                     _abilityData;                                      // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UPowerWidgetPresentationComponent*> _powerWidgetPresentationComponents;             // 0x00C8(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0xC0];                                      // 0x00D8(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class ASurvivorCosmeticHelperActor>> _survivorCosmeticHelperActorsToSpawn;    // 0x0198(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class ADBDPlayerCosmeticHelperActor>> _killerCosmeticHelperActorsToSpawn;     // 0x01A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UTimerObject*                           _cooldownTimer;                                    // 0x01B8(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTimerObject*                           _durationTimer;                                    // 0x01C0(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTimerObject*                           _tokenRechargeTimer;                               // 0x01C8(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _tokenCount;                                       // 0x01D0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D4[0xC];                                      // 0x01D4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnIntroComplete();
	void OnRep_CooldownTimer();
	void OnRep_DurationTimer();
	void OnRep_TokenCount(const int32 oldCount);
	void OnRep_TokenRechargeTimer();

	float GetCooldown() const;
	float GetDuration() const;
	class AKiller* GetOwningKiller() const;
	class AKillerPower* GetOwningPower() const;
	float GetRemainingCooldown() const;
	float GetRemainingCooldownPercent() const;
	float GetRemainingDurationPercent() const;
	bool IsApplicable() const;
	bool IsAvailable() const;
	bool IsDurationTimerActive() const;
	bool IsOnCooldown() const;
	void PlayAudioOnOwningKiller(class UAkAudioEvent* AudioEvent, bool OnlyPlayIfLocallyObserved) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerAbilityComponent">();
	}
	static class UKillerAbilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerAbilityComponent>();
	}
};
static_assert(alignof(UKillerAbilityComponent) == 0x000008, "Wrong alignment on UKillerAbilityComponent");
static_assert(sizeof(UKillerAbilityComponent) == 0x0001E0, "Wrong size on UKillerAbilityComponent");
static_assert(offsetof(UKillerAbilityComponent, _abilityData) == 0x0000C0, "Member 'UKillerAbilityComponent::_abilityData' has a wrong offset!");
static_assert(offsetof(UKillerAbilityComponent, _powerWidgetPresentationComponents) == 0x0000C8, "Member 'UKillerAbilityComponent::_powerWidgetPresentationComponents' has a wrong offset!");
static_assert(offsetof(UKillerAbilityComponent, _survivorCosmeticHelperActorsToSpawn) == 0x000198, "Member 'UKillerAbilityComponent::_survivorCosmeticHelperActorsToSpawn' has a wrong offset!");
static_assert(offsetof(UKillerAbilityComponent, _killerCosmeticHelperActorsToSpawn) == 0x0001A8, "Member 'UKillerAbilityComponent::_killerCosmeticHelperActorsToSpawn' has a wrong offset!");
static_assert(offsetof(UKillerAbilityComponent, _cooldownTimer) == 0x0001B8, "Member 'UKillerAbilityComponent::_cooldownTimer' has a wrong offset!");
static_assert(offsetof(UKillerAbilityComponent, _durationTimer) == 0x0001C0, "Member 'UKillerAbilityComponent::_durationTimer' has a wrong offset!");
static_assert(offsetof(UKillerAbilityComponent, _tokenRechargeTimer) == 0x0001C8, "Member 'UKillerAbilityComponent::_tokenRechargeTimer' has a wrong offset!");
static_assert(offsetof(UKillerAbilityComponent, _tokenCount) == 0x0001D0, "Member 'UKillerAbilityComponent::_tokenCount' has a wrong offset!");

// Class DBDGameplay.AudioBlockFeedback
// 0x0018 (0x02C0 - 0x02A8)
class AAudioBlockFeedback final : public ABlockFeedbackBase
{
public:
	class UAkAudioEvent*                          _akAudioEventBlockStart;                           // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          _akAudioEventBlockStop;                            // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           _blockableAudioComponent;                          // 0x02B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AudioBlockFeedback">();
	}
	static class AAudioBlockFeedback* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAudioBlockFeedback>();
	}
};
static_assert(alignof(AAudioBlockFeedback) == 0x000008, "Wrong alignment on AAudioBlockFeedback");
static_assert(sizeof(AAudioBlockFeedback) == 0x0002C0, "Wrong size on AAudioBlockFeedback");
static_assert(offsetof(AAudioBlockFeedback, _akAudioEventBlockStart) == 0x0002A8, "Member 'AAudioBlockFeedback::_akAudioEventBlockStart' has a wrong offset!");
static_assert(offsetof(AAudioBlockFeedback, _akAudioEventBlockStop) == 0x0002B0, "Member 'AAudioBlockFeedback::_akAudioEventBlockStop' has a wrong offset!");
static_assert(offsetof(AAudioBlockFeedback, _blockableAudioComponent) == 0x0002B8, "Member 'AAudioBlockFeedback::_blockableAudioComponent' has a wrong offset!");

// Class DBDGameplay.KillerAbilityData
// 0x0038 (0x0070 - 0x0038)
class UKillerAbilityData : public UDataAsset
{
public:
	float                                         _cooldown;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _startsOnCooldown;                                 // 0x003C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _duration;                                         // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isTokenBased;                                     // 0x0044(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _startTokenCount;                                  // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _maxTokenCount;                                    // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _shouldAutomaticallyRechargeTokens;                // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _timeRequiredToChargeToken;                        // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _availabilityRequiresAToken;                       // 0x0058(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          _onCooldownCompletedAkEvent;                       // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          _onTokenAddedAkEvent;                              // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	float GetCooldown() const;
	float GetDuration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerAbilityData">();
	}
	static class UKillerAbilityData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerAbilityData>();
	}
};
static_assert(alignof(UKillerAbilityData) == 0x000008, "Wrong alignment on UKillerAbilityData");
static_assert(sizeof(UKillerAbilityData) == 0x000070, "Wrong size on UKillerAbilityData");
static_assert(offsetof(UKillerAbilityData, _cooldown) == 0x000038, "Member 'UKillerAbilityData::_cooldown' has a wrong offset!");
static_assert(offsetof(UKillerAbilityData, _startsOnCooldown) == 0x00003C, "Member 'UKillerAbilityData::_startsOnCooldown' has a wrong offset!");
static_assert(offsetof(UKillerAbilityData, _duration) == 0x000040, "Member 'UKillerAbilityData::_duration' has a wrong offset!");
static_assert(offsetof(UKillerAbilityData, _isTokenBased) == 0x000044, "Member 'UKillerAbilityData::_isTokenBased' has a wrong offset!");
static_assert(offsetof(UKillerAbilityData, _startTokenCount) == 0x000048, "Member 'UKillerAbilityData::_startTokenCount' has a wrong offset!");
static_assert(offsetof(UKillerAbilityData, _maxTokenCount) == 0x00004C, "Member 'UKillerAbilityData::_maxTokenCount' has a wrong offset!");
static_assert(offsetof(UKillerAbilityData, _shouldAutomaticallyRechargeTokens) == 0x000050, "Member 'UKillerAbilityData::_shouldAutomaticallyRechargeTokens' has a wrong offset!");
static_assert(offsetof(UKillerAbilityData, _timeRequiredToChargeToken) == 0x000054, "Member 'UKillerAbilityData::_timeRequiredToChargeToken' has a wrong offset!");
static_assert(offsetof(UKillerAbilityData, _availabilityRequiresAToken) == 0x000058, "Member 'UKillerAbilityData::_availabilityRequiresAToken' has a wrong offset!");
static_assert(offsetof(UKillerAbilityData, _onCooldownCompletedAkEvent) == 0x000060, "Member 'UKillerAbilityData::_onCooldownCompletedAkEvent' has a wrong offset!");
static_assert(offsetof(UKillerAbilityData, _onTokenAddedAkEvent) == 0x000068, "Member 'UKillerAbilityData::_onTokenAddedAkEvent' has a wrong offset!");

// Class DBDGameplay.TargetableStrategy
// 0x0018 (0x0048 - 0x0030)
class UTargetableStrategy : public UObject
{
public:
	bool                                          _isRangeBased;                                     // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasMinTargetableDistance;                         // 0x0031(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _minTargetableDistance;                            // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasMaxTargetableDistance;                         // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _maxTargetableDistance;                            // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _useCurrentCameraTargetInsteadOfPlayerLocation;    // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetableStrategy">();
	}
	static class UTargetableStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetableStrategy>();
	}
};
static_assert(alignof(UTargetableStrategy) == 0x000008, "Wrong alignment on UTargetableStrategy");
static_assert(sizeof(UTargetableStrategy) == 0x000048, "Wrong size on UTargetableStrategy");
static_assert(offsetof(UTargetableStrategy, _isRangeBased) == 0x000030, "Member 'UTargetableStrategy::_isRangeBased' has a wrong offset!");
static_assert(offsetof(UTargetableStrategy, _hasMinTargetableDistance) == 0x000031, "Member 'UTargetableStrategy::_hasMinTargetableDistance' has a wrong offset!");
static_assert(offsetof(UTargetableStrategy, _minTargetableDistance) == 0x000034, "Member 'UTargetableStrategy::_minTargetableDistance' has a wrong offset!");
static_assert(offsetof(UTargetableStrategy, _hasMaxTargetableDistance) == 0x000038, "Member 'UTargetableStrategy::_hasMaxTargetableDistance' has a wrong offset!");
static_assert(offsetof(UTargetableStrategy, _maxTargetableDistance) == 0x00003C, "Member 'UTargetableStrategy::_maxTargetableDistance' has a wrong offset!");
static_assert(offsetof(UTargetableStrategy, _useCurrentCameraTargetInsteadOfPlayerLocation) == 0x000040, "Member 'UTargetableStrategy::_useCurrentCameraTargetInsteadOfPlayerLocation' has a wrong offset!");

// Class DBDGameplay.CrowTriggerComponent
// 0x0038 (0x01F8 - 0x01C0)
class UCrowTriggerComponent : public UTriggerableWorldObjectComponent
{
public:
	TSubclassOf<class ABubbleIndicator>           _bubbleIndicatorBP;                                // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _takeoffSpeedThreshold;                            // 0x01C8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         _bubbleIndicatorLifetime;                          // 0x01F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _numberOfCrows;                                    // 0x01F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrowTriggerComponent">();
	}
	static class UCrowTriggerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrowTriggerComponent>();
	}
};
static_assert(alignof(UCrowTriggerComponent) == 0x000008, "Wrong alignment on UCrowTriggerComponent");
static_assert(sizeof(UCrowTriggerComponent) == 0x0001F8, "Wrong size on UCrowTriggerComponent");
static_assert(offsetof(UCrowTriggerComponent, _bubbleIndicatorBP) == 0x0001C0, "Member 'UCrowTriggerComponent::_bubbleIndicatorBP' has a wrong offset!");
static_assert(offsetof(UCrowTriggerComponent, _takeoffSpeedThreshold) == 0x0001C8, "Member 'UCrowTriggerComponent::_takeoffSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UCrowTriggerComponent, _bubbleIndicatorLifetime) == 0x0001F0, "Member 'UCrowTriggerComponent::_bubbleIndicatorLifetime' has a wrong offset!");
static_assert(offsetof(UCrowTriggerComponent, _numberOfCrows) == 0x0001F4, "Member 'UCrowTriggerComponent::_numberOfCrows' has a wrong offset!");

// Class DBDGameplay.TargetableComponent
// 0x00A0 (0x0370 - 0x02D0)
#pragma pack(push, 0x1)
class alignas(0x10) UTargetableComponent : public USceneComponent
{
public:
	class UTargetableStrategy*                    _targetableStrategy;                               // 0x02D0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             _relativeTransformToTargetActor;                   // 0x02E0(0x0060)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_340[0x2];                                      // 0x0340(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _targetingUpdatesOutline;                          // 0x0342(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_343[0x1];                                      // 0x0343(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           _outlineColorWhenAnAvailableTarget;                // 0x0344(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _outlineColorWhenBeingTargeted;                    // 0x0354(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_364[0x4];                                      // 0x0364(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetableComponent">();
	}
	static class UTargetableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetableComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UTargetableComponent) == 0x000010, "Wrong alignment on UTargetableComponent");
static_assert(sizeof(UTargetableComponent) == 0x000370, "Wrong size on UTargetableComponent");
static_assert(offsetof(UTargetableComponent, _targetableStrategy) == 0x0002D0, "Member 'UTargetableComponent::_targetableStrategy' has a wrong offset!");
static_assert(offsetof(UTargetableComponent, _relativeTransformToTargetActor) == 0x0002E0, "Member 'UTargetableComponent::_relativeTransformToTargetActor' has a wrong offset!");
static_assert(offsetof(UTargetableComponent, _targetingUpdatesOutline) == 0x000342, "Member 'UTargetableComponent::_targetingUpdatesOutline' has a wrong offset!");
static_assert(offsetof(UTargetableComponent, _outlineColorWhenAnAvailableTarget) == 0x000344, "Member 'UTargetableComponent::_outlineColorWhenAnAvailableTarget' has a wrong offset!");
static_assert(offsetof(UTargetableComponent, _outlineColorWhenBeingTargeted) == 0x000354, "Member 'UTargetableComponent::_outlineColorWhenBeingTargeted' has a wrong offset!");

// Class DBDGameplay.AuraOverriderComponent
// 0x0050 (0x0108 - 0x00B8)
class UAuraOverriderComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x50];                                      // 0x00B8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceShowAura(const class AActor* Actor, const struct FLinearColor& Color, bool IsAlwaysVisible, const float MinimumOutlineDistanceVisible, const float MinimumOutlineDistance);
	void ResetAura(const class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuraOverriderComponent">();
	}
	static class UAuraOverriderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuraOverriderComponent>();
	}
};
static_assert(alignof(UAuraOverriderComponent) == 0x000008, "Wrong alignment on UAuraOverriderComponent");
static_assert(sizeof(UAuraOverriderComponent) == 0x000108, "Wrong size on UAuraOverriderComponent");

// Class DBDGameplay.TeleportPositionFinderComponent
// 0x00F0 (0x01A8 - 0x00B8)
class UTeleportPositionFinderComponent : public UActorComponent
{
public:
	float                                         _rayCastZOffet;                                    // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _raycastLength;                                    // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _killerInRangeMinimumDistanceCheck;                // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _killerInRangeMaxRangePercentage;                  // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _deltaHeightThreshold;                             // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _minDistanceFromTarget;                            // 0x00D0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _maxDistanceFromTarget;                            // 0x00F8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_120[0x10];                                     // 0x0120(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _timeBetweenFailsafeChecks;                        // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_134[0x44];                                     // 0x0134(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AEscapeDoor*>                    _escapeDoors;                                      // 0x0178(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_188[0x18];                                     // 0x0188(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _minDistanceNeededFromEscapeDoors;                 // 0x01A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A4[0x4];                                      // 0x01A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeleportPositionFinderComponent">();
	}
	static class UTeleportPositionFinderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeleportPositionFinderComponent>();
	}
};
static_assert(alignof(UTeleportPositionFinderComponent) == 0x000008, "Wrong alignment on UTeleportPositionFinderComponent");
static_assert(sizeof(UTeleportPositionFinderComponent) == 0x0001A8, "Wrong size on UTeleportPositionFinderComponent");
static_assert(offsetof(UTeleportPositionFinderComponent, _rayCastZOffet) == 0x0000B8, "Member 'UTeleportPositionFinderComponent::_rayCastZOffet' has a wrong offset!");
static_assert(offsetof(UTeleportPositionFinderComponent, _raycastLength) == 0x0000BC, "Member 'UTeleportPositionFinderComponent::_raycastLength' has a wrong offset!");
static_assert(offsetof(UTeleportPositionFinderComponent, _killerInRangeMinimumDistanceCheck) == 0x0000C0, "Member 'UTeleportPositionFinderComponent::_killerInRangeMinimumDistanceCheck' has a wrong offset!");
static_assert(offsetof(UTeleportPositionFinderComponent, _killerInRangeMaxRangePercentage) == 0x0000C4, "Member 'UTeleportPositionFinderComponent::_killerInRangeMaxRangePercentage' has a wrong offset!");
static_assert(offsetof(UTeleportPositionFinderComponent, _deltaHeightThreshold) == 0x0000C8, "Member 'UTeleportPositionFinderComponent::_deltaHeightThreshold' has a wrong offset!");
static_assert(offsetof(UTeleportPositionFinderComponent, _minDistanceFromTarget) == 0x0000D0, "Member 'UTeleportPositionFinderComponent::_minDistanceFromTarget' has a wrong offset!");
static_assert(offsetof(UTeleportPositionFinderComponent, _maxDistanceFromTarget) == 0x0000F8, "Member 'UTeleportPositionFinderComponent::_maxDistanceFromTarget' has a wrong offset!");
static_assert(offsetof(UTeleportPositionFinderComponent, _timeBetweenFailsafeChecks) == 0x000130, "Member 'UTeleportPositionFinderComponent::_timeBetweenFailsafeChecks' has a wrong offset!");
static_assert(offsetof(UTeleportPositionFinderComponent, _escapeDoors) == 0x000178, "Member 'UTeleportPositionFinderComponent::_escapeDoors' has a wrong offset!");
static_assert(offsetof(UTeleportPositionFinderComponent, _minDistanceNeededFromEscapeDoors) == 0x0001A0, "Member 'UTeleportPositionFinderComponent::_minDistanceNeededFromEscapeDoors' has a wrong offset!");

// Class DBDGameplay.ReadMapInteraction
// 0x0010 (0x08D0 - 0x08C0)
class UReadMapInteraction final : public UChargeableInteractionDefinition
{
public:
	bool                                          _chargeCompleted;                                  // 0x08C0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8C1[0xF];                                      // 0x08C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadMapInteraction">();
	}
	static class UReadMapInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadMapInteraction>();
	}
};
static_assert(alignof(UReadMapInteraction) == 0x000010, "Wrong alignment on UReadMapInteraction");
static_assert(sizeof(UReadMapInteraction) == 0x0008D0, "Wrong size on UReadMapInteraction");
static_assert(offsetof(UReadMapInteraction, _chargeCompleted) == 0x0008C0, "Member 'UReadMapInteraction::_chargeCompleted' has a wrong offset!");

// Class DBDGameplay.AISenseEvent_Terror
// 0x0030 (0x0060 - 0x0030)
class UAISenseEvent_Terror final : public UAISenseEvent
{
public:
	struct FAITerrorEvent                         Event;                                             // 0x0030(0x0030)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISenseEvent_Terror">();
	}
	static class UAISenseEvent_Terror* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISenseEvent_Terror>();
	}
};
static_assert(alignof(UAISenseEvent_Terror) == 0x000008, "Wrong alignment on UAISenseEvent_Terror");
static_assert(sizeof(UAISenseEvent_Terror) == 0x000060, "Wrong size on UAISenseEvent_Terror");
static_assert(offsetof(UAISenseEvent_Terror, Event) == 0x000030, "Member 'UAISenseEvent_Terror::Event' has a wrong offset!");

// Class DBDGameplay.SurvivorTeleportationPositionFinderComponent
// 0x0020 (0x01C8 - 0x01A8)
class USurvivorTeleportationPositionFinderComponent : public UTeleportPositionFinderComponent
{
public:
	uint8                                         Pad_1A8[0x20];                                     // 0x01A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorTeleportationPositionFinderComponent">();
	}
	static class USurvivorTeleportationPositionFinderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorTeleportationPositionFinderComponent>();
	}
};
static_assert(alignof(USurvivorTeleportationPositionFinderComponent) == 0x000008, "Wrong alignment on USurvivorTeleportationPositionFinderComponent");
static_assert(sizeof(USurvivorTeleportationPositionFinderComponent) == 0x0001C8, "Wrong size on USurvivorTeleportationPositionFinderComponent");

// Class DBDGameplay.FadeComponent
// 0x0020 (0x00D8 - 0x00B8)
class UFadeComponent : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(float fadePercent)> OnFadePercentChanged;                          // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         _fadeDuration;                                     // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC[0xC];                                       // 0x00CC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetFadePercent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FadeComponent">();
	}
	static class UFadeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFadeComponent>();
	}
};
static_assert(alignof(UFadeComponent) == 0x000008, "Wrong alignment on UFadeComponent");
static_assert(sizeof(UFadeComponent) == 0x0000D8, "Wrong size on UFadeComponent");
static_assert(offsetof(UFadeComponent, OnFadePercentChanged) == 0x0000B8, "Member 'UFadeComponent::OnFadePercentChanged' has a wrong offset!");
static_assert(offsetof(UFadeComponent, _fadeDuration) == 0x0000C8, "Member 'UFadeComponent::_fadeDuration' has a wrong offset!");

// Class DBDGameplay.TargetingStrategy
// 0x0000 (0x0030 - 0x0030)
class UTargetingStrategy : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetingStrategy">();
	}
	static class UTargetingStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetingStrategy>();
	}
};
static_assert(alignof(UTargetingStrategy) == 0x000008, "Wrong alignment on UTargetingStrategy");
static_assert(sizeof(UTargetingStrategy) == 0x000030, "Wrong size on UTargetingStrategy");

// Class DBDGameplay.BlindFlashlightableLightingStrategy
// 0x0060 (0x00A0 - 0x0040)
class UBlindFlashlightableLightingStrategy : public UFlashlightablePointsLightingStrategy
{
public:
	TArray<struct FGameplayTag>                   _flashlightableIgnoreTags;                         // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSet<class AActor*>                           _additionalOcclusionIgnoredActors;                 // 0x0050(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlindFlashlightableLightingStrategy">();
	}
	static class UBlindFlashlightableLightingStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlindFlashlightableLightingStrategy>();
	}
};
static_assert(alignof(UBlindFlashlightableLightingStrategy) == 0x000008, "Wrong alignment on UBlindFlashlightableLightingStrategy");
static_assert(sizeof(UBlindFlashlightableLightingStrategy) == 0x0000A0, "Wrong size on UBlindFlashlightableLightingStrategy");
static_assert(offsetof(UBlindFlashlightableLightingStrategy, _flashlightableIgnoreTags) == 0x000040, "Member 'UBlindFlashlightableLightingStrategy::_flashlightableIgnoreTags' has a wrong offset!");
static_assert(offsetof(UBlindFlashlightableLightingStrategy, _additionalOcclusionIgnoredActors) == 0x000050, "Member 'UBlindFlashlightableLightingStrategy::_additionalOcclusionIgnoredActors' has a wrong offset!");

// Class DBDGameplay.PoseableHusk
// 0x0008 (0x02F0 - 0x02E8)
class APoseableHusk : public ABaseHusk
{
public:
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CapturePose();
	void Cosmetic_OnAnimationPoseCaptured();
	void OnActiveStateChanged(bool IsActive);
	void SetIsActive(bool IsActive);

	bool GetIsActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoseableHusk">();
	}
	static class APoseableHusk* GetDefaultObj()
	{
		return GetDefaultObjImpl<APoseableHusk>();
	}
};
static_assert(alignof(APoseableHusk) == 0x000008, "Wrong alignment on APoseableHusk");
static_assert(sizeof(APoseableHusk) == 0x0002F0, "Wrong size on APoseableHusk");

// Class DBDGameplay.CharacterOptimizer
// 0x0010 (0x00C8 - 0x00B8)
class UCharacterOptimizer final : public UActorComponent
{
public:
	float                                         _characterMovementTickRateWhenInsignificant;       // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BC[0xC];                                       // 0x00BC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterOptimizer">();
	}
	static class UCharacterOptimizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterOptimizer>();
	}
};
static_assert(alignof(UCharacterOptimizer) == 0x000008, "Wrong alignment on UCharacterOptimizer");
static_assert(sizeof(UCharacterOptimizer) == 0x0000C8, "Wrong size on UCharacterOptimizer");
static_assert(offsetof(UCharacterOptimizer, _characterMovementTickRateWhenInsignificant) == 0x0000B8, "Member 'UCharacterOptimizer::_characterMovementTickRateWhenInsignificant' has a wrong offset!");

// Class DBDGameplay.ActorNavMovementComponent
// 0x0028 (0x0198 - 0x0170)
class UActorNavMovementComponent : public UNavMovementComponent
{
public:
	class AActor*                                 _owningActor;                                      // 0x0170(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPathFollowingComponent*                _pathFollowingComponent;                           // 0x0178(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bPositionCorrected : 1;                            // 0x0180(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_181[0x3];                                      // 0x0181(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _maxSpeed;                                         // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _acceleration;                                     // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _deceleration;                                     // 0x018C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_190[0x8];                                      // 0x0190(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAcceleration(float Acceleration);
	void SetDeceleration(float Deceleration);
	void SetMaxSpeed(float MaxSpeed);

	class AActor* GetOwningActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorNavMovementComponent">();
	}
	static class UActorNavMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorNavMovementComponent>();
	}
};
static_assert(alignof(UActorNavMovementComponent) == 0x000008, "Wrong alignment on UActorNavMovementComponent");
static_assert(sizeof(UActorNavMovementComponent) == 0x000198, "Wrong size on UActorNavMovementComponent");
static_assert(offsetof(UActorNavMovementComponent, _owningActor) == 0x000170, "Member 'UActorNavMovementComponent::_owningActor' has a wrong offset!");
static_assert(offsetof(UActorNavMovementComponent, _pathFollowingComponent) == 0x000178, "Member 'UActorNavMovementComponent::_pathFollowingComponent' has a wrong offset!");
static_assert(offsetof(UActorNavMovementComponent, _maxSpeed) == 0x000184, "Member 'UActorNavMovementComponent::_maxSpeed' has a wrong offset!");
static_assert(offsetof(UActorNavMovementComponent, _acceleration) == 0x000188, "Member 'UActorNavMovementComponent::_acceleration' has a wrong offset!");
static_assert(offsetof(UActorNavMovementComponent, _deceleration) == 0x00018C, "Member 'UActorNavMovementComponent::_deceleration' has a wrong offset!");

// Class DBDGameplay.IgnoreCollisionsHandlerComponent
// 0x0020 (0x0600 - 0x05E0)
class UIgnoreCollisionsHandlerComponent : public UBoxComponent
{
public:
	uint8                                         Pad_5E0[0x20];                                     // 0x05E0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgnoreCollisionsHandlerComponent">();
	}
	static class UIgnoreCollisionsHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgnoreCollisionsHandlerComponent>();
	}
};
static_assert(alignof(UIgnoreCollisionsHandlerComponent) == 0x000010, "Wrong alignment on UIgnoreCollisionsHandlerComponent");
static_assert(sizeof(UIgnoreCollisionsHandlerComponent) == 0x000600, "Wrong size on UIgnoreCollisionsHandlerComponent");

// Class DBDGameplay.IgnoreCollisionsPalletHandlerComponent
// 0x0000 (0x0600 - 0x0600)
class UIgnoreCollisionsPalletHandlerComponent : public UIgnoreCollisionsHandlerComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgnoreCollisionsPalletHandlerComponent">();
	}
	static class UIgnoreCollisionsPalletHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgnoreCollisionsPalletHandlerComponent>();
	}
};
static_assert(alignof(UIgnoreCollisionsPalletHandlerComponent) == 0x000010, "Wrong alignment on UIgnoreCollisionsPalletHandlerComponent");
static_assert(sizeof(UIgnoreCollisionsPalletHandlerComponent) == 0x000600, "Wrong size on UIgnoreCollisionsPalletHandlerComponent");

// Class DBDGameplay.IgnoreCollisionsWindowHandlerComponent
// 0x0000 (0x0600 - 0x0600)
class UIgnoreCollisionsWindowHandlerComponent : public UIgnoreCollisionsHandlerComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgnoreCollisionsWindowHandlerComponent">();
	}
	static class UIgnoreCollisionsWindowHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgnoreCollisionsWindowHandlerComponent>();
	}
};
static_assert(alignof(UIgnoreCollisionsWindowHandlerComponent) == 0x000010, "Wrong alignment on UIgnoreCollisionsWindowHandlerComponent");
static_assert(sizeof(UIgnoreCollisionsWindowHandlerComponent) == 0x000600, "Wrong size on UIgnoreCollisionsWindowHandlerComponent");

// Class DBDGameplay.KillerProjectileAbilityProjectile
// 0x0048 (0x0420 - 0x03D8)
class AKillerProjectileAbilityProjectile : public AKillerProjectile
{
public:
	class USphereComponent*                       _targetDetector;                                   // 0x03D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _hitSurvivorScoreEvent;                            // 0x03E0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3EC[0x4];                                      // 0x03EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPoolableProjectileComponent*           _poolableProjectile;                               // 0x03F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       _collision;                                        // 0x03F8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URotatingMovementComponent*             _rotatingMovement;                                 // 0x0400(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_408[0x18];                                     // 0x0408(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnCollisionDetected(EPhysicalSurface SurfaceType);
	void Cosmetic_OnLaunchNoImpact();
	void Cosmetic_OnPlayerDetected();
	void Cosmetic_OnSlashableDetected();
	void OnAcquiredChanged(bool IsAcquired);
	void OnActivationChanged(bool Enabled);
	void OnComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, const struct FVector& NormalImpulse, const struct FHitResult& HitResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerProjectileAbilityProjectile">();
	}
	static class AKillerProjectileAbilityProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKillerProjectileAbilityProjectile>();
	}
};
static_assert(alignof(AKillerProjectileAbilityProjectile) == 0x000008, "Wrong alignment on AKillerProjectileAbilityProjectile");
static_assert(sizeof(AKillerProjectileAbilityProjectile) == 0x000420, "Wrong size on AKillerProjectileAbilityProjectile");
static_assert(offsetof(AKillerProjectileAbilityProjectile, _targetDetector) == 0x0003D8, "Member 'AKillerProjectileAbilityProjectile::_targetDetector' has a wrong offset!");
static_assert(offsetof(AKillerProjectileAbilityProjectile, _hitSurvivorScoreEvent) == 0x0003E0, "Member 'AKillerProjectileAbilityProjectile::_hitSurvivorScoreEvent' has a wrong offset!");
static_assert(offsetof(AKillerProjectileAbilityProjectile, _poolableProjectile) == 0x0003F0, "Member 'AKillerProjectileAbilityProjectile::_poolableProjectile' has a wrong offset!");
static_assert(offsetof(AKillerProjectileAbilityProjectile, _collision) == 0x0003F8, "Member 'AKillerProjectileAbilityProjectile::_collision' has a wrong offset!");
static_assert(offsetof(AKillerProjectileAbilityProjectile, _rotatingMovement) == 0x000400, "Member 'AKillerProjectileAbilityProjectile::_rotatingMovement' has a wrong offset!");

// Class DBDGameplay.KillerProjectileAbility
// 0x0050 (0x0230 - 0x01E0)
class UKillerProjectileAbility : public UKillerAbilityComponent
{
public:
	class UAuthoritativeActorPoolComponent*       _projectilePool;                                   // 0x01E0(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UKillerProjectileAbilityLauncher> _killerAbilityProjectileLauncherClass;       // 0x01E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AKillerProjectileAbilityProjectile> _killerProjectileClass;                    // 0x01F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UKillerProjectileAbilityChargeThrowInteraction> _killerChargeThrowProjectileInteractionClass; // 0x01F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UKillerProjectileAbilityThrowInteraction> _killerThrowProjectileInteractionClass; // 0x0200(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UKillerProjectileAbilityThrowCancelledInteraction> _killerThrowCancelledInteractionClass; // 0x0208(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UKillerProjectileAbilityLauncher*       _abilityProjectileLauncher;                        // 0x0210(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractionDefinition*                 _throwCancelledInteraction;                        // 0x0218(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractionDefinition*                 _throwInteraction;                                 // 0x0220(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_AbilityProjectileLauncher();
	void OnRep_ProjectilePool();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerProjectileAbility">();
	}
	static class UKillerProjectileAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerProjectileAbility>();
	}
};
static_assert(alignof(UKillerProjectileAbility) == 0x000008, "Wrong alignment on UKillerProjectileAbility");
static_assert(sizeof(UKillerProjectileAbility) == 0x000230, "Wrong size on UKillerProjectileAbility");
static_assert(offsetof(UKillerProjectileAbility, _projectilePool) == 0x0001E0, "Member 'UKillerProjectileAbility::_projectilePool' has a wrong offset!");
static_assert(offsetof(UKillerProjectileAbility, _killerAbilityProjectileLauncherClass) == 0x0001E8, "Member 'UKillerProjectileAbility::_killerAbilityProjectileLauncherClass' has a wrong offset!");
static_assert(offsetof(UKillerProjectileAbility, _killerProjectileClass) == 0x0001F0, "Member 'UKillerProjectileAbility::_killerProjectileClass' has a wrong offset!");
static_assert(offsetof(UKillerProjectileAbility, _killerChargeThrowProjectileInteractionClass) == 0x0001F8, "Member 'UKillerProjectileAbility::_killerChargeThrowProjectileInteractionClass' has a wrong offset!");
static_assert(offsetof(UKillerProjectileAbility, _killerThrowProjectileInteractionClass) == 0x000200, "Member 'UKillerProjectileAbility::_killerThrowProjectileInteractionClass' has a wrong offset!");
static_assert(offsetof(UKillerProjectileAbility, _killerThrowCancelledInteractionClass) == 0x000208, "Member 'UKillerProjectileAbility::_killerThrowCancelledInteractionClass' has a wrong offset!");
static_assert(offsetof(UKillerProjectileAbility, _abilityProjectileLauncher) == 0x000210, "Member 'UKillerProjectileAbility::_abilityProjectileLauncher' has a wrong offset!");
static_assert(offsetof(UKillerProjectileAbility, _throwCancelledInteraction) == 0x000218, "Member 'UKillerProjectileAbility::_throwCancelledInteraction' has a wrong offset!");
static_assert(offsetof(UKillerProjectileAbility, _throwInteraction) == 0x000220, "Member 'UKillerProjectileAbility::_throwInteraction' has a wrong offset!");

// Class DBDGameplay.KillerProjectileAbilityData
// 0x0098 (0x0108 - 0x0070)
class UKillerProjectileAbilityData : public UKillerAbilityData
{
public:
	float                                         _projectileTimeOutDuration;                        // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _playerDetectorRadius;                             // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _collisionDetectorRadius;                          // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isRotatingProjectile;                             // 0x007C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _eulerRotationRate;                                // 0x0080(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _launchPositionOffsetFromCamera;                   // 0x0098(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _throwProjectileWindUpDuration;                    // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _throwProjectileWindUpGracePeriodDuration;         // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _shouldUseChargeBehaviour;                         // 0x00B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _throwProjectileChargeDuration;                    // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _launchSpeed;                                      // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _launchSpeedScaleByChargePercentCurve;             // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _launchGravity;                                    // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _launchGravityScaleByChargePercentCurve;           // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _launchAddedPitch;                                 // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _launchAddedPitchScaleByChargePercentCurve;        // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _launchAddedPitchByLaunchPitchCurve;               // 0x00F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _throwProjectileLaunchDuration;                    // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _throwProjectileCooldownDuration;                  // 0x00FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _throwCancelledCooldownDuration;                   // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerProjectileAbilityData">();
	}
	static class UKillerProjectileAbilityData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerProjectileAbilityData>();
	}
};
static_assert(alignof(UKillerProjectileAbilityData) == 0x000008, "Wrong alignment on UKillerProjectileAbilityData");
static_assert(sizeof(UKillerProjectileAbilityData) == 0x000108, "Wrong size on UKillerProjectileAbilityData");
static_assert(offsetof(UKillerProjectileAbilityData, _projectileTimeOutDuration) == 0x000070, "Member 'UKillerProjectileAbilityData::_projectileTimeOutDuration' has a wrong offset!");
static_assert(offsetof(UKillerProjectileAbilityData, _playerDetectorRadius) == 0x000074, "Member 'UKillerProjectileAbilityData::_playerDetectorRadius' has a wrong offset!");
static_assert(offsetof(UKillerProjectileAbilityData, _collisionDetectorRadius) == 0x000078, "Member 'UKillerProjectileAbilityData::_collisionDetectorRadius' has a wrong offset!");
static_assert(offsetof(UKillerProjectileAbilityData, _isRotatingProjectile) == 0x00007C, "Member 'UKillerProjectileAbilityData::_isRotatingProjectile' has a wrong offset!");
static_assert(offsetof(UKillerProjectileAbilityData, _eulerRotationRate) == 0x000080, "Member 'UKillerProjectileAbilityData::_eulerRotationRate' has a wrong offset!");
static_assert(offsetof(UKillerProjectileAbilityData, _launchPositionOffsetFromCamera) == 0x000098, "Member 'UKillerProjectileAbilityData::_launchPositionOffsetFromCamera' has a wrong offset!");
static_assert(offsetof(UKillerProjectileAbilityData, _throwProjectileWindUpDuration) == 0x0000B0, "Member 'UKillerProjectileAbilityData::_throwProjectileWindUpDuration' has a wrong offset!");
static_assert(offsetof(UKillerProjectileAbilityData, _throwProjectileWindUpGracePeriodDuration) == 0x0000B4, "Member 'UKillerProjectileAbilityData::_throwProjectileWindUpGracePeriodDuration' has a wrong offset!");
static_assert(offsetof(UKillerProjectileAbilityData, _shouldUseChargeBehaviour) == 0x0000B8, "Member 'UKillerProjectileAbilityData::_shouldUseChargeBehaviour' has a wrong offset!");
static_assert(offsetof(UKillerProjectileAbilityData, _throwProjectileChargeDuration) == 0x0000BC, "Member 'UKillerProjectileAbilityData::_throwProjectileChargeDuration' has a wrong offset!");
static_assert(offsetof(UKillerProjectileAbilityData, _launchSpeed) == 0x0000C0, "Member 'UKillerProjectileAbilityData::_launchSpeed' has a wrong offset!");
static_assert(offsetof(UKillerProjectileAbilityData, _launchSpeedScaleByChargePercentCurve) == 0x0000C8, "Member 'UKillerProjectileAbilityData::_launchSpeedScaleByChargePercentCurve' has a wrong offset!");
static_assert(offsetof(UKillerProjectileAbilityData, _launchGravity) == 0x0000D0, "Member 'UKillerProjectileAbilityData::_launchGravity' has a wrong offset!");
static_assert(offsetof(UKillerProjectileAbilityData, _launchGravityScaleByChargePercentCurve) == 0x0000D8, "Member 'UKillerProjectileAbilityData::_launchGravityScaleByChargePercentCurve' has a wrong offset!");
static_assert(offsetof(UKillerProjectileAbilityData, _launchAddedPitch) == 0x0000E0, "Member 'UKillerProjectileAbilityData::_launchAddedPitch' has a wrong offset!");
static_assert(offsetof(UKillerProjectileAbilityData, _launchAddedPitchScaleByChargePercentCurve) == 0x0000E8, "Member 'UKillerProjectileAbilityData::_launchAddedPitchScaleByChargePercentCurve' has a wrong offset!");
static_assert(offsetof(UKillerProjectileAbilityData, _launchAddedPitchByLaunchPitchCurve) == 0x0000F0, "Member 'UKillerProjectileAbilityData::_launchAddedPitchByLaunchPitchCurve' has a wrong offset!");
static_assert(offsetof(UKillerProjectileAbilityData, _throwProjectileLaunchDuration) == 0x0000F8, "Member 'UKillerProjectileAbilityData::_throwProjectileLaunchDuration' has a wrong offset!");
static_assert(offsetof(UKillerProjectileAbilityData, _throwProjectileCooldownDuration) == 0x0000FC, "Member 'UKillerProjectileAbilityData::_throwProjectileCooldownDuration' has a wrong offset!");
static_assert(offsetof(UKillerProjectileAbilityData, _throwCancelledCooldownDuration) == 0x000100, "Member 'UKillerProjectileAbilityData::_throwCancelledCooldownDuration' has a wrong offset!");

// Class DBDGameplay.CageHookOutlineUpdateStrategy
// 0x0000 (0x0160 - 0x0160)
class UCageHookOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CageHookOutlineUpdateStrategy">();
	}
	static class UCageHookOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCageHookOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UCageHookOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UCageHookOutlineUpdateStrategy");
static_assert(sizeof(UCageHookOutlineUpdateStrategy) == 0x000160, "Wrong size on UCageHookOutlineUpdateStrategy");

// Class DBDGameplay.ProjectileAbilityKillerCosmeticHelperActor
// 0x0010 (0x02F8 - 0x02E8)
class AProjectileAbilityKillerCosmeticHelperActor : public ADBDPlayerCosmeticHelperActor
{
public:
	uint8                                         Pad_2E8[0x10];                                     // 0x02E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnChargeThrowStarted();
	void Cosmetic_OnThrowCancelled();
	void Cosmetic_OnThrowSuccess();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileAbilityKillerCosmeticHelperActor">();
	}
	static class AProjectileAbilityKillerCosmeticHelperActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectileAbilityKillerCosmeticHelperActor>();
	}
};
static_assert(alignof(AProjectileAbilityKillerCosmeticHelperActor) == 0x000008, "Wrong alignment on AProjectileAbilityKillerCosmeticHelperActor");
static_assert(sizeof(AProjectileAbilityKillerCosmeticHelperActor) == 0x0002F8, "Wrong size on AProjectileAbilityKillerCosmeticHelperActor");

// Class DBDGameplay.TargetingTeleportInteraction
// 0x0020 (0x0790 - 0x0770)
class UTargetingTeleportInteraction : public UInteractionDefinition
{
public:
	uint8                                         Pad_768[0x3];                                      // 0x0768(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          StopInteractionOnInputReleaseDuringTargetingPhase; // 0x076B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_76C[0x4];                                      // 0x076C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTargetableComponent*                   _teleportTarget;                                   // 0x0770(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_778[0x8];                                      // 0x0778(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFloatValueStrategy*                    _teleportDuration;                                 // 0x0780(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_788[0x8];                                      // 0x0788(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Server_SetTeleportTarget(class UTargetableComponent* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetingTeleportInteraction">();
	}
	static class UTargetingTeleportInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetingTeleportInteraction>();
	}
};
static_assert(alignof(UTargetingTeleportInteraction) == 0x000010, "Wrong alignment on UTargetingTeleportInteraction");
static_assert(sizeof(UTargetingTeleportInteraction) == 0x000790, "Wrong size on UTargetingTeleportInteraction");
static_assert(offsetof(UTargetingTeleportInteraction, StopInteractionOnInputReleaseDuringTargetingPhase) == 0x00076B, "Member 'UTargetingTeleportInteraction::StopInteractionOnInputReleaseDuringTargetingPhase' has a wrong offset!");
static_assert(offsetof(UTargetingTeleportInteraction, _teleportTarget) == 0x000770, "Member 'UTargetingTeleportInteraction::_teleportTarget' has a wrong offset!");
static_assert(offsetof(UTargetingTeleportInteraction, _teleportDuration) == 0x000780, "Member 'UTargetingTeleportInteraction::_teleportDuration' has a wrong offset!");

// Class DBDGameplay.BaseRangedExplosiveActorEffect
// 0x0000 (0x0030 - 0x0030)
class UBaseRangedExplosiveActorEffect : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseRangedExplosiveActorEffect">();
	}
	static class UBaseRangedExplosiveActorEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseRangedExplosiveActorEffect>();
	}
};
static_assert(alignof(UBaseRangedExplosiveActorEffect) == 0x000008, "Wrong alignment on UBaseRangedExplosiveActorEffect");
static_assert(sizeof(UBaseRangedExplosiveActorEffect) == 0x000030, "Wrong size on UBaseRangedExplosiveActorEffect");

// Class DBDGameplay.BlindAndDeafenRangedExplosiveActorEffect
// 0x0000 (0x0030 - 0x0030)
class UBlindAndDeafenRangedExplosiveActorEffect : public UBaseRangedExplosiveActorEffect
{
public:
	bool Authority_TryToBlind(class UBlindableBaseComponent* BlindableComponent, class AActor* effectorActor) const;
	bool Authority_TryToDeafen(const class ADBDPlayer* Player, class UAudioFXComponent* AudioFXComponent) const;
	float GetBlindnessEffectDuration(const class AActor* Player) const;
	float GetDeafnessEffectDuration(const class AActor* Player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlindAndDeafenRangedExplosiveActorEffect">();
	}
	static class UBlindAndDeafenRangedExplosiveActorEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlindAndDeafenRangedExplosiveActorEffect>();
	}
};
static_assert(alignof(UBlindAndDeafenRangedExplosiveActorEffect) == 0x000008, "Wrong alignment on UBlindAndDeafenRangedExplosiveActorEffect");
static_assert(sizeof(UBlindAndDeafenRangedExplosiveActorEffect) == 0x000030, "Wrong size on UBlindAndDeafenRangedExplosiveActorEffect");

// Class DBDGameplay.BubbleIndicatorNotifier
// 0x0000 (0x0030 - 0x0030)
class UBubbleIndicatorNotifier final : public UBlueprintFunctionLibrary
{
public:
	static void ActivateBubbleIndicator(class UObject* WorldContextObject, class ABubbleIndicator* BubbleIndicator, const struct FTransform& Transform, bool TriggerLoudNoise, float Lifetime, float audibleRange);
	static class ABubbleIndicator* PreSpawnBubbleIndicator(class UObject* WorldContextObject, TSubclassOf<class ABubbleIndicator> bubbleIndicatorBP, class UStaticMesh* silhouetteStaticMesh);
	static void SpawnBubbleIndicator(class UObject* WorldContextObject, TSubclassOf<class ABubbleIndicator> bubbleIndicatorBP, const struct FTransform& Transform, bool TriggerLoudNoise, EBubbleShowedPlayerType showedPlayerType, float Lifetime, class UStaticMesh* silhouetteStaticMesh, float audibleRange);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BubbleIndicatorNotifier">();
	}
	static class UBubbleIndicatorNotifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBubbleIndicatorNotifier>();
	}
};
static_assert(alignof(UBubbleIndicatorNotifier) == 0x000008, "Wrong alignment on UBubbleIndicatorNotifier");
static_assert(sizeof(UBubbleIndicatorNotifier) == 0x000030, "Wrong size on UBubbleIndicatorNotifier");

// Class DBDGameplay.KillerFormSwitchingAbility
// 0x0110 (0x02F0 - 0x01E0)
class UKillerFormSwitchingAbility : public UKillerAbilityComponent
{
public:
	uint8                                         Pad_1E0[0x20];                                     // 0x01E0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _currentFormID;                                    // 0x0200(0x000C)(Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20C[0x4];                                      // 0x020C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UKillerForm*>                    _forms;                                            // 0x0210(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UKillerForm*                            _currentForm;                                      // 0x0220(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _startingFormID;                                   // 0x0228(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UKillerFormSwitchingInteraction> _formSwitchingInteractionClass;               // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UKillerFormSwitchingInteraction*        _formSwitchingInteraction;                         // 0x0240(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UKillerFormSwitchingTransitionInteraction> _formSwitchingPreviousTransitionInteractionClass; // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UKillerFormSwitchingTransitionInteraction* _formSwitchingPreviousTransitionInteraction;    // 0x0250(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UKillerFormSwitchingTransitionInteraction> _formSwitchingNextTransitionInteractionClass; // 0x0258(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UKillerFormSwitchingTransitionInteraction* _formSwitchingNextTransitionInteraction;        // 0x0260(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPlayerPerspectiveChangeComponent> _perspectiveChangeComponentClass;           // 0x0268(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerPerspectiveChangeComponent*      _perspectiveChangeComponent;                       // 0x0270(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDBDSpringArmComponent>     _springArmClass;                                   // 0x0278(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDSpringArmComponent*                 _springArm;                                        // 0x0280(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_288[0x60];                                     // 0x0288(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _transitionDuration;                               // 0x02E8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _baseTransitionDuration;                           // 0x02EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Cosmetic_OnCurrentFormChanged(bool isStartingForm);
	void Cosmetic_OnEnterForm(const struct FGameplayTag& formID, bool isStartingForm);
	void Cosmetic_OnExitForm(const struct FGameplayTag& formID);
	float GetTransitionDuration();
	void OnRep_CurrentFormID(const struct FGameplayTag& oldFormId);

	struct FGameplayTag GetCurrentFormID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerFormSwitchingAbility">();
	}
	static class UKillerFormSwitchingAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerFormSwitchingAbility>();
	}
};
static_assert(alignof(UKillerFormSwitchingAbility) == 0x000008, "Wrong alignment on UKillerFormSwitchingAbility");
static_assert(sizeof(UKillerFormSwitchingAbility) == 0x0002F0, "Wrong size on UKillerFormSwitchingAbility");
static_assert(offsetof(UKillerFormSwitchingAbility, _currentFormID) == 0x000200, "Member 'UKillerFormSwitchingAbility::_currentFormID' has a wrong offset!");
static_assert(offsetof(UKillerFormSwitchingAbility, _forms) == 0x000210, "Member 'UKillerFormSwitchingAbility::_forms' has a wrong offset!");
static_assert(offsetof(UKillerFormSwitchingAbility, _currentForm) == 0x000220, "Member 'UKillerFormSwitchingAbility::_currentForm' has a wrong offset!");
static_assert(offsetof(UKillerFormSwitchingAbility, _startingFormID) == 0x000228, "Member 'UKillerFormSwitchingAbility::_startingFormID' has a wrong offset!");
static_assert(offsetof(UKillerFormSwitchingAbility, _formSwitchingInteractionClass) == 0x000238, "Member 'UKillerFormSwitchingAbility::_formSwitchingInteractionClass' has a wrong offset!");
static_assert(offsetof(UKillerFormSwitchingAbility, _formSwitchingInteraction) == 0x000240, "Member 'UKillerFormSwitchingAbility::_formSwitchingInteraction' has a wrong offset!");
static_assert(offsetof(UKillerFormSwitchingAbility, _formSwitchingPreviousTransitionInteractionClass) == 0x000248, "Member 'UKillerFormSwitchingAbility::_formSwitchingPreviousTransitionInteractionClass' has a wrong offset!");
static_assert(offsetof(UKillerFormSwitchingAbility, _formSwitchingPreviousTransitionInteraction) == 0x000250, "Member 'UKillerFormSwitchingAbility::_formSwitchingPreviousTransitionInteraction' has a wrong offset!");
static_assert(offsetof(UKillerFormSwitchingAbility, _formSwitchingNextTransitionInteractionClass) == 0x000258, "Member 'UKillerFormSwitchingAbility::_formSwitchingNextTransitionInteractionClass' has a wrong offset!");
static_assert(offsetof(UKillerFormSwitchingAbility, _formSwitchingNextTransitionInteraction) == 0x000260, "Member 'UKillerFormSwitchingAbility::_formSwitchingNextTransitionInteraction' has a wrong offset!");
static_assert(offsetof(UKillerFormSwitchingAbility, _perspectiveChangeComponentClass) == 0x000268, "Member 'UKillerFormSwitchingAbility::_perspectiveChangeComponentClass' has a wrong offset!");
static_assert(offsetof(UKillerFormSwitchingAbility, _perspectiveChangeComponent) == 0x000270, "Member 'UKillerFormSwitchingAbility::_perspectiveChangeComponent' has a wrong offset!");
static_assert(offsetof(UKillerFormSwitchingAbility, _springArmClass) == 0x000278, "Member 'UKillerFormSwitchingAbility::_springArmClass' has a wrong offset!");
static_assert(offsetof(UKillerFormSwitchingAbility, _springArm) == 0x000280, "Member 'UKillerFormSwitchingAbility::_springArm' has a wrong offset!");
static_assert(offsetof(UKillerFormSwitchingAbility, _transitionDuration) == 0x0002E8, "Member 'UKillerFormSwitchingAbility::_transitionDuration' has a wrong offset!");
static_assert(offsetof(UKillerFormSwitchingAbility, _baseTransitionDuration) == 0x0002EC, "Member 'UKillerFormSwitchingAbility::_baseTransitionDuration' has a wrong offset!");

// Class DBDGameplay.RangedExplosive
// 0x0070 (0x0418 - 0x03A8)
class ARangedExplosive : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x18];                                     // 0x03A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _debugDisplayEnabled;                              // 0x03C0(0x0001)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C1[0x7];                                      // 0x03C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       _effectArea;                                       // 0x03C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           _akComponent;                                      // 0x03D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   _mesh;                                             // 0x03D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UGameplayModifierContainer*>     _effectModifiers;                                  // 0x03E0(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class ADBDPlayer*                             _owningPlayer;                                     // 0x03F0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isExploding;                                      // 0x03F8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F9[0x7];                                      // 0x03F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         _actorsInRange;                                    // 0x0400(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UBaseRangedExplosiveActorEffect*        _explosiveActorEffect;                             // 0x0410(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Multicast_InitFromSpawningPlayer(class ADBDPlayer* spawner);
	void OnExplode_BP();
	void OnFuseBurnEnter();
	void OnFuseBurnExit();
	void OnFuseBurnUpdate(float DeltaSeconds, float fuseTimeLeftPercent);

	float GetExplosionEffectDuration() const;
	float GetExplosionRange() const;
	float GetModifierValue(const struct FGameplayTag& Type) const;
	class ADBDPlayer* GetOwningPlayer() const;
	class UBaseRangedExplosiveActorEffect* GetRangedExplosiveActorEffect() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RangedExplosive">();
	}
	static class ARangedExplosive* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARangedExplosive>();
	}
};
static_assert(alignof(ARangedExplosive) == 0x000008, "Wrong alignment on ARangedExplosive");
static_assert(sizeof(ARangedExplosive) == 0x000418, "Wrong size on ARangedExplosive");
static_assert(offsetof(ARangedExplosive, _debugDisplayEnabled) == 0x0003C0, "Member 'ARangedExplosive::_debugDisplayEnabled' has a wrong offset!");
static_assert(offsetof(ARangedExplosive, _effectArea) == 0x0003C8, "Member 'ARangedExplosive::_effectArea' has a wrong offset!");
static_assert(offsetof(ARangedExplosive, _akComponent) == 0x0003D0, "Member 'ARangedExplosive::_akComponent' has a wrong offset!");
static_assert(offsetof(ARangedExplosive, _mesh) == 0x0003D8, "Member 'ARangedExplosive::_mesh' has a wrong offset!");
static_assert(offsetof(ARangedExplosive, _effectModifiers) == 0x0003E0, "Member 'ARangedExplosive::_effectModifiers' has a wrong offset!");
static_assert(offsetof(ARangedExplosive, _owningPlayer) == 0x0003F0, "Member 'ARangedExplosive::_owningPlayer' has a wrong offset!");
static_assert(offsetof(ARangedExplosive, _isExploding) == 0x0003F8, "Member 'ARangedExplosive::_isExploding' has a wrong offset!");
static_assert(offsetof(ARangedExplosive, _actorsInRange) == 0x000400, "Member 'ARangedExplosive::_actorsInRange' has a wrong offset!");
static_assert(offsetof(ARangedExplosive, _explosiveActorEffect) == 0x000410, "Member 'ARangedExplosive::_explosiveActorEffect' has a wrong offset!");

// Class DBDGameplay.KillerForm
// 0x0090 (0x00C8 - 0x0038)
class UKillerForm : public UDataAsset
{
public:
	struct FGameplayTag                           _formID;                                           // 0x0038(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   _formName;                                         // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _formStatusEffectClass;                            // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _formMaxWalkSpeed;                                 // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerPerspectiveChangeTargetData     _perspectiveChangeTargetData;                      // 0x0070(0x0020)(Edit, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FVector                                _cameraTargetOffset;                               // 0x0090(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _postFormSwitchStatusEffectDuration;               // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _postFormSwitchSpeedCurve;                         // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _animTag;                                          // 0x00B8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerForm">();
	}
	static class UKillerForm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerForm>();
	}
};
static_assert(alignof(UKillerForm) == 0x000008, "Wrong alignment on UKillerForm");
static_assert(sizeof(UKillerForm) == 0x0000C8, "Wrong size on UKillerForm");
static_assert(offsetof(UKillerForm, _formID) == 0x000038, "Member 'UKillerForm::_formID' has a wrong offset!");
static_assert(offsetof(UKillerForm, _formName) == 0x000048, "Member 'UKillerForm::_formName' has a wrong offset!");
static_assert(offsetof(UKillerForm, _formStatusEffectClass) == 0x000060, "Member 'UKillerForm::_formStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UKillerForm, _formMaxWalkSpeed) == 0x000068, "Member 'UKillerForm::_formMaxWalkSpeed' has a wrong offset!");
static_assert(offsetof(UKillerForm, _perspectiveChangeTargetData) == 0x000070, "Member 'UKillerForm::_perspectiveChangeTargetData' has a wrong offset!");
static_assert(offsetof(UKillerForm, _cameraTargetOffset) == 0x000090, "Member 'UKillerForm::_cameraTargetOffset' has a wrong offset!");
static_assert(offsetof(UKillerForm, _postFormSwitchStatusEffectDuration) == 0x0000A8, "Member 'UKillerForm::_postFormSwitchStatusEffectDuration' has a wrong offset!");
static_assert(offsetof(UKillerForm, _postFormSwitchSpeedCurve) == 0x0000B0, "Member 'UKillerForm::_postFormSwitchSpeedCurve' has a wrong offset!");
static_assert(offsetof(UKillerForm, _animTag) == 0x0000B8, "Member 'UKillerForm::_animTag' has a wrong offset!");

// Class DBDGameplay.CageHookPoolComponent
// 0x0040 (0x0158 - 0x0118)
class UCageHookPoolComponent final : public UAuthoritativeActorPoolComponent
{
public:
	uint8                                         Pad_118[0x40];                                     // 0x0118(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_SpawnTrapBlocker(const TArray<struct FTransform>& spawnLocations, const struct FVector& BoxExtent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CageHookPoolComponent">();
	}
	static class UCageHookPoolComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCageHookPoolComponent>();
	}
};
static_assert(alignof(UCageHookPoolComponent) == 0x000008, "Wrong alignment on UCageHookPoolComponent");
static_assert(sizeof(UCageHookPoolComponent) == 0x000158, "Wrong size on UCageHookPoolComponent");

// Class DBDGameplay.LimitGeneratorRegressionEventComponent
// 0x01A8 (0x0260 - 0x00B8)
class ULimitGeneratorRegressionEventComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(int32 currentRegressionLevel, bool survivorInteracting)> Cosmetic_OnRegressionEvent; // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(int32 currentRegressionLevel)> Cosmetic_OnRegressionEventZoneEntered; // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(int32 currentRegressionLevel)> Cosmetic_OnRegressionEventZoneExited; // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(int32 currentRegressionLevel)> Cosmetic_OnRepairStarted;           // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(int32 currentRegressionLevel)> Cosmetic_OnRepairStopped;           // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(int32 currentRegressionLevel, bool Blocked)> Cosmetic_OnBlockingStatusChanged; // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	int32                                         _regressionEventsSuffered;                         // 0x0118(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _numberLastRegressionEventsToShow;                 // 0x0120(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _maxNumberRegressionEventsAllowed;                 // 0x0148(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _thresholdImmediateRegressionToConsiderRegressionEvent; // 0x0170(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _immediateRegressionPercentage;                    // 0x0198(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _immediateRegressionPercentageLimitRegressionEvents; // 0x01C0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _killerProximityZoneRadius;                        // 0x01E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FCollisionProfileName                  _killerProximityZoneDefaultCollisionProfile;       // 0x01EC(0x000C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FCollisionProfileName                  _killerProximityZoneNoCollisionProfile;            // 0x01F8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         _waitTimeAfterGeneratorWasInteractedUponToTriggerVfx; // 0x0204(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       _killerProximityZoneForRegressionEvents;           // 0x0208(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_210[0x50];                                     // 0x0210(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnKillerProximityZoneForRegressionEventsOverlapBegin(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnKillerProximityZoneForRegressionEventsOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnRep_RegressionEventsSuffered();

	int32 GetMaxNumberRegressionEventsAllowed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LimitGeneratorRegressionEventComponent">();
	}
	static class ULimitGeneratorRegressionEventComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULimitGeneratorRegressionEventComponent>();
	}
};
static_assert(alignof(ULimitGeneratorRegressionEventComponent) == 0x000008, "Wrong alignment on ULimitGeneratorRegressionEventComponent");
static_assert(sizeof(ULimitGeneratorRegressionEventComponent) == 0x000260, "Wrong size on ULimitGeneratorRegressionEventComponent");
static_assert(offsetof(ULimitGeneratorRegressionEventComponent, Cosmetic_OnRegressionEvent) == 0x0000B8, "Member 'ULimitGeneratorRegressionEventComponent::Cosmetic_OnRegressionEvent' has a wrong offset!");
static_assert(offsetof(ULimitGeneratorRegressionEventComponent, Cosmetic_OnRegressionEventZoneEntered) == 0x0000C8, "Member 'ULimitGeneratorRegressionEventComponent::Cosmetic_OnRegressionEventZoneEntered' has a wrong offset!");
static_assert(offsetof(ULimitGeneratorRegressionEventComponent, Cosmetic_OnRegressionEventZoneExited) == 0x0000D8, "Member 'ULimitGeneratorRegressionEventComponent::Cosmetic_OnRegressionEventZoneExited' has a wrong offset!");
static_assert(offsetof(ULimitGeneratorRegressionEventComponent, Cosmetic_OnRepairStarted) == 0x0000E8, "Member 'ULimitGeneratorRegressionEventComponent::Cosmetic_OnRepairStarted' has a wrong offset!");
static_assert(offsetof(ULimitGeneratorRegressionEventComponent, Cosmetic_OnRepairStopped) == 0x0000F8, "Member 'ULimitGeneratorRegressionEventComponent::Cosmetic_OnRepairStopped' has a wrong offset!");
static_assert(offsetof(ULimitGeneratorRegressionEventComponent, Cosmetic_OnBlockingStatusChanged) == 0x000108, "Member 'ULimitGeneratorRegressionEventComponent::Cosmetic_OnBlockingStatusChanged' has a wrong offset!");
static_assert(offsetof(ULimitGeneratorRegressionEventComponent, _regressionEventsSuffered) == 0x000118, "Member 'ULimitGeneratorRegressionEventComponent::_regressionEventsSuffered' has a wrong offset!");
static_assert(offsetof(ULimitGeneratorRegressionEventComponent, _numberLastRegressionEventsToShow) == 0x000120, "Member 'ULimitGeneratorRegressionEventComponent::_numberLastRegressionEventsToShow' has a wrong offset!");
static_assert(offsetof(ULimitGeneratorRegressionEventComponent, _maxNumberRegressionEventsAllowed) == 0x000148, "Member 'ULimitGeneratorRegressionEventComponent::_maxNumberRegressionEventsAllowed' has a wrong offset!");
static_assert(offsetof(ULimitGeneratorRegressionEventComponent, _thresholdImmediateRegressionToConsiderRegressionEvent) == 0x000170, "Member 'ULimitGeneratorRegressionEventComponent::_thresholdImmediateRegressionToConsiderRegressionEvent' has a wrong offset!");
static_assert(offsetof(ULimitGeneratorRegressionEventComponent, _immediateRegressionPercentage) == 0x000198, "Member 'ULimitGeneratorRegressionEventComponent::_immediateRegressionPercentage' has a wrong offset!");
static_assert(offsetof(ULimitGeneratorRegressionEventComponent, _immediateRegressionPercentageLimitRegressionEvents) == 0x0001C0, "Member 'ULimitGeneratorRegressionEventComponent::_immediateRegressionPercentageLimitRegressionEvents' has a wrong offset!");
static_assert(offsetof(ULimitGeneratorRegressionEventComponent, _killerProximityZoneRadius) == 0x0001E8, "Member 'ULimitGeneratorRegressionEventComponent::_killerProximityZoneRadius' has a wrong offset!");
static_assert(offsetof(ULimitGeneratorRegressionEventComponent, _killerProximityZoneDefaultCollisionProfile) == 0x0001EC, "Member 'ULimitGeneratorRegressionEventComponent::_killerProximityZoneDefaultCollisionProfile' has a wrong offset!");
static_assert(offsetof(ULimitGeneratorRegressionEventComponent, _killerProximityZoneNoCollisionProfile) == 0x0001F8, "Member 'ULimitGeneratorRegressionEventComponent::_killerProximityZoneNoCollisionProfile' has a wrong offset!");
static_assert(offsetof(ULimitGeneratorRegressionEventComponent, _waitTimeAfterGeneratorWasInteractedUponToTriggerVfx) == 0x000204, "Member 'ULimitGeneratorRegressionEventComponent::_waitTimeAfterGeneratorWasInteractedUponToTriggerVfx' has a wrong offset!");
static_assert(offsetof(ULimitGeneratorRegressionEventComponent, _killerProximityZoneForRegressionEvents) == 0x000208, "Member 'ULimitGeneratorRegressionEventComponent::_killerProximityZoneForRegressionEvents' has a wrong offset!");

// Class DBDGameplay.AISenseConfig_Terror
// 0x0068 (0x00B8 - 0x0050)
class UAISenseConfig_Terror final : public UAISenseConfig
{
public:
	TSubclassOf<class UAISense_Terror>            Implementation;                                    // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBreathingSoundRange;                            // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EAITerrorLevel, float>                   TerrorRanges;                                      // 0x0060(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAISenseAffiliationFilter              DetectionByAffiliation;                            // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISenseConfig_Terror">();
	}
	static class UAISenseConfig_Terror* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISenseConfig_Terror>();
	}
};
static_assert(alignof(UAISenseConfig_Terror) == 0x000008, "Wrong alignment on UAISenseConfig_Terror");
static_assert(sizeof(UAISenseConfig_Terror) == 0x0000B8, "Wrong size on UAISenseConfig_Terror");
static_assert(offsetof(UAISenseConfig_Terror, Implementation) == 0x000050, "Member 'UAISenseConfig_Terror::Implementation' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_Terror, MaxBreathingSoundRange) == 0x000058, "Member 'UAISenseConfig_Terror::MaxBreathingSoundRange' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_Terror, TerrorRanges) == 0x000060, "Member 'UAISenseConfig_Terror::TerrorRanges' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_Terror, DetectionByAffiliation) == 0x0000B0, "Member 'UAISenseConfig_Terror::DetectionByAffiliation' has a wrong offset!");

// Class DBDGameplay.KillerFormSwitchingInteraction
// 0x0000 (0x0770 - 0x0770)
class UKillerFormSwitchingInteraction : public UInteractionDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerFormSwitchingInteraction">();
	}
	static class UKillerFormSwitchingInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerFormSwitchingInteraction>();
	}
};
static_assert(alignof(UKillerFormSwitchingInteraction) == 0x000010, "Wrong alignment on UKillerFormSwitchingInteraction");
static_assert(sizeof(UKillerFormSwitchingInteraction) == 0x000770, "Wrong size on UKillerFormSwitchingInteraction");

// Class DBDGameplay.PalletTrackerVisibilityComponent
// 0x00C0 (0x0178 - 0x00B8)
class UPalletTrackerVisibilityComponent : public UActorComponent
{
public:
	struct FDBDTunableRowHandle                   _visibilityRange;                                  // 0x00B8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FActorPairQueryHeightRange             _visibilityHeightRange;                            // 0x00E0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGameplayTagQuery                      _visibilityTagQuery;                               // 0x00E8(0x0048)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_130[0x48];                                     // 0x0130(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnPalletTrackerSelectedChanged(bool Selected);
	void Cosmetic_OnVisibilityChanged(bool IsVisible);
	void OnLocallyObservedChanged();

	class APalletTracker* GetPalletTrackerOwner() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalletTrackerVisibilityComponent">();
	}
	static class UPalletTrackerVisibilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalletTrackerVisibilityComponent>();
	}
};
static_assert(alignof(UPalletTrackerVisibilityComponent) == 0x000008, "Wrong alignment on UPalletTrackerVisibilityComponent");
static_assert(sizeof(UPalletTrackerVisibilityComponent) == 0x000178, "Wrong size on UPalletTrackerVisibilityComponent");
static_assert(offsetof(UPalletTrackerVisibilityComponent, _visibilityRange) == 0x0000B8, "Member 'UPalletTrackerVisibilityComponent::_visibilityRange' has a wrong offset!");
static_assert(offsetof(UPalletTrackerVisibilityComponent, _visibilityHeightRange) == 0x0000E0, "Member 'UPalletTrackerVisibilityComponent::_visibilityHeightRange' has a wrong offset!");
static_assert(offsetof(UPalletTrackerVisibilityComponent, _visibilityTagQuery) == 0x0000E8, "Member 'UPalletTrackerVisibilityComponent::_visibilityTagQuery' has a wrong offset!");

// Class DBDGameplay.PowerChargeComponent
// 0x00A8 (0x0160 - 0x00B8)
class UPowerChargeComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(float currentChargePercent)> OnPowerChargeChanged;                 // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x54];                                      // 0x00C8(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _chargeRate;                                       // 0x011C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSpeedBasedNetSyncedValue              _currentCharge;                                    // 0x0120(0x0038)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_158[0x4];                                      // 0x0158(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _forceFullCharge;                                  // 0x015C(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_15D[0x3];                                      // 0x015D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCurrentChargeChanged(float Value);
	void OnRep_CurrentCharge();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PowerChargeComponent">();
	}
	static class UPowerChargeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPowerChargeComponent>();
	}
};
static_assert(alignof(UPowerChargeComponent) == 0x000008, "Wrong alignment on UPowerChargeComponent");
static_assert(sizeof(UPowerChargeComponent) == 0x000160, "Wrong size on UPowerChargeComponent");
static_assert(offsetof(UPowerChargeComponent, OnPowerChargeChanged) == 0x0000B8, "Member 'UPowerChargeComponent::OnPowerChargeChanged' has a wrong offset!");
static_assert(offsetof(UPowerChargeComponent, _chargeRate) == 0x00011C, "Member 'UPowerChargeComponent::_chargeRate' has a wrong offset!");
static_assert(offsetof(UPowerChargeComponent, _currentCharge) == 0x000120, "Member 'UPowerChargeComponent::_currentCharge' has a wrong offset!");
static_assert(offsetof(UPowerChargeComponent, _forceFullCharge) == 0x00015C, "Member 'UPowerChargeComponent::_forceFullCharge' has a wrong offset!");

// Class DBDGameplay.ActorPathFollowingComponent
// 0x0000 (0x02E0 - 0x02E0)
class UActorPathFollowingComponent : public UPathFollowingComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorPathFollowingComponent">();
	}
	static class UActorPathFollowingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorPathFollowingComponent>();
	}
};
static_assert(alignof(UActorPathFollowingComponent) == 0x000008, "Wrong alignment on UActorPathFollowingComponent");
static_assert(sizeof(UActorPathFollowingComponent) == 0x0002E0, "Wrong size on UActorPathFollowingComponent");

// Class DBDGameplay.AimableComponent
// 0x0070 (0x0128 - 0x00B8)
class UAimableComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         _occlusionIgnoredActors;                           // 0x00C0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	float                                         _maxAimDistance;                                   // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAimDirectionProvider*                  _aimDirectionProvider;                             // 0x00D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _useOcclusion;                                     // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _aimPointLerpFactor;                               // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAimPointProcessor*>             _preOcclusionAimPointProcessors;                   // 0x00E8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0x30];                                      // 0x00F8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMaxAimDistance(float maxAimDistance);
	void SetOcclusionIgnoredActors(const TArray<class AActor*>& IgnoredActors);
	void SetProcessors(const TArray<class UAimPointProcessor*>& processors);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimableComponent">();
	}
	static class UAimableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimableComponent>();
	}
};
static_assert(alignof(UAimableComponent) == 0x000008, "Wrong alignment on UAimableComponent");
static_assert(sizeof(UAimableComponent) == 0x000128, "Wrong size on UAimableComponent");
static_assert(offsetof(UAimableComponent, _occlusionIgnoredActors) == 0x0000C0, "Member 'UAimableComponent::_occlusionIgnoredActors' has a wrong offset!");
static_assert(offsetof(UAimableComponent, _maxAimDistance) == 0x0000D0, "Member 'UAimableComponent::_maxAimDistance' has a wrong offset!");
static_assert(offsetof(UAimableComponent, _aimDirectionProvider) == 0x0000D8, "Member 'UAimableComponent::_aimDirectionProvider' has a wrong offset!");
static_assert(offsetof(UAimableComponent, _useOcclusion) == 0x0000E0, "Member 'UAimableComponent::_useOcclusion' has a wrong offset!");
static_assert(offsetof(UAimableComponent, _aimPointLerpFactor) == 0x0000E4, "Member 'UAimableComponent::_aimPointLerpFactor' has a wrong offset!");
static_assert(offsetof(UAimableComponent, _preOcclusionAimPointProcessors) == 0x0000E8, "Member 'UAimableComponent::_preOcclusionAimPointProcessors' has a wrong offset!");

// Class DBDGameplay.BubbleIndicator
// 0x0010 (0x02B0 - 0x02A0)
class ABubbleIndicator final : public AActor
{
public:
	float                                         _lifetime;                                         // 0x02A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _displayToLocallyObserved;                         // 0x02A4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInRange;                                        // 0x02A5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isPreSpawned;                                     // 0x02A6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A7[0x9];                                      // 0x02A7(0x0009)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateBubbleFX(const float Duration);
	void DeactivateBubble();
	void RefreshBubbleVisibility(const bool IsVisible);
	void SetSilhouette(class UStaticMesh* StaticMesh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BubbleIndicator">();
	}
	static class ABubbleIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABubbleIndicator>();
	}
};
static_assert(alignof(ABubbleIndicator) == 0x000008, "Wrong alignment on ABubbleIndicator");
static_assert(sizeof(ABubbleIndicator) == 0x0002B0, "Wrong size on ABubbleIndicator");
static_assert(offsetof(ABubbleIndicator, _lifetime) == 0x0002A0, "Member 'ABubbleIndicator::_lifetime' has a wrong offset!");
static_assert(offsetof(ABubbleIndicator, _displayToLocallyObserved) == 0x0002A4, "Member 'ABubbleIndicator::_displayToLocallyObserved' has a wrong offset!");
static_assert(offsetof(ABubbleIndicator, _isInRange) == 0x0002A5, "Member 'ABubbleIndicator::_isInRange' has a wrong offset!");
static_assert(offsetof(ABubbleIndicator, _isPreSpawned) == 0x0002A6, "Member 'ABubbleIndicator::_isPreSpawned' has a wrong offset!");

// Class DBDGameplay.KillerProjectileAbilityInterface
// 0x0000 (0x0000 - 0x0000)
class IKillerProjectileAbilityInterface final
{
public:
	void Cosmetic_SetProjectileVisibility(const bool Visible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerProjectileAbilityInterface">();
	}
	static class IKillerProjectileAbilityInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IKillerProjectileAbilityInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IKillerProjectileAbilityInterface) == 0x000001, "Wrong alignment on IKillerProjectileAbilityInterface");
static_assert(sizeof(IKillerProjectileAbilityInterface) == 0x000001, "Wrong size on IKillerProjectileAbilityInterface");

// Class DBDGameplay.AimDirectionProvider
// 0x0000 (0x0030 - 0x0030)
class UAimDirectionProvider : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimDirectionProvider">();
	}
	static class UAimDirectionProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimDirectionProvider>();
	}
};
static_assert(alignof(UAimDirectionProvider) == 0x000008, "Wrong alignment on UAimDirectionProvider");
static_assert(sizeof(UAimDirectionProvider) == 0x000030, "Wrong size on UAimDirectionProvider");

// Class DBDGameplay.AimPointProcessor
// 0x0000 (0x00B8 - 0x00B8)
class UAimPointProcessor : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimPointProcessor">();
	}
	static class UAimPointProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimPointProcessor>();
	}
};
static_assert(alignof(UAimPointProcessor) == 0x000008, "Wrong alignment on UAimPointProcessor");
static_assert(sizeof(UAimPointProcessor) == 0x0000B8, "Wrong size on UAimPointProcessor");

// Class DBDGameplay.SteamPipeEffectComponent
// 0x0078 (0x0130 - 0x00B8)
class USteamPipeEffectComponent final : public UActorComponent
{
public:
	TSubclassOf<class UStatusEffect>              _hinderedEffectClass;                              // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                   _stateTagsToIgnore;                                // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTagStateBool                          _isInActiveSteamPipeZone;                          // 0x00D0(0x0048)(Net, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ASteamPipe>              _overlappingSteamPipe;                             // 0x0118(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x10];                                     // 0x0120(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnHealthStateChanged(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData);
	void Authority_OnStoppedCrouching(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamPipeEffectComponent">();
	}
	static class USteamPipeEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamPipeEffectComponent>();
	}
};
static_assert(alignof(USteamPipeEffectComponent) == 0x000008, "Wrong alignment on USteamPipeEffectComponent");
static_assert(sizeof(USteamPipeEffectComponent) == 0x000130, "Wrong size on USteamPipeEffectComponent");
static_assert(offsetof(USteamPipeEffectComponent, _hinderedEffectClass) == 0x0000B8, "Member 'USteamPipeEffectComponent::_hinderedEffectClass' has a wrong offset!");
static_assert(offsetof(USteamPipeEffectComponent, _stateTagsToIgnore) == 0x0000C0, "Member 'USteamPipeEffectComponent::_stateTagsToIgnore' has a wrong offset!");
static_assert(offsetof(USteamPipeEffectComponent, _isInActiveSteamPipeZone) == 0x0000D0, "Member 'USteamPipeEffectComponent::_isInActiveSteamPipeZone' has a wrong offset!");
static_assert(offsetof(USteamPipeEffectComponent, _overlappingSteamPipe) == 0x000118, "Member 'USteamPipeEffectComponent::_overlappingSteamPipe' has a wrong offset!");

// Class DBDGameplay.AimPointPerlinNoise
// 0x0038 (0x00F0 - 0x00B8)
class UAimPointPerlinNoise final : public UAimPointProcessor
{
public:
	uint8                                         Pad_B8[0x4];                                       // 0x00B8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _baseInaccuracyNoisePersistence;                   // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _baseInaccuracyNoiseOctaveCount;                   // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _baseInaccuracyNoiseAmplitude;                     // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x4];                                       // 0x00C8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _baseInaccuracyNoiseFrequency;                     // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x4];                                       // 0x00D0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _timeOffset;                                       // 0x00D4(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x18];                                      // 0x00D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBaseInaccuracyNoiseAmplitude(const float Amplitude);
	void SetBaseInaccuracyNoiseFrequency(const float Frequency);
	void SetBaseInaccuracyNoiseOctaveCount(const int32 octaveCount);
	void SetBaseInaccuracyNoisePersistence(const float noisePersistence);
	void SetNoiseAmplitudeMultiplier(const float Multiplier);
	void SetNoiseFrequencyMultiplier(const float Multiplier);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimPointPerlinNoise">();
	}
	static class UAimPointPerlinNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimPointPerlinNoise>();
	}
};
static_assert(alignof(UAimPointPerlinNoise) == 0x000008, "Wrong alignment on UAimPointPerlinNoise");
static_assert(sizeof(UAimPointPerlinNoise) == 0x0000F0, "Wrong size on UAimPointPerlinNoise");
static_assert(offsetof(UAimPointPerlinNoise, _baseInaccuracyNoisePersistence) == 0x0000BC, "Member 'UAimPointPerlinNoise::_baseInaccuracyNoisePersistence' has a wrong offset!");
static_assert(offsetof(UAimPointPerlinNoise, _baseInaccuracyNoiseOctaveCount) == 0x0000C0, "Member 'UAimPointPerlinNoise::_baseInaccuracyNoiseOctaveCount' has a wrong offset!");
static_assert(offsetof(UAimPointPerlinNoise, _baseInaccuracyNoiseAmplitude) == 0x0000C4, "Member 'UAimPointPerlinNoise::_baseInaccuracyNoiseAmplitude' has a wrong offset!");
static_assert(offsetof(UAimPointPerlinNoise, _baseInaccuracyNoiseFrequency) == 0x0000CC, "Member 'UAimPointPerlinNoise::_baseInaccuracyNoiseFrequency' has a wrong offset!");
static_assert(offsetof(UAimPointPerlinNoise, _timeOffset) == 0x0000D4, "Member 'UAimPointPerlinNoise::_timeOffset' has a wrong offset!");

// Class DBDGameplay.AISense_Terror
// 0x0060 (0x00F0 - 0x0090)
class UAISense_Terror final : public UAISense
{
public:
	TArray<struct FAITerrorEvent>                 _events;                                           // 0x0090(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A0[0x50];                                      // 0x00A0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ReportTerrorEvent(class UObject* worldContextObj, const struct FVector& Location, class AActor* Instigator, class UTerrorRadiusEmitterComponent* TerrorEmitter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISense_Terror">();
	}
	static class UAISense_Terror* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISense_Terror>();
	}
};
static_assert(alignof(UAISense_Terror) == 0x000008, "Wrong alignment on UAISense_Terror");
static_assert(sizeof(UAISense_Terror) == 0x0000F0, "Wrong size on UAISense_Terror");
static_assert(offsetof(UAISense_Terror, _events) == 0x000090, "Member 'UAISense_Terror::_events' has a wrong offset!");

// Class DBDGameplay.AttachKillerSpecificVaultComponent
// 0x0010 (0x00C8 - 0x00B8)
class UAttachKillerSpecificVaultComponent final : public UActorComponent
{
public:
	TSubclassOf<class UInteractionDefinition>     _vaultPalletInteractionClass;                      // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UInteractionDefinition>     _vaultWindowInteractionClass;                      // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttachKillerSpecificVaultComponent">();
	}
	static class UAttachKillerSpecificVaultComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttachKillerSpecificVaultComponent>();
	}
};
static_assert(alignof(UAttachKillerSpecificVaultComponent) == 0x000008, "Wrong alignment on UAttachKillerSpecificVaultComponent");
static_assert(sizeof(UAttachKillerSpecificVaultComponent) == 0x0000C8, "Wrong size on UAttachKillerSpecificVaultComponent");
static_assert(offsetof(UAttachKillerSpecificVaultComponent, _vaultPalletInteractionClass) == 0x0000B8, "Member 'UAttachKillerSpecificVaultComponent::_vaultPalletInteractionClass' has a wrong offset!");
static_assert(offsetof(UAttachKillerSpecificVaultComponent, _vaultWindowInteractionClass) == 0x0000C0, "Member 'UAttachKillerSpecificVaultComponent::_vaultWindowInteractionClass' has a wrong offset!");

// Class DBDGameplay.BaseActorAttackableComponent
// 0x0038 (0x00F0 - 0x00B8)
class UBaseActorAttackableComponent : public UAttackableComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _killerProjectilesThatCanDamageActor;              // 0x00D0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void HitWithProjectile(class ABaseProjectile* Projectile);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseActorAttackableComponent">();
	}
	static class UBaseActorAttackableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseActorAttackableComponent>();
	}
};
static_assert(alignof(UBaseActorAttackableComponent) == 0x000008, "Wrong alignment on UBaseActorAttackableComponent");
static_assert(sizeof(UBaseActorAttackableComponent) == 0x0000F0, "Wrong size on UBaseActorAttackableComponent");
static_assert(offsetof(UBaseActorAttackableComponent, _killerProjectilesThatCanDamageActor) == 0x0000D0, "Member 'UBaseActorAttackableComponent::_killerProjectilesThatCanDamageActor' has a wrong offset!");

// Class DBDGameplay.BlockFeedbackComponent
// 0x0088 (0x0140 - 0x00B8)
class UBlockFeedbackComponent final : public UActorComponent
{
public:
	class ULocalPlayerTrackerComponent*           _localPlayerTracker;                               // 0x00B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABlockFeedbackBase*>             _defaultBlockSelfFeedbacks;                        // 0x00D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ABlockFeedbackBase*>             _defaultBlockOtherFeedbacks;                       // 0x00E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class ABlockFeedbackBase>> _defaultBlockSelfFeedbackClasses;                  // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class ABlockFeedbackBase>> _defaultBlockOtherFeedbackClasses;                 // 0x0100(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FBlockFeedbackStyleOverride>    _styleOverrides;                                   // 0x0110(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x20];                                     // 0x0120(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLocallyObservedChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlockFeedbackComponent">();
	}
	static class UBlockFeedbackComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlockFeedbackComponent>();
	}
};
static_assert(alignof(UBlockFeedbackComponent) == 0x000008, "Wrong alignment on UBlockFeedbackComponent");
static_assert(sizeof(UBlockFeedbackComponent) == 0x000140, "Wrong size on UBlockFeedbackComponent");
static_assert(offsetof(UBlockFeedbackComponent, _localPlayerTracker) == 0x0000B8, "Member 'UBlockFeedbackComponent::_localPlayerTracker' has a wrong offset!");
static_assert(offsetof(UBlockFeedbackComponent, _defaultBlockSelfFeedbacks) == 0x0000D0, "Member 'UBlockFeedbackComponent::_defaultBlockSelfFeedbacks' has a wrong offset!");
static_assert(offsetof(UBlockFeedbackComponent, _defaultBlockOtherFeedbacks) == 0x0000E0, "Member 'UBlockFeedbackComponent::_defaultBlockOtherFeedbacks' has a wrong offset!");
static_assert(offsetof(UBlockFeedbackComponent, _defaultBlockSelfFeedbackClasses) == 0x0000F0, "Member 'UBlockFeedbackComponent::_defaultBlockSelfFeedbackClasses' has a wrong offset!");
static_assert(offsetof(UBlockFeedbackComponent, _defaultBlockOtherFeedbackClasses) == 0x000100, "Member 'UBlockFeedbackComponent::_defaultBlockOtherFeedbackClasses' has a wrong offset!");
static_assert(offsetof(UBlockFeedbackComponent, _styleOverrides) == 0x000110, "Member 'UBlockFeedbackComponent::_styleOverrides' has a wrong offset!");

// Class DBDGameplay.CageUtilities
// 0x0000 (0x0030 - 0x0030)
class UCageUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CageUtilities">();
	}
	static class UCageUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCageUtilities>();
	}
};
static_assert(alignof(UCageUtilities) == 0x000008, "Wrong alignment on UCageUtilities");
static_assert(sizeof(UCageUtilities) == 0x000030, "Wrong size on UCageUtilities");

// Class DBDGameplay.CameraCenterTargetingStrategy
// 0x0008 (0x0038 - 0x0030)
class UCameraCenterTargetingStrategy final : public UTargetingStrategy
{
public:
	float                                         _cameraDegreesToleranceFromCenterScreen;           // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraCenterTargetingStrategy">();
	}
	static class UCameraCenterTargetingStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraCenterTargetingStrategy>();
	}
};
static_assert(alignof(UCameraCenterTargetingStrategy) == 0x000008, "Wrong alignment on UCameraCenterTargetingStrategy");
static_assert(sizeof(UCameraCenterTargetingStrategy) == 0x000038, "Wrong size on UCameraCenterTargetingStrategy");
static_assert(offsetof(UCameraCenterTargetingStrategy, _cameraDegreesToleranceFromCenterScreen) == 0x000030, "Member 'UCameraCenterTargetingStrategy::_cameraDegreesToleranceFromCenterScreen' has a wrong offset!");

// Class DBDGameplay.CollectableComponentUtilities
// 0x0000 (0x0030 - 0x0030)
class UCollectableComponentUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class ADBDPlayer* GetCollector(const class UActorComponent* Component);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectableComponentUtilities">();
	}
	static class UCollectableComponentUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollectableComponentUtilities>();
	}
};
static_assert(alignof(UCollectableComponentUtilities) == 0x000008, "Wrong alignment on UCollectableComponentUtilities");
static_assert(sizeof(UCollectableComponentUtilities) == 0x000030, "Wrong size on UCollectableComponentUtilities");

// Class DBDGameplay.CollectFatherKeyCardInteraction
// 0x0000 (0x07B0 - 0x07B0)
class UCollectFatherKeyCardInteraction final : public UCollectItemInteraction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectFatherKeyCardInteraction">();
	}
	static class UCollectFatherKeyCardInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollectFatherKeyCardInteraction>();
	}
};
static_assert(alignof(UCollectFatherKeyCardInteraction) == 0x000010, "Wrong alignment on UCollectFatherKeyCardInteraction");
static_assert(sizeof(UCollectFatherKeyCardInteraction) == 0x0007B0, "Wrong size on UCollectFatherKeyCardInteraction");

// Class DBDGameplay.ConspicuousActionComponent
// 0x0028 (0x00E0 - 0x00B8)
class UConspicuousActionComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x28];                                      // 0x00B8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConspicuousActionComponent">();
	}
	static class UConspicuousActionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConspicuousActionComponent>();
	}
};
static_assert(alignof(UConspicuousActionComponent) == 0x000008, "Wrong alignment on UConspicuousActionComponent");
static_assert(sizeof(UConspicuousActionComponent) == 0x0000E0, "Wrong size on UConspicuousActionComponent");

// Class DBDGameplay.CrowBombTriggerComponent
// 0x0000 (0x01F8 - 0x01F8)
class UCrowBombTriggerComponent final : public UCrowTriggerComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrowBombTriggerComponent">();
	}
	static class UCrowBombTriggerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrowBombTriggerComponent>();
	}
};
static_assert(alignof(UCrowBombTriggerComponent) == 0x000008, "Wrong alignment on UCrowBombTriggerComponent");
static_assert(sizeof(UCrowBombTriggerComponent) == 0x0001F8, "Wrong size on UCrowBombTriggerComponent");

// Class DBDGameplay.DBDBaseActor
// 0x0008 (0x02A8 - 0x02A0)
class ADBDBaseActor final : public AActor
{
public:
	class USceneComponent*                        _rootComponent;                                    // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBaseActor">();
	}
	static class ADBDBaseActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDBaseActor>();
	}
};
static_assert(alignof(ADBDBaseActor) == 0x000008, "Wrong alignment on ADBDBaseActor");
static_assert(sizeof(ADBDBaseActor) == 0x0002A8, "Wrong size on ADBDBaseActor");
static_assert(offsetof(ADBDBaseActor, _rootComponent) == 0x0002A0, "Member 'ADBDBaseActor::_rootComponent' has a wrong offset!");

// Class DBDGameplay.DBDCharacterPusherComponent
// 0x0010 (0x0180 - 0x0170)
class UDBDCharacterPusherComponent final : public UCharacterPusherComponent
{
public:
	uint8                                         Pad_170[0x10];                                     // 0x0170(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDCharacterPusherComponent">();
	}
	static class UDBDCharacterPusherComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDCharacterPusherComponent>();
	}
};
static_assert(alignof(UDBDCharacterPusherComponent) == 0x000008, "Wrong alignment on UDBDCharacterPusherComponent");
static_assert(sizeof(UDBDCharacterPusherComponent) == 0x000180, "Wrong size on UDBDCharacterPusherComponent");

// Class DBDGameplay.DBDChildActorComponent
// 0x0090 (0x0360 - 0x02D0)
class UDBDChildActorComponent final : public USceneComponent
{
public:
	TSubclassOf<class AActor>                     _childActorToSpawn;                                // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _socketNameToAttach;                               // 0x02D8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttachmentRule                               _attachmentLocationRule;                           // 0x02E4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttachmentRule                               _attachmentRotationRule;                           // 0x02E5(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttachmentRule                               _attachmentScaleRule;                              // 0x02E6(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _weldSimulatedBodies;                              // 0x02E7(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             _childActorTransformOnSpawn;                       // 0x02F0(0x0060)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 _childActor;                                       // 0x0350(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDChildActorComponent">();
	}
	static class UDBDChildActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDChildActorComponent>();
	}
};
static_assert(alignof(UDBDChildActorComponent) == 0x000010, "Wrong alignment on UDBDChildActorComponent");
static_assert(sizeof(UDBDChildActorComponent) == 0x000360, "Wrong size on UDBDChildActorComponent");
static_assert(offsetof(UDBDChildActorComponent, _childActorToSpawn) == 0x0002D0, "Member 'UDBDChildActorComponent::_childActorToSpawn' has a wrong offset!");
static_assert(offsetof(UDBDChildActorComponent, _socketNameToAttach) == 0x0002D8, "Member 'UDBDChildActorComponent::_socketNameToAttach' has a wrong offset!");
static_assert(offsetof(UDBDChildActorComponent, _attachmentLocationRule) == 0x0002E4, "Member 'UDBDChildActorComponent::_attachmentLocationRule' has a wrong offset!");
static_assert(offsetof(UDBDChildActorComponent, _attachmentRotationRule) == 0x0002E5, "Member 'UDBDChildActorComponent::_attachmentRotationRule' has a wrong offset!");
static_assert(offsetof(UDBDChildActorComponent, _attachmentScaleRule) == 0x0002E6, "Member 'UDBDChildActorComponent::_attachmentScaleRule' has a wrong offset!");
static_assert(offsetof(UDBDChildActorComponent, _weldSimulatedBodies) == 0x0002E7, "Member 'UDBDChildActorComponent::_weldSimulatedBodies' has a wrong offset!");
static_assert(offsetof(UDBDChildActorComponent, _childActorTransformOnSpawn) == 0x0002F0, "Member 'UDBDChildActorComponent::_childActorTransformOnSpawn' has a wrong offset!");
static_assert(offsetof(UDBDChildActorComponent, _childActor) == 0x000350, "Member 'UDBDChildActorComponent::_childActor' has a wrong offset!");

// Class DBDGameplay.DBDCustomCheatComponent
// 0x0060 (0x0118 - 0x00B8)
class UDBDCustomCheatComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(const class FName customCheatName)> OnCustomCheatCalled;           // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TSet<class FName>                             _customCheatNames;                                 // 0x00C8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void OnCustomCheatCalledOnManager(const class FName customCheatName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDCustomCheatComponent">();
	}
	static class UDBDCustomCheatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDCustomCheatComponent>();
	}
};
static_assert(alignof(UDBDCustomCheatComponent) == 0x000008, "Wrong alignment on UDBDCustomCheatComponent");
static_assert(sizeof(UDBDCustomCheatComponent) == 0x000118, "Wrong size on UDBDCustomCheatComponent");
static_assert(offsetof(UDBDCustomCheatComponent, OnCustomCheatCalled) == 0x0000B8, "Member 'UDBDCustomCheatComponent::OnCustomCheatCalled' has a wrong offset!");
static_assert(offsetof(UDBDCustomCheatComponent, _customCheatNames) == 0x0000C8, "Member 'UDBDCustomCheatComponent::_customCheatNames' has a wrong offset!");

// Class DBDGameplay.DBDCustomCheatManager
// 0x0018 (0x00D0 - 0x00B8)
class UDBDCustomCheatManager final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_CallCustomCheat(const class FName& customCheatName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDCustomCheatManager">();
	}
	static class UDBDCustomCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDCustomCheatManager>();
	}
};
static_assert(alignof(UDBDCustomCheatManager) == 0x000008, "Wrong alignment on UDBDCustomCheatManager");
static_assert(sizeof(UDBDCustomCheatManager) == 0x0000D0, "Wrong size on UDBDCustomCheatManager");

// Class DBDGameplay.DebugIndicator
// 0x0020 (0x02C0 - 0x02A0)
class ADebugIndicator final : public AActor
{
public:
	class UStaticMeshComponent*                   _staticMeshComponent;                              // 0x02A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDOutlineComponent*                   _outlineComponent;                                 // 0x02A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B0[0x10];                                     // 0x02B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetColor(const struct FLinearColor& Color);
	void SetVisible(const bool Visible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugIndicator">();
	}
	static class ADebugIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebugIndicator>();
	}
};
static_assert(alignof(ADebugIndicator) == 0x000008, "Wrong alignment on ADebugIndicator");
static_assert(sizeof(ADebugIndicator) == 0x0002C0, "Wrong size on ADebugIndicator");
static_assert(offsetof(ADebugIndicator, _staticMeshComponent) == 0x0002A0, "Member 'ADebugIndicator::_staticMeshComponent' has a wrong offset!");
static_assert(offsetof(ADebugIndicator, _outlineComponent) == 0x0002A8, "Member 'ADebugIndicator::_outlineComponent' has a wrong offset!");

// Class DBDGameplay.DebugTimerLogComponent
// 0x0080 (0x0138 - 0x00B8)
class UDebugTimerLogComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x30];                                      // 0x00B8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _timerDisplayName;                                 // 0x00E8(0x0010)(Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSpeedBasedNetSyncedValue              _timerCountdown;                                   // 0x00F8(0x0038)(Net, RepNotify, NativeAccessSpecifierPrivate)
	float                                         _timerRemainingPercent;                            // 0x0130(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_TimerCountdown();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugTimerLogComponent">();
	}
	static class UDebugTimerLogComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugTimerLogComponent>();
	}
};
static_assert(alignof(UDebugTimerLogComponent) == 0x000008, "Wrong alignment on UDebugTimerLogComponent");
static_assert(sizeof(UDebugTimerLogComponent) == 0x000138, "Wrong size on UDebugTimerLogComponent");
static_assert(offsetof(UDebugTimerLogComponent, _timerDisplayName) == 0x0000E8, "Member 'UDebugTimerLogComponent::_timerDisplayName' has a wrong offset!");
static_assert(offsetof(UDebugTimerLogComponent, _timerCountdown) == 0x0000F8, "Member 'UDebugTimerLogComponent::_timerCountdown' has a wrong offset!");
static_assert(offsetof(UDebugTimerLogComponent, _timerRemainingPercent) == 0x000130, "Member 'UDebugTimerLogComponent::_timerRemainingPercent' has a wrong offset!");

// Class DBDGameplay.EndGameEffectsComponent
// 0x0020 (0x00D8 - 0x00B8)
class UEndGameEffectsComponent : public UActorComponent
{
public:
	bool                                          _hasEndGameBegun;                                  // 0x00B8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _playCameraShakeOnce;                              // 0x00B9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BA[0x1E];                                      // 0x00BA(0x001E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLocallyObservedChanged(class ADBDPlayer* Player);
	void RegisterLocallyObservedEvents();
	void StartUpdateTimer(const struct FGameplayTag& gameEventType, const struct FGameEventData& GameEventData);
	void UnregisterLocallyObservedEvents();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndGameEffectsComponent">();
	}
	static class UEndGameEffectsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndGameEffectsComponent>();
	}
};
static_assert(alignof(UEndGameEffectsComponent) == 0x000008, "Wrong alignment on UEndGameEffectsComponent");
static_assert(sizeof(UEndGameEffectsComponent) == 0x0000D8, "Wrong size on UEndGameEffectsComponent");
static_assert(offsetof(UEndGameEffectsComponent, _hasEndGameBegun) == 0x0000B8, "Member 'UEndGameEffectsComponent::_hasEndGameBegun' has a wrong offset!");
static_assert(offsetof(UEndGameEffectsComponent, _playCameraShakeOnce) == 0x0000B9, "Member 'UEndGameEffectsComponent::_playCameraShakeOnce' has a wrong offset!");

// Class DBDGameplay.EtherealComponent
// 0x0040 (0x00F8 - 0x00B8)
class UEtherealComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x28];                                      // 0x00B8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isEthereal;                                       // 0x00E0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E1[0x17];                                      // 0x00E1(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_OnIsEtherealChanged();
	void Server_SetIsEthereal(float Timestamp, bool Ethereal);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EtherealComponent">();
	}
	static class UEtherealComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEtherealComponent>();
	}
};
static_assert(alignof(UEtherealComponent) == 0x000008, "Wrong alignment on UEtherealComponent");
static_assert(sizeof(UEtherealComponent) == 0x0000F8, "Wrong size on UEtherealComponent");
static_assert(offsetof(UEtherealComponent, _isEthereal) == 0x0000E0, "Member 'UEtherealComponent::_isEthereal' has a wrong offset!");

// Class DBDGameplay.RangeToActorsTrackerStrategy
// 0x0040 (0x0070 - 0x0030)
class URangeToActorsTrackerStrategy : public UObject
{
public:
	struct FDBDTunableRowHandle                   _range;                                            // 0x0030(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x18];                                      // 0x0058(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInRangeToTrackedActorsChanged(const bool inRange);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RangeToActorsTrackerStrategy">();
	}
	static class URangeToActorsTrackerStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<URangeToActorsTrackerStrategy>();
	}
};
static_assert(alignof(URangeToActorsTrackerStrategy) == 0x000008, "Wrong alignment on URangeToActorsTrackerStrategy");
static_assert(sizeof(URangeToActorsTrackerStrategy) == 0x000070, "Wrong size on URangeToActorsTrackerStrategy");
static_assert(offsetof(URangeToActorsTrackerStrategy, _range) == 0x000030, "Member 'URangeToActorsTrackerStrategy::_range' has a wrong offset!");

// Class DBDGameplay.ExitGateSwitchesRangeTrackerStrategy
// 0x0000 (0x0070 - 0x0070)
class UExitGateSwitchesRangeTrackerStrategy final : public URangeToActorsTrackerStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExitGateSwitchesRangeTrackerStrategy">();
	}
	static class UExitGateSwitchesRangeTrackerStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExitGateSwitchesRangeTrackerStrategy>();
	}
};
static_assert(alignof(UExitGateSwitchesRangeTrackerStrategy) == 0x000008, "Wrong alignment on UExitGateSwitchesRangeTrackerStrategy");
static_assert(sizeof(UExitGateSwitchesRangeTrackerStrategy) == 0x000070, "Wrong size on UExitGateSwitchesRangeTrackerStrategy");

// Class DBDGameplay.FadingBlockFeedback
// 0x0018 (0x02C0 - 0x02A8)
class AFadingBlockFeedback : public ABlockFeedbackBase
{
public:
	class UCurveFloat*                            _fadeCurve;                                        // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0[0x10];                                     // 0x02B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFadeOutEnded();
	void OnFadeOutStarted(const float fadeDuration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FadingBlockFeedback">();
	}
	static class AFadingBlockFeedback* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFadingBlockFeedback>();
	}
};
static_assert(alignof(AFadingBlockFeedback) == 0x000008, "Wrong alignment on AFadingBlockFeedback");
static_assert(sizeof(AFadingBlockFeedback) == 0x0002C0, "Wrong size on AFadingBlockFeedback");
static_assert(offsetof(AFadingBlockFeedback, _fadeCurve) == 0x0002A8, "Member 'AFadingBlockFeedback::_fadeCurve' has a wrong offset!");

// Class DBDGameplay.FatherTerminalHackingInteraction
// 0x00D0 (0x0840 - 0x0770)
class UFatherTerminalHackingInteraction final : public UInteractionDefinition
{
public:
	TMulticastInlineDelegate<void(bool IsRunning)> Cosmetic_OnCooldownTimerStartOrDoneEvent;         // 0x0768(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              Cosmetic_OnInteractionStarted;                     // 0x0778(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              Cosmetic_OnSuccessfullyEndMiniGameAnimationStarted; // 0x0788(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FDirectionalMiniGameDefinition         _miniGameDefinition;                               // 0x0798(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         _cooldownDurationSeconds;                          // 0x07B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7BC[0x14];                                     // 0x07BC(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isHackingCompleted;                               // 0x07D0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isCooldownTimerRunning;                           // 0x07D1(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _useSuccessfullyEndMiniGameExit;                   // 0x07D2(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7D3[0x5];                                      // 0x07D3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimationMontageDescriptor            _successfullyEndMiniGameAnimationMontageDescriptor; // 0x07D8(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7F8[0x48];                                     // 0x07F8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnCoolDownTimerDone();
	void Authority_OnMinigameEnd(class ASurvivor* Survivor, EDirectionalMinigameResult Result);
	void OnRep_IsCooldownTimerRunning();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FatherTerminalHackingInteraction">();
	}
	static class UFatherTerminalHackingInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFatherTerminalHackingInteraction>();
	}
};
static_assert(alignof(UFatherTerminalHackingInteraction) == 0x000010, "Wrong alignment on UFatherTerminalHackingInteraction");
static_assert(sizeof(UFatherTerminalHackingInteraction) == 0x000840, "Wrong size on UFatherTerminalHackingInteraction");
static_assert(offsetof(UFatherTerminalHackingInteraction, Cosmetic_OnCooldownTimerStartOrDoneEvent) == 0x000768, "Member 'UFatherTerminalHackingInteraction::Cosmetic_OnCooldownTimerStartOrDoneEvent' has a wrong offset!");
static_assert(offsetof(UFatherTerminalHackingInteraction, Cosmetic_OnInteractionStarted) == 0x000778, "Member 'UFatherTerminalHackingInteraction::Cosmetic_OnInteractionStarted' has a wrong offset!");
static_assert(offsetof(UFatherTerminalHackingInteraction, Cosmetic_OnSuccessfullyEndMiniGameAnimationStarted) == 0x000788, "Member 'UFatherTerminalHackingInteraction::Cosmetic_OnSuccessfullyEndMiniGameAnimationStarted' has a wrong offset!");
static_assert(offsetof(UFatherTerminalHackingInteraction, _miniGameDefinition) == 0x000798, "Member 'UFatherTerminalHackingInteraction::_miniGameDefinition' has a wrong offset!");
static_assert(offsetof(UFatherTerminalHackingInteraction, _cooldownDurationSeconds) == 0x0007B8, "Member 'UFatherTerminalHackingInteraction::_cooldownDurationSeconds' has a wrong offset!");
static_assert(offsetof(UFatherTerminalHackingInteraction, _isHackingCompleted) == 0x0007D0, "Member 'UFatherTerminalHackingInteraction::_isHackingCompleted' has a wrong offset!");
static_assert(offsetof(UFatherTerminalHackingInteraction, _isCooldownTimerRunning) == 0x0007D1, "Member 'UFatherTerminalHackingInteraction::_isCooldownTimerRunning' has a wrong offset!");
static_assert(offsetof(UFatherTerminalHackingInteraction, _useSuccessfullyEndMiniGameExit) == 0x0007D2, "Member 'UFatherTerminalHackingInteraction::_useSuccessfullyEndMiniGameExit' has a wrong offset!");
static_assert(offsetof(UFatherTerminalHackingInteraction, _successfullyEndMiniGameAnimationMontageDescriptor) == 0x0007D8, "Member 'UFatherTerminalHackingInteraction::_successfullyEndMiniGameAnimationMontageDescriptor' has a wrong offset!");

// Class DBDGameplay.Firecracker
// 0x0008 (0x0420 - 0x0418)
class AFirecracker : public ARangedExplosive
{
public:
	class UFirecrackerStateMachine*               _firecrackerStateMachine;                          // 0x0418(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Firecracker">();
	}
	static class AFirecracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFirecracker>();
	}
};
static_assert(alignof(AFirecracker) == 0x000008, "Wrong alignment on AFirecracker");
static_assert(sizeof(AFirecracker) == 0x000420, "Wrong size on AFirecracker");
static_assert(offsetof(AFirecracker, _firecrackerStateMachine) == 0x000418, "Member 'AFirecracker::_firecrackerStateMachine' has a wrong offset!");

// Class DBDGameplay.FirecrackerScoreComponent
// 0x0008 (0x00C0 - 0x00B8)
class UFirecrackerScoreComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FirecrackerScoreComponent">();
	}
	static class UFirecrackerScoreComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFirecrackerScoreComponent>();
	}
};
static_assert(alignof(UFirecrackerScoreComponent) == 0x000008, "Wrong alignment on UFirecrackerScoreComponent");
static_assert(sizeof(UFirecrackerScoreComponent) == 0x0000C0, "Wrong size on UFirecrackerScoreComponent");

// Class DBDGameplay.FirecrackerSpawner
// 0x0010 (0x05B0 - 0x05A0)
class AFirecrackerSpawner final : public ABaseSurvivorCollectable
{
public:
	TSubclassOf<class AActor>                     _firecrackerClass;                                 // 0x05A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _possibleThrowHeight;                              // 0x05A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5AC[0x4];                                      // 0x05AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FirecrackerSpawner">();
	}
	static class AFirecrackerSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFirecrackerSpawner>();
	}
};
static_assert(alignof(AFirecrackerSpawner) == 0x000008, "Wrong alignment on AFirecrackerSpawner");
static_assert(sizeof(AFirecrackerSpawner) == 0x0005B0, "Wrong size on AFirecrackerSpawner");
static_assert(offsetof(AFirecrackerSpawner, _firecrackerClass) == 0x0005A0, "Member 'AFirecrackerSpawner::_firecrackerClass' has a wrong offset!");
static_assert(offsetof(AFirecrackerSpawner, _possibleThrowHeight) == 0x0005A8, "Member 'AFirecrackerSpawner::_possibleThrowHeight' has a wrong offset!");

// Class DBDGameplay.FirecrackerSpawnInteraction
// 0x0000 (0x0770 - 0x0770)
class UFirecrackerSpawnInteraction final : public UInteractionDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FirecrackerSpawnInteraction">();
	}
	static class UFirecrackerSpawnInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFirecrackerSpawnInteraction>();
	}
};
static_assert(alignof(UFirecrackerSpawnInteraction) == 0x000010, "Wrong alignment on UFirecrackerSpawnInteraction");
static_assert(sizeof(UFirecrackerSpawnInteraction) == 0x000770, "Wrong size on UFirecrackerSpawnInteraction");

// Class DBDGameplay.FirecrackerStateMachine
// 0x0000 (0x0130 - 0x0130)
class UFirecrackerStateMachine final : public UStateMachine
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FirecrackerStateMachine">();
	}
	static class UFirecrackerStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFirecrackerStateMachine>();
	}
};
static_assert(alignof(UFirecrackerStateMachine) == 0x000010, "Wrong alignment on UFirecrackerStateMachine");
static_assert(sizeof(UFirecrackerStateMachine) == 0x000130, "Wrong size on UFirecrackerStateMachine");

// Class DBDGameplay.Flashlight
// 0x00F0 (0x0690 - 0x05A0)
class AFlashlight final : public ABaseSurvivorCollectable
{
public:
	struct FGameplayTagContainer                  _allowedInteractionSemanticsDuringUse;             // 0x05A0(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C0[0x58];                                     // 0x05C0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _shouldUseCooldowns;                               // 0x0618(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_619[0x3];                                      // 0x0619(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _cooldownWhileOnDuration;                          // 0x061C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _cooldownWhileOffDuration;                         // 0x0620(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_624[0x6C];                                     // 0x0624(0x006C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USpotLightComponent* GetSpotlightComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Flashlight">();
	}
	static class AFlashlight* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlashlight>();
	}
};
static_assert(alignof(AFlashlight) == 0x000008, "Wrong alignment on AFlashlight");
static_assert(sizeof(AFlashlight) == 0x000690, "Wrong size on AFlashlight");
static_assert(offsetof(AFlashlight, _allowedInteractionSemanticsDuringUse) == 0x0005A0, "Member 'AFlashlight::_allowedInteractionSemanticsDuringUse' has a wrong offset!");
static_assert(offsetof(AFlashlight, _shouldUseCooldowns) == 0x000618, "Member 'AFlashlight::_shouldUseCooldowns' has a wrong offset!");
static_assert(offsetof(AFlashlight, _cooldownWhileOnDuration) == 0x00061C, "Member 'AFlashlight::_cooldownWhileOnDuration' has a wrong offset!");
static_assert(offsetof(AFlashlight, _cooldownWhileOffDuration) == 0x000620, "Member 'AFlashlight::_cooldownWhileOffDuration' has a wrong offset!");

// Class DBDGameplay.FlashlightableComponent
// 0x0088 (0x0140 - 0x00B8)
class UFlashlightableComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(const class UFlashlightComponent* Flashlight)> OnFlashlightAddedEvent; // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class UFlashlightComponent* Flashlight)> OnFlashlightRemovedEvent; // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool IsLit)>    OnFlashlightLitChangedEvent;                       // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UFlashlightableLightingStrategy*        _lightingStrategy;                                 // 0x00E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class UFlashlightComponent*>             _flashlights;                                      // 0x00F0(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	bool IsLit() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlashlightableComponent">();
	}
	static class UFlashlightableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlashlightableComponent>();
	}
};
static_assert(alignof(UFlashlightableComponent) == 0x000008, "Wrong alignment on UFlashlightableComponent");
static_assert(sizeof(UFlashlightableComponent) == 0x000140, "Wrong size on UFlashlightableComponent");
static_assert(offsetof(UFlashlightableComponent, OnFlashlightAddedEvent) == 0x0000B8, "Member 'UFlashlightableComponent::OnFlashlightAddedEvent' has a wrong offset!");
static_assert(offsetof(UFlashlightableComponent, OnFlashlightRemovedEvent) == 0x0000C8, "Member 'UFlashlightableComponent::OnFlashlightRemovedEvent' has a wrong offset!");
static_assert(offsetof(UFlashlightableComponent, OnFlashlightLitChangedEvent) == 0x0000D8, "Member 'UFlashlightableComponent::OnFlashlightLitChangedEvent' has a wrong offset!");
static_assert(offsetof(UFlashlightableComponent, _lightingStrategy) == 0x0000E8, "Member 'UFlashlightableComponent::_lightingStrategy' has a wrong offset!");
static_assert(offsetof(UFlashlightableComponent, _flashlights) == 0x0000F0, "Member 'UFlashlightableComponent::_flashlights' has a wrong offset!");

// Class DBDGameplay.FlashlightConeComponent
// 0x00B8 (0x0170 - 0x00B8)
class UFlashlightConeComponent final : public UActorComponent
{
public:
	struct FVector                                AIAimBeamLocationOffset;                           // 0x00B8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AIAimBeamRotationOffset;                           // 0x00D0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class USceneComponent*                        _flashlightBottom;                                 // 0x00E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _baseBeamAngle;                                    // 0x00F0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _baseBeamLength;                                   // 0x0118(0x0028)(Edit, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AActor>                  _cacheCollidingActor;                              // 0x0140(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x18];                                     // 0x0148(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   _tagsPreventingBeamOcclusion;                      // 0x0160(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	float GetEffectiveConeHalfAngle() const;
	float GetEffectiveConeLength() const;
	float GetOcclusionDistance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlashlightConeComponent">();
	}
	static class UFlashlightConeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlashlightConeComponent>();
	}
};
static_assert(alignof(UFlashlightConeComponent) == 0x000008, "Wrong alignment on UFlashlightConeComponent");
static_assert(sizeof(UFlashlightConeComponent) == 0x000170, "Wrong size on UFlashlightConeComponent");
static_assert(offsetof(UFlashlightConeComponent, AIAimBeamLocationOffset) == 0x0000B8, "Member 'UFlashlightConeComponent::AIAimBeamLocationOffset' has a wrong offset!");
static_assert(offsetof(UFlashlightConeComponent, AIAimBeamRotationOffset) == 0x0000D0, "Member 'UFlashlightConeComponent::AIAimBeamRotationOffset' has a wrong offset!");
static_assert(offsetof(UFlashlightConeComponent, _flashlightBottom) == 0x0000E8, "Member 'UFlashlightConeComponent::_flashlightBottom' has a wrong offset!");
static_assert(offsetof(UFlashlightConeComponent, _baseBeamAngle) == 0x0000F0, "Member 'UFlashlightConeComponent::_baseBeamAngle' has a wrong offset!");
static_assert(offsetof(UFlashlightConeComponent, _baseBeamLength) == 0x000118, "Member 'UFlashlightConeComponent::_baseBeamLength' has a wrong offset!");
static_assert(offsetof(UFlashlightConeComponent, _cacheCollidingActor) == 0x000140, "Member 'UFlashlightConeComponent::_cacheCollidingActor' has a wrong offset!");
static_assert(offsetof(UFlashlightConeComponent, _tagsPreventingBeamOcclusion) == 0x000160, "Member 'UFlashlightConeComponent::_tagsPreventingBeamOcclusion' has a wrong offset!");

// Class DBDGameplay.FlashlightFXComponent
// 0x01B0 (0x0268 - 0x00B8)
class UFlashlightFXComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void()>              OnFlashEvent;                                      // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USceneComponent*                        _tip;                                              // 0x00C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   _centerGlowMesh;                                   // 0x00D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USplineMeshComponent*                   _beamMesh;                                         // 0x00D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minimumOcclusionDistanceForSpotlight;             // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _flashEffectIntensityCurve;                        // 0x00E8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _flashEffectDuration;                              // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _spotLightHalfAngle;                               // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _spotLightIntensity;                               // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _beamBlindingHalfAngle;                            // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _beamFlashHalfAngle;                               // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _beamBlindingRatioInterpSpeedWithTarget;           // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _beamBlindingRatioInterpSpeedWithoutTarget;        // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _resizeConeLength;                                 // 0x010C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _centerGlowWidthScaleWithoutBlindTarget;           // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _centerGlowWidthScaleWithBlindTarget;              // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _centerGlowWidthScaleDuringFlash;                  // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _centerGlowShrinkDistance;                         // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _centerGlowLengthMaxScale;                         // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAkObservedPlayerSoundLoop             _aimedAtSoundLoop;                                 // 0x0128(0x0040)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UFlashlightTargetFXComponent*           _currentBeamModifyingTarget;                       // 0x0168(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class UFlashlightTargetFXComponent*>     _targets;                                          // 0x0170(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C0[0xA8];                                     // 0x01C0(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCollectedEvent(class ADBDPlayer* collector);
	void OnCollectorLocallyObservedChangedEvent(bool IsLocallyObserved);
	void OnDroppedEvent();
	void OnStartEvent();
	void OnStopEvent();
	void OnTurnedOff();
	void OnTurnedOn();
	void PostUpdateEvent();
	void UpdateConeEvent(float Length, float halfAngle);
	void UpdateFXTargets();

	float GetBlindingSuccessRatio() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlashlightFXComponent">();
	}
	static class UFlashlightFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlashlightFXComponent>();
	}
};
static_assert(alignof(UFlashlightFXComponent) == 0x000008, "Wrong alignment on UFlashlightFXComponent");
static_assert(sizeof(UFlashlightFXComponent) == 0x000268, "Wrong size on UFlashlightFXComponent");
static_assert(offsetof(UFlashlightFXComponent, OnFlashEvent) == 0x0000B8, "Member 'UFlashlightFXComponent::OnFlashEvent' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _tip) == 0x0000C8, "Member 'UFlashlightFXComponent::_tip' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _centerGlowMesh) == 0x0000D0, "Member 'UFlashlightFXComponent::_centerGlowMesh' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _beamMesh) == 0x0000D8, "Member 'UFlashlightFXComponent::_beamMesh' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _minimumOcclusionDistanceForSpotlight) == 0x0000E0, "Member 'UFlashlightFXComponent::_minimumOcclusionDistanceForSpotlight' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _flashEffectIntensityCurve) == 0x0000E8, "Member 'UFlashlightFXComponent::_flashEffectIntensityCurve' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _flashEffectDuration) == 0x0000F0, "Member 'UFlashlightFXComponent::_flashEffectDuration' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _spotLightHalfAngle) == 0x0000F4, "Member 'UFlashlightFXComponent::_spotLightHalfAngle' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _spotLightIntensity) == 0x0000F8, "Member 'UFlashlightFXComponent::_spotLightIntensity' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _beamBlindingHalfAngle) == 0x0000FC, "Member 'UFlashlightFXComponent::_beamBlindingHalfAngle' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _beamFlashHalfAngle) == 0x000100, "Member 'UFlashlightFXComponent::_beamFlashHalfAngle' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _beamBlindingRatioInterpSpeedWithTarget) == 0x000104, "Member 'UFlashlightFXComponent::_beamBlindingRatioInterpSpeedWithTarget' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _beamBlindingRatioInterpSpeedWithoutTarget) == 0x000108, "Member 'UFlashlightFXComponent::_beamBlindingRatioInterpSpeedWithoutTarget' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _resizeConeLength) == 0x00010C, "Member 'UFlashlightFXComponent::_resizeConeLength' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _centerGlowWidthScaleWithoutBlindTarget) == 0x000110, "Member 'UFlashlightFXComponent::_centerGlowWidthScaleWithoutBlindTarget' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _centerGlowWidthScaleWithBlindTarget) == 0x000114, "Member 'UFlashlightFXComponent::_centerGlowWidthScaleWithBlindTarget' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _centerGlowWidthScaleDuringFlash) == 0x000118, "Member 'UFlashlightFXComponent::_centerGlowWidthScaleDuringFlash' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _centerGlowShrinkDistance) == 0x00011C, "Member 'UFlashlightFXComponent::_centerGlowShrinkDistance' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _centerGlowLengthMaxScale) == 0x000120, "Member 'UFlashlightFXComponent::_centerGlowLengthMaxScale' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _aimedAtSoundLoop) == 0x000128, "Member 'UFlashlightFXComponent::_aimedAtSoundLoop' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _currentBeamModifyingTarget) == 0x000168, "Member 'UFlashlightFXComponent::_currentBeamModifyingTarget' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _targets) == 0x000170, "Member 'UFlashlightFXComponent::_targets' has a wrong offset!");

// Class DBDGameplay.FlashlightUtilities
// 0x0000 (0x0030 - 0x0030)
class UFlashlightUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlashlightUtilities">();
	}
	static class UFlashlightUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlashlightUtilities>();
	}
};
static_assert(alignof(UFlashlightUtilities) == 0x000008, "Wrong alignment on UFlashlightUtilities");
static_assert(sizeof(UFlashlightUtilities) == 0x000030, "Wrong size on UFlashlightUtilities");

// Class DBDGameplay.FootstepManagerComponent
// 0x0368 (0x0420 - 0x00B8)
class UFootstepManagerComponent final : public UActorComponent
{
public:
	struct FBHVRPerDetailModeInt                  _decalPoolSize;                                    // 0x00B8(0x00A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FBHVRPerDetailModeFloat                _recycleThresholdPercentage;                       // 0x0158(0x00A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FBHVRPerDetailModeFloat                _recycleDistancePercentage;                        // 0x01F8(0x00A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FBHVRPerDetailModeInt                  _maxOverlapping;                                   // 0x0298(0x00A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _raycastHalfAngle;                                 // 0x0338(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _raycastZOffset;                                   // 0x033C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _raycastDistance;                                  // 0x0340(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minimumDecalSize;                                 // 0x0344(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maximumDecalSize;                                 // 0x0348(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _projectionTickness;                               // 0x034C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     _footstepsMaterial;                                // 0x0350(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FFootstep>                      _currentFootSteps;                                 // 0x0358(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UDecalSpawner*                          _decalSpawner;                                     // 0x0368(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_370[0xB0];                                     // 0x0370(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnUpdateCreatorFootsteps(class UFootstepCreatorComponent* creator);
	void OnUpdateObserverFootsteps();
	void TriggerSpawnFootstep(class UFootstepCreatorComponent* originatorComponent, const struct FVector& Location);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootstepManagerComponent">();
	}
	static class UFootstepManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootstepManagerComponent>();
	}
};
static_assert(alignof(UFootstepManagerComponent) == 0x000008, "Wrong alignment on UFootstepManagerComponent");
static_assert(sizeof(UFootstepManagerComponent) == 0x000420, "Wrong size on UFootstepManagerComponent");
static_assert(offsetof(UFootstepManagerComponent, _decalPoolSize) == 0x0000B8, "Member 'UFootstepManagerComponent::_decalPoolSize' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _recycleThresholdPercentage) == 0x000158, "Member 'UFootstepManagerComponent::_recycleThresholdPercentage' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _recycleDistancePercentage) == 0x0001F8, "Member 'UFootstepManagerComponent::_recycleDistancePercentage' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _maxOverlapping) == 0x000298, "Member 'UFootstepManagerComponent::_maxOverlapping' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _raycastHalfAngle) == 0x000338, "Member 'UFootstepManagerComponent::_raycastHalfAngle' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _raycastZOffset) == 0x00033C, "Member 'UFootstepManagerComponent::_raycastZOffset' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _raycastDistance) == 0x000340, "Member 'UFootstepManagerComponent::_raycastDistance' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _minimumDecalSize) == 0x000344, "Member 'UFootstepManagerComponent::_minimumDecalSize' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _maximumDecalSize) == 0x000348, "Member 'UFootstepManagerComponent::_maximumDecalSize' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _projectionTickness) == 0x00034C, "Member 'UFootstepManagerComponent::_projectionTickness' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _footstepsMaterial) == 0x000350, "Member 'UFootstepManagerComponent::_footstepsMaterial' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _currentFootSteps) == 0x000358, "Member 'UFootstepManagerComponent::_currentFootSteps' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _decalSpawner) == 0x000368, "Member 'UFootstepManagerComponent::_decalSpawner' has a wrong offset!");

// Class DBDGameplay.FootstepPerceptionComponent
// 0x0018 (0x00D0 - 0x00B8)
class UFootstepPerceptionComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _canSeeFootstepsDefaultValue;                      // 0x00C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootstepPerceptionComponent">();
	}
	static class UFootstepPerceptionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootstepPerceptionComponent>();
	}
};
static_assert(alignof(UFootstepPerceptionComponent) == 0x000008, "Wrong alignment on UFootstepPerceptionComponent");
static_assert(sizeof(UFootstepPerceptionComponent) == 0x0000D0, "Wrong size on UFootstepPerceptionComponent");
static_assert(offsetof(UFootstepPerceptionComponent, _canSeeFootstepsDefaultValue) == 0x0000C8, "Member 'UFootstepPerceptionComponent::_canSeeFootstepsDefaultValue' has a wrong offset!");

// Class DBDGameplay.FootstepsUtilities
// 0x0000 (0x0030 - 0x0030)
class UFootstepsUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootstepsUtilities">();
	}
	static class UFootstepsUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootstepsUtilities>();
	}
};
static_assert(alignof(UFootstepsUtilities) == 0x000008, "Wrong alignment on UFootstepsUtilities");
static_assert(sizeof(UFootstepsUtilities) == 0x000030, "Wrong size on UFootstepsUtilities");

// Class DBDGameplay.GeneratorWithMostProgressTracker
// 0x0010 (0x00C8 - 0x00B8)
class UGeneratorWithMostProgressTracker final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGeneratorCompleted(bool isAutoCompleted);
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratorWithMostProgressTracker">();
	}
	static class UGeneratorWithMostProgressTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneratorWithMostProgressTracker>();
	}
};
static_assert(alignof(UGeneratorWithMostProgressTracker) == 0x000008, "Wrong alignment on UGeneratorWithMostProgressTracker");
static_assert(sizeof(UGeneratorWithMostProgressTracker) == 0x0000C8, "Wrong size on UGeneratorWithMostProgressTracker");

// Class DBDGameplay.HooksWithSurvivorRangeTrackerStrategy
// 0x0060 (0x00D0 - 0x0070)
class UHooksWithSurvivorRangeTrackerStrategy final : public URangeToActorsTrackerStrategy
{
public:
	uint8                                         Pad_70[0x60];                                      // 0x0070(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HooksWithSurvivorRangeTrackerStrategy">();
	}
	static class UHooksWithSurvivorRangeTrackerStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHooksWithSurvivorRangeTrackerStrategy>();
	}
};
static_assert(alignof(UHooksWithSurvivorRangeTrackerStrategy) == 0x000008, "Wrong alignment on UHooksWithSurvivorRangeTrackerStrategy");
static_assert(sizeof(UHooksWithSurvivorRangeTrackerStrategy) == 0x0000D0, "Wrong size on UHooksWithSurvivorRangeTrackerStrategy");

// Class DBDGameplay.IgnorePalletsCollisionsComponent
// 0x0018 (0x0120 - 0x0108)
class UIgnorePalletsCollisionsComponent final : public UIgnoreCollisionsComponent
{
public:
	TSubclassOf<class UIgnoreCollisionsPalletHandlerComponent> _collisionHandlerComponentClass;      // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UIgnoreCollisionsPalletHandlerComponent*> _collisionHandlerComponents;              // 0x0110(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgnorePalletsCollisionsComponent">();
	}
	static class UIgnorePalletsCollisionsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgnorePalletsCollisionsComponent>();
	}
};
static_assert(alignof(UIgnorePalletsCollisionsComponent) == 0x000008, "Wrong alignment on UIgnorePalletsCollisionsComponent");
static_assert(sizeof(UIgnorePalletsCollisionsComponent) == 0x000120, "Wrong size on UIgnorePalletsCollisionsComponent");
static_assert(offsetof(UIgnorePalletsCollisionsComponent, _collisionHandlerComponentClass) == 0x000108, "Member 'UIgnorePalletsCollisionsComponent::_collisionHandlerComponentClass' has a wrong offset!");
static_assert(offsetof(UIgnorePalletsCollisionsComponent, _collisionHandlerComponents) == 0x000110, "Member 'UIgnorePalletsCollisionsComponent::_collisionHandlerComponents' has a wrong offset!");

// Class DBDGameplay.IgnoreWindowsCollisionsComponent
// 0x0018 (0x0120 - 0x0108)
class UIgnoreWindowsCollisionsComponent final : public UIgnoreCollisionsComponent
{
public:
	TSubclassOf<class UIgnoreCollisionsWindowHandlerComponent> _collisionHandlerComponentClass;      // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UIgnoreCollisionsWindowHandlerComponent*> _collisionHandlerComponents;              // 0x0110(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgnoreWindowsCollisionsComponent">();
	}
	static class UIgnoreWindowsCollisionsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgnoreWindowsCollisionsComponent>();
	}
};
static_assert(alignof(UIgnoreWindowsCollisionsComponent) == 0x000008, "Wrong alignment on UIgnoreWindowsCollisionsComponent");
static_assert(sizeof(UIgnoreWindowsCollisionsComponent) == 0x000120, "Wrong size on UIgnoreWindowsCollisionsComponent");
static_assert(offsetof(UIgnoreWindowsCollisionsComponent, _collisionHandlerComponentClass) == 0x000108, "Member 'UIgnoreWindowsCollisionsComponent::_collisionHandlerComponentClass' has a wrong offset!");
static_assert(offsetof(UIgnoreWindowsCollisionsComponent, _collisionHandlerComponents) == 0x000110, "Member 'UIgnoreWindowsCollisionsComponent::_collisionHandlerComponents' has a wrong offset!");

// Class DBDGameplay.InteractionAttacherComponent
// 0x00A8 (0x0160 - 0x00B8)
class UInteractionAttacherComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x20];                                      // 0x00B8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInteractionDefinition*>         _interactionDefinitions;                           // 0x00D8(0x0010)(ExportObject, Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UChargeableComponent*>           _chargeableComponents;                             // 0x00E8(0x0010)(ExportObject, Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSubclassOf<class UInteractionDefinition>     _interactionDefinition;                            // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EInteractionOwnerType                         _restriction;                                      // 0x0100(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _useChargeableInteraction;                         // 0x0101(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_102[0x2];                                      // 0x0102(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _chargeableComponentID;                            // 0x0104(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _chargeableComponentName;                          // 0x0110(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _secondsToCharge;                                  // 0x0120(0x0028)(Edit, Net, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          _clientWaitForOwnerInitialization;                 // 0x0148(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_149[0x17];                                     // 0x0149(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ChargeableComponents();
	void OnRep_InteractionDefinitions();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionAttacherComponent">();
	}
	static class UInteractionAttacherComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionAttacherComponent>();
	}
};
static_assert(alignof(UInteractionAttacherComponent) == 0x000008, "Wrong alignment on UInteractionAttacherComponent");
static_assert(sizeof(UInteractionAttacherComponent) == 0x000160, "Wrong size on UInteractionAttacherComponent");
static_assert(offsetof(UInteractionAttacherComponent, _interactionDefinitions) == 0x0000D8, "Member 'UInteractionAttacherComponent::_interactionDefinitions' has a wrong offset!");
static_assert(offsetof(UInteractionAttacherComponent, _chargeableComponents) == 0x0000E8, "Member 'UInteractionAttacherComponent::_chargeableComponents' has a wrong offset!");
static_assert(offsetof(UInteractionAttacherComponent, _interactionDefinition) == 0x0000F8, "Member 'UInteractionAttacherComponent::_interactionDefinition' has a wrong offset!");
static_assert(offsetof(UInteractionAttacherComponent, _restriction) == 0x000100, "Member 'UInteractionAttacherComponent::_restriction' has a wrong offset!");
static_assert(offsetof(UInteractionAttacherComponent, _useChargeableInteraction) == 0x000101, "Member 'UInteractionAttacherComponent::_useChargeableInteraction' has a wrong offset!");
static_assert(offsetof(UInteractionAttacherComponent, _chargeableComponentID) == 0x000104, "Member 'UInteractionAttacherComponent::_chargeableComponentID' has a wrong offset!");
static_assert(offsetof(UInteractionAttacherComponent, _chargeableComponentName) == 0x000110, "Member 'UInteractionAttacherComponent::_chargeableComponentName' has a wrong offset!");
static_assert(offsetof(UInteractionAttacherComponent, _secondsToCharge) == 0x000120, "Member 'UInteractionAttacherComponent::_secondsToCharge' has a wrong offset!");
static_assert(offsetof(UInteractionAttacherComponent, _clientWaitForOwnerInitialization) == 0x000148, "Member 'UInteractionAttacherComponent::_clientWaitForOwnerInitialization' has a wrong offset!");

// Class DBDGameplay.InteractionStarterComponent
// 0x0018 (0x00D0 - 0x00B8)
class UInteractionStarterComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionDefinition*                 _interaction;                                      // 0x00C0(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _shouldStartInteraction;                           // 0x00C8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInteractionStarted();
	void OnRep_ShouldStartInteraction();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionStarterComponent">();
	}
	static class UInteractionStarterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionStarterComponent>();
	}
};
static_assert(alignof(UInteractionStarterComponent) == 0x000008, "Wrong alignment on UInteractionStarterComponent");
static_assert(sizeof(UInteractionStarterComponent) == 0x0000D0, "Wrong size on UInteractionStarterComponent");
static_assert(offsetof(UInteractionStarterComponent, _interaction) == 0x0000C0, "Member 'UInteractionStarterComponent::_interaction' has a wrong offset!");
static_assert(offsetof(UInteractionStarterComponent, _shouldStartInteraction) == 0x0000C8, "Member 'UInteractionStarterComponent::_shouldStartInteraction' has a wrong offset!");

// Class DBDGameplay.KillerAbilityBasedPowerWidgetBundlePresentationComponent
// 0x0000 (0x0118 - 0x0118)
class UKillerAbilityBasedPowerWidgetBundlePresentationComponent final : public UPowerWidgetBundlePresentationComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerAbilityBasedPowerWidgetBundlePresentationComponent">();
	}
	static class UKillerAbilityBasedPowerWidgetBundlePresentationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerAbilityBasedPowerWidgetBundlePresentationComponent>();
	}
};
static_assert(alignof(UKillerAbilityBasedPowerWidgetBundlePresentationComponent) == 0x000008, "Wrong alignment on UKillerAbilityBasedPowerWidgetBundlePresentationComponent");
static_assert(sizeof(UKillerAbilityBasedPowerWidgetBundlePresentationComponent) == 0x000118, "Wrong size on UKillerAbilityBasedPowerWidgetBundlePresentationComponent");

// Class DBDGameplay.KillerFlashlightSFXComponent
// 0x00A0 (0x0158 - 0x00B8)
class UKillerFlashlightSFXComponent final : public UActorComponent
{
public:
	struct FAkObservedPlayerSoundLoop             _targetSoundLoop;                                  // 0x00B8(0x0040)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UFlashlightTargetFXComponent*>   _flashlightTargets;                                // 0x00F8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x50];                                     // 0x0108(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerFlashlightSFXComponent">();
	}
	static class UKillerFlashlightSFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerFlashlightSFXComponent>();
	}
};
static_assert(alignof(UKillerFlashlightSFXComponent) == 0x000008, "Wrong alignment on UKillerFlashlightSFXComponent");
static_assert(sizeof(UKillerFlashlightSFXComponent) == 0x000158, "Wrong size on UKillerFlashlightSFXComponent");
static_assert(offsetof(UKillerFlashlightSFXComponent, _targetSoundLoop) == 0x0000B8, "Member 'UKillerFlashlightSFXComponent::_targetSoundLoop' has a wrong offset!");
static_assert(offsetof(UKillerFlashlightSFXComponent, _flashlightTargets) == 0x0000F8, "Member 'UKillerFlashlightSFXComponent::_flashlightTargets' has a wrong offset!");

// Class DBDGameplay.PlayerFootstepPerceptionComponent
// 0x0040 (0x0110 - 0x00D0)
class UPlayerFootstepPerceptionComponent : public UFootstepPerceptionComponent
{
public:
	TArray<struct FGameplayTag>                   _allowFootstepsSeenPerkFlags;                      // 0x00D0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTag>                   _disallowFootstepsSeenPerkFlags;                   // 0x00E0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0[0x20];                                      // 0x00F0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerFootstepPerceptionComponent">();
	}
	static class UPlayerFootstepPerceptionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerFootstepPerceptionComponent>();
	}
};
static_assert(alignof(UPlayerFootstepPerceptionComponent) == 0x000008, "Wrong alignment on UPlayerFootstepPerceptionComponent");
static_assert(sizeof(UPlayerFootstepPerceptionComponent) == 0x000110, "Wrong size on UPlayerFootstepPerceptionComponent");
static_assert(offsetof(UPlayerFootstepPerceptionComponent, _allowFootstepsSeenPerkFlags) == 0x0000D0, "Member 'UPlayerFootstepPerceptionComponent::_allowFootstepsSeenPerkFlags' has a wrong offset!");
static_assert(offsetof(UPlayerFootstepPerceptionComponent, _disallowFootstepsSeenPerkFlags) == 0x0000E0, "Member 'UPlayerFootstepPerceptionComponent::_disallowFootstepsSeenPerkFlags' has a wrong offset!");

// Class DBDGameplay.KillerFootstepPerceptionComponent
// 0x0000 (0x0110 - 0x0110)
class UKillerFootstepPerceptionComponent : public UPlayerFootstepPerceptionComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerFootstepPerceptionComponent">();
	}
	static class UKillerFootstepPerceptionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerFootstepPerceptionComponent>();
	}
};
static_assert(alignof(UKillerFootstepPerceptionComponent) == 0x000008, "Wrong alignment on UKillerFootstepPerceptionComponent");
static_assert(sizeof(UKillerFootstepPerceptionComponent) == 0x000110, "Wrong size on UKillerFootstepPerceptionComponent");

// Class DBDGameplay.KillerFormSwitchingAbilityData
// 0x0010 (0x0080 - 0x0070)
class UKillerFormSwitchingAbilityData final : public UKillerAbilityData
{
public:
	class UAkAudioEvent*                          _onFormSwitchingInteractionEnterAkEvent;           // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          _onFormSwitchingInteractionCancelAkEvent;          // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerFormSwitchingAbilityData">();
	}
	static class UKillerFormSwitchingAbilityData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerFormSwitchingAbilityData>();
	}
};
static_assert(alignof(UKillerFormSwitchingAbilityData) == 0x000008, "Wrong alignment on UKillerFormSwitchingAbilityData");
static_assert(sizeof(UKillerFormSwitchingAbilityData) == 0x000080, "Wrong size on UKillerFormSwitchingAbilityData");
static_assert(offsetof(UKillerFormSwitchingAbilityData, _onFormSwitchingInteractionEnterAkEvent) == 0x000070, "Member 'UKillerFormSwitchingAbilityData::_onFormSwitchingInteractionEnterAkEvent' has a wrong offset!");
static_assert(offsetof(UKillerFormSwitchingAbilityData, _onFormSwitchingInteractionCancelAkEvent) == 0x000078, "Member 'UKillerFormSwitchingAbilityData::_onFormSwitchingInteractionCancelAkEvent' has a wrong offset!");

// Class DBDGameplay.KillerFormSwitchingTransitionInteraction
// 0x0010 (0x0780 - 0x0770)
class UKillerFormSwitchingTransitionInteraction final : public UInteractionDefinition
{
public:
	bool                                          _targetFormToTransitionIsNextForm;                 // 0x0768(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_769[0x17];                                     // 0x0769(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerFormSwitchingTransitionInteraction">();
	}
	static class UKillerFormSwitchingTransitionInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerFormSwitchingTransitionInteraction>();
	}
};
static_assert(alignof(UKillerFormSwitchingTransitionInteraction) == 0x000010, "Wrong alignment on UKillerFormSwitchingTransitionInteraction");
static_assert(sizeof(UKillerFormSwitchingTransitionInteraction) == 0x000780, "Wrong size on UKillerFormSwitchingTransitionInteraction");
static_assert(offsetof(UKillerFormSwitchingTransitionInteraction, _targetFormToTransitionIsNextForm) == 0x000768, "Member 'UKillerFormSwitchingTransitionInteraction::_targetFormToTransitionIsNextForm' has a wrong offset!");

// Class DBDGameplay.KillerInstinctComponent
// 0x01C8 (0x0280 - 0x00B8)
class UKillerInstinctComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCustomKillerInstinctData              _defaultKillerInstinctAsset;                       // 0x00C0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      _particleSystemComponent;                          // 0x00E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x4];                                       // 0x00F0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           _camperHighlightColorOverride;                     // 0x00F4(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_104[0xAC];                                     // 0x0104(0x00AC)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCustomKillerInstinctData>      _customKillerInstinctData;                         // 0x01B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FCustomKillerInstinctData              _currentKillerInstinctData;                        // 0x01C0(0x0028)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E8[0x98];                                     // 0x01E8(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UNiagaraComponent* GetParticleSystem();
	bool IsRevealedToPlayer(const class ADBDPlayer* Player);
	void OnKillerLocallyObservedChanged(bool locallyObserved);
	void SetParticleSystem(class UNiagaraComponent* ParticleSystemComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerInstinctComponent">();
	}
	static class UKillerInstinctComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerInstinctComponent>();
	}
};
static_assert(alignof(UKillerInstinctComponent) == 0x000008, "Wrong alignment on UKillerInstinctComponent");
static_assert(sizeof(UKillerInstinctComponent) == 0x000280, "Wrong size on UKillerInstinctComponent");
static_assert(offsetof(UKillerInstinctComponent, _defaultKillerInstinctAsset) == 0x0000C0, "Member 'UKillerInstinctComponent::_defaultKillerInstinctAsset' has a wrong offset!");
static_assert(offsetof(UKillerInstinctComponent, _particleSystemComponent) == 0x0000E8, "Member 'UKillerInstinctComponent::_particleSystemComponent' has a wrong offset!");
static_assert(offsetof(UKillerInstinctComponent, _camperHighlightColorOverride) == 0x0000F4, "Member 'UKillerInstinctComponent::_camperHighlightColorOverride' has a wrong offset!");
static_assert(offsetof(UKillerInstinctComponent, _customKillerInstinctData) == 0x0001B0, "Member 'UKillerInstinctComponent::_customKillerInstinctData' has a wrong offset!");
static_assert(offsetof(UKillerInstinctComponent, _currentKillerInstinctData) == 0x0001C0, "Member 'UKillerInstinctComponent::_currentKillerInstinctData' has a wrong offset!");

// Class DBDGameplay.KillerPowerElementsSpawnedDelegate
// 0x0028 (0x0058 - 0x0030)
class UKillerPowerElementsSpawnedDelegate final : public UObject
{
public:
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerPowerElementsSpawnedDelegate">();
	}
	static class UKillerPowerElementsSpawnedDelegate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerPowerElementsSpawnedDelegate>();
	}
};
static_assert(alignof(UKillerPowerElementsSpawnedDelegate) == 0x000008, "Wrong alignment on UKillerPowerElementsSpawnedDelegate");
static_assert(sizeof(UKillerPowerElementsSpawnedDelegate) == 0x000058, "Wrong size on UKillerPowerElementsSpawnedDelegate");

// Class DBDGameplay.KillerPowerReference
// 0x0000 (0x0000 - 0x0000)
class IKillerPowerReference final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerPowerReference">();
	}
	static class IKillerPowerReference* GetDefaultObj()
	{
		return GetDefaultObjImpl<IKillerPowerReference>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IKillerPowerReference) == 0x000001, "Wrong alignment on IKillerPowerReference");
static_assert(sizeof(IKillerPowerReference) == 0x000001, "Wrong size on IKillerPowerReference");

// Class DBDGameplay.KillerPowerUtilities
// 0x0000 (0x0030 - 0x0030)
class UKillerPowerUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class AKillerPower* GetKillerPowerFromPlayer(const class ADBDPlayer* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerPowerUtilities">();
	}
	static class UKillerPowerUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerPowerUtilities>();
	}
};
static_assert(alignof(UKillerPowerUtilities) == 0x000008, "Wrong alignment on UKillerPowerUtilities");
static_assert(sizeof(UKillerPowerUtilities) == 0x000030, "Wrong size on UKillerPowerUtilities");

// Class DBDGameplay.KillerProjectileAbilityChargeThrowInteraction
// 0x00B0 (0x09D0 - 0x0920)
class UKillerProjectileAbilityChargeThrowInteraction final : public UBasicChargeableInteraction
{
public:
	class UCurveFloat*                            _previewDistanceCurve;                             // 0x0920(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _numberOfPointsNeeded;                             // 0x0928(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minPointDistance;                                 // 0x092C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _killerProjectileAimStartGameEventTag;             // 0x0930(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _killerProjectileAimEndGameEventTag;               // 0x093C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_948[0x88];                                     // 0x0948(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_MakeArcPreview(const TArray<struct FVector>& Points, const struct FHitResult& HitResult, const bool shouldShowImpactPoint, const float arclengthAtImpactPoint);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerProjectileAbilityChargeThrowInteraction">();
	}
	static class UKillerProjectileAbilityChargeThrowInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerProjectileAbilityChargeThrowInteraction>();
	}
};
static_assert(alignof(UKillerProjectileAbilityChargeThrowInteraction) == 0x000010, "Wrong alignment on UKillerProjectileAbilityChargeThrowInteraction");
static_assert(sizeof(UKillerProjectileAbilityChargeThrowInteraction) == 0x0009D0, "Wrong size on UKillerProjectileAbilityChargeThrowInteraction");
static_assert(offsetof(UKillerProjectileAbilityChargeThrowInteraction, _previewDistanceCurve) == 0x000920, "Member 'UKillerProjectileAbilityChargeThrowInteraction::_previewDistanceCurve' has a wrong offset!");
static_assert(offsetof(UKillerProjectileAbilityChargeThrowInteraction, _numberOfPointsNeeded) == 0x000928, "Member 'UKillerProjectileAbilityChargeThrowInteraction::_numberOfPointsNeeded' has a wrong offset!");
static_assert(offsetof(UKillerProjectileAbilityChargeThrowInteraction, _minPointDistance) == 0x00092C, "Member 'UKillerProjectileAbilityChargeThrowInteraction::_minPointDistance' has a wrong offset!");
static_assert(offsetof(UKillerProjectileAbilityChargeThrowInteraction, _killerProjectileAimStartGameEventTag) == 0x000930, "Member 'UKillerProjectileAbilityChargeThrowInteraction::_killerProjectileAimStartGameEventTag' has a wrong offset!");
static_assert(offsetof(UKillerProjectileAbilityChargeThrowInteraction, _killerProjectileAimEndGameEventTag) == 0x00093C, "Member 'UKillerProjectileAbilityChargeThrowInteraction::_killerProjectileAimEndGameEventTag' has a wrong offset!");

// Class DBDGameplay.KillerProjectileAbilityThrowCancelledInteraction
// 0x0010 (0x0780 - 0x0770)
class UKillerProjectileAbilityThrowCancelledInteraction final : public UInteractionDefinition
{
public:
	uint8                                         Pad_768[0x18];                                     // 0x0768(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerProjectileAbilityThrowCancelledInteraction">();
	}
	static class UKillerProjectileAbilityThrowCancelledInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerProjectileAbilityThrowCancelledInteraction>();
	}
};
static_assert(alignof(UKillerProjectileAbilityThrowCancelledInteraction) == 0x000010, "Wrong alignment on UKillerProjectileAbilityThrowCancelledInteraction");
static_assert(sizeof(UKillerProjectileAbilityThrowCancelledInteraction) == 0x000780, "Wrong size on UKillerProjectileAbilityThrowCancelledInteraction");

// Class DBDGameplay.KillerProjectileAbilityThrowInteraction
// 0x0010 (0x0780 - 0x0770)
class UKillerProjectileAbilityThrowInteraction final : public UInteractionDefinition
{
public:
	uint8                                         Pad_768[0x18];                                     // 0x0768(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerProjectileAbilityThrowInteraction">();
	}
	static class UKillerProjectileAbilityThrowInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerProjectileAbilityThrowInteraction>();
	}
};
static_assert(alignof(UKillerProjectileAbilityThrowInteraction) == 0x000010, "Wrong alignment on UKillerProjectileAbilityThrowInteraction");
static_assert(sizeof(UKillerProjectileAbilityThrowInteraction) == 0x000780, "Wrong size on UKillerProjectileAbilityThrowInteraction");

// Class DBDGameplay.KillerScoringComponent
// 0x0010 (0x00C8 - 0x00B8)
class UKillerScoringComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerScoringComponent">();
	}
	static class UKillerScoringComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerScoringComponent>();
	}
};
static_assert(alignof(UKillerScoringComponent) == 0x000008, "Wrong alignment on UKillerScoringComponent");
static_assert(sizeof(UKillerScoringComponent) == 0x0000C8, "Wrong size on UKillerScoringComponent");

// Class DBDGameplay.LockerAccessInteraction
// 0x0000 (0x07A0 - 0x07A0)
class ULockerAccessInteraction : public UBaseLockerInteraction
{
public:
	bool                                          _rushed;                                           // 0x0798(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _shouldCheckRushInput;                             // 0x0799(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_79A[0x6];                                      // 0x079A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FireSoundEventFromInteractor(class AActor* Instigator, class ADBDPlayer* instigatingPlayer);
	void SetOtherInteractorsUsable(const bool IsEnabled);

	class UInteractor* GetInsideInteractor() const;
	class ADBDPlayer* GetPlayerInLocker() const;
	bool IsInteractingPlayerInsideLocker(const class ADBDPlayer* Player) const;
	bool IsOccupied() const;
	bool IsRushed() const;
	void SetCollisionWithLocker(const bool IsEnabled, class ADBDPlayer* Player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LockerAccessInteraction">();
	}
	static class ULockerAccessInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULockerAccessInteraction>();
	}
};
static_assert(alignof(ULockerAccessInteraction) == 0x000010, "Wrong alignment on ULockerAccessInteraction");
static_assert(sizeof(ULockerAccessInteraction) == 0x0007A0, "Wrong size on ULockerAccessInteraction");
static_assert(offsetof(ULockerAccessInteraction, _rushed) == 0x000798, "Member 'ULockerAccessInteraction::_rushed' has a wrong offset!");
static_assert(offsetof(ULockerAccessInteraction, _shouldCheckRushInput) == 0x000799, "Member 'ULockerAccessInteraction::_shouldCheckRushInput' has a wrong offset!");

// Class DBDGameplay.LockerEnterInteraction
// 0x0020 (0x07C0 - 0x07A0)
class ULockerEnterInteraction : public ULockerAccessInteraction
{
public:
	TSubclassOf<class UStatusEffect>              _lockerBlindnessStatusEffectClass;                 // 0x07A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _ejectionFromLockerDelaySeconds;                   // 0x07A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7AC[0x14];                                     // 0x07AC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EjectSurvivorFromLocker(class ASurvivor* Survivor, class ALocker* Locker);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LockerEnterInteraction">();
	}
	static class ULockerEnterInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULockerEnterInteraction>();
	}
};
static_assert(alignof(ULockerEnterInteraction) == 0x000010, "Wrong alignment on ULockerEnterInteraction");
static_assert(sizeof(ULockerEnterInteraction) == 0x0007C0, "Wrong size on ULockerEnterInteraction");
static_assert(offsetof(ULockerEnterInteraction, _lockerBlindnessStatusEffectClass) == 0x0007A0, "Member 'ULockerEnterInteraction::_lockerBlindnessStatusEffectClass' has a wrong offset!");
static_assert(offsetof(ULockerEnterInteraction, _ejectionFromLockerDelaySeconds) == 0x0007A8, "Member 'ULockerEnterInteraction::_ejectionFromLockerDelaySeconds' has a wrong offset!");

// Class DBDGameplay.LockerExitInteraction
// 0x0010 (0x07B0 - 0x07A0)
class ULockerExitInteraction final : public ULockerAccessInteraction
{
public:
	uint8                                         Pad_7A0[0x10];                                     // 0x07A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LockerExitInteraction">();
	}
	static class ULockerExitInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULockerExitInteraction>();
	}
};
static_assert(alignof(ULockerExitInteraction) == 0x000010, "Wrong alignment on ULockerExitInteraction");
static_assert(sizeof(ULockerExitInteraction) == 0x0007B0, "Wrong size on ULockerExitInteraction");

// Class DBDGameplay.LockerGrabInteraction
// 0x0010 (0x07B0 - 0x07A0)
class ULockerGrabInteraction final : public USearchLockerInteraction
{
public:
	TSubclassOf<class UStatusEffect>              _lockerGrabBlindImmunity;                          // 0x07A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ASurvivor*                              _survivorInLocker;                                 // 0x07A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LockerGrabInteraction">();
	}
	static class ULockerGrabInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULockerGrabInteraction>();
	}
};
static_assert(alignof(ULockerGrabInteraction) == 0x000010, "Wrong alignment on ULockerGrabInteraction");
static_assert(sizeof(ULockerGrabInteraction) == 0x0007B0, "Wrong size on ULockerGrabInteraction");
static_assert(offsetof(ULockerGrabInteraction, _lockerGrabBlindImmunity) == 0x0007A0, "Member 'ULockerGrabInteraction::_lockerGrabBlindImmunity' has a wrong offset!");
static_assert(offsetof(ULockerGrabInteraction, _survivorInLocker) == 0x0007A8, "Member 'ULockerGrabInteraction::_survivorInLocker' has a wrong offset!");

// Class DBDGameplay.LockerJumpScareEnterInteraction
// 0x0050 (0x0810 - 0x07C0)
class ULockerJumpScareEnterInteraction final : public ULockerEnterInteraction
{
public:
	TArray<struct FLockerJumpScarePropStruct>     _propInfos;                                        // 0x07C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         _spawnedPropActors;                                // 0x07D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7E0[0x30];                                     // 0x07E0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LockerJumpScareEnterInteraction">();
	}
	static class ULockerJumpScareEnterInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULockerJumpScareEnterInteraction>();
	}
};
static_assert(alignof(ULockerJumpScareEnterInteraction) == 0x000010, "Wrong alignment on ULockerJumpScareEnterInteraction");
static_assert(sizeof(ULockerJumpScareEnterInteraction) == 0x000810, "Wrong size on ULockerJumpScareEnterInteraction");
static_assert(offsetof(ULockerJumpScareEnterInteraction, _propInfos) == 0x0007C0, "Member 'ULockerJumpScareEnterInteraction::_propInfos' has a wrong offset!");
static_assert(offsetof(ULockerJumpScareEnterInteraction, _spawnedPropActors) == 0x0007D0, "Member 'ULockerJumpScareEnterInteraction::_spawnedPropActors' has a wrong offset!");

// Class DBDGameplay.LockerJumpScareManagerComponent
// 0x0048 (0x0100 - 0x00B8)
class ULockerJumpScareManagerComponent final : public UMapSpecificGameStateComponent
{
public:
	TSubclassOf<class ULockerJumpScareEnterInteraction> _lockerJumpScareInteraction;                 // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _globalJumpScareChanceIncrease;                    // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _globalJumpScareChanceInitialValue;                // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           _akLockerJumpScareComponent;                       // 0x00C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULockerJumpScareEnterInteraction*       _interaction;                                      // 0x00D8(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ALocker*                                _locker;                                           // 0x00E0(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _shouldImplementLockerJumpScareInteraction;        // 0x00E8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E9[0x17];                                      // 0x00E9(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnLevelReadyToPlay();
	void Authority_OnLockerInteractorChanged(bool IsLocked);
	void Authority_OnLockerJumpScareInteractionDone();
	void DBD_ShowLockerJumpScare(bool Enable);
	void OnRep_JumpScareLocker(class ALocker* lastLocker);
	void OnRep_LockerJumpScareInteraction();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LockerJumpScareManagerComponent">();
	}
	static class ULockerJumpScareManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULockerJumpScareManagerComponent>();
	}
};
static_assert(alignof(ULockerJumpScareManagerComponent) == 0x000008, "Wrong alignment on ULockerJumpScareManagerComponent");
static_assert(sizeof(ULockerJumpScareManagerComponent) == 0x000100, "Wrong size on ULockerJumpScareManagerComponent");
static_assert(offsetof(ULockerJumpScareManagerComponent, _lockerJumpScareInteraction) == 0x0000B8, "Member 'ULockerJumpScareManagerComponent::_lockerJumpScareInteraction' has a wrong offset!");
static_assert(offsetof(ULockerJumpScareManagerComponent, _globalJumpScareChanceIncrease) == 0x0000C0, "Member 'ULockerJumpScareManagerComponent::_globalJumpScareChanceIncrease' has a wrong offset!");
static_assert(offsetof(ULockerJumpScareManagerComponent, _globalJumpScareChanceInitialValue) == 0x0000C4, "Member 'ULockerJumpScareManagerComponent::_globalJumpScareChanceInitialValue' has a wrong offset!");
static_assert(offsetof(ULockerJumpScareManagerComponent, _akLockerJumpScareComponent) == 0x0000C8, "Member 'ULockerJumpScareManagerComponent::_akLockerJumpScareComponent' has a wrong offset!");
static_assert(offsetof(ULockerJumpScareManagerComponent, _interaction) == 0x0000D8, "Member 'ULockerJumpScareManagerComponent::_interaction' has a wrong offset!");
static_assert(offsetof(ULockerJumpScareManagerComponent, _locker) == 0x0000E0, "Member 'ULockerJumpScareManagerComponent::_locker' has a wrong offset!");
static_assert(offsetof(ULockerJumpScareManagerComponent, _shouldImplementLockerJumpScareInteraction) == 0x0000E8, "Member 'ULockerJumpScareManagerComponent::_shouldImplementLockerJumpScareInteraction' has a wrong offset!");

// Class DBDGameplay.LookAtScriptedEventMapTriggerComponent
// 0x00F0 (0x03C0 - 0x02D0)
class ULookAtScriptedEventMapTriggerComponent final : public USceneComponent
{
public:
	TMulticastInlineDelegate<void()>              _cosmetic_firstPlayerEnterTriggerVolumeEvent;      // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              _cosmetic_lastPlayerExitTriggerVolumeEvent;        // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              _cosmetic_lookTowardPointEvent;                    // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              _cosmetic_noLookTowardPointEvent;                  // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              _cosmetic_eventTriggeredEvent;                     // 0x0310(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FCollisionProfileName                  _triggerVolumeCollisionProfile;                    // 0x0320(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         _precisionAngleDegrees;                            // 0x032C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _useLookAtTimer;                                   // 0x0330(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_331[0x3];                                      // 0x0331(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _lookAtTimerTime;                                  // 0x0334(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UShapeComponent*                        _playerTriggerVolume;                              // 0x0338(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   _lookAtPoint;                                      // 0x0340(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<TWeakObjectPtr<class ADBDPlayer>, struct FLookingAtData> _authority_overlappingPlayers;     // 0x0348(0x0050)(Transient, NativeAccessSpecifierPrivate)
	bool                                          _isAnyPlayerInTriggerVolume;                       // 0x0398(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isAnyPlayerLookingAtPoint;                        // 0x0399(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _wasEventTriggered;                                // 0x039A(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39B[0x25];                                     // 0x039B(0x0025)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnPlayerEnterTriggerVolume(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void Authority_OnPlayerExitTriggerVolume(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnLevelReadyToPlay();
	void OnRep_IsAnyPlayerInTriggerVolume();
	void OnRep_IsAnyPlayerLookingAtPoint();
	void OnRep_WasEventTriggered();
	void ResetTriggerConditions();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LookAtScriptedEventMapTriggerComponent">();
	}
	static class ULookAtScriptedEventMapTriggerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULookAtScriptedEventMapTriggerComponent>();
	}
};
static_assert(alignof(ULookAtScriptedEventMapTriggerComponent) == 0x000010, "Wrong alignment on ULookAtScriptedEventMapTriggerComponent");
static_assert(sizeof(ULookAtScriptedEventMapTriggerComponent) == 0x0003C0, "Wrong size on ULookAtScriptedEventMapTriggerComponent");
static_assert(offsetof(ULookAtScriptedEventMapTriggerComponent, _cosmetic_firstPlayerEnterTriggerVolumeEvent) == 0x0002D0, "Member 'ULookAtScriptedEventMapTriggerComponent::_cosmetic_firstPlayerEnterTriggerVolumeEvent' has a wrong offset!");
static_assert(offsetof(ULookAtScriptedEventMapTriggerComponent, _cosmetic_lastPlayerExitTriggerVolumeEvent) == 0x0002E0, "Member 'ULookAtScriptedEventMapTriggerComponent::_cosmetic_lastPlayerExitTriggerVolumeEvent' has a wrong offset!");
static_assert(offsetof(ULookAtScriptedEventMapTriggerComponent, _cosmetic_lookTowardPointEvent) == 0x0002F0, "Member 'ULookAtScriptedEventMapTriggerComponent::_cosmetic_lookTowardPointEvent' has a wrong offset!");
static_assert(offsetof(ULookAtScriptedEventMapTriggerComponent, _cosmetic_noLookTowardPointEvent) == 0x000300, "Member 'ULookAtScriptedEventMapTriggerComponent::_cosmetic_noLookTowardPointEvent' has a wrong offset!");
static_assert(offsetof(ULookAtScriptedEventMapTriggerComponent, _cosmetic_eventTriggeredEvent) == 0x000310, "Member 'ULookAtScriptedEventMapTriggerComponent::_cosmetic_eventTriggeredEvent' has a wrong offset!");
static_assert(offsetof(ULookAtScriptedEventMapTriggerComponent, _triggerVolumeCollisionProfile) == 0x000320, "Member 'ULookAtScriptedEventMapTriggerComponent::_triggerVolumeCollisionProfile' has a wrong offset!");
static_assert(offsetof(ULookAtScriptedEventMapTriggerComponent, _precisionAngleDegrees) == 0x00032C, "Member 'ULookAtScriptedEventMapTriggerComponent::_precisionAngleDegrees' has a wrong offset!");
static_assert(offsetof(ULookAtScriptedEventMapTriggerComponent, _useLookAtTimer) == 0x000330, "Member 'ULookAtScriptedEventMapTriggerComponent::_useLookAtTimer' has a wrong offset!");
static_assert(offsetof(ULookAtScriptedEventMapTriggerComponent, _lookAtTimerTime) == 0x000334, "Member 'ULookAtScriptedEventMapTriggerComponent::_lookAtTimerTime' has a wrong offset!");
static_assert(offsetof(ULookAtScriptedEventMapTriggerComponent, _playerTriggerVolume) == 0x000338, "Member 'ULookAtScriptedEventMapTriggerComponent::_playerTriggerVolume' has a wrong offset!");
static_assert(offsetof(ULookAtScriptedEventMapTriggerComponent, _lookAtPoint) == 0x000340, "Member 'ULookAtScriptedEventMapTriggerComponent::_lookAtPoint' has a wrong offset!");
static_assert(offsetof(ULookAtScriptedEventMapTriggerComponent, _authority_overlappingPlayers) == 0x000348, "Member 'ULookAtScriptedEventMapTriggerComponent::_authority_overlappingPlayers' has a wrong offset!");
static_assert(offsetof(ULookAtScriptedEventMapTriggerComponent, _isAnyPlayerInTriggerVolume) == 0x000398, "Member 'ULookAtScriptedEventMapTriggerComponent::_isAnyPlayerInTriggerVolume' has a wrong offset!");
static_assert(offsetof(ULookAtScriptedEventMapTriggerComponent, _isAnyPlayerLookingAtPoint) == 0x000399, "Member 'ULookAtScriptedEventMapTriggerComponent::_isAnyPlayerLookingAtPoint' has a wrong offset!");
static_assert(offsetof(ULookAtScriptedEventMapTriggerComponent, _wasEventTriggered) == 0x00039A, "Member 'ULookAtScriptedEventMapTriggerComponent::_wasEventTriggered' has a wrong offset!");

// Class DBDGameplay.LullabyFeedbackComponent
// 0x0050 (0x0108 - 0x00B8)
class ULullabyFeedbackComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLullabyKillerData>             _killersData;                                      // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x28];                                      // 0x00E0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LullabyFeedbackComponent">();
	}
	static class ULullabyFeedbackComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULullabyFeedbackComponent>();
	}
};
static_assert(alignof(ULullabyFeedbackComponent) == 0x000008, "Wrong alignment on ULullabyFeedbackComponent");
static_assert(sizeof(ULullabyFeedbackComponent) == 0x000108, "Wrong size on ULullabyFeedbackComponent");
static_assert(offsetof(ULullabyFeedbackComponent, _killersData) == 0x0000D0, "Member 'ULullabyFeedbackComponent::_killersData' has a wrong offset!");

// Class DBDGameplay.MapCollectable
// 0x0008 (0x05A8 - 0x05A0)
class AMapCollectable final : public ABaseSurvivorCollectable
{
public:
	uint8                                         Pad_5A0[0x8];                                      // 0x05A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnReadMapInteractionFinished();

	class UActorKnowledgeCollection* GetActorKnowledgeCollection() const;
	class UChargeableComponent* GetChargeableComponent() const;
	class UChargerComponent* GetChargerComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapCollectable">();
	}
	static class AMapCollectable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapCollectable>();
	}
};
static_assert(alignof(AMapCollectable) == 0x000008, "Wrong alignment on AMapCollectable");
static_assert(sizeof(AMapCollectable) == 0x0005A8, "Wrong size on AMapCollectable");

// Class DBDGameplay.MapMarkerActor
// 0x0000 (0x02A0 - 0x02A0)
class AMapMarkerActor final : public AActor
{
public:
	void OnDestroy();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapMarkerActor">();
	}
	static class AMapMarkerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapMarkerActor>();
	}
};
static_assert(alignof(AMapMarkerActor) == 0x000008, "Wrong alignment on AMapMarkerActor");
static_assert(sizeof(AMapMarkerActor) == 0x0002A0, "Wrong size on AMapMarkerActor");

// Class DBDGameplay.Medkit
// 0x0040 (0x05E0 - 0x05A0)
class AMedkit final : public ABaseSurvivorCollectable
{
public:
	class UAkComponent*                           _akComponent;                                      // 0x05A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChargerComponent*                      _charger;                                          // 0x05A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        _dustRingTemplate;                                 // 0x05B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          _medkitGetAkEvent;                                 // 0x05B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          _medkitDropAkEvent;                                // 0x05C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioBank*                           _medkitBank;                                       // 0x05C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _healOtherChargeMultiplier;                        // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D4[0xC];                                      // 0x05D4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_ConsumeIfNotInteracting();
	void Authority_OnAnyOngoingInteractionChanged(const bool IsInteracting);
	void Authority_OnChargeStateChange(const bool Empty);
	void OnMedkitHealedCamper(class ADBDPlayer* healedPlayer);
	void UseCharge(float Seconds);

	float GetCharge() const;
	float GetChargeMultiplier() const;
	bool HasCharge() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Medkit">();
	}
	static class AMedkit* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMedkit>();
	}
};
static_assert(alignof(AMedkit) == 0x000008, "Wrong alignment on AMedkit");
static_assert(sizeof(AMedkit) == 0x0005E0, "Wrong size on AMedkit");
static_assert(offsetof(AMedkit, _akComponent) == 0x0005A0, "Member 'AMedkit::_akComponent' has a wrong offset!");
static_assert(offsetof(AMedkit, _charger) == 0x0005A8, "Member 'AMedkit::_charger' has a wrong offset!");
static_assert(offsetof(AMedkit, _dustRingTemplate) == 0x0005B0, "Member 'AMedkit::_dustRingTemplate' has a wrong offset!");
static_assert(offsetof(AMedkit, _medkitGetAkEvent) == 0x0005B8, "Member 'AMedkit::_medkitGetAkEvent' has a wrong offset!");
static_assert(offsetof(AMedkit, _medkitDropAkEvent) == 0x0005C0, "Member 'AMedkit::_medkitDropAkEvent' has a wrong offset!");
static_assert(offsetof(AMedkit, _medkitBank) == 0x0005C8, "Member 'AMedkit::_medkitBank' has a wrong offset!");
static_assert(offsetof(AMedkit, _healOtherChargeMultiplier) == 0x0005D0, "Member 'AMedkit::_healOtherChargeMultiplier' has a wrong offset!");

// Class DBDGameplay.PointsProvider
// 0x0000 (0x0030 - 0x0030)
class UPointsProvider : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PointsProvider">();
	}
	static class UPointsProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPointsProvider>();
	}
};
static_assert(alignof(UPointsProvider) == 0x000008, "Wrong alignment on UPointsProvider");
static_assert(sizeof(UPointsProvider) == 0x000030, "Wrong size on UPointsProvider");

// Class DBDGameplay.MeshSocketPointsProvider
// 0x0048 (0x0078 - 0x0030)
class UMeshSocketPointsProvider final : public UPointsProvider
{
public:
	struct FComponentReference                    _meshReference;                                    // 0x0030(0x0030)(Edit, NativeAccessSpecifierPrivate)
	class UMeshComponent*                         _mesh;                                             // 0x0060(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _sockets;                                          // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshSocketPointsProvider">();
	}
	static class UMeshSocketPointsProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshSocketPointsProvider>();
	}
};
static_assert(alignof(UMeshSocketPointsProvider) == 0x000008, "Wrong alignment on UMeshSocketPointsProvider");
static_assert(sizeof(UMeshSocketPointsProvider) == 0x000078, "Wrong size on UMeshSocketPointsProvider");
static_assert(offsetof(UMeshSocketPointsProvider, _meshReference) == 0x000030, "Member 'UMeshSocketPointsProvider::_meshReference' has a wrong offset!");
static_assert(offsetof(UMeshSocketPointsProvider, _mesh) == 0x000060, "Member 'UMeshSocketPointsProvider::_mesh' has a wrong offset!");
static_assert(offsetof(UMeshSocketPointsProvider, _sockets) == 0x000068, "Member 'UMeshSocketPointsProvider::_sockets' has a wrong offset!");

// Class DBDGameplay.MoveToGroundComponent
// 0x0010 (0x00C8 - 0x00B8)
class UMoveToGroundComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MoveOwnerToGround();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoveToGroundComponent">();
	}
	static class UMoveToGroundComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoveToGroundComponent>();
	}
};
static_assert(alignof(UMoveToGroundComponent) == 0x000008, "Wrong alignment on UMoveToGroundComponent");
static_assert(sizeof(UMoveToGroundComponent) == 0x0000C8, "Wrong size on UMoveToGroundComponent");

// Class DBDGameplay.MultiSceneComponentPointProvider
// 0x0020 (0x0050 - 0x0030)
class UMultiSceneComponentPointProvider final : public UPointsProvider
{
public:
	TArray<struct FComponentReference>            _sceneReferences;                                  // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class USceneComponent*>                _sceneComponents;                                  // 0x0040(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MultiSceneComponentPointProvider">();
	}
	static class UMultiSceneComponentPointProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMultiSceneComponentPointProvider>();
	}
};
static_assert(alignof(UMultiSceneComponentPointProvider) == 0x000008, "Wrong alignment on UMultiSceneComponentPointProvider");
static_assert(sizeof(UMultiSceneComponentPointProvider) == 0x000050, "Wrong size on UMultiSceneComponentPointProvider");
static_assert(offsetof(UMultiSceneComponentPointProvider, _sceneReferences) == 0x000030, "Member 'UMultiSceneComponentPointProvider::_sceneReferences' has a wrong offset!");
static_assert(offsetof(UMultiSceneComponentPointProvider, _sceneComponents) == 0x000040, "Member 'UMultiSceneComponentPointProvider::_sceneComponents' has a wrong offset!");

// Class DBDGameplay.NearestOutsideMapBoundsLocator
// 0x0028 (0x00E0 - 0x00B8)
class UNearestOutsideMapBoundsLocator : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkComponent*                           _akComponent;                                      // 0x00C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxDistanceFromBorderAllowed;                     // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _heightOfOOBPosition;                              // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x10];                                      // 0x00D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_InitializeAkLimitPointEvent();
	void OnGameBegin();
	void OnGameEnd(EEndGameReason endGameReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NearestOutsideMapBoundsLocator">();
	}
	static class UNearestOutsideMapBoundsLocator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNearestOutsideMapBoundsLocator>();
	}
};
static_assert(alignof(UNearestOutsideMapBoundsLocator) == 0x000008, "Wrong alignment on UNearestOutsideMapBoundsLocator");
static_assert(sizeof(UNearestOutsideMapBoundsLocator) == 0x0000E0, "Wrong size on UNearestOutsideMapBoundsLocator");
static_assert(offsetof(UNearestOutsideMapBoundsLocator, _akComponent) == 0x0000C0, "Member 'UNearestOutsideMapBoundsLocator::_akComponent' has a wrong offset!");
static_assert(offsetof(UNearestOutsideMapBoundsLocator, _maxDistanceFromBorderAllowed) == 0x0000C8, "Member 'UNearestOutsideMapBoundsLocator::_maxDistanceFromBorderAllowed' has a wrong offset!");
static_assert(offsetof(UNearestOutsideMapBoundsLocator, _heightOfOOBPosition) == 0x0000CC, "Member 'UNearestOutsideMapBoundsLocator::_heightOfOOBPosition' has a wrong offset!");

// Class DBDGameplay.NiagaraBlockFeedback
// 0x0008 (0x02C8 - 0x02C0)
class ANiagaraBlockFeedback final : public AFadingBlockFeedback
{
public:
	class UNiagaraComponent*                      _effect;                                           // 0x02C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiagaraBlockFeedback">();
	}
	static class ANiagaraBlockFeedback* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANiagaraBlockFeedback>();
	}
};
static_assert(alignof(ANiagaraBlockFeedback) == 0x000008, "Wrong alignment on ANiagaraBlockFeedback");
static_assert(sizeof(ANiagaraBlockFeedback) == 0x0002C8, "Wrong size on ANiagaraBlockFeedback");
static_assert(offsetof(ANiagaraBlockFeedback, _effect) == 0x0002C0, "Member 'ANiagaraBlockFeedback::_effect' has a wrong offset!");

// Class DBDGameplay.ParticleBlockFeedback
// 0x0008 (0x02C8 - 0x02C0)
class AParticleBlockFeedback final : public AFadingBlockFeedback
{
public:
	class UParticleSystemComponent*               _effect;                                           // 0x02C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleBlockFeedback">();
	}
	static class AParticleBlockFeedback* GetDefaultObj()
	{
		return GetDefaultObjImpl<AParticleBlockFeedback>();
	}
};
static_assert(alignof(AParticleBlockFeedback) == 0x000008, "Wrong alignment on AParticleBlockFeedback");
static_assert(sizeof(AParticleBlockFeedback) == 0x0002C8, "Wrong size on AParticleBlockFeedback");
static_assert(offsetof(AParticleBlockFeedback, _effect) == 0x0002C0, "Member 'AParticleBlockFeedback::_effect' has a wrong offset!");

// Class DBDGameplay.Passage
// 0x0120 (0x04C8 - 0x03A8)
class APassage final : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(EPassageCosmeticState newState, EPassageCosmeticState oldState)> _cosmetic_onPassageCosmeticStateChange; // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class ADBDPlayer* Player, bool IsInRange)> _cosmetic_onPlayerInRangeOfPassageChanged; // 0x03C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UBoxComponent*                          _enterInteractionZone;                             // 0x03D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          _revealExitAuraZone;                               // 0x03D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _moveTowardsComponent;                             // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _teleportEndPointComponent;                        // 0x03E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _teleportToIfStuckComponent;                       // 0x03F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F8[0xC];                                      // 0x03F8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _debugOverridePassageTag;                          // 0x0404(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _debugOverrideConnectedPassageTag;                 // 0x0410(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPassageCosmeticState                         _passageStartingCosmeticState;                     // 0x041C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41D[0x3];                                      // 0x041D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ADBDPlayer*, struct FPassagePlayerHandles> _playerEventHandles;                       // 0x0420(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_470[0x10];                                     // 0x0470(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USpawnedActorReplicationComponent*      _spawnedActorReplicationComponent;                 // 0x0480(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APassage*                               _connectedPassage;                                 // 0x0488(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _entranceRevealTime;                               // 0x0490(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _idleAudioRange;                                   // 0x0494(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _duringInteractionAudioRange;                      // 0x0498(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _entranceVFXDistance;                              // 0x049C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _entranceVFXDistanceMaxHeightOffset;               // 0x04A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isEntryPassage;                                   // 0x04A4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isExitPassage;                                    // 0x04A5(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A6[0x2];                                      // 0x04A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _cameraLocationOffset;                             // 0x04A8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C0[0x8];                                      // 0x04C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnPlayerInRangeChanged(const bool inRange, const class ADBDPlayer* Player);
	void Local_OnPlayerLeftGame(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData);
	void Local_OnPlayerLocallyObservedChanged(bool isObserved, const class ADBDPlayer* Player);
	void OnBeginOverlapRevealExitAuraZone(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlapRevealExitAuraZone(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

	class APassage* GetConnectedPassage() const;
	EPassageCosmeticState GetPassageCosmeticState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passage">();
	}
	static class APassage* GetDefaultObj()
	{
		return GetDefaultObjImpl<APassage>();
	}
};
static_assert(alignof(APassage) == 0x000008, "Wrong alignment on APassage");
static_assert(sizeof(APassage) == 0x0004C8, "Wrong size on APassage");
static_assert(offsetof(APassage, _cosmetic_onPassageCosmeticStateChange) == 0x0003B0, "Member 'APassage::_cosmetic_onPassageCosmeticStateChange' has a wrong offset!");
static_assert(offsetof(APassage, _cosmetic_onPlayerInRangeOfPassageChanged) == 0x0003C0, "Member 'APassage::_cosmetic_onPlayerInRangeOfPassageChanged' has a wrong offset!");
static_assert(offsetof(APassage, _enterInteractionZone) == 0x0003D0, "Member 'APassage::_enterInteractionZone' has a wrong offset!");
static_assert(offsetof(APassage, _revealExitAuraZone) == 0x0003D8, "Member 'APassage::_revealExitAuraZone' has a wrong offset!");
static_assert(offsetof(APassage, _moveTowardsComponent) == 0x0003E0, "Member 'APassage::_moveTowardsComponent' has a wrong offset!");
static_assert(offsetof(APassage, _teleportEndPointComponent) == 0x0003E8, "Member 'APassage::_teleportEndPointComponent' has a wrong offset!");
static_assert(offsetof(APassage, _teleportToIfStuckComponent) == 0x0003F0, "Member 'APassage::_teleportToIfStuckComponent' has a wrong offset!");
static_assert(offsetof(APassage, _debugOverridePassageTag) == 0x000404, "Member 'APassage::_debugOverridePassageTag' has a wrong offset!");
static_assert(offsetof(APassage, _debugOverrideConnectedPassageTag) == 0x000410, "Member 'APassage::_debugOverrideConnectedPassageTag' has a wrong offset!");
static_assert(offsetof(APassage, _passageStartingCosmeticState) == 0x00041C, "Member 'APassage::_passageStartingCosmeticState' has a wrong offset!");
static_assert(offsetof(APassage, _playerEventHandles) == 0x000420, "Member 'APassage::_playerEventHandles' has a wrong offset!");
static_assert(offsetof(APassage, _spawnedActorReplicationComponent) == 0x000480, "Member 'APassage::_spawnedActorReplicationComponent' has a wrong offset!");
static_assert(offsetof(APassage, _connectedPassage) == 0x000488, "Member 'APassage::_connectedPassage' has a wrong offset!");
static_assert(offsetof(APassage, _entranceRevealTime) == 0x000490, "Member 'APassage::_entranceRevealTime' has a wrong offset!");
static_assert(offsetof(APassage, _idleAudioRange) == 0x000494, "Member 'APassage::_idleAudioRange' has a wrong offset!");
static_assert(offsetof(APassage, _duringInteractionAudioRange) == 0x000498, "Member 'APassage::_duringInteractionAudioRange' has a wrong offset!");
static_assert(offsetof(APassage, _entranceVFXDistance) == 0x00049C, "Member 'APassage::_entranceVFXDistance' has a wrong offset!");
static_assert(offsetof(APassage, _entranceVFXDistanceMaxHeightOffset) == 0x0004A0, "Member 'APassage::_entranceVFXDistanceMaxHeightOffset' has a wrong offset!");
static_assert(offsetof(APassage, _isEntryPassage) == 0x0004A4, "Member 'APassage::_isEntryPassage' has a wrong offset!");
static_assert(offsetof(APassage, _isExitPassage) == 0x0004A5, "Member 'APassage::_isExitPassage' has a wrong offset!");
static_assert(offsetof(APassage, _cameraLocationOffset) == 0x0004A8, "Member 'APassage::_cameraLocationOffset' has a wrong offset!");

// Class DBDGameplay.PassageEnterInteraction
// 0x0050 (0x07C0 - 0x0770)
class UPassageEnterInteraction final : public UInteractionDefinition
{
public:
	TMulticastInlineDelegate<void(class ADBDPlayer* Player)> _cosmetic_onPassageInteractionStarted;  // 0x0768(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         _enterMovePhaseSeconds;                            // 0x0778(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _transitionPhaseSeconds;                           // 0x077C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _exitMovePhaseSeconds;                             // 0x0780(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _targetSpringArmLength;                            // 0x0784(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _enterSequenceMoveDistance;                        // 0x0788(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _exitSequenceMoveDistance;                         // 0x078C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _stuckInPassageDistance;                           // 0x0790(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_794[0x8];                                      // 0x0794(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCollisionProfileName                  _collisionProfileForSequence;                      // 0x079C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FCollisionProfileName                  _collisionProfileOnExit;                           // 0x07A8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7B4[0x4];                                      // 0x07B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _preventRunningStatusEffect;                       // 0x07B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class APassage* GetOwningPassage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PassageEnterInteraction">();
	}
	static class UPassageEnterInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassageEnterInteraction>();
	}
};
static_assert(alignof(UPassageEnterInteraction) == 0x000010, "Wrong alignment on UPassageEnterInteraction");
static_assert(sizeof(UPassageEnterInteraction) == 0x0007C0, "Wrong size on UPassageEnterInteraction");
static_assert(offsetof(UPassageEnterInteraction, _cosmetic_onPassageInteractionStarted) == 0x000768, "Member 'UPassageEnterInteraction::_cosmetic_onPassageInteractionStarted' has a wrong offset!");
static_assert(offsetof(UPassageEnterInteraction, _enterMovePhaseSeconds) == 0x000778, "Member 'UPassageEnterInteraction::_enterMovePhaseSeconds' has a wrong offset!");
static_assert(offsetof(UPassageEnterInteraction, _transitionPhaseSeconds) == 0x00077C, "Member 'UPassageEnterInteraction::_transitionPhaseSeconds' has a wrong offset!");
static_assert(offsetof(UPassageEnterInteraction, _exitMovePhaseSeconds) == 0x000780, "Member 'UPassageEnterInteraction::_exitMovePhaseSeconds' has a wrong offset!");
static_assert(offsetof(UPassageEnterInteraction, _targetSpringArmLength) == 0x000784, "Member 'UPassageEnterInteraction::_targetSpringArmLength' has a wrong offset!");
static_assert(offsetof(UPassageEnterInteraction, _enterSequenceMoveDistance) == 0x000788, "Member 'UPassageEnterInteraction::_enterSequenceMoveDistance' has a wrong offset!");
static_assert(offsetof(UPassageEnterInteraction, _exitSequenceMoveDistance) == 0x00078C, "Member 'UPassageEnterInteraction::_exitSequenceMoveDistance' has a wrong offset!");
static_assert(offsetof(UPassageEnterInteraction, _stuckInPassageDistance) == 0x000790, "Member 'UPassageEnterInteraction::_stuckInPassageDistance' has a wrong offset!");
static_assert(offsetof(UPassageEnterInteraction, _collisionProfileForSequence) == 0x00079C, "Member 'UPassageEnterInteraction::_collisionProfileForSequence' has a wrong offset!");
static_assert(offsetof(UPassageEnterInteraction, _collisionProfileOnExit) == 0x0007A8, "Member 'UPassageEnterInteraction::_collisionProfileOnExit' has a wrong offset!");
static_assert(offsetof(UPassageEnterInteraction, _preventRunningStatusEffect) == 0x0007B8, "Member 'UPassageEnterInteraction::_preventRunningStatusEffect' has a wrong offset!");

// Class DBDGameplay.PlayerCameraAimDirectionProvider
// 0x0000 (0x0030 - 0x0030)
class UPlayerCameraAimDirectionProvider final : public UAimDirectionProvider
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCameraAimDirectionProvider">();
	}
	static class UPlayerCameraAimDirectionProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerCameraAimDirectionProvider>();
	}
};
static_assert(alignof(UPlayerCameraAimDirectionProvider) == 0x000008, "Wrong alignment on UPlayerCameraAimDirectionProvider");
static_assert(sizeof(UPlayerCameraAimDirectionProvider) == 0x000030, "Wrong size on UPlayerCameraAimDirectionProvider");

// Class DBDGameplay.PlayerInteractionListenerComponent
// 0x0050 (0x0108 - 0x00B8)
class UPlayerInteractionListenerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x50];                                      // 0x00B8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ListenToInteractionEnd(class ADBDPlayer* Player, const struct FGameplayTag& interactionSemantic, const TDelegate<void(class ADBDPlayer* Player, const struct FGameplayTag& interactionSemantic)>& interactionDelegate);
	void ListenToInteractionStart(class ADBDPlayer* Player, const struct FGameplayTag& interactionSemantic, const TDelegate<void(class ADBDPlayer* Player, const struct FGameplayTag& interactionSemantic)>& interactionDelegate);
	void OnActorDestroyed(class AActor* DestroyedActor);
	void UnlistenToInteractionEnd(class ADBDPlayer* Player, const struct FGameplayTag& interactionSemantic);
	void UnlistenToInteractionStart(class ADBDPlayer* Player, const struct FGameplayTag& interactionSemantic);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerInteractionListenerComponent">();
	}
	static class UPlayerInteractionListenerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerInteractionListenerComponent>();
	}
};
static_assert(alignof(UPlayerInteractionListenerComponent) == 0x000008, "Wrong alignment on UPlayerInteractionListenerComponent");
static_assert(sizeof(UPlayerInteractionListenerComponent) == 0x000108, "Wrong size on UPlayerInteractionListenerComponent");

// Class DBDGameplay.PlayerMovementUtilities
// 0x0000 (0x0030 - 0x0030)
class UPlayerMovementUtilities final : public UBlueprintFunctionLibrary
{
public:
	static void Local_ApplyGamepadPitchScaleMultiplier(class ADBDPlayer* Player, const float Multiplier, const float adjustmentTime);
	static void Local_ApplyGamepadYawScaleMultiplier(class ADBDPlayer* Player, const float Multiplier, const float adjustmentTime);
	static void Local_ApplyMousePitchScaleMultiplier(class ADBDPlayer* Player, const float Multiplier, const float adjustmentTime);
	static void Local_ApplyMouseYawScaleMultiplier(class ADBDPlayer* Player, const float Multiplier, const float adjustmentTime);
	static void Local_ApplyPitchScaleMultiplier(class ADBDPlayer* Player, const float Multiplier, const float adjustmentTime);
	static void Local_ApplyRotationScaleMultiplier(class ADBDPlayer* Player, const float Multiplier, const float adjustmentTime);
	static void Local_ApplyYawScaleMultiplier(class ADBDPlayer* Player, const float Multiplier, const float adjustmentTime);
	static void Local_ResetGamepadLookCurves(class ADBDPlayer* Player);
	static void Local_ResetRotationScale(class ADBDPlayer* Player, const float adjustmentTime);
	static void Local_SetGamepadPitchCurve(class ADBDPlayer* Player, class UCurveFloat* Curve);
	static void Local_SetGamepadYawCurve(class ADBDPlayer* Player, class UCurveFloat* Curve);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerMovementUtilities">();
	}
	static class UPlayerMovementUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerMovementUtilities>();
	}
};
static_assert(alignof(UPlayerMovementUtilities) == 0x000008, "Wrong alignment on UPlayerMovementUtilities");
static_assert(sizeof(UPlayerMovementUtilities) == 0x000030, "Wrong size on UPlayerMovementUtilities");

// Class DBDGameplay.PlayersInZoneTracker
// 0x00A0 (0x0158 - 0x00B8)
class UPlayersInZoneTracker final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x30];                                      // 0x00B8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ADBDPlayer* Player)> Cosmetic_OnPlayerEnterZone;             // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class ADBDPlayer* Player)> Cosmetic_OnPlayerExitZone;              // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTag>                   _tagsPreventingEnteringRange;                      // 0x0108(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                   _tagsToAddToPlayerInZone;                          // 0x0118(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class USphereComponent*                       _playerTracker;                                    // 0x0128(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ADBDPlayer>>      _playersInRange;                                   // 0x0130(0x0010)(Net, ZeroConstructor, RepNotify, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_140[0x18];                                     // 0x0140(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnBeginPlayerOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void Authority_OnEndPlayerOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnRep_PlayersInRange();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayersInZoneTracker">();
	}
	static class UPlayersInZoneTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayersInZoneTracker>();
	}
};
static_assert(alignof(UPlayersInZoneTracker) == 0x000008, "Wrong alignment on UPlayersInZoneTracker");
static_assert(sizeof(UPlayersInZoneTracker) == 0x000158, "Wrong size on UPlayersInZoneTracker");
static_assert(offsetof(UPlayersInZoneTracker, Cosmetic_OnPlayerEnterZone) == 0x0000E8, "Member 'UPlayersInZoneTracker::Cosmetic_OnPlayerEnterZone' has a wrong offset!");
static_assert(offsetof(UPlayersInZoneTracker, Cosmetic_OnPlayerExitZone) == 0x0000F8, "Member 'UPlayersInZoneTracker::Cosmetic_OnPlayerExitZone' has a wrong offset!");
static_assert(offsetof(UPlayersInZoneTracker, _tagsPreventingEnteringRange) == 0x000108, "Member 'UPlayersInZoneTracker::_tagsPreventingEnteringRange' has a wrong offset!");
static_assert(offsetof(UPlayersInZoneTracker, _tagsToAddToPlayerInZone) == 0x000118, "Member 'UPlayersInZoneTracker::_tagsToAddToPlayerInZone' has a wrong offset!");
static_assert(offsetof(UPlayersInZoneTracker, _playerTracker) == 0x000128, "Member 'UPlayersInZoneTracker::_playerTracker' has a wrong offset!");
static_assert(offsetof(UPlayersInZoneTracker, _playersInRange) == 0x000130, "Member 'UPlayersInZoneTracker::_playersInRange' has a wrong offset!");

// Class DBDGameplay.ZoneComponent
// 0x0030 (0x00E8 - 0x00B8)
class UZoneComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x20];                                      // 0x00B8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _currentZoneTag;                                   // 0x00D8(0x000C)(Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_CurrentZone();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZoneComponent">();
	}
	static class UZoneComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZoneComponent>();
	}
};
static_assert(alignof(UZoneComponent) == 0x000008, "Wrong alignment on UZoneComponent");
static_assert(sizeof(UZoneComponent) == 0x0000E8, "Wrong size on UZoneComponent");
static_assert(offsetof(UZoneComponent, _currentZoneTag) == 0x0000D8, "Member 'UZoneComponent::_currentZoneTag' has a wrong offset!");

// Class DBDGameplay.PlayerZoneComponent
// 0x0000 (0x00E8 - 0x00E8)
class UPlayerZoneComponent final : public UZoneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerZoneComponent">();
	}
	static class UPlayerZoneComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerZoneComponent>();
	}
};
static_assert(alignof(UPlayerZoneComponent) == 0x000008, "Wrong alignment on UPlayerZoneComponent");
static_assert(sizeof(UPlayerZoneComponent) == 0x0000E8, "Wrong size on UPlayerZoneComponent");

// Class DBDGameplay.PositionLagCompensationComponent
// 0x0008 (0x00C0 - 0x00B8)
class UPositionLagCompensationComponent final : public UActorComponent
{
public:
	float                                         _maxExtrapolationDurationInSeconds;                // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxInterpolationToServerMoveInSeconds;            // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PositionLagCompensationComponent">();
	}
	static class UPositionLagCompensationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPositionLagCompensationComponent>();
	}
};
static_assert(alignof(UPositionLagCompensationComponent) == 0x000008, "Wrong alignment on UPositionLagCompensationComponent");
static_assert(sizeof(UPositionLagCompensationComponent) == 0x0000C0, "Wrong size on UPositionLagCompensationComponent");
static_assert(offsetof(UPositionLagCompensationComponent, _maxExtrapolationDurationInSeconds) == 0x0000B8, "Member 'UPositionLagCompensationComponent::_maxExtrapolationDurationInSeconds' has a wrong offset!");
static_assert(offsetof(UPositionLagCompensationComponent, _maxInterpolationToServerMoveInSeconds) == 0x0000BC, "Member 'UPositionLagCompensationComponent::_maxInterpolationToServerMoveInSeconds' has a wrong offset!");

// Class DBDGameplay.PowerChargePresentationItemProgressComponent
// 0x0018 (0x00D8 - 0x00C0)
class UPowerChargePresentationItemProgressComponent final : public UPresentationItemProgressComponent
{
public:
	class UPowerChargeComponent*                  _powerChargeComponent;                             // 0x00C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPowerToggleComponent*                  _powerToggleComponent;                             // 0x00C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _chargeReadyThreshold;                             // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PowerChargePresentationItemProgressComponent">();
	}
	static class UPowerChargePresentationItemProgressComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPowerChargePresentationItemProgressComponent>();
	}
};
static_assert(alignof(UPowerChargePresentationItemProgressComponent) == 0x000008, "Wrong alignment on UPowerChargePresentationItemProgressComponent");
static_assert(sizeof(UPowerChargePresentationItemProgressComponent) == 0x0000D8, "Wrong size on UPowerChargePresentationItemProgressComponent");
static_assert(offsetof(UPowerChargePresentationItemProgressComponent, _powerChargeComponent) == 0x0000C0, "Member 'UPowerChargePresentationItemProgressComponent::_powerChargeComponent' has a wrong offset!");
static_assert(offsetof(UPowerChargePresentationItemProgressComponent, _powerToggleComponent) == 0x0000C8, "Member 'UPowerChargePresentationItemProgressComponent::_powerToggleComponent' has a wrong offset!");
static_assert(offsetof(UPowerChargePresentationItemProgressComponent, _chargeReadyThreshold) == 0x0000D0, "Member 'UPowerChargePresentationItemProgressComponent::_chargeReadyThreshold' has a wrong offset!");

// Class DBDGameplay.PowerToggleComponent
// 0x0020 (0x00D8 - 0x00B8)
class UPowerToggleComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isInPower;                                        // 0x00D0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_IsInPower() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PowerToggleComponent">();
	}
	static class UPowerToggleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPowerToggleComponent>();
	}
};
static_assert(alignof(UPowerToggleComponent) == 0x000008, "Wrong alignment on UPowerToggleComponent");
static_assert(sizeof(UPowerToggleComponent) == 0x0000D8, "Wrong size on UPowerToggleComponent");
static_assert(offsetof(UPowerToggleComponent, _isInPower) == 0x0000D0, "Member 'UPowerToggleComponent::_isInPower' has a wrong offset!");

// Class DBDGameplay.RacoonDogComponent
// 0x0180 (0x0238 - 0x00B8)
class URacoonDogComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void()>              _cosmetic_onLookingAtTimerCompleted;               // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              _onHideActor;                                      // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              _onWasActivatedResetDebug;                         // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UDBDSkeletalMeshComponentBudgeted*      _cachedAnimatedSkeletalMesh;                       // 0x00E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0[0x120];                                     // 0x00F0(0x0120)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _wasActivated;                                     // 0x0210(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_211[0x1];                                      // 0x0211(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         _selectedMontageIndex;                             // 0x0212(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_213[0x5];                                      // 0x0213(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRandomAnimationMontage>        _animationMontages;                                // 0x0218(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _activationRange;                                  // 0x0228(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _secondsToLookAtActor;                             // 0x022C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _destroyActorAfterIdleTime;                        // 0x0230(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _precisionAngleDegrees;                            // 0x0234(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnDeleteActorTimerCompleted();
	void Authority_OnIsLookingTowardsTimerFinished();
	void Authority_OnPlayerInRangeChanged(class AActor* playerActor, const bool IsInRange);
	void Authority_OnPlayerIsLookingTowardsChanged(const bool IsLookingTowards, const class ADBDPlayer* Player);
	void Authority_OnPossessedPawnChanged(class APawn* OldPawn, class APawn* NewPawn);
	void DBD_ResetRacoonDogWasActivated();
	void DBD_SetSelectedRacoonDogAnimIndex(const uint8 Index_0);
	void OnAnimationMontageCompleted();
	void OnRep_WasActivated();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RacoonDogComponent">();
	}
	static class URacoonDogComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URacoonDogComponent>();
	}
};
static_assert(alignof(URacoonDogComponent) == 0x000008, "Wrong alignment on URacoonDogComponent");
static_assert(sizeof(URacoonDogComponent) == 0x000238, "Wrong size on URacoonDogComponent");
static_assert(offsetof(URacoonDogComponent, _cosmetic_onLookingAtTimerCompleted) == 0x0000B8, "Member 'URacoonDogComponent::_cosmetic_onLookingAtTimerCompleted' has a wrong offset!");
static_assert(offsetof(URacoonDogComponent, _onHideActor) == 0x0000C8, "Member 'URacoonDogComponent::_onHideActor' has a wrong offset!");
static_assert(offsetof(URacoonDogComponent, _onWasActivatedResetDebug) == 0x0000D8, "Member 'URacoonDogComponent::_onWasActivatedResetDebug' has a wrong offset!");
static_assert(offsetof(URacoonDogComponent, _cachedAnimatedSkeletalMesh) == 0x0000E8, "Member 'URacoonDogComponent::_cachedAnimatedSkeletalMesh' has a wrong offset!");
static_assert(offsetof(URacoonDogComponent, _wasActivated) == 0x000210, "Member 'URacoonDogComponent::_wasActivated' has a wrong offset!");
static_assert(offsetof(URacoonDogComponent, _selectedMontageIndex) == 0x000212, "Member 'URacoonDogComponent::_selectedMontageIndex' has a wrong offset!");
static_assert(offsetof(URacoonDogComponent, _animationMontages) == 0x000218, "Member 'URacoonDogComponent::_animationMontages' has a wrong offset!");
static_assert(offsetof(URacoonDogComponent, _activationRange) == 0x000228, "Member 'URacoonDogComponent::_activationRange' has a wrong offset!");
static_assert(offsetof(URacoonDogComponent, _secondsToLookAtActor) == 0x00022C, "Member 'URacoonDogComponent::_secondsToLookAtActor' has a wrong offset!");
static_assert(offsetof(URacoonDogComponent, _destroyActorAfterIdleTime) == 0x000230, "Member 'URacoonDogComponent::_destroyActorAfterIdleTime' has a wrong offset!");
static_assert(offsetof(URacoonDogComponent, _precisionAngleDegrees) == 0x000234, "Member 'URacoonDogComponent::_precisionAngleDegrees' has a wrong offset!");

// Class DBDGameplay.RandomScriptedEventMapTriggerComponent
// 0x0018 (0x00D0 - 0x00B8)
class URandomScriptedEventMapTriggerComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void()>              _cosmetic_randomEventTriggered;                    // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         _randomChance;                                     // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool Authority_TryTriggerRandomEvent();
	void Multicast_RandomEventTriggered();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RandomScriptedEventMapTriggerComponent">();
	}
	static class URandomScriptedEventMapTriggerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URandomScriptedEventMapTriggerComponent>();
	}
};
static_assert(alignof(URandomScriptedEventMapTriggerComponent) == 0x000008, "Wrong alignment on URandomScriptedEventMapTriggerComponent");
static_assert(sizeof(URandomScriptedEventMapTriggerComponent) == 0x0000D0, "Wrong size on URandomScriptedEventMapTriggerComponent");
static_assert(offsetof(URandomScriptedEventMapTriggerComponent, _cosmetic_randomEventTriggered) == 0x0000B8, "Member 'URandomScriptedEventMapTriggerComponent::_cosmetic_randomEventTriggered' has a wrong offset!");
static_assert(offsetof(URandomScriptedEventMapTriggerComponent, _randomChance) == 0x0000C8, "Member 'URandomScriptedEventMapTriggerComponent::_randomChance' has a wrong offset!");

// Class DBDGameplay.RangedExplosiveEffectHandlerComponent
// 0x0070 (0x0128 - 0x00B8)
class URangedExplosiveEffectHandlerComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(const struct FRangedExplosiveEffectData& effectData)> OnRangedExplosiveInRangeBegin; // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FRangedExplosiveEffectData& effectData)> OnRangedExplosiveInRangeEnd; // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSet<class ARangedExplosive*>                 _inRangeRangedExplosives;                          // 0x00D8(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	void OnRangedExplosiveDestroyed(class AActor* DestroyedActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RangedExplosiveEffectHandlerComponent">();
	}
	static class URangedExplosiveEffectHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URangedExplosiveEffectHandlerComponent>();
	}
};
static_assert(alignof(URangedExplosiveEffectHandlerComponent) == 0x000008, "Wrong alignment on URangedExplosiveEffectHandlerComponent");
static_assert(sizeof(URangedExplosiveEffectHandlerComponent) == 0x000128, "Wrong size on URangedExplosiveEffectHandlerComponent");
static_assert(offsetof(URangedExplosiveEffectHandlerComponent, OnRangedExplosiveInRangeBegin) == 0x0000B8, "Member 'URangedExplosiveEffectHandlerComponent::OnRangedExplosiveInRangeBegin' has a wrong offset!");
static_assert(offsetof(URangedExplosiveEffectHandlerComponent, OnRangedExplosiveInRangeEnd) == 0x0000C8, "Member 'URangedExplosiveEffectHandlerComponent::OnRangedExplosiveInRangeEnd' has a wrong offset!");
static_assert(offsetof(URangedExplosiveEffectHandlerComponent, _inRangeRangedExplosives) == 0x0000D8, "Member 'URangedExplosiveEffectHandlerComponent::_inRangeRangedExplosives' has a wrong offset!");

// Class DBDGameplay.RangeToActorsTrackerComponent
// 0x0010 (0x00C8 - 0x00B8)
class URangeToActorsTrackerComponent final : public UActorComponent
{
public:
	TArray<class URangeToActorsTrackerStrategy*>  _rangeTrackers;                                    // 0x00B8(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, NoClear, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RangeToActorsTrackerComponent">();
	}
	static class URangeToActorsTrackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URangeToActorsTrackerComponent>();
	}
};
static_assert(alignof(URangeToActorsTrackerComponent) == 0x000008, "Wrong alignment on URangeToActorsTrackerComponent");
static_assert(sizeof(URangeToActorsTrackerComponent) == 0x0000C8, "Wrong size on URangeToActorsTrackerComponent");
static_assert(offsetof(URangeToActorsTrackerComponent, _rangeTrackers) == 0x0000B8, "Member 'URangeToActorsTrackerComponent::_rangeTrackers' has a wrong offset!");

// Class DBDGameplay.RangeToActorsTrackerDefaultStrategy
// 0x0008 (0x0078 - 0x0070)
class URangeToActorsTrackerDefaultStrategy final : public URangeToActorsTrackerStrategy
{
public:
	TSubclassOf<class AActor>                     _actorClass;                                       // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RangeToActorsTrackerDefaultStrategy">();
	}
	static class URangeToActorsTrackerDefaultStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<URangeToActorsTrackerDefaultStrategy>();
	}
};
static_assert(alignof(URangeToActorsTrackerDefaultStrategy) == 0x000008, "Wrong alignment on URangeToActorsTrackerDefaultStrategy");
static_assert(sizeof(URangeToActorsTrackerDefaultStrategy) == 0x000078, "Wrong size on URangeToActorsTrackerDefaultStrategy");
static_assert(offsetof(URangeToActorsTrackerDefaultStrategy, _actorClass) == 0x000070, "Member 'URangeToActorsTrackerDefaultStrategy::_actorClass' has a wrong offset!");

// Class DBDGameplay.RespawnableComponent
// 0x01F8 (0x02B0 - 0x00B8)
class URespawnableComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x30];                                      // 0x00B8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              Cosmetic_OnRespawn;                                // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              Cosmetic_OnDespawn;                                // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              Cosmetic_OnFirstSpawn;                             // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnTeleportSucceded;                                // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	bool                                          _hasStartedRespawning;                             // 0x0128(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasExceededMinRespawnTime;                        // 0x0129(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGameplayElementType                          _gameplayElementSpawnType;                         // 0x012A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETileSpawnPointType                           _tileSpawnType;                                    // 0x012B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        _spawnElementInUse;                                // 0x0130(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _usesTimers;                                       // 0x0138(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _respawnFrequencyMin;                              // 0x0140(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _respawnFrequencyMax;                              // 0x0168(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _disappearDuration;                                // 0x0190(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minTimeBetweenRespawns;                           // 0x0194(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _spawnHeightOffset;                                // 0x0198(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_19C[0x34];                                     // 0x019C(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _usesGameplayElementSpawner;                       // 0x01D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D1[0x67];                                     // 0x01D1(0x0067)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _actorLocation;                                    // 0x0238(0x0018)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_250[0x4];                                      // 0x0250(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _collisionCapsuleHalfHeight;                       // 0x0254(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _collisionCapsuleRadius;                           // 0x0258(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDebugTimerLogComponent*                _debugLogTimer;                                    // 0x0260(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _onlyLimitDistanceBetweenSameActorType;            // 0x0268(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_269[0x7];                                      // 0x0269(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _minDistanceFromActivatedSpawnElements;            // 0x0270(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          _allowSpawnEvenWithNonBlockingOverlaps;            // 0x0298(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _canUseFallbackSpawnElement;                       // 0x0299(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29A[0x6];                                      // 0x029A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECollisionChannel>                     _collisionChannelsToCheckOnRespawn;                // 0x02A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void Authority_OnMinRespawnTimerDone();
	void Authority_OnTimerDone();
	bool Authority_TryTeleport();
	void OnDespawnCosmeticsComplete();
	void OnLevelReadyToPlay();
	void OnRep_OnLocationChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RespawnableComponent">();
	}
	static class URespawnableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URespawnableComponent>();
	}
};
static_assert(alignof(URespawnableComponent) == 0x000008, "Wrong alignment on URespawnableComponent");
static_assert(sizeof(URespawnableComponent) == 0x0002B0, "Wrong size on URespawnableComponent");
static_assert(offsetof(URespawnableComponent, Cosmetic_OnRespawn) == 0x0000E8, "Member 'URespawnableComponent::Cosmetic_OnRespawn' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, Cosmetic_OnDespawn) == 0x0000F8, "Member 'URespawnableComponent::Cosmetic_OnDespawn' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, Cosmetic_OnFirstSpawn) == 0x000108, "Member 'URespawnableComponent::Cosmetic_OnFirstSpawn' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, OnTeleportSucceded) == 0x000118, "Member 'URespawnableComponent::OnTeleportSucceded' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _hasStartedRespawning) == 0x000128, "Member 'URespawnableComponent::_hasStartedRespawning' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _hasExceededMinRespawnTime) == 0x000129, "Member 'URespawnableComponent::_hasExceededMinRespawnTime' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _gameplayElementSpawnType) == 0x00012A, "Member 'URespawnableComponent::_gameplayElementSpawnType' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _tileSpawnType) == 0x00012B, "Member 'URespawnableComponent::_tileSpawnType' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _spawnElementInUse) == 0x000130, "Member 'URespawnableComponent::_spawnElementInUse' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _usesTimers) == 0x000138, "Member 'URespawnableComponent::_usesTimers' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _respawnFrequencyMin) == 0x000140, "Member 'URespawnableComponent::_respawnFrequencyMin' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _respawnFrequencyMax) == 0x000168, "Member 'URespawnableComponent::_respawnFrequencyMax' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _disappearDuration) == 0x000190, "Member 'URespawnableComponent::_disappearDuration' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _minTimeBetweenRespawns) == 0x000194, "Member 'URespawnableComponent::_minTimeBetweenRespawns' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _spawnHeightOffset) == 0x000198, "Member 'URespawnableComponent::_spawnHeightOffset' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _usesGameplayElementSpawner) == 0x0001D0, "Member 'URespawnableComponent::_usesGameplayElementSpawner' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _actorLocation) == 0x000238, "Member 'URespawnableComponent::_actorLocation' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _collisionCapsuleHalfHeight) == 0x000254, "Member 'URespawnableComponent::_collisionCapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _collisionCapsuleRadius) == 0x000258, "Member 'URespawnableComponent::_collisionCapsuleRadius' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _debugLogTimer) == 0x000260, "Member 'URespawnableComponent::_debugLogTimer' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _onlyLimitDistanceBetweenSameActorType) == 0x000268, "Member 'URespawnableComponent::_onlyLimitDistanceBetweenSameActorType' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _minDistanceFromActivatedSpawnElements) == 0x000270, "Member 'URespawnableComponent::_minDistanceFromActivatedSpawnElements' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _allowSpawnEvenWithNonBlockingOverlaps) == 0x000298, "Member 'URespawnableComponent::_allowSpawnEvenWithNonBlockingOverlaps' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _canUseFallbackSpawnElement) == 0x000299, "Member 'URespawnableComponent::_canUseFallbackSpawnElement' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _collisionChannelsToCheckOnRespawn) == 0x0002A0, "Member 'URespawnableComponent::_collisionChannelsToCheckOnRespawn' has a wrong offset!");

// Class DBDGameplay.SceneComponentPointProvider
// 0x0038 (0x0068 - 0x0030)
class USceneComponentPointProvider final : public UPointsProvider
{
public:
	struct FComponentReference                    _sceneReference;                                   // 0x0030(0x0030)(Edit, NativeAccessSpecifierPrivate)
	class USceneComponent*                        _sceneComponent;                                   // 0x0060(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneComponentPointProvider">();
	}
	static class USceneComponentPointProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneComponentPointProvider>();
	}
};
static_assert(alignof(USceneComponentPointProvider) == 0x000008, "Wrong alignment on USceneComponentPointProvider");
static_assert(sizeof(USceneComponentPointProvider) == 0x000068, "Wrong size on USceneComponentPointProvider");
static_assert(offsetof(USceneComponentPointProvider, _sceneReference) == 0x000030, "Member 'USceneComponentPointProvider::_sceneReference' has a wrong offset!");
static_assert(offsetof(USceneComponentPointProvider, _sceneComponent) == 0x000060, "Member 'USceneComponentPointProvider::_sceneComponent' has a wrong offset!");

// Class DBDGameplay.ScreamFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UScreamFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ScreamRevealSurvivor(class ASurvivor* Survivor, float screamRevealDuration, bool SpawnBubbleIndicator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreamFunctionLibrary">();
	}
	static class UScreamFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreamFunctionLibrary>();
	}
};
static_assert(alignof(UScreamFunctionLibrary) == 0x000008, "Wrong alignment on UScreamFunctionLibrary");
static_assert(sizeof(UScreamFunctionLibrary) == 0x000030, "Wrong size on UScreamFunctionLibrary");

// Class DBDGameplay.SightRevealableComponent
// 0x0228 (0x02E0 - 0x00B8)
class USightRevealableComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x48];                                      // 0x00B8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _ignoredTags;                                      // 0x0100(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _ignoredComponentTags;                             // 0x0120(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _revealTimeBase;                                   // 0x0130(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _revealRate;                                       // 0x01B0(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _revealRegressionRate;                             // 0x0230(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0[0x30];                                     // 0x02B0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool Authority_IsBeingRevealed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SightRevealableComponent">();
	}
	static class USightRevealableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USightRevealableComponent>();
	}
};
static_assert(alignof(USightRevealableComponent) == 0x000008, "Wrong alignment on USightRevealableComponent");
static_assert(sizeof(USightRevealableComponent) == 0x0002E0, "Wrong size on USightRevealableComponent");
static_assert(offsetof(USightRevealableComponent, _ignoredTags) == 0x000100, "Member 'USightRevealableComponent::_ignoredTags' has a wrong offset!");
static_assert(offsetof(USightRevealableComponent, _ignoredComponentTags) == 0x000120, "Member 'USightRevealableComponent::_ignoredComponentTags' has a wrong offset!");
static_assert(offsetof(USightRevealableComponent, _revealTimeBase) == 0x000130, "Member 'USightRevealableComponent::_revealTimeBase' has a wrong offset!");
static_assert(offsetof(USightRevealableComponent, _revealRate) == 0x0001B0, "Member 'USightRevealableComponent::_revealRate' has a wrong offset!");
static_assert(offsetof(USightRevealableComponent, _revealRegressionRate) == 0x000230, "Member 'USightRevealableComponent::_revealRegressionRate' has a wrong offset!");

// Class DBDGameplay.TerrorRadiusEmitterComponent
// 0x0110 (0x03E0 - 0x02D0)
class UTerrorRadiusEmitterComponent : public USceneComponent
{
public:
	uint8                                         Pad_2D0[0x30];                                     // 0x02D0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _simulatedFixedDistance;                           // 0x0300(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _imitatesAudioOnly;                                // 0x0304(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _active;                                           // 0x0305(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isFakeTerrorRadius;                               // 0x0306(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_307[0x1];                                      // 0x0307(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _radius;                                           // 0x0308(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TWeakObjectPtr<class UTerrorRadiusReceiverComponent>, bool> _receiversInTerrorRadiusMap;    // 0x0310(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<TWeakObjectPtr<class UTerrorRadiusReceiverComponent>, bool> _receiversPhysicallyInRadiusRangeMap; // 0x0360(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B0[0x30];                                     // 0x03B0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetEmitterActive(bool Active);
	void SetImitatesAudioOnly(bool imitatesAudioOnly);
	void SetIsFakeTerrorRadius(bool Value);
	void SetSimulatedFixedDistance(float Distance);
	void SetTerrorRadius(float Radius);

	bool GetImitatesAudioOnly() const;
	bool GetIsActive() const;
	float GetRadius() const;
	float GetSimulatedFixedDistance() const;
	bool IsInTerrorRadius(class UTerrorRadiusReceiverComponent* receiver) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TerrorRadiusEmitterComponent">();
	}
	static class UTerrorRadiusEmitterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTerrorRadiusEmitterComponent>();
	}
};
static_assert(alignof(UTerrorRadiusEmitterComponent) == 0x000010, "Wrong alignment on UTerrorRadiusEmitterComponent");
static_assert(sizeof(UTerrorRadiusEmitterComponent) == 0x0003E0, "Wrong size on UTerrorRadiusEmitterComponent");
static_assert(offsetof(UTerrorRadiusEmitterComponent, _simulatedFixedDistance) == 0x000300, "Member 'UTerrorRadiusEmitterComponent::_simulatedFixedDistance' has a wrong offset!");
static_assert(offsetof(UTerrorRadiusEmitterComponent, _imitatesAudioOnly) == 0x000304, "Member 'UTerrorRadiusEmitterComponent::_imitatesAudioOnly' has a wrong offset!");
static_assert(offsetof(UTerrorRadiusEmitterComponent, _active) == 0x000305, "Member 'UTerrorRadiusEmitterComponent::_active' has a wrong offset!");
static_assert(offsetof(UTerrorRadiusEmitterComponent, _isFakeTerrorRadius) == 0x000306, "Member 'UTerrorRadiusEmitterComponent::_isFakeTerrorRadius' has a wrong offset!");
static_assert(offsetof(UTerrorRadiusEmitterComponent, _radius) == 0x000308, "Member 'UTerrorRadiusEmitterComponent::_radius' has a wrong offset!");
static_assert(offsetof(UTerrorRadiusEmitterComponent, _receiversInTerrorRadiusMap) == 0x000310, "Member 'UTerrorRadiusEmitterComponent::_receiversInTerrorRadiusMap' has a wrong offset!");
static_assert(offsetof(UTerrorRadiusEmitterComponent, _receiversPhysicallyInRadiusRangeMap) == 0x000360, "Member 'UTerrorRadiusEmitterComponent::_receiversPhysicallyInRadiusRangeMap' has a wrong offset!");

// Class DBDGameplay.SlasherTerrorRadiusEmitterComponent
// 0x0090 (0x0470 - 0x03E0)
class USlasherTerrorRadiusEmitterComponent final : public UTerrorRadiusEmitterComponent
{
public:
	uint8                                         Pad_3E0[0x90];                                     // 0x03E0(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBaseTerrorRadius(float baseTerrorRadius, const bool progressive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlasherTerrorRadiusEmitterComponent">();
	}
	static class USlasherTerrorRadiusEmitterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlasherTerrorRadiusEmitterComponent>();
	}
};
static_assert(alignof(USlasherTerrorRadiusEmitterComponent) == 0x000010, "Wrong alignment on USlasherTerrorRadiusEmitterComponent");
static_assert(sizeof(USlasherTerrorRadiusEmitterComponent) == 0x000470, "Wrong size on USlasherTerrorRadiusEmitterComponent");

// Class DBDGameplay.SmokeBomb
// 0x0230 (0x0650 - 0x0420)
class ASmokeBomb final : public AFirecracker
{
public:
	class UItemModifier*                          _itemModifier;                                     // 0x0420(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _smokeCloudAreaRadius;                             // 0x0428(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _secondsToExpand;                                  // 0x0450(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _secondsAtMaxSize;                                 // 0x0478(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _secondsToDisappear;                               // 0x04A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _useSmokeBombScoreEvent;                           // 0x04C8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOfferingEffectType                           _offeringDoublingScore;                            // 0x04D4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D5[0x3];                                      // 0x04D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _scratchMarkPreventionAreaMinRadius;               // 0x04D8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _scratchMarkPreventionAreaMaxRadius;               // 0x0500(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _scratchMarkPreventionStatusEffect;                // 0x0528(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FCollisionProfileName                  _playerDetectorCollisionProfileName;               // 0x0530(0x000C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_53C[0x4];                                      // 0x053C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ASmokeBombCosmeticHelperActor> _smokePlayerCosmeticHelperActorClass;           // 0x0540(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USmokeBombCosmeticHelperManager*        _smokeCosmeticManager;                             // 0x0548(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_550[0x100];                                    // 0x0550(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSmokeAreaStartedToShrink();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmokeBomb">();
	}
	static class ASmokeBomb* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASmokeBomb>();
	}
};
static_assert(alignof(ASmokeBomb) == 0x000008, "Wrong alignment on ASmokeBomb");
static_assert(sizeof(ASmokeBomb) == 0x000650, "Wrong size on ASmokeBomb");
static_assert(offsetof(ASmokeBomb, _itemModifier) == 0x000420, "Member 'ASmokeBomb::_itemModifier' has a wrong offset!");
static_assert(offsetof(ASmokeBomb, _smokeCloudAreaRadius) == 0x000428, "Member 'ASmokeBomb::_smokeCloudAreaRadius' has a wrong offset!");
static_assert(offsetof(ASmokeBomb, _secondsToExpand) == 0x000450, "Member 'ASmokeBomb::_secondsToExpand' has a wrong offset!");
static_assert(offsetof(ASmokeBomb, _secondsAtMaxSize) == 0x000478, "Member 'ASmokeBomb::_secondsAtMaxSize' has a wrong offset!");
static_assert(offsetof(ASmokeBomb, _secondsToDisappear) == 0x0004A0, "Member 'ASmokeBomb::_secondsToDisappear' has a wrong offset!");
static_assert(offsetof(ASmokeBomb, _useSmokeBombScoreEvent) == 0x0004C8, "Member 'ASmokeBomb::_useSmokeBombScoreEvent' has a wrong offset!");
static_assert(offsetof(ASmokeBomb, _offeringDoublingScore) == 0x0004D4, "Member 'ASmokeBomb::_offeringDoublingScore' has a wrong offset!");
static_assert(offsetof(ASmokeBomb, _scratchMarkPreventionAreaMinRadius) == 0x0004D8, "Member 'ASmokeBomb::_scratchMarkPreventionAreaMinRadius' has a wrong offset!");
static_assert(offsetof(ASmokeBomb, _scratchMarkPreventionAreaMaxRadius) == 0x000500, "Member 'ASmokeBomb::_scratchMarkPreventionAreaMaxRadius' has a wrong offset!");
static_assert(offsetof(ASmokeBomb, _scratchMarkPreventionStatusEffect) == 0x000528, "Member 'ASmokeBomb::_scratchMarkPreventionStatusEffect' has a wrong offset!");
static_assert(offsetof(ASmokeBomb, _playerDetectorCollisionProfileName) == 0x000530, "Member 'ASmokeBomb::_playerDetectorCollisionProfileName' has a wrong offset!");
static_assert(offsetof(ASmokeBomb, _smokePlayerCosmeticHelperActorClass) == 0x000540, "Member 'ASmokeBomb::_smokePlayerCosmeticHelperActorClass' has a wrong offset!");
static_assert(offsetof(ASmokeBomb, _smokeCosmeticManager) == 0x000548, "Member 'ASmokeBomb::_smokeCosmeticManager' has a wrong offset!");

// Class DBDGameplay.SmokeBombCosmeticHelperActor
// 0x0060 (0x0300 - 0x02A0)
class ASmokeBombCosmeticHelperActor final : public AActor
{
public:
	uint8                                         Pad_2A0[0x60];                                     // 0x02A0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnSmokeEnded();
	void Cosmetic_OnSmokeStarted();
	void Cosmetic_UpdateVisibility(bool IsVisible);
	void OnFirstPersonChanged(bool isFirstPerson);

	class ADBDPlayer* GetOwningPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmokeBombCosmeticHelperActor">();
	}
	static class ASmokeBombCosmeticHelperActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASmokeBombCosmeticHelperActor>();
	}
};
static_assert(alignof(ASmokeBombCosmeticHelperActor) == 0x000008, "Wrong alignment on ASmokeBombCosmeticHelperActor");
static_assert(sizeof(ASmokeBombCosmeticHelperActor) == 0x000300, "Wrong size on ASmokeBombCosmeticHelperActor");

// Class DBDGameplay.SmokeBombCosmeticHelperManager
// 0x0058 (0x0110 - 0x00B8)
class USmokeBombCosmeticHelperManager final : public UActorComponent
{
public:
	class ASmokeBombCosmeticHelperActor*          _playerCosmeticHelperActor;                        // 0x00B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x50];                                      // 0x00C0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLocallyObservedChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmokeBombCosmeticHelperManager">();
	}
	static class USmokeBombCosmeticHelperManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USmokeBombCosmeticHelperManager>();
	}
};
static_assert(alignof(USmokeBombCosmeticHelperManager) == 0x000008, "Wrong alignment on USmokeBombCosmeticHelperManager");
static_assert(sizeof(USmokeBombCosmeticHelperManager) == 0x000110, "Wrong size on USmokeBombCosmeticHelperManager");
static_assert(offsetof(USmokeBombCosmeticHelperManager, _playerCosmeticHelperActor) == 0x0000B8, "Member 'USmokeBombCosmeticHelperManager::_playerCosmeticHelperActor' has a wrong offset!");

// Class DBDGameplay.StaticMeshBlockFeedback
// 0x0010 (0x02D0 - 0x02C0)
class AStaticMeshBlockFeedback final : public AFadingBlockFeedback
{
public:
	class UStaticMeshComponent*                   _mesh;                                             // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialHelper*                        _materialHelper;                                   // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticMeshBlockFeedback">();
	}
	static class AStaticMeshBlockFeedback* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStaticMeshBlockFeedback>();
	}
};
static_assert(alignof(AStaticMeshBlockFeedback) == 0x000008, "Wrong alignment on AStaticMeshBlockFeedback");
static_assert(sizeof(AStaticMeshBlockFeedback) == 0x0002D0, "Wrong size on AStaticMeshBlockFeedback");
static_assert(offsetof(AStaticMeshBlockFeedback, _mesh) == 0x0002C0, "Member 'AStaticMeshBlockFeedback::_mesh' has a wrong offset!");
static_assert(offsetof(AStaticMeshBlockFeedback, _materialHelper) == 0x0002C8, "Member 'AStaticMeshBlockFeedback::_materialHelper' has a wrong offset!");

// Class DBDGameplay.SteamPipe
// 0x00E8 (0x0388 - 0x02A0)
class ASteamPipe final : public AActor
{
public:
	uint8                                         Pad_2A0[0x18];                                     // 0x02A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          _overlapVolume;                                    // 0x02B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESteamPipeState                               _currentSteamPipeState;                            // 0x02C0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class USteamPipeEffectComponent>> _overlappingPlayerComponents;            // 0x02C8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D8[0x30];                                     // 0x02D8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _debugResetTimer;                                  // 0x0308(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _warningStateTime;                                 // 0x0310(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _activeTime;                                       // 0x0338(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _warningStateTimeNoCharge;                         // 0x0360(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void Authority_OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void Authority_OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void Cosmetic_OnSteamPipeStateChanged(ESteamPipeState newState);
	void OnRep_SteamPipeState();

	ESteamPipeState GetCurrentSteamPipeState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamPipe">();
	}
	static class ASteamPipe* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASteamPipe>();
	}
};
static_assert(alignof(ASteamPipe) == 0x000008, "Wrong alignment on ASteamPipe");
static_assert(sizeof(ASteamPipe) == 0x000388, "Wrong size on ASteamPipe");
static_assert(offsetof(ASteamPipe, _overlapVolume) == 0x0002B8, "Member 'ASteamPipe::_overlapVolume' has a wrong offset!");
static_assert(offsetof(ASteamPipe, _currentSteamPipeState) == 0x0002C0, "Member 'ASteamPipe::_currentSteamPipeState' has a wrong offset!");
static_assert(offsetof(ASteamPipe, _overlappingPlayerComponents) == 0x0002C8, "Member 'ASteamPipe::_overlappingPlayerComponents' has a wrong offset!");
static_assert(offsetof(ASteamPipe, _debugResetTimer) == 0x000308, "Member 'ASteamPipe::_debugResetTimer' has a wrong offset!");
static_assert(offsetof(ASteamPipe, _warningStateTime) == 0x000310, "Member 'ASteamPipe::_warningStateTime' has a wrong offset!");
static_assert(offsetof(ASteamPipe, _activeTime) == 0x000338, "Member 'ASteamPipe::_activeTime' has a wrong offset!");
static_assert(offsetof(ASteamPipe, _warningStateTimeNoCharge) == 0x000360, "Member 'ASteamPipe::_warningStateTimeNoCharge' has a wrong offset!");

// Class DBDGameplay.SteamPipeManagerComponent
// 0x00B8 (0x0170 - 0x00B8)
class USteamPipeManagerComponent final : public UActorComponent
{
public:
	TSubclassOf<class USteamPipeEffectComponent>  _steamPipeEffectComponentClass;                    // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UChargeableComponent>       _chargeableComponentClass;                         // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _resetSwitchCooldownTime;                          // 0x00C8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _sharedChargeableComponent;                        // 0x00F0(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ASteamPipe>>      _steamPipes;                                       // 0x00F8(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ASteamPipeResetSwitch>> _steamPipeResetSwitches;                     // 0x0108(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x40];                                     // 0x0118(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class ADBDPlayer>>      _interactingPlayersArray;                          // 0x0158(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_168[0x8];                                      // 0x0168(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnCharacterAdded(class ADBDPlayer* Character);
	void Authority_OnResetInteractionComplete(bool COMPLETED, const TArray<class AActor*>& instigatorsForCompletion);
	void Authority_OnSteamPipeStateChanged(const class ASteamPipe* SteamPipe, const ESteamPipeState newState);
	void Authority_OnSwitchCooldownComplete();
	void Authority_UpdateCanUseResetSwitch();
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamPipeManagerComponent">();
	}
	static class USteamPipeManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamPipeManagerComponent>();
	}
};
static_assert(alignof(USteamPipeManagerComponent) == 0x000008, "Wrong alignment on USteamPipeManagerComponent");
static_assert(sizeof(USteamPipeManagerComponent) == 0x000170, "Wrong size on USteamPipeManagerComponent");
static_assert(offsetof(USteamPipeManagerComponent, _steamPipeEffectComponentClass) == 0x0000B8, "Member 'USteamPipeManagerComponent::_steamPipeEffectComponentClass' has a wrong offset!");
static_assert(offsetof(USteamPipeManagerComponent, _chargeableComponentClass) == 0x0000C0, "Member 'USteamPipeManagerComponent::_chargeableComponentClass' has a wrong offset!");
static_assert(offsetof(USteamPipeManagerComponent, _resetSwitchCooldownTime) == 0x0000C8, "Member 'USteamPipeManagerComponent::_resetSwitchCooldownTime' has a wrong offset!");
static_assert(offsetof(USteamPipeManagerComponent, _sharedChargeableComponent) == 0x0000F0, "Member 'USteamPipeManagerComponent::_sharedChargeableComponent' has a wrong offset!");
static_assert(offsetof(USteamPipeManagerComponent, _steamPipes) == 0x0000F8, "Member 'USteamPipeManagerComponent::_steamPipes' has a wrong offset!");
static_assert(offsetof(USteamPipeManagerComponent, _steamPipeResetSwitches) == 0x000108, "Member 'USteamPipeManagerComponent::_steamPipeResetSwitches' has a wrong offset!");
static_assert(offsetof(USteamPipeManagerComponent, _interactingPlayersArray) == 0x000158, "Member 'USteamPipeManagerComponent::_interactingPlayersArray' has a wrong offset!");

// Class DBDGameplay.SteamPipeResetSwitch
// 0x0070 (0x0418 - 0x03A8)
class ASteamPipeResetSwitch final : public AInteractable
{
public:
	class UDBDSkeletalMeshComponentBudgeted*      _skeletalMeshComponent;                            // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _resetSoundDistance;                               // 0x03B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class USteamPipeManagerComponent> _managerComponentClass;                            // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _sharedChargeableComponent;                        // 0x03E0(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E8[0x14];                                     // 0x03E8(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isOnCooldown;                                     // 0x03FC(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3FD[0x3];                                      // 0x03FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _numberOfDisabledSteamPipes;                       // 0x0400(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _totalSteamPipesInLevel;                           // 0x0404(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class USteamPipeManagerComponent> _steamPipeManagerComponent;                     // 0x0408(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_410[0x4];                                      // 0x0410(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _canUseResetSwitch;                                // 0x0414(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_415[0x3];                                      // 0x0415(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_NumberOfDisabledSteamPipesChanged(const int32 numberOfDisabledSteamPipes);
	void Cosmetic_OnCooldownDone();
	void Cosmetic_OnSwitchTriggered(float cooldownTime);
	void Cosmetic_OnTotalSteamPipesInLevelChanged(const int32 totalSteamPipesInLevel);
	void OnRep_IsOnCooldown();
	void OnRep_NumberOfDisabledSteamPipes();
	void OnRep_SharedChargeableComponent();

	int32 GetTotalSteamPipesInLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamPipeResetSwitch">();
	}
	static class ASteamPipeResetSwitch* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASteamPipeResetSwitch>();
	}
};
static_assert(alignof(ASteamPipeResetSwitch) == 0x000008, "Wrong alignment on ASteamPipeResetSwitch");
static_assert(sizeof(ASteamPipeResetSwitch) == 0x000418, "Wrong size on ASteamPipeResetSwitch");
static_assert(offsetof(ASteamPipeResetSwitch, _skeletalMeshComponent) == 0x0003A8, "Member 'ASteamPipeResetSwitch::_skeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(ASteamPipeResetSwitch, _resetSoundDistance) == 0x0003B0, "Member 'ASteamPipeResetSwitch::_resetSoundDistance' has a wrong offset!");
static_assert(offsetof(ASteamPipeResetSwitch, _managerComponentClass) == 0x0003D8, "Member 'ASteamPipeResetSwitch::_managerComponentClass' has a wrong offset!");
static_assert(offsetof(ASteamPipeResetSwitch, _sharedChargeableComponent) == 0x0003E0, "Member 'ASteamPipeResetSwitch::_sharedChargeableComponent' has a wrong offset!");
static_assert(offsetof(ASteamPipeResetSwitch, _isOnCooldown) == 0x0003FC, "Member 'ASteamPipeResetSwitch::_isOnCooldown' has a wrong offset!");
static_assert(offsetof(ASteamPipeResetSwitch, _numberOfDisabledSteamPipes) == 0x000400, "Member 'ASteamPipeResetSwitch::_numberOfDisabledSteamPipes' has a wrong offset!");
static_assert(offsetof(ASteamPipeResetSwitch, _totalSteamPipesInLevel) == 0x000404, "Member 'ASteamPipeResetSwitch::_totalSteamPipesInLevel' has a wrong offset!");
static_assert(offsetof(ASteamPipeResetSwitch, _steamPipeManagerComponent) == 0x000408, "Member 'ASteamPipeResetSwitch::_steamPipeManagerComponent' has a wrong offset!");
static_assert(offsetof(ASteamPipeResetSwitch, _canUseResetSwitch) == 0x000414, "Member 'ASteamPipeResetSwitch::_canUseResetSwitch' has a wrong offset!");

// Class DBDGameplay.SteamPipeResetSwitchInteraction
// 0x0050 (0x0910 - 0x08C0)
class USteamPipeResetSwitchInteraction final : public UChargeableInteractionDefinition
{
public:
	uint8                                         Pad_8C0[0x50];                                     // 0x08C0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamPipeResetSwitchInteraction">();
	}
	static class USteamPipeResetSwitchInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamPipeResetSwitchInteraction>();
	}
};
static_assert(alignof(USteamPipeResetSwitchInteraction) == 0x000010, "Wrong alignment on USteamPipeResetSwitchInteraction");
static_assert(sizeof(USteamPipeResetSwitchInteraction) == 0x000910, "Wrong size on USteamPipeResetSwitchInteraction");

// Class DBDGameplay.StruggleComponent
// 0x00D0 (0x0188 - 0x00B8)
class UStruggleComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x54];                                      // 0x00B8(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _skillCheckCount;                                  // 0x010C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x78];                                     // 0x0110(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_TryActivateSkillCheck();
	void OnSkillCheckEnd(bool hadInput, bool Success, bool Bonus, ESkillCheckCustomType Type, class ADBDPlayer* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StruggleComponent">();
	}
	static class UStruggleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStruggleComponent>();
	}
};
static_assert(alignof(UStruggleComponent) == 0x000008, "Wrong alignment on UStruggleComponent");
static_assert(sizeof(UStruggleComponent) == 0x000188, "Wrong size on UStruggleComponent");
static_assert(offsetof(UStruggleComponent, _skillCheckCount) == 0x00010C, "Member 'UStruggleComponent::_skillCheckCount' has a wrong offset!");

// Class DBDGameplay.SurvivorAimStanceCameraDirectionProvider
// 0x0000 (0x0030 - 0x0030)
class USurvivorAimStanceCameraDirectionProvider final : public UAimDirectionProvider
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorAimStanceCameraDirectionProvider">();
	}
	static class USurvivorAimStanceCameraDirectionProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorAimStanceCameraDirectionProvider>();
	}
};
static_assert(alignof(USurvivorAimStanceCameraDirectionProvider) == 0x000008, "Wrong alignment on USurvivorAimStanceCameraDirectionProvider");
static_assert(sizeof(USurvivorAimStanceCameraDirectionProvider) == 0x000030, "Wrong size on USurvivorAimStanceCameraDirectionProvider");

// Class DBDGameplay.SurvivorAimStateComponent
// 0x0080 (0x0138 - 0x00B8)
class USurvivorAimStateComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ACollectable*                           _aimableCollectable;                               // 0x00D0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x60];                                      // 0x00D8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorAimStateComponent">();
	}
	static class USurvivorAimStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorAimStateComponent>();
	}
};
static_assert(alignof(USurvivorAimStateComponent) == 0x000008, "Wrong alignment on USurvivorAimStateComponent");
static_assert(sizeof(USurvivorAimStateComponent) == 0x000138, "Wrong size on USurvivorAimStateComponent");
static_assert(offsetof(USurvivorAimStateComponent, _aimableCollectable) == 0x0000D0, "Member 'USurvivorAimStateComponent::_aimableCollectable' has a wrong offset!");

// Class DBDGameplay.SurvivorBoundOptimizer
// 0x0020 (0x00D8 - 0x00B8)
class USurvivorBoundOptimizer final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x20];                                      // 0x00B8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorBoundOptimizer">();
	}
	static class USurvivorBoundOptimizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorBoundOptimizer>();
	}
};
static_assert(alignof(USurvivorBoundOptimizer) == 0x000008, "Wrong alignment on USurvivorBoundOptimizer");
static_assert(sizeof(USurvivorBoundOptimizer) == 0x0000D8, "Wrong size on USurvivorBoundOptimizer");

// Class DBDGameplay.SurvivorFootstepPerceptionComponent
// 0x0000 (0x0110 - 0x0110)
class USurvivorFootstepPerceptionComponent final : public UPlayerFootstepPerceptionComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorFootstepPerceptionComponent">();
	}
	static class USurvivorFootstepPerceptionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorFootstepPerceptionComponent>();
	}
};
static_assert(alignof(USurvivorFootstepPerceptionComponent) == 0x000008, "Wrong alignment on USurvivorFootstepPerceptionComponent");
static_assert(sizeof(USurvivorFootstepPerceptionComponent) == 0x000110, "Wrong size on USurvivorFootstepPerceptionComponent");

// Class DBDGameplay.TerrorRadiusAudioFeedbackComponent
// 0x0048 (0x0100 - 0x00B8)
class UTerrorRadiusAudioFeedbackComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x48];                                      // 0x00B8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TerrorRadiusAudioFeedbackComponent">();
	}
	static class UTerrorRadiusAudioFeedbackComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTerrorRadiusAudioFeedbackComponent>();
	}
};
static_assert(alignof(UTerrorRadiusAudioFeedbackComponent) == 0x000008, "Wrong alignment on UTerrorRadiusAudioFeedbackComponent");
static_assert(sizeof(UTerrorRadiusAudioFeedbackComponent) == 0x000100, "Wrong size on UTerrorRadiusAudioFeedbackComponent");

// Class DBDGameplay.TerrorRadiusBPMComponent
// 0x0058 (0x0110 - 0x00B8)
class UTerrorRadiusBPMComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x58];                                      // 0x00B8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TerrorRadiusBPMComponent">();
	}
	static class UTerrorRadiusBPMComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTerrorRadiusBPMComponent>();
	}
};
static_assert(alignof(UTerrorRadiusBPMComponent) == 0x000008, "Wrong alignment on UTerrorRadiusBPMComponent");
static_assert(sizeof(UTerrorRadiusBPMComponent) == 0x000110, "Wrong size on UTerrorRadiusBPMComponent");

// Class DBDGameplay.TerrorRadiusReceiverComponent
// 0x0178 (0x0230 - 0x00B8)
class UTerrorRadiusReceiverComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x30];                                      // 0x00B8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _trVerticalDistanceFactor;                         // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _heartbeatSmoothingInterpolationSpeed;             // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ASurvivor* Survivor, bool IsInTerrorRadius)> OnIsInTerrorRadiusChanged; // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_108[0x128];                                    // 0x0108(0x0128)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsInTerrorRadius() const;
	bool IsInTerrorRadiusRange() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TerrorRadiusReceiverComponent">();
	}
	static class UTerrorRadiusReceiverComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTerrorRadiusReceiverComponent>();
	}
};
static_assert(alignof(UTerrorRadiusReceiverComponent) == 0x000008, "Wrong alignment on UTerrorRadiusReceiverComponent");
static_assert(sizeof(UTerrorRadiusReceiverComponent) == 0x000230, "Wrong size on UTerrorRadiusReceiverComponent");
static_assert(offsetof(UTerrorRadiusReceiverComponent, _trVerticalDistanceFactor) == 0x0000E8, "Member 'UTerrorRadiusReceiverComponent::_trVerticalDistanceFactor' has a wrong offset!");
static_assert(offsetof(UTerrorRadiusReceiverComponent, _heartbeatSmoothingInterpolationSpeed) == 0x0000F0, "Member 'UTerrorRadiusReceiverComponent::_heartbeatSmoothingInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UTerrorRadiusReceiverComponent, OnIsInTerrorRadiusChanged) == 0x0000F8, "Member 'UTerrorRadiusReceiverComponent::OnIsInTerrorRadiusChanged' has a wrong offset!");

// Class DBDGameplay.TerrorRadiusScreenIndicatorComponent
// 0x00C0 (0x03B0 - 0x02F0)
class UTerrorRadiusScreenIndicatorComponent final : public UScreenIndicatorWorldMarkerComponent
{
public:
	TArray<struct FHideHeartIndicatorWithDelay>   _hideHeartIndicatorWithDelay;                      // 0x02E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0xB8];                                     // 0x02F8(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHeartStateChanged(const struct FGameplayTag& heartState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TerrorRadiusScreenIndicatorComponent">();
	}
	static class UTerrorRadiusScreenIndicatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTerrorRadiusScreenIndicatorComponent>();
	}
};
static_assert(alignof(UTerrorRadiusScreenIndicatorComponent) == 0x000010, "Wrong alignment on UTerrorRadiusScreenIndicatorComponent");
static_assert(sizeof(UTerrorRadiusScreenIndicatorComponent) == 0x0003B0, "Wrong size on UTerrorRadiusScreenIndicatorComponent");
static_assert(offsetof(UTerrorRadiusScreenIndicatorComponent, _hideHeartIndicatorWithDelay) == 0x0002E8, "Member 'UTerrorRadiusScreenIndicatorComponent::_hideHeartIndicatorWithDelay' has a wrong offset!");

// Class DBDGameplay.TerrorRadiusVisualFeedbackComponent
// 0x00C8 (0x0180 - 0x00B8)
class UTerrorRadiusVisualFeedbackComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(const struct FGameplayTag& heartState)> OnHeartStateChanged;       // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FTerrorRadiusVisualIndicatorHeartStateRange> _heartStateRanges;                    // 0x00C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTag>                   _hideHeartStateTags;                               // 0x00D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(float bpmIntensityPercentage)> OnHeartBeat;                        // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x88];                                      // 0x00F8(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TerrorRadiusVisualFeedbackComponent">();
	}
	static class UTerrorRadiusVisualFeedbackComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTerrorRadiusVisualFeedbackComponent>();
	}
};
static_assert(alignof(UTerrorRadiusVisualFeedbackComponent) == 0x000008, "Wrong alignment on UTerrorRadiusVisualFeedbackComponent");
static_assert(sizeof(UTerrorRadiusVisualFeedbackComponent) == 0x000180, "Wrong size on UTerrorRadiusVisualFeedbackComponent");
static_assert(offsetof(UTerrorRadiusVisualFeedbackComponent, OnHeartStateChanged) == 0x0000B8, "Member 'UTerrorRadiusVisualFeedbackComponent::OnHeartStateChanged' has a wrong offset!");
static_assert(offsetof(UTerrorRadiusVisualFeedbackComponent, _heartStateRanges) == 0x0000C8, "Member 'UTerrorRadiusVisualFeedbackComponent::_heartStateRanges' has a wrong offset!");
static_assert(offsetof(UTerrorRadiusVisualFeedbackComponent, _hideHeartStateTags) == 0x0000D8, "Member 'UTerrorRadiusVisualFeedbackComponent::_hideHeartStateTags' has a wrong offset!");
static_assert(offsetof(UTerrorRadiusVisualFeedbackComponent, OnHeartBeat) == 0x0000E8, "Member 'UTerrorRadiusVisualFeedbackComponent::OnHeartBeat' has a wrong offset!");

// Class DBDGameplay.TracingConeFlashlightableLightingStrategy
// 0x0008 (0x0038 - 0x0030)
class UTracingConeFlashlightableLightingStrategy final : public UFlashlightableLightingStrategy
{
public:
	int32                                         _aroundConeCircleTraceCount;                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TracingConeFlashlightableLightingStrategy">();
	}
	static class UTracingConeFlashlightableLightingStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTracingConeFlashlightableLightingStrategy>();
	}
};
static_assert(alignof(UTracingConeFlashlightableLightingStrategy) == 0x000008, "Wrong alignment on UTracingConeFlashlightableLightingStrategy");
static_assert(sizeof(UTracingConeFlashlightableLightingStrategy) == 0x000038, "Wrong size on UTracingConeFlashlightableLightingStrategy");
static_assert(offsetof(UTracingConeFlashlightableLightingStrategy, _aroundConeCircleTraceCount) == 0x000030, "Member 'UTracingConeFlashlightableLightingStrategy::_aroundConeCircleTraceCount' has a wrong offset!");

// Class DBDGameplay.TurnLimitationStrategy
// 0x0028 (0x0058 - 0x0030)
class UTurnLimitationStrategy final : public UObject
{
public:
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TurnLimitationStrategy">();
	}
	static class UTurnLimitationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTurnLimitationStrategy>();
	}
};
static_assert(alignof(UTurnLimitationStrategy) == 0x000008, "Wrong alignment on UTurnLimitationStrategy");
static_assert(sizeof(UTurnLimitationStrategy) == 0x000058, "Wrong size on UTurnLimitationStrategy");

// Class DBDGameplay.UnhookedSurvivorTrackerComponent
// 0x0028 (0x00E0 - 0x00B8)
class UUnhookedSurvivorTrackerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x28];                                      // 0x00B8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnhookedSurvivorTrackerComponent">();
	}
	static class UUnhookedSurvivorTrackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnhookedSurvivorTrackerComponent>();
	}
};
static_assert(alignof(UUnhookedSurvivorTrackerComponent) == 0x000008, "Wrong alignment on UUnhookedSurvivorTrackerComponent");
static_assert(sizeof(UUnhookedSurvivorTrackerComponent) == 0x0000E0, "Wrong size on UUnhookedSurvivorTrackerComponent");

// Class DBDGameplay.VisibleHatchRangeTrackerStrategy
// 0x0028 (0x0098 - 0x0070)
class UVisibleHatchRangeTrackerStrategy final : public URangeToActorsTrackerStrategy
{
public:
	uint8                                         Pad_70[0x28];                                      // 0x0070(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VisibleHatchRangeTrackerStrategy">();
	}
	static class UVisibleHatchRangeTrackerStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVisibleHatchRangeTrackerStrategy>();
	}
};
static_assert(alignof(UVisibleHatchRangeTrackerStrategy) == 0x000008, "Wrong alignment on UVisibleHatchRangeTrackerStrategy");
static_assert(sizeof(UVisibleHatchRangeTrackerStrategy) == 0x000098, "Wrong size on UVisibleHatchRangeTrackerStrategy");

// Class DBDGameplay.WiggleComponent
// 0x0198 (0x0250 - 0x00B8)
class UWiggleComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnFailSkillCheckAudioEvent;                        // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnMissSkillCheckAudioEvent;                        // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class FString                                 AUDIO_EVENT_SKILL_CHECK_WARNING;                   // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 AUDIO_EVENT_SKILL_CHECK_GOOD;                      // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 AUDIO_EVENT_SKILL_CHECK_GREAT;                     // 0x0100(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChargeableComponent*                   _wiggleProgress;                                   // 0x0110(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AKiller>                 _killerWigglingFrom;                               // 0x0118(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UInputComponent>         _inputComponent;                                   // 0x0120(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x110];                                    // 0x0128(0x0110)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _wiggleInputLockTime;                              // 0x0238(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23C[0x14];                                     // 0x023C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_AddWiggleCharge(float ChargeAmount);
	void Authority_TutorialEndWiggle();
	void OnHideWiggleSkillCheck(ESkillCheckCustomType Type);
	void OnKeyBindingsChanged();
	void OnLevelReadyToPlay();
	void OnPickedUpSkillCheckEnd(bool hadInput, bool Success, bool Bonus, ESkillCheckCustomType Type, class ADBDPlayer* Player);
	void OnPlayerPickedUpEnd(class ADBDPlayer* picker);
	void OnPlayerPickedUpStart(class ADBDPlayer* picker);
	void OnSurvivorHookedOrUnhookedOrDropped();
	void OnWiggleEnd();
	void OnWiggleInput();
	void OnWiggleSkillCheckEnd(bool hadInput, bool Success, bool Bonus, ESkillCheckCustomType Type, class ADBDPlayer* Player);

	void DBD_SetWiggleProgress(const float progressPercent) const;
	class UChargeableComponent* GetWiggleChargeable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WiggleComponent">();
	}
	static class UWiggleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWiggleComponent>();
	}
};
static_assert(alignof(UWiggleComponent) == 0x000008, "Wrong alignment on UWiggleComponent");
static_assert(sizeof(UWiggleComponent) == 0x000250, "Wrong size on UWiggleComponent");
static_assert(offsetof(UWiggleComponent, OnFailSkillCheckAudioEvent) == 0x0000C0, "Member 'UWiggleComponent::OnFailSkillCheckAudioEvent' has a wrong offset!");
static_assert(offsetof(UWiggleComponent, OnMissSkillCheckAudioEvent) == 0x0000D0, "Member 'UWiggleComponent::OnMissSkillCheckAudioEvent' has a wrong offset!");
static_assert(offsetof(UWiggleComponent, AUDIO_EVENT_SKILL_CHECK_WARNING) == 0x0000E0, "Member 'UWiggleComponent::AUDIO_EVENT_SKILL_CHECK_WARNING' has a wrong offset!");
static_assert(offsetof(UWiggleComponent, AUDIO_EVENT_SKILL_CHECK_GOOD) == 0x0000F0, "Member 'UWiggleComponent::AUDIO_EVENT_SKILL_CHECK_GOOD' has a wrong offset!");
static_assert(offsetof(UWiggleComponent, AUDIO_EVENT_SKILL_CHECK_GREAT) == 0x000100, "Member 'UWiggleComponent::AUDIO_EVENT_SKILL_CHECK_GREAT' has a wrong offset!");
static_assert(offsetof(UWiggleComponent, _wiggleProgress) == 0x000110, "Member 'UWiggleComponent::_wiggleProgress' has a wrong offset!");
static_assert(offsetof(UWiggleComponent, _killerWigglingFrom) == 0x000118, "Member 'UWiggleComponent::_killerWigglingFrom' has a wrong offset!");
static_assert(offsetof(UWiggleComponent, _inputComponent) == 0x000120, "Member 'UWiggleComponent::_inputComponent' has a wrong offset!");
static_assert(offsetof(UWiggleComponent, _wiggleInputLockTime) == 0x000238, "Member 'UWiggleComponent::_wiggleInputLockTime' has a wrong offset!");

// Class DBDGameplay.WiggleFreeComponent
// 0x0030 (0x00E8 - 0x00B8)
class UWiggleFreeComponent final : public UActorComponent
{
public:
	class AKiller*                                _killerWigglingFrom;                               // 0x00B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x28];                                      // 0x00C0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnChargeableCompleteEvent(bool COMPLETED, const TArray<class AActor*>& instigatorsForCompletion);
	void Authority_OnChargeApplied(float IndividualChargeAmount, float TotalChargeAmount, class AActor* ChargeInstigator, bool WasCoop, float DeltaTime);
	void Authority_OnPlayerPickedUpEnd(class ADBDPlayer* picker);
	void Authority_OnWiggleEnd();
	void Authority_RegisterListeners();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WiggleFreeComponent">();
	}
	static class UWiggleFreeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWiggleFreeComponent>();
	}
};
static_assert(alignof(UWiggleFreeComponent) == 0x000008, "Wrong alignment on UWiggleFreeComponent");
static_assert(sizeof(UWiggleFreeComponent) == 0x0000E8, "Wrong size on UWiggleFreeComponent");
static_assert(offsetof(UWiggleFreeComponent, _killerWigglingFrom) == 0x0000B8, "Member 'UWiggleFreeComponent::_killerWigglingFrom' has a wrong offset!");

// Class DBDGameplay.WiggleMotionComponent
// 0x00C0 (0x0178 - 0x00B8)
class UWiggleMotionComponent final : public UActorComponent
{
public:
	class ADBDPlayer*                             _carriedPlayer;                                    // 0x00B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDCharacterMovementComponent*         _ownerMovementComponent;                           // 0x00C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x60];                                      // 0x00C8(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _goodSkillCheckBumpsAmplitude;                     // 0x0128(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _greatSkillCheckBumpsAmplitude;                    // 0x0150(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void OnHideWiggleSkillCheck(ESkillCheckCustomType Type);
	void OnSurvivorPickedUp(class ADBDPlayer* Target, float pickupDuration);
	void OnSurvivorRemoved(class ADBDPlayer* Target);
	void OnWiggleSkillCheckEnd(bool hadInput, bool Success, bool Bonus, ESkillCheckCustomType Type, class ADBDPlayer* Player);
	void Server_SetIsBeingWiggled(const bool isBeingWiggled);
	void SetIsBeingWiggled(const bool isBeingWiggled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WiggleMotionComponent">();
	}
	static class UWiggleMotionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWiggleMotionComponent>();
	}
};
static_assert(alignof(UWiggleMotionComponent) == 0x000008, "Wrong alignment on UWiggleMotionComponent");
static_assert(sizeof(UWiggleMotionComponent) == 0x000178, "Wrong size on UWiggleMotionComponent");
static_assert(offsetof(UWiggleMotionComponent, _carriedPlayer) == 0x0000B8, "Member 'UWiggleMotionComponent::_carriedPlayer' has a wrong offset!");
static_assert(offsetof(UWiggleMotionComponent, _ownerMovementComponent) == 0x0000C0, "Member 'UWiggleMotionComponent::_ownerMovementComponent' has a wrong offset!");
static_assert(offsetof(UWiggleMotionComponent, _goodSkillCheckBumpsAmplitude) == 0x000128, "Member 'UWiggleMotionComponent::_goodSkillCheckBumpsAmplitude' has a wrong offset!");
static_assert(offsetof(UWiggleMotionComponent, _greatSkillCheckBumpsAmplitude) == 0x000150, "Member 'UWiggleMotionComponent::_greatSkillCheckBumpsAmplitude' has a wrong offset!");

// Class DBDGameplay.WormholeFatherDeadBody
// 0x0038 (0x03E0 - 0x03A8)
class AWormholeFatherDeadBody final : public AInteractable
{
public:
	class UStaticMeshComponent*                   _wrmFatherDeadBodyStaticMesh;                      // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _wrmFatherKeyCardAttachment;                       // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AWormholeFatherKeyCard>     _wrmFatherEasterEggKeyCardStaticClass;             // 0x03B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxPlayerOverlapComponent*             _wrmFatherKeyCardInteractableZone;                 // 0x03C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractor*                            _wrmKeyCardFirstCollectionInteractor;              // 0x03C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCollectFatherKeyCardInteraction*       _fatherKeyCardCollectionInteraction;               // 0x03D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 _wrmFatherEasterEggSpawnedKeyCard;                 // 0x03D8(0x0008)(Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WormholeFatherDeadBody">();
	}
	static class AWormholeFatherDeadBody* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWormholeFatherDeadBody>();
	}
};
static_assert(alignof(AWormholeFatherDeadBody) == 0x000008, "Wrong alignment on AWormholeFatherDeadBody");
static_assert(sizeof(AWormholeFatherDeadBody) == 0x0003E0, "Wrong size on AWormholeFatherDeadBody");
static_assert(offsetof(AWormholeFatherDeadBody, _wrmFatherDeadBodyStaticMesh) == 0x0003A8, "Member 'AWormholeFatherDeadBody::_wrmFatherDeadBodyStaticMesh' has a wrong offset!");
static_assert(offsetof(AWormholeFatherDeadBody, _wrmFatherKeyCardAttachment) == 0x0003B0, "Member 'AWormholeFatherDeadBody::_wrmFatherKeyCardAttachment' has a wrong offset!");
static_assert(offsetof(AWormholeFatherDeadBody, _wrmFatherEasterEggKeyCardStaticClass) == 0x0003B8, "Member 'AWormholeFatherDeadBody::_wrmFatherEasterEggKeyCardStaticClass' has a wrong offset!");
static_assert(offsetof(AWormholeFatherDeadBody, _wrmFatherKeyCardInteractableZone) == 0x0003C0, "Member 'AWormholeFatherDeadBody::_wrmFatherKeyCardInteractableZone' has a wrong offset!");
static_assert(offsetof(AWormholeFatherDeadBody, _wrmKeyCardFirstCollectionInteractor) == 0x0003C8, "Member 'AWormholeFatherDeadBody::_wrmKeyCardFirstCollectionInteractor' has a wrong offset!");
static_assert(offsetof(AWormholeFatherDeadBody, _fatherKeyCardCollectionInteraction) == 0x0003D0, "Member 'AWormholeFatherDeadBody::_fatherKeyCardCollectionInteraction' has a wrong offset!");
static_assert(offsetof(AWormholeFatherDeadBody, _wrmFatherEasterEggSpawnedKeyCard) == 0x0003D8, "Member 'AWormholeFatherDeadBody::_wrmFatherEasterEggSpawnedKeyCard' has a wrong offset!");

// Class DBDGameplay.WormholeFatherDoorAnimInstance
// 0x0010 (0x0360 - 0x0350)
class UWormholeFatherDoorAnimInstance final : public UAnimInstance
{
public:
	bool                                          _isOpened;                                         // 0x0350(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_351[0xF];                                      // 0x0351(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnStateChanged(bool HasBeenHacked);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WormholeFatherDoorAnimInstance">();
	}
	static class UWormholeFatherDoorAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWormholeFatherDoorAnimInstance>();
	}
};
static_assert(alignof(UWormholeFatherDoorAnimInstance) == 0x000010, "Wrong alignment on UWormholeFatherDoorAnimInstance");
static_assert(sizeof(UWormholeFatherDoorAnimInstance) == 0x000360, "Wrong size on UWormholeFatherDoorAnimInstance");
static_assert(offsetof(UWormholeFatherDoorAnimInstance, _isOpened) == 0x000350, "Member 'UWormholeFatherDoorAnimInstance::_isOpened' has a wrong offset!");

// Class DBDGameplay.WormholeFatherHackableActor
// 0x0038 (0x02D8 - 0x02A0)
class AWormholeFatherHackableActor final : public AActor
{
public:
	struct FGameplayTagContainer                  _hackedGameEvents;                                 // 0x02A0(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UWormholeFatherHackingComponent*        _hackingComponent;                                 // 0x02C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8[0x10];                                     // 0x02C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHackedEvent(const struct FGameplayTag& GameEvent, const struct FGameEventData& GameEventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WormholeFatherHackableActor">();
	}
	static class AWormholeFatherHackableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWormholeFatherHackableActor>();
	}
};
static_assert(alignof(AWormholeFatherHackableActor) == 0x000008, "Wrong alignment on AWormholeFatherHackableActor");
static_assert(sizeof(AWormholeFatherHackableActor) == 0x0002D8, "Wrong size on AWormholeFatherHackableActor");
static_assert(offsetof(AWormholeFatherHackableActor, _hackedGameEvents) == 0x0002A0, "Member 'AWormholeFatherHackableActor::_hackedGameEvents' has a wrong offset!");
static_assert(offsetof(AWormholeFatherHackableActor, _hackingComponent) == 0x0002C0, "Member 'AWormholeFatherHackableActor::_hackingComponent' has a wrong offset!");

// Class DBDGameplay.WormholeFatherHackingComponent
// 0x0030 (0x00E8 - 0x00B8)
class UWormholeFatherHackingComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool HasBeenHacked)> Cosmetic_OnHasBeenHackedChanged;              // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          _hasBeenHacked;                                    // 0x00E0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHasBeenHacked(const bool HasBeenHacked);

	bool HasBeenHacked() const;
	void OnRep_HasBeenHacked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WormholeFatherHackingComponent">();
	}
	static class UWormholeFatherHackingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWormholeFatherHackingComponent>();
	}
};
static_assert(alignof(UWormholeFatherHackingComponent) == 0x000008, "Wrong alignment on UWormholeFatherHackingComponent");
static_assert(sizeof(UWormholeFatherHackingComponent) == 0x0000E8, "Wrong size on UWormholeFatherHackingComponent");
static_assert(offsetof(UWormholeFatherHackingComponent, Cosmetic_OnHasBeenHackedChanged) == 0x0000D0, "Member 'UWormholeFatherHackingComponent::Cosmetic_OnHasBeenHackedChanged' has a wrong offset!");
static_assert(offsetof(UWormholeFatherHackingComponent, _hasBeenHacked) == 0x0000E0, "Member 'UWormholeFatherHackingComponent::_hasBeenHacked' has a wrong offset!");

// Class DBDGameplay.WormholeFatherKeyCard
// 0x0018 (0x05B8 - 0x05A0)
class AWormholeFatherKeyCard final : public ABaseSurvivorCollectable
{
public:
	EFatherKeyCardState                           _keyCardState;                                     // 0x05A0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5A1[0x17];                                     // 0x05A1(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnKeyCardCollected();
	void Cosmetic_OnKeyCardDropped();
	void OnRep_KeyCardState();

	void ApplyInitialTag(class ADBDPlayer* Character) const;
	EFatherKeyCardState GetKeyCardState() const;
	void RemoveInitialTag(class ADBDPlayer* Character) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WormholeFatherKeyCard">();
	}
	static class AWormholeFatherKeyCard* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWormholeFatherKeyCard>();
	}
};
static_assert(alignof(AWormholeFatherKeyCard) == 0x000008, "Wrong alignment on AWormholeFatherKeyCard");
static_assert(sizeof(AWormholeFatherKeyCard) == 0x0005B8, "Wrong size on AWormholeFatherKeyCard");
static_assert(offsetof(AWormholeFatherKeyCard, _keyCardState) == 0x0005A0, "Member 'AWormholeFatherKeyCard::_keyCardState' has a wrong offset!");

// Class DBDGameplay.WormholeFatherKeyCardOutlineUpdateStrategy
// 0x0000 (0x0110 - 0x0110)
class UWormholeFatherKeyCardOutlineUpdateStrategy final : public USurvivorCollectableOutlineUpdateStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WormholeFatherKeyCardOutlineUpdateStrategy">();
	}
	static class UWormholeFatherKeyCardOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWormholeFatherKeyCardOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UWormholeFatherKeyCardOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UWormholeFatherKeyCardOutlineUpdateStrategy");
static_assert(sizeof(UWormholeFatherKeyCardOutlineUpdateStrategy) == 0x000110, "Wrong size on UWormholeFatherKeyCardOutlineUpdateStrategy");

// Class DBDGameplay.WormholeFatherRoomZoneOverlap
// 0x0028 (0x02C8 - 0x02A0)
class AWormholeFatherRoomZoneOverlap final : public AActor
{
public:
	class USpherePlayerOverlapComponent*          _wormholeFatherRoomZone;                           // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A8[0x20];                                     // 0x02A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOverlapEnter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnOverlapExit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WormholeFatherRoomZoneOverlap">();
	}
	static class AWormholeFatherRoomZoneOverlap* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWormholeFatherRoomZoneOverlap>();
	}
};
static_assert(alignof(AWormholeFatherRoomZoneOverlap) == 0x000008, "Wrong alignment on AWormholeFatherRoomZoneOverlap");
static_assert(sizeof(AWormholeFatherRoomZoneOverlap) == 0x0002C8, "Wrong size on AWormholeFatherRoomZoneOverlap");
static_assert(offsetof(AWormholeFatherRoomZoneOverlap, _wormholeFatherRoomZone) == 0x0002A0, "Member 'AWormholeFatherRoomZoneOverlap::_wormholeFatherRoomZone' has a wrong offset!");

// Class DBDGameplay.ZoneTileComponent
// 0x0020 (0x00D8 - 0x00B8)
class UZoneTileComponent final : public UActorComponent
{
public:
	struct FGameplayTag                           _zoneTag;                                          // 0x00B8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C4[0x14];                                      // 0x00C4(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZoneTileComponent">();
	}
	static class UZoneTileComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZoneTileComponent>();
	}
};
static_assert(alignof(UZoneTileComponent) == 0x000008, "Wrong alignment on UZoneTileComponent");
static_assert(sizeof(UZoneTileComponent) == 0x0000D8, "Wrong size on UZoneTileComponent");
static_assert(offsetof(UZoneTileComponent, _zoneTag) == 0x0000B8, "Member 'UZoneTileComponent::_zoneTag' has a wrong offset!");

// Class DBDGameplay.ZoneUtilities
// 0x0000 (0x0030 - 0x0030)
class UZoneUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZoneUtilities">();
	}
	static class UZoneUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZoneUtilities>();
	}
};
static_assert(alignof(UZoneUtilities) == 0x000008, "Wrong alignment on UZoneUtilities");
static_assert(sizeof(UZoneUtilities) == 0x000030, "Wrong size on UZoneUtilities");

}

