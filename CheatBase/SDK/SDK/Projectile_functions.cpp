#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Projectile

#include "Basic.hpp"

#include "Projectile_classes.hpp"
#include "Projectile_parameters.hpp"


namespace SDK
{

// Function Projectile.DBDProjectileMovementComponent.AddComponentToSweep
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDProjectileMovementComponent::AddComponentToSweep(class UPrimitiveComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDProjectileMovementComponent", "AddComponentToSweep");

	Params::DBDProjectileMovementComponent_AddComponentToSweep Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.DBDProjectileMovementComponent.GetPreviousLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector                    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FVector UDBDProjectileMovementComponent::GetPreviousLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDProjectileMovementComponent", "GetPreviousLocation");

	Params::DBDProjectileMovementComponent_GetPreviousLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectileLauncher.Authority_AddMaxAmmo
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ammoToAdd                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileLauncher::Authority_AddMaxAmmo(int32 ammoToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "Authority_AddMaxAmmo");

	Params::BaseProjectileLauncher_Authority_AddMaxAmmo Parms{};

	Parms.ammoToAdd = ammoToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileLauncher.Authority_Launch
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UBaseProjectileLauncher::Authority_Launch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "Authority_Launch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileLauncher.Authority_Reload
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UBaseProjectileLauncher::Authority_Reload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "Authority_Reload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileLauncher.Authority_SetMaxAmmo
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   newMaxAmmo                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isMaxAmmoImmutable                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileLauncher::Authority_SetMaxAmmo(int32 newMaxAmmo, bool isMaxAmmoImmutable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "Authority_SetMaxAmmo");

	Params::BaseProjectileLauncher_Authority_SetMaxAmmo Parms{};

	Parms.newMaxAmmo = newMaxAmmo;
	Parms.isMaxAmmoImmutable = isMaxAmmoImmutable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileLauncher.Cosmetic_OnOutOfAmmo
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void UBaseProjectileLauncher::Cosmetic_OnOutOfAmmo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "Cosmetic_OnOutOfAmmo");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Projectile.BaseProjectileLauncher.OnLaunch
// (Event, Protected, BlueprintEvent)
// Parameters:
// const struct FLaunchInfo&               LaunchInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class ABaseProjectile*                  Projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileLauncher::OnLaunch(const struct FLaunchInfo& LaunchInfo, class ABaseProjectile* Projectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "OnLaunch");

	Params::BaseProjectileLauncher_OnLaunch Parms{};

	Parms.LaunchInfo = std::move(LaunchInfo);
	Parms.Projectile = Projectile;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Projectile.BaseProjectileLauncher.OnRep_Ammo
// (Native, Protected)
// Parameters:
// int32                                   oldAmmo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileLauncher::OnRep_Ammo(int32 oldAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "OnRep_Ammo");

	Params::BaseProjectileLauncher_OnRep_Ammo Parms{};

	Parms.oldAmmo = oldAmmo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileLauncher.OnRep_MaxAmmo
// (Native, Protected)
// Parameters:
// int32                                   oldMaxAmmo                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileLauncher::OnRep_MaxAmmo(int32 oldMaxAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "OnRep_MaxAmmo");

	Params::BaseProjectileLauncher_OnRep_MaxAmmo Parms{};

	Parms.oldMaxAmmo = oldMaxAmmo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileLauncher.Server_Launch
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// const struct FLaunchInfo&               LaunchInfo                                             (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class ABaseProjectile*                  Projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileLauncher::Server_Launch(const struct FLaunchInfo& LaunchInfo, class ABaseProjectile* Projectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "Server_Launch");

	Params::BaseProjectileLauncher_Server_Launch Parms{};

	Parms.LaunchInfo = std::move(LaunchInfo);
	Parms.Projectile = Projectile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileLauncher.Server_LaunchWithImpact
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// const struct FLaunchInfo&               LaunchInfo                                             (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FImpactInfo&               ImpactInfo                                             (ConstParm, Parm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class ABaseProjectile*                  Projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileLauncher::Server_LaunchWithImpact(const struct FLaunchInfo& LaunchInfo, const struct FImpactInfo& ImpactInfo, class ABaseProjectile* Projectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "Server_LaunchWithImpact");

	Params::BaseProjectileLauncher_Server_LaunchWithImpact Parms{};

	Parms.LaunchInfo = std::move(LaunchInfo);
	Parms.ImpactInfo = std::move(ImpactInfo);
	Parms.Projectile = Projectile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileLauncher.SetProjectileProvider
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IProjectileProvider>ProjectileProvider                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileLauncher::SetProjectileProvider(TScriptInterface<class IProjectileProvider> ProjectileProvider)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "SetProjectileProvider");

	Params::BaseProjectileLauncher_SetProjectileProvider Parms{};

	Parms.ProjectileProvider = ProjectileProvider;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileLauncher.SetProjectileVar
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             VarName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileLauncher::SetProjectileVar(class FName VarName, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "SetProjectileVar");

	Params::BaseProjectileLauncher_SetProjectileVar Parms{};

	Parms.VarName = VarName;
	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Projectile.BaseProjectileLauncher.GetAmmo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBaseProjectileLauncher::GetAmmo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "GetAmmo");

	Params::BaseProjectileLauncher_GetAmmo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectileLauncher.GetLaunchDirection
// (Native, Event, Protected, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UBaseProjectileLauncher::GetLaunchDirection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "GetLaunchDirection");

	Params::BaseProjectileLauncher_GetLaunchDirection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectileLauncher.GetLaunchDirectionAtViewAndThrowPowerRatio
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const struct FRotator&                  ViewRotation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   throwPowerRatio                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UBaseProjectileLauncher::GetLaunchDirectionAtViewAndThrowPowerRatio(const struct FRotator& ViewRotation, float throwPowerRatio) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "GetLaunchDirectionAtViewAndThrowPowerRatio");

	Params::BaseProjectileLauncher_GetLaunchDirectionAtViewAndThrowPowerRatio Parms{};

	Parms.ViewRotation = std::move(ViewRotation);
	Parms.throwPowerRatio = throwPowerRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectileLauncher.GetLaunchGravityScale
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBaseProjectileLauncher::GetLaunchGravityScale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "GetLaunchGravityScale");

	Params::BaseProjectileLauncher_GetLaunchGravityScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectileLauncher.GetLaunchPosition
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UBaseProjectileLauncher::GetLaunchPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "GetLaunchPosition");

	Params::BaseProjectileLauncher_GetLaunchPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectileLauncher.GetLaunchSpeed
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBaseProjectileLauncher::GetLaunchSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "GetLaunchSpeed");

	Params::BaseProjectileLauncher_GetLaunchSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectileLauncher.GetLaunchSpeedAtThrowPowerRatio
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   throwPowerRatio                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBaseProjectileLauncher::GetLaunchSpeedAtThrowPowerRatio(float throwPowerRatio) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "GetLaunchSpeedAtThrowPowerRatio");

	Params::BaseProjectileLauncher_GetLaunchSpeedAtThrowPowerRatio Parms{};

	Parms.throwPowerRatio = throwPowerRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectileLauncher.GetOwningPawn
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* UBaseProjectileLauncher::GetOwningPawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "GetOwningPawn");

	Params::BaseProjectileLauncher_GetOwningPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectileLauncher.GetProjectileToLaunch
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class ABaseProjectile*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABaseProjectile* UBaseProjectileLauncher::GetProjectileToLaunch() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "GetProjectileToLaunch");

	Params::BaseProjectileLauncher_GetProjectileToLaunch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectileLauncher.HasAuthority
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBaseProjectileLauncher::HasAuthority() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "HasAuthority");

	Params::BaseProjectileLauncher_HasAuthority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectileLauncher.HasProjectile
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBaseProjectileLauncher::HasProjectile() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "HasProjectile");

	Params::BaseProjectileLauncher_HasProjectile Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectileLauncher.IsAmmoFull
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBaseProjectileLauncher::IsAmmoFull() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "IsAmmoFull");

	Params::BaseProjectileLauncher_IsAmmoFull Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectile.Authority_TryDetectCollision
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const struct FImpactInfo&               ImpactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseProjectile::Authority_TryDetectCollision(const struct FImpactInfo& ImpactInfo, bool force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "Authority_TryDetectCollision");

	Params::BaseProjectile_Authority_TryDetectCollision Parms{};

	Parms.ImpactInfo = std::move(ImpactInfo);
	Parms.force = force;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectile.IsValidImpactDetection
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// const struct FImpactInfo&               ImpactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseProjectile::IsValidImpactDetection(const struct FImpactInfo& ImpactInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "IsValidImpactDetection");

	Params::BaseProjectile_IsValidImpactDetection Parms{};

	Parms.ImpactInfo = std::move(ImpactInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectile.IsValidPlayerDetection
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// const struct FImpactInfo&               ImpactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseProjectile::IsValidPlayerDetection(const struct FImpactInfo& ImpactInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "IsValidPlayerDetection");

	Params::BaseProjectile_IsValidPlayerDetection Parms{};

	Parms.ImpactInfo = std::move(ImpactInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectile.IsValidSlashableDetection
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// const struct FImpactInfo&               ImpactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseProjectile::IsValidSlashableDetection(const struct FImpactInfo& ImpactInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "IsValidSlashableDetection");

	Params::BaseProjectile_IsValidSlashableDetection Parms{};

	Parms.ImpactInfo = std::move(ImpactInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectile.Local_SweepImpactCollision
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Start                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  colliderRotation                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FHitResult*                      OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseProjectile::Local_SweepImpactCollision(const struct FVector& Start, const struct FVector& End, const struct FRotator& colliderRotation, struct FHitResult* OutHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "Local_SweepImpactCollision");

	Params::BaseProjectile_Local_SweepImpactCollision Parms{};

	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.colliderRotation = std::move(colliderRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectile.Local_TryDetectCollision
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FImpactInfo&               ImpactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseProjectile::Local_TryDetectCollision(const struct FImpactInfo& ImpactInfo, bool force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "Local_TryDetectCollision");

	Params::BaseProjectile_Local_TryDetectCollision Parms{};

	Parms.ImpactInfo = std::move(ImpactInfo);
	Parms.force = force;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectile.OnDetectCollision
// (Event, Protected, BlueprintEvent)
// Parameters:
// const struct FImpactInfo&               ImpactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ABaseProjectile::OnDetectCollision(const struct FImpactInfo& ImpactInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "OnDetectCollision");

	Params::BaseProjectile_OnDetectCollision Parms{};

	Parms.ImpactInfo = std::move(ImpactInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Projectile.BaseProjectile.OnDetectPlayer
// (Event, Protected, BlueprintEvent)
// Parameters:
// const struct FImpactInfo&               ImpactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ABaseProjectile::OnDetectPlayer(const struct FImpactInfo& ImpactInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "OnDetectPlayer");

	Params::BaseProjectile_OnDetectPlayer Parms{};

	Parms.ImpactInfo = std::move(ImpactInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Projectile.BaseProjectile.OnLaunch
// (Event, Protected, BlueprintEvent)
// Parameters:
// const struct FLaunchInfo&               LaunchInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    hasImpactOnLaunch                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseProjectile::OnLaunch(const struct FLaunchInfo& LaunchInfo, bool hasImpactOnLaunch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "OnLaunch");

	Params::BaseProjectile_OnLaunch Parms{};

	Parms.LaunchInfo = std::move(LaunchInfo);
	Parms.hasImpactOnLaunch = hasImpactOnLaunch;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Projectile.BaseProjectile.OnSetActive
// (Event, Protected, BlueprintEvent)
// Parameters:
// const bool                              Active                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseProjectile::OnSetActive(const bool Active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "OnSetActive");

	Params::BaseProjectile_OnSetActive Parms{};

	Parms.Active = Active;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Projectile.BaseProjectile.GetAddLauncherVeloctyFactor
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ABaseProjectile::GetAddLauncherVeloctyFactor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "GetAddLauncherVeloctyFactor");

	Params::BaseProjectile_GetAddLauncherVeloctyFactor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectile.GetImpactPrimitiveComponent
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// class UPrimitiveComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* ABaseProjectile::GetImpactPrimitiveComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "GetImpactPrimitiveComponent");

	Params::BaseProjectile_GetImpactPrimitiveComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectile.GetLauncher
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBaseProjectileLauncher*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBaseProjectileLauncher* ABaseProjectile::GetLauncher() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "GetLauncher");

	Params::BaseProjectile_GetLauncher Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectile.IsOwningPawnLocallyControlled
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseProjectile::IsOwningPawnLocallyControlled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "IsOwningPawnLocallyControlled");

	Params::BaseProjectile_IsOwningPawnLocallyControlled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectile.SphereTraceSingle
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USphereComponent*                 Sphere                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      outHitResult                                           (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseProjectile::SphereTraceSingle(const struct FVector& Start, const struct FVector& End, class USphereComponent* Sphere, struct FHitResult* outHitResult) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "SphereTraceSingle");

	Params::BaseProjectile_SphereTraceSingle Parms{};

	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Sphere = Sphere;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outHitResult != nullptr)
		*outHitResult = std::move(Parms.outHitResult);

	return Parms.ReturnValue;
}


// Function Projectile.AuthoritativePoolProjectileProviderAdapter.Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAuthoritativeActorPoolComponent* Pool                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuthoritativePoolProjectileProviderAdapter::Init(class UAuthoritativeActorPoolComponent* Pool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuthoritativePoolProjectileProviderAdapter", "Init");

	Params::AuthoritativePoolProjectileProviderAdapter_Init Parms{};

	Parms.Pool = Pool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.SingleProjectileProviderComponent.OnRep_Projectile
// (Final, Native, Private)

void USingleProjectileProviderComponent::OnRep_Projectile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SingleProjectileProviderComponent", "OnRep_Projectile");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileReplicationComponent.Client_LaunchRefusedByServer
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class ABaseProjectile*                  Projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileReplicationComponent::Client_LaunchRefusedByServer(class ABaseProjectile* Projectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileReplicationComponent", "Client_LaunchRefusedByServer");

	Params::BaseProjectileReplicationComponent_Client_LaunchRefusedByServer Parms{};

	Parms.Projectile = Projectile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileReplicationComponent.Client_ReceiveDetectPlayerValidation
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// class ABaseProjectile*                  Projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileReplicationComponent::Client_ReceiveDetectPlayerValidation(class ABaseProjectile* Projectile, bool Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileReplicationComponent", "Client_ReceiveDetectPlayerValidation");

	Params::BaseProjectileReplicationComponent_Client_ReceiveDetectPlayerValidation Parms{};

	Parms.Projectile = Projectile;
	Parms.Success = Success;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileReplicationComponent.Multicast_DetectImpact
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ABaseProjectile*                  Projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FImpactInfo&               ImpactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UBaseProjectileReplicationComponent::Multicast_DetectImpact(class ABaseProjectile* Projectile, const struct FImpactInfo& ImpactInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileReplicationComponent", "Multicast_DetectImpact");

	Params::BaseProjectileReplicationComponent_Multicast_DetectImpact Parms{};

	Parms.Projectile = Projectile;
	Parms.ImpactInfo = std::move(ImpactInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileReplicationComponent.Multicast_DetectPlayer
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ABaseProjectile*                  Projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FImpactInfo&               ImpactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UBaseProjectileReplicationComponent::Multicast_DetectPlayer(class ABaseProjectile* Projectile, const struct FImpactInfo& ImpactInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileReplicationComponent", "Multicast_DetectPlayer");

	Params::BaseProjectileReplicationComponent_Multicast_DetectPlayer Parms{};

	Parms.Projectile = Projectile;
	Parms.ImpactInfo = std::move(ImpactInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileReplicationComponent.Multicast_OnLaunch
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ABaseProjectile*                  Projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLaunchInfo&               LaunchInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const bool                              wasPredicted                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileReplicationComponent::Multicast_OnLaunch(class ABaseProjectile* Projectile, const struct FLaunchInfo& LaunchInfo, const bool wasPredicted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileReplicationComponent", "Multicast_OnLaunch");

	Params::BaseProjectileReplicationComponent_Multicast_OnLaunch Parms{};

	Parms.Projectile = Projectile;
	Parms.LaunchInfo = std::move(LaunchInfo);
	Parms.wasPredicted = wasPredicted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileReplicationComponent.Multicast_OnLaunchWithImpact
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ABaseProjectile*                  Projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLaunchInfo&               LaunchInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FImpactInfo&               ImpactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const bool                              wasPredicted                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileReplicationComponent::Multicast_OnLaunchWithImpact(class ABaseProjectile* Projectile, const struct FLaunchInfo& LaunchInfo, const struct FImpactInfo& ImpactInfo, const bool wasPredicted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileReplicationComponent", "Multicast_OnLaunchWithImpact");

	Params::BaseProjectileReplicationComponent_Multicast_OnLaunchWithImpact Parms{};

	Parms.Projectile = Projectile;
	Parms.LaunchInfo = std::move(LaunchInfo);
	Parms.ImpactInfo = std::move(ImpactInfo);
	Parms.wasPredicted = wasPredicted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileReplicationComponent.Multicast_SendAuthorityDetectPlayer
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ABaseProjectile*                  Projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FImpactInfo&               ImpactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UBaseProjectileReplicationComponent::Multicast_SendAuthorityDetectPlayer(class ABaseProjectile* Projectile, const struct FImpactInfo& ImpactInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileReplicationComponent", "Multicast_SendAuthorityDetectPlayer");

	Params::BaseProjectileReplicationComponent_Multicast_SendAuthorityDetectPlayer Parms{};

	Parms.Projectile = Projectile;
	Parms.ImpactInfo = std::move(ImpactInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileReplicationComponent.Mutlicast_DetectSlashable
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ABaseProjectile*                  Projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FImpactInfo&               ImpactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UBaseProjectileReplicationComponent::Mutlicast_DetectSlashable(class ABaseProjectile* Projectile, const struct FImpactInfo& ImpactInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileReplicationComponent", "Mutlicast_DetectSlashable");

	Params::BaseProjectileReplicationComponent_Mutlicast_DetectSlashable Parms{};

	Parms.Projectile = Projectile;
	Parms.ImpactInfo = std::move(ImpactInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileReplicationComponent.Server_TryDetectPlayer
// (Final, Net, NetReliable, Native, Event, Private, NetServer, HasDefaults)
// Parameters:
// class ABaseProjectile*                  Projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FImpactInfo&               ImpactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FVector_NetQuantize100&    projectileLocation                                     (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector_NetQuantize10&     projectileRotation                                     (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             TargetLocationTimestamp                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             launchTime                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             clientTime                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   projectileCurrentLocationOnClient                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileReplicationComponent::Server_TryDetectPlayer(class ABaseProjectile* Projectile, const struct FImpactInfo& ImpactInfo, const struct FVector_NetQuantize100& projectileLocation, const struct FVector_NetQuantize10& projectileRotation, const float TargetLocationTimestamp, const float launchTime, const float clientTime, const struct FVector& projectileCurrentLocationOnClient)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileReplicationComponent", "Server_TryDetectPlayer");

	Params::BaseProjectileReplicationComponent_Server_TryDetectPlayer Parms{};

	Parms.Projectile = Projectile;
	Parms.ImpactInfo = std::move(ImpactInfo);
	Parms.projectileLocation = std::move(projectileLocation);
	Parms.projectileRotation = std::move(projectileRotation);
	Parms.TargetLocationTimestamp = TargetLocationTimestamp;
	Parms.launchTime = launchTime;
	Parms.clientTime = clientTime;
	Parms.projectileCurrentLocationOnClient = std::move(projectileCurrentLocationOnClient);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

