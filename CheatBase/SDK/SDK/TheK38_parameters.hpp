#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheK38

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "TheK38_structs.hpp"
#include "Engine_structs.hpp"
#include "AIModule_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "AnimationUtilities_structs.hpp"
#include "DeadByDaylight_structs.hpp"
#include "DBDSharedTypes_structs.hpp"


namespace SDK::Params
{

// Function TheK38.K38ReturnToOwnerDogState.Authority_OnMoveCompleted
// 0x0008 (0x0008 - 0x0000)
struct K38ReturnToOwnerDogState_Authority_OnMoveCompleted final
{
public:
	struct FAIRequestID                           RequestID;                                         // 0x0000(0x0004)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	EPathFollowingResult                          Result;                                            // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K38ReturnToOwnerDogState_Authority_OnMoveCompleted) == 0x000004, "Wrong alignment on K38ReturnToOwnerDogState_Authority_OnMoveCompleted");
static_assert(sizeof(K38ReturnToOwnerDogState_Authority_OnMoveCompleted) == 0x000008, "Wrong size on K38ReturnToOwnerDogState_Authority_OnMoveCompleted");
static_assert(offsetof(K38ReturnToOwnerDogState_Authority_OnMoveCompleted, RequestID) == 0x000000, "Member 'K38ReturnToOwnerDogState_Authority_OnMoveCompleted::RequestID' has a wrong offset!");
static_assert(offsetof(K38ReturnToOwnerDogState_Authority_OnMoveCompleted, Result) == 0x000004, "Member 'K38ReturnToOwnerDogState_Authority_OnMoveCompleted::Result' has a wrong offset!");

// Function TheK38.K38DashTarget.ShowFootprints
// 0x0010 (0x0010 - 0x0000)
struct K38DashTarget_ShowFootprints final
{
public:
	TArray<struct FTransform>                     footprintsTransforms;                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38DashTarget_ShowFootprints) == 0x000008, "Wrong alignment on K38DashTarget_ShowFootprints");
static_assert(sizeof(K38DashTarget_ShowFootprints) == 0x000010, "Wrong size on K38DashTarget_ShowFootprints");
static_assert(offsetof(K38DashTarget_ShowFootprints, footprintsTransforms) == 0x000000, "Member 'K38DashTarget_ShowFootprints::footprintsTransforms' has a wrong offset!");

// Function TheK38.K38DashTarget.ShowTargetBeam
// 0x0038 (0x0038 - 0x0000)
struct K38DashTarget_ShowTargetBeam final
{
public:
	struct FVector                                Start;                                             // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EK38DogDashAimStatus                          aimStatus;                                         // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K38DashTarget_ShowTargetBeam) == 0x000008, "Wrong alignment on K38DashTarget_ShowTargetBeam");
static_assert(sizeof(K38DashTarget_ShowTargetBeam) == 0x000038, "Wrong size on K38DashTarget_ShowTargetBeam");
static_assert(offsetof(K38DashTarget_ShowTargetBeam, Start) == 0x000000, "Member 'K38DashTarget_ShowTargetBeam::Start' has a wrong offset!");
static_assert(offsetof(K38DashTarget_ShowTargetBeam, End) == 0x000018, "Member 'K38DashTarget_ShowTargetBeam::End' has a wrong offset!");
static_assert(offsetof(K38DashTarget_ShowTargetBeam, aimStatus) == 0x000030, "Member 'K38DashTarget_ShowTargetBeam::aimStatus' has a wrong offset!");

// Function TheK38.K38DashTarget.ShowVaultOrPallet
// 0x0068 (0x0068 - 0x0000)
struct K38DashTarget_ShowVaultOrPallet final
{
public:
	struct FVector                                vaultActorLocation;                                // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                StartLocation;                                     // 0x0030(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                endLocation;                                       // 0x0048(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isVault;                                           // 0x0060(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isPallet;                                          // 0x0061(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x2];                                       // 0x0062(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Count;                                             // 0x0064(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38DashTarget_ShowVaultOrPallet) == 0x000008, "Wrong alignment on K38DashTarget_ShowVaultOrPallet");
static_assert(sizeof(K38DashTarget_ShowVaultOrPallet) == 0x000068, "Wrong size on K38DashTarget_ShowVaultOrPallet");
static_assert(offsetof(K38DashTarget_ShowVaultOrPallet, vaultActorLocation) == 0x000000, "Member 'K38DashTarget_ShowVaultOrPallet::vaultActorLocation' has a wrong offset!");
static_assert(offsetof(K38DashTarget_ShowVaultOrPallet, Rotation) == 0x000018, "Member 'K38DashTarget_ShowVaultOrPallet::Rotation' has a wrong offset!");
static_assert(offsetof(K38DashTarget_ShowVaultOrPallet, StartLocation) == 0x000030, "Member 'K38DashTarget_ShowVaultOrPallet::StartLocation' has a wrong offset!");
static_assert(offsetof(K38DashTarget_ShowVaultOrPallet, endLocation) == 0x000048, "Member 'K38DashTarget_ShowVaultOrPallet::endLocation' has a wrong offset!");
static_assert(offsetof(K38DashTarget_ShowVaultOrPallet, isVault) == 0x000060, "Member 'K38DashTarget_ShowVaultOrPallet::isVault' has a wrong offset!");
static_assert(offsetof(K38DashTarget_ShowVaultOrPallet, isPallet) == 0x000061, "Member 'K38DashTarget_ShowVaultOrPallet::isPallet' has a wrong offset!");
static_assert(offsetof(K38DashTarget_ShowVaultOrPallet, Count) == 0x000064, "Member 'K38DashTarget_ShowVaultOrPallet::Count' has a wrong offset!");

// Function TheK38.K38Addon14ScreamEffect.IsScreamTimerActive
// 0x0001 (0x0001 - 0x0000)
struct K38Addon14ScreamEffect_IsScreamTimerActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38Addon14ScreamEffect_IsScreamTimerActive) == 0x000001, "Wrong alignment on K38Addon14ScreamEffect_IsScreamTimerActive");
static_assert(sizeof(K38Addon14ScreamEffect_IsScreamTimerActive) == 0x000001, "Wrong size on K38Addon14ScreamEffect_IsScreamTimerActive");
static_assert(offsetof(K38Addon14ScreamEffect_IsScreamTimerActive, ReturnValue) == 0x000000, "Member 'K38Addon14ScreamEffect_IsScreamTimerActive::ReturnValue' has a wrong offset!");

// Function TheK38.K38CheatComponent.DBD_K38ComeToMeDoggy
// 0x0010 (0x0010 - 0x0000)
struct K38CheatComponent_DBD_K38ComeToMeDoggy final
{
public:
	class FString                                 localPlayerId;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38CheatComponent_DBD_K38ComeToMeDoggy) == 0x000008, "Wrong alignment on K38CheatComponent_DBD_K38ComeToMeDoggy");
static_assert(sizeof(K38CheatComponent_DBD_K38ComeToMeDoggy) == 0x000010, "Wrong size on K38CheatComponent_DBD_K38ComeToMeDoggy");
static_assert(offsetof(K38CheatComponent_DBD_K38ComeToMeDoggy, localPlayerId) == 0x000000, "Member 'K38CheatComponent_DBD_K38ComeToMeDoggy::localPlayerId' has a wrong offset!");

// Function TheK38.K38CheatComponent.DBD_K38DebugDogState
// 0x0004 (0x0004 - 0x0000)
struct K38CheatComponent_DBD_K38DebugDogState final
{
public:
	float                                         timeToDisplayDebug;                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38CheatComponent_DBD_K38DebugDogState) == 0x000004, "Wrong alignment on K38CheatComponent_DBD_K38DebugDogState");
static_assert(sizeof(K38CheatComponent_DBD_K38DebugDogState) == 0x000004, "Wrong size on K38CheatComponent_DBD_K38DebugDogState");
static_assert(offsetof(K38CheatComponent_DBD_K38DebugDogState, timeToDisplayDebug) == 0x000000, "Member 'K38CheatComponent_DBD_K38DebugDogState::timeToDisplayDebug' has a wrong offset!");

// Function TheK38.K38CheatComponent.DBD_K38DebugSurvivorHeldByDogPath
// 0x0001 (0x0001 - 0x0000)
struct K38CheatComponent_DBD_K38DebugSurvivorHeldByDogPath final
{
public:
	bool                                          isDebugActive;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38CheatComponent_DBD_K38DebugSurvivorHeldByDogPath) == 0x000001, "Wrong alignment on K38CheatComponent_DBD_K38DebugSurvivorHeldByDogPath");
static_assert(sizeof(K38CheatComponent_DBD_K38DebugSurvivorHeldByDogPath) == 0x000001, "Wrong size on K38CheatComponent_DBD_K38DebugSurvivorHeldByDogPath");
static_assert(offsetof(K38CheatComponent_DBD_K38DebugSurvivorHeldByDogPath, isDebugActive) == 0x000000, "Member 'K38CheatComponent_DBD_K38DebugSurvivorHeldByDogPath::isDebugActive' has a wrong offset!");

// Function TheK38.K38CheatComponent.DBD_K38PlayDogMontage
// 0x0020 (0x0020 - 0x0000)
struct K38CheatComponent_DBD_K38PlayDogMontage final
{
public:
	class FName                                   MontageID;                                         // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 localPlayerId;                                     // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38CheatComponent_DBD_K38PlayDogMontage) == 0x000008, "Wrong alignment on K38CheatComponent_DBD_K38PlayDogMontage");
static_assert(sizeof(K38CheatComponent_DBD_K38PlayDogMontage) == 0x000020, "Wrong size on K38CheatComponent_DBD_K38PlayDogMontage");
static_assert(offsetof(K38CheatComponent_DBD_K38PlayDogMontage, MontageID) == 0x000000, "Member 'K38CheatComponent_DBD_K38PlayDogMontage::MontageID' has a wrong offset!");
static_assert(offsetof(K38CheatComponent_DBD_K38PlayDogMontage, Duration) == 0x00000C, "Member 'K38CheatComponent_DBD_K38PlayDogMontage::Duration' has a wrong offset!");
static_assert(offsetof(K38CheatComponent_DBD_K38PlayDogMontage, localPlayerId) == 0x000010, "Member 'K38CheatComponent_DBD_K38PlayDogMontage::localPlayerId' has a wrong offset!");

// Function TheK38.K38CheatComponent.DBD_K38TriggerDogStruggle
// 0x0010 (0x0010 - 0x0000)
struct K38CheatComponent_DBD_K38TriggerDogStruggle final
{
public:
	class FString                                 localPlayerId;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38CheatComponent_DBD_K38TriggerDogStruggle) == 0x000008, "Wrong alignment on K38CheatComponent_DBD_K38TriggerDogStruggle");
static_assert(sizeof(K38CheatComponent_DBD_K38TriggerDogStruggle) == 0x000010, "Wrong size on K38CheatComponent_DBD_K38TriggerDogStruggle");
static_assert(offsetof(K38CheatComponent_DBD_K38TriggerDogStruggle, localPlayerId) == 0x000000, "Member 'K38CheatComponent_DBD_K38TriggerDogStruggle::localPlayerId' has a wrong offset!");

// Function TheK38.K38CheatComponent.DBD_K38TriggerDogTeleport
// 0x0010 (0x0010 - 0x0000)
struct K38CheatComponent_DBD_K38TriggerDogTeleport final
{
public:
	class FString                                 localPlayerId;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38CheatComponent_DBD_K38TriggerDogTeleport) == 0x000008, "Wrong alignment on K38CheatComponent_DBD_K38TriggerDogTeleport");
static_assert(sizeof(K38CheatComponent_DBD_K38TriggerDogTeleport) == 0x000010, "Wrong size on K38CheatComponent_DBD_K38TriggerDogTeleport");
static_assert(offsetof(K38CheatComponent_DBD_K38TriggerDogTeleport, localPlayerId) == 0x000000, "Member 'K38CheatComponent_DBD_K38TriggerDogTeleport::localPlayerId' has a wrong offset!");

// Function TheK38.K38DashDogState.Authority_OnProximityDashHitboxBeginOverlap
// 0x0110 (0x0110 - 0x0000)
struct K38DashDogState_Authority_OnProximityDashHitboxBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F0)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38DashDogState_Authority_OnProximityDashHitboxBeginOverlap) == 0x000008, "Wrong alignment on K38DashDogState_Authority_OnProximityDashHitboxBeginOverlap");
static_assert(sizeof(K38DashDogState_Authority_OnProximityDashHitboxBeginOverlap) == 0x000110, "Wrong size on K38DashDogState_Authority_OnProximityDashHitboxBeginOverlap");
static_assert(offsetof(K38DashDogState_Authority_OnProximityDashHitboxBeginOverlap, OverlappedComponent) == 0x000000, "Member 'K38DashDogState_Authority_OnProximityDashHitboxBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(K38DashDogState_Authority_OnProximityDashHitboxBeginOverlap, OtherActor) == 0x000008, "Member 'K38DashDogState_Authority_OnProximityDashHitboxBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(K38DashDogState_Authority_OnProximityDashHitboxBeginOverlap, OtherComp) == 0x000010, "Member 'K38DashDogState_Authority_OnProximityDashHitboxBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(K38DashDogState_Authority_OnProximityDashHitboxBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'K38DashDogState_Authority_OnProximityDashHitboxBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(K38DashDogState_Authority_OnProximityDashHitboxBeginOverlap, bFromSweep) == 0x00001C, "Member 'K38DashDogState_Authority_OnProximityDashHitboxBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(K38DashDogState_Authority_OnProximityDashHitboxBeginOverlap, SweepResult) == 0x000020, "Member 'K38DashDogState_Authority_OnProximityDashHitboxBeginOverlap::SweepResult' has a wrong offset!");

// Function TheK38.K38DashDogState.OnBeginOverlap
// 0x0110 (0x0110 - 0x0000)
struct K38DashDogState_OnBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F0)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38DashDogState_OnBeginOverlap) == 0x000008, "Wrong alignment on K38DashDogState_OnBeginOverlap");
static_assert(sizeof(K38DashDogState_OnBeginOverlap) == 0x000110, "Wrong size on K38DashDogState_OnBeginOverlap");
static_assert(offsetof(K38DashDogState_OnBeginOverlap, OverlappedComponent) == 0x000000, "Member 'K38DashDogState_OnBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(K38DashDogState_OnBeginOverlap, OtherActor) == 0x000008, "Member 'K38DashDogState_OnBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(K38DashDogState_OnBeginOverlap, OtherComp) == 0x000010, "Member 'K38DashDogState_OnBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(K38DashDogState_OnBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'K38DashDogState_OnBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(K38DashDogState_OnBeginOverlap, bFromSweep) == 0x00001C, "Member 'K38DashDogState_OnBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(K38DashDogState_OnBeginOverlap, SweepResult) == 0x000020, "Member 'K38DashDogState_OnBeginOverlap::SweepResult' has a wrong offset!");

// Function TheK38.K38DashRedirectComponent.FadeToWhiteKiller
// 0x0004 (0x0004 - 0x0000)
struct K38DashRedirectComponent_FadeToWhiteKiller final
{
public:
	float                                         fadeDuration;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38DashRedirectComponent_FadeToWhiteKiller) == 0x000004, "Wrong alignment on K38DashRedirectComponent_FadeToWhiteKiller");
static_assert(sizeof(K38DashRedirectComponent_FadeToWhiteKiller) == 0x000004, "Wrong size on K38DashRedirectComponent_FadeToWhiteKiller");
static_assert(offsetof(K38DashRedirectComponent_FadeToWhiteKiller, fadeDuration) == 0x000000, "Member 'K38DashRedirectComponent_FadeToWhiteKiller::fadeDuration' has a wrong offset!");

// Function TheK38.K38DashRedirectComponent.OnPawnControllerSet
// 0x0018 (0x0018 - 0x0000)
struct K38DashRedirectComponent_OnPawnControllerSet final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            OldController;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            NewController;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38DashRedirectComponent_OnPawnControllerSet) == 0x000008, "Wrong alignment on K38DashRedirectComponent_OnPawnControllerSet");
static_assert(sizeof(K38DashRedirectComponent_OnPawnControllerSet) == 0x000018, "Wrong size on K38DashRedirectComponent_OnPawnControllerSet");
static_assert(offsetof(K38DashRedirectComponent_OnPawnControllerSet, Pawn) == 0x000000, "Member 'K38DashRedirectComponent_OnPawnControllerSet::Pawn' has a wrong offset!");
static_assert(offsetof(K38DashRedirectComponent_OnPawnControllerSet, OldController) == 0x000008, "Member 'K38DashRedirectComponent_OnPawnControllerSet::OldController' has a wrong offset!");
static_assert(offsetof(K38DashRedirectComponent_OnPawnControllerSet, NewController) == 0x000010, "Member 'K38DashRedirectComponent_OnPawnControllerSet::NewController' has a wrong offset!");

// Function TheK38.K38DashRedirectComponent.Server_UpdateCurrentAimDirection
// 0x0018 (0x0018 - 0x0000)
struct K38DashRedirectComponent_Server_UpdateCurrentAimDirection final
{
public:
	struct FVector_NetQuantizeNormal              Direction;                                         // 0x0000(0x0018)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38DashRedirectComponent_Server_UpdateCurrentAimDirection) == 0x000008, "Wrong alignment on K38DashRedirectComponent_Server_UpdateCurrentAimDirection");
static_assert(sizeof(K38DashRedirectComponent_Server_UpdateCurrentAimDirection) == 0x000018, "Wrong size on K38DashRedirectComponent_Server_UpdateCurrentAimDirection");
static_assert(offsetof(K38DashRedirectComponent_Server_UpdateCurrentAimDirection, Direction) == 0x000000, "Member 'K38DashRedirectComponent_Server_UpdateCurrentAimDirection::Direction' has a wrong offset!");

// Function TheK38.K38DashRedirectComponent.GetDog
// 0x0008 (0x0008 - 0x0000)
struct K38DashRedirectComponent_GetDog final
{
public:
	class AK38Dog*                                ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38DashRedirectComponent_GetDog) == 0x000008, "Wrong alignment on K38DashRedirectComponent_GetDog");
static_assert(sizeof(K38DashRedirectComponent_GetDog) == 0x000008, "Wrong size on K38DashRedirectComponent_GetDog");
static_assert(offsetof(K38DashRedirectComponent_GetDog, ReturnValue) == 0x000000, "Member 'K38DashRedirectComponent_GetDog::ReturnValue' has a wrong offset!");

// Function TheK38.K38DashRedirectComponent.GetOwningPlayer
// 0x0008 (0x0008 - 0x0000)
struct K38DashRedirectComponent_GetOwningPlayer final
{
public:
	class AKiller*                                ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38DashRedirectComponent_GetOwningPlayer) == 0x000008, "Wrong alignment on K38DashRedirectComponent_GetOwningPlayer");
static_assert(sizeof(K38DashRedirectComponent_GetOwningPlayer) == 0x000008, "Wrong size on K38DashRedirectComponent_GetOwningPlayer");
static_assert(offsetof(K38DashRedirectComponent_GetOwningPlayer, ReturnValue) == 0x000000, "Member 'K38DashRedirectComponent_GetOwningPlayer::ReturnValue' has a wrong offset!");

// Function TheK38.K38Dog.Authority_OnDogMovementModeChange
// 0x0010 (0x0010 - 0x0000)
struct K38Dog_Authority_OnDogMovementModeChange final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 PrevMovementMode;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PreviousCustomMode;                                // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K38Dog_Authority_OnDogMovementModeChange) == 0x000008, "Wrong alignment on K38Dog_Authority_OnDogMovementModeChange");
static_assert(sizeof(K38Dog_Authority_OnDogMovementModeChange) == 0x000010, "Wrong size on K38Dog_Authority_OnDogMovementModeChange");
static_assert(offsetof(K38Dog_Authority_OnDogMovementModeChange, Character) == 0x000000, "Member 'K38Dog_Authority_OnDogMovementModeChange::Character' has a wrong offset!");
static_assert(offsetof(K38Dog_Authority_OnDogMovementModeChange, PrevMovementMode) == 0x000008, "Member 'K38Dog_Authority_OnDogMovementModeChange::PrevMovementMode' has a wrong offset!");
static_assert(offsetof(K38Dog_Authority_OnDogMovementModeChange, PreviousCustomMode) == 0x000009, "Member 'K38Dog_Authority_OnDogMovementModeChange::PreviousCustomMode' has a wrong offset!");

// Function TheK38.K38Dog.Cosmetic_DrawCollisionRangeCircle
// 0x0020 (0x0020 - 0x0000)
struct K38Dog_Cosmetic_DrawCollisionRangeCircle final
{
public:
	struct FVector                                circleCenter;                                      // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K38Dog_Cosmetic_DrawCollisionRangeCircle) == 0x000008, "Wrong alignment on K38Dog_Cosmetic_DrawCollisionRangeCircle");
static_assert(sizeof(K38Dog_Cosmetic_DrawCollisionRangeCircle) == 0x000020, "Wrong size on K38Dog_Cosmetic_DrawCollisionRangeCircle");
static_assert(offsetof(K38Dog_Cosmetic_DrawCollisionRangeCircle, circleCenter) == 0x000000, "Member 'K38Dog_Cosmetic_DrawCollisionRangeCircle::circleCenter' has a wrong offset!");
static_assert(offsetof(K38Dog_Cosmetic_DrawCollisionRangeCircle, Radius) == 0x000018, "Member 'K38Dog_Cosmetic_DrawCollisionRangeCircle::Radius' has a wrong offset!");

// Function TheK38.K38Dog.Cosmetic_DrawDetectionRangeCircle
// 0x0020 (0x0020 - 0x0000)
struct K38Dog_Cosmetic_DrawDetectionRangeCircle final
{
public:
	struct FVector                                circleCenter;                                      // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isInPatrolIdleState;                               // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K38Dog_Cosmetic_DrawDetectionRangeCircle) == 0x000008, "Wrong alignment on K38Dog_Cosmetic_DrawDetectionRangeCircle");
static_assert(sizeof(K38Dog_Cosmetic_DrawDetectionRangeCircle) == 0x000020, "Wrong size on K38Dog_Cosmetic_DrawDetectionRangeCircle");
static_assert(offsetof(K38Dog_Cosmetic_DrawDetectionRangeCircle, circleCenter) == 0x000000, "Member 'K38Dog_Cosmetic_DrawDetectionRangeCircle::circleCenter' has a wrong offset!");
static_assert(offsetof(K38Dog_Cosmetic_DrawDetectionRangeCircle, Radius) == 0x000018, "Member 'K38Dog_Cosmetic_DrawDetectionRangeCircle::Radius' has a wrong offset!");
static_assert(offsetof(K38Dog_Cosmetic_DrawDetectionRangeCircle, isInPatrolIdleState) == 0x00001C, "Member 'K38Dog_Cosmetic_DrawDetectionRangeCircle::isInPatrolIdleState' has a wrong offset!");

// Function TheK38.K38Dog.Cosmetic_EndCollisionRangeCircle
// 0x0020 (0x0020 - 0x0000)
struct K38Dog_Cosmetic_EndCollisionRangeCircle final
{
public:
	struct FVector                                circleCenter;                                      // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K38Dog_Cosmetic_EndCollisionRangeCircle) == 0x000008, "Wrong alignment on K38Dog_Cosmetic_EndCollisionRangeCircle");
static_assert(sizeof(K38Dog_Cosmetic_EndCollisionRangeCircle) == 0x000020, "Wrong size on K38Dog_Cosmetic_EndCollisionRangeCircle");
static_assert(offsetof(K38Dog_Cosmetic_EndCollisionRangeCircle, circleCenter) == 0x000000, "Member 'K38Dog_Cosmetic_EndCollisionRangeCircle::circleCenter' has a wrong offset!");
static_assert(offsetof(K38Dog_Cosmetic_EndCollisionRangeCircle, Radius) == 0x000018, "Member 'K38Dog_Cosmetic_EndCollisionRangeCircle::Radius' has a wrong offset!");

// Function TheK38.K38Dog.Cosmetic_OnDogInjuredSurvivorDoingInteracton
// 0x0018 (0x0018 - 0x0000)
struct K38Dog_Cosmetic_OnDogInjuredSurvivorDoingInteracton final
{
public:
	class ASurvivor*                              Survivor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AK38Dog*                                dog;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHealthState                                  newDamageState;                                    // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K38Dog_Cosmetic_OnDogInjuredSurvivorDoingInteracton) == 0x000008, "Wrong alignment on K38Dog_Cosmetic_OnDogInjuredSurvivorDoingInteracton");
static_assert(sizeof(K38Dog_Cosmetic_OnDogInjuredSurvivorDoingInteracton) == 0x000018, "Wrong size on K38Dog_Cosmetic_OnDogInjuredSurvivorDoingInteracton");
static_assert(offsetof(K38Dog_Cosmetic_OnDogInjuredSurvivorDoingInteracton, Survivor) == 0x000000, "Member 'K38Dog_Cosmetic_OnDogInjuredSurvivorDoingInteracton::Survivor' has a wrong offset!");
static_assert(offsetof(K38Dog_Cosmetic_OnDogInjuredSurvivorDoingInteracton, dog) == 0x000008, "Member 'K38Dog_Cosmetic_OnDogInjuredSurvivorDoingInteracton::dog' has a wrong offset!");
static_assert(offsetof(K38Dog_Cosmetic_OnDogInjuredSurvivorDoingInteracton, newDamageState) == 0x000010, "Member 'K38Dog_Cosmetic_OnDogInjuredSurvivorDoingInteracton::newDamageState' has a wrong offset!");

// Function TheK38.K38Dog.Cosmetic_OnDogTeleport
// 0x0002 (0x0002 - 0x0000)
struct K38Dog_Cosmetic_OnDogTeleport final
{
public:
	EK38DogTeleportReasons                        Reason;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          showVFX;                                           // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38Dog_Cosmetic_OnDogTeleport) == 0x000001, "Wrong alignment on K38Dog_Cosmetic_OnDogTeleport");
static_assert(sizeof(K38Dog_Cosmetic_OnDogTeleport) == 0x000002, "Wrong size on K38Dog_Cosmetic_OnDogTeleport");
static_assert(offsetof(K38Dog_Cosmetic_OnDogTeleport, Reason) == 0x000000, "Member 'K38Dog_Cosmetic_OnDogTeleport::Reason' has a wrong offset!");
static_assert(offsetof(K38Dog_Cosmetic_OnDogTeleport, showVFX) == 0x000001, "Member 'K38Dog_Cosmetic_OnDogTeleport::showVFX' has a wrong offset!");

// Function TheK38.K38Dog.Cosmetic_OnDogTeleportStartFade
// 0x0001 (0x0001 - 0x0000)
struct K38Dog_Cosmetic_OnDogTeleportStartFade final
{
public:
	EK38DogTeleportReasons                        Reason;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38Dog_Cosmetic_OnDogTeleportStartFade) == 0x000001, "Wrong alignment on K38Dog_Cosmetic_OnDogTeleportStartFade");
static_assert(sizeof(K38Dog_Cosmetic_OnDogTeleportStartFade) == 0x000001, "Wrong size on K38Dog_Cosmetic_OnDogTeleportStartFade");
static_assert(offsetof(K38Dog_Cosmetic_OnDogTeleportStartFade, Reason) == 0x000000, "Member 'K38Dog_Cosmetic_OnDogTeleportStartFade::Reason' has a wrong offset!");

// Function TheK38.K38Dog.Cosmetic_OnRedirectTick
// 0x0004 (0x0004 - 0x0000)
struct K38Dog_Cosmetic_OnRedirectTick final
{
public:
	float                                         elapsedDurationPercent;                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38Dog_Cosmetic_OnRedirectTick) == 0x000004, "Wrong alignment on K38Dog_Cosmetic_OnRedirectTick");
static_assert(sizeof(K38Dog_Cosmetic_OnRedirectTick) == 0x000004, "Wrong size on K38Dog_Cosmetic_OnRedirectTick");
static_assert(offsetof(K38Dog_Cosmetic_OnRedirectTick, elapsedDurationPercent) == 0x000000, "Member 'K38Dog_Cosmetic_OnRedirectTick::elapsedDurationPercent' has a wrong offset!");

// Function TheK38.K38Dog.Cosmetic_RedirectFadeToBlack
// 0x0004 (0x0004 - 0x0000)
struct K38Dog_Cosmetic_RedirectFadeToBlack final
{
public:
	float                                         fadeDuration;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38Dog_Cosmetic_RedirectFadeToBlack) == 0x000004, "Wrong alignment on K38Dog_Cosmetic_RedirectFadeToBlack");
static_assert(sizeof(K38Dog_Cosmetic_RedirectFadeToBlack) == 0x000004, "Wrong size on K38Dog_Cosmetic_RedirectFadeToBlack");
static_assert(offsetof(K38Dog_Cosmetic_RedirectFadeToBlack, fadeDuration) == 0x000000, "Member 'K38Dog_Cosmetic_RedirectFadeToBlack::fadeDuration' has a wrong offset!");

// Function TheK38.K38Dog.Cosmetic_StartCollisionRangeCircle
// 0x0020 (0x0020 - 0x0000)
struct K38Dog_Cosmetic_StartCollisionRangeCircle final
{
public:
	struct FVector                                circleCenter;                                      // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K38Dog_Cosmetic_StartCollisionRangeCircle) == 0x000008, "Wrong alignment on K38Dog_Cosmetic_StartCollisionRangeCircle");
static_assert(sizeof(K38Dog_Cosmetic_StartCollisionRangeCircle) == 0x000020, "Wrong size on K38Dog_Cosmetic_StartCollisionRangeCircle");
static_assert(offsetof(K38Dog_Cosmetic_StartCollisionRangeCircle, circleCenter) == 0x000000, "Member 'K38Dog_Cosmetic_StartCollisionRangeCircle::circleCenter' has a wrong offset!");
static_assert(offsetof(K38Dog_Cosmetic_StartCollisionRangeCircle, Radius) == 0x000018, "Member 'K38Dog_Cosmetic_StartCollisionRangeCircle::Radius' has a wrong offset!");

// Function TheK38.K38Dog.Cosmetic_StartDetectionRangeCircle
// 0x0020 (0x0020 - 0x0000)
struct K38Dog_Cosmetic_StartDetectionRangeCircle final
{
public:
	struct FVector                                circleCenter;                                      // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isInPatrolIdleState;                               // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K38Dog_Cosmetic_StartDetectionRangeCircle) == 0x000008, "Wrong alignment on K38Dog_Cosmetic_StartDetectionRangeCircle");
static_assert(sizeof(K38Dog_Cosmetic_StartDetectionRangeCircle) == 0x000020, "Wrong size on K38Dog_Cosmetic_StartDetectionRangeCircle");
static_assert(offsetof(K38Dog_Cosmetic_StartDetectionRangeCircle, circleCenter) == 0x000000, "Member 'K38Dog_Cosmetic_StartDetectionRangeCircle::circleCenter' has a wrong offset!");
static_assert(offsetof(K38Dog_Cosmetic_StartDetectionRangeCircle, Radius) == 0x000018, "Member 'K38Dog_Cosmetic_StartDetectionRangeCircle::Radius' has a wrong offset!");
static_assert(offsetof(K38Dog_Cosmetic_StartDetectionRangeCircle, isInPatrolIdleState) == 0x00001C, "Member 'K38Dog_Cosmetic_StartDetectionRangeCircle::isInPatrolIdleState' has a wrong offset!");

// Function TheK38.K38Dog.Cosmetic_StopDetectionRangeCircle
// 0x0020 (0x0020 - 0x0000)
struct K38Dog_Cosmetic_StopDetectionRangeCircle final
{
public:
	struct FVector                                circleCenter;                                      // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isInPatrolIdleState;                               // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K38Dog_Cosmetic_StopDetectionRangeCircle) == 0x000008, "Wrong alignment on K38Dog_Cosmetic_StopDetectionRangeCircle");
static_assert(sizeof(K38Dog_Cosmetic_StopDetectionRangeCircle) == 0x000020, "Wrong size on K38Dog_Cosmetic_StopDetectionRangeCircle");
static_assert(offsetof(K38Dog_Cosmetic_StopDetectionRangeCircle, circleCenter) == 0x000000, "Member 'K38Dog_Cosmetic_StopDetectionRangeCircle::circleCenter' has a wrong offset!");
static_assert(offsetof(K38Dog_Cosmetic_StopDetectionRangeCircle, Radius) == 0x000018, "Member 'K38Dog_Cosmetic_StopDetectionRangeCircle::Radius' has a wrong offset!");
static_assert(offsetof(K38Dog_Cosmetic_StopDetectionRangeCircle, isInPatrolIdleState) == 0x00001C, "Member 'K38Dog_Cosmetic_StopDetectionRangeCircle::isInPatrolIdleState' has a wrong offset!");

// Function TheK38.K38Dog.Multicast_CosmeticOnDogInjuredSurivor
// 0x0008 (0x0008 - 0x0000)
struct K38Dog_Multicast_CosmeticOnDogInjuredSurivor final
{
public:
	class ASurvivor*                              Survivor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38Dog_Multicast_CosmeticOnDogInjuredSurivor) == 0x000008, "Wrong alignment on K38Dog_Multicast_CosmeticOnDogInjuredSurivor");
static_assert(sizeof(K38Dog_Multicast_CosmeticOnDogInjuredSurivor) == 0x000008, "Wrong size on K38Dog_Multicast_CosmeticOnDogInjuredSurivor");
static_assert(offsetof(K38Dog_Multicast_CosmeticOnDogInjuredSurivor, Survivor) == 0x000000, "Member 'K38Dog_Multicast_CosmeticOnDogInjuredSurivor::Survivor' has a wrong offset!");

// Function TheK38.K38Dog.Multicast_PlayDogMontage
// 0x0030 (0x0030 - 0x0000)
struct K38Dog_Multicast_PlayDogMontage final
{
public:
	bool                                          Enable;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimationMontageDescriptor            MontageID;                                         // 0x0008(0x0020)(Parm, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          addFPVTag;                                         // 0x002C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K38Dog_Multicast_PlayDogMontage) == 0x000008, "Wrong alignment on K38Dog_Multicast_PlayDogMontage");
static_assert(sizeof(K38Dog_Multicast_PlayDogMontage) == 0x000030, "Wrong size on K38Dog_Multicast_PlayDogMontage");
static_assert(offsetof(K38Dog_Multicast_PlayDogMontage, Enable) == 0x000000, "Member 'K38Dog_Multicast_PlayDogMontage::Enable' has a wrong offset!");
static_assert(offsetof(K38Dog_Multicast_PlayDogMontage, MontageID) == 0x000008, "Member 'K38Dog_Multicast_PlayDogMontage::MontageID' has a wrong offset!");
static_assert(offsetof(K38Dog_Multicast_PlayDogMontage, Duration) == 0x000028, "Member 'K38Dog_Multicast_PlayDogMontage::Duration' has a wrong offset!");
static_assert(offsetof(K38Dog_Multicast_PlayDogMontage, addFPVTag) == 0x00002C, "Member 'K38Dog_Multicast_PlayDogMontage::addFPVTag' has a wrong offset!");

// Function TheK38.K38Dog.OnStateChanged
// 0x0018 (0x0018 - 0x0000)
struct K38Dog_OnStateChanged final
{
public:
	struct FGameplayTag                           oldState;                                          // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           newState;                                          // 0x000C(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38Dog_OnStateChanged) == 0x000004, "Wrong alignment on K38Dog_OnStateChanged");
static_assert(sizeof(K38Dog_OnStateChanged) == 0x000018, "Wrong size on K38Dog_OnStateChanged");
static_assert(offsetof(K38Dog_OnStateChanged, oldState) == 0x000000, "Member 'K38Dog_OnStateChanged::oldState' has a wrong offset!");
static_assert(offsetof(K38Dog_OnStateChanged, newState) == 0x00000C, "Member 'K38Dog_OnStateChanged::newState' has a wrong offset!");

// Function TheK38.K38Dog.GetAudioComponent
// 0x0008 (0x0008 - 0x0000)
struct K38Dog_GetAudioComponent final
{
public:
	class UAkComponent*                           ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38Dog_GetAudioComponent) == 0x000008, "Wrong alignment on K38Dog_GetAudioComponent");
static_assert(sizeof(K38Dog_GetAudioComponent) == 0x000008, "Wrong size on K38Dog_GetAudioComponent");
static_assert(offsetof(K38Dog_GetAudioComponent, ReturnValue) == 0x000000, "Member 'K38Dog_GetAudioComponent::ReturnValue' has a wrong offset!");

// Function TheK38.K38Dog.GetLeftFootGroundDetector
// 0x0008 (0x0008 - 0x0000)
struct K38Dog_GetLeftFootGroundDetector final
{
public:
	class UBaseGroundDetectorComponent*           ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38Dog_GetLeftFootGroundDetector) == 0x000008, "Wrong alignment on K38Dog_GetLeftFootGroundDetector");
static_assert(sizeof(K38Dog_GetLeftFootGroundDetector) == 0x000008, "Wrong size on K38Dog_GetLeftFootGroundDetector");
static_assert(offsetof(K38Dog_GetLeftFootGroundDetector, ReturnValue) == 0x000000, "Member 'K38Dog_GetLeftFootGroundDetector::ReturnValue' has a wrong offset!");

// Function TheK38.K38Dog.GetLeftFrontFootGroundDetector
// 0x0008 (0x0008 - 0x0000)
struct K38Dog_GetLeftFrontFootGroundDetector final
{
public:
	class UBaseGroundDetectorComponent*           ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38Dog_GetLeftFrontFootGroundDetector) == 0x000008, "Wrong alignment on K38Dog_GetLeftFrontFootGroundDetector");
static_assert(sizeof(K38Dog_GetLeftFrontFootGroundDetector) == 0x000008, "Wrong size on K38Dog_GetLeftFrontFootGroundDetector");
static_assert(offsetof(K38Dog_GetLeftFrontFootGroundDetector, ReturnValue) == 0x000000, "Member 'K38Dog_GetLeftFrontFootGroundDetector::ReturnValue' has a wrong offset!");

// Function TheK38.K38Dog.GetRightFootGroundDetector
// 0x0008 (0x0008 - 0x0000)
struct K38Dog_GetRightFootGroundDetector final
{
public:
	class UBaseGroundDetectorComponent*           ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38Dog_GetRightFootGroundDetector) == 0x000008, "Wrong alignment on K38Dog_GetRightFootGroundDetector");
static_assert(sizeof(K38Dog_GetRightFootGroundDetector) == 0x000008, "Wrong size on K38Dog_GetRightFootGroundDetector");
static_assert(offsetof(K38Dog_GetRightFootGroundDetector, ReturnValue) == 0x000000, "Member 'K38Dog_GetRightFootGroundDetector::ReturnValue' has a wrong offset!");

// Function TheK38.K38Dog.GetRightFrontFootGroundDetector
// 0x0008 (0x0008 - 0x0000)
struct K38Dog_GetRightFrontFootGroundDetector final
{
public:
	class UBaseGroundDetectorComponent*           ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38Dog_GetRightFrontFootGroundDetector) == 0x000008, "Wrong alignment on K38Dog_GetRightFrontFootGroundDetector");
static_assert(sizeof(K38Dog_GetRightFrontFootGroundDetector) == 0x000008, "Wrong size on K38Dog_GetRightFrontFootGroundDetector");
static_assert(offsetof(K38Dog_GetRightFrontFootGroundDetector, ReturnValue) == 0x000000, "Member 'K38Dog_GetRightFrontFootGroundDetector::ReturnValue' has a wrong offset!");

// Function TheK38.K38DogCompanionAbility.Cosmetic_ShowDashPath
// 0x0010 (0x0010 - 0x0000)
struct K38DogCompanionAbility_Cosmetic_ShowDashPath final
{
public:
	TArray<struct FVector>                        Positions;                                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38DogCompanionAbility_Cosmetic_ShowDashPath) == 0x000008, "Wrong alignment on K38DogCompanionAbility_Cosmetic_ShowDashPath");
static_assert(sizeof(K38DogCompanionAbility_Cosmetic_ShowDashPath) == 0x000010, "Wrong size on K38DogCompanionAbility_Cosmetic_ShowDashPath");
static_assert(offsetof(K38DogCompanionAbility_Cosmetic_ShowDashPath, Positions) == 0x000000, "Member 'K38DogCompanionAbility_Cosmetic_ShowDashPath::Positions' has a wrong offset!");

// Function TheK38.K38DogCompanionAbility.Multicast_CosmeticEndRedirect
// 0x0001 (0x0001 - 0x0000)
struct K38DogCompanionAbility_Multicast_CosmeticEndRedirect final
{
public:
	bool                                          Success;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38DogCompanionAbility_Multicast_CosmeticEndRedirect) == 0x000001, "Wrong alignment on K38DogCompanionAbility_Multicast_CosmeticEndRedirect");
static_assert(sizeof(K38DogCompanionAbility_Multicast_CosmeticEndRedirect) == 0x000001, "Wrong size on K38DogCompanionAbility_Multicast_CosmeticEndRedirect");
static_assert(offsetof(K38DogCompanionAbility_Multicast_CosmeticEndRedirect, Success) == 0x000000, "Member 'K38DogCompanionAbility_Multicast_CosmeticEndRedirect::Success' has a wrong offset!");

// Function TheK38.K38DogCompanionAbility.Multicast_GivePatrolCommand
// 0x0018 (0x0018 - 0x0000)
struct K38DogCompanionAbility_Multicast_GivePatrolCommand final
{
public:
	struct FVector                                targetLocation;                                    // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38DogCompanionAbility_Multicast_GivePatrolCommand) == 0x000008, "Wrong alignment on K38DogCompanionAbility_Multicast_GivePatrolCommand");
static_assert(sizeof(K38DogCompanionAbility_Multicast_GivePatrolCommand) == 0x000018, "Wrong size on K38DogCompanionAbility_Multicast_GivePatrolCommand");
static_assert(offsetof(K38DogCompanionAbility_Multicast_GivePatrolCommand, targetLocation) == 0x000000, "Member 'K38DogCompanionAbility_Multicast_GivePatrolCommand::targetLocation' has a wrong offset!");

// Function TheK38.K38DogCompanionAbility.Server_RequestDashCommand
// 0x0030 (0x0030 - 0x0000)
struct K38DogCompanionAbility_Server_RequestDashCommand final
{
public:
	struct FVector                                StartLocation;                                     // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38DogCompanionAbility_Server_RequestDashCommand) == 0x000008, "Wrong alignment on K38DogCompanionAbility_Server_RequestDashCommand");
static_assert(sizeof(K38DogCompanionAbility_Server_RequestDashCommand) == 0x000030, "Wrong size on K38DogCompanionAbility_Server_RequestDashCommand");
static_assert(offsetof(K38DogCompanionAbility_Server_RequestDashCommand, StartLocation) == 0x000000, "Member 'K38DogCompanionAbility_Server_RequestDashCommand::StartLocation' has a wrong offset!");
static_assert(offsetof(K38DogCompanionAbility_Server_RequestDashCommand, Direction) == 0x000018, "Member 'K38DogCompanionAbility_Server_RequestDashCommand::Direction' has a wrong offset!");

// Function TheK38.K38DogCompanionAbility.Server_RequestPatrolCommand
// 0x0018 (0x0018 - 0x0000)
struct K38DogCompanionAbility_Server_RequestPatrolCommand final
{
public:
	struct FVector                                targetLocation;                                    // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38DogCompanionAbility_Server_RequestPatrolCommand) == 0x000008, "Wrong alignment on K38DogCompanionAbility_Server_RequestPatrolCommand");
static_assert(sizeof(K38DogCompanionAbility_Server_RequestPatrolCommand) == 0x000018, "Wrong size on K38DogCompanionAbility_Server_RequestPatrolCommand");
static_assert(offsetof(K38DogCompanionAbility_Server_RequestPatrolCommand, targetLocation) == 0x000000, "Member 'K38DogCompanionAbility_Server_RequestPatrolCommand::targetLocation' has a wrong offset!");

// Function TheK38.K38DogCompanionAbility.Server_RequestRedirectCommand
// 0x0018 (0x0018 - 0x0000)
struct K38DogCompanionAbility_Server_RequestRedirectCommand final
{
public:
	struct FVector                                Direction;                                         // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38DogCompanionAbility_Server_RequestRedirectCommand) == 0x000008, "Wrong alignment on K38DogCompanionAbility_Server_RequestRedirectCommand");
static_assert(sizeof(K38DogCompanionAbility_Server_RequestRedirectCommand) == 0x000018, "Wrong size on K38DogCompanionAbility_Server_RequestRedirectCommand");
static_assert(offsetof(K38DogCompanionAbility_Server_RequestRedirectCommand, Direction) == 0x000000, "Member 'K38DogCompanionAbility_Server_RequestRedirectCommand::Direction' has a wrong offset!");

// Function TheK38.K38DogFollowKillerComponent.Authority_OnDogMovementModeChange
// 0x0010 (0x0010 - 0x0000)
struct K38DogFollowKillerComponent_Authority_OnDogMovementModeChange final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 PrevMovementMode;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PreviousCustomMode;                                // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K38DogFollowKillerComponent_Authority_OnDogMovementModeChange) == 0x000008, "Wrong alignment on K38DogFollowKillerComponent_Authority_OnDogMovementModeChange");
static_assert(sizeof(K38DogFollowKillerComponent_Authority_OnDogMovementModeChange) == 0x000010, "Wrong size on K38DogFollowKillerComponent_Authority_OnDogMovementModeChange");
static_assert(offsetof(K38DogFollowKillerComponent_Authority_OnDogMovementModeChange, Character) == 0x000000, "Member 'K38DogFollowKillerComponent_Authority_OnDogMovementModeChange::Character' has a wrong offset!");
static_assert(offsetof(K38DogFollowKillerComponent_Authority_OnDogMovementModeChange, PrevMovementMode) == 0x000008, "Member 'K38DogFollowKillerComponent_Authority_OnDogMovementModeChange::PrevMovementMode' has a wrong offset!");
static_assert(offsetof(K38DogFollowKillerComponent_Authority_OnDogMovementModeChange, PreviousCustomMode) == 0x000009, "Member 'K38DogFollowKillerComponent_Authority_OnDogMovementModeChange::PreviousCustomMode' has a wrong offset!");

// Function TheK38.K38DogFollowKillerComponent.Authority_OnKillerMovementModeChange
// 0x0010 (0x0010 - 0x0000)
struct K38DogFollowKillerComponent_Authority_OnKillerMovementModeChange final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 PrevMovementMode;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PreviousCustomMode;                                // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K38DogFollowKillerComponent_Authority_OnKillerMovementModeChange) == 0x000008, "Wrong alignment on K38DogFollowKillerComponent_Authority_OnKillerMovementModeChange");
static_assert(sizeof(K38DogFollowKillerComponent_Authority_OnKillerMovementModeChange) == 0x000010, "Wrong size on K38DogFollowKillerComponent_Authority_OnKillerMovementModeChange");
static_assert(offsetof(K38DogFollowKillerComponent_Authority_OnKillerMovementModeChange, Character) == 0x000000, "Member 'K38DogFollowKillerComponent_Authority_OnKillerMovementModeChange::Character' has a wrong offset!");
static_assert(offsetof(K38DogFollowKillerComponent_Authority_OnKillerMovementModeChange, PrevMovementMode) == 0x000008, "Member 'K38DogFollowKillerComponent_Authority_OnKillerMovementModeChange::PrevMovementMode' has a wrong offset!");
static_assert(offsetof(K38DogFollowKillerComponent_Authority_OnKillerMovementModeChange, PreviousCustomMode) == 0x000009, "Member 'K38DogFollowKillerComponent_Authority_OnKillerMovementModeChange::PreviousCustomMode' has a wrong offset!");

// Function TheK38.K38DogFollowKillerComponent.Authority_OnMoveCompleted
// 0x0008 (0x0008 - 0x0000)
struct K38DogFollowKillerComponent_Authority_OnMoveCompleted final
{
public:
	struct FAIRequestID                           RequestID;                                         // 0x0000(0x0004)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	EPathFollowingResult                          Result;                                            // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K38DogFollowKillerComponent_Authority_OnMoveCompleted) == 0x000004, "Wrong alignment on K38DogFollowKillerComponent_Authority_OnMoveCompleted");
static_assert(sizeof(K38DogFollowKillerComponent_Authority_OnMoveCompleted) == 0x000008, "Wrong size on K38DogFollowKillerComponent_Authority_OnMoveCompleted");
static_assert(offsetof(K38DogFollowKillerComponent_Authority_OnMoveCompleted, RequestID) == 0x000000, "Member 'K38DogFollowKillerComponent_Authority_OnMoveCompleted::RequestID' has a wrong offset!");
static_assert(offsetof(K38DogFollowKillerComponent_Authority_OnMoveCompleted, Result) == 0x000004, "Member 'K38DogFollowKillerComponent_Authority_OnMoveCompleted::Result' has a wrong offset!");

// Function TheK38.K38DogTeleportComponent.Multicast_OnDogTeleportEnd
// 0x0038 (0x0038 - 0x0000)
struct K38DogTeleportComponent_Multicast_OnDogTeleportEnd final
{
public:
	struct FVector                                StartLocation;                                     // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                endLocation;                                       // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EK38DogTeleportReasons                        Reason;                                            // 0x0030(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          skipCosmeticCall;                                  // 0x0031(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K38DogTeleportComponent_Multicast_OnDogTeleportEnd) == 0x000008, "Wrong alignment on K38DogTeleportComponent_Multicast_OnDogTeleportEnd");
static_assert(sizeof(K38DogTeleportComponent_Multicast_OnDogTeleportEnd) == 0x000038, "Wrong size on K38DogTeleportComponent_Multicast_OnDogTeleportEnd");
static_assert(offsetof(K38DogTeleportComponent_Multicast_OnDogTeleportEnd, StartLocation) == 0x000000, "Member 'K38DogTeleportComponent_Multicast_OnDogTeleportEnd::StartLocation' has a wrong offset!");
static_assert(offsetof(K38DogTeleportComponent_Multicast_OnDogTeleportEnd, endLocation) == 0x000018, "Member 'K38DogTeleportComponent_Multicast_OnDogTeleportEnd::endLocation' has a wrong offset!");
static_assert(offsetof(K38DogTeleportComponent_Multicast_OnDogTeleportEnd, Reason) == 0x000030, "Member 'K38DogTeleportComponent_Multicast_OnDogTeleportEnd::Reason' has a wrong offset!");
static_assert(offsetof(K38DogTeleportComponent_Multicast_OnDogTeleportEnd, skipCosmeticCall) == 0x000031, "Member 'K38DogTeleportComponent_Multicast_OnDogTeleportEnd::skipCosmeticCall' has a wrong offset!");

// Function TheK38.K38DogTeleportComponent.Multicast_OnDogTeleportStart
// 0x0038 (0x0038 - 0x0000)
struct K38DogTeleportComponent_Multicast_OnDogTeleportStart final
{
public:
	struct FVector                                StartLocation;                                     // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                endLocation;                                       // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EK38DogTeleportReasons                        Reason;                                            // 0x0030(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K38DogTeleportComponent_Multicast_OnDogTeleportStart) == 0x000008, "Wrong alignment on K38DogTeleportComponent_Multicast_OnDogTeleportStart");
static_assert(sizeof(K38DogTeleportComponent_Multicast_OnDogTeleportStart) == 0x000038, "Wrong size on K38DogTeleportComponent_Multicast_OnDogTeleportStart");
static_assert(offsetof(K38DogTeleportComponent_Multicast_OnDogTeleportStart, StartLocation) == 0x000000, "Member 'K38DogTeleportComponent_Multicast_OnDogTeleportStart::StartLocation' has a wrong offset!");
static_assert(offsetof(K38DogTeleportComponent_Multicast_OnDogTeleportStart, endLocation) == 0x000018, "Member 'K38DogTeleportComponent_Multicast_OnDogTeleportStart::endLocation' has a wrong offset!");
static_assert(offsetof(K38DogTeleportComponent_Multicast_OnDogTeleportStart, Reason) == 0x000030, "Member 'K38DogTeleportComponent_Multicast_OnDogTeleportStart::Reason' has a wrong offset!");

// Function TheK38.K38GroundTarget.Cosmetic_OnGroundTargetTooCloseToKillerToDeployChanged
// 0x0001 (0x0001 - 0x0000)
struct K38GroundTarget_Cosmetic_OnGroundTargetTooCloseToKillerToDeployChanged final
{
public:
	bool                                          tooCloseToKillerToDeploy;                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38GroundTarget_Cosmetic_OnGroundTargetTooCloseToKillerToDeployChanged) == 0x000001, "Wrong alignment on K38GroundTarget_Cosmetic_OnGroundTargetTooCloseToKillerToDeployChanged");
static_assert(sizeof(K38GroundTarget_Cosmetic_OnGroundTargetTooCloseToKillerToDeployChanged) == 0x000001, "Wrong size on K38GroundTarget_Cosmetic_OnGroundTargetTooCloseToKillerToDeployChanged");
static_assert(offsetof(K38GroundTarget_Cosmetic_OnGroundTargetTooCloseToKillerToDeployChanged, tooCloseToKillerToDeploy) == 0x000000, "Member 'K38GroundTarget_Cosmetic_OnGroundTargetTooCloseToKillerToDeployChanged::tooCloseToKillerToDeploy' has a wrong offset!");

// Function TheK38.K38GroundTarget.Cosmetic_OnGroundTargetVisibilityChanged
// 0x0001 (0x0001 - 0x0000)
struct K38GroundTarget_Cosmetic_OnGroundTargetVisibilityChanged final
{
public:
	bool                                          Visible;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38GroundTarget_Cosmetic_OnGroundTargetVisibilityChanged) == 0x000001, "Wrong alignment on K38GroundTarget_Cosmetic_OnGroundTargetVisibilityChanged");
static_assert(sizeof(K38GroundTarget_Cosmetic_OnGroundTargetVisibilityChanged) == 0x000001, "Wrong size on K38GroundTarget_Cosmetic_OnGroundTargetVisibilityChanged");
static_assert(offsetof(K38GroundTarget_Cosmetic_OnGroundTargetVisibilityChanged, Visible) == 0x000000, "Member 'K38GroundTarget_Cosmetic_OnGroundTargetVisibilityChanged::Visible' has a wrong offset!");

// Function TheK38.K38GroundTarget.Cosmetic_SetIsGroundTargetPositionValid
// 0x0001 (0x0001 - 0x0000)
struct K38GroundTarget_Cosmetic_SetIsGroundTargetPositionValid final
{
public:
	bool                                          isGroundTargetPlacementValid;                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38GroundTarget_Cosmetic_SetIsGroundTargetPositionValid) == 0x000001, "Wrong alignment on K38GroundTarget_Cosmetic_SetIsGroundTargetPositionValid");
static_assert(sizeof(K38GroundTarget_Cosmetic_SetIsGroundTargetPositionValid) == 0x000001, "Wrong size on K38GroundTarget_Cosmetic_SetIsGroundTargetPositionValid");
static_assert(offsetof(K38GroundTarget_Cosmetic_SetIsGroundTargetPositionValid, isGroundTargetPlacementValid) == 0x000000, "Member 'K38GroundTarget_Cosmetic_SetIsGroundTargetPositionValid::isGroundTargetPlacementValid' has a wrong offset!");

// Function TheK38.K38GroundTarget.Multicast_SetTargetLocation
// 0x0020 (0x0020 - 0x0000)
struct K38GroundTarget_Multicast_SetTargetLocation final
{
public:
	struct FVector_NetQuantize                    targetLocation;                                    // 0x0000(0x0018)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isValidLocation;                                   // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K38GroundTarget_Multicast_SetTargetLocation) == 0x000008, "Wrong alignment on K38GroundTarget_Multicast_SetTargetLocation");
static_assert(sizeof(K38GroundTarget_Multicast_SetTargetLocation) == 0x000020, "Wrong size on K38GroundTarget_Multicast_SetTargetLocation");
static_assert(offsetof(K38GroundTarget_Multicast_SetTargetLocation, targetLocation) == 0x000000, "Member 'K38GroundTarget_Multicast_SetTargetLocation::targetLocation' has a wrong offset!");
static_assert(offsetof(K38GroundTarget_Multicast_SetTargetLocation, isValidLocation) == 0x000018, "Member 'K38GroundTarget_Multicast_SetTargetLocation::isValidLocation' has a wrong offset!");

// Function TheK38.K38GroundTarget.OnLocallyObservedChanged
// 0x0001 (0x0001 - 0x0000)
struct K38GroundTarget_OnLocallyObservedChanged final
{
public:
	bool                                          isPlayerLocallyObserved;                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38GroundTarget_OnLocallyObservedChanged) == 0x000001, "Wrong alignment on K38GroundTarget_OnLocallyObservedChanged");
static_assert(sizeof(K38GroundTarget_OnLocallyObservedChanged) == 0x000001, "Wrong size on K38GroundTarget_OnLocallyObservedChanged");
static_assert(offsetof(K38GroundTarget_OnLocallyObservedChanged, isPlayerLocallyObserved) == 0x000000, "Member 'K38GroundTarget_OnLocallyObservedChanged::isPlayerLocallyObserved' has a wrong offset!");

// Function TheK38.K38GroundTarget.Server_SetTargetLocation
// 0x0020 (0x0020 - 0x0000)
struct K38GroundTarget_Server_SetTargetLocation final
{
public:
	struct FVector_NetQuantize                    targetLocation;                                    // 0x0000(0x0018)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isValidLocation;                                   // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K38GroundTarget_Server_SetTargetLocation) == 0x000008, "Wrong alignment on K38GroundTarget_Server_SetTargetLocation");
static_assert(sizeof(K38GroundTarget_Server_SetTargetLocation) == 0x000020, "Wrong size on K38GroundTarget_Server_SetTargetLocation");
static_assert(offsetof(K38GroundTarget_Server_SetTargetLocation, targetLocation) == 0x000000, "Member 'K38GroundTarget_Server_SetTargetLocation::targetLocation' has a wrong offset!");
static_assert(offsetof(K38GroundTarget_Server_SetTargetLocation, isValidLocation) == 0x000018, "Member 'K38GroundTarget_Server_SetTargetLocation::isValidLocation' has a wrong offset!");

// Function TheK38.K38GroundTarget.GetGroundTargetDistancePercentToKiller
// 0x0004 (0x0004 - 0x0000)
struct K38GroundTarget_GetGroundTargetDistancePercentToKiller final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38GroundTarget_GetGroundTargetDistancePercentToKiller) == 0x000004, "Wrong alignment on K38GroundTarget_GetGroundTargetDistancePercentToKiller");
static_assert(sizeof(K38GroundTarget_GetGroundTargetDistancePercentToKiller) == 0x000004, "Wrong size on K38GroundTarget_GetGroundTargetDistancePercentToKiller");
static_assert(offsetof(K38GroundTarget_GetGroundTargetDistancePercentToKiller, ReturnValue) == 0x000000, "Member 'K38GroundTarget_GetGroundTargetDistancePercentToKiller::ReturnValue' has a wrong offset!");

// Function TheK38.K38GroundTarget.GetGroundTargetDistanceToKiller
// 0x0004 (0x0004 - 0x0000)
struct K38GroundTarget_GetGroundTargetDistanceToKiller final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38GroundTarget_GetGroundTargetDistanceToKiller) == 0x000004, "Wrong alignment on K38GroundTarget_GetGroundTargetDistanceToKiller");
static_assert(sizeof(K38GroundTarget_GetGroundTargetDistanceToKiller) == 0x000004, "Wrong size on K38GroundTarget_GetGroundTargetDistanceToKiller");
static_assert(offsetof(K38GroundTarget_GetGroundTargetDistanceToKiller, ReturnValue) == 0x000000, "Member 'K38GroundTarget_GetGroundTargetDistanceToKiller::ReturnValue' has a wrong offset!");

// Function TheK38.K38HoldingSurvivorDogState.Authority_OnSurvivorHeldGameStateChanged
// 0x0010 (0x0010 - 0x0000)
struct K38HoldingSurvivorDogState_Authority_OnSurvivorHeldGameStateChanged final
{
public:
	class ADBDPlayerState*                        PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameState                                    GameState;                                         // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K38HoldingSurvivorDogState_Authority_OnSurvivorHeldGameStateChanged) == 0x000008, "Wrong alignment on K38HoldingSurvivorDogState_Authority_OnSurvivorHeldGameStateChanged");
static_assert(sizeof(K38HoldingSurvivorDogState_Authority_OnSurvivorHeldGameStateChanged) == 0x000010, "Wrong size on K38HoldingSurvivorDogState_Authority_OnSurvivorHeldGameStateChanged");
static_assert(offsetof(K38HoldingSurvivorDogState_Authority_OnSurvivorHeldGameStateChanged, PlayerState) == 0x000000, "Member 'K38HoldingSurvivorDogState_Authority_OnSurvivorHeldGameStateChanged::PlayerState' has a wrong offset!");
static_assert(offsetof(K38HoldingSurvivorDogState_Authority_OnSurvivorHeldGameStateChanged, GameState) == 0x000008, "Member 'K38HoldingSurvivorDogState_Authority_OnSurvivorHeldGameStateChanged::GameState' has a wrong offset!");

// Function TheK38.K38KillerInstinctLingeringEffect.Authority_OnSurvivorCrouchChanged
// 0x0040 (0x0040 - 0x0000)
struct K38KillerInstinctLingeringEffect_Authority_OnSurvivorCrouchChanged final
{
public:
	struct FGameplayTag                           GameEvent;                                         // 0x0000(0x000C)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameEventData                         GameEventData;                                     // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38KillerInstinctLingeringEffect_Authority_OnSurvivorCrouchChanged) == 0x000008, "Wrong alignment on K38KillerInstinctLingeringEffect_Authority_OnSurvivorCrouchChanged");
static_assert(sizeof(K38KillerInstinctLingeringEffect_Authority_OnSurvivorCrouchChanged) == 0x000040, "Wrong size on K38KillerInstinctLingeringEffect_Authority_OnSurvivorCrouchChanged");
static_assert(offsetof(K38KillerInstinctLingeringEffect_Authority_OnSurvivorCrouchChanged, GameEvent) == 0x000000, "Member 'K38KillerInstinctLingeringEffect_Authority_OnSurvivorCrouchChanged::GameEvent' has a wrong offset!");
static_assert(offsetof(K38KillerInstinctLingeringEffect_Authority_OnSurvivorCrouchChanged, GameEventData) == 0x000010, "Member 'K38KillerInstinctLingeringEffect_Authority_OnSurvivorCrouchChanged::GameEventData' has a wrong offset!");

// Function TheK38.K38MoveToTargetLocationDogState.Authority_OnMoveCompleted
// 0x0008 (0x0008 - 0x0000)
struct K38MoveToTargetLocationDogState_Authority_OnMoveCompleted final
{
public:
	struct FAIRequestID                           RequestID;                                         // 0x0000(0x0004)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	EPathFollowingResult                          Result;                                            // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K38MoveToTargetLocationDogState_Authority_OnMoveCompleted) == 0x000004, "Wrong alignment on K38MoveToTargetLocationDogState_Authority_OnMoveCompleted");
static_assert(sizeof(K38MoveToTargetLocationDogState_Authority_OnMoveCompleted) == 0x000008, "Wrong size on K38MoveToTargetLocationDogState_Authority_OnMoveCompleted");
static_assert(offsetof(K38MoveToTargetLocationDogState_Authority_OnMoveCompleted, RequestID) == 0x000000, "Member 'K38MoveToTargetLocationDogState_Authority_OnMoveCompleted::RequestID' has a wrong offset!");
static_assert(offsetof(K38MoveToTargetLocationDogState_Authority_OnMoveCompleted, Result) == 0x000004, "Member 'K38MoveToTargetLocationDogState_Authority_OnMoveCompleted::Result' has a wrong offset!");

// Function TheK38.K38ObjectiveAimAssistTarget.Cosmetic_OnAimAssistObjectiveSelected
// 0x0010 (0x0010 - 0x0000)
struct K38ObjectiveAimAssistTarget_Cosmetic_OnAimAssistObjectiveSelected final
{
public:
	class AActor*                                 selectedObject;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AKiller*                                Killer;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38ObjectiveAimAssistTarget_Cosmetic_OnAimAssistObjectiveSelected) == 0x000008, "Wrong alignment on K38ObjectiveAimAssistTarget_Cosmetic_OnAimAssistObjectiveSelected");
static_assert(sizeof(K38ObjectiveAimAssistTarget_Cosmetic_OnAimAssistObjectiveSelected) == 0x000010, "Wrong size on K38ObjectiveAimAssistTarget_Cosmetic_OnAimAssistObjectiveSelected");
static_assert(offsetof(K38ObjectiveAimAssistTarget_Cosmetic_OnAimAssistObjectiveSelected, selectedObject) == 0x000000, "Member 'K38ObjectiveAimAssistTarget_Cosmetic_OnAimAssistObjectiveSelected::selectedObject' has a wrong offset!");
static_assert(offsetof(K38ObjectiveAimAssistTarget_Cosmetic_OnAimAssistObjectiveSelected, Killer) == 0x000008, "Member 'K38ObjectiveAimAssistTarget_Cosmetic_OnAimAssistObjectiveSelected::Killer' has a wrong offset!");

// Function TheK38.K38ObjectiveAimAssistTarget.Multicast_SetSelectedObjective
// 0x0008 (0x0008 - 0x0000)
struct K38ObjectiveAimAssistTarget_Multicast_SetSelectedObjective final
{
public:
	class AActor*                                 newSelectedObjective;                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38ObjectiveAimAssistTarget_Multicast_SetSelectedObjective) == 0x000008, "Wrong alignment on K38ObjectiveAimAssistTarget_Multicast_SetSelectedObjective");
static_assert(sizeof(K38ObjectiveAimAssistTarget_Multicast_SetSelectedObjective) == 0x000008, "Wrong size on K38ObjectiveAimAssistTarget_Multicast_SetSelectedObjective");
static_assert(offsetof(K38ObjectiveAimAssistTarget_Multicast_SetSelectedObjective, newSelectedObjective) == 0x000000, "Member 'K38ObjectiveAimAssistTarget_Multicast_SetSelectedObjective::newSelectedObjective' has a wrong offset!");

// Function TheK38.K38ObjectiveAimAssistTarget.Server_SetSelectedObjective
// 0x0008 (0x0008 - 0x0000)
struct K38ObjectiveAimAssistTarget_Server_SetSelectedObjective final
{
public:
	class AActor*                                 newSelectedObjective;                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38ObjectiveAimAssistTarget_Server_SetSelectedObjective) == 0x000008, "Wrong alignment on K38ObjectiveAimAssistTarget_Server_SetSelectedObjective");
static_assert(sizeof(K38ObjectiveAimAssistTarget_Server_SetSelectedObjective) == 0x000008, "Wrong size on K38ObjectiveAimAssistTarget_Server_SetSelectedObjective");
static_assert(offsetof(K38ObjectiveAimAssistTarget_Server_SetSelectedObjective, newSelectedObjective) == 0x000000, "Member 'K38ObjectiveAimAssistTarget_Server_SetSelectedObjective::newSelectedObjective' has a wrong offset!");

// Function TheK38.K38P01.Cosmetic_OnStaggeringLanding
// 0x0008 (0x0008 - 0x0000)
struct K38P01_Cosmetic_OnStaggeringLanding final
{
public:
	class AKiller*                                Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38P01_Cosmetic_OnStaggeringLanding) == 0x000008, "Wrong alignment on K38P01_Cosmetic_OnStaggeringLanding");
static_assert(sizeof(K38P01_Cosmetic_OnStaggeringLanding) == 0x000008, "Wrong size on K38P01_Cosmetic_OnStaggeringLanding");
static_assert(offsetof(K38P01_Cosmetic_OnStaggeringLanding, Killer) == 0x000000, "Member 'K38P01_Cosmetic_OnStaggeringLanding::Killer' has a wrong offset!");

// Function TheK38.K38P01.Multicast_OnK38P01Landing
// 0x0008 (0x0008 - 0x0000)
struct K38P01_Multicast_OnK38P01Landing final
{
public:
	class AKiller*                                Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38P01_Multicast_OnK38P01Landing) == 0x000008, "Wrong alignment on K38P01_Multicast_OnK38P01Landing");
static_assert(sizeof(K38P01_Multicast_OnK38P01Landing) == 0x000008, "Wrong size on K38P01_Multicast_OnK38P01Landing");
static_assert(offsetof(K38P01_Multicast_OnK38P01Landing, Player) == 0x000000, "Member 'K38P01_Multicast_OnK38P01Landing::Player' has a wrong offset!");

// Function TheK38.K38P02.Authority_OnSurvivorHookedOnScourgeHook
// 0x0030 (0x0030 - 0x0000)
struct K38P02_Authority_OnSurvivorHookedOnScourgeHook final
{
public:
	struct FGameEventData                         GameEventData;                                     // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38P02_Authority_OnSurvivorHookedOnScourgeHook) == 0x000008, "Wrong alignment on K38P02_Authority_OnSurvivorHookedOnScourgeHook");
static_assert(sizeof(K38P02_Authority_OnSurvivorHookedOnScourgeHook) == 0x000030, "Wrong size on K38P02_Authority_OnSurvivorHookedOnScourgeHook");
static_assert(offsetof(K38P02_Authority_OnSurvivorHookedOnScourgeHook, GameEventData) == 0x000000, "Member 'K38P02_Authority_OnSurvivorHookedOnScourgeHook::GameEventData' has a wrong offset!");

// Function TheK38.K38P02.Cosmetic_NewScourgeHookEvent
// 0x0010 (0x0010 - 0x0000)
struct K38P02_Cosmetic_NewScourgeHookEvent final
{
public:
	class AKiller*                                Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMeatHook*                              Hook;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38P02_Cosmetic_NewScourgeHookEvent) == 0x000008, "Wrong alignment on K38P02_Cosmetic_NewScourgeHookEvent");
static_assert(sizeof(K38P02_Cosmetic_NewScourgeHookEvent) == 0x000010, "Wrong size on K38P02_Cosmetic_NewScourgeHookEvent");
static_assert(offsetof(K38P02_Cosmetic_NewScourgeHookEvent, Killer) == 0x000000, "Member 'K38P02_Cosmetic_NewScourgeHookEvent::Killer' has a wrong offset!");
static_assert(offsetof(K38P02_Cosmetic_NewScourgeHookEvent, Hook) == 0x000008, "Member 'K38P02_Cosmetic_NewScourgeHookEvent::Hook' has a wrong offset!");

// Function TheK38.K38P02.Multicast_NewScourgeHookEvent
// 0x0010 (0x0010 - 0x0000)
struct K38P02_Multicast_NewScourgeHookEvent final
{
public:
	class AKiller*                                Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMeatHook*                              Hook;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38P02_Multicast_NewScourgeHookEvent) == 0x000008, "Wrong alignment on K38P02_Multicast_NewScourgeHookEvent");
static_assert(sizeof(K38P02_Multicast_NewScourgeHookEvent) == 0x000010, "Wrong size on K38P02_Multicast_NewScourgeHookEvent");
static_assert(offsetof(K38P02_Multicast_NewScourgeHookEvent, Killer) == 0x000000, "Member 'K38P02_Multicast_NewScourgeHookEvent::Killer' has a wrong offset!");
static_assert(offsetof(K38P02_Multicast_NewScourgeHookEvent, Hook) == 0x000008, "Member 'K38P02_Multicast_NewScourgeHookEvent::Hook' has a wrong offset!");

// Function TheK38.K38P02.GetGeneratorRevealDurationAtLevel
// 0x0004 (0x0004 - 0x0000)
struct K38P02_GetGeneratorRevealDurationAtLevel final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38P02_GetGeneratorRevealDurationAtLevel) == 0x000004, "Wrong alignment on K38P02_GetGeneratorRevealDurationAtLevel");
static_assert(sizeof(K38P02_GetGeneratorRevealDurationAtLevel) == 0x000004, "Wrong size on K38P02_GetGeneratorRevealDurationAtLevel");
static_assert(offsetof(K38P02_GetGeneratorRevealDurationAtLevel, ReturnValue) == 0x000000, "Member 'K38P02_GetGeneratorRevealDurationAtLevel::ReturnValue' has a wrong offset!");

// Function TheK38.K38P03.Authority_OnSelfHealInteractionFinished
// 0x0010 (0x0010 - 0x0000)
struct K38P03_Authority_OnSelfHealInteractionFinished final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          hasInteractionStarted;                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K38P03_Authority_OnSelfHealInteractionFinished) == 0x000008, "Wrong alignment on K38P03_Authority_OnSelfHealInteractionFinished");
static_assert(sizeof(K38P03_Authority_OnSelfHealInteractionFinished) == 0x000010, "Wrong size on K38P03_Authority_OnSelfHealInteractionFinished");
static_assert(offsetof(K38P03_Authority_OnSelfHealInteractionFinished, Player) == 0x000000, "Member 'K38P03_Authority_OnSelfHealInteractionFinished::Player' has a wrong offset!");
static_assert(offsetof(K38P03_Authority_OnSelfHealInteractionFinished, hasInteractionStarted) == 0x000008, "Member 'K38P03_Authority_OnSelfHealInteractionFinished::hasInteractionStarted' has a wrong offset!");

// Function TheK38.K38P03.Multicast_ActivateSkillCheck
// 0x0008 (0x0008 - 0x0000)
struct K38P03_Multicast_ActivateSkillCheck final
{
public:
	class ADBDPlayer*                             Survivor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38P03_Multicast_ActivateSkillCheck) == 0x000008, "Wrong alignment on K38P03_Multicast_ActivateSkillCheck");
static_assert(sizeof(K38P03_Multicast_ActivateSkillCheck) == 0x000008, "Wrong size on K38P03_Multicast_ActivateSkillCheck");
static_assert(offsetof(K38P03_Multicast_ActivateSkillCheck, Survivor) == 0x000000, "Member 'K38P03_Multicast_ActivateSkillCheck::Survivor' has a wrong offset!");

// Function TheK38.K38P03.GetBrokenStatusDurationAtLevel
// 0x0004 (0x0004 - 0x0000)
struct K38P03_GetBrokenStatusDurationAtLevel final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38P03_GetBrokenStatusDurationAtLevel) == 0x000004, "Wrong alignment on K38P03_GetBrokenStatusDurationAtLevel");
static_assert(sizeof(K38P03_GetBrokenStatusDurationAtLevel) == 0x000004, "Wrong size on K38P03_GetBrokenStatusDurationAtLevel");
static_assert(offsetof(K38P03_GetBrokenStatusDurationAtLevel, ReturnValue) == 0x000000, "Member 'K38P03_GetBrokenStatusDurationAtLevel::ReturnValue' has a wrong offset!");

// Function TheK38.K38PatrolPathNode.Cosmetic_OnFollowPatrolPathChanged
// 0x0001 (0x0001 - 0x0000)
struct K38PatrolPathNode_Cosmetic_OnFollowPatrolPathChanged final
{
public:
	bool                                          patrolPathFollowed;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38PatrolPathNode_Cosmetic_OnFollowPatrolPathChanged) == 0x000001, "Wrong alignment on K38PatrolPathNode_Cosmetic_OnFollowPatrolPathChanged");
static_assert(sizeof(K38PatrolPathNode_Cosmetic_OnFollowPatrolPathChanged) == 0x000001, "Wrong size on K38PatrolPathNode_Cosmetic_OnFollowPatrolPathChanged");
static_assert(offsetof(K38PatrolPathNode_Cosmetic_OnFollowPatrolPathChanged, patrolPathFollowed) == 0x000000, "Member 'K38PatrolPathNode_Cosmetic_OnFollowPatrolPathChanged::patrolPathFollowed' has a wrong offset!");

// Function TheK38.K38PatrolPathNode.OnPatrolPathFollowedChanged
// 0x0001 (0x0001 - 0x0000)
struct K38PatrolPathNode_OnPatrolPathFollowedChanged final
{
public:
	bool                                          isOnPatrolPath;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38PatrolPathNode_OnPatrolPathFollowedChanged) == 0x000001, "Wrong alignment on K38PatrolPathNode_OnPatrolPathFollowedChanged");
static_assert(sizeof(K38PatrolPathNode_OnPatrolPathFollowedChanged) == 0x000001, "Wrong size on K38PatrolPathNode_OnPatrolPathFollowedChanged");
static_assert(offsetof(K38PatrolPathNode_OnPatrolPathFollowedChanged, isOnPatrolPath) == 0x000000, "Member 'K38PatrolPathNode_OnPatrolPathFollowedChanged::isOnPatrolPath' has a wrong offset!");

// Function TheK38.K38PatrolPathNode.IsFirstNode
// 0x0001 (0x0001 - 0x0000)
struct K38PatrolPathNode_IsFirstNode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38PatrolPathNode_IsFirstNode) == 0x000001, "Wrong alignment on K38PatrolPathNode_IsFirstNode");
static_assert(sizeof(K38PatrolPathNode_IsFirstNode) == 0x000001, "Wrong size on K38PatrolPathNode_IsFirstNode");
static_assert(offsetof(K38PatrolPathNode_IsFirstNode, ReturnValue) == 0x000000, "Member 'K38PatrolPathNode_IsFirstNode::ReturnValue' has a wrong offset!");

// Function TheK38.K38Power.Cosmetic_OnAimCommandSwitched
// 0x0010 (0x0010 - 0x0000)
struct K38Power_Cosmetic_OnAimCommandSwitched final
{
public:
	const class AKiller*                          Killer;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          switchToPatrol;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K38Power_Cosmetic_OnAimCommandSwitched) == 0x000008, "Wrong alignment on K38Power_Cosmetic_OnAimCommandSwitched");
static_assert(sizeof(K38Power_Cosmetic_OnAimCommandSwitched) == 0x000010, "Wrong size on K38Power_Cosmetic_OnAimCommandSwitched");
static_assert(offsetof(K38Power_Cosmetic_OnAimCommandSwitched, Killer) == 0x000000, "Member 'K38Power_Cosmetic_OnAimCommandSwitched::Killer' has a wrong offset!");
static_assert(offsetof(K38Power_Cosmetic_OnAimCommandSwitched, switchToPatrol) == 0x000008, "Member 'K38Power_Cosmetic_OnAimCommandSwitched::switchToPatrol' has a wrong offset!");

// Function TheK38.K38Power.Cosmetic_OnAimDashActivated
// 0x0010 (0x0010 - 0x0000)
struct K38Power_Cosmetic_OnAimDashActivated final
{
public:
	const class AKiller*                          killerPlayer;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AK38Dog*                          dog;                                               // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38Power_Cosmetic_OnAimDashActivated) == 0x000008, "Wrong alignment on K38Power_Cosmetic_OnAimDashActivated");
static_assert(sizeof(K38Power_Cosmetic_OnAimDashActivated) == 0x000010, "Wrong size on K38Power_Cosmetic_OnAimDashActivated");
static_assert(offsetof(K38Power_Cosmetic_OnAimDashActivated, killerPlayer) == 0x000000, "Member 'K38Power_Cosmetic_OnAimDashActivated::killerPlayer' has a wrong offset!");
static_assert(offsetof(K38Power_Cosmetic_OnAimDashActivated, dog) == 0x000008, "Member 'K38Power_Cosmetic_OnAimDashActivated::dog' has a wrong offset!");

// Function TheK38.K38Power.Cosmetic_OnAimDashChargeCancelled
// 0x0010 (0x0010 - 0x0000)
struct K38Power_Cosmetic_OnAimDashChargeCancelled final
{
public:
	const class AKiller*                          killerPlayer;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AK38Dog*                          dog;                                               // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38Power_Cosmetic_OnAimDashChargeCancelled) == 0x000008, "Wrong alignment on K38Power_Cosmetic_OnAimDashChargeCancelled");
static_assert(sizeof(K38Power_Cosmetic_OnAimDashChargeCancelled) == 0x000010, "Wrong size on K38Power_Cosmetic_OnAimDashChargeCancelled");
static_assert(offsetof(K38Power_Cosmetic_OnAimDashChargeCancelled, killerPlayer) == 0x000000, "Member 'K38Power_Cosmetic_OnAimDashChargeCancelled::killerPlayer' has a wrong offset!");
static_assert(offsetof(K38Power_Cosmetic_OnAimDashChargeCancelled, dog) == 0x000008, "Member 'K38Power_Cosmetic_OnAimDashChargeCancelled::dog' has a wrong offset!");

// Function TheK38.K38Power.Cosmetic_OnAimDashChargeComplete
// 0x0010 (0x0010 - 0x0000)
struct K38Power_Cosmetic_OnAimDashChargeComplete final
{
public:
	const class AKiller*                          killerPlayer;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AK38Dog*                          dog;                                               // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38Power_Cosmetic_OnAimDashChargeComplete) == 0x000008, "Wrong alignment on K38Power_Cosmetic_OnAimDashChargeComplete");
static_assert(sizeof(K38Power_Cosmetic_OnAimDashChargeComplete) == 0x000010, "Wrong size on K38Power_Cosmetic_OnAimDashChargeComplete");
static_assert(offsetof(K38Power_Cosmetic_OnAimDashChargeComplete, killerPlayer) == 0x000000, "Member 'K38Power_Cosmetic_OnAimDashChargeComplete::killerPlayer' has a wrong offset!");
static_assert(offsetof(K38Power_Cosmetic_OnAimDashChargeComplete, dog) == 0x000008, "Member 'K38Power_Cosmetic_OnAimDashChargeComplete::dog' has a wrong offset!");

// Function TheK38.K38Power.Cosmetic_OnAimPatrolActivated
// 0x0010 (0x0010 - 0x0000)
struct K38Power_Cosmetic_OnAimPatrolActivated final
{
public:
	const class AKiller*                          killerPlayer;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AK38Dog*                          dog;                                               // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38Power_Cosmetic_OnAimPatrolActivated) == 0x000008, "Wrong alignment on K38Power_Cosmetic_OnAimPatrolActivated");
static_assert(sizeof(K38Power_Cosmetic_OnAimPatrolActivated) == 0x000010, "Wrong size on K38Power_Cosmetic_OnAimPatrolActivated");
static_assert(offsetof(K38Power_Cosmetic_OnAimPatrolActivated, killerPlayer) == 0x000000, "Member 'K38Power_Cosmetic_OnAimPatrolActivated::killerPlayer' has a wrong offset!");
static_assert(offsetof(K38Power_Cosmetic_OnAimPatrolActivated, dog) == 0x000008, "Member 'K38Power_Cosmetic_OnAimPatrolActivated::dog' has a wrong offset!");

// Function TheK38.K38Power.Cosmetic_OnAimPatrolChargeCancelled
// 0x0010 (0x0010 - 0x0000)
struct K38Power_Cosmetic_OnAimPatrolChargeCancelled final
{
public:
	const class AKiller*                          killerPlayer;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AK38Dog*                          dog;                                               // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38Power_Cosmetic_OnAimPatrolChargeCancelled) == 0x000008, "Wrong alignment on K38Power_Cosmetic_OnAimPatrolChargeCancelled");
static_assert(sizeof(K38Power_Cosmetic_OnAimPatrolChargeCancelled) == 0x000010, "Wrong size on K38Power_Cosmetic_OnAimPatrolChargeCancelled");
static_assert(offsetof(K38Power_Cosmetic_OnAimPatrolChargeCancelled, killerPlayer) == 0x000000, "Member 'K38Power_Cosmetic_OnAimPatrolChargeCancelled::killerPlayer' has a wrong offset!");
static_assert(offsetof(K38Power_Cosmetic_OnAimPatrolChargeCancelled, dog) == 0x000008, "Member 'K38Power_Cosmetic_OnAimPatrolChargeCancelled::dog' has a wrong offset!");

// Function TheK38.K38Power.Cosmetic_OnAimPatrolChargeComplete
// 0x0010 (0x0010 - 0x0000)
struct K38Power_Cosmetic_OnAimPatrolChargeComplete final
{
public:
	const class AKiller*                          killerPlayer;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AK38Dog*                          dog;                                               // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38Power_Cosmetic_OnAimPatrolChargeComplete) == 0x000008, "Wrong alignment on K38Power_Cosmetic_OnAimPatrolChargeComplete");
static_assert(sizeof(K38Power_Cosmetic_OnAimPatrolChargeComplete) == 0x000010, "Wrong size on K38Power_Cosmetic_OnAimPatrolChargeComplete");
static_assert(offsetof(K38Power_Cosmetic_OnAimPatrolChargeComplete, killerPlayer) == 0x000000, "Member 'K38Power_Cosmetic_OnAimPatrolChargeComplete::killerPlayer' has a wrong offset!");
static_assert(offsetof(K38Power_Cosmetic_OnAimPatrolChargeComplete, dog) == 0x000008, "Member 'K38Power_Cosmetic_OnAimPatrolChargeComplete::dog' has a wrong offset!");

// Function TheK38.K38Power.Cosmetic_OnAimReady
// 0x0008 (0x0008 - 0x0000)
struct K38Power_Cosmetic_OnAimReady final
{
public:
	const class AKiller*                          Killer;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38Power_Cosmetic_OnAimReady) == 0x000008, "Wrong alignment on K38Power_Cosmetic_OnAimReady");
static_assert(sizeof(K38Power_Cosmetic_OnAimReady) == 0x000008, "Wrong size on K38Power_Cosmetic_OnAimReady");
static_assert(offsetof(K38Power_Cosmetic_OnAimReady, Killer) == 0x000000, "Member 'K38Power_Cosmetic_OnAimReady::Killer' has a wrong offset!");

// Function TheK38.K38Power.Cosmetic_OnKillerEffectActivated
// 0x0010 (0x0010 - 0x0000)
struct K38Power_Cosmetic_OnKillerEffectActivated final
{
public:
	const class AK38Dog*                          dog;                                               // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class ASurvivor*                        Survivor;                                          // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38Power_Cosmetic_OnKillerEffectActivated) == 0x000008, "Wrong alignment on K38Power_Cosmetic_OnKillerEffectActivated");
static_assert(sizeof(K38Power_Cosmetic_OnKillerEffectActivated) == 0x000010, "Wrong size on K38Power_Cosmetic_OnKillerEffectActivated");
static_assert(offsetof(K38Power_Cosmetic_OnKillerEffectActivated, dog) == 0x000000, "Member 'K38Power_Cosmetic_OnKillerEffectActivated::dog' has a wrong offset!");
static_assert(offsetof(K38Power_Cosmetic_OnKillerEffectActivated, Survivor) == 0x000008, "Member 'K38Power_Cosmetic_OnKillerEffectActivated::Survivor' has a wrong offset!");

// Function TheK38.K38Power.Cosmetic_OnKillerRecallDog
// 0x0008 (0x0008 - 0x0000)
struct K38Power_Cosmetic_OnKillerRecallDog final
{
public:
	const class AK38Dog*                          dog;                                               // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38Power_Cosmetic_OnKillerRecallDog) == 0x000008, "Wrong alignment on K38Power_Cosmetic_OnKillerRecallDog");
static_assert(sizeof(K38Power_Cosmetic_OnKillerRecallDog) == 0x000008, "Wrong size on K38Power_Cosmetic_OnKillerRecallDog");
static_assert(offsetof(K38Power_Cosmetic_OnKillerRecallDog, dog) == 0x000000, "Member 'K38Power_Cosmetic_OnKillerRecallDog::dog' has a wrong offset!");

// Function TheK38.K38Power.Cosmetic_OnPatrolDetectionRadiusMax
// 0x0010 (0x0010 - 0x0000)
struct K38Power_Cosmetic_OnPatrolDetectionRadiusMax final
{
public:
	const class AKiller*                          killerPlayer;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AK38Dog*                          dog;                                               // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38Power_Cosmetic_OnPatrolDetectionRadiusMax) == 0x000008, "Wrong alignment on K38Power_Cosmetic_OnPatrolDetectionRadiusMax");
static_assert(sizeof(K38Power_Cosmetic_OnPatrolDetectionRadiusMax) == 0x000010, "Wrong size on K38Power_Cosmetic_OnPatrolDetectionRadiusMax");
static_assert(offsetof(K38Power_Cosmetic_OnPatrolDetectionRadiusMax, killerPlayer) == 0x000000, "Member 'K38Power_Cosmetic_OnPatrolDetectionRadiusMax::killerPlayer' has a wrong offset!");
static_assert(offsetof(K38Power_Cosmetic_OnPatrolDetectionRadiusMax, dog) == 0x000008, "Member 'K38Power_Cosmetic_OnPatrolDetectionRadiusMax::dog' has a wrong offset!");

// Function TheK38.K38Power.Cosmetic_OnRedirectActivated
// 0x0010 (0x0010 - 0x0000)
struct K38Power_Cosmetic_OnRedirectActivated final
{
public:
	const class AKiller*                          killerPlayer;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AK38Dog*                          dog;                                               // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38Power_Cosmetic_OnRedirectActivated) == 0x000008, "Wrong alignment on K38Power_Cosmetic_OnRedirectActivated");
static_assert(sizeof(K38Power_Cosmetic_OnRedirectActivated) == 0x000010, "Wrong size on K38Power_Cosmetic_OnRedirectActivated");
static_assert(offsetof(K38Power_Cosmetic_OnRedirectActivated, killerPlayer) == 0x000000, "Member 'K38Power_Cosmetic_OnRedirectActivated::killerPlayer' has a wrong offset!");
static_assert(offsetof(K38Power_Cosmetic_OnRedirectActivated, dog) == 0x000008, "Member 'K38Power_Cosmetic_OnRedirectActivated::dog' has a wrong offset!");

// Function TheK38.K38Power.Cosmetic_OnRedirectCancelled
// 0x0010 (0x0010 - 0x0000)
struct K38Power_Cosmetic_OnRedirectCancelled final
{
public:
	const class AKiller*                          killerPlayer;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AK38Dog*                          dog;                                               // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38Power_Cosmetic_OnRedirectCancelled) == 0x000008, "Wrong alignment on K38Power_Cosmetic_OnRedirectCancelled");
static_assert(sizeof(K38Power_Cosmetic_OnRedirectCancelled) == 0x000010, "Wrong size on K38Power_Cosmetic_OnRedirectCancelled");
static_assert(offsetof(K38Power_Cosmetic_OnRedirectCancelled, killerPlayer) == 0x000000, "Member 'K38Power_Cosmetic_OnRedirectCancelled::killerPlayer' has a wrong offset!");
static_assert(offsetof(K38Power_Cosmetic_OnRedirectCancelled, dog) == 0x000008, "Member 'K38Power_Cosmetic_OnRedirectCancelled::dog' has a wrong offset!");

// Function TheK38.K38Power.Cosmetic_OnRedirectDogStruggleInteractionCooldownComplete
// 0x0008 (0x0008 - 0x0000)
struct K38Power_Cosmetic_OnRedirectDogStruggleInteractionCooldownComplete final
{
public:
	class AKiller*                                killerPlayer;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38Power_Cosmetic_OnRedirectDogStruggleInteractionCooldownComplete) == 0x000008, "Wrong alignment on K38Power_Cosmetic_OnRedirectDogStruggleInteractionCooldownComplete");
static_assert(sizeof(K38Power_Cosmetic_OnRedirectDogStruggleInteractionCooldownComplete) == 0x000008, "Wrong size on K38Power_Cosmetic_OnRedirectDogStruggleInteractionCooldownComplete");
static_assert(offsetof(K38Power_Cosmetic_OnRedirectDogStruggleInteractionCooldownComplete, killerPlayer) == 0x000000, "Member 'K38Power_Cosmetic_OnRedirectDogStruggleInteractionCooldownComplete::killerPlayer' has a wrong offset!");

// Function TheK38.K38Power.Cosmetic_OnRedirectDogStruggleTargetLocationChanged
// 0x0008 (0x0008 - 0x0000)
struct K38Power_Cosmetic_OnRedirectDogStruggleTargetLocationChanged final
{
public:
	class AKiller*                                killerPlayer;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38Power_Cosmetic_OnRedirectDogStruggleTargetLocationChanged) == 0x000008, "Wrong alignment on K38Power_Cosmetic_OnRedirectDogStruggleTargetLocationChanged");
static_assert(sizeof(K38Power_Cosmetic_OnRedirectDogStruggleTargetLocationChanged) == 0x000008, "Wrong size on K38Power_Cosmetic_OnRedirectDogStruggleTargetLocationChanged");
static_assert(offsetof(K38Power_Cosmetic_OnRedirectDogStruggleTargetLocationChanged, killerPlayer) == 0x000000, "Member 'K38Power_Cosmetic_OnRedirectDogStruggleTargetLocationChanged::killerPlayer' has a wrong offset!");

// Function TheK38.K38Power.Cosmetic_OnRedirectStarted
// 0x0010 (0x0010 - 0x0000)
struct K38Power_Cosmetic_OnRedirectStarted final
{
public:
	const class AKiller*                          killerPlayer;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AK38Dog*                          dog;                                               // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38Power_Cosmetic_OnRedirectStarted) == 0x000008, "Wrong alignment on K38Power_Cosmetic_OnRedirectStarted");
static_assert(sizeof(K38Power_Cosmetic_OnRedirectStarted) == 0x000010, "Wrong size on K38Power_Cosmetic_OnRedirectStarted");
static_assert(offsetof(K38Power_Cosmetic_OnRedirectStarted, killerPlayer) == 0x000000, "Member 'K38Power_Cosmetic_OnRedirectStarted::killerPlayer' has a wrong offset!");
static_assert(offsetof(K38Power_Cosmetic_OnRedirectStarted, dog) == 0x000008, "Member 'K38Power_Cosmetic_OnRedirectStarted::dog' has a wrong offset!");

// Function TheK38.K38Power.Cosmetic_OnSlipStreamChanged
// 0x000C (0x000C - 0x0000)
struct K38Power_Cosmetic_OnSlipStreamChanged final
{
public:
	float                                         lastSlipStreamPoints;                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         currentSlipStreamPoints;                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         maxSlipStreamPoints;                               // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38Power_Cosmetic_OnSlipStreamChanged) == 0x000004, "Wrong alignment on K38Power_Cosmetic_OnSlipStreamChanged");
static_assert(sizeof(K38Power_Cosmetic_OnSlipStreamChanged) == 0x00000C, "Wrong size on K38Power_Cosmetic_OnSlipStreamChanged");
static_assert(offsetof(K38Power_Cosmetic_OnSlipStreamChanged, lastSlipStreamPoints) == 0x000000, "Member 'K38Power_Cosmetic_OnSlipStreamChanged::lastSlipStreamPoints' has a wrong offset!");
static_assert(offsetof(K38Power_Cosmetic_OnSlipStreamChanged, currentSlipStreamPoints) == 0x000004, "Member 'K38Power_Cosmetic_OnSlipStreamChanged::currentSlipStreamPoints' has a wrong offset!");
static_assert(offsetof(K38Power_Cosmetic_OnSlipStreamChanged, maxSlipStreamPoints) == 0x000008, "Member 'K38Power_Cosmetic_OnSlipStreamChanged::maxSlipStreamPoints' has a wrong offset!");

// Function TheK38.K38Power.Cosmetic_OnSlipStreamPathFollowedChanged
// 0x0001 (0x0001 - 0x0000)
struct K38Power_Cosmetic_OnSlipStreamPathFollowedChanged final
{
public:
	bool                                          onPath;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38Power_Cosmetic_OnSlipStreamPathFollowedChanged) == 0x000001, "Wrong alignment on K38Power_Cosmetic_OnSlipStreamPathFollowedChanged");
static_assert(sizeof(K38Power_Cosmetic_OnSlipStreamPathFollowedChanged) == 0x000001, "Wrong size on K38Power_Cosmetic_OnSlipStreamPathFollowedChanged");
static_assert(offsetof(K38Power_Cosmetic_OnSlipStreamPathFollowedChanged, onPath) == 0x000000, "Member 'K38Power_Cosmetic_OnSlipStreamPathFollowedChanged::onPath' has a wrong offset!");

// Function TheK38.K38Power.Cosmetic_OnStartAimDashCharge
// 0x0010 (0x0010 - 0x0000)
struct K38Power_Cosmetic_OnStartAimDashCharge final
{
public:
	const class AKiller*                          killerPlayer;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AK38Dog*                          dog;                                               // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38Power_Cosmetic_OnStartAimDashCharge) == 0x000008, "Wrong alignment on K38Power_Cosmetic_OnStartAimDashCharge");
static_assert(sizeof(K38Power_Cosmetic_OnStartAimDashCharge) == 0x000010, "Wrong size on K38Power_Cosmetic_OnStartAimDashCharge");
static_assert(offsetof(K38Power_Cosmetic_OnStartAimDashCharge, killerPlayer) == 0x000000, "Member 'K38Power_Cosmetic_OnStartAimDashCharge::killerPlayer' has a wrong offset!");
static_assert(offsetof(K38Power_Cosmetic_OnStartAimDashCharge, dog) == 0x000008, "Member 'K38Power_Cosmetic_OnStartAimDashCharge::dog' has a wrong offset!");

// Function TheK38.K38Power.Cosmetic_OnStartAimPatrolCharge
// 0x0010 (0x0010 - 0x0000)
struct K38Power_Cosmetic_OnStartAimPatrolCharge final
{
public:
	const class AKiller*                          killerPlayer;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AK38Dog*                          dog;                                               // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38Power_Cosmetic_OnStartAimPatrolCharge) == 0x000008, "Wrong alignment on K38Power_Cosmetic_OnStartAimPatrolCharge");
static_assert(sizeof(K38Power_Cosmetic_OnStartAimPatrolCharge) == 0x000010, "Wrong size on K38Power_Cosmetic_OnStartAimPatrolCharge");
static_assert(offsetof(K38Power_Cosmetic_OnStartAimPatrolCharge, killerPlayer) == 0x000000, "Member 'K38Power_Cosmetic_OnStartAimPatrolCharge::killerPlayer' has a wrong offset!");
static_assert(offsetof(K38Power_Cosmetic_OnStartAimPatrolCharge, dog) == 0x000008, "Member 'K38Power_Cosmetic_OnStartAimPatrolCharge::dog' has a wrong offset!");

// Function TheK38.K38Power.Cosmetic_RedirectFadeToWhite
// 0x0010 (0x0010 - 0x0000)
struct K38Power_Cosmetic_RedirectFadeToWhite final
{
public:
	const class AKiller*                          killerPlayer;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K38Power_Cosmetic_RedirectFadeToWhite) == 0x000008, "Wrong alignment on K38Power_Cosmetic_RedirectFadeToWhite");
static_assert(sizeof(K38Power_Cosmetic_RedirectFadeToWhite) == 0x000010, "Wrong size on K38Power_Cosmetic_RedirectFadeToWhite");
static_assert(offsetof(K38Power_Cosmetic_RedirectFadeToWhite, killerPlayer) == 0x000000, "Member 'K38Power_Cosmetic_RedirectFadeToWhite::killerPlayer' has a wrong offset!");
static_assert(offsetof(K38Power_Cosmetic_RedirectFadeToWhite, Duration) == 0x000008, "Member 'K38Power_Cosmetic_RedirectFadeToWhite::Duration' has a wrong offset!");

// Function TheK38.K38Power.GetK38DogActor
// 0x0008 (0x0008 - 0x0000)
struct K38Power_GetK38DogActor final
{
public:
	class AK38Dog*                                ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38Power_GetK38DogActor) == 0x000008, "Wrong alignment on K38Power_GetK38DogActor");
static_assert(sizeof(K38Power_GetK38DogActor) == 0x000008, "Wrong size on K38Power_GetK38DogActor");
static_assert(offsetof(K38Power_GetK38DogActor, ReturnValue) == 0x000000, "Member 'K38Power_GetK38DogActor::ReturnValue' has a wrong offset!");

// Function TheK38.K38PowerAddon20.OnDogStateChanged
// 0x0018 (0x0018 - 0x0000)
struct K38PowerAddon20_OnDogStateChanged final
{
public:
	struct FGameplayTag                           oldState;                                          // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           newState;                                          // 0x000C(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38PowerAddon20_OnDogStateChanged) == 0x000004, "Wrong alignment on K38PowerAddon20_OnDogStateChanged");
static_assert(sizeof(K38PowerAddon20_OnDogStateChanged) == 0x000018, "Wrong size on K38PowerAddon20_OnDogStateChanged");
static_assert(offsetof(K38PowerAddon20_OnDogStateChanged, oldState) == 0x000000, "Member 'K38PowerAddon20_OnDogStateChanged::oldState' has a wrong offset!");
static_assert(offsetof(K38PowerAddon20_OnDogStateChanged, newState) == 0x00000C, "Member 'K38PowerAddon20_OnDogStateChanged::newState' has a wrong offset!");

// Function TheK38.K38PowerAddon20.OnPatrolPathFollowedChanged
// 0x0001 (0x0001 - 0x0000)
struct K38PowerAddon20_OnPatrolPathFollowedChanged final
{
public:
	bool                                          isOnPatrolPath;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38PowerAddon20_OnPatrolPathFollowedChanged) == 0x000001, "Wrong alignment on K38PowerAddon20_OnPatrolPathFollowedChanged");
static_assert(sizeof(K38PowerAddon20_OnPatrolPathFollowedChanged) == 0x000001, "Wrong size on K38PowerAddon20_OnPatrolPathFollowedChanged");
static_assert(offsetof(K38PowerAddon20_OnPatrolPathFollowedChanged, isOnPatrolPath) == 0x000000, "Member 'K38PowerAddon20_OnPatrolPathFollowedChanged::isOnPatrolPath' has a wrong offset!");

// Function TheK38.K38SurvivorCosmeticHelperActor.Cosmetic_OnDetectedStatusEffectActiveChanged
// 0x0001 (0x0001 - 0x0000)
struct K38SurvivorCosmeticHelperActor_Cosmetic_OnDetectedStatusEffectActiveChanged final
{
public:
	bool                                          IsActive;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38SurvivorCosmeticHelperActor_Cosmetic_OnDetectedStatusEffectActiveChanged) == 0x000001, "Wrong alignment on K38SurvivorCosmeticHelperActor_Cosmetic_OnDetectedStatusEffectActiveChanged");
static_assert(sizeof(K38SurvivorCosmeticHelperActor_Cosmetic_OnDetectedStatusEffectActiveChanged) == 0x000001, "Wrong size on K38SurvivorCosmeticHelperActor_Cosmetic_OnDetectedStatusEffectActiveChanged");
static_assert(offsetof(K38SurvivorCosmeticHelperActor_Cosmetic_OnDetectedStatusEffectActiveChanged, IsActive) == 0x000000, "Member 'K38SurvivorCosmeticHelperActor_Cosmetic_OnDetectedStatusEffectActiveChanged::IsActive' has a wrong offset!");

// Function TheK38.K38SurvivorHeldByDogComponent.Cosmetic_OnStruggleEnded
// 0x0008 (0x0008 - 0x0000)
struct K38SurvivorHeldByDogComponent_Cosmetic_OnStruggleEnded final
{
public:
	class AK38Dog*                                previouslyAttachedDog;                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38SurvivorHeldByDogComponent_Cosmetic_OnStruggleEnded) == 0x000008, "Wrong alignment on K38SurvivorHeldByDogComponent_Cosmetic_OnStruggleEnded");
static_assert(sizeof(K38SurvivorHeldByDogComponent_Cosmetic_OnStruggleEnded) == 0x000008, "Wrong size on K38SurvivorHeldByDogComponent_Cosmetic_OnStruggleEnded");
static_assert(offsetof(K38SurvivorHeldByDogComponent_Cosmetic_OnStruggleEnded, previouslyAttachedDog) == 0x000000, "Member 'K38SurvivorHeldByDogComponent_Cosmetic_OnStruggleEnded::previouslyAttachedDog' has a wrong offset!");

// Function TheK38.K38SurvivorHeldByDogComponent.OnRep_AudioIsFightingBack
// 0x0001 (0x0001 - 0x0000)
struct K38SurvivorHeldByDogComponent_OnRep_AudioIsFightingBack final
{
public:
	bool                                          OldValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38SurvivorHeldByDogComponent_OnRep_AudioIsFightingBack) == 0x000001, "Wrong alignment on K38SurvivorHeldByDogComponent_OnRep_AudioIsFightingBack");
static_assert(sizeof(K38SurvivorHeldByDogComponent_OnRep_AudioIsFightingBack) == 0x000001, "Wrong size on K38SurvivorHeldByDogComponent_OnRep_AudioIsFightingBack");
static_assert(offsetof(K38SurvivorHeldByDogComponent_OnRep_AudioIsFightingBack, OldValue) == 0x000000, "Member 'K38SurvivorHeldByDogComponent_OnRep_AudioIsFightingBack::OldValue' has a wrong offset!");

// Function TheK38.K38SurvivorHeldByDogComponent.OnRep_AudioIsPulling
// 0x0001 (0x0001 - 0x0000)
struct K38SurvivorHeldByDogComponent_OnRep_AudioIsPulling final
{
public:
	bool                                          OldValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38SurvivorHeldByDogComponent_OnRep_AudioIsPulling) == 0x000001, "Wrong alignment on K38SurvivorHeldByDogComponent_OnRep_AudioIsPulling");
static_assert(sizeof(K38SurvivorHeldByDogComponent_OnRep_AudioIsPulling) == 0x000001, "Wrong size on K38SurvivorHeldByDogComponent_OnRep_AudioIsPulling");
static_assert(offsetof(K38SurvivorHeldByDogComponent_OnRep_AudioIsPulling, OldValue) == 0x000000, "Member 'K38SurvivorHeldByDogComponent_OnRep_AudioIsPulling::OldValue' has a wrong offset!");

// Function TheK38.K38SurvivorHeldByDogComponent.OnRep_DogHoldingSurvivor
// 0x0008 (0x0008 - 0x0000)
struct K38SurvivorHeldByDogComponent_OnRep_DogHoldingSurvivor final
{
public:
	class AK38Dog*                                OldValue;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38SurvivorHeldByDogComponent_OnRep_DogHoldingSurvivor) == 0x000008, "Wrong alignment on K38SurvivorHeldByDogComponent_OnRep_DogHoldingSurvivor");
static_assert(sizeof(K38SurvivorHeldByDogComponent_OnRep_DogHoldingSurvivor) == 0x000008, "Wrong size on K38SurvivorHeldByDogComponent_OnRep_DogHoldingSurvivor");
static_assert(offsetof(K38SurvivorHeldByDogComponent_OnRep_DogHoldingSurvivor, OldValue) == 0x000000, "Member 'K38SurvivorHeldByDogComponent_OnRep_DogHoldingSurvivor::OldValue' has a wrong offset!");

// Function TheK38.K38SurvivorHeldByDogComponent.Server_SetFightingBack
// 0x0001 (0x0001 - 0x0000)
struct K38SurvivorHeldByDogComponent_Server_SetFightingBack final
{
public:
	bool                                          isFightingBack;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38SurvivorHeldByDogComponent_Server_SetFightingBack) == 0x000001, "Wrong alignment on K38SurvivorHeldByDogComponent_Server_SetFightingBack");
static_assert(sizeof(K38SurvivorHeldByDogComponent_Server_SetFightingBack) == 0x000001, "Wrong size on K38SurvivorHeldByDogComponent_Server_SetFightingBack");
static_assert(offsetof(K38SurvivorHeldByDogComponent_Server_SetFightingBack, isFightingBack) == 0x000000, "Member 'K38SurvivorHeldByDogComponent_Server_SetFightingBack::isFightingBack' has a wrong offset!");

// Function TheK38.K38SurvivorHeldByDogComponent.GetDogHoldingSurvivor
// 0x0008 (0x0008 - 0x0000)
struct K38SurvivorHeldByDogComponent_GetDogHoldingSurvivor final
{
public:
	class AK38Dog*                                ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38SurvivorHeldByDogComponent_GetDogHoldingSurvivor) == 0x000008, "Wrong alignment on K38SurvivorHeldByDogComponent_GetDogHoldingSurvivor");
static_assert(sizeof(K38SurvivorHeldByDogComponent_GetDogHoldingSurvivor) == 0x000008, "Wrong size on K38SurvivorHeldByDogComponent_GetDogHoldingSurvivor");
static_assert(offsetof(K38SurvivorHeldByDogComponent_GetDogHoldingSurvivor, ReturnValue) == 0x000000, "Member 'K38SurvivorHeldByDogComponent_GetDogHoldingSurvivor::ReturnValue' has a wrong offset!");

// Function TheK38.K38SurvivorHeldByDogComponent.GetSurvivor
// 0x0008 (0x0008 - 0x0000)
struct K38SurvivorHeldByDogComponent_GetSurvivor final
{
public:
	class ASurvivor*                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38SurvivorHeldByDogComponent_GetSurvivor) == 0x000008, "Wrong alignment on K38SurvivorHeldByDogComponent_GetSurvivor");
static_assert(sizeof(K38SurvivorHeldByDogComponent_GetSurvivor) == 0x000008, "Wrong size on K38SurvivorHeldByDogComponent_GetSurvivor");
static_assert(offsetof(K38SurvivorHeldByDogComponent_GetSurvivor, ReturnValue) == 0x000000, "Member 'K38SurvivorHeldByDogComponent_GetSurvivor::ReturnValue' has a wrong offset!");

// Function TheK38.K38SurvivorStatusComponent.Cosmetic_OnK38DetectionKillerEffectEnd
// 0x0008 (0x0008 - 0x0000)
struct K38SurvivorStatusComponent_Cosmetic_OnK38DetectionKillerEffectEnd final
{
public:
	class ASurvivor*                              Survivor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38SurvivorStatusComponent_Cosmetic_OnK38DetectionKillerEffectEnd) == 0x000008, "Wrong alignment on K38SurvivorStatusComponent_Cosmetic_OnK38DetectionKillerEffectEnd");
static_assert(sizeof(K38SurvivorStatusComponent_Cosmetic_OnK38DetectionKillerEffectEnd) == 0x000008, "Wrong size on K38SurvivorStatusComponent_Cosmetic_OnK38DetectionKillerEffectEnd");
static_assert(offsetof(K38SurvivorStatusComponent_Cosmetic_OnK38DetectionKillerEffectEnd, Survivor) == 0x000000, "Member 'K38SurvivorStatusComponent_Cosmetic_OnK38DetectionKillerEffectEnd::Survivor' has a wrong offset!");

// Function TheK38.K38SurvivorStatusComponent.Cosmetic_OnK38DetectionKillerEffectStart
// 0x0008 (0x0008 - 0x0000)
struct K38SurvivorStatusComponent_Cosmetic_OnK38DetectionKillerEffectStart final
{
public:
	class ASurvivor*                              Survivor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38SurvivorStatusComponent_Cosmetic_OnK38DetectionKillerEffectStart) == 0x000008, "Wrong alignment on K38SurvivorStatusComponent_Cosmetic_OnK38DetectionKillerEffectStart");
static_assert(sizeof(K38SurvivorStatusComponent_Cosmetic_OnK38DetectionKillerEffectStart) == 0x000008, "Wrong size on K38SurvivorStatusComponent_Cosmetic_OnK38DetectionKillerEffectStart");
static_assert(offsetof(K38SurvivorStatusComponent_Cosmetic_OnK38DetectionKillerEffectStart, Survivor) == 0x000000, "Member 'K38SurvivorStatusComponent_Cosmetic_OnK38DetectionKillerEffectStart::Survivor' has a wrong offset!");

// Function TheK38.K38SurvivorStatusComponent.Multicast_ApplyKillerEffectToSurvivor
// 0x0018 (0x0018 - 0x0000)
struct K38SurvivorStatusComponent_Multicast_ApplyKillerEffectToSurvivor final
{
public:
	class AKiller*                                Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          applyEffect;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          keepCosmeticEffectActive;                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K38SurvivorStatusComponent_Multicast_ApplyKillerEffectToSurvivor) == 0x000008, "Wrong alignment on K38SurvivorStatusComponent_Multicast_ApplyKillerEffectToSurvivor");
static_assert(sizeof(K38SurvivorStatusComponent_Multicast_ApplyKillerEffectToSurvivor) == 0x000018, "Wrong size on K38SurvivorStatusComponent_Multicast_ApplyKillerEffectToSurvivor");
static_assert(offsetof(K38SurvivorStatusComponent_Multicast_ApplyKillerEffectToSurvivor, Killer) == 0x000000, "Member 'K38SurvivorStatusComponent_Multicast_ApplyKillerEffectToSurvivor::Killer' has a wrong offset!");
static_assert(offsetof(K38SurvivorStatusComponent_Multicast_ApplyKillerEffectToSurvivor, applyEffect) == 0x000008, "Member 'K38SurvivorStatusComponent_Multicast_ApplyKillerEffectToSurvivor::applyEffect' has a wrong offset!");
static_assert(offsetof(K38SurvivorStatusComponent_Multicast_ApplyKillerEffectToSurvivor, Duration) == 0x00000C, "Member 'K38SurvivorStatusComponent_Multicast_ApplyKillerEffectToSurvivor::Duration' has a wrong offset!");
static_assert(offsetof(K38SurvivorStatusComponent_Multicast_ApplyKillerEffectToSurvivor, keepCosmeticEffectActive) == 0x000010, "Member 'K38SurvivorStatusComponent_Multicast_ApplyKillerEffectToSurvivor::keepCosmeticEffectActive' has a wrong offset!");

// Function TheK38.K38VaultingDogState.Authority_OnBeginOverlap
// 0x0110 (0x0110 - 0x0000)
struct K38VaultingDogState_Authority_OnBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F0)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(K38VaultingDogState_Authority_OnBeginOverlap) == 0x000008, "Wrong alignment on K38VaultingDogState_Authority_OnBeginOverlap");
static_assert(sizeof(K38VaultingDogState_Authority_OnBeginOverlap) == 0x000110, "Wrong size on K38VaultingDogState_Authority_OnBeginOverlap");
static_assert(offsetof(K38VaultingDogState_Authority_OnBeginOverlap, OverlappedComponent) == 0x000000, "Member 'K38VaultingDogState_Authority_OnBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(K38VaultingDogState_Authority_OnBeginOverlap, OtherActor) == 0x000008, "Member 'K38VaultingDogState_Authority_OnBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(K38VaultingDogState_Authority_OnBeginOverlap, OtherComp) == 0x000010, "Member 'K38VaultingDogState_Authority_OnBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(K38VaultingDogState_Authority_OnBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'K38VaultingDogState_Authority_OnBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(K38VaultingDogState_Authority_OnBeginOverlap, bFromSweep) == 0x00001C, "Member 'K38VaultingDogState_Authority_OnBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(K38VaultingDogState_Authority_OnBeginOverlap, SweepResult) == 0x000020, "Member 'K38VaultingDogState_Authority_OnBeginOverlap::SweepResult' has a wrong offset!");

}

